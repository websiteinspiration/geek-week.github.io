<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤝 ♉️ 🛌🏾 Nombre maximal de valeurs dans la partie II de l'énumération 🎈 💾 👩🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Première partie, théorique  | Deuxième partie, pratique
 
 
 Nous continuons à rechercher le nombre maximum de valeurs possible dans l'énumération. 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nombre maximal de valeurs dans la partie II de l'énumération</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Première partie, théorique</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deuxième partie, pratique</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous continuons à rechercher le nombre maximum de valeurs possible dans l'énumération. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fois, nous nous concentrerons sur le côté pratique du problème et verrons comment l'IDE, le compilateur et la JVM réagiront à nos réalisations.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contenu</font></font></h1><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outils </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Méthode d'extraction </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dynamiques de fichiers de classe </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difficultés soudaines </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Futur brillant </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">Test </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dangereux </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour </font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac et les </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">performances des </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">commutateurs </font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion </font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ressources supplémentaires</font></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outils</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javac prend soin de nous: il </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supprime les caractères qu'il n'aime pas dans les identifiants</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et interdit d'en hériter </font></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, donc pour les expériences, nous avons besoin d'autres outils. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tester des</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hypothèses en utilisant </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">asmtools</font></a><font style="vertical-align: inherit;"> , l'assembleur et le désassembleur pour la JVM, et générer des fichiers de classe à l'échelle industrielle en utilisant la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la simplicité de la compréhension, l'essence de ce qui se passe sera dupliquée dans un pseudocode de type java.</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme point de départ, il est logique de prendre le meilleur résultat, réalisable sans astuces, avec l'aide d'un seul </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tout ici est simple - nous créons le fichier source avec l'énumération et ajouter des </font><font style="vertical-align: inherit;">éléments jusqu'à ce que javac refuse de compiler </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la malédiction « code trop grand ». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assez longtemps, depuis Java 1.7, ce nombre a été maintenu au niveau de 2_746 éléments. </font><font style="vertical-align: inherit;">Mais quelque part après Java 11, il y a eu des changements dans l'algorithme de stockage des valeurs dans le pool constant et le nombre maximum a diminué à 2_743. </font><font style="vertical-align: inherit;">Oui, oui, juste à cause du changement de l'ordre des éléments dans le pool de constantes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous concentrerons sur la meilleure des valeurs.</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extraire la méthode</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme l'un des facteurs limitants est lié à la taille du bytecode dans le bloc d'initialisation statique, nous allons essayer de rendre ce dernier aussi simple que possible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rappelez-vous à quoi cela ressemble sur l'exemple de l'énumération </font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de la première partie. </font><font style="vertical-align: inherit;">Les commentaires fournissent des instructions de montage appropriées.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">statique {}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première chose qui me vient à l'esprit est de placer la création et le remplissage du tableau </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une méthode distincte.</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En développant cette idée, la création d'instances d'éléments d'énumération peut être transférée à la même méthode:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déjà mieux, mais chaque capture d'un élément de tableau et l'incrément d'index qui en résulte coûtent 6 octets, ce qui est trop cher pour nous. </font><font style="vertical-align: inherit;">Mettez-les dans une méthode distincte.</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il </font><font style="vertical-align: inherit;">faut 11 octets pour </font><font style="vertical-align: inherit;">s'initialiser </font><font style="vertical-align: inherit;">et revenir du bloc d'initialisation statique </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et il reste 65_524 octets pour initialiser les champs. </font><font style="vertical-align: inherit;">L'initialisation de chaque champ nécessite 6 octets, ce qui nous permet de créer une énumération de 10_920 éléments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La croissance de près de quatre fois par rapport à javac doit certainement être célébrée par la génération de code! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code source du générateur: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Exemple de classe </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">générée</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constantes dynamiques de fichier de classe</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de se souvenir du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de ses mystérieuses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constantes dynamiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'essence de l'innovation en un mot: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
aux types déjà existants pris en charge par un pool de constantes, en a ajouté un autre </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Lors du chargement d'une classe, le type d'une telle constante est connu, mais sa valeur est inconnue. Le premier chargement d'une constante conduit à un appel à la méthode bootstrap spécifiée dans sa déclaration. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat de cette méthode devient une valeur constante. Il n'existe aucun moyen de modifier la valeur associée à une constante déjà initialisée. Ce qui est assez logique pour une constante.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez également pensé à Singleton, oubliez-le immédiatement. </font><font style="vertical-align: inherit;">La spécification souligne séparément qu'il n'y a aucune garantie de sécurité des threads dans ce cas, et la méthode d'initialisation en code multi-thread peut être appelée plusieurs fois. </font><font style="vertical-align: inherit;">Il est seulement garanti que dans le cas de plusieurs appels à la méthode bootstrap pour la même constante, la JVM lancera une pièce et sélectionnera l'une des valeurs calculées pour le rôle de la valeur constante, et les autres seront sacrifiées au garbage collector.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportementalement, une constante CONSTANT_Dynamic est résolue en exécutant sa méthode d'amorçage sur les paramètres suivants: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un objet Lookup local,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la chaîne représentant le composant de nom de la constante,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la classe représentant le type constant attendu, et</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tous les arguments d'amorçage restants.</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour charger des valeurs à partir du pool de constantes dans le bytecode, des commandes sont fournies </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ce qui nous intéresse est le premier - </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement aux autres, il ne peut charger des valeurs qu'à partir des 255 premiers emplacements du pool constant, mais il prend 1 octet de moins en bytecode. Tout cela nous permet d'économiser jusqu'à 255 octets et un </font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élément dans l'énumération. Cette fois, la croissance n'est pas si impressionnante, mais elle est toujours là. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armé de cette connaissance, commençons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le bloc d'initialisation statique, au lieu d'appels de méthode, </font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous allons maintenant charger la valeur de la constante dynamique. La valeur de l' </font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index ordinal de l'élément d'énumération sera passée explicitement, éliminant ainsi le champ </font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, la méthode d'usine</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et des doutes sur la sécurité des threads de notre implémentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme méthode d'amorçage, nous utiliserons un sous-type spécial de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui imite le comportement d'un opérateur </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Java. </font><font style="vertical-align: inherit;">La bibliothèque standard fournit une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthode MethodHandles.Lookup :: findConstructor ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour obtenir un tel </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">descripteur de</font></a><font style="vertical-align: inherit;"> méthode </font><font style="vertical-align: inherit;">, mais dans notre cas, la JVM se chargera de la construction du descripteur de méthode nécessaire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour utiliser le constructeur de notre énumération comme méthode d'amorçage, il devra être légèrement modifié en changeant la signature. </font><font style="vertical-align: inherit;">Les paramètres requis pour la méthode d'amorçage seront ajoutés au constructeur traditionnel de l'élément d'énumération de nom et du numéro de série:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sous forme de pseudo-code, l'initialisation ressemblera à ceci:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple ci-dessus, les instructions sont </font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">désignées comme des appels de méthode </font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dans le bytecode à leur place seront les instructions JVM correspondantes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque nous avons maintenant une constante distincte pour chaque élément de l'énumération, la création et le remplissage du tableau </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peuvent également être implémentés via une constante dynamique. </font><font style="vertical-align: inherit;">La méthode bootstrap est très simple:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute l'astuce dans la liste des paramètres statiques pour cette constante dynamique, là nous allons lister tous les éléments que nous voulons mettre </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootstrapMethods:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1: # 54 REF_invokeStatic FizzBuzz.createValues: (Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBuzz;) [LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    Arguments de la méthode:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 1 # 0: Fizz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 2 # 0: Buzz: LFizzBuzz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      # 3 # 0: FizzBuzz: LFizzBuzz;</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La JVM gâche le tableau à partir de ces paramètres statiques et le transmet à notre méthode d'amorçage en tant que paramètre vararg </font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le nombre maximum de paramètres statiques est traditionnel 65_535, il est donc garanti qu'il sera suffisant pour tous les éléments de l'énumération, quel que soit leur nombre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les transferts avec un grand nombre d'éléments, cette modification réduira la taille du fichier de classe résultant, et dans le cas où, en raison du grand nombre d'éléments, la méthode </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devait être divisée en plusieurs parties, elle enregistre également des emplacements dans le pool constant. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et au final, c'est tout simplement magnifique.</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Difficultés soudaines</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce que nous avons héroïquement surmonté en générant des classes manuellement. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les bibliothèques de haut niveau offrent une interface pratique en échange d'une certaine restriction de la liberté d'action. </font><font style="vertical-align: inherit;">La bibliothèque ASM que nous utilisons pour générer des fichiers de classe ne fait pas exception. </font><font style="vertical-align: inherit;">Il ne fournit pas de mécanismes pour contrôler directement le contenu du pool de constantes. </font><font style="vertical-align: inherit;">Ce n'est généralement pas très important, mais pas dans notre cas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous vous en souvenez, nous avons besoin des 255 premiers éléments du pool constant pour enregistrer de précieux octets dans le bloc d'initialisation statique. </font><font style="vertical-align: inherit;">Lorsque des constantes dynamiques sont ajoutées de manière standard, elles seront situées à des indices aléatoires et mélangées à d'autres éléments qui ne sont pas si critiques pour nous. </font><font style="vertical-align: inherit;">Cela nous empêchera d'atteindre le maximum.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment d'un ensemble de constantes formées de façon traditionnelle</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Piscine constante:</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   # 1 = Utf8 FizzBuzz</font></font><font></font>
   #2 = Class              #1             // FizzBuzz<font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, il existe une solution de contournement: lors de la création d'une classe, vous pouvez spécifier un exemple de classe à partir duquel un pool de constantes et un attribut avec une description des méthodes d'amorçage seront copiés. </font><font style="vertical-align: inherit;">Seulement maintenant, nous devons le générer manuellement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, ce n'est pas aussi difficile que cela puisse paraître à première vue. </font><font style="vertical-align: inherit;">Le format du fichier de classe est assez simple et sa génération manuelle est un processus quelque peu fastidieux, mais pas du tout compliqué. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La chose la plus importante ici est un plan clair. </font><font style="vertical-align: inherit;">Pour énumérer les </font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">éléments dont nous avons besoin:</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements de type </font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- nos constantes dynamiques</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements de type </font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- paires de liens vers le nom de l'élément d'énumération et son type. </font><font style="vertical-align: inherit;">Le type sera le même pour tout le monde, c'est le type de classe de notre énumération.</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements de type </font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- directement les noms des éléments d'énumération</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements de type </font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- numéros de série des éléments d'énumération transmis au constructeur comme valeur de paramètre</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noms des classes actuelles et de base, attributs, signatures de méthode et autres détails d'implémentation ennuyeux. </font><font style="vertical-align: inherit;">Les personnes intéressées peuvent consulter le code source du générateur.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a beaucoup d'éléments constitutifs dans le pool de constantes qui se réfèrent à d'autres éléments du pool par index, donc tous les indices dont nous avons besoin doivent être calculés à l'avance, </font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est une liste des noms des éléments de notre énumération:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après cela, nous commençons à écrire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début - la signature du fichier de classe, les quatre octets connus de tous </font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la version du format de fichier:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite - un pool de constantes:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool de constantes</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après la constante de la </font><font style="vertical-align: inherit;">piscine à </font><font style="vertical-align: inherit;">parler de modificateurs d'accès et des </font><font style="vertical-align: inherit;">drapeaux ( </font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, etc.), le nom de classe et son ancêtre:</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe factice que nous avons générée n'aura pas d'interfaces, pas de champs, pas de méthodes, mais il y aura un attribut avec une description des méthodes d'amorçage:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici le corps de l'attribut lui-même:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout, la classe est formée. </font><font style="vertical-align: inherit;">Nous prenons ces octets et créons à partir d'eux </font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'était pas si difficile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code source du générateur: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brillant avenir</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous nous éloignons brièvement de nos listes:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le bloc d'initialisation statique de cette classe, il n'y aura soudainement qu'une seule opération d'écriture, dans le champ </font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais qu'en est-il </font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'équipe va aider à faire la lumière sur cette énigme </font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, voici le fragment qui nous intéresse:</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur du champ final statique est passée du bloc d'initialisation à un attribut distinct </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Voici ce qu'ils écrivent sur cet attribut dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §4.7.2</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un attribut ConstantValue représente la valeur d'une expression constante (JLS §15.28) et est utilisé comme suit:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si l'indicateur ACC_STATIC dans l'élément access_flags de la structure field_info est défini, le champ représenté par la structure field_info se voit attribuer la valeur représentée par son attribut ConstantValue dans le cadre de l'initialisation de la classe ou de l'interface déclarant le champ (§5.5). </font><font style="vertical-align: inherit;">Cela se produit avant l'invocation de la méthode d'initialisation de classe ou d'interface de cette classe ou interface (§2.9.2).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinon, la machine virtuelle Java doit ignorer silencieusement l'attribut.</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si un tel attribut se produit en même temps </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(bien que ce dernier ne soit pas explicitement indiqué ici) dans un champ, ce champ est initialisé avec la valeur de cet attribut. </font><font style="vertical-align: inherit;">Et cela se produit avant même que la méthode d'initialisation statique soit appelée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il serait tentant d'utiliser cet attribut pour initialiser les éléments de l'énumération, dans notre chapitre avant-dernier, il n'y avait que des constantes, quoique dynamiques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous ne sommes pas les premiers à penser dans ce sens, il y a une mention dans JEP 309 </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Malheureusement, cette mention est dans le chapitre Travaux futurs:</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Travaux</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
futurs Les extensions futures possibles comprennent: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Attacher des constantes dynamiques à l'attribut ConstantValue des champs statiques</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En attendant, on ne peut que rêver des moments où cette fonctionnalité passera de l'état «bon à faire» à «prêt». </font><font style="vertical-align: inherit;">Ensuite, les restrictions sur la taille du code dans le bloc d'initialisation perdront leur influence et le nombre maximal d'éléments dans l'énumération déterminera les limitations du pool constant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selon des estimations approximatives, dans ce cas, nous pouvons espérer un </font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">élément. </font><font style="vertical-align: inherit;">Voici </font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le nombre d'emplacements inoccupés du pool constant, 46 des 65_535 théoriquement possibles sont allés au-dessus. </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- le nombre d'emplacements requis pour la déclaration d'un champ et la constante dynamique correspondante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le nombre exact, bien sûr, ne peut être trouvé qu'après la sortie de la version JDK avec prise en charge de cette fonctionnalité.</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Peu sûr</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre ennemi est la croissance linéaire du bloc d'initialisation avec une augmentation du nombre d'éléments d'énumération. </font><font style="vertical-align: inherit;">Si nous avions trouvé un moyen de limiter l'initialisation dans une boucle, supprimant ainsi la relation entre le nombre d'éléments dans l'énumération et la taille du bloc d'initialisation, nous ferions une autre percée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, aucune des API publiques standard ne permet d'écrire dans des </font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">champs même à l'intérieur d'un bloc d'initialisation statique. </font><font style="vertical-align: inherit;">Ni Reflection ni VarHandles n'aideront ici. </font><font style="vertical-align: inherit;">Notre seul espoir est grand et terrible </font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une exécution dangereuse de FizzBuzz pourrait ressembler à ceci:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FizzBuzz dangereux</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette approche nous permet de créer un dénombrement avec environ 21 mille éléments; de plus, la capacité du pool de constantes n'est pas suffisante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La documentation sur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enum :: ordinal ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> requiert que sa valeur corresponde au numéro de séquence de l'élément correspondant dans la déclaration d'énumération, vous devez donc stocker explicitement la liste des noms de champs dans le bon ordre, doublant ainsi presque la taille du fichier de classe.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal () </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retourne l'ordinal de cette constante d'énumération (sa position dans sa déclaration d'énumération, où la constante initiale se voit attribuer un ordinal de zéro).</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, l'API publique au contenu du pool de constantes pourrait aider, nous savons déjà comment la remplir dans l'ordre dont nous avons besoin, mais il n'y a pas une telle API et il est peu probable qu'elle le soit. La méthode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disponible dans OpenJDK est </font><font style="vertical-align: inherit;">déclarée comme package-private et il serait téméraire de s'y fier dans le code utilisateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le bloc d'initialisation est maintenant assez compact et presque indépendant du nombre d'éléments dans l'énumération, vous </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pouvez donc le refuser en incorporant son corps dans la boucle:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, un processus semblable à une avalanche se produit: avec la méthode </font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, les instructions de lecture des champs des éléments d'énumération disparaissent, les enregistrements de type </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour ces champs </font><font style="vertical-align: inherit;">deviennent inutiles </font><font style="vertical-align: inherit;">, et donc les </font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enregistrements de type pour les enregistrements de type </font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans le pool constant, des </font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">emplacements sont </font><font style="vertical-align: inherit;">libérés </font><font style="vertical-align: inherit;">qui peuvent être utilisés pour déclarer des éléments d'énumération supplémentaires. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais tout n'est pas si rose, les tests montrent une baisse significative des performances: l'initialisation d'une classe d'énumération avec 65 000 éléments prend impensable une minute et demie. Comme il s'est avéré assez rapidement, "le réflexe ralentit". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'implémentation de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans OpenJDK a un comportement asymptotique linéaire du nombre de champs dans la classe, et notre bloc d'initialisation est quadratique à cause de cela.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ajout de la mise en cache améliore quelque peu la situation, même si elle ne la résout pas complètement:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'approche dangereuse décrite dans ce chapitre vous permet de créer des transferts avec le nombre d'éléments jusqu'à 65_410, ce qui est presque 24 fois plus que le résultat atteignable avec javac et est assez proche de la limite théorique de 65_505 éléments que nous avons calculée dans la publication précédente du cycle.</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vérifier les performances</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les tests, nous prenons la plus grande énumération, en la générant à l'aide de la commande </font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. En conséquence, nous obtenons un fichier de classe de 2 mégaoctets et 65_410 éléments de taille. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créez un nouveau projet Java dans IDEA et ajoutez la classe générée en tant que bibliothèque externe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Presque immédiatement, il devient évident que IDEA n'est pas prêt pour un tel test de résistance: la </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
saisie automatique d'un élément de dénombrement prend des dizaines de secondes à la fois sur l'ancien mobile i5 et sur le plus moderne i7 8700K. Et si vous essayez d'utiliser la correction rapide pour ajouter les éléments manquants au commutateur, IDEA arrête même de redessiner les fenêtres. Je soupçonne cela temporairement, mais je n'ai pas attendu la fin. La réactivité lors du débogage laisse également beaucoup à désirer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par un petit nombre d'éléments dans </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a pas de surprise ici, la compilation et le lancement sont réguliers:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'en est-il de plus d'articles dans </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Pouvons-nous, par exemple, traiter </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tous nos 65 000 éléments </font><font style="vertical-align: inherit;">en une seule </font><font style="vertical-align: inherit;">fois?</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hélas non. </font><font style="vertical-align: inherit;">Lorsque nous essayons de compiler, nous obtenons tout un tas de messages d'erreur:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac et interrupteur</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour comprendre ce qui se passe, il faut comprendre comment se produit la traduction </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des éléments de l'énumération. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La spécification JVM comporte un chapitre distinct dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11 §3.10 Compilation Switches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dont les recommandations se résument à l' </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilisation de l'une des deux instructions de bytecode, </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous ne trouverons </font><font style="vertical-align: inherit;">aucune référence </font><font style="vertical-align: inherit;">à des chaînes ou à des éléments d'énumération dans ce chapitre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La meilleure documentation est le code, il est donc temps de plonger dans la source </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le choix entre </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se produit dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gen :: visitSwitch ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et dépend du nombre d'options dans </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dans la plupart des cas, gagne </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'en-tête </font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait environ 16 octets plus 4 octets par valeur. </font><font style="vertical-align: inherit;">Ainsi, </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en aucun cas il ne peut y avoir plus d' </font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">éléments. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En effet, après avoir réduit le nombre de branches </font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans le corps </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à 16 mille, il ne reste qu'une seule erreur de compilation, la plus mystérieuse:</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A la recherche de la source de l'erreur, nous reviendrons un peu plus tôt, au stade de l'élimination du sucre syntaxique. </font><font style="vertical-align: inherit;">Les </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">méthodes sont responsables de la </font><font style="vertical-align: inherit;">traduction </font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et la classe </font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lower.java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On y trouve également un petit commentaire documentaire:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnumMapping JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le mystérieux </font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fait partie d'une classe d'assistance générée automatiquement </font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Inside - une déclaration d'un tableau statique et du code pour l'initialiser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau corrige la correspondance entre les noms des éléments d'énumération et les </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeurs numériques </font><font style="vertical-align: inherit;">qui leur sont attribuées lors de la compilation </font><font style="vertical-align: inherit;">, protégeant ainsi le code compilé des effets néfastes de la refactorisation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la réorganisation, de l'ajout de nouveaux ou de la suppression d'éléments d'énumération existants, certains d'entre eux peuvent modifier la valeur </font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et c'est ce que protège un niveau d'indirection supplémentaire.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code d'initialisation est simple et consomme de 15 à 17 octets par élément. </font><font style="vertical-align: inherit;">En conséquence, le bloc d'initialisation statique prend en charge l'initialisation de pas plus de 3_862 éléments. </font><font style="vertical-align: inherit;">Ce nombre s'avère être le nombre maximal d'éléments d'énumération que nous pouvons utiliser en un </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec l'implémentation actuelle </font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons vu que l'utilisation d'une technique aussi simple que l'allocation de la création d'éléments d'énumération et l'initialisation d'un tableau </font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une méthode distincte vous permet d'augmenter le nombre maximal d'éléments dans une énumération de 2_746 à 10_920. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats dynamiques constants dans le contexte des réalisations précédentes ne semblent pas très impressionnants et vous permettent d'obtenir seulement 43 éléments de plus, mais avec cette approche, il est beaucoup plus élégant d'ajouter de nouvelles propriétés à l'énumération - il suffit de modifier le constructeur et de lui transmettre les valeurs nécessaires via les paramètres statiques de la constante dynamique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si quelque temps dans l'attribut futur </font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sera enseigné à comprendre les constantes dynamiques, ce nombre pourrait atteindre 10 mille à 16. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utilisation</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous permet de faire un bond de géant et d'augmenter le nombre maximum d'éléments à 65_410. Mais n'oubliez pas qu'il </font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s'agit d'une API propriétaire qui peut disparaître avec le temps et que son utilisation représente un risque considérable, comme le prévient directement javac:</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais, il s'est avéré qu'il ne suffit pas de générer un dénombrement géant, vous devez également pouvoir l'utiliser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Actuellement, il existe des problèmes avec la prise en charge de telles énumérations à la fois à partir de l'EDI et au niveau du compilateur Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un grand nombre de champs de la classe peuvent dégrader la réactivité de l'IDE à la fois lors de l'édition et du débogage. </font><font style="vertical-align: inherit;">Parfois jusqu'à un blocage complet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les restrictions imposées par le format de fichier de classe et les détails d'implémentation de javac rendent impossible l'utilisation de </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus de 3_862 éléments </font><font style="vertical-align: inherit;">dans le code </font><font style="vertical-align: inherit;">en même temps. </font><font style="vertical-align: inherit;">Parmi les aspects positifs, il convient de mentionner que ceux-ci peuvent être des éléments arbitraires 3_862. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une amélioration supplémentaire des résultats n'est possible que grâce au raffinement du compilateur Java, mais c'est une histoire complètement différente.</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matériaux additionnels</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code source GitHub: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Fichier JAR collecté: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aide au démarrage prise en charge</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501860/index.html">15 mai RU-Center peut vous ajouter un service payant sans votre participation</a></li>
<li><a href="../fr501862/index.html">Flotter sous le capot</a></li>
<li><a href="../fr501864/index.html">Assistant ou inspecteur: pour qui le robot appelle-t-il?</a></li>
<li><a href="../fr501866/index.html">Combien d'emplois les robots vont détruire</a></li>
<li><a href="../fr501868/index.html">Comment ne pas laisser le comptable se jeter ou On transfère 1C vers le cloud. Instruction étape par étape</a></li>
<li><a href="../fr501872/index.html">Lieu d'étude dans les systèmes cybernétiques</a></li>
<li><a href="../fr501874/index.html">Architectures frontales modernes (partie 2)</a></li>
<li><a href="../fr501880/index.html">À propos de la traduction de "débuts" et "débuts" sans début, début et premier</a></li>
<li><a href="../fr501882/index.html">Comment nous utilisons les algorithmes de vision par ordinateur: traitement vidéo dans un navigateur mobile utilisant OpenCV.js</a></li>
<li><a href="../fr501884/index.html">Comment les archives électroniques d'informations médicales aideront à diagnostiquer plus efficacement les maladies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>