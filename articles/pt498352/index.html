<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíí üñçÔ∏è üë®üèº‚Äçü§ù‚Äçüë®üèª SHISHUA: o gerador de n√∫meros pseudo-aleat√≥rios mais r√°pido do mundo üèûÔ∏è üñïüèæ üçñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seis meses atr√°s, eu queria criar o melhor gerador de n√∫meros pseudo-aleat√≥rios (PRNG) com alguma arquitetura incomum. Eu pensei que o come√ßo seria f√°...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: o gerador de n√∫meros pseudo-aleat√≥rios mais r√°pido do mundo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seis meses atr√°s, eu queria criar o melhor gerador de n√∫meros pseudo-aleat√≥rios (PRNG) com alguma arquitetura incomum. Eu pensei que o come√ßo seria f√°cil e, √† medida que voc√™ trabalha, a tarefa se torna lentamente mais complexa. E eu pensei que se eu pudesse aprender tudo r√°pido o suficiente para lidar com as mais dif√≠ceis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para minha surpresa, a complexidade n√£o aumentou linearmente. Teste de qui-quadrado byte provou ser muito dif√≠cil! Mais tarde, foi igualmente dif√≠cil passar em testes obstinados. Eu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publicou os resultados atuais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para entender o que outras dificuldades esperam por mim. No entanto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o teste do PractRand falhou naquele momento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o foi muito dif√≠cil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passar no teste BigCrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi muito dif√≠cil transferir 32 terabytes de dados ao passar o PractRand. </font><font style="vertical-align: inherit;">A velocidade se tornou um problema. </font><font style="vertical-align: inherit;">N√£o foi suficiente criar um design que gerasse dez megabytes por segundo, porque a aprova√ß√£o do PractRand levaria um m√™s. </font><font style="vertical-align: inherit;">Mas devo admitir que </font><font style="vertical-align: inherit;">foi muito dif√≠cil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passar neste teste a uma velocidade de gigabytes por segundo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando voc√™ chega a tal altura ... voc√™ quer saber se pode chegar √† fronteira de Pareto. </font><font style="vertical-align: inherit;">Voc√™ deseja criar o PRNG mais r√°pido do mundo, que passar√° nos testes estat√≠sticos mais complexos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu consegui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falei sobre o que aprendi para alcan√ßar meu objetivo. </font><font style="vertical-align: inherit;">E aqui vou lhe dizer como a arquitetura final funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetivo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar com o √≥bvio: a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade depende da plataforma</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu me concentrei na otimiza√ß√£o da arquitetura moderna x86-64 (processadores Intel e AMD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A m√©trica </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cl√°ssica √© usada para comparar o desempenho </font><font style="vertical-align: inherit;">: este √© o n√∫mero de ciclos do processador gastos na gera√ß√£o de um byte. </font><font style="vertical-align: inherit;">Essa m√©trica √© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculada e comparada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em todos os trabalhos criptogr√°ficos. </font><font style="vertical-align: inherit;">Uma cpb um pouco menor no mundo de software ou hardware pode garantir a vit√≥ria na competi√ß√£o ou o uso em sites em todo o mundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para melhorar o cpb, voc√™ pode:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gere mais bytes com a mesma quantidade de trabalho,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou fa√ßa menos trabalho para gerar o mesmo n√∫mero de bytes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou paralelizar o trabalho.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faremos tudo o que precede. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com o primeiro ponto, precisamos produzir mais bits a cada itera√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tinha medo de que eles me dissessem: ‚ÄúSe n√£o der n√∫meros de 32 bits, esse n√£o √© o PRSP‚Äù, ou o mesmo com n√∫meros de 64 bits. Ou: ‚ÄúO PRNG deve ser apenas para a arquitetura x86-64‚Äù, como se instru√ß√µes como POPCNT ou registros como% xmm7 fossem proibidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o PRNG √© de engenharia: os geradores v√™m tentando h√° v√°rias d√©cadas extrair todo o poss√≠vel dos processadores! Quando o ROL apareceu, eles come√ßaram a confiar nele. Com o advento dos processadores de 64 bits, eles come√ßaram a confiar no% rax. Obviamente, no ARM, esses algoritmos podem funcionar mais lentamente (embora isso ainda deva ser visto), no entanto, os PRNs de 64 bits foram usados ‚Äã‚Äãativamente mesmo antes do Android come√ßar a exigir suporte para 64 bits em 2019! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, esta √°rea est√° se desenvolvendo junto com o hardware. E hoje, os processadores Intel e AMD, devido ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j√° suportam opera√ß√µes de 256 bits. O RC4 produziu 1 byte, o drand48 pode produzir 4 bytes por vez, pcg64 - 8 bytes, e agora podemos gerar imediatamente 32 bytes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 bytes podem ser um n√∫mero de 64 bits, e a maioria das linguagens de programa√ß√£o possui tipos internos para isso. </font><font style="vertical-align: inherit;">Mas poucos idiomas fornecem tipos para 16 bytes (uma exce√ß√£o not√°vel √© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em C). </font><font style="vertical-align: inherit;">Menos idiomas ainda t√™m tipo para 32 bytes (exceto interno). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, podemos dizer adeus ao prot√≥tipo usual da fun√ß√£o PRNG (exemplo do benchmark Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez disso, voc√™ pode criar um gerador que preencha o buffer (exemplo do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meu benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais s√£o as desvantagens desta solu√ß√£o? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o seu gerador produzir 32 bytes de cada vez, voc√™ precisar√° que o consumidor forne√ßa uma matriz com um m√∫ltiplo de 32 (idealmente alinhado a 32 bytes). </font><font style="vertical-align: inherit;">Embora voc√™ possa ficar sem ele, preencheremos o buffer. </font><font style="vertical-align: inherit;">Removeremos os dados n√£o utilizados e os preencheremos novamente conforme necess√°rio. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O atraso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se torna imprevis√≠vel: algumas chamadas apenas ler√£o o buffer. </font><font style="vertical-align: inherit;">Mas, em m√©dia, tudo ser√° o mesmo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora geramos mais bytes, fazendo a mesma quantidade de trabalho. </font><font style="vertical-align: inherit;">Como n√≥s a paralelizamos?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelismo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os processadores oferecem um incr√≠vel conjunto de ferramentas de paraleliza√ß√£o em todos os n√≠veis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, estas s√£o as instru√ß√µes SIMD (instru√ß√£o √∫nica, dados m√∫ltiplos). Por exemplo, o AVX2 executa simultaneamente quatro adi√ß√µes de 64 bits ou oito de 32 bits, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â usado em criptografia h√° cerca de quinze anos. A </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simultaneidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proporcionou o incr√≠vel desempenho do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">ChaCha20</font></a><font style="vertical-align: inherit;"> . √â usado pelas primitivas mais importantes que n√£o usam AESNI. Por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli s√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projetados com o paralelismo em mente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, o interesse neste t√≥pico tamb√©m aumentou na comunidade PRNG n√£o criptogr√°fica. Em particular, as primitivas existentes que n√£o foram projetadas para SIMD podem ser a base para a cria√ß√£o de PRNs muito r√°pidos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando Sebastiano Vigna promoveu sua arquitetura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na biblioteca padr√£o Julia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele descobriu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que os resultados de oito inst√¢ncias PRNG competitivas e diferentemente inicializadas podem ser concatenadas muito rapidamente se cada opera√ß√£o for executada simultaneamente em todas as PRNRs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD √© apenas um dos n√≠veis de paraleliza√ß√£o no processador. Eu recomendo a leitura do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior sobre este t√≥pico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ter uma id√©ia melhor, mas darei algumas explica√ß√µes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os pipelines do processador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permitem que v√°rias instru√ß√µes sejam processadas em diferentes est√°gios. Se a ordem de execu√ß√£o for bem organizada para reduzir as depend√™ncias entre os est√°gios, o processamento das instru√ß√µes poder√° ser acelerado.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A execu√ß√£o superescalar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite processar simultaneamente as partes computacionais das instru√ß√µes. </font><font style="vertical-align: inherit;">Mas para isso, eles n√£o devem ter depend√™ncias de leitura e grava√ß√£o. </font><font style="vertical-align: inherit;">Voc√™ pode adaptar a arquitetura para reduzir o risco de tempo de inatividade gravando muito antes da leitura. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A execu√ß√£o extraordin√°ria</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite que o processador execute instru√ß√µes n√£o na ordem da sequ√™ncia, mas como est√£o prontas, mesmo que as instru√ß√µes anteriores ainda n√£o estejam prontas. </font><font style="vertical-align: inherit;">Mas, para isso, n√£o deve haver depend√™ncia de leitura e grava√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora passamos √† implementa√ß√£o!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitetura</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um esquema chamado semi-SHISHUA. </font><font style="vertical-align: inherit;">A origem do nome se tornar√° gradualmente aparente enquanto voc√™ l√™. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O esquema √© assim:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere sua linha por linha.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O estado √© dividido em duas partes, que s√£o colocadas no registro AVX2 (256 bits). Para aumentar a velocidade, mantemos o resultado pr√≥ximo ao pr√≥prio estado, mas ele n√£o faz parte do estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m temos um contador de 64 bits. Para simplificar o c√°lculo, tamb√©m √© um registro AVX2. O fato √© que o AVX2 possui um pequeno recurso: os registros comuns (% rax e similares) n√£o podem ser transferidos diretamente para o SIMD via MOV, eles devem passar pela RAM (geralmente pela pilha), o que aumenta o atraso e custa duas instru√ß√µes do processador (MOV na pilha, VMOV da pilha). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos olhar para a gera√ß√£o. Vamos come√ßar carregando, depois percorrer o buffer e preench√™-lo com 32 bytes a cada itera√ß√£o.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // ‚Ä¶<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a fun√ß√£o est√° em linha, o preenchimento imediato do buffer na inicializa√ß√£o permite que o processador execute imediatamente as instru√ß√µes, dependendo disso, por meio de um mecanismo de execu√ß√£o extraordin√°rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro do loop, executamos rapidamente tr√™s opera√ß√µes de estado:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da√≠ o nome SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeira marcha</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, o AVX2 n√£o suporta rota√ß√µes. </font><font style="vertical-align: inherit;">Mas eu quero misturar os bits de uma posi√ß√£o em um n√∫mero de 64 bits com os bits de outra posi√ß√£o! </font><font style="vertical-align: inherit;">E a mudan√ßa √© a melhor maneira de perceber isso. </font><font style="vertical-align: inherit;">Mudaremos para um n√∫mero √≠mpar, para que cada bit visite todas as posi√ß√µes de 64 bits, e n√£o metade delas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante o turno, os bits s√£o perdidos, o que leva √† remo√ß√£o de informa√ß√µes do nosso estado. </font><font style="vertical-align: inherit;">Isso √© ruim, voc√™ precisa minimizar as perdas. </font><font style="vertical-align: inherit;">Os menores n√∫meros √≠mpares s√£o 1 e 3, usaremos diferentes valores de deslocamento para aumentar a discrep√¢ncia entre as duas partes. </font><font style="vertical-align: inherit;">Isso ajudar√° a reduzir a semelhan√ßa de sua auto-correla√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mudaremos para a direita, porque os bits mais √† direita t√™m a menor difus√£o durante a adi√ß√£o: por exemplo, o bit menos significativo em A + B √© apenas o XOR dos bits mais baixos A e B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agita√ß√£o</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos a mistura de 32 bits, porque fornece uma granularidade diferente em compara√ß√£o √†s opera√ß√µes de 64 bits que usamos em qualquer lugar (o alinhamento de 64 bits √© violado). Tamb√©m pode ser uma opera√ß√£o de faixa cruzada: outros shuffles podem mover bits dentro dos 128 bits esquerdos se come√ßarem √† esquerda, ou dentro dos 128 bits direitos se come√ßarem √† direita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Constantes de mistura:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que a mistura realmente melhore o resultado, moveremos as partes fracas (baixa dispers√£o) de 32 bits das adi√ß√µes de 64 bits para posi√ß√µes fortes, de modo que as pr√≥ximas adi√ß√µes as enriquecem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parte inferior de 32 bits do bloco de 64 bits nunca se move para o mesmo bloco de 64 bits da parte de alta ordem. </font><font style="vertical-align: inherit;">Assim, ambas as partes n√£o permanecem no mesmo peda√ßo, o que melhora a mistura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, cada parte de 32 bits passa por todas as posi√ß√µes em um c√≠rculo: de A a B, de B a C, ... de H a A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ deve ter notado que a mistura mais simples que leva em conta todos esses requisitos s√£o dois de 256 bits rotatividade (rota√ß√µes de 96 bits e 160 bits para a direita, respectivamente).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adi√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos adicionar peda√ßos de 64 bits de duas vari√°veis ‚Äã‚Äãtempor√°rias - shift e mixagem.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A adi√ß√£o √© a principal fonte de dispers√£o: nesta opera√ß√£o, os bits s√£o combinados em combina√ß√µes irredut√≠veis de express√µes XOR e AND distribu√≠das em posi√ß√µes de 64 bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armazenar o resultado da adi√ß√£o dentro de um estado preserva permanentemente essa dispers√£o.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fun√ß√£o de sa√≠da</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De onde obtemos a sa√≠da? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â simples: a estrutura que criamos nos permite gerar duas partes independentes do estado s0 e s1, que n√£o se afetam de forma alguma. </font><font style="vertical-align: inherit;">Aplique o XOR a eles e obtenha um resultado completamente aleat√≥rio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fortalecer a independ√™ncia entre os dados aos quais aplicamos o XOR, obtemos um resultado parcial: a parte deslocada de um estado e a parte mista de outro.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© semelhante √† redu√ß√£o das depend√™ncias de leitura e grava√ß√£o entre instru√ß√µes em um processador superescalar, como se u0 e t1 estivessem prontos para ler para s0 e s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora discuta o balc√£o. N√≥s a processamos no in√≠cio do ciclo. Primeiro, altere o estado e aumente o valor do contador:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que primeiro alteramos o estado e atualizamos o contador? s1 se torna dispon√≠vel anteriormente, isso reduz a probabilidade de que as instru√ß√µes subsequentes que a leem parem no pipeline do processador. Al√©m disso, essa sequ√™ncia ajuda a evitar a depend√™ncia direta do contador de leitura e grava√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicamos o contador a s1, e n√£o a s0, porque ambos afetam a sa√≠da de qualquer maneira; no entanto, s1 perde mais bits devido √† mudan√ßa, de modo que ajuda a "se levantar" ap√≥s a mudan√ßa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O contador pode n√£o gravar o teste do PractRand. Seu √∫nico objetivo √© estabelecer um limite inferior de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes = 512 exbibytes para o per√≠odo PRNG: come√ßamos a repetir o ciclo somente ap√≥s um mil√™nio de trabalho a uma velocidade de 10 gibytes por segundo. √â improv√°vel que seja muito lento para uso pr√°tico nos pr√≥ximos s√©culos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incremento:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os n√∫meros √≠mpares s√£o escolhidos como incrementos, porque apenas os n√∫meros b√°sicos do coprime cobrem todo o ciclo do campo finito GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), e todos os n√∫meros √≠mpares s√£o coprime para 2. Em outras palavras, se voc√™ incrementar por um n√∫mero inteiro par no intervalo de 0 a 4, retornando a 0 ap√≥s 4, ocorre a sequ√™ncia 0-2-0-2- ..., que nunca levar√° a 1 ou 3. E o incremento √≠mpar passa por todos os n√∫meros inteiros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos os n√∫meros de 64 bits no estado, usaremos n√∫meros √≠mpares diferentes, que os separar√£o ainda mais e aumentar√£o ligeiramente a mistura. </font><font style="vertical-align: inherit;">Eu escolhi os menores n√∫meros √≠mpares para que eles n√£o pare√ßam m√°gicos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â assim que as fun√ß√µes de transi√ß√£o e sa√≠da de estado funcionam. </font><font style="vertical-align: inherit;">Como inicializ√°-los?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicializa√ß√£o</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializamos o estado usando os d√≠gitos hexadecimais Œ¶, o n√∫mero irracional que √© menos aproximado pela fra√ß√£o.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pegue uma semente de 256 bits. </font><font style="vertical-align: inherit;">Isso geralmente √© feito em criptografia e n√£o prejudica o trabalho de PRNGs n√£o criptogr√°ficos:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // ‚Ä¶<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o queremos redefinir toda a parte do estado (s0 ou s1) com esse n√∫mero inicial, precisamos apenas afetar a metade. </font><font style="vertical-align: inherit;">Dessa forma, evitaremos o uso de n√∫meros iniciais atenuantes, que acidental ou intencionalmente originam um estado inicial fraco conhecido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como n√£o alteramos metade de cada estado, mantemos o controle sobre 128 bits de status. </font><font style="vertical-align: inherit;">Essa entropia √© suficiente para iniciar e manter uma posi√ß√£o forte.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, repetimos ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">v√°rias vezes a </font><font style="vertical-align: inherit;">seguinte sequ√™ncia:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execute as etapas ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) das itera√ß√µes SHISHUA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribu√≠mos uma parte do estado a outro estado e a outra parte √† sa√≠da.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atribuir um resultado de sa√≠da aumenta a dispers√£o do estado. </font><font style="vertical-align: inherit;">Durante a inicializa√ß√£o, o trabalho adicional e a correla√ß√£o de estados n√£o importam, porque essa s√©rie de opera√ß√µes √© executada uma vez. </font><font style="vertical-align: inherit;">Estamos interessados ‚Äã‚Äãapenas na dispers√£o durante a inicializa√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de avaliar o efeito na correla√ß√£o dos valores iniciais, escolhi </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">para o </font><font style="vertical-align: inherit;">valor e </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">10. Calculei a correla√ß√£o calculando as anomalias ‚Äúincomuns‚Äù e ‚Äúsuspeitas‚Äù decorrentes da ferramenta de controle de qualidade PRNG no PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atua√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â dif√≠cil medir a velocidade por v√°rios motivos:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medi√ß√£o do rel√≥gio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode n√£o ser precisa o suficiente.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu uso a instru√ß√£o do processador RDTSC, que calcula o n√∫mero de ciclos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que qualquer um possa reproduzir meus resultados, eu uso uma m√°quina virtual baseada em nuvem. Isso n√£o altera o n√≠vel dos resultados de benchmark em compara√ß√£o com os testes locais. Al√©m disso, voc√™ n√£o precisa comprar o mesmo computador que o meu. Por fim, h√° muitas situa√ß√µes em que o PRNG √© lan√ßado nas nuvens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escolhi o Google Cloud Platform N2 (processador Intel) e N2D (processador AMD). A vantagem do GCP √© que eles oferecem servidores com processadores de ambos os fabricantes. Neste artigo, focaremos na Intel, mas para a AMD os resultados ser√£o na mesma ordem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aprofundar o assunto, primeiro vamos nos livrar do antigo gerador criptogr√°fico RC4. Incapaz de paralelizar o trabalho, consegui</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ciclos por byte gerado). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos executar um MCG muito popular e r√°pido: o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128 PRNG mais simples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que passa no teste BigCrush, mostrou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Uau, √≥timo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, executaremos o desenvolvimento mais recente, usado para tabelas de hash r√°pidas - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um pouco melhor! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns PRSPs n√£o passam no teste PractRand de 32 terabytes, mas funcionam muito rapidamente. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atingiu apenas 512 mebibytes, mas mostrou uma velocidade muito alta: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro desenvolvimento recente do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ela afirma ser o PRNG mais r√°pido do mundo - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, √© o suficiente. </font><font style="vertical-align: inherit;">O que mostrou semi-SHISHUA? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Duas vezes mais r√°pido que o RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legal. </font><font style="vertical-align: inherit;">Agora teste o gerador criptogr√°fico ChaCha8. </font><font style="vertical-align: inherit;">Ele atingiu ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD √© verdadeira magia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para a comunidade criptogr√°fica, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso n√£o foi uma surpresa especial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 √© extremamente f√°cil de paralelizar. </font><font style="vertical-align: inherit;">Este √© apenas um contador bem-hash em um estado difuso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E lembre-se de como a equipe de idiomas da Julia tentou combinar v√°rias inst√¢ncias da arquitetura de Vigny para criar um PRNG r√°pido baseado em SIMD? </font><font style="vertical-align: inherit;">Vejamos o resultado deles usando esta t√©cnica ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 peda√ßos de Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tecnicamente, meu laptop pode afetar os resultados. N√£o sei por que o desenvolvimento da equipe de Julia √© mais r√°pido que o ChaCha8 no GCP, mas mais lento quando testado localmente. Na minha m√°quina, o semi-SHISHUA roda mais r√°pido que o desenvolvimento da equipe Julia, mas mais lento que o ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â necess√°rio derrotar todos os concorrentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ provavelmente j√° est√° se perguntando por que chamamos a vers√£o anterior do gerador semi-SHISHUA? Porque acabou sendo f√°cil dobrar a velocidade se voc√™ executar duas c√≥pias do semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semelhante √† id√©ia do comando Julia, inicializamos separadamente dois PRNGs (quatro blocos de um estado de 256 bits), fornecendo alternadamente a sa√≠da de seu trabalho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas se criarmos mais estados, podemos produzir ainda mais dados, combinando quatro estados em pares:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o n√≥s adquirimos o SHISHUA, que mostrou uma velocidade de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso √© duas vezes mais r√°pido que o concorrente mais r√°pido do mundo, que passou no teste PractRand de 32 terabytes. </font><font style="vertical-align: inherit;">O resultado est√° no gr√°fico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acredito que o desenvolvimento acabou sendo competitivo. </font><font style="vertical-align: inherit;">Funciona ainda mais r√°pido no meu laptop - 0,03 cpb, mas seguirei meus princ√≠pios em rela√ß√£o ao benchmark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que por mais algumas semanas meu gerador fique no p√≥dio dos mais r√°pidos do mundo (por favor, fa√ßa isso).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gerador passa honestamente no BigCrush e no teste PractRand de 32 terabytes. E tudo gra√ßas a quatro fluxos de sa√≠da. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As desvantagens da arquitetura incluem sua </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreversibilidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso pode ser visto reduzindo-se para um estado de 4 bits com </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Com uma mudan√ßa, obtemos </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e com agita√ß√£o, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Novos </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguais </font></font><code>[b, c] + [0, a] = [b‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguais </font></font><code>[d, a] + [0, c] = [d‚äï(a‚àßc), a‚äïc]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se </font></font><code>a = ¬¨c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ent√£o, </font></font><code>a‚äïc = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>a‚àßc = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ou seja, temos duas combina√ß√µes de </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nos d√£o o mesmo estado final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, isso n√£o √© um problema, porque o contador de 64 bits tamb√©m faz parte do estado. Acontece que o ciclo m√≠nimo de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes (128 bytes por transi√ß√£o de estado), a uma velocidade de 10 gibytes / s. </font><font style="vertical-align: inherit;">durar√° sete mil anos. </font><font style="vertical-align: inherit;">Isso equilibra os estados perdidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, apesar da irreversibilidade, o per√≠odo m√©dio de transi√ß√£o entre estados √© de 2 ^ ((256 + 1) √∑ 2). </font><font style="vertical-align: inherit;">Isso fornece um ciclo m√©dio de </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes (a uma velocidade de 10 gibytes / s. Durar√° mais de um trilh√£o de vezes mais do que o universo existe). </font><font style="vertical-align: inherit;">Embora eu acredite que os ciclos m√©dios estejam superestimados, porque eles n√£o nos dizem nada sobre a qualidade do gerador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√£o os resultados do benchmark:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerador</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atua√ß√£o</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correla√ß√£o de sementes</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o n√∫mero de ciclos do processador gastos em um byte gerado. </font><font style="vertical-align: inherit;">Recebido nas m√°quinas em nuvem N2 GCP e N2D (AMD), o pedido √© o mesmo.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o n√≠vel em que o gerador falha no teste do PractRand. </font><font style="vertical-align: inherit;">Se n√£o falhar, h√° um sinal&gt;. </font><font style="vertical-align: inherit;">Se o resultado n√£o for comprovado, h√° um ponto de interroga√ß√£o.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correla√ß√£o de n√∫meros de sementes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : travessia PractRand com bytes alternados de oito fluxos com n√∫meros de sementes 0, 1, 2, 4, 8, 16, 32, 64. Usamos o PractRand com convolu√ß√£o dupla e testes avan√ßados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais longe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora no nosso caso n√£o haja problemas com a irreversibilidade, ainda podemos melhorar o SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha opini√£o, o PRNG ideal tem as seguintes propriedades:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    ¬´¬ª (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicializa√ß√£o do estado tem dispers√£o perfeita</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : todos os bits do n√∫mero inicial afetam todos os bits do estado com a mesma probabilidade. </font><font style="vertical-align: inherit;">Eu quero descobrir em rela√ß√£o a SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dos problemas que atrasam o desenvolvimento de PRNGs e criptografia como um todo √© a falta de melhores ferramentas de uso geral. </font><font style="vertical-align: inherit;">Preciso de uma ferramenta que possa me fornecer imediatamente o resultado exato da medi√ß√£o, para que eu possa comparar diferentes arquiteturas em tempo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PractRand √© √≥timo comparado ao que era antes, no entanto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N√£o permite avaliar geradores de alta qualidade, tornando imposs√≠vel compar√°-los entre si. </font><font style="vertical-align: inherit;">Temos que dizer: "bem, depois de 32 terabytes eles n√£o t√™m anomalias ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demora semanas para execut√°-lo ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que a situa√ß√£o melhore muito em breve.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt498332/index.html">Implementa√ß√£o de arquitetura de seguran√ßa de confian√ßa zero: segunda edi√ß√£o</a></li>
<li><a href="../pt498334/index.html">Como organizar o processo de planejamento no SAP Analytics Cloud</a></li>
<li><a href="../pt498340/index.html">Sobre a nova casa da AID (revis√£o)</a></li>
<li><a href="../pt498346/index.html">GoLand 2020.1 - Suporte aprimorado para os m√≥dulos Go, muito preenchimento autom√°tico e muito mais</a></li>
<li><a href="../pt498350/index.html">Os melhores materiais para entrevistas de emprego e pesquisas de emprego</a></li>
<li><a href="../pt498354/index.html">Como traduzir "Wishlist" em "hardware" ou semi-desktop semi-m√≥vel semi-ideal</a></li>
<li><a href="../pt498358/index.html">Aprenda franc√™s ou como obter um adaptador universal em um scanner de diagn√≥stico PSA</a></li>
<li><a href="../pt498360/index.html">Avalia√ß√£o integrada de m√©tricas de carga do servidor</a></li>
<li><a href="../pt498362/index.html">A Kingston mant√©m a lideran√ßa nos envios de SSD: como fazemos?</a></li>
<li><a href="../pt498366/index.html">Quais algoritmos os desenvolvedores Yandex implementam todos os dias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>