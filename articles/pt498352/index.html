<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💒 🖍️ 👨🏼‍🤝‍👨🏻 SHISHUA: o gerador de números pseudo-aleatórios mais rápido do mundo 🏞️ 🖕🏾 🍖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Seis meses atrás, eu queria criar o melhor gerador de números pseudo-aleatórios (PRNG) com alguma arquitetura incomum. Eu pensei que o começo seria fá...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SHISHUA: o gerador de números pseudo-aleatórios mais rápido do mundo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/498352/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/ex/bl/5pexblhd_seedlgm8iidkfktef4.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seis meses atrás, eu queria criar o melhor gerador de números pseudo-aleatórios (PRNG) com alguma arquitetura incomum. Eu pensei que o começo seria fácil e, à medida que você trabalha, a tarefa se torna lentamente mais complexa. E eu pensei que se eu pudesse aprender tudo rápido o suficiente para lidar com as mais difíceis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para minha surpresa, a complexidade não aumentou linearmente. Teste de qui-quadrado byte provou ser muito difícil! Mais tarde, foi igualmente difícil passar em testes obstinados. Eu </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publicou os resultados atuais</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para entender o que outras dificuldades esperam por mim. No entanto </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o teste do PractRand falhou naquele momento</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então foi muito difícil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passar no teste BigCrush</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi muito difícil transferir 32 terabytes de dados ao passar o PractRand. </font><font style="vertical-align: inherit;">A velocidade se tornou um problema. </font><font style="vertical-align: inherit;">Não foi suficiente criar um design que gerasse dez megabytes por segundo, porque a aprovação do PractRand levaria um mês. </font><font style="vertical-align: inherit;">Mas devo admitir que </font><font style="vertical-align: inherit;">foi muito difícil </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">passar neste teste a uma velocidade de gigabytes por segundo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando você chega a tal altura ... você quer saber se pode chegar à fronteira de Pareto. </font><font style="vertical-align: inherit;">Você deseja criar o PRNG mais rápido do mundo, que passará nos testes estatísticos mais complexos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu consegui. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> falei sobre o que aprendi para alcançar meu objetivo. </font><font style="vertical-align: inherit;">E aqui vou lhe dizer como a arquitetura final funciona.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objetivo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar com o óbvio: a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">velocidade depende da plataforma</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Eu me concentrei na otimização da arquitetura moderna x86-64 (processadores Intel e AMD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A métrica </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> clássica é usada para comparar o desempenho </font><font style="vertical-align: inherit;">: este é o número de ciclos do processador gastos na geração de um byte. </font><font style="vertical-align: inherit;">Essa métrica é </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calculada e comparada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em todos os trabalhos criptográficos. </font><font style="vertical-align: inherit;">Uma cpb um pouco menor no mundo de software ou hardware pode garantir a vitória na competição ou o uso em sites em todo o mundo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para melhorar o cpb, você pode:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gere mais bytes com a mesma quantidade de trabalho,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou faça menos trabalho para gerar o mesmo número de bytes,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ou paralelizar o trabalho.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faremos tudo o que precede. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com o primeiro ponto, precisamos produzir mais bits a cada iteração. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu tinha medo de que eles me dissessem: “Se não der números de 32 bits, esse não é o PRSP”, ou o mesmo com números de 64 bits. Ou: “O PRNG deve ser apenas para a arquitetura x86-64”, como se instruções como POPCNT ou registros como% xmm7 fossem proibidas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, o PRNG é de engenharia: os geradores vêm tentando há várias décadas extrair todo o possível dos processadores! Quando o ROL apareceu, eles começaram a confiar nele. Com o advento dos processadores de 64 bits, eles começaram a confiar no% rax. Obviamente, no ARM, esses algoritmos podem funcionar mais lentamente (embora isso ainda deva ser visto), no entanto, os PRNs de 64 bits foram usados ​​ativamente mesmo antes do Android começar a exigir suporte para 64 bits em 2019! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, esta área está se desenvolvendo junto com o hardware. E hoje, os processadores Intel e AMD, devido ao </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVX2,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> já suportam operações de 256 bits. O RC4 produziu 1 byte, o drand48 pode produzir 4 bytes por vez, pcg64 - 8 bytes, e agora podemos gerar imediatamente 32 bytes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8 bytes podem ser um número de 64 bits, e a maioria das linguagens de programação possui tipos internos para isso. </font><font style="vertical-align: inherit;">Mas poucos idiomas fornecem tipos para 16 bytes (uma exceção notável é </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__uint128_t</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em C). </font><font style="vertical-align: inherit;">Menos idiomas ainda têm tipo para 32 bytes (exceto interno). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, podemos dizer adeus ao protótipo usual da função PRNG (exemplo do benchmark Vigny </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HWD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">static uint64_t next(void);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez disso, você pode criar um gerador que preencha o buffer (exemplo do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meu benchmark</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="plaintext hljs">void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quais são as desvantagens desta solução? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se o seu gerador produzir 32 bytes de cada vez, você precisará que o consumidor forneça uma matriz com um múltiplo de 32 (idealmente alinhado a 32 bytes). </font><font style="vertical-align: inherit;">Embora você possa ficar sem ele, preencheremos o buffer. </font><font style="vertical-align: inherit;">Removeremos os dados não utilizados e os preencheremos novamente conforme necessário. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O atraso</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se torna imprevisível: algumas chamadas apenas lerão o buffer. </font><font style="vertical-align: inherit;">Mas, em média, tudo será o mesmo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora geramos mais bytes, fazendo a mesma quantidade de trabalho. </font><font style="vertical-align: inherit;">Como nós a paralelizamos?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelismo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os processadores oferecem um incrível conjunto de ferramentas de paralelização em todos os níveis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em primeiro lugar, estas são as instruções SIMD (instrução única, dados múltiplos). Por exemplo, o AVX2 executa simultaneamente quatro adições de 64 bits ou oito de 32 bits, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É usado em criptografia há cerca de quinze anos. A </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simultaneidade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proporcionou o incrível desempenho do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">ChaCha20</font></a><font style="vertical-align: inherit;"> . É usado pelas primitivas mais importantes que não usam AESNI. Por exemplo, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NORX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gimli são</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projetados com o paralelismo em mente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, o interesse neste tópico também aumentou na comunidade PRNG não criptográfica. Em particular, as primitivas existentes que não foram projetadas para SIMD podem ser a base para a criação de PRNs muito rápidos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando Sebastiano Vigna promoveu sua arquitetura </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na biblioteca padrão Julia, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ele descobriu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que os resultados de oito instâncias PRNG competitivas e diferentemente inicializadas podem ser concatenadas muito rapidamente se cada operação for executada simultaneamente em todas as PRNRs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD é apenas um dos níveis de paralelização no processador. Eu recomendo a leitura do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artigo anterior sobre este tópico</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para ter uma idéia melhor, mas darei algumas explicações. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os pipelines do processador</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permitem que várias instruções sejam processadas em diferentes estágios. Se a ordem de execução for bem organizada para reduzir as dependências entre os estágios, o processamento das instruções poderá ser acelerado.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A execução superescalar</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite processar simultaneamente as partes computacionais das instruções. </font><font style="vertical-align: inherit;">Mas para isso, eles não devem ter dependências de leitura e gravação. </font><font style="vertical-align: inherit;">Você pode adaptar a arquitetura para reduzir o risco de tempo de inatividade gravando muito antes da leitura. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A execução extraordinária</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> permite que o processador execute instruções não na ordem da sequência, mas como estão prontas, mesmo que as instruções anteriores ainda não estejam prontas. </font><font style="vertical-align: inherit;">Mas, para isso, não deve haver dependência de leitura e gravação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora passamos à implementação!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arquitetura</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere um esquema chamado semi-SHISHUA. </font><font style="vertical-align: inherit;">A origem do nome se tornará gradualmente aparente enquanto você lê. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O esquema é assim:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd8/df1/b8f/bd8df1b8fcfae4897eb4b74f2c6e856f.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere sua linha por linha.</font></font><br>
<br>
<pre><code class="plaintext hljs">typedef struct prng_state {<font></font>
  __m256i state[2];<font></font>
  __m256i output;<font></font>
  __m256i counter;<font></font>
} prng_state;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O estado é dividido em duas partes, que são colocadas no registro AVX2 (256 bits). Para aumentar a velocidade, mantemos o resultado próximo ao próprio estado, mas ele não faz parte do estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Também temos um contador de 64 bits. Para simplificar o cálculo, também é um registro AVX2. O fato é que o AVX2 possui um pequeno recurso: os registros comuns (% rax e similares) não podem ser transferidos diretamente para o SIMD via MOV, eles devem passar pela RAM (geralmente pela pilha), o que aumenta o atraso e custa duas instruções do processador (MOV na pilha, VMOV da pilha). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos olhar para a geração. Vamos começar carregando, depois percorrer o buffer e preenchê-lo com 32 bytes a cada iteração.</font></font><br>
<br>
<pre><code class="plaintext hljs">inline void prng_gen(prng_state *s, __uint64_t buf[], __uint64_t size) {<font></font>
  __m256i s0 = s-&gt;state[0], counter = s-&gt;counter,<font></font>
          s1 = s-&gt;state[1],       o = s-&gt;output;<font></font>
  for (__uint64_t i = 0; i &lt; size; i += 4) {<font></font>
    _mm256_storeu_si256((__m256i*)&amp;buf[i], o);<font></font>
    // …<font></font>
  }<font></font>
  s-&gt;state[0] = s0; s-&gt;counter = counter;<font></font>
  s-&gt;state[1] = s1; s-&gt;output  = o;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como a função está em linha, o preenchimento imediato do buffer na inicialização permite que o processador execute imediatamente as instruções, dependendo disso, por meio de um mecanismo de execução extraordinário. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro do loop, executamos rapidamente três operações de estado:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ft</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHU</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ffle</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dd</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daí o nome SHISHUA!</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primeira marcha</font></font></h3><br>
<pre><code class="plaintext hljs">u0 = _mm256_srli_epi64(s0, 1);              u1 = _mm256_srli_epi64(s1, 3);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, o AVX2 não suporta rotações. </font><font style="vertical-align: inherit;">Mas eu quero misturar os bits de uma posição em um número de 64 bits com os bits de outra posição! </font><font style="vertical-align: inherit;">E a mudança é a melhor maneira de perceber isso. </font><font style="vertical-align: inherit;">Mudaremos para um número ímpar, para que cada bit visite todas as posições de 64 bits, e não metade delas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durante o turno, os bits são perdidos, o que leva à remoção de informações do nosso estado. </font><font style="vertical-align: inherit;">Isso é ruim, você precisa minimizar as perdas. </font><font style="vertical-align: inherit;">Os menores números ímpares são 1 e 3, usaremos diferentes valores de deslocamento para aumentar a discrepância entre as duas partes. </font><font style="vertical-align: inherit;">Isso ajudará a reduzir a semelhança de sua auto-correlação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mudaremos para a direita, porque os bits mais à direita têm a menor difusão durante a adição: por exemplo, o bit menos significativo em A + B é apenas o XOR dos bits mais baixos A e B.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agitação</font></font></h3><br>
<pre><code class="plaintext hljs">t0 = _mm256_permutevar8x32_epi32(s0, shu0); t1 = _mm256_permutevar8x32_epi32(s1, shu1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usaremos a mistura de 32 bits, porque fornece uma granularidade diferente em comparação às operações de 64 bits que usamos em qualquer lugar (o alinhamento de 64 bits é violado). Também pode ser uma operação de faixa cruzada: outros shuffles podem mover bits dentro dos 128 bits esquerdos se começarem à esquerda, ou dentro dos 128 bits direitos se começarem à direita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Constantes de mistura:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i shu0 = _mm256_set_epi32(4, 3, 2, 1, 0, 7, 6, 5),<font></font>
        shu1 = _mm256_set_epi32(2, 1, 0, 7, 6, 5, 4, 3);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que a mistura realmente melhore o resultado, moveremos as partes fracas (baixa dispersão) de 32 bits das adições de 64 bits para posições fortes, de modo que as próximas adições as enriquecem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parte inferior de 32 bits do bloco de 64 bits nunca se move para o mesmo bloco de 64 bits da parte de alta ordem. </font><font style="vertical-align: inherit;">Assim, ambas as partes não permanecem no mesmo pedaço, o que melhora a mistura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, cada parte de 32 bits passa por todas as posições em um círculo: de A a B, de B a C, ... de H a A. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você deve ter notado que a mistura mais simples que leva em conta todos esses requisitos são dois de 256 bits rotatividade (rotações de 96 bits e 160 bits para a direita, respectivamente).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adição</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos adicionar pedaços de 64 bits de duas variáveis ​​temporárias - shift e mixagem.</font></font><br>
<br>
<pre><code class="plaintext hljs">s0 = _mm256_add_epi64(t0, u0);              s1 = _mm256_add_epi64(t1, u1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A adição é a principal fonte de dispersão: nesta operação, os bits são combinados em combinações irredutíveis de expressões XOR e AND distribuídas em posições de 64 bits. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Armazenar o resultado da adição dentro de um estado preserva permanentemente essa dispersão.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Função de saída</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De onde obtemos a saída? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É simples: a estrutura que criamos nos permite gerar duas partes independentes do estado s0 e s1, que não se afetam de forma alguma. </font><font style="vertical-align: inherit;">Aplique o XOR a eles e obtenha um resultado completamente aleatório. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fortalecer a independência entre os dados aos quais aplicamos o XOR, obtemos um resultado parcial: a parte deslocada de um estado e a parte mista de outro.</font></font><br>
<br>
<pre><code class="plaintext hljs">o = _mm256_xor_si256(u0, t1);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é semelhante à redução das dependências de leitura e gravação entre instruções em um processador superescalar, como se u0 e t1 estivessem prontos para ler para s0 e s1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora discuta o balcão. Nós a processamos no início do ciclo. Primeiro, altere o estado e aumente o valor do contador:</font></font><br>
<br>
<pre><code class="plaintext hljs">s1 = _mm256_add_epi64(s1, counter);<font></font>
counter = _mm256_add_epi64(counter, increment);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que primeiro alteramos o estado e atualizamos o contador? s1 se torna disponível anteriormente, isso reduz a probabilidade de que as instruções subsequentes que a leem parem no pipeline do processador. Além disso, essa sequência ajuda a evitar a dependência direta do contador de leitura e gravação. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicamos o contador a s1, e não a s0, porque ambos afetam a saída de qualquer maneira; no entanto, s1 perde mais bits devido à mudança, de modo que ajuda a "se levantar" após a mudança. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O contador pode não gravar o teste do PractRand. Seu único objetivo é estabelecer um limite inferior de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">69</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes = 512 exbibytes para o período PRNG: começamos a repetir o ciclo somente após um milênio de trabalho a uma velocidade de 10 gibytes por segundo. É improvável que seja muito lento para uso prático nos próximos séculos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Incremento:</font></font><br>
<br>
<pre><code class="plaintext hljs">__m256i increment = _mm256_set_epi64x(1, 3, 5, 7);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os números ímpares são escolhidos como incrementos, porque apenas os números básicos do coprime cobrem todo o ciclo do campo finito GF (2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), e todos os números ímpares são coprime para 2. Em outras palavras, se você incrementar por um número inteiro par no intervalo de 0 a 4, retornando a 0 após 4, ocorre a sequência 0-2-0-2- ..., que nunca levará a 1 ou 3. E o incremento ímpar passa por todos os números inteiros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para todos os números de 64 bits no estado, usaremos números ímpares diferentes, que os separarão ainda mais e aumentarão ligeiramente a mistura. </font><font style="vertical-align: inherit;">Eu escolhi os menores números ímpares para que eles não pareçam mágicos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É assim que as funções de transição e saída de estado funcionam. </font><font style="vertical-align: inherit;">Como inicializá-los?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inicialização</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializamos o estado usando os dígitos hexadecimais Φ, o número irracional que é menos aproximado pela fração.</font></font><br>
<br>
<pre><code class="plaintext hljs">static __uint64_t phi[8] = {<font></font>
  0x9E3779B97F4A7C15, 0xF39CC0605CEDC834, 0x1082276BF3A27251, 0xF86C6A11D0C18E95,<font></font>
  0x2767F0B153D27B7F, 0x0347045B5BF1827F, 0x01886F0928403002, 0xC1D64BA40F335E36,<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pegue uma semente de 256 bits. </font><font style="vertical-align: inherit;">Isso geralmente é feito em criptografia e não prejudica o trabalho de PRNGs não criptográficos:</font></font><br>
<br>
<pre><code class="plaintext hljs">prng_state prng_init(SEEDTYPE seed[4]) {<font></font>
  prng_state s;<font></font>
  // …<font></font>
  return s;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não queremos redefinir toda a parte do estado (s0 ou s1) com esse número inicial, precisamos apenas afetar a metade. </font><font style="vertical-align: inherit;">Dessa forma, evitaremos o uso de números iniciais atenuantes, que acidental ou intencionalmente originam um estado inicial fraco conhecido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como não alteramos metade de cada estado, mantemos o controle sobre 128 bits de status. </font><font style="vertical-align: inherit;">Essa entropia é suficiente para iniciar e manter uma posição forte.</font></font><br>
<br>
<pre><code class="plaintext hljs">s.state[0] = _mm256_set_epi64x(phi[3], phi[2] ^ seed[1], phi[1], phi[0] ^ seed[0]);<font></font>
s.state[1] = _mm256_set_epi64x(phi[7], phi[6] ^ seed[3], phi[5], phi[4] ^ seed[2]);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, repetimos ( </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">várias vezes a </font><font style="vertical-align: inherit;">seguinte sequência:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Execute as etapas ( </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) das iterações SHISHUA.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribuímos uma parte do estado a outro estado e a outra parte à saída.</font></font></li>
</ol><br>
<pre><code class="plaintext hljs">for (char i = 0; i &lt; ROUNDS; i++) {<font></font>
  prng_gen(&amp;s, buf, 4 * STEPS);<font></font>
  s.state[0] = s.state[1];<font></font>
  s.state[1] = s.output;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atribuir um resultado de saída aumenta a dispersão do estado. </font><font style="vertical-align: inherit;">Durante a inicialização, o trabalho adicional e a correlação de estados não importam, porque essa série de operações é executada uma vez. </font><font style="vertical-align: inherit;">Estamos interessados ​​apenas na dispersão durante a inicialização. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de avaliar o efeito na correlação dos valores iniciais, escolhi </font></font><code>STEPS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font><font style="vertical-align: inherit;">para o </font><font style="vertical-align: inherit;">valor e </font></font><code>ROUNDS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font><font style="vertical-align: inherit;">para </font><font style="vertical-align: inherit;">10. Calculei a correlação calculando as anomalias “incomuns” e “suspeitas” decorrentes da ferramenta de controle de qualidade PRNG no PractRand.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atuação</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É difícil medir a velocidade por vários motivos:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A medição do relógio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pode não ser precisa o suficiente.</font></font></li>
<li>    <strong></strong>,      , -  ,  -,       .</li>
<li>,        .        <strong></strong>   .</li>
<li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><strong>  </strong></a>:        ,       .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu uso a instrução do processador RDTSC, que calcula o número de ciclos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que qualquer um possa reproduzir meus resultados, eu uso uma máquina virtual baseada em nuvem. Isso não altera o nível dos resultados de benchmark em comparação com os testes locais. Além disso, você não precisa comprar o mesmo computador que o meu. Por fim, há muitas situações em que o PRNG é lançado nas nuvens. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu escolhi o Google Cloud Platform N2 (processador Intel) e N2D (processador AMD). A vantagem do GCP é que eles oferecem servidores com processadores de ambos os fabricantes. Neste artigo, focaremos na Intel, mas para a AMD os resultados serão na mesma ordem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para aprofundar o assunto, primeiro vamos nos livrar do antigo gerador criptográfico RC4. Incapaz de paralelizar o trabalho, consegui</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ciclos por byte gerado). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos executar um MCG muito popular e rápido: o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128 PRNG mais simples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que passa no teste BigCrush, mostrou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,5 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Uau, ótimo! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, executaremos o desenvolvimento mais recente, usado para tabelas de hash rápidas - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wyrand</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um pouco melhor! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns PRSPs não passam no teste PractRand de 32 terabytes, mas funcionam muito rapidamente. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atingiu apenas 512 mebibytes, mas mostrou uma velocidade muito alta: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro desenvolvimento recente do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ela afirma ser o PRNG mais rápido do mundo - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, é o suficiente. </font><font style="vertical-align: inherit;">O que mostrou semi-SHISHUA? </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,14 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Duas vezes mais rápido que o RomuTrio.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c84/f7a/c9f/c84f7ac9fcbc4d4a7b2400ae552522a4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legal. </font><font style="vertical-align: inherit;">Agora teste o gerador criptográfico ChaCha8. </font><font style="vertical-align: inherit;">Ele atingiu ... </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oh. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SIMD é verdadeira magia! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para a comunidade criptográfica, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isso não foi uma surpresa especial</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">ChaCha8 é extremamente fácil de paralelizar. </font><font style="vertical-align: inherit;">Este é apenas um contador bem-hash em um estado difuso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E lembre-se de como a equipe de idiomas da Julia tentou combinar várias instâncias da arquitetura de Vigny para criar um PRNG rápido baseado em SIMD? </font><font style="vertical-align: inherit;">Vejamos o resultado deles usando esta técnica ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 pedaços de Xoshiro256 +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tecnicamente, meu laptop pode afetar os resultados. Não sei por que o desenvolvimento da equipe de Julia é mais rápido que o ChaCha8 no GCP, mas mais lento quando testado localmente. Na minha máquina, o semi-SHISHUA roda mais rápido que o desenvolvimento da equipe Julia, mas mais lento que o ChaCha8. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É necessário derrotar todos os concorrentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você provavelmente já está se perguntando por que chamamos a versão anterior do gerador semi-SHISHUA? Porque acabou sendo fácil dobrar a velocidade se você executar duas cópias do semi-SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semelhante à idéia do comando Julia, inicializamos separadamente dois PRNGs (quatro blocos de um estado de 256 bits), fornecendo alternadamente a saída de seu trabalho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas se criarmos mais estados, podemos produzir ainda mais dados, combinando quatro estados em pares:</font></font><br>
<br>
<pre><code class="plaintext hljs">o0 = _mm256_xor_si256(u0, t1);<font></font>
o1 = _mm256_xor_si256(u2, t3);<font></font>
o2 = _mm256_xor_si256(s0, s3);<font></font>
o3 = _mm256_xor_si256(s2, s1);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então nós adquirimos o SHISHUA, que mostrou uma velocidade de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06 cpb</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é duas vezes mais rápido que o concorrente mais rápido do mundo, que passou no teste PractRand de 32 terabytes. </font><font style="vertical-align: inherit;">O resultado está no gráfico. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Acredito que o desenvolvimento acabou sendo competitivo. </font><font style="vertical-align: inherit;">Funciona ainda mais rápido no meu laptop - 0,03 cpb, mas seguirei meus princípios em relação ao benchmark. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que por mais algumas semanas meu gerador fique no pódio dos mais rápidos do mundo (por favor, faça isso).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O gerador passa honestamente no BigCrush e no teste PractRand de 32 terabytes. E tudo graças a quatro fluxos de saída. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As desvantagens da arquitetura incluem sua </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">irreversibilidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Isso pode ser visto reduzindo-se para um estado de 4 bits com </font></font><code>s0 = [a, b]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>s1 = [c, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Com uma mudança, obtemos </font></font><code>[0, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>[0, d]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, e com agitação, </font></font><code>[b, c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>[d, a]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Novos </font></font><code>s0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguais </font></font><code>[b, c] + [0, a] = [b⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas </font></font><code>s1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iguais </font></font><code>[d, a] + [0, c] = [d⊕(a∧c), a⊕c]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Se </font></font><code>a = ¬c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, então, </font></font><code>a⊕c = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>a∧c = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, portanto, </font></font><code>s0 = [b, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>s1 = [d, 1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ou seja, temos duas combinações de </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font><code>c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nos dão o mesmo estado final. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, isso não é um problema, porque o contador de 64 bits também faz parte do estado. Acontece que o ciclo mínimo de 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">71</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bytes (128 bytes por transição de estado), a uma velocidade de 10 gibytes / s. </font><font style="vertical-align: inherit;">durará sete mil anos. </font><font style="vertical-align: inherit;">Isso equilibra os estados perdidos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, apesar da irreversibilidade, o período médio de transição entre estados é de 2 ^ ((256 + 1) ÷ 2). </font><font style="vertical-align: inherit;">Isso fornece um ciclo médio de </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.135</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bytes (a uma velocidade de 10 gibytes / s. Durará mais de um trilhão de vezes mais do que o universo existe). </font><font style="vertical-align: inherit;">Embora eu acredite que os ciclos médios estejam superestimados, porque eles não nos dizem nada sobre a qualidade do gerador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui estão os resultados do benchmark:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gerador</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atuação</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></strong></th>
<th><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlação de sementes</font></font></strong></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SHISHUA</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,06</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 256 GiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 + x8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,09</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ChaCha8</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,12</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB?</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RomuTrio</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,31</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xoshiro256 +</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,34</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">512 MiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wyrand</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,41</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lehmer128</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,44</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; 32 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RC4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7,48</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 TiB</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 KiB</font></font></td>
</tr>
</tbody></table></div><br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desempenho</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o número de ciclos do processador gastos em um byte gerado. </font><font style="vertical-align: inherit;">Recebido nas máquinas em nuvem N2 GCP e N2D (AMD), o pedido é o mesmo.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualidade</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o nível em que o gerador falha no teste do PractRand. </font><font style="vertical-align: inherit;">Se não falhar, há um sinal&gt;. </font><font style="vertical-align: inherit;">Se o resultado não for comprovado, há um ponto de interrogação.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correlação de números de sementes</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : travessia PractRand com bytes alternados de oito fluxos com números de sementes 0, 1, 2, 4, 8, 16, 32, 64. Usamos o PractRand com convolução dupla e testes avançados.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3f6/f1d/ea73f6f1db25664622785ba127764dbc.png"></div><br>
</li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais longe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora no nosso caso não haja problemas com a irreversibilidade, ainda podemos melhorar o SHISHUA. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na minha opinião, o PRNG ideal tem as seguintes propriedades:</font></font><br>
<br>
<ol>
<li><strong>      </strong>,     2<sup>1024</sup>.      10 /.    10<sup>282</sup>  ,   .    «» (  ).              ,       .  ,      128-  NEON   ARM?  ,      ,     .</li>
<li><strong>    </strong>.      ,   SHISHUA  XOR    .     ,     .</li>
<li><strong>  ,</strong>      2<sup>128</sup>    (     ).        SHISHUA,  ,  .  ,      ( )    (, , .  2).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A inicialização do estado tem dispersão perfeita</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : todos os bits do número inicial afetam todos os bits do estado com a mesma probabilidade. </font><font style="vertical-align: inherit;">Eu quero descobrir em relação a SHISHUA.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dos problemas que atrasam o desenvolvimento de PRNGs e criptografia como um todo é a falta de melhores ferramentas de uso geral. </font><font style="vertical-align: inherit;">Preciso de uma ferramenta que possa me fornecer imediatamente o resultado exato da medição, para que eu possa comparar diferentes arquiteturas em tempo real. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O PractRand é ótimo comparado ao que era antes, no entanto:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não permite avaliar geradores de alta qualidade, tornando impossível compará-los entre si. </font><font style="vertical-align: inherit;">Temos que dizer: "bem, depois de 32 terabytes eles não têm anomalias ..."</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demora semanas para executá-lo ...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que a situação melhore muito em breve.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt498332/index.html">Implementação de arquitetura de segurança de confiança zero: segunda edição</a></li>
<li><a href="../pt498334/index.html">Como organizar o processo de planejamento no SAP Analytics Cloud</a></li>
<li><a href="../pt498340/index.html">Sobre a nova casa da AID (revisão)</a></li>
<li><a href="../pt498346/index.html">GoLand 2020.1 - Suporte aprimorado para os módulos Go, muito preenchimento automático e muito mais</a></li>
<li><a href="../pt498350/index.html">Os melhores materiais para entrevistas de emprego e pesquisas de emprego</a></li>
<li><a href="../pt498354/index.html">Como traduzir "Wishlist" em "hardware" ou semi-desktop semi-móvel semi-ideal</a></li>
<li><a href="../pt498358/index.html">Aprenda francês ou como obter um adaptador universal em um scanner de diagnóstico PSA</a></li>
<li><a href="../pt498360/index.html">Avaliação integrada de métricas de carga do servidor</a></li>
<li><a href="../pt498362/index.html">A Kingston mantém a liderança nos envios de SSD: como fazemos?</a></li>
<li><a href="../pt498366/index.html">Quais algoritmos os desenvolvedores Yandex implementam todos os dias</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>