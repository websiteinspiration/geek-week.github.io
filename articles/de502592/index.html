<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêΩ üè≥Ô∏è üéØ Neomorphismus mit SwiftUI. Teil 1 üïß üñçÔ∏è üò£</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gru√ü, Chabrowiten! Im Vorfeld des Starts des Fortgeschrittenenkurses ‚ÄûIOS Developer‚Äú haben wir eine weitere interessante √úbersetzung vorbereitet.
 
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Neomorphismus mit SwiftUI. Teil 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502592/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gru√ü, Chabrowiten! </font><font style="vertical-align: inherit;">Im Vorfeld des Starts des Fortgeschrittenenkurses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûIOS Developer‚Äú haben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir eine weitere interessante √úbersetzung vorbereitet.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/nr/7d/ml/nr7dmlj7ru0rbnazf8ce8wox3ra.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nicht-morphisches Design ist vielleicht der interessanteste Trend der letzten Monate, obwohl Apple es in Wahrheit als Designmotiv auf der WWDC18 verwendet hat. </font><font style="vertical-align: inherit;">In diesem Artikel werden wir untersuchen, wie Sie ein nicht-morphisches Design mit SwiftUI implementieren k√∂nnen, warum Sie dies m√∂glicherweise tun m√∂chten und - was am wichtigsten ist - wie wir dieses Design verfeinern k√∂nnen, um seine Zug√§nglichkeit zu verbessern.</font></font><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wichtig</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Neomorphismus - manchmal auch als Neuromorphismus bezeichnet - hat schwerwiegende Folgen f√ºr die Zug√§nglichkeit. Trotz der Versuchung, den ersten Teil dieses Artikels zu lesen und den Rest zu √ºberspringen, fordere ich Sie auf, den Artikel bis zum Ende zu lesen und sowohl die Vor- als auch die Nachteile zu untersuchen, damit Sie das gesamte Bild sehen k√∂nnen .</font></font><br>
</blockquote><a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/z3tJdxwlo_Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundlagen des Neomorphismus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir zum Code √ºbergehen, m√∂chte ich kurz zwei Grundprinzipien dieser Richtung im Design skizzieren, da sie im weiteren Verlauf relevant sein werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Neomorphismus verwendet Blendung und Schatten, um die Formen von Objekten auf dem Bildschirm zu bestimmen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Kontrast nimmt tendenziell ab; </font><font style="vertical-align: inherit;">Es werden keine vollst√§ndig wei√üen oder schwarzen Elemente verwendet, mit denen Sie Glanzlichter und Schatten hervorheben k√∂nnen.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Endergebnis ist ein Look, der an ‚Äûextrudierten Kunststoff‚Äú erinnert - ein Design der Benutzeroberfl√§che, das auf jeden Fall frisch und interessant aussieht, ohne in die Augen zu sto√üen. </font><font style="vertical-align: inherit;">Ich kann nur noch einmal wiederholen, dass das Verringern des Kontrasts und das Verwenden von Schatten zum Hervorheben von Formen die Zug√§nglichkeit ernsthaft beeintr√§chtigt, und wir werden sp√§ter darauf zur√ºckkommen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke jedoch immer noch, dass sich die Zeit, die Sie mit dem Erlernen des Neomorphismus in SwiftUI verbringen, lohnt - auch wenn Sie ihn nicht in Ihren eigenen Anwendungen verwenden, ist er wie eine Code-Schreib-Kata, um Ihre F√§higkeiten zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Okay, genug Leerlaufgespr√§che - fahren wir mit dem Code fort.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen einer nicht-morphischen Karte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der einfachste Ausgangspunkt ist das Erstellen einer nicht-morphischen Karte: ein abgerundetes Rechteck, das einige Informationen enth√§lt. Als n√§chstes werden wir uns ansehen, wie wir diese Prinzipien auf andere Teile von SwiftUI √ºbertragen k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit der Erstellung eines neuen iOS-Projekts mithilfe der Single View-App-Vorlage. Stellen Sie sicher, dass Sie SwiftUI f√ºr die Benutzeroberfl√§che verwenden, und benennen Sie das Projekt Neumorphism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tipp: Wenn Sie Zugriff auf die Vorschau von SwiftUI in Xcode haben, empfehle ich, diese sofort zu aktivieren - das Experimentieren ist f√ºr Sie viel einfacher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst definieren wir eine Farbe, die einen cremigen Farbton darstellt. </font><font style="vertical-align: inherit;">Dies ist kein reines Grau, sondern ein sehr subtiler Farbton, der der Benutzeroberfl√§che ein wenig W√§rme oder K√ºhle verleiht. </font><font style="vertical-align: inherit;">Sie k√∂nnen es dem Asset-Verzeichnis hinzuf√ºgen, wenn Sie m√∂chten, aber jetzt ist es einfacher, es im Code zu tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie dies </font></font><code>Color</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au√üerhalb der Struktur hinzu </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Color</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> offWhite = <span class="hljs-type">Color</span>(red: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, green: <span class="hljs-number">225</span> / <span class="hljs-number">255</span>, blue: <span class="hljs-number">235</span> / <span class="hljs-number">255</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ja, es ist fast wei√ü, aber es ist dunkel genug, um echtes Wei√ü wie ein Gl√ºhen aussehen zu lassen, wenn wir es brauchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir den K√∂rper f√ºllen, </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem </font><font style="vertical-align: inherit;">wir ihn </font><font style="vertical-align: inherit;">bereitstellen </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der den gesamten Bildschirm einnimmt, und unsere neue quasi-wei√üe Farbe verwenden, um den gesamten Raum auszuf√ºllen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span> {
            <span class="hljs-type">Color</span>.offWhite<font></font>
        }<font></font>
        .edgesIgnoringSafeArea(.all)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur Darstellung unserer Karte verwenden wir ein abgerundetes Rechteck mit einer Aufl√∂sung von 300 x 300, um es auf dem Bildschirm sch√∂n und klar zu machen. </font><font style="vertical-align: inherit;">F√ºgen Sie dies also </font></font><code>ZStack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter der Farbe hinzu:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standardm√§√üig ist es schwarz, aber f√ºr die Implementierung des Neomorphismus m√∂chten wir den Kontrast stark reduzieren, sodass wir ihn durch dieselbe Farbe ersetzen, die wir f√ºr den Hintergrund verwenden, wodurch die Form tats√§chlich unsichtbar wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also √§ndere es so:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">25</span>)<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .frame(width: <span class="hljs-number">300</span>, height: <span class="hljs-number">300</span>)</code></pre><br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein wichtiger Punkt:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir bestimmen die Form mit Schatten, einem dunklen und einem hellen, als w√ºrde das Licht Strahlen aus der oberen linken Ecke des Bildschirms werfen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit SwiftUI k√∂nnen wir Modifikatoren mehrmals anwenden, was die Implementierung von Neomorphismus erleichtert. </font><font style="vertical-align: inherit;">F√ºgen Sie Ihrem abgerundeten Rechteck die folgenden zwei Modifikatoren hinzu:</font></font><br>
<br>
<pre><code class="swift hljs">.shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
.shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie repr√§sentieren den Versatz des dunklen Schattens in der unteren rechten Ecke und den Versatz des hellen Schattens in der oberen linken Ecke. </font><font style="vertical-align: inherit;">Der helle Schatten ist sichtbar, weil wir einen quasi wei√üen Hintergrund verwendet haben, und jetzt wird die Karte sichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben nur ein paar Codezeilen geschrieben, aber wir haben bereits eine nicht-morphische Karte - ich hoffe, Sie werden zustimmen, dass SwiftUI den Prozess √ºberraschend erleichtert!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/_z/0h/he_z0hdu4zlhtftzxwsvxo5k9t8.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen einer einfachen nicht-morphischen Schaltfl√§che</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Von allen Elementen einer Benutzeroberfl√§che stellt der Neomorphismus ein relativ geringes Risiko f√ºr Karten dar. Wenn die Benutzeroberfl√§che in Ihren Karten klar ist, hat die Karte m√∂glicherweise keinen klaren Rand, was die Zug√§nglichkeit nicht beeintr√§chtigt. Tasten sind eine andere Sache, da sie f√ºr die Interaktion ausgelegt sind, sodass eine Verringerung des Kontrasts mehr schaden als n√ºtzen kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns damit umgehen, indem wir unseren eigenen Schaltfl√§chenstil erstellen, da SwiftUI auf diese Weise die Verteilung von Schaltfl√§chenkonfigurationen an vielen Stellen erm√∂glicht. Dies ist viel praktischer als das Hinzuf√ºgen vieler Modifikatoren zu jeder von Ihnen erstellten Schaltfl√§che. Wir k√∂nnen den Stil einfach einmal definieren und an vielen Stellen verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden einen Schaltfl√§chenstil definieren, der tats√§chlich leer ist: SwiftUI gibt uns die Bezeichnung f√ºr die Schaltfl√§che, die Text, Bild oder etwas anderes sein kann, und wir senden sie ohne √Ñnderungen zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºgen Sie diese Struktur irgendwo au√üerhalb hinzu </font></font><code>ContentView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SimpleButtonStyle</span>: <span class="hljs-title">ButtonStyle</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {<font></font>
        configuration.label<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser </font></font><code>configuration.label</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt den Inhalt der Schaltfl√§che, und bald werden wir noch etwas hinzuf√ºgen. </font><font style="vertical-align: inherit;">Definieren wir zun√§chst eine Schaltfl√§che, die sie verwendet, damit Sie sehen k√∂nnen, wie sich das Design entwickelt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Button</span>(action: {
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Button tapped"</span>)<font></font>
}) {<font></font>
    <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"heart.fill"</span>)<font></font>
        .foregroundColor(.gray)<font></font>
}<font></font>
.buttonStyle(<span class="hljs-type">SimpleButtonStyle</span>())</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Bildschirm wird nichts Besonderes angezeigt, aber wir k√∂nnen das Problem beheben, indem wir dem Schaltfl√§chenstil unseren nicht-morphischen Effekt hinzuf√ºgen. Dieses Mal wird kein abgerundetes Rechteck verwendet, da f√ºr einfache Symbole der Kreis besser ist. Wir m√ºssen jedoch einige Einr√ºckungen hinzuf√ºgen, damit der Klickbereich f√ºr Schaltfl√§chen gro√ü und sch√∂n ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern Sie Ihre Methode, </font></font><code>makeBody()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indem Sie einen Einzug hinzuf√ºgen und dann unseren nicht-morphischen Effekt als Hintergrund f√ºr die Schaltfl√§che platzieren:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
            .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
    )</code></pre><br>
<img src="https://habrastorage.org/webt/nm/-x/yp/nm-xyp4klovncqtomhthav-za7y.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bringt uns dem gew√ºnschten Effekt nahe genug, aber wenn Sie die Anwendung ausf√ºhren, werden Sie feststellen, dass das Verhalten in der Praxis immer noch nicht perfekt ist - die Taste reagiert beim Dr√ºcken nicht visuell, was nur seltsam aussieht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu beheben, m√ºssen wir die Eigenschaft </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in unserem benutzerdefinierten Schaltfl√§chenstil </font><font style="vertical-align: inherit;">lesen </font><font style="vertical-align: inherit;">, der angibt, ob die Schaltfl√§che gerade gedr√ºckt wird oder nicht. Wir k√∂nnen dies verwenden, um unseren Stil zu verbessern und visuell anzuzeigen, ob die Taste gedr√ºckt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einem einfachen: Wir werden </font></font><code>Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schaltfl√§chen f√ºr den Hintergrund verwenden und dann </font></font><code>configuration.isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entweder einen flachen Kreis </font><font style="vertical-align: inherit;">√ºberpr√ºfen </font><font style="vertical-align: inherit;">und zur√ºckgeben, wenn die Schaltfl√§che gedr√ºckt wird, oder unseren aktuellen abgedunkelten Kreis ansonsten:</font></font><br>
<br>
<pre><code class="swift hljs">configuration.label<font></font>
    .padding(<span class="hljs-number">30</span>)<font></font>
    .background(<font></font>
        <span class="hljs-type">Group</span> {
            <span class="hljs-keyword">if</span> configuration.isPressed {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Circle</span>()<font></font>
                    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
                    .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
            }<font></font>
        }<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da im Zustand ein </font></font><code>isPressed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kreis mit einer quasi wei√üen Farbe verwendet wird, wird unser Effekt beim Dr√ºcken der Taste unsichtbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warnung: Aufgrund der Art und Weise, wie SwiftUI tippbare Bereiche berechnet, haben wir den Klickbereich f√ºr unsere Schaltfl√§che unbeabsichtigt sehr klein gemacht. Jetzt m√ºssen Sie auf das Bild selbst tippen und nicht auf das unomorphe Design um es herum. </font><font style="vertical-align: inherit;">Um dies zu beheben, f√ºgen Sie </font></font><code>.contentShape(Circle())</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unmittelbar danach </font><font style="vertical-align: inherit;">einen Modifikator hinzu </font></font><code>.padding(30)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der SwiftUI zwingt, den gesamten verf√ºgbaren Speicherplatz zu nutzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt k√∂nnen wir den Effekt der k√ºnstlichen Konkavit√§t </font></font><code>shadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erzeugen, indem </font><font style="vertical-align: inherit;">wir den Schatten umdrehen - indem wir zwei Modifikatoren </font><font style="vertical-align: inherit;">aus dem </font><font style="vertical-align: inherit;">Basiseffekt kopieren </font><font style="vertical-align: inherit;">und die X- und Y-Werte gegen Wei√ü und Schwarz austauschen, wie hier gezeigt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> configuration.isPressed {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-type">Circle</span>()<font></font>
        .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.2</span>), radius: <span class="hljs-number">10</span>, x: <span class="hljs-number">10</span>, y: <span class="hljs-number">10</span>)<font></font>
        .shadow(color: <span class="hljs-type">Color</span>.white.opacity(<span class="hljs-number">0.7</span>), radius: <span class="hljs-number">10</span>, x: -<span class="hljs-number">5</span>, y: -<span class="hljs-number">5</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sch√§tzen Sie das Ergebnis.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/nz/gv/bknzgvars2r0e4anrdqngo12wr4.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie interne Schatten f√ºr einen Klick auf eine Schaltfl√§che</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser aktueller Code funktioniert im Prinzip bereits, aber die Leute interpretieren den Effekt anders - einige sehen ihn als konkaven Knopf, andere sehen, dass der Knopf immer noch nicht gedr√ºckt wird, nur das Licht kommt aus einem anderen Winkel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee der Verbesserung besteht darin, einen inneren Schatten zu erzeugen, der den Effekt des Dr√ºckens der Taste nach innen simuliert. Dies ist nicht Teil des Standard-SwiftUI-Kits, aber wir k√∂nnen es recht einfach implementieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines inneren Schattens erfordert zwei lineare Verl√§ufe. Diese sind nur die ersten von vielen internen Verl√§ufen, die wir in diesem Artikel verwenden. Daher f√ºgen wir sofort eine kleine Hilfserweiterung f√ºr hinzu </font></font><code>LinearGradient</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um die Erstellung von Standardverl√§ufen zu vereinfachen:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">LinearGradient</span> </span>{
    <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> colors: <span class="hljs-type">Color</span>...) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(gradient: <span class="hljs-type">Gradient</span>(colors: colors), startPoint: .topLeading, endPoint: .bottomTrailing)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Damit k√∂nnen wir einfach eine variable Liste von Farben bereitstellen, um ihren linearen Farbverlauf in diagonaler Richtung wiederherzustellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zum wichtigen Punkt: Anstatt unserem gedr√ºckten Kreis zwei umgedrehte Schatten hinzuzuf√ºgen, √ºberlagern wir einen neuen Kreis mit einer Unsch√§rfe (Strich) und wenden dann einen weiteren Kreis mit einem Farbverlauf als Maske an. </font><font style="vertical-align: inherit;">Das ist etwas kniffliger, aber lassen Sie es mich St√ºck f√ºr St√ºck erkl√§ren:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unser Grundkreis ist unser aktueller Kreis mit einem neomorphen Effekt, der mit einer quasi wei√üen Farbe gef√ºllt ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir platzieren einen Kreis dar√ºber, eingerahmt von einem grauen Rahmen, und verwischen leicht, um die R√§nder zu mildern.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wenden wir eine Maske mit einem anderen Kreis auf diesen dar√ºber liegenden Kreis an, diesmal gef√ºllt mit einem linearen Farbverlauf.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine Ansicht als Maske f√ºr eine andere anwenden, verwendet SwiftUI den Alphakanal der Maske, um festzulegen, was in der Basisansicht angezeigt werden soll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir also einen verschwommenen grauen Strich zeichnen und ihn dann mit einem linearen Farbverlauf von schwarz nach transparent maskieren, ist der verschwommene Strich auf der einen Seite unsichtbar und nimmt auf der anderen Seite allm√§hlich zu - wir erhalten einen glatten internen Farbverlauf. Um den Effekt st√§rker zu machen, k√∂nnen wir die schattierten Kreise leicht in beide Richtungen verschieben. Nachdem ich ein wenig experimentiert hatte, stellte ich fest, dass das Zeichnen eines hellen Schattens mit einer dickeren Linie als einer dunklen dazu beitr√§gt, den Effekt zu maximieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie daran, dass zwei Schatten verwendet werden, um ein Gef√ºhl der Tiefe im Neomorphismus zu erzeugen: ein Licht und ein Dunkel. Daher werden wir diesen Effekt des inneren Schattens zweimal mit unterschiedlichen Farben hinzuf√ºgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ñndern Sie den Kreis </font></font><code>configuration.isPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie folgt:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">Circle</span>()<font></font>
    .fill(<span class="hljs-type">Color</span>.offWhite)<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.gray, lineWidth: <span class="hljs-number">4</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: <span class="hljs-number">2</span>, y: <span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.black, <span class="hljs-type">Color</span>.clear)))<font></font>
    )<font></font>
    .overlay(<font></font>
        <span class="hljs-type">Circle</span>()<font></font>
            .stroke(<span class="hljs-type">Color</span>.white, lineWidth: <span class="hljs-number">8</span>)<font></font>
            .blur(radius: <span class="hljs-number">4</span>)<font></font>
            .offset(x: -<span class="hljs-number">2</span>, y: -<span class="hljs-number">2</span>)<font></font>
            .mask(<span class="hljs-type">Circle</span>().fill(<span class="hljs-type">LinearGradient</span>(<span class="hljs-type">Color</span>.clear, <span class="hljs-type">Color</span>.black)))<font></font>
    )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Anwendung erneut ausf√ºhren, werden Sie feststellen, dass das Dr√ºcken einer Taste viel ausgepr√§gter ist und besser aussieht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1r/f1/ha/1rf1hanjn-9zhj0xhglha6e4lr0.jpeg"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Damit endete der erste Teil der √úbersetzung. </font><font style="vertical-align: inherit;">In den kommenden Tagen werden wir die Fortsetzung ver√∂ffentlichen und jetzt laden wir Sie ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mehr √ºber den bevorstehenden Kurs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">erfahren</font></a><font style="vertical-align: inherit;"> .</font></font></i></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502576/index.html">Apple Watch f√ºr preiswerte: wie sie mich auf Avito und Yulia "z√ºchten" wollten</a></li>
<li><a href="../de502578/index.html">√úber die Revolution in Radar, Fristen und den Eintritt in die vierte Dimension</a></li>
<li><a href="../de502580/index.html">Als Entwickler in Open Source engagieren? Wir besch√§ftigen uns mit den Rechten (hi, nginx)</a></li>
<li><a href="../de502584/index.html">Der Hersteller Mi Band wird eine selbstdesinfizierende transparente Maske zum Schutz vor COVID-19 herausbringen</a></li>
<li><a href="../de502588/index.html">Die unglaubliche Geschichte von PowerPoint</a></li>
<li><a href="../de502594/index.html">7 Gr√ºnde, warum Webprojekte nicht beendet werden und wie man damit umgeht</a></li>
<li><a href="../de502596/index.html">Kostenlose Quarant√§ne-Bildungskurse: Design</a></li>
<li><a href="../de502598/index.html">Sicherheitswoche 21: Sicherheitsanf√§lligkeit in Windows Print Service</a></li>
<li><a href="../de502604/index.html">Eine Einf√ºhrung in TLS f√ºr Patrik Patrick (Teil 1)</a></li>
<li><a href="../de502608/index.html">Wie wir den Marktplatz f√ºr Anwendungen im SaaS-Dienst gestartet haben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>