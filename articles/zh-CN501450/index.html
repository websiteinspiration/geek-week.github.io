<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏾 💦 🧛🏼 iOS开发人员必须知道的14件事 🚫 🥞 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="经作者许可，我发表了Norberto Gil Vasconcelos的文章翻译，内容为“ 14位iOS开发者必须知道”（链接到原始作者）。在本文发表时，Swift 3版本是相关的，
 
 作为iOS开发人员（目前绝对依赖Swift），我从头开始创建了应用程序，受支持的应用程序并在各个团队中工作。在从...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>iOS开发人员必须知道的14件事</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501450/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">经作者许可，我发表了Norberto Gil Vasconcelos的文章翻译，内容为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ 14位iOS开发者必须知道”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到原始作者</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。在本文发表时，Swift 3版本是相关的，</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为iOS开发人员（目前绝对依赖Swift），我从头开始创建了应用程序，受支持的应用程序并在各个团队中工作。在从事该行业的所有时间里，我经常听到这样的短语：“您无法解释，那么您将无法理解。”因此，为了理解我每天到底要做什么，我创建了一份清单，我认为这对任何iOS开发人员都很重要。我会尽力解释每时每刻。 [请随时纠正我，表达您的意见或建议您对此列表进行补充。]</font></font><br>
<br>
<hr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主题：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本控制</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑图案</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objective-C的与斯威夫特</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖管理器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信息存储</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CollectionViews和TableViews</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户界面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短路</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地理位置</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可本地化的字符串</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><a name="habracut"></a><hr><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我的列表，事不宜迟，随机排列。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本控制</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
恭喜，您已被接受！从存储库中提取代码并开始工作。停什么</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
版本控制对于任何项目都是必需的，即使您只是开发人员。最常用的系统是Git和SVN。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SVN</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于集中式版本控制系统。这是在其中创建工作副本的存储库，要访问它们，您需要网络连接。更改授权以特定方式进行；系统通过注册每个文件来监视更改，更改的完整历史记录只能在存储库中查看。工作副本仅包含最新版本。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吉特</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用分布式版本控制系统。</font><font style="vertical-align: inherit;">您将拥有一个可以在其中工作的本地存储库，只有同步才需要网络连接。</font><font style="vertical-align: inherit;">更改工作副本时，将保存整个目录的状态，但仅记录所做的更改；</font><font style="vertical-align: inherit;">存储库和工作副本都具有完整的更改历史记录。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建筑图案</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您的手指激动得发抖，您发现了版本控制功能！还是因为喝咖啡？没关系！您即将来到，编程的时机已到！不。还等什么呢？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
坐在键盘上之前，必须选择要遵循的建筑模式。如果尚未启动项目，则必须匹配现有模式。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在移动应用程序的开发中使用了多种模式（MVC，MVP，MVVM，VIPER等）。我将简要概述iOS开发中最常用的：</font></font><br>
<br>
<ul>
<li><b>MVC</b> —   Model, View, Controller. Controller    Model  View,      .   View  Controller  ,  Controller   .   ?  ,     View,   (ViewController)   .    ,      MVC.    MVC  .     ( !), , ,    Model,     ,   .    MVC  ,    ,    iOS   . <br>
<br>
<img src="https://habrastorage.org/webt/0x/7h/xl/0x7hxlsqy_qxcd_wp91iw60kliq.png"><br>
<sup>MVC –  </sup><br>
</li>
<li><b>MVVM</b> —   <b>M</b>odel, <b>V</b>iew, <b>V</b>iew<b>M</b>odel.  (   )   View  ViewModel,   ViewModel    ,    ViewModel,   View - . ViewModel     View,   ,     .<br>
<br>
<img src="https://habrastorage.org/webt/vn/an/wq/vnanwqwrpz4vgez4w6uunvjuvci.png"><br>
<sup>MVVM –  </sup><br>
</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了更深入地了解和了解其他模式，建议阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下文章</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这看起来可能不那么多，但是结构良好且组织良好的代码可以避免很多麻烦。</font><font style="vertical-align: inherit;">每个开发人员在某个时候犯的一个大错误就是仅仅获得期望的结果而拒绝组织代码，错误地认为这样做可以节省时间。</font><font style="vertical-align: inherit;">如果您不同意，请听旧的Benji：</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您花在组织业务上的每一分钟都可以节省一个小时</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-本杰明·富兰克林</font></font></i><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的目标是获得易于使用和维护的直观易读的代码。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objective-C与Swift</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在决定使用哪种编程语言编写应用程序时，您应该知道它们各自具有的功能。如果可能的话，我更喜欢使用Swift。为什么？老实说，与Swift相比，Objective-C几乎没有优势。大多数示例和教程都是用Objective-C编写的，而Swift每次更新都会对范例进行调整，这可能会令人沮丧。但是，这些问题最终将消失。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与Objective-C相比，Swift在许多方面都有了飞跃。它易于阅读，看起来像自然的英语，并且由于它不是基于C的，因此您可以放弃传统约定。对于那些了解Objective-C的人来说，这意味着不再需要分号，并且方法调用和表达式条件也不需要放在方括号中。维护代码也更容易：Swift仅需要.swift文件而不是.h和.m文件，因为Xcode和LLVM编译器可以检测依赖关系并自动执行增量构建。通常，您不必担心创建标准化代码，并且您会发现用更少的行就能达到相同的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还是有疑问吗？ Swift更安全，更快速，并且可以进行内存管理（大部分情况下！）。您知道用未初始化的指针变量调用方法时在Objective-C中会发生什么吗？没有。该表达式变为非活动状态并被跳过。听起来不错，因为它不会导致应用程序崩溃，但是会导致许多错误和不稳定行为，因此您需要考虑改变职业。说真的成为专业的walk狗人的想法闪耀着新的色彩。同时，Swift计数器可使用可选值。您不仅会更好地了解nil可以做什么，并设置条件以防止使用nil值，而且如果仍然使用nil可选，还会导致运行时崩溃，这将简化调试。ARC（自动引用计数）可帮助您更好地管理Swift中的内存。在Objective-C中，ARC不适用于过程C或诸如Core Graphics之类的API。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反应还是不反应？</font><font style="vertical-align: inherit;">（就是那个问题）</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
功能反应式编程（FRP）是新的热门。</font><font style="vertical-align: inherit;">它旨在简化异步操作和事件/数据流的编译。</font><font style="vertical-align: inherit;">对于Swift来说，这是通过Observable接口表达的通用计算抽象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
举例说明，最简单的方法就是编写一些代码。假设婴儿蒂米（Timmy）和他的妹妹珍妮（Jenny）想购买一个新的游戏机。蒂米每周从父母那里收到5欧元，詹妮也是如此。但是，珍妮在周末分发报纸又赚了5欧​​元。如果两者都节省一分钱，我们可以每周检查控制台是否可用！每次储蓄的值更改时，都会计算其总值。如果足够，该消息将存储在isConsoleAttainable变量中。在任何时候，我们都可以通过订阅来检查消息。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-comment">// </span>
<span class="hljs-keyword">let</span> timmySavings = <span class="hljs-type">Variable</span>(<span class="hljs-number">5</span>)
<span class="hljs-keyword">let</span> jennySavings = <span class="hljs-type">Variable</span>(<span class="hljs-number">10</span>)<font></font>
<font></font>
<span class="hljs-keyword">var</span> isConsoleAttainable =
<span class="hljs-type">Observable</span>
.combineLatest(timmy.asObservable(), jenny.asObservable()) { $<span class="hljs-number">0</span> + $<span class="hljs-number">1</span> }<font></font>
.<span class="hljs-built_in">filter</span> { $<span class="hljs-number">0</span> &gt;= <span class="hljs-number">300</span> }<font></font>
.<span class="hljs-built_in">map</span> { <span class="hljs-string">"\($0)    !"</span> }<font></font>
<font></font>
<span class="hljs-comment">//  </span>
timmySavings.value = <span class="hljs-number">10</span>
jennySavings.value = <span class="hljs-number">20</span><font></font>
isConsoleAttainable<font></font>
   .subscribe(onNext: { <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>) }) <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-comment">//  </span>
timmySavings.value = <span class="hljs-number">100</span>
jennySavings.value = <span class="hljs-number">200</span><font></font>
isConsoleAttainable<font></font>
   .subscribe(onNext: { <span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>) }) <span class="hljs-comment">// 300    !</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这只是FRP可以完成的一个示例，一旦您掌握了FRP，它将为使用MVC以外的体系结构开辟一个全新的可能性世界……是的，是的！</font><font style="vertical-align: inherit;">MVVM！</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以查看两个主要的Swift FRP头衔申请人：</font></font><br>
<br>
<ul>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rxswift</font></font></a></b></li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活性可可</font></font></a></b></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依赖经理</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CocoaPods和Carthage是Cocoa Swift和Objective-C项目中最常见的依赖项管理器。</font><font style="vertical-align: inherit;">它们简化了实现库并保持其最新状态的过程。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CocoaPods</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有许多使用Ruby构建的库，可以使用以下命令进行安装：</font></font><br>
<br>
<pre><code class="bash hljs">$ sudo gem install cocoapods</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安装后，您将要为您的项目创建一个Podfile。</font><font style="vertical-align: inherit;">您可以运行以下命令：</font></font><br>
<br>
<pre><code class="bash hljs">$ pod install</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
或使用以下结构创建自定义Podfile：</font></font><br>
<br>
<pre><code class="bash hljs">platform :ios, <span class="hljs-string">'8.0'</span><font></font>
use_frameworks!<font></font>
<font></font>
target <span class="hljs-string">'MyApp'</span> <span class="hljs-keyword">do</span>
pod <span class="hljs-string">'AFNetworking'</span>, <span class="hljs-string">'~&gt; 2.6'</span>
pod <span class="hljs-string">'ORStackView'</span>, <span class="hljs-string">'~&gt; 3.0'</span>
pod <span class="hljs-string">'SwiftyJSON'</span>, <span class="hljs-string">'~&gt; 2.3'</span><font></font>
end<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建完成后，就该安装新模块了：</font></font><br>
<br>
<pre><code class="bash hljs">$ pod install</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，您可以打开</font><font style="vertical-align: inherit;">项目</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.xcworkspace</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，不要忘记导入依赖项。</font><font style="vertical-align: inherit;">与CocoaPods不同，</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carthage</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个分散的依赖性管理器。</font><font style="vertical-align: inherit;">这样做的缺点是，用户查找现有库变得越来越困难。</font><font style="vertical-align: inherit;">另一方面，此方法需要较少的支持工作，并避免了由于集中存储而造成的中断。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关安装和使用的更多信息，请查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHub项目</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据存储</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从最简单的方法为应用程序保存数据开始。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之所以</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">命名为</font><b><font style="vertical-align: inherit;">NSUserDefaults</font></b><font style="vertical-align: inherit;">，是因为它通常用于保存应用程序首次加载时显示的默认用户数据。</font><font style="vertical-align: inherit;">因此，它变得简单易用，但这也意味着一些限制。</font><font style="vertical-align: inherit;">其中之一是此方法接受的对象的类型。</font><font style="vertical-align: inherit;">它的行为与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性列表（Plist）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常相似</font><font style="vertical-align: inherit;">，后者具有相同的限制。</font><font style="vertical-align: inherit;">它们可以存储以下六种类型的对象：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSData</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSDate</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NS编号</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSDictionary</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nsstring</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSArray</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了与Swift兼容，NSNumber可以接受以下类型：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UInt</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浮动</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">布尔</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以按如下方式将对象存储在NSUserDefaults中（首先创建一个常数，该常数将存储所存储对象的密钥）：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> keyConstant = <span class="hljs-string">"objectKey"</span><font></font>
<font></font>
<span class="hljs-keyword">let</span> defaults = <span class="hljs-type">NSUserDefaults</span>.standardsUserDefaults()<font></font>
defaults.setObject(<span class="hljs-string">"Object to save"</span>, objectKey: keyConstant)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要从NSUserDefaults中读取对象，我们可以执行以下操作：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> name = defaults.stringForKey(keyConstant) {
   <span class="hljs-built_in">print</span>(name)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有几种方便的方法可以读取和写入NSUserDefaults，这些方法接收特定的对象而不是AnyObject。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">钥匙串</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个密码管理系统，可能包含密码，证书，私钥或个人注释。钥匙串具有两个级别的设备加密。第一级使用锁定屏幕锁定代码作为加密密钥。第二级使用生成并存储在设备上的密钥。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是什么意思？这不是绝对超级安全，尤其是在锁定屏幕上不使用密码的情况下。由于第二级使用的密钥存储在设备中，因此还有其他方法可以访问。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最好的解决方案是使用您自己的加密。 （不要将密钥存储在设备上）</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CoreData</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是Apple开发的框架，因此您的应用程序可以以面向对象的方式与数据库进行交互。</font><font style="vertical-align: inherit;">通过减少代码量并消除了测试本节的需要，这简化了过程。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的应用程序需要持久性数据，则应使用CoreData，这将大大简化保存它们的过程，并允许您不创建/测试自己的与数据库通信的方式。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CollectionViews和TableViews</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
几乎每个应用程序都有一个或多个CollectionViews和/或TableViews。了解它们的工作方式以及何时使用一种或另一种将防止将来对应用程序进行复杂的更改。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TableViews</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在垂直的单个列中显示项目列表，并且仅受垂直滚动限制。每个项目都由一个UITableViewCell表示，可以完全自定义。它们可以按节和行进行排序。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CollectionViews</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">还显示项目列表，但它们可以具有多个列和行（例如，网格）。它们可以水平和/或垂直滚动​​，每个元素由一个UICollectionViewCell表示。与UITableViewCells一样，可以根据需要对其进行自定义并按节和行进行排序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它们都具有相似的功能，并使用可重复使用的单元来提高移动性。您需要什么的选择取决于列表上要具有的复杂性。 CollectionView可用于表示任何列表，我认为，它始终是最佳选择。假设您要提交联系人列表。该列表很简单，您可以用一个列来实现它，因此选择一个UITableView。一切正常！几个月后，您的设计师将决定应以网格格式而不是列表显示联系人。唯一的方法是将UITableView的实现更改为UICollectionView的实现。我想说的是，尽管您的列表可能很简单，并且如果设计更改的可能性很大，那么UITableView可能就足够了，最好使用UICollectionView实现此列表。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论您做出什么选择，创建一个通用的TableView / CollectionView都是一个好主意。</font><font style="vertical-align: inherit;">这有助于实现并允许重用大量代码。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情节提要VS Xibs VS可编程UI</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些方法中的每一个都可以单独用于创建用户界面，但是没有什么可以阻止您将它们组合在一起。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">故事板</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供了设计人员希望的项目的更广泛视图，使您可以查看应用程序的流程及其窗口。</font><font style="vertical-align: inherit;">缺点是，随着窗口的增加，连接变得更加混乱，并且情节提要的加载时间增加。</font><font style="vertical-align: inherit;">合并问题更为常见，因为整个用户界面都在单个文件中。</font><font style="vertical-align: inherit;">它们也变得更加难以解决。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锡伯斯</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供窗口或窗口部分的可视视图。优点是易于重用，与情节提要相比合并冲突更少，并且易于查看每个窗口的内容。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通过编程</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户界面，您可以更好地控制它，减少合并冲突的频率，如果发生冲突，则更容易消除。缺点是可视化较少，编写时需要更多时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建用户界面的上述方法差别很大。</font><font style="vertical-align: inherit;">但是，以我的主观观点，最好的选择是将这三者结合起来。</font><font style="vertical-align: inherit;">几个情节提要板（现在我们可以在情节提要板之间切换！），使用Xib代替不是主窗口的任何可视对象，最后还需要进行一些编程以进行其他控制，因此在某些情况下是必需的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">9- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">协议！</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在日常生活中，存在协议，因此在某种情况下我们知道如何应对。</font><font style="vertical-align: inherit;">假设您是一名消防员，并且发生了紧急情况。</font><font style="vertical-align: inherit;">每名消防员都必须遵循一项协议，该协议列出了成功响应的要求。</font><font style="vertical-align: inherit;">Swift / Objective-C中的协议也是如此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
协议定义了指定功能的方法，属性和其他要求的草图。</font><font style="vertical-align: inherit;">它可以由类，结构或枚举采用，然后将具有这些要求的实际实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是创建和使用协议的</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
示例</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">在我的示例中，我将需要一个枚举，列出用于扑灭火灾的不同类型的材料。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ExtinguisherType</span>: <span class="hljs-title">String</span> </span>{<font></font>
<font></font>
   <span class="hljs-keyword">case</span> water, foam, sand<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我将创建一个紧急响应协议。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">RespondEmergencyProtocol</span> </span>{<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">putOutFire</span><span class="hljs-params">(with material: ExtinguisherType)</span></span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我将创建一个遵守该协议的消防员类。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fireman</span>: <span class="hljs-title">RespondEmergencyProtocol</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">putOutFire</span><span class="hljs-params">(with material: ExtinguisherType)</span></span> {<font></font>
<font></font>
       <span class="hljs-built_in">print</span>(<span class="hljs-string">"Fire was put out using \(material.rawValue)."</span>)<font></font>
<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细！</font><font style="vertical-align: inherit;">现在我们使用消防员。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">var</span> fireman: <span class="hljs-type">Fireman</span> = <span class="hljs-type">Fireman</span>()<font></font>
<font></font>
fireman.putOutFire(with: .foam)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果应该是：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“用泡沫扑灭了火。” </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
委托中也使用协议。</font><font style="vertical-align: inherit;">这允许类或结构将某些功能委托给另一种类型的实例。</font><font style="vertical-align: inherit;">创建具有委托职责的协议，以确保其功能具有适当的类型。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一个小例子！</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">FireStationDelegate</span>: <span class="hljs-title">AnyObject</span> </span>{<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleEmergency</span><span class="hljs-params">()</span></span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
消防部门委托消防员采取应急措施。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FireStation</span> </span>{
   <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> delegate: <span class="hljs-type">FireStationDelegate?</span><font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">emergencyCallReceived</span><span class="hljs-params">()</span></span> {<font></font>
      delegate?.handleEmergency()<font></font>
   }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着消防员还必须遵守FireStationDelegate协议。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fireman</span>: <span class="hljs-title">RespondEmergencyProtocol</span>, <span class="hljs-title">FireStationDelegate</span> </span>{<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">putOutFire</span><span class="hljs-params">(with material: ExtinguisherType)</span></span> {
      <span class="hljs-built_in">print</span>(<span class="hljs-string">"Fire was put out using \(material.rawValue)."</span>)<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleEmergency</span><span class="hljs-params">()</span></span> {<font></font>
      putOutFire(with: .water)<font></font>
   }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有要做的就是让消防员被任命为消防局的代表，他将处理接到的紧急呼叫。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">let</span> firestation: <span class="hljs-type">FireStation</span> = <span class="hljs-type">FireStation</span>()<font></font>
firestation.delegate = fireman<font></font>
firestation.emergencyCallReceived()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们得到：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“用水灭火了。”</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">短路</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它只涉及Swift闭包。</font><font style="vertical-align: inherit;">它们主要用于返回尾随块或具有高阶函数。</font><font style="vertical-align: inherit;">顾名思义，最终块用于在任务完成后执行代码块。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift中的闭包类似于C和Objective-C中的闭包。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
闭包是一流的对象*，因此可以嵌套和传递闭包（类似于Objective-C中的块）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Swift中，函数是闭包的特殊情况。</font></font><br>
<br>
<i><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来源-fuckingswiftblocksyntax.com **</font></font></sup></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该资源是学习闭包语法的好地方。</font></font><br>
<br>
<sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*一流的对象-可以不受限制地使用的对象：分配给变量，从函数传递/返回，在程序执行期间创建/销毁等。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更多细节</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">（以下简称-近似翻译器）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
**该站点无法正常运行，但是在Waybackmachine中仍然有图片，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://web.archive.org/web/20150311200453/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例如</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></sup><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十一- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，电路是在配置之间切换的任何简便方法。</font><font style="vertical-align: inherit;">让我们从基本信息开始。</font><font style="vertical-align: inherit;">工作区包含各种相关项目。</font><font style="vertical-align: inherit;">一个项目可以有各种目标-这些目标确定要组装的产品和组装方法。</font><font style="vertical-align: inherit;">此外，项目可能具有各种配置。</font><font style="vertical-align: inherit;">Xcode中的模式定义了程序集的目标集合，程序集期间使用的配置以及要执行的测试的集合。</font></font><br>
 <img src="https://habrastorage.org/webt/ka/w0/s-/kaw0s-fkclhycwnfrcocjrbxwri.png"><br>
<sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">紫色显示一种可能的模式。</font></font></sup><br>
<br>
<a name="tests"></a><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">12-测试</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您花时间测试您的应用程序，那么您就走对了。</font><font style="vertical-align: inherit;">当然，这不是万能药，您无法修复每个错误，也不能保证您的应用程序不会出现任何问题。</font><font style="vertical-align: inherit;">但是我认为利弊大于利弊。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从</font><font style="vertical-align: inherit;">单元测试</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缺点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加开发时间；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">增加代码量。</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要创建模块化代码（以简化测试）；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显然在发布之前检测到大多数错误；</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化支持。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tools</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实用程序结合使用</font><font style="vertical-align: inherit;">，您将拥有使该应用程序灵活且正常运行且没有错误和崩溃的一切。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以使用许多工具来测试应用程序。</font><font style="vertical-align: inherit;">根据要跟踪的内容，可以选择一个或多个。</font><font style="vertical-align: inherit;">也许最常用的工具是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leaks</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Time Profiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocations</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">13-地理位置</font></font></anchor></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在许多应用程序中，某些功能需要定位用户。</font><font style="vertical-align: inherit;">因此，对位置如何适用于iOS有了一个大概的想法将是很好的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个名为“核心位置”的框架，该框架使您可以访问所需的所有内容：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核心位置框架允许您确定设备的当前位置或移动方向。</font><font style="vertical-align: inherit;">该框架使用可用的硬件来确定用户的位置和方向。</font><font style="vertical-align: inherit;">您可以使用此框架的类和协议来配置和安排与位置和方向有关的事件。</font><font style="vertical-align: inherit;">您还可以使用“核心位置”来跟踪跨地理区域的移动。</font><font style="vertical-align: inherit;">在iOS中，您还可以确定到蓝牙信标*的距离。</font></font><br>
<br>
<sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">*据我了解，这与</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">iBeacon</font></a><font style="vertical-align: inherit;">技术有关</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a></sup></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不错，不是吗？</font><font style="vertical-align: inherit;">查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple文档</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和那里的示例，以更好地了解框架的功能。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">14- </font></font><anchor><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 可本地化的字符串</font></font></anchor></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在任何应用程序中应实现什么。</font><font style="vertical-align: inherit;">这使您可以根据设备所在的区域来更改语言。</font><font style="vertical-align: inherit;">即使您的应用程序仅使用一种语言，将来也可能需要添加新的语言。</font><font style="vertical-align: inherit;">如果使用可本地化的字符串输入所有文本，那么您要做的就是为新语言添加Localizable.strings文件的翻译版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以通过文件检查器将资源添加到语言。</font><font style="vertical-align: inherit;">要使用NSLocalizedString获取字符串，您需要编写以下内容：</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-type">NSLocalizedString</span>(key:, comment:)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，要将新行添加到可本地化文件中，必须手动完成。</font><font style="vertical-align: inherit;">这是一个示例结构：</font></font><br>
<br>
<pre><code class="swift hljs">{
<span class="hljs-string">"APP_NAME"</span> = <span class="hljs-string">"MyApp"</span>
<span class="hljs-string">"LOGIN_LBL"</span> = <span class="hljs-string">"Login"</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是另一种语言（葡萄牙语），本地化文件：</font></font><br>
<br>
<pre><code class="swift hljs">{
<span class="hljs-string">"APP_NAME"</span> = <span class="hljs-string">"MinhaApp"</span>
<span class="hljs-string">"LOGIN_LBL"</span> = <span class="hljs-string">"Entrar"</span><font></font>
...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
甚至还有实现复数的方法。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终分享您所学。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-尤达大师</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
希望本文对您有所帮助！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501436/index.html">具有第二种错误可能性的图像上的数字识别算法</a></li>
<li><a href="../zh-CN501438/index.html">3D游戏渲染的工作原理：照明和阴影</a></li>
<li><a href="../zh-CN501440/index.html">Zabbix 5.0发布</a></li>
<li><a href="../zh-CN501442/index.html">初学者的基本Linux命令</a></li>
<li><a href="../zh-CN501448/index.html">我们如何描述独特的敏捷课程</a></li>
<li><a href="../zh-CN501454/index.html">在功能测试中使用PostgreSQL的六个技巧</a></li>
<li><a href="../zh-CN501456/index.html">Android上的Qt：我们如何赋予作者冥想应用程序以新生</a></li>
<li><a href="../zh-CN501458/index.html">延迟死亡或如何用懒惰埋葬潜在客户</a></li>
<li><a href="../zh-CN501460/index.html">面向IT人员的在线测验的宣布：Google的名字，硅谷的故事和leap问题</a></li>
<li><a href="../zh-CN501462/index.html">Robo Sumo：智能机器人大战</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>