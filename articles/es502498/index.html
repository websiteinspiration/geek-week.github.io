<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑 🥉 🚴🏼 Mejores prácticas para mejorar el rendimiento en C # 👿 👧🏼 🐯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos. Hemos preparado una traducción de otro material útil en la víspera del inicio del curso "C # Developer" . Disfruta leyendo.
 
 
 
 Como ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mejores prácticas para mejorar el rendimiento en C #</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502498/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola a todos. </font><font style="vertical-align: inherit;">Hemos preparado una traducción de otro material útil en la víspera del inicio del curso </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Disfruta leyendo.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/q4/xs/kv/q4xskv5-ia4gfwlhgm1hx5e1gdc.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como recientemente hice una lista de las mejores prácticas en C # para Criteo, pensé que sería bueno compartirla públicamente. El propósito de este artículo es proporcionar una lista incompleta de plantillas de código que deben evitarse, ya sea porque son cuestionables o porque simplemente funcionan mal. La lista puede parecer un poco aleatoria, porque está ligeramente fuera de contexto, pero </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sus elementos se encontraron en nuestro código en algún momento y causaron problemas de producción. Espero que esto sirva como una buena prevención y evite sus errores en el futuro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También tenga en cuenta que los servicios web de Criteo se basan en código de alto rendimiento, de ahí la necesidad de evitar un código ineficiente. En la mayoría de las aplicaciones, no habrá una diferencia tangible notable al reemplazar algunas de estas plantillas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y por último, pero no menos importante, algunos puntos (por ejemplo </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) ya se han discutido en muchos artículos, por lo que no me detendré en ellos en detalle. </font><font style="vertical-align: inherit;">El objetivo es formar una lista compacta de puntos a los que debe prestar atención, y no proporcionar un cálculo técnico detallado para cada uno de ellos.</font></font><a name="habracut"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincrónicamente esperando código asincrónico</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca espere sincrónicamente tareas inacabadas. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esto se aplica a, pero no se limita a: </font></font><code>Task.Wait, Task.Result, Task.GetAwaiter().GetResult(), Task.WaitAny, Task.WaitAll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como generalización: cualquier relación síncrona entre dos subprocesos de grupo puede causar el agotamiento del grupo. </font><font style="vertical-align: inherit;">Las causas de este fenómeno se describen en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este artículo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si se puede invocar su código desde un contexto de sincronización, utilícelo </font></font><code>ConfigureAwait(false)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para cada una de sus llamadas en espera. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que esto </font></font><code>ConfigureAwait</code> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo</font></font><code>await</code><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es </font><b><font style="vertical-align: inherit;">útil cuando se utiliza una palabra clave </font></b><b><font style="vertical-align: inherit;">. </font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por ejemplo, el siguiente código no tiene sentido:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//  ConfigureAwait        </span>
<span class="hljs-keyword">var</span> result = ProcessAsync().ConfigureAwait(<span class="hljs-literal">false</span>).GetAwaiter().GetResult();</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vacío asíncrono</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca lo use</font></font><code>async void</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">La excepción lanzada en el </font></font><code>async void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">método se propaga al contexto de sincronización y generalmente hace que toda la aplicación se bloquee. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no puede devolver la tarea en su método (por ejemplo, porque está implementando la interfaz), mueva el código asincrónico a otro método y llámelo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">interface</span> <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Implementation</span> : <span class="hljs-title">IInterface</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">//      ,</span>
        <span class="hljs-comment">//      </span><font></font>
        _ = DoSomethingAsync();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DoSomethingAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite asíncrono siempre que sea posible </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por costumbre o por memoria muscular, puedes escribir algo como:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque el código es semánticamente correcto, </font></font><code>async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se requiere el </font><font style="vertical-align: inherit;">uso de una palabra clave </font><font style="vertical-align: inherit;">aquí y puede generar una sobrecarga significativa en un entorno altamente cargado. </font><font style="vertical-align: inherit;">Intenta evitarlo siempre que sea posible:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">CallAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client();
    <span class="hljs-keyword">return</span> _client.GetAsync();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, tenga en cuenta que no puede recurrir a esta optimización cuando su código está envuelto en bloques (por ejemplo, </font></font><code> try/catch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font><code>using</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Correct</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> client.GetAsync();<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Incorrect</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> Client())<font></font>
    {<font></font>
        <span class="hljs-keyword">return</span> client.GetAsync();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la versión incorrecta ( </font></font><code>Incorrect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), el cliente puede eliminarse antes de que </font></font><code>GetAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se </font><font style="vertical-align: inherit;">complete la </font><font style="vertical-align: inherit;">llamada, ya que la tarea dentro del bloque de uso no se espera en espera.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparaciones regionales</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no tiene ninguna razón para usar comparaciones regionales, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use siempre comparaciones ordinales</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aunque debido a las optimizaciones internas, esto no importa mucho para los formularios de presentación de datos en EE. UU., La comparación es un orden de magnitud más lento para los formularios de presentación de otras regiones (¡y hasta dos órdenes de magnitud en Linux!) </font><font style="vertical-align: inherit;">Dado que la comparación de cadenas es una operación frecuente en la mayoría de las aplicaciones, la sobrecarga aumenta significativamente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConcurrentBag </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca lo use </font></font><code><code>ConcurrentBag&lt;</code>T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sin benchmarking</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Esta colección fue diseñada para casos de uso muy específicos (cuando la mayoría de las veces el elemento está excluido de la cola por el hilo que lo puso en cola) y sufre serios problemas de rendimiento si se usa para otros fines. Si necesita una colección flujos seguros, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prefieren ConcurrentQueue </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font><code>&gt;</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ReaderWriterLock / ReaderWriterLockSlim </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nunca lo use </font><font style="vertical-align: inherit;">sin benchmarking. </font></font><code><code>ReaderWriterLock&lt;T&gt;</code>/ReaderWriterLockSlim&lt;T<code>&gt;</code></code><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aunque el uso de este tipo de primitiva de sincronización especializada cuando se trabaja con lectores y escritores puede ser tentador, su costo es mucho mayor que el simple </font></font><code>Monitor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(utilizado con la palabra clave </font></font><code>lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Si el número de lectores que realizan la sección crítica al mismo tiempo no es muy grande, la concurrencia no será suficiente para absorber el aumento de la sobrecarga y el código funcionará peor.</font></font><br>
<br>
</h3><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefiere funciones lambda en lugar de grupos de métodos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere el siguiente código:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(i =&gt; Filter(i));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resharper sugiere reescribir el código sin una función lambda, que podría verse un poco más limpia:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(Filter);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desafortunadamente, esto lleva a la asignación de memoria dinámica para cada llamada. </font><font style="vertical-align: inherit;">De hecho, la llamada se compila como:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(<span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter));<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto puede tener un impacto significativo en el rendimiento si el código se llama en una sección muy cargada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El uso de funciones lambda inicia la optimización del compilador, que almacena en caché al delegado en un campo estático, evitando la asignación. </font><font style="vertical-align: inherit;">Esto solo funciona si es </font></font><code>Filter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estático. </font><font style="vertical-align: inherit;">De lo contrario, puede almacenar en caché el delegado usted mismo:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">private</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt; _filter;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Constructor</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    _filter = <span class="hljs-keyword">new</span> Predicate&lt;<span class="hljs-keyword">int</span>&gt;(Filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">GetItems</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _list.Where(_filter);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">Filter</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> element</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Convertir enumeraciones en cadenas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Llamando </font></font><code>Enum.ToString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>.net</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es bastante caro, ya que la reflexión se utiliza para convertir el interior, y una llamada al método virtual en los provoca estructura de empaquetado. </font><font style="vertical-align: inherit;">Esto debe evitarse tanto como sea posible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las enumeraciones a menudo se pueden reemplazar con cadenas constantes:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">//       Numbers.One, Numbers.Two, ...</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Numbers<font></font>
{<font></font>
    One,<font></font>
    Two,<font></font>
    Three<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Numbers</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> One = <span class="hljs-string">"One"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Two = <span class="hljs-string">"Two"</span>;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> Three = <span class="hljs-string">"Three"</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si realmente necesita usar una enumeración, considere almacenar en caché el valor convertido en un diccionario para amortizar los gastos generales.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comparación de enumeración</font></font></h2><br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: esto ya no es relevante en .net core, desde la versión 2.1, JIT realiza la optimización automáticamente.</font></font></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al usar enumeraciones como banderas, puede ser tentador usar el método </font></font><code>Enum.HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">Flags</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Options<font></font>
{<font></font>
    Option1 = <span class="hljs-number">1</span>,<font></font>
    Option2 = <span class="hljs-number">2</span>,<font></font>
    Option3 = <span class="hljs-number">4</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> Options _option;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> _option.HasFlag(Options.Option2);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código provoca dos paquetes con la asignación: uno para la conversión </font></font><code>Options.Option2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font><code>Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y el otro para una llamada virtual </font></font><code>HasFlag</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para la estructura. </font><font style="vertical-align: inherit;">Esto hace que este código sea desproporcionadamente caro. </font><font style="vertical-align: inherit;">En cambio, debe sacrificar la legibilidad y utilizar operadores binarios:</font></font><br>
 <br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">IsOption2Enabled</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> (_option &amp; Options.Option2) == Options.Option2;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementación de métodos de comparación de estructuras.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al usar una estructura en las comparaciones (por ejemplo, cuando se usa como clave para un diccionario), debe anular los métodos </font></font><code>Equals/GetHashCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La implementación predeterminada usa reflexión y es muy lenta. </font><font style="vertical-align: inherit;">La implementación generada por Resharper suele ser bastante buena. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede obtener más información sobre esto aquí: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devblogs.microsoft.com/premier-developer/performance-implications-of-default-struct-equality-in-c</font></font></a></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evite empaques inapropiados cuando use estructuras con interfaces</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere el siguiente código:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntValue</span> : <span class="hljs-title">IValue</span><font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SendValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LogValue</span>(<span class="hljs-params">IValue <span class="hljs-keyword">value</span></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hacer </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estructurado puede ser tentador para evitar asignar memoria dinámica. </font><font style="vertical-align: inherit;">Pero desde </font></font><code>AddValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>SendValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se espera interfaz y las interfaces tienen una semántica de referencia, el valor será embalado con cada llamada, negando los beneficios de esta "optimización". </font><font style="vertical-align: inherit;">De hecho, habrá incluso más asignaciones de memoria que si </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fuera una clase, ya que el valor se empaquetará de forma independiente para cada llamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está escribiendo una API y espera que algunos valores sean estructuras, intente utilizar métodos genéricos:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> IntValue : IValue<font></font>
{<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoStuff</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">new</span> IntValue();<font></font>
<font></font>
    LogValue(<span class="hljs-keyword">value</span>);<font></font>
    SendValue(<span class="hljs-keyword">value</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> SendValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> LogValue&lt;T&gt;(T <span class="hljs-keyword">value</span>) <span class="hljs-keyword">where</span> T : IValue<font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aunque la conversión de estos métodos a universal parece inútil a primera vista, en realidad le permite evitar el empaquetado con asignación en el caso de que </font></font><code>IntValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sea ​​una estructura.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cancelación Suscripciones aceptadas siempre en línea</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando cancela </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, todas las suscripciones se ejecutarán dentro del hilo actual. </font><font style="vertical-align: inherit;">Esto puede conducir a pausas no planificadas o incluso a puntos muertos implícitos.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
cts.Token.Register(() =&gt; Thread.Sleep(<span class="hljs-number">5000</span>));<font></font>
cts.Cancel(); <span class="hljs-comment">//     5 </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No puedes escapar de este comportamiento. </font><font style="vertical-align: inherit;">Por lo tanto, al cancelar </font></font><code>CancellationTokenSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pregúntese si puede permitir que su hilo actual sea capturado de manera segura. </font><font style="vertical-align: inherit;">Si la respuesta es no, envuelva la llamada </font></font><code>Cancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dentro </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para ejecutarla en el grupo de subprocesos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource continuaciones a menudo en línea</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al igual que las suscripciones </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, las continuaciones </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">son a menudo en línea. </font><font style="vertical-align: inherit;">Esta es una buena optimización, pero puede causar errores implícitos. </font><font style="vertical-align: inherit;">Por ejemplo, considere el siguiente programa:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ManualResetEventSlim _mutex = <span class="hljs-keyword">new</span> ManualResetEventSlim();<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Deadlock</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> ProcessAsync();<font></font>
        _mutex.Wait();<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">var</span> tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">bool</span>&gt;();<font></font>
        <font></font>
        Task.Run(() =&gt;<font></font>
        {<font></font>
            Thread.Sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">//  - </span>
            tcs.SetResult(<span class="hljs-literal">true</span>);<font></font>
            _mutex.Set();<font></font>
        });<font></font>
        <font></font>
        <span class="hljs-keyword">return</span> tcs.Task;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        Deadlock().Wait();<font></font>
        Console.WriteLine(<span class="hljs-string">"Will never get there"</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La llamada </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hace que la continuación se </font></font><code>await ProcessAsync()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecute en el hilo actual. </font><font style="vertical-align: inherit;">Por lo tanto, la declaración </font></font><code>_mutex.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se ejecuta mediante el mismo subproceso que debería llamar </font></font><code>_mutex.Set()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo que conduce a un punto muerto. </font><font style="vertical-align: inherit;">Esto se puede evitar pasando el parámetro </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si no tiene una buena razón para descuidarlo, use siempre la opción </font></font><code>TaskCreationsOptions.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">al crear </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga cuidado: el código también se compilará si se utiliza </font></font><code><b>TaskContinuationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en su lugar </font></font><code><b>TaskCreationOptions</b>.RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero se ignora los parámetros y las continuaciones aún estarán en línea. </font><font style="vertical-align: inherit;">Este es un error sorprendentemente común porque </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">precede al </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autocompletado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Run / Task.Factory.StartNew</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si no tiene ninguna razón para usar </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, elija siempre </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ejecutar una tarea en segundo plano. </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utiliza valores predeterminados más seguros y, lo que es más importante, desempaqueta automáticamente la tarea devuelta, lo que puede evitar errores no obvios con métodos asincrónicos. </font><font style="vertical-align: inherit;">Considere el siguiente programa:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ProcessAsync</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);<font></font>
        Console.WriteLine(<span class="hljs-string">"Processing done"</span>);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>[] args</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> Task.Factory.StartNew(ProcessAsync);<font></font>
        Console.WriteLine(<span class="hljs-string">"End of program"</span>);<font></font>
        Console.ReadLine();<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesar de su apariencia, el Fin del programa se mostrará antes que el Procesamiento realizado. </font><font style="vertical-align: inherit;">Esto se debe a que </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volverá </font></font><code><code>Task&lt;Task&gt;</code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y el código solo espera una tarea externa. </font><font style="vertical-align: inherit;">El código correcto podría ser </font></font><code>await Task.Factory.StartNew(ProcessAsync).Unwrap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o </font></font><code>await Task.Run(ProcessAsync)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo hay tres casos de uso válidos </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ejecutar una tarea en otro planificador.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Realizar una tarea en un hilo dedicado (usando </font></font><code>TaskCreationOptions.LongRunning</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font></li>
<li>       (  <code>TaskCreationOptions.PreferFairness</code>).</li>
</ul><br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">   .</a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es502486/index.html">El libro "Carrera con la epidemia. Antibióticos contra las superbacterias "</a></li>
<li><a href="../es502490/index.html">Intermitentes creencias restrictivas. ¿Para qué y qué da?</a></li>
<li><a href="../es502492/index.html">Innovaciones en Zextras Suite y Zimbra OSE</a></li>
<li><a href="../es502494/index.html">7 errores de un Black Friday y cómo funciona Magento Cloud - video</a></li>
<li><a href="../es502496/index.html">Fácil acceso web a aplicaciones PHP LabVIEW VI a través del servidor ActiveX</a></li>
<li><a href="../es502500/index.html">La evolución de un escáner de pasaportes: desde artesanías de madera contrachapada hasta negocios reales</a></li>
<li><a href="../es502504/index.html">Rodea el dígito del usuario</a></li>
<li><a href="../es502508/index.html">Trolley Robot 2.0. Parte 2. Gestión en rviz y sin ella Elementos de belleza en rviz</a></li>
<li><a href="../es502510/index.html">Que guardar en la nube</a></li>
<li><a href="../es502512/index.html">Resultados del concurso de expertos en sofás: las reglas del poking científico</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>