<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏱️ 📹 👧🏼 Webアプリケーションでのメモリリークとの戦い 🚴🏿 🤽🏿 ✌🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="サーバー上でページが形成されるWebサイトの開発から、クライアントでレンダリングされる単一ページのWebアプリケーションの作成に移行したとき、ゲームの特定のルールを採用しました。それらの1つは、ユーザーのデバイス上のリソースの正確な処理です。つまり、メインストリームをブロックしたり、ラップトップのフ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Webアプリケーションでのメモリリークとの戦い</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバー上でページが形成されるWebサイトの開発から、クライアントでレンダリングされる単一ページのWebアプリケーションの作成に移行したとき、ゲームの特定のルールを採用しました。それらの1つは、ユーザーのデバイス上のリソースの正確な処理です。つまり、メインストリームをブロックしたり、ラップトップのファンを「回転」させたり、スマートフォンのバッテリーを入れたりしないでください。 Webプロジェクトの対話性の改善、およびそれらの動作が通常のアプリケーションの動作に似ているという事実を交換しました。これは、サーバーレンダリングの世界には存在しない新しいクラスの問題です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような問題の1つはメモリリークです。</font><font style="vertical-align: inherit;">適切に設計されていない1ページのアプリケーションは、メガバイトまたはギガバイトのメモリを簡単に飲み尽くしてしまいます。</font><font style="vertical-align: inherit;">背景タブに静かに座っている場合でも、ますます多くのリソースを使用できます。</font><font style="vertical-align: inherit;">そのようなアプリケーションのページは、法外な量のリソースをキャプチャした後、大幅に「スローダウン」し始める場合があります。</font><font style="vertical-align: inherit;">さらに、ブラウザは単にタブをシャットダウンして、ユーザーに「何か問題が発生した」と伝えることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題が発生しました</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、サーバー上でレンダリングされたサイトも、メモリリークの問題の影響を受ける可能性があります。しかし、ここではサーバーのメモリについて話しています。同時に、ユーザーがページ間を移動するたびにブラウザがメモリをクリアするため、このようなアプリケーションがクライアントでメモリリークを引き起こす可能性はほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリリークのトピックは、Web開発の出版物では十分にカバーされていません。それでも、ほとんどの重要な単一ページアプリケーションは、メモリリークの影響を受けることはほぼ間違いありません。それらを扱うチームが、この問題を検出して修正するための信頼できるツールを持っている場合を除きます。ここでのポイントは、JavaScriptでは、特定の量のメモリをランダムに割り当て、このメモリを解放するのを忘れることが非常に簡単であることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事の著者（翻訳は本日公開）は、Webアプリケーションのメモリリークとの闘いにおける彼の経験を読者と共有し、効果的な検出の例も示します。</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれについてほとんど書かれていないのですか？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、メモリリークについてほとんど記述されていない理由についてお話します。</font><font style="vertical-align: inherit;">ここにはいくつかの理由があると思います：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーの不満の欠如：ほとんどのユーザーは、Webの閲覧中にタスクマネージャーを注意深く監視することに忙しくない。</font><font style="vertical-align: inherit;">通常、開発者は、メモリリークが深刻でアプリケーションが機能しなくなったり、アプリケーションの速度が低下したりするまで、ユーザーからの苦情はありません。</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       «»     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React、Vue、SvelteなどのWebアプリケーションを開発するための最新のライブラリとフレームワークは、アプリケーションのコンポーネントモデルを使用します。このモデル内で、メモリリークを引き起こす最も一般的な方法は次のようなものです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">これは、プロジェクトにメモリリークを「装備」するために必要なすべてです。</font><font style="vertical-align: inherit;">これを行うには、呼び出すだけ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でaddEventListenerの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">いくつかのグローバルオブジェクト（のような</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あるいは</font></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または何か他のものに類似の）、およびコンポーネントをアンマウントするときに、使用してイベントリスナ削除することを忘れて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、removeEventListenerの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法を</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、コンポーネント全体のリークが発生するため、この結果はさらに悪化します。</font><font style="vertical-align: inherit;">これは、メソッドがに</font></font><code>this.onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アタッチされているため</font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">このコンポーネントとともに、その子コンポーネントのリークが発生します。</font><font style="vertical-align: inherit;">このコンポーネントに関連付けられているすべてのDOMノードがリークする可能性が非常に高いです。</font><font style="vertical-align: inherit;">その結果、状況は非常に早く制御不能になり、非常に悪い結果につながる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決する方法は次のとおりです。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリリークが最も頻繁に発生する状況</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験上、次のAPIを使用するとメモリリークが最も頻繁に発生することがわかります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ここで、メモリリークが最も頻繁に発生します。</font><font style="vertical-align: inherit;">問題を解決するには、適切なタイミングで電話をかけるだけで十分</font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  «»   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  —  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>      .   ,    ,     —   ,      . , ,  «»   ,        .    «»     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバルオブジェクトによって表されるリポジトリ。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などを使用してアプリケーションの状態を制御する</font><font style="vertical-align: inherit;">場合、状態ストアはグローバルオブジェクトで表されます。</font><font style="vertical-align: inherit;">その結果、このようなストレージを不注意に処理すると、不要なデータが削除されず、サイズが常に増加します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">無限のDOM成長。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用せずにページが無限スクロールを実装する場合</font><font style="vertical-align: inherit;">、これは、このページのDOMノードの数が無制限に増える可能性があることを意味します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記では、メモリリークが最も頻繁に発生する状況を検討しましたが、もちろん、他にも問題が発生するケースは多数あります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メモリリークの特定</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、メモリリークを特定するという課題に移ります。そもそも、既存のツールのどれもこれに非常に適しているとは思いません。私はFirefoxのメモリ分析ツールを試し、EdgeとIEのツールを試しました。 Windows Performance Analyzerでもテスト済み。しかし、これらのツールの最高のものは、まだChromeデベロッパーツールです。確かに、これらのツールには、知っておく価値のある多くの「鋭い角」があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chrome開発者が提供するツールの中で、</font><font style="vertical-align: inherit;">ヒープスナップショットを作成できる</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タブからの</font><font style="vertical-align: inherit;">プロファイラーに最も関心が</font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あります。 Chromeでメモリを分析するためのツールは他にもありますが、メモリリークの検出において、それらのツールから特別な利点を引き出すことができませんでした。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープスナップショットツールを使用すると、メインストリーム、Webワーカー、またはiframe要素のメモリのスナップショットを取得できます。Chrome</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ツールウィンドウが前の図のように表示されている場合、ボタンをクリックする</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、選択した仮想マシンのメモリ内のすべてのオブジェクトに関する情報</font><font style="vertical-align: inherit;">が表示</font><font style="vertical-align: inherit;">されます調査したページのJavaScript。これには</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、で参照されるオブジェクト、呼び出し</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">使用されるコールバックによって参照されるオブジェクト</font><font style="vertical-align: inherit;">などが含まれます。メモリのスナップショットは、調査されたエンティティの作業の「凍結された瞬間」として認識でき、このエンティティによって使用されるすべてのメモリに関する情報を表します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真を撮った後、漏れを見つける次のステップに進みます。これは、開発者によると、メモリリークが発生する可能性のあるシナリオを再現することです。たとえば、特定のモーダルウィンドウを開いたり閉じたりしています。同様のウィンドウが閉じられた後、割り当てられたメモリの量は、ウィンドウが開かれる前に存在していたレベルに戻ることが予想されます。したがって、彼らは別の写真を撮り、それを以前に撮った写真と比較します。実際のところ、画像の比較は私たちにとって最も重要な機能です</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のスナップショットを作成してから、メモリリークを引き起こす可能性のあるアクションを実行してから、別のスナップショットを作成します。</font><font style="vertical-align: inherit;">リークがない場合、割り当てられたメモリのサイズは等しくなりますが</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
、これ</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は理想的なツールとはほど遠いものです。</font><font style="vertical-align: inherit;">これには、知っておくべきいくつかの制限があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ガベージコレクションを開始</font><font style="vertical-align: inherit;">するパネルの小さなボタン</font><font style="vertical-align: inherit;">（</font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">をクリックして</font><font style="vertical-align: inherit;">も、メモリが本当にクリアされていることを確認するために、連続して数枚の写真を撮る必要がある場合があります。</font><font style="vertical-align: inherit;">私は通常3つのショットを持っています。</font><font style="vertical-align: inherit;">ここでは、各画像の合計サイズに注目する価値があります。最終的には安定します。</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   —      ,       ,    .</li>
<li>           «».             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、アプリケーションが非常に複雑な場合、スナップショットを比較すると、多くの「リーク」オブジェクトに気付く場合があります。</font><font style="vertical-align: inherit;">メモリリークと間違えられる可能性があるため、状況は多少複雑になります。</font><font style="vertical-align: inherit;">疑わしいことの多くは、オブジェクトを操作するための通常のプロセスにすぎません。</font><font style="vertical-align: inherit;">一部のオブジェクトが占有しているメモリは、他のオブジェクトをこのメモリに配置するためにクリアされ、何かがキャッシュにフラッシュされます。そのため、対応するメモリはすぐにはクリアされません。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">情報のノイズを乗り切る</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
情報のノイズを突破する最善の方法は、メモリリークを引き起こすと思われるアクションを繰り返すことです。たとえば、最初のショットをキャプチャした後にモーダルウィンドウを一度だけ開閉する代わりに、これは7回行うことができます。なぜ7？はい、7が顕著な素数だからです。次に、2番目のショットを撮り、最初のショットと比較して、特定のオブジェクトが7回（または14回、または21回）「漏出した」かどうかを確認する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヒープのスナップショットを比較します。画像3と画像6を比較していることに注意してください。実際には、Chromeでガベージコレクションセッションを増やすために、3枚連続で撮影しました。さらに、一部のオブジェクトが7回「リーク」したことに注意してください。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
もう1つの便利なトリックは、最初の写真を作成する前に、最初の手順を1回実行することです。メモリーリーク。これは、プロジェクトでコード分割が使用されている場合に特に推奨されます。このような場合、疑わしいアクションを最初に実行したときに、必要なJavaScriptモジュールが読み込まれ、割り当てられたメモリの量に影響を与える可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、メモリの総量ではなく、オブジェクトの数に特別な注意を払う必要がある理由について質問があるかもしれません。ここでは、「漏れる」メモリの量を減らすために直感的に努力していると言えます。この点で、使用されているメモリの総量を監視する必要があると思うかもしれません。しかし、このアプローチは、重要な理由の1つとして、私たちにはあまり適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かが「漏れる」場合、それは（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジョーアームストロングを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">語り返す</font><font style="vertical-align: inherit;">）バナナが必要な</font><font style="vertical-align: inherit;">ために起こり</font><font style="vertical-align: inherit;">ますが、最終的にはバナナ、それを保持するゴリラ、さらにはすべてのジャングルが必要になります。メモリの総量に注目すると、それはジャングルの「測定」と同じであり、興味のあるバナナではありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴリラがバナナを食べています。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
では、上の例に戻り</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。リークソースは、関数を参照するイベントリスナーです。そして、この関数は、配列、文​​字列、オブジェクトなどの優れた要素へのリンクを格納するコンポーネントを参照します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画像間の違いを分析し、エンティティが占有するメモリの量でエンティティを並べ替えると、多くの配列、線、オブジェクトを確認できます。これらのほとんどは、リークに関連していない可能性があります。そして結局のところ、それがすべて始まったまさにそのイベントリスナーを見つける必要があります。彼は、彼が言及しているものと比較して、記憶をほとんど取りません。リークを修正するには、ジャングルではなくバナナを見つける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、「リークされた」オブジェクトの数でレコードをソートすると、7つのイベントリスナーに気付くでしょう。</font><font style="vertical-align: inherit;">そして、おそらく7つのコンポーネントと14のサブコンポーネント、そしておそらく他の何か。</font><font style="vertical-align: inherit;">この番号7は、それにもかかわらず、かなり目立って異常な番号であるため、全体像から目立つはずです。</font><font style="vertical-align: inherit;">この場合、不審な行為が何回繰り返されてもかまいません。</font><font style="vertical-align: inherit;">画像を調査する際、疑いが正当化されると、「漏えいした」オブジェクトと同じ数だけ記録されます。</font><font style="vertical-align: inherit;">これにより、メモリリークの原因をすばやく特定できます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクツリー分析</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スナップショットを作成するためのツールには、「リンクチェーン」を表示する機能があり、他のオブジェクトによって参照されているオブジェクトを見つけるのに役立ちます。</font><font style="vertical-align: inherit;">これにより、アプリケーションが機能します。</font><font style="vertical-align: inherit;">このようなリンクの「チェーン」または「ツリー」を分析することで、「リーク」オブジェクトにメモリが割り当てられた場所を正確に見つけることができます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンクのチェーンを使用すると、「漏出」オブジェクトを参照しているオブジェクトを見つけることができます。</font><font style="vertical-align: inherit;">これらのチェーンを読み取るときは、その下にあるオブジェクトが上にあるオブジェクトを参照することを考慮する必要があります。</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記の例では</font><font style="vertical-align: inherit;">、イベントリスナーによって参照される</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロージャ（</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で参照さ</font><font style="vertical-align: inherit;">れると呼ばれる変数があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ソースコードへのリンクをクリックすると、かなりわかりやすいプログラムのテキストが表示されます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードを前の図と比較すると</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、その図は</font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を参照する</font><font style="vertical-align: inherit;">クロージャで</font><font style="vertical-align: inherit;">あること</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">わかり</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人為的な例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">実際のメモリリークはそれほど明白ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープスナップショットツールにはいくつかの制限があることに注意してください。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショットファイルを保存してから再度アップロードすると、コードを含むファイルへのリンクは失われます。</font><font style="vertical-align: inherit;">つまり、たとえば、スナップショットをダウンロードした場合、イベントリスナークロージャコードがファイルの22行目にあることを確認することはできません</font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この情報は非常に重要であるため、ヒープスナップショットファイルを保存したり、たとえば誰かに転送したりしても、ほとんど役に立ちません。</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> —     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> —     ,  ,   ,  «»   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、メモリリークを識別するための私の基本的な戦略の説明です。</font><font style="vertical-align: inherit;">私はこのテクニックを使って何十ものリークを検出することに成功しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、メモリリークを見つけるためのこのガイドは、実際に起こっていることのほんの一部しかカバーしていないと言わざるを得ません。</font><font style="vertical-align: inherit;">これはほんの始まりに過ぎません。</font><font style="vertical-align: inherit;">さらに、ブレークポイントのインストール、ロギング、修正のテストを処理して、問題が解決するかどうかを判断できる必要があります。</font><font style="vertical-align: inherit;">そして、残念ながら、これらすべては、本質的に、時間の深刻な投資につながります。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動メモリリーク分析</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このセクションでは、メモリリークの検出を自動化する適切な方法が見つからなかったという事実から始めたいと思います。 Chromeには独自の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">があり</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">が、プライバシー上の理由から、</font><font style="vertical-align: inherit;">十分に詳細なデータ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">収集</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">することはできません</font></a><font style="vertical-align: inherit;">。その結果、このAPIを本番環境で使用してリークを検出することはできません。 W3C Webパフォーマンスワーキンググループは以前に</font><font style="vertical-align: inherit;">メモリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について説明しました</font><font style="vertical-align: inherit;">が、そのメンバーは、このAPIを置き換えるように設計された新しい標準にまだ合意していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テスト環境では</font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Chromeフラグ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">--enable-precise-memory-info</font></a><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">データ出力の細分性を高めることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ヒープのスナップショットはまだChromedriver自身のチームを使用して作成することができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このチームには、すでに説明したのと同じ制限があります。このコマンドを使用する場合、上記の理由により、3回呼び出してから、最後の呼び出しの結果として受信したものだけを使用するのが理にかなっている可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントリスナーはメモリリークの最も一般的な原因であるため、私が使用する別のリーク検出手法について説明します。これは、APIのモンキーパッチを作成すること</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、リンクの数を数えてゼロに戻ることを確認</font><font style="vertical-align: inherit;">することで構成され</font><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これがどのように行われるかの一例。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chromeデベロッパーツールでは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネイティブAPI </font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">て、特定の要素に関連付けられているイベントリスナーを見つける</font><font style="vertical-align: inherit;">こともできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、このコマンドは開発者ツールバーからのみ使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Matthias Binensが別の便利なChromeツールAPIについて教えてくれたことを付け加えておきます。</font><font style="vertical-align: inherit;">これらは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これにより、特定のコンストラクターを使用して作成されたすべてのオブジェクトに関する情報を取得できます。</font><font style="vertical-align: inherit;">Puppeteerでのメモリリーク検出の自動化に関するこのトピックに関する優れた資料を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下に示し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webアプリケーションでのメモリリークの検索と修正はまだ始まったばかりです。ここでは、私の場合、うまくいくいくつかのテクニックについて話しました。しかし、これらの技術の適用には依然として一定の困難と時間がかかることを認識しておく必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らが言うように、あらゆるパフォーマンスの問題と同様に、事前のピンチはポンドの価値があります。おそらく、リークが発生した後でリークを分析するのではなく、適切な模擬テストを準備する方が便利だと思う人もいるでしょう。そして、それが1つのリークではなく複数のリークである場合、問題の分析はタマネギの皮むきのようなものに変わる可能性があります。1つの問題が修正された後、別の問題が発見され、このプロセスが繰り返されます（そして、いつも、タマネギからのように） 、目の涙）。コードレビューは、一般的なリークパターンの特定にも役立ちます。しかし、これ-あなたが知っているなら-どこを見るか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScriptは、メモリを安全に操作するための言語です。</font><font style="vertical-align: inherit;">したがって、Webアプリケーションでメモリリークが発生しやすくなるという皮肉があります。</font><font style="vertical-align: inherit;">確かに、これは一部にはデバイスのユーザーインターフェイスの機能によるものです。</font><font style="vertical-align: inherit;">マウスイベント、スクロールイベント、キーボードイベントなど、多くのイベントをリッスンする必要があります。</font><font style="vertical-align: inherit;">これらのパターンをすべて適用すると、メモリリークが発生しやすくなります。</font><font style="vertical-align: inherit;">しかし、私たちのWebアプリケーションがメモリを控えめに使用するように努めることで、パフォーマンスを向上させ、「クラッシュ」から保護することができます。</font><font style="vertical-align: inherit;">さらに、これによりユーザーデバイスのリソース制限の尊重を示します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の皆様！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Webプロジェクトでメモリリークが発生しましたか？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja490610/index.html">バイドゥ、カリフォルニア州ロボモービルの自律性評価でWaymoを上回る</a></li>
<li><a href="../ja490612/index.html">Scalaでのトランザクションへの機能的アプローチ、または独自の有用なモナドの記述</a></li>
<li><a href="../ja490616/index.html">先週のフロントエンドの世界からのフレッシュな素材のダイジェスト第404号（2020年2月24日〜2020年3月1日）</a></li>
<li><a href="../ja490618/index.html">Goroutineスタックバッファー</a></li>
<li><a href="../ja490620/index.html">「ニューラルネットワークを復元しました」という言葉を聞くと、バックアップを確認するために登ります</a></li>
<li><a href="../ja490624/index.html">機能ポリシーHTTPヘッダーとWebブラウザーコントロール</a></li>
<li><a href="../ja490626/index.html">データの完全なガイド-* HTML属性</a></li>
<li><a href="../ja490628/index.html">CSSがページ解析をブロックする場合はどうすればよいですか？</a></li>
<li><a href="../ja490630/index.html">ディスクからのNumPy配列の読み込み：memmap（）とZarr / HDF5の比較</a></li>
<li><a href="../ja490634/index.html">3月2日から8日までのモスクワでのデジタルイベント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>