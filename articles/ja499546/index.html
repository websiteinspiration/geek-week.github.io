<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍🌾 💅🏿 🧖 アナログビデオカメラEVR-Y2022Fのファームウェア開発 🖕🏻 🏇 🛐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前回の記事では、独自のファームウェアを作成するために、アナログビデオカメラのデバイスについて詳細に検討しました。すでに述べたように、カメラには未知の起源のマイクロコントローラーがあります。通常のAVRよりもはるかに豊富です。3.3Vと1.8Vの2つの電源電圧があり、DSP機能も備えています。オートフ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アナログビデオカメラEVR-Y2022Fのファームウェア開発</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499546/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事では、独自のファームウェアを作成するために、アナログビデオカメラのデバイスについて詳細に検討しました。すでに述べたように、カメラには未知の起源のマイクロコントローラーがあります。通常のAVRよりもはるかに豊富です。3.3Vと1.8Vの2つの電源電圧があり、DSP機能も備えています。オートフォーカスアルゴリズムの実装について考えたとき、この結論に達しました。それでも、STM32などの複雑なMKを使用したことがなかったからといって、私はそれらを好みませんでした。私は間違いなく、AVR MKの1つを使用してファームウェアを実装することにしました。したがって、すでにこの段階で、オートフォーカス機能の実装は非常に扱いにくい、または不可能であることに気づき始めました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の腕に落ちたのはATmega128 MKでした。特に、念のため、ビデオプロセッサからのデジタルビデオストリームの入力用にMKポート全体を予約することにしたので、ATmega8 MKは結論の数の点で十分ではありません。まず、自分のファームウェアに含まれる機能、特に、元のファームウェアに含まれていない機能と、無視する必要がある機能を特定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デジタルビデオストリームを分析するためのオートフォーカスアルゴリズムの変形について考えてみましょう。ビデオストリームデータが「CK」パルスと同期したバイトの交互であることがわかりました。ビデオストリームのバイトは、ビデオ信号のY、Cr、Cbコンポーネントのレベルを8ビットグラデーション（256レベル）でエンコードします。つまり、このカメラのビデオプロセッサから出力されるデジタルビデオは、コンポーネント多重化されています。明るさ（Y）に関する情報はビデオストリームの2バイトごとに含まれ、色に関する情報は2分の1の頻度で表示されます。すなわち、赤の色差信号の情報と青の色差信号の情報が４バイトおきに含まれている。したがって、ストリームは次のシーケンスを表します：Cb0、Y0、Cr0、Y1、Cb2、Y2、Cr2、Y3、Cb4、Y4、Cr4、Y5、...。つまり、各ピクセルの明るさに関する情報は隙間なく提供されますが、ピクセルの色に関する情報はコンポーネントごとに順番に提供されます。この間引きは、細部の色に対する鈍感な特性と、ビデオ信号の色帯域の減少によるものです。これらのプロパティは、アナログテレビやビデオのデジタル化で使用されます。上記の「圧縮」（カラーサブサンプリング）のコンポーネント比率は、4：2：2です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートフォーカスアルゴリズムを機能させるには、輝度コンポーネントのみを分析するだけで十分です。これは、ビデオストリームを「バイト単位」でインターセプトすることによっても簡単に実現できます。 CK周波数が約18 MHzの場合、CK / 2は9 MHzです。これは、ATmega128 MKでかなり達成できるようです。水平同期パルスと垂直同期パルスにより、コントローラーは画像の任意の領域を「カウント」して分析できます。おそらく、オートフォーカスアルゴリズムの場合は、ラスターの中心のみを分析すれば十分です。明らかに、焦点が良くなるほど、画像は鮮明になり、ビデオ信号の周波数帯域が広くなります（RFコンポーネントが増えます）。つまり、デジタルビデオストリームのフラグメントに高速フーリエ変換（FFT）アルゴリズムを適用して、RFコンポーネントを分析することが可能です（必要な場合でも）。この場合、毎回フォーカスフォーカスをひねる必要があります。数学的な最適化手法として「半除算」手法を使用します。したがって、最良の結果を得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なアーキテクチャのMKでは不可能だったので、オートフォーカス機能を気にしませんでしたが、いずれにしても、デジタルビデオ用にポートを予約しました。オートフォーカスの代わりに、元のファームウェアでは利用できなかった他の多くの機能を実装することにしました。ただし、これを行うには、ビデオカメラを静止状態に制限する必要があります。これは、ビデオ監視では一般的です。その後、カメラは自動および手動の両方で、特別なメカニズムを使用して水平面および垂直面で回転できると想定されています。カメラが自動的に特定のオブジェクトに向けられると、その球座標が制御デバイスのメモリに事前に保存され、ズームとフォーカスの「座標」も変化します。これも事前に選択され、メモリに保存されます。管理はPELCO-Dプロトコルに従って編成できます。さらに、このプロトコルの仕様には、このビジネスのための特別なチームがあります。もちろん、ズームとフォーカスの座標は、特定の距離に対して「ペア」になります。つまり、特定の距離にあるオブジェクトに焦点が合います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファームウェアプログラムの作成を開始する前に、MKのどのペリフェラルとどのような結論が関係するかを考える必要があります。次に、ボードをカメラ内部の独自のMKで配置して固定する方法を考える必要があります。そして、それは可能な限り便利で保守しやすいものでした。 MKのボードを使用することにしました。その結論は完全に左右にルーティングされます。ボードは、スペースがほとんどないカメラの下部に配置され、取り外し可能な接続で保持されます。同時に、ボード自体にコネクタの「ピン」があり、カメラの側面に嵌合ソケットがあります。レスポンスソケットについては、カメラの側面のサイズのアダプターボードをさらに2つ作成することにしました。これらのカードのラメラは、カメラの上側、メインボードに直接行きます。各ラメラは、カメラのメインボード上の目的のポイントに配線されると想定されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MKを使用したボードの開発中に、ビデオカメラに時計（RTC）を追加するというアイデアがあり、RTC DS1307ボードに配置されたI2Cラインを強調表示しました（クオーツとバッテリー、そして念のためにEEPROM 24AA512）。手で。また、ボードの上端には、SPIおよびJTAGプログラマーを接続するためのコネクターがあります。元のマザーボードでは、MKは12 MHzクオーツからクロック供給されています。私も同じです。一般に、UARTを明確に動作させるには、水晶を11.0592 MHzに配置する方が適切です。取り外し可能なジョイントの「くし」の間の距離は、事前に注意深く計算しました。メインボードの下のフレームにねじ込まれる5ボルトの「Krenka」からMKを供給することにしました（ヒートシンクとしても機能します）。図に示すように、電源はヒューズFB801の直後の入力電圧12Vから取得されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pk/rs/q8/pkrsq8mtjjredo8w2mfne5goziy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 1.マイクロコントローラーの電源管理。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
「SprintLayout」でボードを描画しているときに、MKの各ピンがコネクタに「out」で出力される目的を知りました。結果はそのような絵です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bm/95/xg/bm95xgf-akgycofwc_mdsjp8rki.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 2.追加のプリント回路基板のスケッチ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
実を言うと、この記事の執筆段階でサイドボード（端に沿って）を描きました。でも実はカッターで作ったんです。最も成功したオプションではないことが判明しました。そして、MKを使用したボード自体は曲がって作成されました。どういうわけか、サイド補助ボードをカメラフレームの側面にねじ込み、フラックスナットをPCBの銅表面にはんだ付けしました。実際のところ、側面のスペースはほとんどなく、カメラの蓋は背中合わせに「締め付け」られています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の図は、MKの結論の分布とその目的を示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cc/ry/d2/ccryd2b_viknimo-w0asy0j8fuy.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 3.マイクロコントローラーの結論の目的。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
コメントすべき点はたくさんあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPIプログラマー（STK200 +）の場合、出力「PEN」は不要でした。アクティベーションは通常通り「リセット」によって行われます。ただし、「MISO」と「MOSI」の代わりに、MKには個別のインターフェース（PDI / PDO）があり、「CLK」ラインが結合されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADCの基準電圧として、MK自体に電源が供給されているのと同じ5Vを選択しました。 （元の回路と同様に）3.3Vを個別に取得しようとしましたが、同時に落とし穴がありました。また、5V基準電圧に切り替えるには、図に示すように回路を少し変更する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mn/od/wr/mnodwrbakf5xlxkq1qskzeuhmkc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 4. 5V基準電圧のボタンの変換。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
つまり、R505抵抗の片側を3.3Vの電源側からはんだ付けせず、代わりにMK電源ラインから5Vを抵抗に加える必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
設計されたボード内でのみ使用されるMKの結論のうち、関係するのは3つだけです。 RTCを含む1 Hzのパルス信号がPB7に到着して時刻を更新します。ピンPD0とPD1はI2Cバスに割り当てられています。ハードウェアi2c（TWI）インターフェイスがこれらの出力に接続されているにもかかわらず、CVAVRライブラリ「i2c.h」を使用してプログラムで実装されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「RESET」MCピンが出力されますが、MKリセットは、外部リセットチェーンなしで自然に発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオフィールドの読み取り精度を高めるために、HDおよびVDクロックパルスが外部割り込みポートを介してMKに到達することがわかっています。ただし、オートフォーカス機能を除き、不要となりました。ズームおよびフォーカス制限スイッチからの信号は、外部割り込みの隣接ポートに送られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ポート「A」MKはデジタルビデオストリーム用に予約されています。ポート「C」はSD用に完全に予約されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PD4ピンはTX / RX RS-485の切り替えに使用されます。元の回路にはスイッチングがありませんでした。MAX485チップの2番目と3番目のレグは接地されていました。元のMKは、PELCO-Dを介してカメラを制御するためのデータしか受信できませんでした。小さなアップグレードをすることにしました。アイデアはこれでした。ビデオカメラが高い位置にあり、密閉された筐体内にある場合、ファームウェアをすばやく更新することは不可能です。そして、そのような必要性は確実に発生します。さまざまなバグを排除し、機能を改善することは、初めての定期的なプラクティスになります。したがって、私はMKのブートローダーを実装するというアイデアを思いつき、RS-485を介してリモートでファームウェアをリモートで更新しました。この場合、双方向の交換が非常に望ましいです。ブートローダーについては、この記事の別の部分になります。そして、MAX485（2および3レッグ）をこのMKピンに接続するために、最初と2番目のボードに小さな変更を加える必要があります。これらのボードはループケーブルで接続されており、そのコネクタにはバックライト制御用の未使用の「IRL」接点があります。 2番目の（メイン）ボードでは、R520抵抗器のはんだを外し、代わりにアダプターボードを通過するワイヤーを対応する出力にATmega128 MKにはんだ付けする必要があります。そして、最初のボードでは、U202の2脚と3脚をはんだ付けしないで曲げ、それらを一緒にはんだ付けし、配線から1コネクタJ302の空き出力まで引き出します。これらの回路変更操作を図に示します。これは、アダプタボードを介して、ATmega128 MKから対応する出力に進みます。そして、最初のボードでは、U202の2脚と3脚をはんだ付けしないで曲げ、それらを一緒にはんだ付けし、配線から1コネクタJ302の空いている出力まで引き出します。これらの回路変更操作を図に示します。これは、アダプタボードを介して、ATmega128 MKから対応する出力に進みます。そして、最初のボードでは、U202の2脚と3脚をはんだ付けしないで曲げ、それらを一緒にはんだ付けし、配線から1コネクタJ302の空き出力まで引き出します。これらの回路変更操作を図に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/20/oe/qu20oe_mzvupcc4mpsbtg4omwma.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 5. TX / RX MAX485を制御するためのTRXラインの構成。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ATmega128に搭載された2つのUART ｲﾝﾀｰﾌ There ｰ ｽがあります。この場合、ピンの最初のインターフェース（ピン2、3）がSPIプログラマーのインターフェースと組み合わされているため、2番目のインターフェース（ピン27、28）を使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理事会では、MKのほとんどすべての結論が関係しています。ポート「G」の結論は未使用であることが判明しました。ちなみに、MKに基づいてプログラムでクロックを実装することは可能でした。主電源がオフのときに時間をカウントするためにバッテリーを使用してスリープモードを提供します。別の低周波クオーツを接続するという結論さえあります。しかし、私はこれに悩まされず、DS1307を平手打ちしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の図は、MKを使用したボードの各出力の目的を示しています。さらに、各ピンからのワイヤがはんだ付けされるメインボードのどの側に、どの側に条件付きでマークされています。また、コメントも必要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i0/fd/df/i0fddfrritx4bjzwqgsfl3bu1r4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 6. MKによる追加支払いの結論の割り当て。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ズームおよびフォーカス制限スイッチからの信号は、割り込みポートだけでなく、ADC入力にも送られます。実はSDの勉強の段階でもそのような特徴に気づきました。ズームまたはフォーカスメカニズムが「ゼロ」の場合、トレーラーからの出力信号は「中間」状態になります。そのようなまれなケースをよりよくキャプチャするために、ADCを使用することにしました。もちろん、これは非常に有能なアプローチではありませんが、これを行うことで、テストファームウェアの初期化段階で時々発生する問題をすばやく解決しました。したがって、アルゴリズムの安定性を高めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I2CからのSDA / SCL信号は、念のためコネクタに接続されているだけで、このボードの外では使用されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDを制御するための各ピンの名前は、実際の接続に従って署名されます。先を見据えたデータの接続は、デバッグ段階でようやく修正されました。多くの混乱がありましたが、エラーは位相の交互にのみあり、逆に正確であり、それらの順序にはありませんでした。 「4-1-2-3」（ズームの場合）と「2-3-4-1」（フォーカスの場合）は同じであり、「1-2-3-4」も同様です。そして基礎として取られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の最後に</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（不名誉にならないように）</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの写真を示します。 1つ目は、追加の回路基板を表示したビデオカメラの底面図です。 2つ目は、封印された標準MK（正確にはマイクロプロセッサ）、多数のワイヤージャンパー、およびその他のSnotを備えたビデオカメラのメインボードを上から見た図です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ISIS 7 Professional（Proteus）プログラムでの予備テストと共にプログラム（ファームウェア）を作成しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/qr/f7/mtqrf7iej-6e3adbtcg-bgghokq.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 7.プロテウスでのプロジェクトのビュー。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
キャラクタージェネレーターとビデオプロセッサ（もちろん、Proteusにはありません）の独自のチップの代わりに、SPIデバッガーをインストールしました。それらの助けを借りて、MKがSPIによって送信するバイトを制御すると便利です。ただし、これらのバイトに対する実際の反応は、ハードウェアで直接制御されます。 Proteusを使用すると、実際のDVRからのPELCO-Dコマンドを監視およびデバッグできます。これを行うには、オプションとして、最も単純な一方向アダプターRS485-&gt; RS232を介してDVRをコンピューターのCOMポートに接続する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、開発とモデリングを始めました。 Excelはこれに大きく貢献しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、タイマーとその構成を決定する必要があります。 1つのタイマー-ステッピングモーターの回転と、ボタンを押したままのボタンの繰り返し操作の実装を実現します。メニューで設定中にこのボタンまたはそのボタンを押し続けると、SDの操作が除外されます。また、メニューの外側にあるズームまたはフォーカスコントロールボタンの1つを押している間、SDは対応する時間パラメーターと共に回転します。したがって、競合はありません。 SDのPWMを実装するために2番目のタイマーを使用する予定でしたが、時間が経つにつれてそれを放棄することにしました。実際、私の場合、オートフォーカスがない場合、PWMは必要ありません。さらに、伝達メカニズムはらせん構造になっているため、静止状態では、SDを直流で「保持」することはできず、メカニズムはどこにもクリープしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、データシートに従って文字ジェネレータの文字のアルファベットを修正し、標準のアルファベットASCIIと比較する必要があります。文字ジェネレーターのアルファベットは128文字で構成されており、最後の半分のサイズです。たとえば、キャラクタージェネレーターのキリル文字は完全に存在しませんが、そのアプリケーションの特徴である特殊文字（太陽、砂時計、小さな男、メモ、電話など）があります。 256要素の「smb [256]」の配列を作成し、それをEEPROM MKに配置しました。表記smb [i] = adrは、文字ジェネレーターのアドレスadrに、ASCIIコードiの文字があることを意味します。シンボルiが文字ジェネレータのアルファベットにない場合、配列要素の値はアドレス0x7Eの「スペース」を参照します。つまり、配列の要素のほぼ半分が「0x7E」の値を持っています。この配列は、下の図に表形式で示されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yo/_b/_g/yo_b_gqswkjfk1smuefynrwgs0e.png"><br>
<i>. 8.    ASCII    PD6464A.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ADCを介してボタンを処理する方法を検討する必要があります。オームの法則によれば、ボタンをクリックすると、ADCの入力での電圧値を簡単に計算できます。その後、区間の境界を計算するのは簡単です。その中間は同じ応力値になります。合計で6つの間隔が取得されます。そのうちの5つは各ボタンに対応し、1つは押されていない（ボタンが押されていない）ことに対応しています。ハードウェアレベルでは、ADC MKはボタンからの電圧値を定期的に分析します。アンチバウンス用のタイマーは、ADCクロックサイクルの計算に基づいて実装できます。デバッグ段階では、プログラムのこの部分に落とし穴がありました。詳細を書く価値はないと思います。この機能の明確な作業を達成するために、私は長い間いじくり回さなければなりませんでした。ボタン認識機能はADC割り込みセクションに配置され、その出力にはボタン番号があります。うつ病フラグと解放フラグ。ボタンの追加処理は、メインプログラムサイクルで行われます。ボタンのポーリング周波数（ADC周波数）は12000/128 = 93.75（kHz）で、128は可能な最大の分周器です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、1つまたは別のPELCO-Dボーレートに応じて、UART構成のUARTレジスタ値の配列UBRR1をコンパイルしました。これは、メニューの設定のリストから選択できます。</font><font style="vertical-align: inherit;">これらの値は、MKのデータシートの式を使用して計算できます。また、AVRウィザードの自動コンフィギュレーターを使用して取得することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、メニューのモデリングを開始しました。</font><font style="vertical-align: inherit;">これは、プログラムを書くための主で時間のかかる段階です。</font><font style="vertical-align: inherit;">原則として、標準ファームウェアのメニューを繰り返すつもりはありませんでしたが、それ以外は階層構造（セクション内のセクション）に複雑化することにしました。</font><font style="vertical-align: inherit;">以下は、私が自分で作成したモデルとメニューの定義の説明です。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取ることができません</font></font></b>
                        <div class="spoiler_text">     .<br>
          .<br>
      .<br>
          .<br>
       «MENU».<br>
<br>
    «»    .<br>
    «»  «»       .<br>
  «»       .<br>
  «»       .<br>
  (   )   ,         .<br>
   « »,     .<br>
<br>
   :<br>
 — ;<br>
 — ;<br>
 — ;<br>
 — .<br>
<br>
    ,   ,   .<br>
    &lt;&gt;.<br>
     .<br>
         "&lt;..&gt;".<br>
      «».<br>
      ,   .<br>
        ( ) .<br>
    "&lt;..&gt;"      .<br>
        ,    .<br>
           .<br>
<br>
      .<br>
     .<br>
        .<br>
     "&lt;•&gt;" ( ).<br>
     "&lt; &gt;" ().<br>
      «».<br>
<br>
    .<br>
           .<br>
     «l*l» (,   «l»).<br>
     «l l» (,   «l»).<br>
        «».<br>
<br>
  ,       .<br>
     .<br>
           .<br>
            .<br>
       : «000», «00», «0».<br>
        .<br>
         : ": ".<br>
  —      (    )       .<br>
 ,   ,     «»  «».<br>
    «»     1.<br>
    «»     1.<br>
<br>
         .<br>
         .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メニューナビゲーションは、「Total Commander」を介したファイルやフォルダのナビゲーションと多少似ています。このメニューモデルの実装コードはそれほど複雑ではありませんが、非常に面倒です。重要な変数は2つあります。アクティブなページの数とページ上のアクティブな位置の数です。どちらの変数でも、2つの「スイッチケース」関数が相互に機能します。この機能のペアは、ボタン「左」、「右」、「メニュー」を押すプロセスに関与します。各場所（各ボタン、ページ、現在のアイテム）に特定のアクションが登録されています。各メニューページには、すべての銘刻文字とパラメータを使用して画面にページを表示する機能があります。ページ出力関数を実装する前に、私は以前に「セルごと」と言っているように、Excelでそれらをモデル化しました。したがって、画面フィールド上の各シンボルのセルの座標がより明確に表示され、この情報はプログラミング段階で必要になります。下の図では、例として、PELCO-Dボーレートがリストから選択されている9ページのビューを示しました。ページのインターフェイス要素はラジオボタンです。それに加えて、最初の段落&lt;..&gt;はこのセクションを終了することです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c0/s1/uy/c0s1uyuaoh9dawm-bqpf5g4pmjg.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 9. ExcelでOSDをモデリングします。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
各ページのポイント数を反映する配列も作成しました。上ボタン、下ボタンを押す処理で使用します。これは、コードを削減し、switch-case関数の使用を回避するために行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボタンを押しながら仮想プレスを繰り返すことは、フラグである整数変数で機能する「スイッチケース」関数によってタイマー割り込みの本体に実装されています。フラグの値は、特定のページおよび特定のメニュー項目のボタンのアクションごとに一意です。仮想クリックが必要な場所でのみ、シリアル番号としてフラグに割り当てられます。同時に、「スイッチケース」関数の内部（タイマー割り込みの本体）には、ボタンのアクションを実装する関数のコピーが配置されます。メモリを節約するために、ボタン処理関数の通常の呼び出しに「ショートカット」（リンク）を配置することができました。それはさらに合理的ですが、プロジェクトをできるだけ早く終了したかったので、現時点では、それをより良くする方法を考える忍耐力がありませんでした。そして、ATmega128のメモリはかなりたくさんであることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、ビデオプロセッサ、キャラクタージェネレータ、および必要な機能を備えたRTC DS1307を操作するための「ライブラリ」を実装しました。その後、この情報またはその情報を格納するEEPROM MKのアドレスを決定しました。最初の32バイトは、メニュー設定情報を格納するために予約されています。次の32バイトは、画面に表示したり、標準コマンド「Pelco-D Write Char。スクリーンに。」 EEPROM領域の次の256バイトはアルファベット用に予約されています（前述のように、ASCIIから文字ジェネレーターのアドレスへの文字の変換）。最後に、次の128バイトは、ズーム/フォーカスの「プリセット」（テンプレート）を保存するために予約されています。オートフォーカスがないため、この機能を導入しました。これについては記事の冒頭で書きました。合計32のテンプレート。ズームまたはフォーカスの座標は2バイトでエンコードされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それとは別に、SD管理の実装について書いておく価値があります。 SDの回転は、タイマー割り込みブロックで関数StepF（）およびStepZ（）を呼び出すことによって実現されます。回転速度は、このタイマーの設定によって決まります。上記の関数の実装により、フォーカスまたはズームのプロモーションが（それぞれ）最小のステップで実装されます。ズームレンズの回転とフォーカスの間、最終的な位置が制御されます。最大フォーカスの位置と最小ズームの位置は、プログラムでは定数（それぞれ280と-600）で表されます。しかし、最小焦点の位置と最大ズームの位置-変数F_minおよびZ_max（より正確には、関数）の形式。このアプローチは、右下隅が切り取られた非長方形の作業領域によって促進されました。 F_minとZ_maxの値を計算するには、区分的に定義された関数F_min（Z）とZ_max（F）が使用されます。それに、SDズームがZ（ズーム座標）&gt; 500で正の方向に回転するとき、後者が座標&lt;（-180）を持っている場合、SDフォーカスは同じ方向に同時に回転します。つまり、原則として、最大ズーム位置は現在のフォーカス位置によって制限されませんが、600に制限されます。五角形領域の対応する角度境界に達したときに2つのSDが同時に回転し、この段階での動きが「カット側」に沿って発生する（グラフで解釈した場合） ）メカニズムの観点からは、これは前の記事で説明したプロセスに相当します。SDがなく、ズームノードとフォーカスノードを手動で移動すると、パスの端にあるズームノードがフォーカスノードを「引き」ます。ズーム座標がフォーカス座標を支配するという事実のために（私がF（Z）依存を考慮する理由は、しかし、その逆はありません）、Step_F（）関数で同様のズーム「スクロール」手順を実装し始めませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のファームウェアでは、ズームとフォーカスの変更速度は固定値でした。これは常に便利なわけではありません。私のファームウェアでは、ズームとフォーカス速度の4つの値を（個別に）提供しました。これらの値は、メニューからも、この機能に割り当てられたPELCO-Dコマンドを使用しても選択できます。これらの4つの値は、利便性に基づいてデバッグ段階で事前に選択されてから、ファームウェアに入力されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BD初期化関数init_MR（）は、ズームとフォーカスのメカニズムを座標系にバインドするために必要です。ビデオカメラの電源を入れるたびに実行されます。彼女の作品のアルゴリズムはおおよそ以下のとおりです。まず、ズームまたはフォーカスがゼロ点にあると想定し、外部割り込み機能によってリミットスイッチからの信号のバウンスをキャッチしようとします。ズームまたはフォーカスが「ゼロ」（光学トレーラーのパーティション分割の境界）の場合、トレーラーの出力での信号は、論理「0」と「1」の間の「中間」状態になることにすぐに注意します。このようなケースはほとんどありませんが、除外することはできません。ただし、割り込み機能はバウンスなどの信号を解釈しません。 ADC MKを使用するようになったのはそのためです。2つの空きチャネルの制限スイッチとズーム制限スイッチからの信号をトリガーします。そう、最初のステップは、8ビット精度のリミットスイッチからの信号の「デジタル化」です。これは、単一のアナログ-デジタル変換を使用して行われます。この場合の基準電圧は5Vであり、リミットスイッチからの論理レベル「1」は3.3Vであることを覚えておく価値があります。論理「0」の場合、ADC値はゼロになり、「1」の場合、3.3 / 5 * 255 = 168になります。 1つまたは別のトレーラーからの信号値が2から165の範囲に入る場合（ファジー間隔がとられる）、これは対応するノードがすでに「ゼロ」にあり、このノードの初期化手順を停止できることを意味します。それ以外の場合は、トレーラー信号の論理値（「0」または「1」）によって、ノードが配置されている部分（半分）を判別する必要があります。 SDの回転方向はこれに依存します。いずれにしても、SDはこの方向に回転させる必要があります。対応するノードが「ゼロ」（リミットスイッチ）に向かって移動するようにします。このようにして、リミットスイッチに到達するまでのステップ数の計算と同時にモータードライブの回転が開始されます。論理レベルの違いに応じて外部割り込みの機能を決定する、対応するリミットスイッチに到達するとすぐに、モータードライブが逆回転します。同じステップ数だけ反対方向に回転し、元の位置に戻ります。初期化関数を終了する前に、対応する符号を持つ各BDのステップ数の値が対応する変数にコピーされます。上記の手順は、同じ関数内のフォーカスとズームに対して（順番にではなく）独立して行われます。初期化段階でのモータードライブの回転速度は、別の定数によって決定され、SMが確実に正しく回転するための最大速度に対応します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラの電源を入れる前に、ズームが負の領域にあり、フォーカスが正の領域にあった例を考えてみます。図は、ステッピングモーターの初期化手順中のポイント（Z; F）の軌跡を概略的に示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1p/59/6d/1p596dlrqriwqff1jh4jfrtvu-8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 10.ズームとフォーカスを初期化するプロセス。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ポイントAは、ズームとフォーカスの初期位置です。両方のノードの動きは、同じ速度（初期化速度）で「ゼロ」の方向に発生します。ポイントBでは、フォーカスがズームよりもゼロに近いため、フォーカスはゼロに到達します。その後、フォーカスが逆になります。ポイントCで、フォーカスは初期化プロセスを完了し、元の位置に戻ります。同時に、ズームはまだ「ゼロ」に向かって動いています。ポイントDでは、「ゼロ」に達し、元の位置（ポイントA）に戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
init_MR（）初期化関数に加えて、goto_zf（z、f）関数があります。</font><font style="vertical-align: inherit;">名前に基づいて、あるプリセットから別のプリセットに切り替えることを目的としています。これについては、記事の冒頭で説明しました。</font><font style="vertical-align: inherit;">移行中のステッピングモーターの回転速度は、初期化中と同じです。</font><font style="vertical-align: inherit;">ズームとフォーカスの移行プロセスは同時に実行されます。</font><font style="vertical-align: inherit;">つまり、点（z1; f1）から点（z2; f2）に移動する必要がある場合、2つのSDの同時回転が開始されます。</font><font style="vertical-align: inherit;">たとえば、| f2-f1 | &lt;| z2-z1 |の場合、フォーカスSDはより早く停止します。</font><font style="vertical-align: inherit;">これを下の図に示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/-y/ya/fb-yyanbovlb6i3pe6rxsfh0ax8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">11.プリセットを選択するときにズームとフォーカスを変更するプロセス。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロマークリミッター通過中のステッピングモーターの全動作時間を通じて、対応する座標はゼロになります。</font><font style="vertical-align: inherit;">そして、これは理論的にはこれを行うことができないという事実にもかかわらずです。</font><font style="vertical-align: inherit;">ただし、実際には、SDの1〜2ステップのエラーがまだあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元のファームウェアとは異なり、私の場合、ズームとフォーカスを（ボタンからとPELCO-Dの両方から）制御するときに、段階的に移動する可能性を備えたことを付け加えておきます。これは次のように機能します。 4つのボタンのいずれかをクリックしてズームまたはフォーカスを制御すると、対応するSDが1ステップ回転して、ズームまたはフォーカスノードの動きを最小限に抑えます。ボタンを離さない場合、しばらくするとステッピングモーターの通常の回転が始まります。この遅延は、経験的に事前に選択されます。この機能は、ボタンを押しながら仮想的に繰り返し押すのと似ています。この機能により、貧弱なインターネット接続を介してPELCO-Dリモートデバイスでズームまたはフォーカスを制御するときにボタンを「固定」する問題が解消されます。より正確には、機会は無礼として発生し、ズームやフォーカスを微調整します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PELCO-Dコマンドのインタープリターは、PTZを介して負荷を切り替えるデバイスと同じように作成されます。私は以前、Habréに関する別の小さな記事をこのシンプルなデバイスに当てました。元のファームウェアとは異なり、ズームおよびフォーカス制御コマンドは、対応するボタンを押すことを完全に指します。つまり、PELCO-Dのズームボタンとフォーカスボタンを使用してメニューを「登る」ことができます。そして、PELCO-Dを介してリモートでメニューを呼び出すため、または「メニュー」ボタンを押すために、このカメラモデルではこの機能が使用されていないため、絞り開放ボタンをそれと比較しました。したがって、押すための5つの基本的なPELCO-Dコマンドと、ボタンを離すための5つの基本的なコマンドがあります。さらに、記事全体でさりげなく書いたので、「Set Preset」、「Clear Preset」、「Go To Preset」、「Write Char。スクリーン」、「スクリーンのクリア」、「ズーム速度の設定」、「フォーカス速度の設定」に移動します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションがメニューで有効になっている場合、RTC付きの日付と時刻は、古いVHSカメラと同様に、画像の左下隅に表示されます。また、メニューでも出力フォーマットを選択できます。日時の横の画面でも曜日を表示することが可能です。時計に加えて、ズームとフォーカスの現在の座標が追加情報として画面に表示されます。このオプションは、主にデバッグ段階で必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実装したメニューの機能についてお話します。時間の経過とともに、必要に応じてメニューが改訂されます。一部の機能は削除でき、一部は追加できます。 SPlanで作成したメニュー構造とページビューを下の図に示します。赤い矢印-セクションに入ります。青い矢印-セクションを終了します。メニューの各ページに青い矢印は描かず、たとえば2つだけ描いた。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/vs/mp/rlvsmpdeoixbmwlg-jmf2uwj51m.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。 12.画面メニューの構造。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のメニューのいくつかのセクションは、オリジナルのセクションと少し似ています。まず、これらは最初の2つのセクション、ホワイトバランスと露出です。 3番目のセクションでは、PELCO-Dカメラのアドレスを指定し、リストからデータレート（ボーレート）を選択できます。 4番目のセクションでは、日付と時刻を扱います。日付、時刻、曜日を設定し、4つの表示形式から1つを選択し、表示方法を選択できます。 5番目のセクション-ズームとフォーカスのプリセット（テンプレート）の操作。番号で呼び出したり、消去したり上書きしたりできます。また、メニューのこのセクションでは、フォーカスまたはズームを変更するための4つの速度のいずれかを選択できます。 5番目のセクションでは、カテゴリ3のバイト9にあるビデオプロセッサのパラメータを編集できます。これは、ビデオ信号のバーストコンポーネントのレベルと反転、およびビデオミラーリングです。メニューの最後のセクションはデバッグ用です。これを使用して、任意のカテゴリの任意のバイトの任意の値をビデオプロセッサに書き込むことができます。値は、10進形式と2進形式の両方で設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、ブートローダーについて少し説明します。すでに書いたように、RS-485を介してビデオカメラをリモートフラッシュするには、ブートローダーが必要です。最初は、自分で完全にブートローダーを実装することを考えていました。ただし、時間を節約するために、インターネットにある、すでに実装されている既製のダウンローダーの1つを使用することにしました。さらに、私はそれらを使用したことがなく、理論的なレベルでのみそれらを理解しています。ブートローダーを選択するための重要な基準の1つは、RS-485サポートです。通常、AVRダウンローダーはUART RS-232で動作します。また、RS-485をサポートするブートローダーは、MKからPCへのデータ転送中にRS-485トランシーバー（たとえば、MAX485）を切り替えるためにMK側に追加の出力が割り当てられる点でのみ異なります。 MKをフラッシュすると、ブートローダーは成功または失敗した記録に関する情報をコンピューターに送信します。最初のブートローダーファームウェア付きのMKのフラッシュメモリだけでなく、EEPROMも記録できることがわかりました。書き込みに加えて、データを読み取ることもできます。しかし、アセンブラのソースコードを使用したこのプロジェクトは非常にわかりにくく、理解できませんでした。さらに、このブートローダーの主な重点は、複数のデバイスを個別にフラッシュする機能であり、それらをRS-485ネットワークから切断せずに、以前に配線されていたアドレスで各デバイスにアクセスしました。 RS-485ネットワークの別のトポロジを使用しているため、このような機能は必要ありません。ビデオカメラをDVRからPCにすばやく切り替えることができます。 2番目のブートローダーはドイツのChip45です。ソースコードはパブリックドメインではなく、作者から購入できます。代わりに、異なるAVR MK、異なるUARTインターフェイス（私の場合のように複数ある場合）には数百のHEXファイルがあります。RS-485またはRS-232から選択できます。要するに、すべての機会に。同時に、著者は、RS-485の場合、TX / RX切り替えピンは固定されており、UARTで実際には使用されないコントローラーインターフェイスのXCK UARTピンに対応することに注意します。私の場合、Atmega128 MKの2番目のUARTインターフェースのXCKの30番目のピンはPORTD.5であり、ズームとフォーカス制限スイッチをアクティブにするために使用されます。私がすでに書いたように、研究が示したように、リミットスイッチは常にアクティブなので、原則として、この機能は必要ありません。また、必要に応じて、この関数を他の空いている出力MKに転送できます。しかし、とにかく、特に中国デザインの「AVRユニバーサルブートローダー」と呼ばれるより興味深いブートローダーに出くわしたので、このブートローダーも印象に残りませんでした。 Chip45と同様に、MKのフラッシュメモリにのみ書き込むことができます。しかし、彼には多くの可能性があるので、私はそれを続けることにしました。これは、Cソースコードを含むAVR Studioプロジェクトとして提供されます。私はCodeVisionAVRで作業しているため、WinAVRと共にAVR Studioをインストールする必要がありました。ブートローダーファームウェアのHEXファイルを取得するには、ソースコードを独自のデバイス構成に事前に変更してプロジェクトをコンパイルする必要があり、独自の構成が必要です。プロジェクトのコンパイルは、コンパイルコマンドが記述されているbatファイル（バッチファイル）を起動することから成ります。したがって、AVR Studioのプロジェクトを開く必要はありません。ソースコードの変更は、手動で（プログラマーレベルで）、またはコンフィギュレーターを使用して行うことができます。後者の役割は、ブートローダーで動作するユーティリティの追加ウィンドウであり、これも接続されています。コンフィギュレータでは、TX / RX RS-485スイッチングのMKピン、制御点滅LEDのMKピン、ブートローダーに入るMKピン、ブートローダーに入る方法、MK名と周波数などを指定できます。さらに、標準の既知のハイパーターミナルプログラムは、ユーザープログラムをMKにロードするためのユーティリティとして機能し、つまりブートローダーで動作し、Xmodemプロトコルを使用してファームウェアをダウンロードします。また、テキストターミナルを介してブートローダーを便利かつ視覚的に操作するために、コンフィギュレーターには特別な機能「詳細モード」が用意されています。しかし、ハイパーターミナルの魅力にもかかわらず、私はブートローダーに付属のユーティリティを使用することにしました。事実、ターミナルで作業しているコンフィギュレーターで便利なVerbose機能をアクティブにすると、次のような状況に遭遇しました。ラインのデータトラフィックが「衝突」した場合（両方のデバイスがTXモード）、カムコーダーのMAX485が非常に高温になり、故障したか、RXセクションのみ（カメラへのRS-485データ送信） 。このため、私はハイパーターミナルを放棄しました。そしてもう一つ不便があります。ハイパーターミナルはHEXテキストファイルでは機能せず、バイナリファイルのみを受け入れます。したがって、16進数からビンへの追加の変換を適用する必要があります。ブートローダーHEXファイルが生成された後、PonyProgプログラムと通常のSPIプログラマーを使用して、MKにそれを縫い付けました。その結果、ブートローダーは次のように動作します。ビデオカメラの電源を入れると、ブートローダーがすぐにアクティブになります。ユーティリティからの接続を1秒間待ってから、メインファームウェアが動作を開始します。接続が正常に確立された場合、その後、点滅プロセスが始まります。同時に、RS-485ラインのもう一方の端を事前にDVRから切断し、RS485 &lt;-&gt; RS232またはRS485 &lt;-&gt; USBアダプターを介してPCに接続する必要があります。ちなみに、アダプターについて。購入したアダプタは高価なので、このようなアダプタを自分で作成する方法についての質問がありました。インターネットをざっと見て、簡単なRS485 &lt;-&gt; RS232アダプター回路を見つけました。次の図に示します。それは主に有名なMAX232およびMAX485マイクロ回路で構成され、TX / RXはツェナーダイオード回路を介してコンピューターのCOMポートコネクタの3番目の出力からの信号によって切り替えられます。つまり、MAX485はPCが送信するデータトラフィックによって切り替えられます。すべてがシンプルで独創的です。RS232またはRS485 &lt;-&gt; USB。ちなみに、アダプターについて。購入したアダプタは高価なので、このようなアダプタを自分で作成する方法についての質問がありました。インターネットをざっと見て、簡単なRS485 &lt;-&gt; RS232アダプター回路を見つけました。次の図に示します。それは主に有名なMAX232およびMAX485マイクロ回路で構成され、TX / RXはツェナーダイオード回路を介してコンピューターのCOMポートコネクタの3番目の出力からの信号によって切り替えられます。つまり、MAX485はPCが送信するデータトラフィックによって切り替えられます。すべてがシンプルで独創的です。RS232またはRS485 &lt;-&gt; USB。ちなみに、アダプターについて。購入したアダプタは高価なので、このようなアダプタを自分で作成する方法についての質問がありました。インターネットをざっと見て、簡単なRS485 &lt;-&gt; RS232アダプター回路を見つけました。次の図に示します。それは主に有名なMAX232およびMAX485マイクロ回路で構成され、TX / RXはツェナーダイオード回路を介してコンピューターのCOMポートコネクタの3番目の出力からの信号によって切り替えられます。つまり、MAX485はPCが送信するデータトラフィックによって切り替えられます。すべてがシンプルで独創的です。それは主に有名なMAX232およびMAX485マイクロ回路で構成され、TX / RXはツェナーダイオード回路を介してコンピューターのCOMポートコネクタの3番目の出力からの信号によって切り替えられます。つまり、MAX485はPCが送信するデータトラフィックによって切り替えられます。すべてがシンプルで独創的です。それは主に有名なMAX232およびMAX485マイクロ回路で構成され、TX / RXはツェナーダイオード回路を介してコンピューターのCOMポートコネクタの3番目の出力からの信号によって切り替えられます。つまり、MAX485はPCが送信するデータトラフィックによって切り替えられます。すべてがシンプルで独創的です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dg/_j/xg/dg_jxg5vy5h-i32yee8szg8urho.png"><br>
<i>. 13.   RS-232 &lt;-&gt; RS-485.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートローダーをマスターした後、暇なときにビデオカメラの光学系を研究することにしました。より正確には、ズームとフォーカスの値のどの組み合わせが、レンズから被写体までのさまざまな距離で焦点の合った画像を生成するかが私にとって興味深いものになりました。ズームとフォーカスのさまざまな相互の値の領域は、五角形の領域（ほぼ長方形）で表されることを思い出してください。たとえば、レンズから被写体までの距離を10 cmとります。ズームの引数（横軸に沿って）には、-600から600までの値の範囲があります。ビデオ画像のレンズの前にある被写体に焦点が合う各ズーム値でフォーカス値を選択する必要があります。次に、テーブルを作成する必要があります。もちろん、1200のズーム値すべてを並べ替えることは意味がありません。特定の等しいステップで数十の値を取るだけで十分です。そのようなステップとして、値50を選択しました。このステップでの各ズーム値（-600、-550、-500、...）で、フォーカス値を選択し、測定結果を記録しました。レンズから被写体までの距離を50 cm、1 m、10 m、100 mとして同様の手順を実行した結果、Excelで表示した一連の曲線が得られました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5o/_4/qi/5o_4qikxragcwmdaeespjactaoi.png"><br>
<i>. 14.  Z-F   .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフを見て、たくさんコメントしたいと思います。最小ズームでは、ほとんどすべての距離でフォーカス値が「中央」（ゼロ）よりわずかに小さくなります。距離10 cmのピンクの曲線は、約250のズーム値で終了します。これは、最小フォーカス値に対応します。この曲線は減少する特性を持ち、上に凸になります。距離1 mの赤い曲線は、形状がまったく異なります。第一に、それは単調ではなく、第二に、凸性特性に関して、変曲点があります。 10 mと100 mの距離の曲線は同様の性質を持っていますが、後者は、ちなみに実際には一致しています。したがって、測定された距離は10メートルと100メートルですが、おおよその距離です。青い曲線が0.5メートルの距離で揺れるのは何ですか。最初は測定しませんでした。この距離は、対応する曲線の断片にできるだけ近づき、領域のコーナー境界（カット）に近づくという原則にほぼ基づいて選択しました。そして、それは起こりました：この境界線は実際にカーブの断片に触れます。一般に、領域の上半分（正のフォーカス値）は実際には使用されないことに注意してください。例外は、被写体からレンズまでの距離が大きく、ズームが最大の場合です。それでも、ほとんどすべての距離（最も近い、0.5メートル未満を除く）について、低ズーム（150以下）では、フォーカス値はほとんど同じです。一般的に言えば、述べられているすべての測定事実は、光学の法則に基づいた理論的な解釈を持つ必要があります。しかし、現時点では、この種のレンズのデバイスについては知りません。最大、私が光学の分野で遭遇したのは、単純な2レンズの屈折望遠鏡の構造です。そして、このカムコーダーの場合-私は光学の仕組みを理解していませんでした。出力では、フォーカスノード（フォーカスを担当）とズームノードの2つの移動ノードしか使用できません。中にレンズがいくつあるかわかりません。これらの移動ノードに接続されている2つを想定します。フォーカスを調整すると、対応するノードが固定されていても、ズームも視覚的にわずかに変化することにも注意してください。これらの移動ノードに接続されています。フォーカスを調整すると、対応するノードが固定されていても、ズームも視覚的にわずかに変化することにも注意してください。これらの移動ノードに接続されています。フォーカスを調整すると、対応するノードが固定されていても、ズームも視覚的にわずかに変化することにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事の最後で、カムコーダーの実際のテストに進みます。たくさんの写真を撮らないことに決めましたが、すぐにビデオ全体をアップロードしました。デバイスを介してビデオキャプチャを記録し、音声はオーディオレコーダーに個別に書き込まれました。元の解像度は720 x 576です。動画をYouTubeにアップロードした後、その品質は著しく変化しました。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/H4agAlZlWW8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラの電源を入れると、最初に起こるのは、ズームのステッピングモーターの初期化であり、ビデオ画像の背景に焦点を合わせます。ビデオプロセッサの初期化手順がまだ完了していないため、この画像は白黒でAGCがありません。左下の現在の日付と時刻には、現在のカメラファームウェアのコンパイルの日付と時刻が表示されます。ファームウェアのソースコードでは、HEXコードの固定アドレスにある対応する変数を作成しました。コンパイル段階で、より正確にはその後に、システム時間から変数の値を取得し、それらをHEXファイルの目的のアドレスに挿入するプログラムが自動的に実行されると想定されています。さらに、チェックサムを再カウントする必要があります。おそらくもっと簡単な方法があります。ビデオの例では、まだこの関数を実装していないため、これらの変数はゼロです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDの初期化後、ビデオプロセッサが初期化され、ビデオ画像の背景にすぐに挨拶が表示されます。ズームとフォーカスを調整すると、その座標が右下に表示されます。ビデオでは、画像のさまざまな部分でのズームとフォーカスのテンプレート（プリセット）の保存と呼び出しの機能の使用方法を示します。プリセットをクリアすると、対応する変数は値-1に対応する値0xFFFFを取得します。この機能は原則として不要であり、除外することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバッグに使用されるメニューの最後のセクションでは、カテゴリ9バイト3のレコードを示します。このバイトに対応する関数は、メニューの前のセクションにあり、何度も書きました。バイトの現在の状態がビデオプロセッサから読み取られないため、許容できるものの1つとして手動で「48」に設定しました。その後、このバイトの個々のビットを変更して、「ミラー」および「逆バースト」機能を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メニューの最後から2番目のセクションの「バースト」レベルを調整すると、簡単に修正できる小さなファームウェアバグに気付くでしょう。その他の欠点-時々、時間を更新すると、文字にギャップが発生します。これは、ビデオカメラ内部の電子機器の「曲がった」設置によるものだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、カメラを操作すると、メニューのナビゲーションに関連する軽微な不便が見つかりました。</font><font style="vertical-align: inherit;">したがって、時間の経過とともに必要な改訂が行われる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、ほとんど忘れました。</font><font style="vertical-align: inherit;">約束通り、開発後のビデオカメラの詰め物を2枚持ってきました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m-/0-/ah/m-0-ahq2z2xqxpr988ndcfae5uu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">15.下部にあるビデオカメラの更新されたビュー。</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/gs/8_/bw/gs8_bwxf2yy1mqyrt2gmbgzoyu8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">16.上部のビデオカメラの更新されたビュー。</font></font></i><br>
<br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja499534/index.html">Pythonバックエンドサービス開発ガイド</a></li>
<li><a href="../ja499536/index.html">自分を知る方法としてのGrowbox</a></li>
<li><a href="../ja499540/index.html">3Dゲームレンダリングのしくみ：テクスチャリングとテクスチャフィルタリング</a></li>
<li><a href="../ja499542/index.html">トップファカポフシアン</a></li>
<li><a href="../ja499544/index.html">Googleスプレッドシートでニューラルネットワークを学ぶ</a></li>
<li><a href="../ja499548/index.html">マスク-他人の世話やセキュリティの幻想？</a></li>
<li><a href="../ja499550/index.html">エコシステム低コードソリューション</a></li>
<li><a href="../ja499556/index.html">MS Orleans上のゲームサーバー-パート3：概要</a></li>
<li><a href="../ja499560/index.html">Linux用Xswitcherレイアウト修正プログラム：ステップ2</a></li>
<li><a href="../ja499562/index.html">反射の加速に関する失敗した記事</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>