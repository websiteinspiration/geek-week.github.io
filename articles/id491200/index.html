<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔪 🐚 👭 Timer fungsi untuk pengontrol industri Simatic S7-1200 🍺 🖖🏻 👆🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahkan untuk seri S7-300 dan S7-400, di bawah Langkah 7, versi klasik dari timer yang ditawarkan kepada pengembang sudah cukup - ini adalah timer IEC ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Timer fungsi untuk pengontrol industri Simatic S7-1200</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan untuk seri S7-300 dan S7-400, di bawah Langkah 7, versi klasik dari timer yang ditawarkan kepada pengembang sudah cukup - ini adalah timer IEC standar, diimplementasikan sebagai blok fungsi, dan timer S5 (yang, bagaimanapun, masih ada untuk seri S7- 1500). Namun, dalam beberapa kasus, pengembang tidak menggunakan alat standar dan mengimplementasikan penghitung waktunya sendiri, paling sering dalam bentuk fungsi. Fungsi pengatur waktu seperti itu diperlukan dengan pendekatan “IT” untuk pemrograman, di mana mereka beroperasi tidak dengan contoh terpisah dari blok fungsional peralatan teknologi, dengan pengikatan input dan output yang sesuai, tetapi dengan susunan struktur. Misalnya, larik struktur tipe input diskrit. Atau larik struktur agregat. Pendekatan pemrograman ini memiliki hak untuk ada, karena memungkinkan Anda untuk secara serius menyimpan memori kerja CPU, tetapi,di sisi lain, membuat kode program sulit dibaca. Programmer pihak ketiga dan dengan tampilan sederhana dari program LAD hampir tidak dapat langsung mengetahuinya, tetapi tumpukan indeks, array, dan fungsi untuk memprosesnya tidak ada pertanyaan, di sini, tanpa dokumentasi untuk perangkat lunak (dan tanpa setengah liter, tentu saja), di mana pun.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Susunan struktur ini biasanya diproses dalam fungsi. Pada prinsipnya, tidak ada yang mencegah pemrosesan blok fungsi, tetapi selalu ada pertanyaan penting - bagaimana cara bekerja dengan timer dalam kasus ini? Penghitung waktu standar mengasumsikan angka (S5) atau turunan dari blok fungsi (IEC). Saya ingatkan Anda, ini adalah pertanyaan pemrosesan array struktur untuk PLC Simatic klasik, dan untuk "memutar" nomor timer ke dalam struktur ini, dan terlebih lagi, instance menjadi sulit atau tidak mungkin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk alasan ini, kami membuat fungsi timer sendiri sebagai fungsi. Pada prinsipnya, untuk pengoperasian timer apa pun, Anda hanya perlu mengetahui beberapa hal - keadaan input, pengaturan waktu, dan berapa banyak waktu yang telah berlalu sejak aktivasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk seri 300 dan 400, ada dua cara untuk menentukan waktu ini. </font><font style="vertical-align: inherit;">Yang pertama adalah untuk melihat runtime dari OB1 utama (ada variabel yang sesuai dalam OB1 itu sendiri) atau OB siklik dan meningkatkan akumulator waktu internal dengan setiap panggilan timer, asalkan "kebenaran" adalah input. </font><font style="vertical-align: inherit;">Bukan pilihan yang baik, karena kali ini berbeda untuk OB1 dan OB siklik. </font><font style="vertical-align: inherit;">Metode kedua adalah fungsi sistem TIME_TCK, yang, dengan setiap panggilan, mengembalikan nilai tunggal - penghitung milidetik internal prosesor sentral. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, untuk timer dari tipe TON (on delay), algoritma operasi adalah sebagai berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sisi atas permintaan respons, setel ulang output dan ingat nilai saat ini dari timer sistem TIME_TCK</font></font></li>
<li>       «»          ,        (   ,  TIME_TCK    0  (2 ^ 31 — 1),          ).   ,        .    ,    «»,    — «»</li>
<li>      «»,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan munculnya seri "seperseribu", situasinya telah sedikit berubah. Faktanya adalah bahwa garis S7-1500 mewarisi dukungan untuk panggilan sistem TIME_TCK, dan pecinta pendekatan "berdiri dan di tempat tidur gantung" (bagaimana lagi Anda dapat memanggil program yang hanya melakukan proses apa susunan struktur, saat beroperasi dengan indeks menyeramkan?) dengan tenang terus menggunakan praktik terbaik mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seri pengendali basis S7-1200 didasarkan pada arsitektur yang berbeda, dan memiliki sejumlah perbedaan dari S7-1500. Termasuk tidak adanya panggilan sistem TIME_TCK. Di jajaran pengembang yang tidak memiliki fleksibilitas berpikir yang memadai, ketidakpuasan telah hilang - tidak mungkin untuk menjalankan salinan / pasta program lama. Namun, tugas menentukan berapa banyak waktu telah berlalu sejak panggilan sebelumnya dapat dilakukan menggunakan fungsi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">runtime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi ini mengembalikan waktu yang telah berlalu sejak panggilan sebelumnya, dalam hitungan detik, sebagai nomor real LREAL dengan presisi ganda. Detail dijelaskan dalam bantuan. Untuk keperluan internal, variabel MEM tambahan (juga dari jenis LREAL) diperlukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan memberikan sumber perkiraan pertama dari fungsi, dan saya akan memberikan beberapa catatan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarasi fungsi:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan input / output, semuanya jelas: IN, Q dan PT. Saya mengatur pengaturan waktu dalam bentuk yang nyata, itu detik. Hanya ingin (tetapi sia-sia, tetapi lebih pada itu di bawah). Lebih lanjut tentang variabel area InOut. Karena kami memiliki fungsi, kami tidak memiliki area STAT, tidak ada variabel yang mempertahankan nilainya selama pemanggilan fungsi berikutnya, dan variabel tersebut diperlukan: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - untuk menentukan tepi positif dari permintaan </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM - variabel tambahan untuk panggilan sistem untuk bekerja runtime </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TimeACC - akumulator waktu , yang akan menyimpan jumlah mikrodetik dari penundaan yang sedang berjalan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variabel TimeACC, udiCycle dan udiPT ditentukan dalam format UDINT, integer yang tidak ditandatangani, 4 byte. </font><font style="vertical-align: inherit;">Terlepas dari kenyataan bahwa saya menentukan waktu sebagai nyata, dan fungsi runtime mengembalikan nyata sebanyak presisi ganda, saya lebih suka melakukan operasi penjumlahan dan membandingkan dengan operan integer sederhana untuk menghemat waktu prosesor. </font><font style="vertical-align: inherit;">Waktu dalam kasus saya diperhitungkan dalam mikrodetik. </font><font style="vertical-align: inherit;">Alasannya sederhana - jika Anda kasar waktu untuk milidetik, maka dengan OB1 hampir kosong (misalnya, jika hanya satu timer dipanggil dalam seluruh program pengontrol dan tidak lebih), "lompatan" siklus mungkin, program kadang-kadang berjalan selama 250 μs. </font><font style="vertical-align: inherit;">Tetapi dalam kasus ini, nilai maksimum yang diizinkan dari akumulator waktu adalah 4.294 detik, hampir 4.295 (2 ^ 32 - 1 = 4.294.967.295). </font><font style="vertical-align: inherit;">Tidak ada yang bisa dilakukan, "optimasi" seperti itu membutuhkan pengorbanan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teks fungsi.</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua baris pertama adalah perhitungan kembali pengaturan timer dari jumlah detik yang ditentukan dalam format NYATA ke jumlah mikrodetik. </font><font style="vertical-align: inherit;">Waktu dalam mikrodetik yang berlalu dari panggilan blok program sebelumnya juga ditentukan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, algoritma ini adalah sebagai berikut, dan saya telah memberikannya:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada sisi naik dari input IN, reset output Q dan reset akumulator waktu</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika "kebenaran" terus menjadi input, kami meningkatkan akumulator waktu dengan nilai udiCycle yang sudah diketahui dan membandingkannya dengan pengaturan waktu. </font><font style="vertical-align: inherit;">Jika pengaturan waktu terlampaui, timer telah bekerja, berikan output "true", jika tidak, berikan output "false"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam hal menerapkan input palsu ke input IN, reset output Q dan reset akumulator waktu.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di akhir fungsi, untuk menentukan tepi input IN, ingat nilai sebelumnya. </font><font style="vertical-align: inherit;">Juga berikan output ENO (saat menggunakan fungsi dalam bahasa grafis, seperti LAD) nilai output Q. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memastikan bahwa fungsi tersebut bekerja, setelah itu menjadi menarik untuk mengevaluasi kecepatannya dan, jika perlu, meningkatkan (sudah terlihat pada pandangan pertama bahwa sejumlah perhitungan idle dan buang waktu CPU sia-sia). </font><font style="vertical-align: inherit;">Untuk mengevaluasi kinerja, saya mendeklarasikan susunan 1000 struktur data timer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deklarasi struktur. </font><font style="vertical-align: inherit;">Fieldnya menduplikasi variabel input dan output dari fungsi timer.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Array struktur dideklarasikan di blok data global TortureTON:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode berikut dijalankan di blok organisasi OB1:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diumumkan 1000 "instance" dari timer, masing-masing mengatur waktu 10 detik. Semua 1000 timer mulai menghitung waktu dengan nilai variabel marker startton. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya meluncurkan fungsi diagnostik pengontrol (S7-1214C DC / DC / DC, versi FW 4.4, versi Step7 - V16) dan menonton waktu siklus pemindaian pengontrol. Pada "idle" (ketika "false" tiba pada input dari timer), seluruh ribu diproses rata-rata selama 36-42 milidetik. Selama hitungan mundur sepuluh detik, pembacaan ini tumbuh sekitar 6-8 milidetik dan kadang-kadang berguling selama 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat apa yang dapat ditingkatkan dalam kode fungsi. Pertama, baris di awal blok program:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka selalu dipanggil, terlepas dari apakah penghitung waktu menghitung waktu, tidak menghitung, atau sudah dihitung. Buang besar uang adalah untuk memuat CPU tidak terlalu kuat dari seri 1200 dengan perhitungan yang melibatkan bahan presisi ganda. Adalah masuk akal untuk mentransfer kedua baris ke bagian kode yang memproses hitung mundur (jika "kebenaran" terus masuk). Juga diperlukan untuk menduplikasi perhitungan udiCycle ke dalam kode yang memproses sisi positif pada input dari timer. Ini akan meringankan "operasi idle" dari timer ketika nilai input salah. Dalam praktiknya, penghitung waktu dalam pengontrol logika yang dapat diprogram paling sering bekerja "idle". Misalnya, waktu penyaringan bouncing kontak adalah puluhan milidetik. Pulsa kontrol dari output diskrit adalah beberapa ratus milidetik, biasanya dari 0,5 hingga 1,0 detik.Waktu untuk memantau pelaksanaan perintah unit (misalnya, waktu katup terbuka sepenuhnya) adalah dari puluhan detik hingga beberapa menit. PLC dalam produksi bekerja 24 jam sehari dan 365 (dan kadang-kadang lebih!) Hari dalam setahun. Artinya, paling sering input timer adalah "nol", dan timer tidak menghitung apa-apa, atau "unit" tiba untuk waktu yang lama, dan timer sudah menghitung semuanya. Untuk membongkar CPU idle tahap kedua (timer sudah dihitung), perlu untuk memeriksa pada tahap "input terus menerima kebenaran" - jika timer sudah menghitung semua waktu dan mengatur output ke true. Dalam hal ini, tidak ada perhitungan yang harus dilakukan.paling sering input penghitung waktu adalah "nol", dan penghitung waktu tidak menghitung apa pun, atau "unit" tiba untuk waktu yang lama, dan penghitung waktu sudah menghitung semuanya. Untuk membongkar CPU idle tahap kedua (timer sudah dihitung), perlu untuk memeriksa pada tahap "kebenaran terus masuk" - jika timer sudah menghitung semua waktu dan mengatur output ke true. Dalam hal ini, tidak ada perhitungan yang harus dilakukan.paling sering input penghitung waktu adalah "nol", dan penghitung waktu tidak menghitung apa pun, atau "unit" tiba untuk waktu yang lama, dan penghitung waktu sudah menghitung semuanya. Untuk membongkar CPU idle tahap kedua (timer sudah dihitung), perlu untuk memeriksa pada tahap "kebenaran terus masuk" - jika timer sudah menghitung semua waktu dan mengatur output ke true. Dalam hal ini, tidak ada perhitungan yang harus dilakukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan perubahan ini, perlu untuk mentransfer output dari timer Q dari area OUTPUT ke area IN_OUT, dan nilai output akan disimpan dalam variabel eksternal (dalam contoh ini, dalam array struktur). Setelah penyempurnaan, seluruh kode fungsi, termasuk deklarasi, adalah sebagai berikut:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, waktu eksekusi meningkat: waktu pemrosesan idle timer adalah 23 ms, dengan waktu penyaringan kerja 37-40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode fungsi ini tidak memeriksa nilai pengaturan timer yang tidak valid - nilai negatif (jika material dikonversi ke integer yang tidak ditandatangani, pengaturan akan terdistorsi) atau nilai yang lebih besar dari 4294,9 detik (pengaturan waktu akan meluap dan mendistorsi). Anda harus mengontrol nilai nilai PT dalam kode, atau mempercayakan tugas untuk memeriksa rentang pengaturan waktu (dari 0 hingga 4294,9 detik) ke sistem operator tingkat atas. Memeriksa rentang dengan menggunakan program PLC meningkatkan waktu pemrosesan menjadi sekitar 45-46 ms (dan, secara umum, cara yang paling benar adalah dengan mengatur waktu timer tidak dalam format REAL, tetapi dalam format UDINT dalam milidetik dan melakukan omong kosong).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek aplikasi dengan penghitung waktu untuk lingkungan TIA Portal Langkah 7 versi 16 tersedia di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491188/index.html">Apa yang harus diketahui oleh backend tester</a></li>
<li><a href="../id491190/index.html">Membuat Toko Online di Nuxt.js 2 Walkthrough Bagian 3</a></li>
<li><a href="../id491192/index.html">Figmiro. Membuat plugin untuk Figma (dan sedikit untuk Miro)</a></li>
<li><a href="../id491194/index.html">Genetika asal. Komposisi populasi</a></li>
<li><a href="../id491198/index.html">Enam tips untuk membuat tutorial game yang tepat</a></li>
<li><a href="../id491202/index.html">Insinyur vs Desainer</a></li>
<li><a href="../id491208/index.html">7 kebiasaan yang akan mengubah introvert menjadi master komunikasi</a></li>
<li><a href="../id491210/index.html">Mini-seri video dengan animasi karakter tentang permainan bully Monster Hustle</a></li>
<li><a href="../id491212/index.html">Minyak dan vodka: bagaimana kita menyingkirkan stiker dari laptop</a></li>
<li><a href="../id491214/index.html">9 strategi untuk memasarkan game seluler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>