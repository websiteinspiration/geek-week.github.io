<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧙 🏾 #⃣ Das Buch „Objektorientierter Ansatz. 5th int. ed. " 👃🏽 🤚🏿 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die objektorientierte Programmierung (OOP) ist das Herzstück der Sprachen C ++, Java, C #, Visual Basic .NET, Ruby, Objective-C und sogar Swift. Sie k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Buch „Objektorientierter Ansatz. 5th int. ed. "</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/486888/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/d7/vu/ym/d7vuymdujarobcypwexhfief-l4.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die objektorientierte Programmierung (OOP) ist das Herzstück der Sprachen C ++, Java, C #, Visual Basic .NET, Ruby, Objective-C und sogar Swift. Sie können nicht auf Web-Technologieobjekte verzichten, da sie JavaScript, Python und PHP verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deshalb rät Matt Weissfeld, eine objektorientierte Denkweise zu entwickeln und erst dann mit der objektorientierten Entwicklung in einer bestimmten Programmiersprache fortzufahren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Buch wurde vom Entwickler für Entwickler geschrieben und ermöglicht es Ihnen, die besten Ansätze zur Lösung spezifischer Probleme auszuwählen. Sie lernen, wie Sie Vererbung und Zusammensetzung richtig anwenden, den Unterschied zwischen Aggregation und Zuordnung verstehen und die Schnittstelle und Implementierung nicht mehr verwirren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programmiertechnologien ändern und entwickeln sich ständig, aber objektorientierte Konzepte sind plattformunabhängig und bleiben durchweg effektiv. </font><font style="vertical-align: inherit;">Diese Veröffentlichung konzentriert sich auf die grundlegenden Grundlagen von OOP: Entwurfsmuster, Abhängigkeiten und SOLID-Prinzipien, die Ihren Code verständlich, flexibel und gut gepflegt machen.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLID Objektorientierte Designprinzipien</font></font></h3><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. SRP: Prinzip der alleinigen Verantwortung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip der alleinigen Verantwortung besagt, dass nur ein Grund erforderlich ist, um Änderungen an einer Klasse vorzunehmen. Jede Klasse und jedes Programmmodul muss eine Aufgabe mit Priorität haben. Daher sollten Sie keine Methoden einführen, die aus mehr als einem Grund Änderungen an der Klasse verursachen können. Wenn die Klassenbeschreibung das Wort „und“ enthält, kann das SRP-Prinzip verletzt werden. Mit anderen Worten, jedes Modul oder jede Klasse muss für einen Teil der Softwarefunktionalität verantwortlich sein, und diese Verantwortung muss vollständig in der Klasse enthalten sein.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen einer Zahlenhierarchie ist eines der klassischen Beispiele für die Vererbung. Dieses Beispiel findet sich häufig in der Lehre und wird in diesem Kapitel (sowie im gesamten Buch) verwendet. </font><font style="vertical-align: inherit;">In diesem Beispiel erbt die Circle-Klasse Attribute von der Shape-Klasse. </font><font style="vertical-align: inherit;">Die Shape-Klasse stellt die abstrakte calcArea () -Methode als Vertrag für eine Unterklasse bereit. </font><font style="vertical-align: inherit;">Jede Klasse, die von Shape erbt, muss über eine eigene Implementierung der calcArea () -Methode verfügen:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span>{
     <span class="hljs-keyword">protected</span> String name;
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel stellt die Circle-Klasse, die von der Shape-Klasse erbt, bei Bedarf die Implementierung der calcArea () -Methode bereit:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>{
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>{<font></font>
           radius = r;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
           area = <span class="hljs-number">3.14</span>*(radius*radius) ;
           <span class="hljs-keyword">return</span> (area);<font></font>
     };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die dritte Klasse, CalculateAreas, berechnet die Fläche der verschiedenen Formen, die im Shape-Array enthalten sind. </font><font style="vertical-align: inherit;">Das Shape-Array ist unbegrenzt groß und kann verschiedene Formen enthalten, z. B. Quadrate und Dreiecke.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{<font></font>
     Shape[] shapes;<font></font>
     <span class="hljs-keyword">double</span> sumTotal=<span class="hljs-number">0</span>;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CalculateAreas</span><span class="hljs-params">(Shape[] sh)</span> </span>{
           <span class="hljs-keyword">this</span>.shapes = sh;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sumAreas</span><span class="hljs-params">()</span> </span>{<font></font>
           sumTotal=<span class="hljs-number">0</span>;
           <span class="hljs-keyword">for</span> (inti=<span class="hljs-number">0</span>; i&lt;shapes.length; i++) {<font></font>
           sumTotal = sumTotal + shapes[i].calcArea() ;<font></font>
           }<font></font>
           <span class="hljs-keyword">return</span> sumTotal ;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Total of all areas = "</span> + sumTotal);<font></font>
     }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass die CalculateAreas-Klasse auch die Anwendungsausgabe verarbeitet, was zu Problemen führen kann. Bereichszählverhalten und Ausgabeverhalten hängen zusammen, da sie in derselben Klasse enthalten sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können die Funktionalität dieses Codes mit der entsprechenden Testanwendung TestShape überprüfen:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestShape</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Hello World!"</span>);<font></font>
<font></font>
            Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">1</span>);<font></font>
<font></font>
            Shape[] shapeArray = <span class="hljs-keyword">new</span> Shape[<span class="hljs-number">1</span>];<font></font>
            shapeArray[<span class="hljs-number">0</span>] = circle;<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas(shapeArray) ;<font></font>
<font></font>
            ca.sumAreas() ;<font></font>
            ca.output();<font></font>
      }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem wir nun eine Testanwendung zur Verfügung haben, können wir uns auf das Problem des Prinzips der alleinigen Verantwortung konzentrieren. Wiederum liegt das Problem bei der CalculateAreas-Klasse und der Tatsache, dass diese Klasse Verhaltensweisen zum Addieren der Bereiche verschiedener Formen sowie zum Ausgeben von Daten enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die grundlegende Frage (und tatsächlich das Problem) ist, dass Sie, wenn Sie die Funktionalität der output () -Methode ändern müssen, Änderungen an der CalculateAreas-Klasse vornehmen müssen, unabhängig davon, ob sich die Methode zur Berechnung des Bereichs von Formen ändert. Wenn wir beispielsweise plötzlich Daten an die HTML-Konsole und nicht an einfachen Text ausgeben möchten, müssen wir den Code neu kompilieren und neu implementieren, wodurch sich der Bereich der Abbildungen addiert. Alles nur, weil die Haftung damit zusammenhängt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Prinzip der alleinigen Verantwortung besteht die Aufgabe darin, eine Methode zu ändern, die die anderen Methoden nicht beeinflusst und nicht neu kompiliert werden muss. "Die Klasse sollte nur einen Grund für Veränderungen haben - die einzige Verantwortung, die geändert werden muss." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses Problem zu lösen, können Sie zwei Methoden in separate Klassen einteilen, eine für die ursprüngliche Konsolenausgabe und eine für die HTML-Ausgabe:</font></font><br>
<br>
<pre><code class="xml hljs">class CaiculateAreas {;<font></font>
     Shape[] shapes;<font></font>
     double sumTotal=0;<font></font>
<font></font>
     public CalculateAreas(Shape[] sh) {<font></font>
           this.shapes = sh;<font></font>
     }<font></font>
<font></font>
     public double sumAreas() {<font></font>
           sumTotal=0;<font></font>
<font></font>
           for (inti=0; i<span class="hljs-tag">&lt;<span class="hljs-name">shapes.length;</span> <span class="hljs-attr">i</span>++) {

                <span class="hljs-attr">sumTotal</span> = <span class="hljs-string">sumTotal</span> + <span class="hljs-attr">shapes</span>[<span class="hljs-attr">i</span>]<span class="hljs-attr">.calcArea</span>();

           }

                <span class="hljs-attr">return</span> <span class="hljs-attr">sumTotal</span>;
           }
}
<span class="hljs-attr">class</span> <span class="hljs-attr">OutputAreas</span> {
     <span class="hljs-attr">double</span> <span class="hljs-attr">areas</span>=<span class="hljs-string">0;</span>
     <span class="hljs-attr">public</span> <span class="hljs-attr">OutputAreas</span> (<span class="hljs-attr">double</span> <span class="hljs-attr">a</span>) {
           <span class="hljs-attr">this.areas</span> = <span class="hljs-string">a;</span>
     }

           <span class="hljs-attr">public</span> <span class="hljs-attr">void</span> <span class="hljs-attr">console</span>() {
           <span class="hljs-attr">System.out.printin</span>("<span class="hljs-attr">Total</span> <span class="hljs-attr">of</span> <span class="hljs-attr">all</span> <span class="hljs-attr">areas</span> = <span class="hljs-string">" + areas);
     }
     public void HTML() {
           System.out.printIn("</span>&lt;<span class="hljs-attr">HTML</span>&gt;</span>") ;<font></font>
           System.out.printin("Total of all areas = " + areas);<font></font>
           System.out.printin("<span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span>") ;<font></font>
     }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Fazit hier ist, dass Sie jetzt je nach Bedarf eine Schlussfolgerung in verschiedene Richtungen senden können. </font><font style="vertical-align: inherit;">Wenn Sie die Möglichkeit einer anderen Ausgabemethode hinzufügen möchten, z. B. JSON, können Sie diese der OutputAreas-Klasse hinzufügen, ohne Änderungen an der CalculateAreas-Klasse vornehmen zu müssen. </font><font style="vertical-align: inherit;">Infolgedessen können Sie die CalculateAreas-Klasse neu verteilen, ohne andere Klassen in irgendeiner Weise zu beeinflussen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. OCP: offenes / geschlossenes Prinzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip der Offenheit / Nähe besagt, dass Sie das Verhalten einer Klasse erweitern können, ohne Änderungen vorzunehmen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns noch einmal auf das Beispiel mit den Zahlen achten. </font><font style="vertical-align: inherit;">Im folgenden Code gibt es eine ShapeCalculator-Klasse, die ein Rectangle-Objekt verwendet, die Fläche dieses Objekts berechnet und Werte zurückgibt. </font><font style="vertical-align: inherit;">Dies ist eine einfache Anwendung, die jedoch nur mit Rechtecken funktioniert.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span></span>{
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> length;
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
           length = <span class="hljs-number">1</span>;<font></font>
           width = w;<font></font>
     };<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(Rectangle r)</span> </span>{<font></font>
<font></font>
           area = r.length * r.width;<font></font>
<font></font>
           <span class="hljs-keyword">return</span> area;<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenClosed</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Hello World"</span>);<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas ();<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span>+ ca.calcArea(r));<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass diese Anwendung nur bei Rechtecken funktioniert, führt zu einer Einschränkung, die das Prinzip der Offenheit / Schließung klar erklärt: Wenn wir die Circle-Klasse zur CalculateArea-Klasse hinzufügen möchten (ändern Sie, was sie tut), müssen Sie Änderungen am Modul selbst vornehmen. Dies steht offensichtlich im Widerspruch zum Prinzip der Offenheit / Nähe, das besagt, dass wir keine Änderungen am Modul vornehmen sollten, um dessen Funktionsweise zu ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dem Prinzip der Offenheit / Nähe zu entsprechen, können wir zu dem bereits getesteten Beispiel mit Zahlen zurückkehren, in dem eine abstrakte Formklasse erstellt wird und die Figuren direkt von der Formklasse erben, die eine abstrakte getArea () -Methode hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Moment können Sie beliebig viele verschiedene Klassen hinzufügen, ohne Änderungen direkt an der Shape-Klasse (z. B. der Circle-Klasse) vornehmen zu müssen. Jetzt können wir sagen, dass die Shape-Klasse geschlossen ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der folgende Code bietet eine Implementierung der Lösung für Rechtecke und Kreise und ermöglicht Ihnen das Erstellen einer unbegrenzten Anzahl von Formen:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span>
</span>{<font></font>
<font></font>
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      };<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> length*width;<font></font>
      }<font></font>
<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span>
</span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> radius;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>{<font></font>
            radius = r;<font></font>
      };<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> radius*radius*<span class="hljs-number">3.14</span>;<font></font>
      }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(Shape s)</span> </span>{<font></font>
            area = s.getArea();<font></font>
            <span class="hljs-keyword">return</span> area;<font></font>
      }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenClosed</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printiIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas() ;<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Area = "</span> + ca.calcArea(r));<font></font>
<font></font>
            Circle c = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">3</span>);<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Area = "</span> + ca.calcArea(c));<font></font>
}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass bei dieser Implementierung die CalculateAreas () -Methode beim Erstellen einer neuen Instanz der Shape-Klasse nicht geändert werden sollte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können den Code skalieren, ohne sich Gedanken über die Existenz des vorherigen Codes machen zu müssen. Das Prinzip der Offenheit / Nähe besteht darin, dass Sie den Code mithilfe von Unterklassen erweitern, damit für die ursprüngliche Klasse keine Änderungen erforderlich sind. Das Konzept der „Erweiterung“ selbst ist jedoch in einigen Diskussionen über die Prinzipien von SOLID umstritten. Um es auf den Punkt zu bringen: Wenn wir Komposition statt Vererbung bevorzugen, wie wirkt sich dies auf das Prinzip der Offenheit / Nähe aus?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei Einhaltung eines der SOLID-Prinzipien kann der Code die Kriterien anderer SOLID-Prinzipien erfüllen. </font><font style="vertical-align: inherit;">Wenn der Code beispielsweise nach dem Prinzip der Offenheit / Nähe gestaltet wird, kann er den Anforderungen des Prinzips der alleinigen Verantwortung entsprechen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. LSP: Lisk-Substitutionsprinzip</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Liskov-Substitutionsprinzip sollte das Design die Möglichkeit bieten, jede Instanz der Elternklasse durch eine Instanz einer der Kindklassen zu ersetzen. Wenn die übergeordnete Klasse eine Aufgabe ausführen kann, muss auch die untergeordnete Klasse dazu in der Lage sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie einen Code, der auf den ersten Blick korrekt ist, aber gegen das Lisk-Substitutionsprinzip verstößt. Der folgende Code enthält eine generische abstrakte Formklasse. Die Rectangle-Klasse erbt wiederum Attribute von der Shape-Klasse und überschreibt ihre abstrakte calcArea () -Methode. Die Square-Klasse wiederum erbt von Rectangle.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      }<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = length*width;<font></font>
            <span class="hljs-keyword">return</span> (area) ;<font></font>
      };<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span></span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{
            <span class="hljs-keyword">super</span>(s, Ss);<font></font>
      }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span> + r.calcArea());<font></font>
<font></font>
            Square s = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">2</span>) ;<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span> + s.calcArea());<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So weit so gut: Das Rechteck ist eine Instanz der Figur, also gibt es keinen Grund zur Sorge, da das Quadrat eine Instanz des Rechtecks ​​ist - und wieder ist alles richtig, oder? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen wir nun eine philosophische Frage: Ist ein Quadrat noch ein Rechteck? </font><font style="vertical-align: inherit;">Viele werden bejahen. </font><font style="vertical-align: inherit;">Obwohl davon ausgegangen werden kann, dass ein Quadrat ein Sonderfall eines Rechtecks ​​ist, unterscheiden sich seine Eigenschaften. </font><font style="vertical-align: inherit;">Ein Rechteck ist ein Parallelogramm (die gegenüberliegenden Seiten sind gleich) wie ein Quadrat. </font><font style="vertical-align: inherit;">Gleichzeitig ist das Quadrat auch eine Raute (alle Seiten sind gleich), das Rechteck jedoch nicht. </font><font style="vertical-align: inherit;">Daher gibt es Unterschiede.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn es um objektorientiertes Design geht, ist das Problem nicht die Geometrie. </font><font style="vertical-align: inherit;">Das Problem ist, wie genau wir Rechtecke und Quadrate erstellen. </font><font style="vertical-align: inherit;">Hier ist der Konstruktor für die Rectangle-Klasse:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
      length = <span class="hljs-number">1</span>;<font></font>
      width = w;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Offensichtlich benötigt der Konstruktor zwei Parameter. </font><font style="vertical-align: inherit;">Der Konstruktor für die Square-Klasse benötigt jedoch nur eine, obwohl die übergeordnete Klasse Rectangle zwei benötigt.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span></span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{
      <span class="hljs-keyword">super</span>(s, Ss);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich unterscheidet sich die Funktion zur Berechnung der Fläche bei jeder dieser beiden Klassen geringfügig. </font><font style="vertical-align: inherit;">Das heißt, die Square-Klasse imitiert sozusagen ein Rechteck und übergibt denselben Parameter zweimal an den Konstruktor. </font><font style="vertical-align: inherit;">Es mag den Anschein haben, dass eine solche Problemumgehung durchaus geeignet ist, aber tatsächlich kann sie die Entwickler irreführen, die den Code begleiten, was in Zukunft mit Fallstricken behaftet ist. </font><font style="vertical-align: inherit;">Zumindest ist dies ein Problem und wahrscheinlich eine zweifelhafte Entwurfsentscheidung. </font><font style="vertical-align: inherit;">Wenn ein Konstruktor einen anderen aufruft, ist es eine gute Idee, eine Pause einzulegen und das Konstrukt zu überdenken - möglicherweise ist die untergeordnete Klasse nicht richtig erstellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie finde ich einen Ausweg aus dieser Situation? </font><font style="vertical-align: inherit;">Einfach ausgedrückt, Sie können ein Rechteck nicht durch eine Quadratklasse ersetzen. </font><font style="vertical-align: inherit;">Daher sollte Square kein Kind der Rectangle-Klasse sein. </font><font style="vertical-align: inherit;">Sie müssen separate Klassen sein.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{<font></font>
<font></font>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = length*width;<font></font>
            <span class="hljs-keyword">return</span> (area);<font></font>
      };<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> side;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{<font></font>
            side = s;<font></font>
      }<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = side*side;<font></font>
            <span class="hljs-keyword">return</span> (area);<font></font>
      };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
             Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Area = "</span> + r.calcArea());<font></font>
<font></font>
             Square s = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">2</span>) ;<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Area = "</span> + s.calcArea());<font></font>
      }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. ISP: Prinzip der Schnittstellenfreigabe</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip der Trennung von Schnittstellen besagt, dass es besser ist, viele kleine Schnittstellen als mehrere große zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Beispiel erstellen wir eine einzelne Schnittstelle, die verschiedene Verhaltensweisen für die Mammal-Klasse enthält, nämlich eat () und makeNoise ():</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMammal</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMammal</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is eating"</span>);<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is making noise"</span>);<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>);<font></font>
<font></font>
            Dog fido = <span class="hljs-keyword">new</span> Dog();<font></font>
            fido.eat();<font></font>
            fido.makeNoise()<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt eine einzelne Schnittstelle für die Mammal-Klasse zu erstellen, müssen Sie </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
separate Schnittstellen für alle Verhaltensweisen </font><font style="vertical-align: inherit;">erstellen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IEat</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMakeNoise</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IEat</span>, <span class="hljs-title">IMakeNoise</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is eating"</span>);<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is making noise"</span>);<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            Dog fido = <span class="hljs-keyword">new</span> Dog();<font></font>
            fido.eat();<font></font>
            fido.makeNoise();<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir trennen Verhaltensweisen von der Säugetierklasse. Es stellt sich heraus, dass wir, anstatt eine einzelne Mammal-Klasse durch Vererbung (genauer gesagt Schnittstellen) zu erstellen, mit dem Design fortfahren, das auf der Zusammensetzung basiert, ähnlich der im vorherigen Kapitel verwendeten Strategie.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Ansatz können wir mit wenigen Worten Instanzen der Mammal-Klasse mithilfe der Komposition erstellen, anstatt gezwungen zu sein, Verhaltensweisen zu verwenden, die in eine einzelne Mammal-Klasse eingebettet sind. Angenommen, es wird ein Säugetier entdeckt, das nicht frisst, sondern Nährstoffe über die Haut aufnimmt. Wenn wir von der Mammal-Klasse erben, die das eat () -Verhalten enthält, ist dieses Verhalten für das neue Säugetier überflüssig. Wenn alle Verhaltensweisen in separaten Schnittstellen dargestellt werden, wird sich außerdem herausstellen, dass die Klasse jedes Säugetiers genau wie beabsichtigt aufgebaut ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Weitere Informationen zum Buch finden Sie auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhaltsverzeichnis</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
für Habrozhitelami 25% Rabatt auf den Gutschein -</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486874/index.html">Coronavirus 2019-nCoV: niedrige Mortalität, hohe Mortalität</a></li>
<li><a href="../de486876/index.html">Erstellen eines Telegramm-Bots in Yandex.Cloud</a></li>
<li><a href="../de486878/index.html">Flügel, Beine und Schwänze</a></li>
<li><a href="../de486880/index.html">Fehler von Übersetzern, die zu katastrophalen Folgen führten</a></li>
<li><a href="../de486884/index.html">Das japanische Pharmaunternehmen beginnt mit dem Testen von Arzneimitteln, die mithilfe eines neuronalen Netzwerks synthetisiert wurden</a></li>
<li><a href="../de486890/index.html">Selbstentwicklung: Wie ich nicht auf zwei Stühlen saß und einen dritten fand</a></li>
<li><a href="../de486892/index.html">Kontaktauswahl-API oder wie Sie Ihre Kontakte mit einem Browser teilen</a></li>
<li><a href="../de486896/index.html">UID- und Stalker-Autorisierung auf dem MAG250</a></li>
<li><a href="../de486902/index.html">Protokollorientierte Programmierung in Swift 5.1</a></li>
<li><a href="../de486904/index.html">Anzeigen des Status der Qualitätskontrolle von Quellcode in SonarQube für Entwickler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>