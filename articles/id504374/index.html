<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👱 🥚 🎲 Traversal grafik sederhana: pencarian mendalam dan luas-pertama menggunakan JavaScript sebagai contoh 🍹 👇🏿 🦅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selamat siang. 
 
 Saya mempersembahkan kepada Anda terjemahan dari artikel “Algoritma pada Grafik: Mari kita bicara Pencarian Kedalaman-Pertama (DFS)...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Traversal grafik sederhana: pencarian mendalam dan luas-pertama menggunakan JavaScript sebagai contoh</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504374/"><img src="https://habrastorage.org/webt/_f/kf/kl/_fkfkl3gfkmnwtes2eypbueifxe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selamat siang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mempersembahkan kepada Anda terjemahan dari artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“Algoritma pada Grafik: Mari kita bicara Pencarian Kedalaman-Pertama (DFS) dan Pencarian Breadth-First (BFS)”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oleh Try Khov.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa itu traversal grafik?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan kata sederhana, grafik traversal adalah transisi dari salah satu simpulnya ke simpul lain untuk mencari properti koneksi simpul tersebut. </font><font style="vertical-align: inherit;">Tautan (garis yang menghubungkan simpul) disebut arah, jalur, wajah, atau tepi grafik. </font><font style="vertical-align: inherit;">Verteks grafik juga disebut sebagai simpul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua algoritma traversal grafik utama adalah Depth-First Search, DFS dan Breadth-First Search, BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa kedua algoritma digunakan untuk melintasi grafik, mereka memiliki beberapa perbedaan. </font><font style="vertical-align: inherit;">Mari kita mulai dengan DFS.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian Kedalaman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DFS mengikuti konsep "go deep, head first". Idenya adalah bahwa kita bergerak dari puncak mulai (titik, tempat) dalam arah tertentu (sepanjang jalur tertentu) sampai kita mencapai ujung jalur atau tujuan (puncak yang diinginkan). Jika kita telah mencapai ujung jalan, tetapi itu bukan tujuan, maka kita kembali (ke jalur bercabang atau menyimpang jalur) dan pergi di sepanjang rute yang berbeda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat sebuah contoh. Misalkan kita memiliki grafik berarah yang terlihat seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita berada pada titik "s" dan kita perlu menemukan simpul "t". Dengan menggunakan DFS, kami menyelidiki salah satu jalur yang mungkin, bergerak sepanjang hingga akhir dan, jika kami tidak menemukan t, kembali dan jelajahi jalur lain. Begini prosesnya:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita bergerak di sepanjang jalan (p1) ke puncak terdekat dan melihat bahwa ini bukan akhir dari jalan. Karena itu, kami beralih ke puncak berikutnya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mencapai akhir p1, tetapi tidak menemukan t, jadi kami kembali ke s dan bergerak di sepanjang jalan kedua. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah mencapai bagian atas jalur "p2" paling dekat dengan titik "s", kita melihat tiga kemungkinan arah untuk pergerakan lebih lanjut. Karena kami telah mengunjungi puncak yang memahkotai arah pertama, kami bergerak di sepanjang yang kedua. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami kembali mencapai ujung jalan, tetapi tidak menemukan t, jadi kami kembali. Kami mengikuti jalan ketiga dan, akhirnya, kami mencapai puncak yang diinginkan "t". </font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inilah cara kerja DFS. Kami bergerak di sepanjang jalan tertentu sampai akhir. Jika ujung jalan adalah puncak yang diinginkan, kita selesai. Jika tidak, kembali dan pindah ke jalur yang berbeda hingga kami menjelajahi semua opsi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mengikuti algoritma ini untuk setiap titik yang dikunjungi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlunya pengulangan prosedur berulang menunjukkan perlunya menggunakan rekursi untuk mengimplementasikan algoritma. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah kode JavaScript:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A: [B,C], B:[D,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfs</span>(<span class="hljs-params">adj, v, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// v -   ()</span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-comment">//    ,    </span>
	<span class="hljs-keyword">if</span>(v === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">if</span>(v.visited) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
	<span class="hljs-comment">//    </span>
	v.visited = <span class="hljs-literal">true</span>
	<span class="hljs-comment">//    (  ) v</span>
	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
		<span class="hljs-comment">//    </span>
		<span class="hljs-keyword">if</span>(!neighbor.visited) {
			<span class="hljs-comment">//     ,      </span>
			<span class="hljs-keyword">let</span> reached = dfs(adj, neighbor, t)
			<span class="hljs-comment">//  true,  </span>
			<span class="hljs-keyword">if</span>(reached) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
		}<font></font>
	}<font></font>
	<span class="hljs-comment">//   v  t  </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: Algoritme DFS khusus ini memungkinkan Anda memeriksa apakah mungkin untuk berpindah dari satu tempat ke tempat lain. </font><font style="vertical-align: inherit;">DFS dapat digunakan untuk berbagai keperluan. </font><font style="vertical-align: inherit;">Sasaran ini akan menentukan bagaimana algoritma itu sendiri akan terlihat. </font><font style="vertical-align: inherit;">Namun, konsep umum terlihat persis seperti itu.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis DFS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita menganalisis algoritma ini. Karena kita berkeliling setiap "tetangga" dari setiap node, mengabaikan mereka yang kita kunjungi sebelumnya, kita memiliki runtime yang sama dengan O (V + E). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penjelasan singkat tentang arti V + E: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V adalah jumlah total simpul. E adalah jumlah total wajah (tepi). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin tampak lebih tepat untuk menggunakan V * E, tetapi mari kita pikirkan apa arti V * E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
V * E berarti bahwa sehubungan dengan masing-masing simpul, kita harus menyelidiki semua wajah grafik terlepas dari apakah wajah-wajah ini milik simpul tertentu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, V + E berarti bahwa untuk setiap titik kami hanya mengevaluasi tepi yang berdekatan dengannya. </font><font style="vertical-align: inherit;">Kembali ke contoh, setiap dhuwur memiliki sejumlah wajah dan, dalam kasus terburuk, kita berkeliling semua simpul (O (V)) dan memeriksa semua wajah (O (E)). </font><font style="vertical-align: inherit;">Kami memiliki simpul V dan wajah E, jadi kami mendapatkan V + E. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih lanjut, karena kita menggunakan rekursi untuk melintasi setiap verteks, ini berarti bahwa stack digunakan (rekursi tak terbatas mengarah ke kesalahan stack overflow). </font><font style="vertical-align: inherit;">Oleh karena itu, kompleksitas spasial adalah O (V). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang pertimbangkan BFS.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian luas</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BFS mengikuti konsep "memperluas lebar, naik ke ketinggian penerbangan burung" ("melebar, pandangan mata burung"). Alih-alih bergerak di sepanjang jalan tertentu sampai akhir, BFS melibatkan bergerak maju satu tetangga pada satu waktu. Ini berarti yang berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alih-alih mengikuti jalan, BFS berarti mengunjungi tetangga terdekat ke dalam satu tindakan (langkah), kemudian mengunjungi tetangga tetangga dan seterusnya sampai t terdeteksi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1u/vb/ny/1uvbnygi83vt6bxqnmv1hbwuzyq.png"><br>
<br>
<img src="https://habrastorage.org/webt/tg/en/jq/tgenjqvsz1zipcv3obsicrhq78a.png"><br>
<br>
<img src="https://habrastorage.org/webt/tf/j9/on/tfj9on04zudfmelpbn00xeh_tpm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana DFS berbeda dari BFS? Saya suka berpikir bahwa DFS berjalan maju, dan BFS tidak terburu-buru, tetapi mempelajari segala sesuatu dalam satu langkah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertanyaan kemudian muncul: bagaimana Anda tahu tetangga mana yang harus dikunjungi terlebih dahulu?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan ini, kita dapat menggunakan konsep "first in, first out" (first-in-first-out, FIFO) dari antrian. </font><font style="vertical-align: inherit;">Kami terlebih dahulu mengantri puncak yang paling dekat dengan kami, kemudian tetangga yang belum dikunjungi, dan melanjutkan proses ini sampai antrian kosong atau sampai kami menemukan titik yang kami cari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini kodenya:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//  ,       </span>
<span class="hljs-comment">// , : adj = {A:[B,C,D], B:[E,F], ... }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bfs</span>(<span class="hljs-params">adj, s, t</span>) </span>{
	<span class="hljs-comment">// adj -  </span>
	<span class="hljs-comment">// s -  </span>
	<span class="hljs-comment">// t -  </span><font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">let</span> queue = []
	<span class="hljs-comment">//  s  </span><font></font>
	queue.push(s)<font></font>
	<span class="hljs-comment">//  s         </span>
	s.visited = <span class="hljs-literal">true</span>
	<span class="hljs-keyword">while</span>(queue.length &gt; <span class="hljs-number">0</span>) {
		<span class="hljs-comment">//   ()   </span>
		<span class="hljs-keyword">let</span> v = queue.shift()
		<span class="hljs-comment">// abj[v] -  v</span>
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> neighbor <span class="hljs-keyword">of</span> adj[v]) {
			<span class="hljs-comment">//    </span>
			<span class="hljs-keyword">if</span>(!neighbor.visited) {
				<span class="hljs-comment">//    </span><font></font>
				queue.push(neighbor)<font></font>
				<span class="hljs-comment">//    </span>
				neighbor.visited = <span class="hljs-literal">true</span>
				<span class="hljs-comment">//     ,  </span>
				<span class="hljs-keyword">if</span>(neighbor === t) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
			}<font></font>
		} <font></font>
	}<font></font>
	<span class="hljs-comment">//  t  ,     </span>
	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisis BFS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tampaknya BFS lebih lambat. Namun, jika Anda melihat secara dekat pada visualisasi, Anda dapat melihat bahwa mereka memiliki runtime yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antrian melibatkan pemrosesan setiap simpul sebelum mencapai tujuan. Ini berarti bahwa, dalam kasus terburuk, BFS mengeksplorasi semua simpul dan wajah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terlepas dari kenyataan bahwa BFS mungkin tampak lebih lambat, sebenarnya lebih cepat, karena ketika bekerja dengan grafik besar ditemukan bahwa DFS menghabiskan banyak waktu mengikuti jalur yang akhirnya ternyata salah. BFS sering digunakan untuk menemukan jalur terpendek antara dua puncak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, runtime BFS juga O (V + E), dan karena kami menggunakan antrian yang berisi semua simpul, kompleksitas spasialnya adalah O (V).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analogi kehidupan nyata</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memberikan analogi dari kehidupan nyata, maka ini adalah bagaimana saya membayangkan karya DFS dan BFS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya memikirkan DFS, saya membayangkan seekor tikus dalam labirin mencari makanan. </font><font style="vertical-align: inherit;">Untuk mencapai target, tikus dipaksa menemui jalan buntu berkali-kali, kembali dan bergerak dengan cara yang berbeda, dan seterusnya hingga menemukan jalan keluar dari labirin atau makanan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-e/f3/ji/-ef3ji72zi8egr3xa26zqvt1x4u.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi yang disederhanakan terlihat seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kq/hb/dr/kqhbdrkv6xstug0ss3l5bpr1l9k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gilirannya, ketika saya berpikir tentang BFS, saya membayangkan lingkaran di atas air. </font><font style="vertical-align: inherit;">Jatuhnya batu ke dalam air menyebabkan penyebaran gangguan (lingkaran) ke segala arah dari pusat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pv/lz/zp/pvlzzpnzfssjv8yzpkc49ovtsho.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi yang disederhanakan terlihat seperti ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/w9/sc/s-w9scwvyp93tvyk2zwimmfc_um.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencarian mendalam dan luas digunakan untuk melintasi grafik.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS bergerak sepanjang sisi bolak-balik, dan BFS menyebar di seluruh tetangga untuk mencari target.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFS menggunakan tumpukan, dan BFS antrian.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Runtime keduanya adalah O (V + E), dan kompleksitas spasial adalah O (V).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma ini memiliki filosofi yang berbeda, tetapi sama pentingnya untuk bekerja dengan grafik.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan </font><font style="vertical-align: inherit;">Per.: Saya bukan spesialis dalam algoritma dan struktur data, oleh karena itu, jika ditemukan kesalahan, ketidakakuratan, atau formulasi yang salah, silakan tulis dalam surat pribadi untuk koreksi dan klarifikasi. </font><font style="vertical-align: inherit;">Saya akan berterima kasih. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Terima kasih atas perhatian Anda.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id504354/index.html">Kurangi ukuran model ML tanpa registrasi dan SMS</a></li>
<li><a href="../id504356/index.html">PHP 8 dalam delapan bagian kode</a></li>
<li><a href="../id504358/index.html">PuppetConf 2016. Kubernetes untuk administrator sistem. Bagian 2</a></li>
<li><a href="../id504362/index.html">Cepat memuat sejumlah besar data di Google Colab</a></li>
<li><a href="../id504370/index.html">Office 365 & Microsoft Teams - Kemudahan Kolaborasi dan Dampak pada Keamanan</a></li>
<li><a href="../id504382/index.html">Bagaimana saya (PhD Neurobiologi) menjadi Ilmuwan Data dalam 6 bulan</a></li>
<li><a href="../id504384/index.html">Secara bertahap perkenalkan TypeScript ke dalam proyek React Anda</a></li>
<li><a href="../id504386/index.html">Vassbotn H. Kelas Variabel Virtual</a></li>
<li><a href="../id504392/index.html">Berapa banyak programmer dan kata-kata yang Anda butuhkan untuk mengenali paspor tulisan tangan?</a></li>
<li><a href="../id504400/index.html">Caching. Bagian 2: 60 hari sebelum rilis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>