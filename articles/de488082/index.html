<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕 👏 🌀 Auf den Punkt gebracht: Async / Await Best Practices in .NET 🕝 🧜🏼 💥</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Vorfeld des Kursbeginns erstellte "C # Developer" eine Übersetzung von interessantem Material.
 
 
 
 Async / Await - Einführung
 Das Async / Await...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Auf den Punkt gebracht: Async / Await Best Practices in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/488082/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vorfeld des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kursbeginns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">"C # Developer"</font></a><font style="vertical-align: inherit;"> eine Übersetzung von interessantem Material.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/6f/io/l8/6fiol8vwkg-r8ja-3zurutnz-ci.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / Await - Einführung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Async / Await-Sprachkonstrukt existiert seit C # Version 5.0 (2012) und wurde schnell zu einer der Säulen der modernen .NET-Programmierung. Jeder C # -Entwickler mit Selbstachtung sollte es verwenden, um die Anwendungsleistung, die allgemeine Reaktionsfähigkeit und die Lesbarkeit des Codes zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Await macht die Einführung von asynchronem Code täuschend einfach und macht es für den Programmierer unnötig, die Details seiner Verarbeitung zu verstehen. Aber wie viele von uns wissen wirklich, wie es funktioniert und welche Vor- und Nachteile hat diese Methode? </font><font style="vertical-align: inherit;">Es gibt viele nützliche Informationen, die jedoch fragmentiert sind. Deshalb habe ich beschlossen, diesen Artikel zu schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann beschäftigen wir uns mit dem Thema.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zustandsmaschine (IAsyncStateMachine)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erste, was Sie wissen müssen, ist, dass der Compiler jedes Mal, wenn Sie eine Methode oder Funktion mit Async / Await haben, Ihre Methode in eine generierte Klasse verwandelt, die die IAsyncStateMachine-Schnittstelle implementiert. Diese Klasse ist für die Aufrechterhaltung des Status Ihrer Methode während des Lebenszyklus einer asynchronen Operation verantwortlich. Sie kapselt alle Variablen Ihrer Methode in Form von Feldern und unterteilt Ihren Code in Abschnitte, die während Zustandsmaschinenübergängen zwischen Status ausgeführt werden, damit der Thread die Methode verlassen kann und wann wird zurückkehren, der Zustand wird sich nicht ändern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiel finden Sie hier eine sehr einfache Klassendefinition mit zwei asynchronen Methoden: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
using System.Threading.Tasks;</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Diagnostics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AsyncAwait</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAwait</span><font></font>
    {<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> myVariable = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After First Await"</span>);<font></font>
            myVariable = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After Second Await"</span>);<font></font>
            myVariable = <span class="hljs-number">2</span>;<font></font>
<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DummyAsyncMethod</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse mit zwei asynchronen Methoden</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn wir uns den Code ansehen, der während der Assembly generiert wurde, sehen wir ungefähr Folgendes: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/xe/63/qoxe63foidhmllsdwfi78tdhrsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass zwei neue innere Klassen für uns generiert wurden, eine für jede asynchrone Methode. Diese Klassen enthalten eine Zustandsmaschine für jede unserer asynchronen Methoden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem </font></font><code><code>&lt;AsyncAwaitExample&gt;</code></code><code> d__0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den dekompilierten Code für untersucht haben </font><font style="vertical-align: inherit;">, werden wir feststellen, dass unsere interne Variable </font></font><code>«myVariable»</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt ein Klassenfeld ist: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/_m/qj/gd_mqjxvsjfw9-_zfd7740n42ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können auch andere Klassenfelder sehen, die intern zur Aufrechterhaltung des Status verwendet werden </font></font><code>IAsyncStateMachine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Zustandsmaschine durchläuft Zustände mit der Methode</font></font><code>MoveNext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Tat ein großer Schalter. </font><font style="vertical-align: inherit;">Beachten Sie, wie die Methode nach jedem asynchronen Aufruf in verschiedenen Abschnitten fortgesetzt wird (mit der vorherigen Fortsetzungsbezeichnung). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/li/ea/kmlieahswg0ebqn3db5nctfzsti.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, asynchrone Eleganz hat ihren Preis. </font><font style="vertical-align: inherit;">Die Verwendung von async / await erhöht die Komplexität (die Sie möglicherweise nicht kennen). </font><font style="vertical-align: inherit;">In der serverseitigen Logik ist dies möglicherweise nicht kritisch. Insbesondere bei der Programmierung mobiler Anwendungen, die jeden CPU- und KB-Speicherzyklus berücksichtigen, sollten Sie dies berücksichtigen, da sich der Overhead schnell erhöhen kann. </font><font style="vertical-align: inherit;">Später in diesem Artikel werden Best Practices für die Verwendung von Async / Await nur bei Bedarf erläutert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie sich dieses </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Video auf YouTube an</font></a><font style="vertical-align: inherit;"> , um eine ziemlich lehrreiche Erklärung der Zustandsmaschine zu erhalten</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann wird Async / Await verwendet?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt im Allgemeinen zwei Szenarien, in denen Async / Await die richtige Lösung ist.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-bezogene Arbeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ihr Code erwartet etwas, z. B. Daten aus einer Datenbank, Lesen einer Datei oder Aufrufen eines Webdienstes. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie Async / Await verwenden, nicht die Task Parallel Library.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU-bezogene Arbeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ihr Code führt komplexe Berechnungen durch. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie Async / Await verwenden, aber Sie müssen die Arbeit in einem anderen Thread mit Task.Run beginnen. </font><font style="vertical-align: inherit;">Sie können auch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Parallel Library verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async den ganzen Weg</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit asynchronen Methoden arbeiten, werden Sie schnell feststellen, dass sich die asynchrone Natur des Codes in Ihrer Aufrufhierarchie auf und ab ausbreitet. Dies bedeutet, dass Sie Ihren aufrufenden Code auch asynchron machen müssen und so weiter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie könnten versucht sein, dies zu stoppen, indem Sie den Code mit Task.Result oder Task.Wait blockieren, einen kleinen Teil der Anwendung konvertieren und in eine synchrone API einbinden, sodass der Rest der Anwendung von Änderungen isoliert ist. Leider ist dies ein Rezept für die Erstellung schwer zu verfolgender Deadlocks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beste Lösung für dieses Problem besteht darin, asynchronen Code auf natürliche Weise in der Codebasis wachsen zu lassen. </font><font style="vertical-align: inherit;">Wenn Sie dieser Entscheidung folgen, wird die Erweiterung des asynchronen Codes bis zu seinem Einstiegspunkt angezeigt, normalerweise eine Ereignishandler- oder Controller-Aktion. </font><font style="vertical-align: inherit;">Geben Sie sich spurlos der Asynchronität hin! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Methode als asynchron deklariert ist, stellen Sie sicher, dass darauf gewartet wird!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Compiler eine asynchrone Methode findet, verwandelt er diese Methode in eine Zustandsmaschine. </font><font style="vertical-align: inherit;">Wenn Ihr Code nicht in seinem Hauptteil wartet, generiert der Compiler eine Warnung, aber die Zustandsmaschine wird trotzdem erstellt, wodurch unnötiger Overhead für eine Operation entsteht, die niemals tatsächlich abgeschlossen wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie asynchrone Leere</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asynchrone Leere ist etwas, das wirklich vermieden werden sollte. </font><font style="vertical-align: inherit;">Machen Sie es sich zur Regel, asynchrone Task anstelle von async void zu verwenden.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methoden async void und async Task Hierfür</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
gibt es mehrere Gründe, darunter:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen, die in der asynchronen Void-Methode ausgelöst werden, können außerhalb dieser Methode nicht abgefangen werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Ausnahme von der </font><font style="vertical-align: inherit;">Methode " </font><font style="vertical-align: inherit;">Async Task" oder "Async Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T" </font><font style="vertical-align: inherit;">ausgelöst </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, wird diese Ausnahme abgefangen und in das Task-Objekt eingefügt. </font><font style="vertical-align: inherit;">Bei Verwendung von asynchronen void-Methoden gibt es kein Task-Objekt. Daher werden alle Ausnahmen, die von der async void-Methode ausgelöst werden, direkt im SynchronizationContext aufgerufen, der aktiv war, als die async void-Methode ausgeführt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie das folgende Beispiel. </font><font style="vertical-align: inherit;">Der Erfassungsblock wird niemals erreicht.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThisWillNotCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        AsyncVoidMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span>(Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//     </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen, die in der async void-Methode ausgelöst werden, können außerhalb dieser Methode nicht abgefangen werden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vergleichen Sie mit diesem Code, bei dem anstelle von async void eine asynchrone Aufgabe verwendet wird. </font><font style="vertical-align: inherit;">In diesem Fall ist der Fang erreichbar.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ThisWillCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> AsyncTaskMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//    </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausnahme wird abgefangen und im Task-Objekt platziert.</font></font></i><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone void-Methoden können unerwünschte Nebenwirkungen verursachen, wenn der Aufrufer nicht erwartet, dass sie asynchron sind</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn Ihre asynchrone Methode nichts zurückgibt, verwenden Sie asynchrone Task (ohne ein „ </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ für Task) als Rückgabetyp.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async-Void-Methoden sind sehr schwer zu testen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Aufgrund der unterschiedlichen Fehlerbehandlung und des unterschiedlichen Layouts ist es schwierig, </font><b><font style="vertical-align: inherit;">Komponententests</font></b><font style="vertical-align: inherit;"> zu schreiben, die Async-Void-Methoden aufrufen. </font><font style="vertical-align: inherit;">Der asynchrone MSTest-Test funktioniert nur für asynchrone Methoden, die eine Aufgabe oder Aufgabe </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zurückgeben </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Ausnahme von dieser Vorgehensweise bilden asynchrone Ereignishandler. </font><font style="vertical-align: inherit;">Aber auch in diesem Fall wird empfohlen, den im Handler selbst geschriebenen Code zu minimieren - erwarten Sie eine asynchrone Task-Methode, die Logik enthält. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieber Rückkehr Aufgabe statt Rückkehr warten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erläutert, erstellt der Compiler jedes Mal, wenn Sie eine Methode als asynchron deklarieren, eine Zustandsmaschinenklasse, die die Logik Ihrer Methode tatsächlich umschließt. Dies erhöht den Overhead, der sich insbesondere bei Mobilgeräten ansammeln kann, bei denen wir strengere Ressourcenbeschränkungen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal muss eine Methode nicht asynchron sein, gibt jedoch Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zurück </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ermöglicht es der anderen Seite, sie entsprechend zu behandeln. Wenn der letzte Satz Ihres Codes eine erwartete Rückgabe ist, sollten Sie in Betracht ziehen, ihn umzugestalten, damit der Rückgabetyp der Methode Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T ist</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(anstelle von asynchronem T). </font><font style="vertical-align: inherit;">Aus diesem Grund vermeiden Sie das Generieren einer Zustandsmaschine, wodurch Ihr Code flexibler wird. </font><font style="vertical-align: inherit;">Der einzige Fall, auf den wir wirklich warten möchten, ist, wenn wir etwas mit der asynchronen Aufgabe tun, was zur Fortsetzung der Methode führt.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">AsyncTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//  !</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">//await -   ,  await  </span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> GetData();<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">JustTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//!</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">// Task</span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieber Rückgabeaufgabe statt Rückgabe warten</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beachten Sie, dass </font><font style="vertical-align: inherit;">die Rückgabe sofort erfolgt </font><font style="vertical-align: inherit;">, wenn wir nicht warten und stattdessen Aufgabe </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zurückgeben. </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich der Code also in einem try / catch-Block befindet, wird die Ausnahme nicht abgefangen. </font><font style="vertical-align: inherit;">Befindet sich der Code im using-Block, wird das Objekt sofort gelöscht. </font><font style="vertical-align: inherit;">Siehe den nächsten Tipp.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließen Sie die Rückgabeaufgabe nicht in try..catch {} oder mit {} Blöcken ein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rückgabeaufgabe kann undefiniertes Verhalten verursachen, wenn sie in einem try..catch-Block (eine von der asynchronen Methode ausgelöste Ausnahme wird niemals abgefangen) oder in einem using-Block verwendet wird, da die Aufgabe sofort zurückgegeben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Ihren asynchronen Code in einen try..catch- oder using-Block einschließen müssen, verwenden Sie stattdessen return await.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskExceptionNotCaught</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">try</span><font></font>
   {<font></font>
       <span class="hljs-comment">// ...</span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
   }<font></font>
   <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
<font></font>
   {<font></font>
       <span class="hljs-comment">//     </span><font></font>
<font></font>
       Debug.WriteLine(ex.Message);<font></font>
       <span class="hljs-keyword">throw</span>;<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskUsingProblem</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> resource = GetResource())<font></font>
   {<font></font>
<font></font>
       <span class="hljs-comment">// ...  ,     , ,    </span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData(resource);<font></font>
   }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wickeln Sie die Rückgabeaufgabe nicht in Blöcke </font></font><code>try..catch{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>using{}</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thread zum Stapelüberlauf.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie </font><font style="vertical-align: inherit;">stattdessen die </font><font style="vertical-align: inherit;">Verwendung von </font></font><code>.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>.Result</code><font style="vertical-align: inherit;"></font><code>GetAwaiter().GetResult()</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warten auf den Abschluss der Async-Aufgabe </font><i><font style="vertical-align: inherit;">blockieren</font></i><font style="vertical-align: inherit;"> müssen, verwenden Sie </font><font style="vertical-align: inherit;">alle Ausnahmen </font></font><code>GetAwaiter().GetResult().</code> <code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen Sie sie ein </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was die Fehlerbehandlung erschwert. </font><font style="vertical-align: inherit;">Der Vorteil </font></font><code>GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist, dass stattdessen die übliche Ausnahme zurückgegeben wird </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetAwaiterGetResultExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">// ,    ,     AggregateException  </span><font></font>
<font></font>
   <span class="hljs-keyword">string</span> data = GetData().Result;<font></font>
<font></font>
   <span class="hljs-comment">// ,   ,      </span><font></font>
<font></font>
   data = GetData().GetAwaiter().GetResult();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das Warten auf den Abschluss der Async-Aufgabe blockieren müssen, verwenden Sie die </font></font><code>GetAwaiter().GetResult().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informationen Weitere Informationen unter diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Methode asynchron ist, fügen Sie ihrem Namen das Async-Suffix hinzu</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die in .NET verwendete Konvention, um leichter zwischen synchronen und asynchronen Methoden zu unterscheiden (mit Ausnahme von Ereignishandlern oder Webcontroller-Methoden, die jedoch von Ihrem Code nicht explizit aufgerufen werden sollten).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Bibliotheksmethoden sollten Task.ConfigureAwait (false) verwenden, um die Leistung zu verbessern</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das .NET Framework hat das Konzept eines "Synchronisationskontexts", mit dem Sie "dorthin zurückkehren können, wo Sie zuvor waren". Immer wenn eine Aufgabe wartet, erfasst sie den aktuellen Synchronisationskontext, bevor sie wartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Abschluss der Aufgabe wird </font></font><code>.Post()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Synchronisationskontextmethode </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">, mit der die Arbeit dort fortgesetzt wird, wo sie zuvor war. Dies ist nützlich, um zum Benutzeroberflächenthread zurückzukehren oder zum gleichen ASP.NET-Kontext usw. zurückzukehren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Bibliothekscode schreiben, müssen Sie selten zu dem Kontext zurückkehren, in dem Sie sich zuvor befanden. Wenn Task.ConfigureAwait (false) verwendet wird, versucht der Code nicht mehr, an der Stelle fortzufahren, an der er zuvor war. Stattdessen wird der Code nach Möglichkeit in dem Thread beendet, der die Aufgabe abgeschlossen hat, wodurch ein Kontextwechsel vermieden wird. Dies verbessert die Leistung geringfügig und kann dazu beitragen, Deadlocks zu vermeiden.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ConfigureAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//   ConfigureAwait(false)   .</span><font></font>
<font></font>
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> GetData().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie normalerweise ConfigureAwait (false) für Serverprozesse und Bibliothekscode. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist besonders wichtig, wenn die Bibliotheksmethode für eine bessere Reaktionsfähigkeit häufig aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie normalerweise ConfigureAwait (false) für Serverprozesse im Allgemeinen. Es ist uns egal, welcher Thread zum Fortfahren verwendet wird, im Gegensatz zu Anwendungen, in denen wir zum Thread der Benutzeroberfläche zurückkehren müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ... In ASP.NET Core hat Microsoft SynchronizationContext abgeschafft, sodass Sie das theoretisch nicht benötigen. Wenn Sie jedoch Bibliothekscode schreiben, der möglicherweise in anderen Anwendungen (z. B. UI-App, Legacy-ASP.NET, Xamarin Forms) wiederverwendet werden kann, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt dies eine bewährte Methode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Video an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um eine gute Erklärung für dieses Konzept zu erhalten </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchroner Aufgabenfortschrittsbericht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein ziemlich häufiger Anwendungsfall für asynchrone Methoden besteht darin, im Hintergrund zu arbeiten, den Benutzeroberflächenthread für andere Aufgaben freizugeben und die Reaktionsfähigkeit aufrechtzuerhalten. In diesem Szenario möchten Sie möglicherweise den Fortschritt an die Benutzeroberfläche zurückmelden, damit der Benutzer den Fortschritt des Prozesses überwachen und mit dem Vorgang interagieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses häufig auftretende Problem zu lösen, stellt .NET die IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Schnittstelle bereit </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Report </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">bereitstellt </font><font style="vertical-align: inherit;">, die </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer asynchronen Task aufgerufen wird, um dem Anrufer den Fortschritt zu melden. Diese Schnittstelle wird als Parameter der asynchronen Methode akzeptiert. Der Aufrufer muss ein Objekt bereitstellen, das diese Schnittstelle implementiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET bietet Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Standardimplementierung von IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die tatsächlich empfohlen wird, da es die gesamte Logik auf niedriger Ebene behandelt, die mit dem Speichern und Wiederherstellen des Synchronisationskontexts verbunden ist. Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet auch ein Action </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Ereignis und einen Rückruf </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- beide werden aufgerufen, wenn eine Aufgabe den Fortschritt meldet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bieten zusammen eine einfache Möglichkeit, Fortschrittsinformationen von einer Hintergrundaufgabe an einen Benutzeroberflächenthread zu übertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T.</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann ein einfacher Wert sein, z. B. ein int, oder ein Objekt, das kontextbezogene Fortschrittsinformationen bereitstellt, z. B. den Fertigstellungsgrad, eine Zeichenfolgenbeschreibung der aktuellen Operation, ETA usw. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überlegen Sie, wie oft Sie Fortschritte melden. </font><font style="vertical-align: inherit;">Abhängig von der von Ihnen ausgeführten Operation stellen Sie möglicherweise fest, dass Ihre Codeberichte mehrmals pro Sekunde ausgeführt werden, was dazu führen kann, dass die Benutzeroberfläche weniger schnell reagiert. </font><font style="vertical-align: inherit;">In einem solchen Szenario wird empfohlen, den Fortschritt in größeren Abständen zu melden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im offiziellen Microsoft .NET-Blog.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Aufgaben abbrechen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer häufiger Anwendungsfall für Hintergrundaufgaben ist die Möglichkeit, die Ausführung abzubrechen. </font><font style="vertical-align: inherit;">.NET stellt die Klasse CancellationToken bereit. </font><font style="vertical-align: inherit;">Die asynchrone Methode empfängt das CancellationToken-Objekt, das dann vom Code des Anrufers und der asynchronen Methode gemeinsam genutzt wird, wodurch ein Mechanismus zum Signalisieren der Löschung bereitgestellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im häufigsten Fall erfolgt die Stornierung wie folgt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer erstellt ein CancellationTokenSource-Objekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer ruft die abgebrochene asynchrone API auf und übergibt das CancellationToken von der CancellationTokenSource (CancellationTokenSource.Token).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer fordert eine Stornierung mit dem Objekt CancellationTokenSource (CancellationTokenSource.Cancel ()) an.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Task bestätigt die Stornierung und bricht sich selbst ab, normalerweise mithilfe der CancellationToken.ThrowIfCancellationRequested-Methode.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass Sie, damit dieser Mechanismus funktioniert, Code schreiben müssen, um in regelmäßigen Abständen (d. H. Bei jeder Iteration Ihres Codes oder an einem natürlichen Haltepunkt in der Logik) nach Stornierungen zu suchen. </font><font style="vertical-align: inherit;">Idealerweise sollte die asynchrone Aufgabe nach einer Abbruchanforderung so schnell wie möglich abgebrochen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten die Rückgängigmachung für alle Methoden in Betracht ziehen, deren Abschluss lange dauern kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im offiziellen Microsoft .NET-Blog.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortschritts- und Stornierungsbericht - Beispiel</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Windows.Forms;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">TestAsyncAwait</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span> : <span class="hljs-title">Form</span><font></font>
   {<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           InitializeComponent();<font></font>
       }<font></font>
<font></font>
       CancellationTokenSource _cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnRunAsync_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-comment">//   .</span><font></font>
<font></font>
            &lt;<span class="hljs-keyword">int</span>&gt;   ,          ,   ,    , ETA  . .<font></font>
<font></font>
           <span class="hljs-keyword">var</span> progressIndicator = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-keyword">int</span>&gt;(ReportProgress);<font></font>
<font></font>
           <span class="hljs-keyword">try</span><font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">//   ,         </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> AsyncMethod(progressIndicator, _cts.Token);<font></font>
<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">catch</span> (OperationCanceledException ex)<font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">// </span><font></font>
<font></font>
               lblProgress.Text = <span class="hljs-string">"Cancelled"</span>;<font></font>
           }<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
          <span class="hljs-comment">// </span><font></font>
           _cts.Cancel();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
<font></font>
       {<font></font>
           <span class="hljs-comment">//    </span><font></font>
<font></font>
           lblProgress.Text = <span class="hljs-keyword">value</span>.ToString();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncMethod</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-keyword">int</span>&gt; progress, CancellationToken ct</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<font></font>
<font></font>
           {<font></font>
              <span class="hljs-comment">//   ,     </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   ct.ThrowIfCancellationRequested();<font></font>
<font></font>
               }<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (progress != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   progress.Report(i);<font></font>
               }<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten auf eine gewisse Zeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine Weile warten müssen (z. B. erneut versuchen, die Verfügbarkeit der Ressource zu überprüfen), müssen Sie Task.Delay verwenden. Verwenden Sie in diesem Szenario niemals Thread.Sleep.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten auf mehrere asynchrone Aufgaben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie Task.WaitAny, um auf den Abschluss einer Aufgabe zu warten. </font><font style="vertical-align: inherit;">Verwenden Sie Task.WaitAll, um auf den Abschluss aller Aufgaben zu warten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss ich mich beeilen, um zu C # 7 oder 8 zu wechseln? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melden Sie sich für ein kostenloses Webinar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an, um dieses Thema zu diskutieren.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488058/index.html">Grafik Dummies: Eine Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de488060/index.html">Backblaze - Festplattenstatistik 2019</a></li>
<li><a href="../de488062/index.html">Dynamics 365 & Power Platform Meetup bei Lamoda - Bericht</a></li>
<li><a href="../de488072/index.html">Ist Koin Dependency Injection oder Service Locator?</a></li>
<li><a href="../de488078/index.html">Mein Bot für den Russian AI Cup 2019</a></li>
<li><a href="../de488088/index.html">Wie Habr mit staatlichen Stellen und anderen Antragstellern umgeht. Transparenzbericht für alle Jahre</a></li>
<li><a href="../de488092/index.html">Hackathons. Wie man das Beste herausholt und überlebt</a></li>
<li><a href="../de488096/index.html">400 g. Blick von der Seite des Getriebes. ZR / ZR +</a></li>
<li><a href="../de488098/index.html">So erstellen Sie ein Django-Projekt aus einer Vorlage</a></li>
<li><a href="../de488102/index.html">Die Beziehung zwischen C # und C #: REST, gRPC und alles dazwischen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>