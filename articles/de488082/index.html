<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßï üëè üåÄ Auf den Punkt gebracht: Async / Await Best Practices in .NET üïù üßúüèº üí•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Vorfeld des Kursbeginns erstellte "C # Developer" eine √úbersetzung von interessantem Material.
 
 
 
 Async / Await - Einf√ºhrung
 Das Async / Await...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Auf den Punkt gebracht: Async / Await Best Practices in .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/488082/"><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vorfeld des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kursbeginns</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erstellte </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">"C # Developer"</font></a><font style="vertical-align: inherit;"> eine √úbersetzung von interessantem Material.</font></font></i></b><br>
<br>
<img src="https://habrastorage.org/webt/6f/io/l8/6fiol8vwkg-r8ja-3zurutnz-ci.png"><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / Await - Einf√ºhrung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Async / Await-Sprachkonstrukt existiert seit C # Version 5.0 (2012) und wurde schnell zu einer der S√§ulen der modernen .NET-Programmierung. Jeder C # -Entwickler mit Selbstachtung sollte es verwenden, um die Anwendungsleistung, die allgemeine Reaktionsf√§higkeit und die Lesbarkeit des Codes zu verbessern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Await macht die Einf√ºhrung von asynchronem Code t√§uschend einfach und macht es f√ºr den Programmierer unn√∂tig, die Details seiner Verarbeitung zu verstehen. Aber wie viele von uns wissen wirklich, wie es funktioniert und welche Vor- und Nachteile hat diese Methode? </font><font style="vertical-align: inherit;">Es gibt viele n√ºtzliche Informationen, die jedoch fragmentiert sind. Deshalb habe ich beschlossen, diesen Artikel zu schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann besch√§ftigen wir uns mit dem Thema.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zustandsmaschine (IAsyncStateMachine)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erste, was Sie wissen m√ºssen, ist, dass der Compiler jedes Mal, wenn Sie eine Methode oder Funktion mit Async / Await haben, Ihre Methode in eine generierte Klasse verwandelt, die die IAsyncStateMachine-Schnittstelle implementiert. Diese Klasse ist f√ºr die Aufrechterhaltung des Status Ihrer Methode w√§hrend des Lebenszyklus einer asynchronen Operation verantwortlich. Sie kapselt alle Variablen Ihrer Methode in Form von Feldern und unterteilt Ihren Code in Abschnitte, die w√§hrend Zustandsmaschinen√ºberg√§ngen zwischen Status ausgef√ºhrt werden, damit der Thread die Methode verlassen kann und wann wird zur√ºckkehren, der Zustand wird sich nicht √§ndern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Beispiel finden Sie hier eine sehr einfache Klassendefinition mit zwei asynchronen Methoden: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
using System.Threading.Tasks;</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Diagnostics;<font></font>
<font></font>
<span class="hljs-keyword">namespace</span> <span class="hljs-title">AsyncAwait</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAwait</span><font></font>
    {<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-keyword">int</span> myVariable = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After First Await"</span>);<font></font>
            myVariable = <span class="hljs-number">1</span>;<font></font>
<font></font>
            <span class="hljs-keyword">await</span> DummyAsyncMethod();<font></font>
            Debug.WriteLine(<span class="hljs-string">"Continuation - After Second Await"</span>);<font></font>
            myVariable = <span class="hljs-number">2</span>;<font></font>
<font></font>
        }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DummyAsyncMethod</span>(<span class="hljs-params"></span>)</span><font></font>
        {<font></font>
            <span class="hljs-comment">// </span><font></font>
        }<font></font>
<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse mit zwei asynchronen Methoden</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn wir uns den Code ansehen, der w√§hrend der Assembly generiert wurde, sehen wir ungef√§hr Folgendes: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qo/xe/63/qoxe63foidhmllsdwfi78tdhrsm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass zwei neue innere Klassen f√ºr uns generiert wurden, eine f√ºr jede asynchrone Methode. Diese Klassen enthalten eine Zustandsmaschine f√ºr jede unserer asynchronen Methoden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem </font></font><code><code>&lt;AsyncAwaitExample&gt;</code></code><code> d__0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir </font><font style="vertical-align: inherit;">den dekompilierten Code f√ºr untersucht haben </font><font style="vertical-align: inherit;">, werden wir feststellen, dass unsere interne Variable </font></font><code>¬´myVariable¬ª</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jetzt ein Klassenfeld ist: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/_m/qj/gd_mqjxvsjfw9-_zfd7740n42ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir k√∂nnen auch andere Klassenfelder sehen, die intern zur Aufrechterhaltung des Status verwendet werden </font></font><code>IAsyncStateMachine</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Die Zustandsmaschine durchl√§uft Zust√§nde mit der Methode</font></font><code>MoveNext()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der Tat ein gro√üer Schalter. </font><font style="vertical-align: inherit;">Beachten Sie, wie die Methode nach jedem asynchronen Aufruf in verschiedenen Abschnitten fortgesetzt wird (mit der vorherigen Fortsetzungsbezeichnung). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/km/li/ea/kmlieahswg0ebqn3db5nctfzsti.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, asynchrone Eleganz hat ihren Preis. </font><font style="vertical-align: inherit;">Die Verwendung von async / await erh√∂ht die Komplexit√§t (die Sie m√∂glicherweise nicht kennen). </font><font style="vertical-align: inherit;">In der serverseitigen Logik ist dies m√∂glicherweise nicht kritisch. Insbesondere bei der Programmierung mobiler Anwendungen, die jeden CPU- und KB-Speicherzyklus ber√ºcksichtigen, sollten Sie dies ber√ºcksichtigen, da sich der Overhead schnell erh√∂hen kann. </font><font style="vertical-align: inherit;">Sp√§ter in diesem Artikel werden Best Practices f√ºr die Verwendung von Async / Await nur bei Bedarf erl√§utert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie sich dieses </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Video auf YouTube an</font></a><font style="vertical-align: inherit;"> , um eine ziemlich lehrreiche Erkl√§rung der Zustandsmaschine zu erhalten</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann wird Async / Await verwendet?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt im Allgemeinen zwei Szenarien, in denen Async / Await die richtige L√∂sung ist.</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E / A-bezogene Arbeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ihr Code erwartet etwas, z. B. Daten aus einer Datenbank, Lesen einer Datei oder Aufrufen eines Webdienstes. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie Async / Await verwenden, nicht die Task Parallel Library.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU-bezogene Arbeit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Ihr Code f√ºhrt komplexe Berechnungen durch. </font><font style="vertical-align: inherit;">In diesem Fall sollten Sie Async / Await verwenden, aber Sie m√ºssen die Arbeit in einem anderen Thread mit Task.Run beginnen. </font><font style="vertical-align: inherit;">Sie k√∂nnen auch die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task Parallel Library verwenden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async den ganzen Weg</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit asynchronen Methoden arbeiten, werden Sie schnell feststellen, dass sich die asynchrone Natur des Codes in Ihrer Aufrufhierarchie auf und ab ausbreitet. Dies bedeutet, dass Sie Ihren aufrufenden Code auch asynchron machen m√ºssen und so weiter. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnten versucht sein, dies zu stoppen, indem Sie den Code mit Task.Result oder Task.Wait blockieren, einen kleinen Teil der Anwendung konvertieren und in eine synchrone API einbinden, sodass der Rest der Anwendung von √Ñnderungen isoliert ist. Leider ist dies ein Rezept f√ºr die Erstellung schwer zu verfolgender Deadlocks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die beste L√∂sung f√ºr dieses Problem besteht darin, asynchronen Code auf nat√ºrliche Weise in der Codebasis wachsen zu lassen. </font><font style="vertical-align: inherit;">Wenn Sie dieser Entscheidung folgen, wird die Erweiterung des asynchronen Codes bis zu seinem Einstiegspunkt angezeigt, normalerweise eine Ereignishandler- oder Controller-Aktion. </font><font style="vertical-align: inherit;">Geben Sie sich spurlos der Asynchronit√§t hin! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Methode als asynchron deklariert ist, stellen Sie sicher, dass darauf gewartet wird!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Compiler eine asynchrone Methode findet, verwandelt er diese Methode in eine Zustandsmaschine. </font><font style="vertical-align: inherit;">Wenn Ihr Code nicht in seinem Hauptteil wartet, generiert der Compiler eine Warnung, aber die Zustandsmaschine wird trotzdem erstellt, wodurch unn√∂tiger Overhead f√ºr eine Operation entsteht, die niemals tats√§chlich abgeschlossen wird.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie asynchrone Leere</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Asynchrone Leere ist etwas, das wirklich vermieden werden sollte. </font><font style="vertical-align: inherit;">Machen Sie es sich zur Regel, asynchrone Task anstelle von async void zu verwenden.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethod</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">//!</span>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methoden async void und async Task Hierf√ºr</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
gibt es mehrere Gr√ºnde, darunter:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen, die in der asynchronen Void-Methode ausgel√∂st werden, k√∂nnen au√üerhalb dieser Methode nicht abgefangen werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font></li>
</ul><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn eine Ausnahme von der </font><font style="vertical-align: inherit;">Methode " </font><font style="vertical-align: inherit;">Async Task" oder "Async Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T" </font><font style="vertical-align: inherit;">ausgel√∂st </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird, wird diese Ausnahme abgefangen und in das Task-Objekt eingef√ºgt. </font><font style="vertical-align: inherit;">Bei Verwendung von asynchronen void-Methoden gibt es kein Task-Objekt. Daher werden alle Ausnahmen, die von der async void-Methode ausgel√∂st werden, direkt im SynchronizationContext aufgerufen, der aktiv war, als die async void-Methode ausgef√ºhrt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie das folgende Beispiel. </font><font style="vertical-align: inherit;">Der Erfassungsblock wird niemals erreicht.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">AsyncVoidMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThisWillNotCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        AsyncVoidMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span>(Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//     </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausnahmen, die in der async void-Methode ausgel√∂st werden, k√∂nnen au√üerhalb dieser Methode nicht abgefangen werden.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vergleichen Sie mit diesem Code, bei dem anstelle von async void eine asynchrone Aufgabe verwendet wird. </font><font style="vertical-align: inherit;">In diesem Fall ist der Fang erreichbar.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncTaskMethodThrowsException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Hmmm, something went wrong!"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ThisWillCatchTheException</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">try</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> AsyncTaskMethodThrowsException();<font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
    {<font></font>
        <span class="hljs-comment">//    </span><font></font>
        Debug.WriteLine(ex.Message);<font></font>
    }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Ausnahme wird abgefangen und im Task-Objekt platziert.</font></font></i><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone void-Methoden k√∂nnen unerw√ºnschte Nebenwirkungen verursachen, wenn der Aufrufer nicht erwartet, dass sie asynchron sind</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Wenn Ihre asynchrone Methode nichts zur√ºckgibt, verwenden Sie asynchrone Task (ohne ein ‚Äû </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú f√ºr Task) als R√ºckgabetyp.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async-Void-Methoden sind sehr schwer zu testen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Aufgrund der unterschiedlichen Fehlerbehandlung und des unterschiedlichen Layouts ist es schwierig, </font><b><font style="vertical-align: inherit;">Komponententests</font></b><font style="vertical-align: inherit;"> zu schreiben, die Async-Void-Methoden aufrufen. </font><font style="vertical-align: inherit;">Der asynchrone MSTest-Test funktioniert nur f√ºr asynchrone Methoden, die eine Aufgabe oder Aufgabe </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zur√ºckgeben </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine Ausnahme von dieser Vorgehensweise bilden asynchrone Ereignishandler. </font><font style="vertical-align: inherit;">Aber auch in diesem Fall wird empfohlen, den im Handler selbst geschriebenen Code zu minimieren - erwarten Sie eine asynchrone Task-Methode, die Logik enth√§lt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MSDN- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieber R√ºckkehr Aufgabe statt R√ºckkehr warten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie bereits erl√§utert, erstellt der Compiler jedes Mal, wenn Sie eine Methode als asynchron deklarieren, eine Zustandsmaschinenklasse, die die Logik Ihrer Methode tats√§chlich umschlie√üt. Dies erh√∂ht den Overhead, der sich insbesondere bei Mobilger√§ten ansammeln kann, bei denen wir strengere Ressourcenbeschr√§nkungen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal muss eine Methode nicht asynchron sein, gibt jedoch Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zur√ºck </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und erm√∂glicht es der anderen Seite, sie entsprechend zu behandeln. Wenn der letzte Satz Ihres Codes eine erwartete R√ºckgabe ist, sollten Sie in Betracht ziehen, ihn umzugestalten, damit der R√ºckgabetyp der Methode Task </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T ist</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(anstelle von asynchronem T). </font><font style="vertical-align: inherit;">Aus diesem Grund vermeiden Sie das Generieren einer Zustandsmaschine, wodurch Ihr Code flexibler wird. </font><font style="vertical-align: inherit;">Der einzige Fall, auf den wir wirklich warten m√∂chten, ist, wenn wir etwas mit der asynchronen Aufgabe tun, was zur Fortsetzung der Methode f√ºhrt.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">AsyncTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//  !</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">//await -   ,  await  </span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> GetData();<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">JustTask</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//!</span>
   <span class="hljs-comment">//...  -  </span>
   <span class="hljs-comment">// Task</span><font></font>
<font></font>
   <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieber R√ºckgabeaufgabe statt R√ºckgabe warten</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Beachten Sie, dass </font><font style="vertical-align: inherit;">die R√ºckgabe sofort erfolgt </font><font style="vertical-align: inherit;">, wenn wir nicht warten und stattdessen Aufgabe </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T zur√ºckgeben. </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich der Code also in einem try / catch-Block befindet, wird die Ausnahme nicht abgefangen. </font><font style="vertical-align: inherit;">Befindet sich der Code im using-Block, wird das Objekt sofort gel√∂scht. </font><font style="vertical-align: inherit;">Siehe den n√§chsten Tipp.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlie√üen Sie die R√ºckgabeaufgabe nicht in try..catch {} oder mit {} Bl√∂cken ein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R√ºckgabeaufgabe kann undefiniertes Verhalten verursachen, wenn sie in einem try..catch-Block (eine von der asynchronen Methode ausgel√∂ste Ausnahme wird niemals abgefangen) oder in einem using-Block verwendet wird, da die Aufgabe sofort zur√ºckgegeben wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Ihren asynchronen Code in einen try..catch- oder using-Block einschlie√üen m√ºssen, verwenden Sie stattdessen return await.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskExceptionNotCaught</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">try</span><font></font>
   {<font></font>
       <span class="hljs-comment">// ...</span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData();<font></font>
<font></font>
   }<font></font>
   <span class="hljs-keyword">catch</span> (Exception ex)<font></font>
<font></font>
   {<font></font>
       <span class="hljs-comment">//     </span><font></font>
<font></font>
       Debug.WriteLine(ex.Message);<font></font>
       <span class="hljs-keyword">throw</span>;<font></font>
   }<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">public</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">ReturnTaskUsingProblem</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> resource = GetResource())<font></font>
   {<font></font>
<font></font>
       <span class="hljs-comment">// ...  ,     , ,    </span><font></font>
<font></font>
       <span class="hljs-keyword">return</span> GetData(resource);<font></font>
   }<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wickeln Sie die R√ºckgabeaufgabe nicht in Bl√∂cke </font></font><code>try..catch{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>using{}</code></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thread zum Stapel√ºberlauf.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie </font><font style="vertical-align: inherit;">stattdessen die </font><font style="vertical-align: inherit;">Verwendung von </font></font><code>.Wait()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>.Result</code><font style="vertical-align: inherit;"></font><code>GetAwaiter().GetResult()</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Warten auf den Abschluss der Async-Aufgabe </font><i><font style="vertical-align: inherit;">blockieren</font></i><font style="vertical-align: inherit;"> m√ºssen, verwenden Sie </font><font style="vertical-align: inherit;">alle Ausnahmen </font></font><code>GetAwaiter().GetResult().</code> <code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werfen Sie sie ein </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was die Fehlerbehandlung erschwert. </font><font style="vertical-align: inherit;">Der Vorteil </font></font><code>GetAwaiter().GetResult()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist, dass stattdessen die √ºbliche Ausnahme zur√ºckgegeben wird </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetAwaiterGetResultExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">// ,    ,     AggregateException  </span><font></font>
<font></font>
   <span class="hljs-keyword">string</span> data = GetData().Result;<font></font>
<font></font>
   <span class="hljs-comment">// ,   ,      </span><font></font>
<font></font>
   data = GetData().GetAwaiter().GetResult();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie das Warten auf den Abschluss der Async-Aufgabe blockieren m√ºssen, verwenden Sie die </font></font><code>GetAwaiter().GetResult().</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informationen Weitere Informationen unter diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die Methode asynchron ist, f√ºgen Sie ihrem Namen das Async-Suffix hinzu</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die in .NET verwendete Konvention, um leichter zwischen synchronen und asynchronen Methoden zu unterscheiden (mit Ausnahme von Ereignishandlern oder Webcontroller-Methoden, die jedoch von Ihrem Code nicht explizit aufgerufen werden sollten).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Bibliotheksmethoden sollten Task.ConfigureAwait (false) verwenden, um die Leistung zu verbessern</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das .NET Framework hat das Konzept eines "Synchronisationskontexts", mit dem Sie "dorthin zur√ºckkehren k√∂nnen, wo Sie zuvor waren". Immer wenn eine Aufgabe wartet, erfasst sie den aktuellen Synchronisationskontext, bevor sie wartet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach Abschluss der Aufgabe wird </font></font><code>.Post()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Synchronisationskontextmethode </font><font style="vertical-align: inherit;">aufgerufen </font><font style="vertical-align: inherit;">, mit der die Arbeit dort fortgesetzt wird, wo sie zuvor war. Dies ist n√ºtzlich, um zum Benutzeroberfl√§chenthread zur√ºckzukehren oder zum gleichen ASP.NET-Kontext usw. zur√ºckzukehren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Bibliothekscode schreiben, m√ºssen Sie selten zu dem Kontext zur√ºckkehren, in dem Sie sich zuvor befanden. Wenn Task.ConfigureAwait (false) verwendet wird, versucht der Code nicht mehr, an der Stelle fortzufahren, an der er zuvor war. Stattdessen wird der Code nach M√∂glichkeit in dem Thread beendet, der die Aufgabe abgeschlossen hat, wodurch ein Kontextwechsel vermieden wird. Dies verbessert die Leistung geringf√ºgig und kann dazu beitragen, Deadlocks zu vermeiden.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ConfigureAwaitExample</span>(<span class="hljs-params"></span>)</span><font></font>
<font></font>
{<font></font>
   <span class="hljs-comment">//   ConfigureAwait(false)   .</span><font></font>
<font></font>
   <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> GetData().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie normalerweise ConfigureAwait (false) f√ºr Serverprozesse und Bibliothekscode. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist besonders wichtig, wenn die Bibliotheksmethode f√ºr eine bessere Reaktionsf√§higkeit h√§ufig aufgerufen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie normalerweise ConfigureAwait (false) f√ºr Serverprozesse im Allgemeinen. Es ist uns egal, welcher Thread zum Fortfahren verwendet wird, im Gegensatz zu Anwendungen, in denen wir zum Thread der Benutzeroberfl√§che zur√ºckkehren m√ºssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ... In ASP.NET Core hat Microsoft SynchronizationContext abgeschafft, sodass Sie das theoretisch nicht ben√∂tigen. Wenn Sie jedoch Bibliothekscode schreiben, der m√∂glicherweise in anderen Anwendungen (z. B. UI-App, Legacy-ASP.NET, Xamarin Forms) wiederverwendet werden kann, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bleibt dies eine bew√§hrte Methode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie sich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Video an</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um eine gute Erkl√§rung f√ºr dieses Konzept zu erhalten </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchroner Aufgabenfortschrittsbericht</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein ziemlich h√§ufiger Anwendungsfall f√ºr asynchrone Methoden besteht darin, im Hintergrund zu arbeiten, den Benutzeroberfl√§chenthread f√ºr andere Aufgaben freizugeben und die Reaktionsf√§higkeit aufrechtzuerhalten. In diesem Szenario m√∂chten Sie m√∂glicherweise den Fortschritt an die Benutzeroberfl√§che zur√ºckmelden, damit der Benutzer den Fortschritt des Prozesses √ºberwachen und mit dem Vorgang interagieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dieses h√§ufig auftretende Problem zu l√∂sen, stellt .NET die IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Schnittstelle bereit </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die Report </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Methode </font><font style="vertical-align: inherit;">bereitstellt </font><font style="vertical-align: inherit;">, die </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von einer asynchronen Task aufgerufen wird, um dem Anrufer den Fortschritt zu melden. Diese Schnittstelle wird als Parameter der asynchronen Methode akzeptiert. Der Aufrufer muss ein Objekt bereitstellen, das diese Schnittstelle implementiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NET bietet Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Standardimplementierung von IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die tats√§chlich empfohlen wird, da es die gesamte Logik auf niedriger Ebene behandelt, die mit dem Speichern und Wiederherstellen des Synchronisationskontexts verbunden ist. Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bietet auch ein Action </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T- </font><font style="vertical-align: inherit;">Ereignis und einen R√ºckruf </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- beide werden aufgerufen, wenn eine Aufgabe den Fortschritt meldet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IProgress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Progress </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T </font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bieten zusammen eine einfache M√∂glichkeit, Fortschrittsinformationen von einer Hintergrundaufgabe an einen Benutzeroberfl√§chenthread zu √ºbertragen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass </font></font><code>&lt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T.</font></font><code>&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies kann ein einfacher Wert sein, z. B. ein int, oder ein Objekt, das kontextbezogene Fortschrittsinformationen bereitstellt, z. B. den Fertigstellungsgrad, eine Zeichenfolgenbeschreibung der aktuellen Operation, ETA usw. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberlegen Sie, wie oft Sie Fortschritte melden. </font><font style="vertical-align: inherit;">Abh√§ngig von der von Ihnen ausgef√ºhrten Operation stellen Sie m√∂glicherweise fest, dass Ihre Codeberichte mehrmals pro Sekunde ausgef√ºhrt werden, was dazu f√ºhren kann, dass die Benutzeroberfl√§che weniger schnell reagiert. </font><font style="vertical-align: inherit;">In einem solchen Szenario wird empfohlen, den Fortschritt in gr√∂√üeren Abst√§nden zu melden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im offiziellen Microsoft .NET-Blog.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Aufgaben abbrechen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiterer h√§ufiger Anwendungsfall f√ºr Hintergrundaufgaben ist die M√∂glichkeit, die Ausf√ºhrung abzubrechen. </font><font style="vertical-align: inherit;">.NET stellt die Klasse CancellationToken bereit. </font><font style="vertical-align: inherit;">Die asynchrone Methode empf√§ngt das CancellationToken-Objekt, das dann vom Code des Anrufers und der asynchronen Methode gemeinsam genutzt wird, wodurch ein Mechanismus zum Signalisieren der L√∂schung bereitgestellt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im h√§ufigsten Fall erfolgt die Stornierung wie folgt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer erstellt ein CancellationTokenSource-Objekt.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer ruft die abgebrochene asynchrone API auf und √ºbergibt das CancellationToken von der CancellationTokenSource (CancellationTokenSource.Token).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Aufrufer fordert eine Stornierung mit dem Objekt CancellationTokenSource (CancellationTokenSource.Cancel ()) an.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Task best√§tigt die Stornierung und bricht sich selbst ab, normalerweise mithilfe der CancellationToken.ThrowIfCancellationRequested-Methode.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass Sie, damit dieser Mechanismus funktioniert, Code schreiben m√ºssen, um in regelm√§√üigen Abst√§nden (d. H. Bei jeder Iteration Ihres Codes oder an einem nat√ºrlichen Haltepunkt in der Logik) nach Stornierungen zu suchen. </font><font style="vertical-align: inherit;">Idealerweise sollte die asynchrone Aufgabe nach einer Abbruchanforderung so schnell wie m√∂glich abgebrochen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie sollten die R√ºckg√§ngigmachung f√ºr alle Methoden in Betracht ziehen, deren Abschluss lange dauern kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Weitere Informationen finden Sie in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diesem Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> im offiziellen Microsoft .NET-Blog.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortschritts- und Stornierungsbericht - Beispiel</font></font></h4><br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Windows.Forms;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">namespace</span> <span class="hljs-title">TestAsyncAwait</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span> : <span class="hljs-title">Form</span><font></font>
   {<font></font>
       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncProgressCancelExampleForm</span>(<span class="hljs-params"></span>)</span><font></font>
       {<font></font>
           InitializeComponent();<font></font>
       }<font></font>
<font></font>
       CancellationTokenSource _cts = <span class="hljs-keyword">new</span> CancellationTokenSource();<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnRunAsync_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-comment">//   .</span><font></font>
<font></font>
            &lt;<span class="hljs-keyword">int</span>&gt;   ,          ,   ,    , ETA  . .<font></font>
<font></font>
           <span class="hljs-keyword">var</span> progressIndicator = <span class="hljs-keyword">new</span> Progress&lt;<span class="hljs-keyword">int</span>&gt;(ReportProgress);<font></font>
<font></font>
           <span class="hljs-keyword">try</span><font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">//   ,         </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> AsyncMethod(progressIndicator, _cts.Token);<font></font>
<font></font>
           }<font></font>
<font></font>
           <span class="hljs-keyword">catch</span> (OperationCanceledException ex)<font></font>
<font></font>
           {<font></font>
               <span class="hljs-comment">// </span><font></font>
<font></font>
               lblProgress.Text = <span class="hljs-string">"Cancelled"</span>;<font></font>
           }<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">btnCancel_Click</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> sender, EventArgs e</span>)</span><font></font>
<font></font>
       {<font></font>
          <span class="hljs-comment">// </span><font></font>
           _cts.Cancel();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReportProgress</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span><font></font>
<font></font>
       {<font></font>
           <span class="hljs-comment">//    </span><font></font>
<font></font>
           lblProgress.Text = <span class="hljs-keyword">value</span>.ToString();<font></font>
<font></font>
       }<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">AsyncMethod</span>(<span class="hljs-params">IProgress&lt;<span class="hljs-keyword">int</span>&gt; progress, CancellationToken ct</span>)</span><font></font>
<font></font>
       {<font></font>
<font></font>
           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<font></font>
<font></font>
           {<font></font>
              <span class="hljs-comment">//   ,     </span><font></font>
<font></font>
               <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   ct.ThrowIfCancellationRequested();<font></font>
<font></font>
               }<font></font>
<font></font>
               <span class="hljs-comment">//   </span><font></font>
<font></font>
               <span class="hljs-keyword">if</span> (progress != <span class="hljs-literal">null</span>)<font></font>
<font></font>
               {<font></font>
<font></font>
                   progress.Report(i);<font></font>
               }<font></font>
           }<font></font>
       }<font></font>
   }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten auf eine gewisse Zeit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine Weile warten m√ºssen (z. B. erneut versuchen, die Verf√ºgbarkeit der Ressource zu √ºberpr√ºfen), m√ºssen Sie Task.Delay verwenden. Verwenden Sie in diesem Szenario niemals Thread.Sleep.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten auf mehrere asynchrone Aufgaben</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie Task.WaitAny, um auf den Abschluss einer Aufgabe zu warten. </font><font style="vertical-align: inherit;">Verwenden Sie Task.WaitAll, um auf den Abschluss aller Aufgaben zu warten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss ich mich beeilen, um zu C # 7 oder 8 zu wechseln? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Melden Sie sich f√ºr ein kostenloses Webinar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an, um dieses Thema zu diskutieren.</font></font></b></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488058/index.html">Grafik Dummies: Eine Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de488060/index.html">Backblaze - Festplattenstatistik 2019</a></li>
<li><a href="../de488062/index.html">Dynamics 365 & Power Platform Meetup bei Lamoda - Bericht</a></li>
<li><a href="../de488072/index.html">Ist Koin Dependency Injection oder Service Locator?</a></li>
<li><a href="../de488078/index.html">Mein Bot f√ºr den Russian AI Cup 2019</a></li>
<li><a href="../de488088/index.html">Wie Habr mit staatlichen Stellen und anderen Antragstellern umgeht. Transparenzbericht f√ºr alle Jahre</a></li>
<li><a href="../de488092/index.html">Hackathons. Wie man das Beste herausholt und √ºberlebt</a></li>
<li><a href="../de488096/index.html">400 g. Blick von der Seite des Getriebes. ZR / ZR +</a></li>
<li><a href="../de488098/index.html">So erstellen Sie ein Django-Projekt aus einer Vorlage</a></li>
<li><a href="../de488102/index.html">Die Beziehung zwischen C # und C #: REST, gRPC und alles dazwischen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>