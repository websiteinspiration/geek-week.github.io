<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 👩🏾‍🤝‍👨🏽 🙃 Speicherzuordnungen 🛶 📮 🤞🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo alle zusammen! Vor nicht allzu langer Zeit kam mir nach einer sehr genauen Untersuchung der Allokatoren und Speicherzuweisungsalgorithmen sowie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Speicherzuordnungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo alle zusammen! </font><font style="vertical-align: inherit;">Vor nicht allzu langer Zeit kam mir nach einer sehr genauen Untersuchung der Allokatoren und Speicherzuweisungsalgorithmen sowie ihrer anschließenden Anwendung in der Praxis die Idee, einen Artikel zu schreiben, der sie so detailliert wie möglich beschreibt. </font><font style="vertical-align: inherit;">Ich denke, dass dieses Thema sehr beliebt sein wird, da es im Netzwerk nur sehr wenige Quellen gibt, insbesondere im russischsprachigen Teil, die sich diesem Thema widmen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst möchte ich sofort darauf hinweisen, dass, wenn jemand zuerst die Begriffe "Allokator", "Speicherzuweisungsalgorithmen" hört und nicht versteht, wofür dies alles ist, ich Sie vor dem Lesen dieses Artikels empfehlen sollte, sich mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelle </font><font style="vertical-align: inherit;">vertraut zu machen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Artikel wird recht gut beschrieben, welche Probleme bei Standardspeicherzuordnungen auftreten und für welche Zwecke es sich lohnt, neben Standardmethoden auch andere Methoden der Speicherzuweisung zu verwenden. </font><font style="vertical-align: inherit;">Hier werde ich nur über die Verteilungsalgorithmen selbst sprechen und am Ende natürlich eine Implementierung eines der Allokatoren geben, die problemlos in Standard-C ++ - Containern verwendet werden können.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grundlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fünf Hauptoperationen, die mit einem Allokator ausgeführt werden können, sind konzeptionell hervorgehoben (ich möchte darauf hinweisen, dass nicht alle Allokatoren explizit dieser Schnittstelle entsprechen können):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - erstellt einen Allokator und gibt ihm eine bestimmte Menge an Speicher;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuweisen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - wählt einen Block einer bestimmten Größe aus dem Speicherbereich aus, den der Zuweiser steuert;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freigeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - gibt einen bestimmten Block frei;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - befreit alle zugewiesenen Blöcke aus dem Allokatorspeicher (der dem Allokator zugewiesene Speicher wird nicht freigegeben);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zerstören</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Zerstört den Allokator mit der anschließenden Freigabe des dem Allokator zugewiesenen Speichers.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearer Allokator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linearer Allokator, es ist auch "linear" - dies ist der einfachste Typ von Allokatoren. Die Idee ist, einen Zeiger auf den Anfang des Speicherblocks für den zugewiesenen Allokator zu speichern und auch einen anderen Zeiger oder eine andere numerische Darstellung zu verwenden, die jedes Mal verschoben werden muss, wenn die Zuordnung vom Allokator abgeschlossen ist. In diesem Allokator wird die interne Fragmentierung minimiert, da alle Elemente nacheinander eingefügt werden (räumliche Lokalität) und die einzige Fragmentierung zwischen ihnen die Ausrichtung ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner schlage ich vor, einige Beispiele zu betrachten, in denen detailliert gezeigt wird, wie dieser Allokator funktioniert. Nehmen Sie einen Speicherblock, der 14 Bytes entspricht, und geben Sie ihn der Steuerung des Allokators. Wie aus dem Bild unten ersichtlich, speichern wir einen Zeiger auf den Anfang des Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und speichern Sie außerdem zwei Zeiger oder zwei numerische Darstellungen, die Informationen über die Gesamtgröße ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und die verwendeten ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendeten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Speichergrößen enthalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, der Allokator hat eine Anforderung zum Zuweisen von 4 Byte Speicher erhalten. </font><font style="vertical-align: inherit;">Die Aktionen des Allokators bei der Ausführung dieser Anforderung sind wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen Sie, ob genügend Speicher zum Zuweisen vorhanden ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie den aktuell verwendeten Zeiger, der dem Benutzer später als Zeiger auf einen Block des zugewiesenen Speichers vom Allokator übergeben wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie den verwendeten Zeiger um einen Betrag, der der Größe des zugewiesenen Speicherblocks entspricht, d. h. </font><font style="vertical-align: inherit;">um 4 Bytes.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner kommt beispielsweise eine Anforderung für die Zuweisung von 8 Bytes und dementsprechend sind die Aktionen des Zuweisers unabhängig von der Größe des zugewiesenen Speicherblocks genau gleich. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber hier wird es schon etwas interessanter sein, wenn beispielsweise eine Anforderung zum Zuweisen von nur 1 Byte kommt und wir keine Blöcke im Speicher ausrichten möchten (z. B. Adressen, die ein Vielfaches von 2, 4, ... sind), bleiben die Aktionen des Zuweisers genau gleich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch Speicherblöcke mit einer bestimmten Ausrichtung zuweisen müssen (z. B. Ausrichtung von Adressen mit einem Vielfachen von 2), ändert sich die Aktion des Zuweisers geringfügig. Es ändert sich nicht in Bezug auf die Implementierung, sondern darin, dass wir zusätzlich zu den Daten selbst, die dem Volumen eines Bytes entsprechen, auch ein zusätzliches Byte aus dem Speicher des Allokators zur Ausrichtung entnehmen, was keine Bedeutung hat. Dies ist genau die sehr mögliche minimale Fragmentierung des Speichers innerhalb eines linearen Allokators. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Großartig, jetzt ist die Zeit gekommen, über die Freigabe von Speicher zu sprechen. Wie bereits erwähnt, unterstützt diese Art von Allokotor die selektive Freigabe bestimmter Speicherblöcke nicht. Das heißt, wenn wir eine subtile Analogie mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free ziehen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einen Zeiger auf beispielsweise </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00 haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir könnten diesen Speicherblock freigeben, aber ein linearer Allokator kann uns dies nicht erlauben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was wir tun können, ist, den gesamten belegten Speicher vollständig im Allokator freizugeben und weiter damit zu arbeiten, als wäre er vollständig leer.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool Allokator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee eines Blockzuweisers ist, dass er ein großes Stück Speicher in kleinere Teile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">derselben Größe aufteilt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Im Kern ist es auch ein sehr einfacher Zuweiser, da er bei Anforderung einer Zuweisung einfach einen der freien Speicherplätze fester Größe zurückgibt und diesen Speicherbereich einfach für die zukünftige Verwendung speichert, wenn er freigegeben werden soll. Daher ist die Verteilung sehr schnell und die Fragmentierung immer noch sehr gering. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben einem linearen Allokator schlage ich außerdem vor, alles anhand eines Beispiels zu betrachten, um die Funktionsweise genauer zu verstehen. Daher nehmen wir einen Speicherblock mit 12 Bytes und geben ihn an die Steuerung des Allokators weiter. Wie Sie auf dem Bild unten sehen können, halten wir den Zeiger auf den Anfang (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des vom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesteuerten Speichers sowie eine Liste ( </font><i><font style="vertical-align: inherit;">Freeblocks</font></i><font style="vertical-align: inherit;"> ) der Adressen der freien Blöcke im Allokator. Um Daten zu speichern, bei denen der Block belegt oder frei ist, können Sie viele Tools verwenden, z. B. ein Array von Booleschen Werten. Ich habe mich jedoch für eine einfach verbundene Liste entschieden, da diese dieses Konzept (übrigens) am einfachsten und klarsten kennzeichnet. Die Links der Liste können in freien Speicherblöcken gespeichert werden, wodurch die zusätzlichen Speicherkosten entfallen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung zum Zuweisen eines Speicherblocks eingeht, sind die Aktionen des Zuweisers sehr primitiv. Zunächst prüft er, ob die Liste der freien Blöcke Links enthält. Wenn diese nicht vorhanden sind, ist es nicht schwer zu erraten, dass der Speicher im Allokator bereits leer ist. Wenn dort mindestens ein Link vorhanden ist, wird einfach der Root- oder Tail-Link (in dieser Implementierung werden Tail-Links angegeben) der Liste entfernt und dem Benutzer seine Adresse mitgeteilt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung für die Zuweisung mehrerer Speicherblöcke eingeht, führt der Zuweiser auf dieselbe Weise nacheinander dieselben Aktionen aus, die im vorherigen Schritt beschrieben wurden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn bei der Freigabe des Blocks eine Freigabeanforderung eintrifft, fügt der Allokator diese Adresse einfach einem der Enden einer einfach verbundenen Liste hinzu. Es ist erwähnenswert, dass beispielsweise eine Adresse, die nicht mit der Speicheradresse des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokators übereinstimmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , z. B. </font><b><font style="vertical-align: inherit;">0xEFAB12</font></b><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">als Adresse des </font><b><font style="vertical-align: inherit;">freizugebenden</font></b><font style="vertical-align: inherit;"> Blocks angegeben werden </font><font style="vertical-align: inherit;">kann. Dann wird es möglich sein, dass wir dem Benutzer einen Speicherplatz geben, der uns nicht gehört (natürlich) Dies führt zu undefiniertem Verhalten oder wenn Sie sehr viel Glück haben, dann einfach zum Absturz des Programms. Um dieses mögliche Problem zu vermeiden, werden nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen Sie überprüfen können, ob der Benutzer während der Anforderung für den Freigabevorgang mit der Adresse verwechselt wurde.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu dem Speicher, den der Allokator nicht steuert, gibt es ein weiteres mögliches Problem. </font><font style="vertical-align: inherit;">Ein Benutzer kann eine Anfrage stellen, absolut jede Adresse freizugeben, die sich im Speicherbereich des Allokators befindet, aber nicht der Startadresse eines der Blöcke entspricht, beispielsweise einen Block mit der Adresse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Operation führt natürlich zu undefiniertem Verhalten. </font><font style="vertical-align: inherit;">Wenn zusätzlich geprüft werden muss, ob der Benutzer alles richtig macht, kann dies nachverfolgt werden. </font><font style="vertical-align: inherit;">Um dies zu verfolgen, gibt es viele Lösungen, zum Beispiel, um Adressen und belegte Blöcke zu speichern oder sogar die Adresse auf eine Vielzahl von Blockgrößen im Allokator zu überprüfen (alles hängt von der Vorstellungskraft und der besonderen Situation ab, in der der Allokator verwendet wird).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelverteiler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist dies eine intelligente Weiterentwicklung eines linearen Allokators, mit dem Sie den Speicher wie einen Stapel verwalten können. Alles ist wie zuvor, wir speichern den Zeiger mit dem "Header" -Block (im Folgenden als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) auf die aktuelle Speicheradresse und verschieben ihn für jede Zuordnung vorwärts. Im Gegensatz zu einem linearen Allokator können wir ihn auch zurück verschieben, dh die Freigabeoperation ausführen, die von einem linearen Allokator nicht unterstützt wird. Nach wie vor bleibt das Prinzip der räumlichen Lokalität erhalten, und die Fragmentierung ist immer noch minimal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage vor, mehrere Beispiele mit demselben Speicherblock von 14 Bytes zu betrachten. Wie bei einem linearen Allokator speichern wir auch Zeiger auf den Anfang des Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sowie einen Zeiger auf das Ende des verwendeten Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung zur Speicherzuweisung eingeht, weisen wir zusätzlich zur Zuweisung einer bestimmten vom Benutzer angeforderten Speichermenge zusätzlich einen Header zu (der Benutzer interagiert in keiner Weise damit), in dem wir Informationen darüber speichern, wie viele Bytes zugewiesen wurden (in diesem Beispiel ist die Headergröße 2 Bytes). Wenn Sie beispielsweise eine Anforderung zur Zuweisung von 2 Byte erhalten haben, ist der Status des Zuweisers genau der gleiche wie in der folgenden Abbildung. Es ist wichtig zu beachten, dass der Benutzer keinen Zeiger auf die Überschrift erhält, sondern auf den Block unmittelbar nach der Überschrift, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Beispiel ist dies der Block mit der Adresse </font><b><font style="vertical-align: inherit;">0xFFAA02</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine ähnliche Situation besteht beispielsweise bei der Zuweisung von 6 Bytes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Veröffentlichung ist jedoch alles etwas interessanter (wie bereits erwähnt, können wir Speicher nur mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus zuweisen und </font><b><font style="vertical-align: inherit;">freigeben</font></b><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Zuerst müssen Sie von dem Zeiger, den der Benutzer freigeben möchte, die Größe des Headers subtrahieren, dann den Wert dereferenzieren und erst danach den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendeten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger </font><font style="vertical-align: inherit;">zusammen mit der Größe des aus dem Header erhaltenen Blocks auf die Größe des Headers verschieben. </font><font style="vertical-align: inherit;">Genau wie beim Blockzuweiser ist hier die Situation möglich, „zufällige“ Speicherblöcke freizugeben, was ebenfalls zu undefiniertem Verhalten führt. </font><font style="vertical-align: inherit;">Es liegt an jedem, die Zuteiler durch zusätzliche Prüfungen zu ergänzen oder nicht. </font><font style="vertical-align: inherit;">Das Wichtigste ist, diesen Moment nicht zu vergessen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie die Grundlagen verstanden haben, ist es Zeit, etwas Ernsthafteres zu lernen.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Primitiver Standardverteiler"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes wird eine Implementierung des Allokators vorgestellt, die ohne Probleme mit STL verwendet werden kann. Der Speicherzuweisungsalgorithmus in diesem Zuweiser ähnelt dem vom Standardzuweiser verwendeten Algorithmus. Ich möchte sofort darauf hinweisen, dass ich nicht vorgebe, eine vollständige Implementierung von malloc zu sein. Ich habe nur die Grundkonzepte daraus übernommen und an einigen Stellen meine Logik hinzugefügt. Natürlich wurden bei dieser Implementierung nicht alle Feinheiten und Nuancen berücksichtigt ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus basiert auf der Interaktion mit „Chunks“ (im Folgenden wird er als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Implementierung ist ihre Größe statisch und sollte ein Vielfaches von vier sein, sowie alle Speicherzuordnungen aus dem Zuweiserspeicher werden durch ein Vielfaches von vier ausgerichtet, was später erläutert wird. Nehmen Sie als Beispiel einen Abschnitt mit einer Größe von 16 Byte. Darin enthält es Zeiger auf den Anfang ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des Speichers, einen Zeiger auf den maximalen Speicherblock ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und viele ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freeblocks)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), in dem Header von freien Blöcken gespeichert werden. Die Headergröße in dieser Implementierung beträgt 4 Byte, kann jedoch für die von Ihnen benötigten Zwecke leicht in der Größe variieren. Wenn Sie beispielsweise sicher sind, dass die Größe der zugewiesenen Speicherblöcke nicht mehr als der maximale numerische Wert beträgt, der in ein oder zwei Byte-Variablen dargestellt werden kann, können Sie einen Header von 1 oder 2 Byte verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Zuweisen von Speicher aus einem Abschnitt müssen Sie zunächst prüfen, ob genügend Speicher vorhanden ist (in dieser Implementierung handelt es sich um eine konstante Operation, die wir nur mit </font><i><font style="vertical-align: inherit;">maxblock</font></i><font style="vertical-align: inherit;"> vergleichen</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header und, wenn die Größe des zugewiesenen Speichers kleiner als der maximale Block ist, dann haben wir genug Speicher für diese Zuordnung). Wenn genügend Speicher vorhanden ist, geben wir einfach die Speicheradresse nach dem Header an, wie im Stapelzuweiser, und löschen auch den vorherigen Header aus dem Satz freier Blöcke und fügen erst danach den neuen Header dem neu zugewiesenen Speicherblock hinzu. Es ist wichtig zu beachten, dass wir den Wert des maximalen Blocks aktualisieren müssen, wenn wir Speicher aus dem maximalen Block zugewiesen haben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der nachfolgenden Auswahl geschieht alles genauso wie im vorherigen Schritt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald jedoch der Speicher in dem Abschnitt leer ist, nimmt der Allokator einen anderen Abschnitt derselben oder einer größeren Größe und erstellt ihn einfach (in dieser Implementierung haben alle Abschnitte dieselbe Größe). Es lohnt sich auch sicherzustellen, dass die Größe des möglichen Blocks für die Zuordnung die Größe des Diagramms abzüglich der Größe des Headers nicht überschreitet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus können Sie im neuen Abschnitt problemlos die erforderlichen Speicherblöcke zuweisen. Die Zuweisung des Speichers erfolgt in genau demselben Szenario wie im vorherigen Abschnitt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein wenig darüber, warum in dieser Implementierung die Größe des Diagramms ein Vielfaches von vier sein sollte. Die Antwort ist sehr einfach - dies geschieht zur Erleichterung der Implementierung und Wahrnehmung des Algorithmus. Da eine solche Situation möglich ist, kann am Ende des Abschnitts ein Speicherbereich verbleiben, der einfach nicht in den Header passt (ein Beispiel hierfür ist in der folgenden Abbildung dargestellt). Um dieses Problem zu lösen, können Sie diesen Speicher mit zusätzlicher Ausrichtung füllen oder die Headergröße verkleinern oder zusätzliche Tools verwenden, um dieses mögliche Problem zu verfolgen. Andernfalls geht dieser Speicher verloren und vor allem kann sich in Zukunft der verlorene Speicher ansammeln!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie Speicher freigeben, müssen Sie bestimmen, in welchem ​​Abschnitt sich der Block befindet (in der aktuellen Implementierung ist diese Operation im Verhältnis zur Gesamtzahl der Abschnitte von linearer Komplexität. Wenn davon ausgegangen wird, dass eine große Anzahl von Abschnitten vorhanden ist, kann sie durch Hinzufügen eines Abschnittsindex zum Header konstant gemacht werden. in dem der Speicher zugewiesen wurde). Im Folgenden ist die Freigabeoperation mit dem Stapelzuweiser identisch, außer dass Sie die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Headeradresse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des freigegebenen Blocks zum Satz freier Blöcke </font><i><font style="vertical-align: inherit;">hinzufügen und maxblock</font></i><font style="vertical-align: inherit;"> aktualisieren </font><i><font style="vertical-align: inherit;">müssen,</font></i><font style="vertical-align: inherit;"> wenn die Größe des neu freigegebenen Blocks größer als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass bei dieser Implementierung bei jeder nachfolgenden Speicherfreigabe versucht wird, die Defragmentierung in dem Bereich durchzuführen, aus dem der Speicher freigegeben wurde. Eine Defragmentierung ist erforderlich, um freie Blöcke zu großen zu kombinieren. In dieser Situation, wie in der folgenden Abbildung, können wir beispielsweise keine 6 Bytes zuweisen, selbst wenn die Größe des freien Speichers dies zulässt, aber die Fragmentierung sagt uns ein festes und entscheidendes „Nein“! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Defragmentierungsoperation ist sehr primitiv. Sein Kern liegt in der Tatsache, dass nach dem Freigeben des Speichers geprüft wird, ob zwei benachbarte Blöcke links und rechts vom freigegebenen frei sind. Wenn zwei benachbarte Blöcke frei sind, werden sie zu einer einzigen Einheit zusammengefasst.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte auch darauf hinweisen, dass diese Implementierung katastrophal schrecklich sein wird, wenn kleine Speicherblöcke zugewiesen werden, die beispielsweise 1 Byte entsprechen. </font><font style="vertical-align: inherit;">In dieser Situation erhalten wir +7 zusätzliche Bytes, um nur ein Byte Speicher zuzuweisen, da die Headergröße 4 Bytes und plus 3 Bytes zum Herausreißen von Adressen beträgt, die ein Vielfaches von vier sein müssen. </font><font style="vertical-align: inherit;">Damit möchte ich sagen, dass Sie keinen Speicherzuweisungsalgorithmus blind verwenden sollten, da anstelle der lang erwarteten Optimierung manchmal nur zusätzliche Kosten anfallen können. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, die Theorie wird ausreichen und deshalb, wie Linus Torvalds sagte: „ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwätz ist wertlos. </font><font style="vertical-align: inherit;">Zeig mir den Code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font><font style="vertical-align: inherit;">Nun, fangen wir an ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anforderungen für Allokatoren sind im C ++ - Standard im Kapitel " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokatoranforderungen [allocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " angegeben. </font><font style="vertical-align: inherit;">Basierend auf diesen Anforderungen sollte die primitivste Allokatorschnittstelle, die in STL verwendet werden kann, ungefähr so ​​aussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird davon ausgegangen, dass STL-Container nicht direkt auf den Allokator zugreifen, sondern über die Vorlage std :: allocator_traits, die Werte wie Folgendes bereitstellt:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
… <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, wir haben die Anforderungen herausgefunden, jetzt fangen wir endlich an, einen Allokator zu schreiben. </font><font style="vertical-align: inherit;">Zunächst werden wir eine Schnittstelle oder einen Adapter schreiben. Tatsächlich ist es schwierig, die eine oder die andere aufzurufen. Lassen Sie es also eine Art „Schicht“ sein, in der wir mithilfe von Strategien den Speicherzuweisungsalgorithmus für bestimmte Zwecke leicht ändern können:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank der Strategie für die Speicherzuweisung können wir Folgendes tun:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wir können die Verteilungsalgorithmen für die erforderlichen Zwecke in einer bestimmten Situation flexibel ändern. </font><font style="vertical-align: inherit;">Die einzige Voraussetzung für AllocationStrategy ist, dass sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungs-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freigabevorgänge haben müssen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachfolgend werden Standardbehälter verwendet. </font><font style="vertical-align: inherit;">Ich bin damit einverstanden, dass es viele Zuweisungen vom Haufen geben wird. </font><font style="vertical-align: inherit;">Ich denke, dass dies für diejenigen, die ihre Zuteiler schreiben werden, inakzeptabel sein wird. </font><font style="vertical-align: inherit;">Alternativ können Sie natürlich Ihre eigenen Container schreiben oder die eines anderen verwenden, die für bestimmte Anforderungen geschärft wurden. In dieser Implementierung habe ich jedoch versucht, das Material so einfach wie möglich zu präsentieren, sodass ich mich für Standardcontainer entschieden habe.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein wenig darüber, wie Sie die Verwendung von Allokatoren zusammen mit Standardbehältern dekorieren können: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können auch Allokatoren mit intelligenten Zeigern verwenden, dafür müssen Sie jedoch eine kleine Ebene schreiben: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun und nun endlich ein Beispiel für die Verwendung all dessen:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte mich auf die Tatsache konzentrieren, dass diese Implementierung die primitivste ist, aber sie kann leicht in die Richtung erweitert werden, die Sie benötigen, sodass alles in Ihren Händen liegt!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank für Ihre Aufmerksamkeit, ich hoffe wirklich, dass dieser Artikel für jemanden nützlich war. </font><font style="vertical-align: inherit;">Ich wünsche allen auch viel Erfolg bei der engen Interaktion mit dem Gedächtnis und vergesse vor allem nicht die sehr wichtigen Worte von Donald Knuth: „ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorzeitige Optimierung ist die Wurzel aller Übel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .“ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der vollständigen Implementierung des Allokators.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendete Quellen</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/de/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505614/index.html">Die Einlagensätze der größten Banken fielen auf ein historisches Minimum: Wie wirkt sich dies auf die Wirtschaft aus und wo erfolgt der Umtausch?</a></li>
<li><a href="../de505616/index.html">Erkennung des russischen Alphabets: vom Sammeln eines Datensatzes bis zum Erstellen einer GUI</a></li>
<li><a href="../de505618/index.html">GRASP-Vorlagen: Ersteller</a></li>
<li><a href="../de505620/index.html">HackTheBox. Walkthrough Nest. NTFS-Streams, Reverse C # und SMB Walker</a></li>
<li><a href="../de505624/index.html">Wie verarbeite ich einen Datenrahmen mit Milliarden von Datensätzen in Sekunden?</a></li>
<li><a href="../de505634/index.html">Proxy-Einstellungen für WSL (Ubuntu)</a></li>
<li><a href="../de505640/index.html">Publikationsbewertungsobjektivität</a></li>
<li><a href="../de505642/index.html">Transparente Coroutinen</a></li>
<li><a href="../de505644/index.html">Urheberrechtsinhaber haben es versucht: Die Musikvideokurse von YouTube mit dem Parsen der Songs anderer Personen können verschwinden</a></li>
<li><a href="../de505648/index.html">Einsteins zwei Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>