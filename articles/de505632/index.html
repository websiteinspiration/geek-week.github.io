<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòã üë©üèæ‚Äçü§ù‚Äçüë®üèΩ üôÉ Speicherzuordnungen üõ∂ üìÆ ü§ûüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo alle zusammen! Vor nicht allzu langer Zeit kam mir nach einer sehr genauen Untersuchung der Allokatoren und Speicherzuweisungsalgorithmen sowie ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Speicherzuordnungen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo alle zusammen! </font><font style="vertical-align: inherit;">Vor nicht allzu langer Zeit kam mir nach einer sehr genauen Untersuchung der Allokatoren und Speicherzuweisungsalgorithmen sowie ihrer anschlie√üenden Anwendung in der Praxis die Idee, einen Artikel zu schreiben, der sie so detailliert wie m√∂glich beschreibt. </font><font style="vertical-align: inherit;">Ich denke, dass dieses Thema sehr beliebt sein wird, da es im Netzwerk nur sehr wenige Quellen gibt, insbesondere im russischsprachigen Teil, die sich diesem Thema widmen.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorwort</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zun√§chst m√∂chte ich sofort darauf hinweisen, dass, wenn jemand zuerst die Begriffe "Allokator", "Speicherzuweisungsalgorithmen" h√∂rt und nicht versteht, wof√ºr dies alles ist, ich Sie vor dem Lesen dieses Artikels empfehlen sollte, sich mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieser</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Quelle </font><font style="vertical-align: inherit;">vertraut zu machen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Artikel wird recht gut beschrieben, welche Probleme bei Standardspeicherzuordnungen auftreten und f√ºr welche Zwecke es sich lohnt, neben Standardmethoden auch andere Methoden der Speicherzuweisung zu verwenden. </font><font style="vertical-align: inherit;">Hier werde ich nur √ºber die Verteilungsalgorithmen selbst sprechen und am Ende nat√ºrlich eine Implementierung eines der Allokatoren geben, die problemlos in Standard-C ++ - Containern verwendet werden k√∂nnen.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Grundlagen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºnf Hauptoperationen, die mit einem Allokator ausgef√ºhrt werden k√∂nnen, sind konzeptionell hervorgehoben (ich m√∂chte darauf hinweisen, dass nicht alle Allokatoren explizit dieser Schnittstelle entsprechen k√∂nnen):</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">create</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - erstellt einen Allokator und gibt ihm eine bestimmte Menge an Speicher;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zuweisen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - w√§hlt einen Block einer bestimmten Gr√∂√üe aus dem Speicherbereich aus, den der Zuweiser steuert;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freigeben</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - gibt einen bestimmten Block frei;</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">free</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - befreit alle zugewiesenen Bl√∂cke aus dem Allokatorspeicher (der dem Allokator zugewiesene Speicher wird nicht freigegeben);</font></font></li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zerst√∂ren</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Zerst√∂rt den Allokator mit der anschlie√üenden Freigabe des dem Allokator zugewiesenen Speichers.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linearer Allokator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linearer Allokator, es ist auch "linear" - dies ist der einfachste Typ von Allokatoren. Die Idee ist, einen Zeiger auf den Anfang des Speicherblocks f√ºr den zugewiesenen Allokator zu speichern und auch einen anderen Zeiger oder eine andere numerische Darstellung zu verwenden, die jedes Mal verschoben werden muss, wenn die Zuordnung vom Allokator abgeschlossen ist. In diesem Allokator wird die interne Fragmentierung minimiert, da alle Elemente nacheinander eingef√ºgt werden (r√§umliche Lokalit√§t) und die einzige Fragmentierung zwischen ihnen die Ausrichtung ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner schlage ich vor, einige Beispiele zu betrachten, in denen detailliert gezeigt wird, wie dieser Allokator funktioniert. Nehmen Sie einen Speicherblock, der 14 Bytes entspricht, und geben Sie ihn der Steuerung des Allokators. Wie aus dem Bild unten ersichtlich, speichern wir einen Zeiger auf den Anfang des Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und speichern Sie au√üerdem zwei Zeiger oder zwei numerische Darstellungen, die Informationen √ºber die Gesamtgr√∂√üe ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und die verwendeten ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendeten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Speichergr√∂√üen enthalten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, der Allokator hat eine Anforderung zum Zuweisen von 4 Byte Speicher erhalten. </font><font style="vertical-align: inherit;">Die Aktionen des Allokators bei der Ausf√ºhrung dieser Anforderung sind wie folgt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úberpr√ºfen Sie, ob gen√ºgend Speicher zum Zuweisen vorhanden ist.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern Sie den aktuell verwendeten Zeiger, der dem Benutzer sp√§ter als Zeiger auf einen Block des zugewiesenen Speichers vom Allokator √ºbergeben wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie den verwendeten Zeiger um einen Betrag, der der Gr√∂√üe des zugewiesenen Speicherblocks entspricht, d. h. </font><font style="vertical-align: inherit;">um 4 Bytes.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/wp/3q/_r/wp3q_r2dp-ywsaou93vzk8zhqkk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ferner kommt beispielsweise eine Anforderung f√ºr die Zuweisung von 8 Bytes und dementsprechend sind die Aktionen des Zuweisers unabh√§ngig von der Gr√∂√üe des zugewiesenen Speicherblocks genau gleich. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/di/g4/ih/dig4ihecjl8qfasqqonhdqtt2lm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber hier wird es schon etwas interessanter sein, wenn beispielsweise eine Anforderung zum Zuweisen von nur 1 Byte kommt und wir keine Bl√∂cke im Speicher ausrichten m√∂chten (z. B. Adressen, die ein Vielfaches von 2, 4, ... sind), bleiben die Aktionen des Zuweisers genau gleich.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vz/x_/cc/vzx_cc45oildurtaxdyi7n9fi7i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch Speicherbl√∂cke mit einer bestimmten Ausrichtung zuweisen m√ºssen (z. B. Ausrichtung von Adressen mit einem Vielfachen von 2), √§ndert sich die Aktion des Zuweisers geringf√ºgig. Es √§ndert sich nicht in Bezug auf die Implementierung, sondern darin, dass wir zus√§tzlich zu den Daten selbst, die dem Volumen eines Bytes entsprechen, auch ein zus√§tzliches Byte aus dem Speicher des Allokators zur Ausrichtung entnehmen, was keine Bedeutung hat. Dies ist genau die sehr m√∂gliche minimale Fragmentierung des Speichers innerhalb eines linearen Allokators. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jx/xg/pz/jxxgpzvrvs9nhyodrphmi1xg1sy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gro√üartig, jetzt ist die Zeit gekommen, √ºber die Freigabe von Speicher zu sprechen. Wie bereits erw√§hnt, unterst√ºtzt diese Art von Allokotor die selektive Freigabe bestimmter Speicherbl√∂cke nicht. Das hei√üt, wenn wir eine subtile Analogie mit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc / free ziehen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und einen Zeiger auf beispielsweise </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA00 haben</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnten diesen Speicherblock freigeben, aber ein linearer Allokator kann uns dies nicht erlauben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mj/es/_0/mjes_04nsdmq3bfiolwehoxwdfk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles, was wir tun k√∂nnen, ist, den gesamten belegten Speicher vollst√§ndig im Allokator freizugeben und weiter damit zu arbeiten, als w√§re er vollst√§ndig leer.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/aa/wg/vgaawgiqzerseegtgqvk0qbjhus.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pool Allokator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Idee eines Blockzuweisers ist, dass er ein gro√ües St√ºck Speicher in kleinere Teile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">derselben Gr√∂√üe aufteilt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Im Kern ist es auch ein sehr einfacher Zuweiser, da er bei Anforderung einer Zuweisung einfach einen der freien Speicherpl√§tze fester Gr√∂√üe zur√ºckgibt und diesen Speicherbereich einfach f√ºr die zuk√ºnftige Verwendung speichert, wenn er freigegeben werden soll. Daher ist die Verteilung sehr schnell und die Fragmentierung immer noch sehr gering. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neben einem linearen Allokator schlage ich au√üerdem vor, alles anhand eines Beispiels zu betrachten, um die Funktionsweise genauer zu verstehen. Daher nehmen wir einen Speicherblock mit 12 Bytes und geben ihn an die Steuerung des Allokators weiter. Wie Sie auf dem Bild unten sehen k√∂nnen, halten wir den Zeiger auf den Anfang (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des vom </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokator</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gesteuerten Speichers sowie eine Liste ( </font><i><font style="vertical-align: inherit;">Freeblocks</font></i><font style="vertical-align: inherit;"> ) der Adressen der freien Bl√∂cke im Allokator. Um Daten zu speichern, bei denen der Block belegt oder frei ist, k√∂nnen Sie viele Tools verwenden, z. B. ein Array von Booleschen Werten. Ich habe mich jedoch f√ºr eine einfach verbundene Liste entschieden, da diese dieses Konzept (√ºbrigens) am einfachsten und klarsten kennzeichnet. Die Links der Liste k√∂nnen in freien Speicherbl√∂cken gespeichert werden, wodurch die zus√§tzlichen Speicherkosten entfallen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/6s/5o/co6s5o7c7ufuvofrrb1oqwke8vy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung zum Zuweisen eines Speicherblocks eingeht, sind die Aktionen des Zuweisers sehr primitiv. Zun√§chst pr√ºft er, ob die Liste der freien Bl√∂cke Links enth√§lt. Wenn diese nicht vorhanden sind, ist es nicht schwer zu erraten, dass der Speicher im Allokator bereits leer ist. Wenn dort mindestens ein Link vorhanden ist, wird einfach der Root- oder Tail-Link (in dieser Implementierung werden Tail-Links angegeben) der Liste entfernt und dem Benutzer seine Adresse mitgeteilt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/j_/44/ucj_44gjfi99_jf4whquo4sra78.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung f√ºr die Zuweisung mehrerer Speicherbl√∂cke eingeht, f√ºhrt der Zuweiser auf dieselbe Weise nacheinander dieselben Aktionen aus, die im vorherigen Schritt beschrieben wurden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/qc/zy/riqczyaeceqtxdshywd0py4r0nw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn bei der Freigabe des Blocks eine Freigabeanforderung eintrifft, f√ºgt der Allokator diese Adresse einfach einem der Enden einer einfach verbundenen Liste hinzu. Es ist erw√§hnenswert, dass beispielsweise eine Adresse, die nicht mit der Speicheradresse des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokators √ºbereinstimmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , z. B. </font><b><font style="vertical-align: inherit;">0xEFAB12</font></b><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">als Adresse des </font><b><font style="vertical-align: inherit;">freizugebenden</font></b><font style="vertical-align: inherit;"> Blocks angegeben werden </font><font style="vertical-align: inherit;">kann. Dann wird es m√∂glich sein, dass wir dem Benutzer einen Speicherplatz geben, der uns nicht geh√∂rt (nat√ºrlich) Dies f√ºhrt zu undefiniertem Verhalten oder wenn Sie sehr viel Gl√ºck haben, dann einfach zum Absturz des Programms. Um dieses m√∂gliche Problem zu vermeiden, werden nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anfang</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mit denen Sie √ºberpr√ºfen k√∂nnen, ob der Benutzer w√§hrend der Anforderung f√ºr den Freigabevorgang mit der Adresse verwechselt wurde.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gd/0n/ed/gd0nedbx2nlhsrxggnymb42keey.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zus√§tzlich zu dem Speicher, den der Allokator nicht steuert, gibt es ein weiteres m√∂gliches Problem. </font><font style="vertical-align: inherit;">Ein Benutzer kann eine Anfrage stellen, absolut jede Adresse freizugeben, die sich im Speicherbereich des Allokators befindet, aber nicht der Startadresse eines der Bl√∂cke entspricht, beispielsweise einen Block mit der Adresse </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFAA07</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Diese Operation f√ºhrt nat√ºrlich zu undefiniertem Verhalten. </font><font style="vertical-align: inherit;">Wenn zus√§tzlich gepr√ºft werden muss, ob der Benutzer alles richtig macht, kann dies nachverfolgt werden. </font><font style="vertical-align: inherit;">Um dies zu verfolgen, gibt es viele L√∂sungen, zum Beispiel, um Adressen und belegte Bl√∂cke zu speichern oder sogar die Adresse auf eine Vielzahl von Blockgr√∂√üen im Allokator zu √ºberpr√ºfen (alles h√§ngt von der Vorstellungskraft und der besonderen Situation ab, in der der Allokator verwendet wird).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3u/mn/hw/3umnhwagefbl_eysi3zl6yhu9be.png"><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelverteiler</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist dies eine intelligente Weiterentwicklung eines linearen Allokators, mit dem Sie den Speicher wie einen Stapel verwalten k√∂nnen. Alles ist wie zuvor, wir speichern den Zeiger mit dem "Header" -Block (im Folgenden als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) auf die aktuelle Speicheradresse und verschieben ihn f√ºr jede Zuordnung vorw√§rts. Im Gegensatz zu einem linearen Allokator k√∂nnen wir ihn auch zur√ºck verschieben, dh die Freigabeoperation ausf√ºhren, die von einem linearen Allokator nicht unterst√ºtzt wird. Nach wie vor bleibt das Prinzip der r√§umlichen Lokalit√§t erhalten, und die Fragmentierung ist immer noch minimal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich schlage vor, mehrere Beispiele mit demselben Speicherblock von 14 Bytes zu betrachten. Wie bei einem linearen Allokator speichern wir auch Zeiger auf den Anfang des Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) sowie einen Zeiger auf das Ende des verwendeten Speichers ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ba/sb/qv/basbqv8yj_v1sijo_td54pa472k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn eine Anforderung zur Speicherzuweisung eingeht, weisen wir zus√§tzlich zur Zuweisung einer bestimmten vom Benutzer angeforderten Speichermenge zus√§tzlich einen Header zu (der Benutzer interagiert in keiner Weise damit), in dem wir Informationen dar√ºber speichern, wie viele Bytes zugewiesen wurden (in diesem Beispiel ist die Headergr√∂√üe 2 Bytes). Wenn Sie beispielsweise eine Anforderung zur Zuweisung von 2 Byte erhalten haben, ist der Status des Zuweisers genau der gleiche wie in der folgenden Abbildung. Es ist wichtig zu beachten, dass der Benutzer keinen Zeiger auf die √úberschrift erh√§lt, sondern auf den Block unmittelbar nach der √úberschrift, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Beispiel ist dies der Block mit der Adresse </font><b><font style="vertical-align: inherit;">0xFFAA02</font></b><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/qb/q2/bgqbq2fei1egpmowdnmz9vciplo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine √§hnliche Situation besteht beispielsweise bei der Zuweisung von 6 Bytes.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/up/pf/x_/uppfx_dpultvroggfr2rvy7lxhc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit der Ver√∂ffentlichung ist jedoch alles etwas interessanter (wie bereits erw√§hnt, k√∂nnen wir Speicher nur mit dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIFO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Algorithmus zuweisen und </font><b><font style="vertical-align: inherit;">freigeben</font></b><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Zuerst m√ºssen Sie von dem Zeiger, den der Benutzer freigeben m√∂chte, die Gr√∂√üe des Headers subtrahieren, dann den Wert dereferenzieren und erst danach den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendeten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zeiger </font><font style="vertical-align: inherit;">zusammen mit der Gr√∂√üe des aus dem Header erhaltenen Blocks auf die Gr√∂√üe des Headers verschieben. </font><font style="vertical-align: inherit;">Genau wie beim Blockzuweiser ist hier die Situation m√∂glich, ‚Äûzuf√§llige‚Äú Speicherbl√∂cke freizugeben, was ebenfalls zu undefiniertem Verhalten f√ºhrt. </font><font style="vertical-align: inherit;">Es liegt an jedem, die Zuteiler durch zus√§tzliche Pr√ºfungen zu erg√§nzen oder nicht. </font><font style="vertical-align: inherit;">Das Wichtigste ist, diesen Moment nicht zu vergessen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/as/fh/s4/asfhs4qflx43fwr9jizq-zmsatq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem Sie die Grundlagen verstanden haben, ist es Zeit, etwas Ernsthafteres zu lernen.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Primitiver Standardverteiler"</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als n√§chstes wird eine Implementierung des Allokators vorgestellt, die ohne Probleme mit STL verwendet werden kann. Der Speicherzuweisungsalgorithmus in diesem Zuweiser √§hnelt dem vom Standardzuweiser verwendeten Algorithmus. Ich m√∂chte sofort darauf hinweisen, dass ich nicht vorgebe, eine vollst√§ndige Implementierung von malloc zu sein. Ich habe nur die Grundkonzepte daraus √ºbernommen und an einigen Stellen meine Logik hinzugef√ºgt. Nat√ºrlich wurden bei dieser Implementierung nicht alle Feinheiten und Nuancen ber√ºcksichtigt ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Algorithmus basiert auf der Interaktion mit ‚ÄûChunks‚Äú (im Folgenden wird er als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt verwendet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Implementierung ist ihre Gr√∂√üe statisch und sollte ein Vielfaches von vier sein, sowie alle Speicherzuordnungen aus dem Zuweiserspeicher werden durch ein Vielfaches von vier ausgerichtet, was sp√§ter erl√§utert wird. Nehmen Sie als Beispiel einen Abschnitt mit einer Gr√∂√üe von 16 Byte. Darin enth√§lt es Zeiger auf den Anfang ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und das Ende ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ende</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des Speichers, einen Zeiger auf den maximalen Speicherblock ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maxblock</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und viele ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freeblocks)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), in dem Header von freien Bl√∂cken gespeichert werden. Die Headergr√∂√üe in dieser Implementierung betr√§gt 4 Byte, kann jedoch f√ºr die von Ihnen ben√∂tigten Zwecke leicht in der Gr√∂√üe variieren. Wenn Sie beispielsweise sicher sind, dass die Gr√∂√üe der zugewiesenen Speicherbl√∂cke nicht mehr als der maximale numerische Wert betr√§gt, der in ein oder zwei Byte-Variablen dargestellt werden kann, k√∂nnen Sie einen Header von 1 oder 2 Byte verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/nr/xq/3f/nrxq3fcbnoooxnu0hehls2dghim.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Zuweisen von Speicher aus einem Abschnitt m√ºssen Sie zun√§chst pr√ºfen, ob gen√ºgend Speicher vorhanden ist (in dieser Implementierung handelt es sich um eine konstante Operation, die wir nur mit </font><i><font style="vertical-align: inherit;">maxblock</font></i><font style="vertical-align: inherit;"> vergleichen</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Header und, wenn die Gr√∂√üe des zugewiesenen Speichers kleiner als der maximale Block ist, dann haben wir genug Speicher f√ºr diese Zuordnung). Wenn gen√ºgend Speicher vorhanden ist, geben wir einfach die Speicheradresse nach dem Header an, wie im Stapelzuweiser, und l√∂schen auch den vorherigen Header aus dem Satz freier Bl√∂cke und f√ºgen erst danach den neuen Header dem neu zugewiesenen Speicherblock hinzu. Es ist wichtig zu beachten, dass wir den Wert des maximalen Blocks aktualisieren m√ºssen, wenn wir Speicher aus dem maximalen Block zugewiesen haben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5m/lm/yw/5mlmywi79wh3uutr-ug7ko7s9em.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der nachfolgenden Auswahl geschieht alles genauso wie im vorherigen Schritt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3m/2m/i9/3m2mi9xd9qmnf6ngnqjf8wfnzd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald jedoch der Speicher in dem Abschnitt leer ist, nimmt der Allokator einen anderen Abschnitt derselben oder einer gr√∂√üeren Gr√∂√üe und erstellt ihn einfach (in dieser Implementierung haben alle Abschnitte dieselbe Gr√∂√üe). Es lohnt sich auch sicherzustellen, dass die Gr√∂√üe des m√∂glichen Blocks f√ºr die Zuordnung die Gr√∂√üe des Diagramms abz√ºglich der Gr√∂√üe des Headers nicht √ºberschreitet. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fy/fz/6g/fyfz6gthdrfysccjef_xcphihb0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus k√∂nnen Sie im neuen Abschnitt problemlos die erforderlichen Speicherbl√∂cke zuweisen. Die Zuweisung des Speichers erfolgt in genau demselben Szenario wie im vorherigen Abschnitt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/eu/gc/aleugc_fka3uvpmju9gw66dpn1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein wenig dar√ºber, warum in dieser Implementierung die Gr√∂√üe des Diagramms ein Vielfaches von vier sein sollte. Die Antwort ist sehr einfach - dies geschieht zur Erleichterung der Implementierung und Wahrnehmung des Algorithmus. Da eine solche Situation m√∂glich ist, kann am Ende des Abschnitts ein Speicherbereich verbleiben, der einfach nicht in den Header passt (ein Beispiel hierf√ºr ist in der folgenden Abbildung dargestellt). Um dieses Problem zu l√∂sen, k√∂nnen Sie diesen Speicher mit zus√§tzlicher Ausrichtung f√ºllen oder die Headergr√∂√üe verkleinern oder zus√§tzliche Tools verwenden, um dieses m√∂gliche Problem zu verfolgen. Andernfalls geht dieser Speicher verloren und vor allem kann sich in Zukunft der verlorene Speicher ansammeln!</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rq/rp/mv/rqrpmvvpbx1thpxjfbqcictzq1o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie Speicher freigeben, m√ºssen Sie bestimmen, in welchem ‚Äã‚ÄãAbschnitt sich der Block befindet (in der aktuellen Implementierung ist diese Operation im Verh√§ltnis zur Gesamtzahl der Abschnitte von linearer Komplexit√§t. Wenn davon ausgegangen wird, dass eine gro√üe Anzahl von Abschnitten vorhanden ist, kann sie durch Hinzuf√ºgen eines Abschnittsindex zum Header konstant gemacht werden. in dem der Speicher zugewiesen wurde). Im Folgenden ist die Freigabeoperation mit dem Stapelzuweiser identisch, au√üer dass Sie die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Headeradresse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des freigegebenen Blocks zum Satz freier Bl√∂cke </font><i><font style="vertical-align: inherit;">hinzuf√ºgen und maxblock</font></i><font style="vertical-align: inherit;"> aktualisieren </font><i><font style="vertical-align: inherit;">m√ºssen,</font></i><font style="vertical-align: inherit;"> wenn die Gr√∂√üe des neu freigegebenen Blocks gr√∂√üer als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxblock ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/sl/yl/fwslyluxwv00a8mwazxe2iakd00.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass bei dieser Implementierung bei jeder nachfolgenden Speicherfreigabe versucht wird, die Defragmentierung in dem Bereich durchzuf√ºhren, aus dem der Speicher freigegeben wurde. Eine Defragmentierung ist erforderlich, um freie Bl√∂cke zu gro√üen zu kombinieren. In dieser Situation, wie in der folgenden Abbildung, k√∂nnen wir beispielsweise keine 6 Bytes zuweisen, selbst wenn die Gr√∂√üe des freien Speichers dies zul√§sst, aber die Fragmentierung sagt uns ein festes und entscheidendes ‚ÄûNein‚Äú! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tm/ec/dp/tmecdpyhyynvn0ahzubdxltorvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Defragmentierungsoperation ist sehr primitiv. Sein Kern liegt in der Tatsache, dass nach dem Freigeben des Speichers gepr√ºft wird, ob zwei benachbarte Bl√∂cke links und rechts vom freigegebenen frei sind. Wenn zwei benachbarte Bl√∂cke frei sind, werden sie zu einer einzigen Einheit zusammengefasst.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jt/1u/hl/jt1uhl_a7d3xo2a3f9kedx_7waq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte auch darauf hinweisen, dass diese Implementierung katastrophal schrecklich sein wird, wenn kleine Speicherbl√∂cke zugewiesen werden, die beispielsweise 1 Byte entsprechen. </font><font style="vertical-align: inherit;">In dieser Situation erhalten wir +7 zus√§tzliche Bytes, um nur ein Byte Speicher zuzuweisen, da die Headergr√∂√üe 4 Bytes und plus 3 Bytes zum Herausrei√üen von Adressen betr√§gt, die ein Vielfaches von vier sein m√ºssen. </font><font style="vertical-align: inherit;">Damit m√∂chte ich sagen, dass Sie keinen Speicherzuweisungsalgorithmus blind verwenden sollten, da anstelle der lang erwarteten Optimierung manchmal nur zus√§tzliche Kosten anfallen k√∂nnen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/r2/ez/v3/r2ezv39toknyjxexeamoq05g3r8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, die Theorie wird ausreichen und deshalb, wie Linus Torvalds sagte: ‚Äû </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschw√§tz ist wertlos. </font><font style="vertical-align: inherit;">Zeig mir den Code</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . " </font><font style="vertical-align: inherit;">Nun, fangen wir an ...</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementierung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anforderungen f√ºr Allokatoren sind im C ++ - Standard im Kapitel " </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allokatoranforderungen [allocator.requirements]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " angegeben. </font><font style="vertical-align: inherit;">Basierend auf diesen Anforderungen sollte die primitivste Allokatorschnittstelle, die in STL verwendet werden kann, ungef√§hr so ‚Äã‚Äãaussehen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span> 
{</span>
    <span class="hljs-keyword">typedef</span> T value_type;<font></font>
    Allocator( );<font></font>
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; 
    <span class="hljs-title">Allocator</span>(<span class="hljs-title">const</span> &lt;T&gt;&amp; <span class="hljs-title">other</span>);</span>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(T* ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">U</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T&gt;&amp;, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U&gt;&amp;);</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird davon ausgegangen, dass STL-Container nicht direkt auf den Allokator zugreifen, sondern √ºber die Vorlage std :: allocator_traits, die Werte wie Folgendes bereitstellt:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">typedef</span> T* pointer;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">const</span> T* const_pointer; <font></font>
‚Ä¶ <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, wir haben die Anforderungen herausgefunden, jetzt fangen wir endlich an, einen Allokator zu schreiben. </font><font style="vertical-align: inherit;">Zun√§chst werden wir eine Schnittstelle oder einen Adapter schreiben. Tats√§chlich ist es schwierig, die eine oder die andere aufzurufen. Lassen Sie es also eine Art ‚ÄûSchicht‚Äú sein, in der wir mithilfe von Strategien den Speicherzuweisungsalgorithmus f√ºr bestimmte Zwecke leicht √§ndern k√∂nnen:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Common interface for interaction with STL</span>
<span class="hljs-comment">// containers and algorithms. You can manually change</span>
<span class="hljs-comment">// allocation algorithm with different 'AllocationStrategy'</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// In this implementation was not implented 'adress' and 'max_size'</span>
<span class="hljs-comment">// unnecessary functions for.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>
{</span>
    <span class="hljs-keyword">static_assert</span>(!<span class="hljs-built_in">std</span>::is_same_v&lt;T, <span class="hljs-keyword">void</span>&gt;, <span class="hljs-string">"Type of the allocator can not be void"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">using</span> value_type = T;<font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocStrategy</span>&gt;
    <span class="hljs-title">friend</span> <span class="hljs-title">class</span> <span class="hljs-title">Allocator</span>;</span><font></font>
    <font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rebind</span>
    {</span>
        <span class="hljs-keyword">using</span> other = Allocator&lt;U, AllocationStrategy&gt;;<font></font>
    };<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    Allocator() = <span class="hljs-keyword">default</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Allocator</span><span class="hljs-params">(AllocationStrategy&amp; strategy)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(&amp;strategy)</span> </span>{}<font></font>
    <font></font>
    Allocator(<span class="hljs-keyword">const</span> Allocator&amp; other) <span class="hljs-keyword">noexcept</span><font></font>
        : m_allocation_strategy(other.m_allocation_strategy) {}<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-title">Allocator</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Allocator&lt;U, AllocationStrategy&gt;&amp; other)</span> <span class="hljs-keyword">noexcept</span>
        : <span class="hljs-title">m_allocation_strategy</span><span class="hljs-params">(other.m_allocation_strategy)</span> </span>{}<font></font>
    <font></font>
    <span class="hljs-function">T* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(m_allocation_strategy-&gt;allocate(count_objects * <span class="hljs-keyword">sizeof</span>(T)));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> count_objects)</span>
    </span>{<font></font>
        assert(m_allocation_strategy &amp;&amp; <span class="hljs-string">"Not initialized allocation strategy"</span>);<font></font>
        m_allocation_strategy-&gt;deallocate(memory_ptr, count_objects * <span class="hljs-keyword">sizeof</span>(T));<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U, <span class="hljs-keyword">typename</span>... Args&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(U* ptr, Args&amp;&amp;... args)</span>
    </span>{
        <span class="hljs-keyword">new</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>*&gt;(ptr)) U { <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)... };<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;
    <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(U* ptr)</span>
    </span>{<font></font>
        ptr-&gt;~U();<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:<font></font>
    AllocationStrategy* m_allocation_strategy = <span class="hljs-literal">nullptr</span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>==(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> lhs.m_allocation_strategy == rhs.m_allocation_strategy;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U, <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllocationStrategy</span>&gt;
<span class="hljs-title">bool</span> <span class="hljs-title">operator</span>!=(<span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;T, AllocationStrategy&gt;&amp; <span class="hljs-title">lhs</span>, <span class="hljs-title">const</span> <span class="hljs-title">Allocator</span>&lt;U, AllocationStrategy&gt;&amp; <span class="hljs-title">rhs</span>)
{</span>
    <span class="hljs-keyword">return</span> !(lhs == rhs);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dank der Strategie f√ºr die Speicherzuweisung k√∂nnen wir Folgendes tun:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForSmallObjects = Allocator&lt;T, StrategyForSmallObjects&gt;;
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> AllocatorForBigObjects = Allocator&lt;T, StrategyForBigObjects&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wir k√∂nnen die Verteilungsalgorithmen f√ºr die erforderlichen Zwecke in einer bestimmten Situation flexibel √§ndern. </font><font style="vertical-align: inherit;">Die einzige Voraussetzung f√ºr AllocationStrategy ist, dass sie </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuweisungs-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freigabevorg√§nge haben m√ºssen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-comment">// Strategy for manipulation memory chunks, like</span>
<span class="hljs-comment">// a primitive malloc allocator.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Warning: if you try to deallocate some random block</span>
<span class="hljs-comment">// of the memory, most of all it will be an undefined behavior,</span>
<span class="hljs-comment">// because current implementation doesn't check this possible situation.</span><font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;<font></font>
class CustomAllocationStrategy<font></font>
{<font></font>
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE != <span class="hljs-number">0u</span>, <span class="hljs-string">"Chunk size must be more, than zero"</span>);
    <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &lt;= <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;::max(),
        <span class="hljs-string">"Chunk size must be less or equal max value of the uint32_t"</span>);
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">allocate</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{<font></font>
        assert(size &lt; CHUNK_SIZE &amp;&amp; <span class="hljs-string">"Incorrect chunk size for future usage"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0u</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">void</span>* allocated_block = chunk.tryReserveBlock(size);
            <span class="hljs-keyword">if</span> (allocated_block) <span class="hljs-comment">//if the block was not reserved, then memory in the chunk has run out</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> allocated_block;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        m_chunks.push_back(details::Chunk&lt;CHUNK_SIZE&gt;{});<font></font>
        <span class="hljs-keyword">auto</span>&amp; chunk = m_chunks.back();
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* allocated_block = chunk.tryReserveBlock(size);
        <span class="hljs-keyword">return</span> allocated_block;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deallocate</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* memory_ptr, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (!memory_ptr) || (size == <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* deallocation_ptr = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(memory_ptr);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; chunk : m_chunks)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (chunk.isInside(deallocation_ptr))<font></font>
            {<font></font>
                chunk.releaseBlock(deallocation_ptr);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;details::Chunk&lt;CHUNK_SIZE&gt;&gt; m_chunks{ <span class="hljs-number">1u</span> };<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachfolgend werden Standardbeh√§lter verwendet. </font><font style="vertical-align: inherit;">Ich bin damit einverstanden, dass es viele Zuweisungen vom Haufen geben wird. </font><font style="vertical-align: inherit;">Ich denke, dass dies f√ºr diejenigen, die ihre Zuteiler schreiben werden, inakzeptabel sein wird. </font><font style="vertical-align: inherit;">Alternativ k√∂nnen Sie nat√ºrlich Ihre eigenen Container schreiben oder die eines anderen verwenden, die f√ºr bestimmte Anforderungen gesch√§rft wurden. In dieser Implementierung habe ich jedoch versucht, das Material so einfach wie m√∂glich zu pr√§sentieren, sodass ich mich f√ºr Standardcontainer entschieden habe.</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">namespace</span> details<font></font>
{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> <span class="hljs-title">getAlignmentPadding</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment)</span>
    </span>{
        <span class="hljs-keyword">if</span> ( (alignment != <span class="hljs-number">0u</span>) &amp;&amp; (not_aligned_address % alignment != <span class="hljs-number">0u</span>) )<font></font>
        {<font></font>
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> multiplier = (not_aligned_address / alignment) + <span class="hljs-number">1u</span>;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> aligned_address = multiplier * alignment;
            <span class="hljs-keyword">return</span> aligned_address - not_aligned_address;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0u</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// Current chunk implementation works only with size</span>
    <span class="hljs-comment">// aligned by 4 bytes, because HEADER_SIZE now also 4 bytes.</span>
    <span class="hljs-comment">// You can modify it with HEADER_SIZE without problems for your purposes.</span><font></font>
<font></font>
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE&gt;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>
    {</span>
        <span class="hljs-keyword">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> HEADER_SIZE = <span class="hljs-number">4u</span>;
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE % HEADER_SIZE == <span class="hljs-number">0</span>, <span class="hljs-string">"CHUNK_SIZE must be multiple of the four"</span>);
        <span class="hljs-keyword">static_assert</span>(CHUNK_SIZE &gt; HEADER_SIZE, <span class="hljs-string">"CHUNK_SIZE must be more than HEADER_SIZE"</span>);
    <span class="hljs-keyword">public</span>:<font></font>
        Chunk()<font></font>
        {<font></font>
            m_blocks.resize(CHUNK_SIZE);<font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* init_header = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(m_blocks.data());<font></font>
            *init_header = CHUNK_SIZE - HEADER_SIZE;<font></font>
            m_max_block = init_header;<font></font>
            m_free_blocks.insert(init_header);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isInside</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* address)</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">noexcept</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* start_chunk_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(m_blocks.data());
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* end_chunk_address = start_chunk_address + CHUNK_SIZE;
            <span class="hljs-keyword">return</span> (start_chunk_address &lt;= address) &amp;&amp; (address &lt;= end_chunk_address);<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* <span class="hljs-title">tryReserveBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> allocation_size)</span>
        </span>{
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> not_aligned_address = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>&gt;(m_max_block) + allocation_size;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> alignment_padding = getAlignmentPadding(not_aligned_address, HEADER_SIZE);
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> allocation_size_with_alignment = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size + alignment_padding);
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (allocation_size_with_alignment &gt; *m_max_block) ) <span class="hljs-comment">// Check on enaught memory for allocation</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">// Find min available by size memory block</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> min_it = <span class="hljs-built_in">std</span>::min_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [allocation_size_with_alignment] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (*rhs &lt; allocation_size_with_alignment)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
                }<font></font>
                <font></font>
                <span class="hljs-keyword">return</span> (*lhs &lt; *rhs) &amp;&amp; (*lhs &gt;= allocation_size_with_alignment);<font></font>
            });<font></font>
            <font></font>
            assert(min_it != m_free_blocks.cend() &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            assert(**min_it &gt;= allocation_size_with_alignment &amp;&amp; <span class="hljs-string">"Internal logic error with reserve block, something wrong in implementation..."</span>);<font></font>
            <font></font>
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* header_address = *min_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* new_header_address =
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE + allocation_size_with_alignment);
            <span class="hljs-keyword">if</span> (m_free_blocks.find(new_header_address) == m_free_blocks.cend()) <span class="hljs-comment">// check if there is free memory in the current block</span><font></font>
            {<font></font>
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> old_block_size = *header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> difference = old_block_size - HEADER_SIZE;
                <span class="hljs-keyword">if</span> (difference &gt;= allocation_size_with_alignment) <span class="hljs-comment">// check if there is enough space for another block</span><font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_block_size = difference - allocation_size_with_alignment;<font></font>
                    *new_header_address = new_block_size;<font></font>
                    m_free_blocks.insert(new_header_address);<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            m_free_blocks.erase(header_address);<font></font>
            *header_address = <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>&gt;(allocation_size);
            <span class="hljs-keyword">if</span> (header_address == m_max_block) <span class="hljs-comment">// if the maximum block were changed, then need to find the maximum block again</span><font></font>
            {<font></font>
                <span class="hljs-comment">// Find max block by size</span>
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> max_it = <span class="hljs-built_in">std</span>::max_element(m_free_blocks.cbegin(), m_free_blocks.cend(), [] (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* lhs, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* rhs)<font></font>
                {<font></font>
                    <span class="hljs-keyword">return</span> (*lhs) &lt; (*rhs);<font></font>
                });<font></font>
                <font></font>
                <span class="hljs-comment">// If there are no free blocks, therefore the memory in this chunk is over</span>
                m_max_block = (max_it != m_free_blocks.cend()) ? (*max_it) : (<span class="hljs-literal">nullptr</span>);<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(header_address) + HEADER_SIZE;<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">releaseBlock</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* block_ptr)</span>
        </span>{
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>* header_address = block_ptr - HEADER_SIZE;
            <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> size_relized_block = *header_address;
            <span class="hljs-keyword">if</span> ( (!m_max_block) || (size_relized_block &gt; *m_max_block) ) <span class="hljs-comment">// if the relized block is greater than the maximum, then need to replace it</span><font></font>
            {<font></font>
                m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address);<font></font>
            }<font></font>
                <font></font>
            m_free_blocks.insert(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> forward_it = m_free_blocks.find(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(header_address));
            <span class="hljs-keyword">auto</span> backward_it = tryDefragment(forward_it, m_free_blocks.end());<font></font>
            tryDefragment(<span class="hljs-built_in">std</span>::make_reverse_iterator(backward_it), m_free_blocks.rend());<font></font>
        }<font></font>
    <span class="hljs-keyword">private</span>:
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> DstIterator, <span class="hljs-keyword">typename</span> SrcIterator&gt;
        <span class="hljs-keyword">constexpr</span> DstIterator <span class="hljs-title">getIterator</span><span class="hljs-params">(SrcIterator it)</span> <span class="hljs-keyword">const</span>
        </span>{
            <span class="hljs-keyword">using</span> iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator;
            <span class="hljs-keyword">using</span> reverse_iterator = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::reverse_iterator;
            <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, reverse_iterator&gt;) )</span>
            </span>{
                <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_reverse_iterator(it);<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">constexpr</span> ( (<span class="hljs-built_in">std</span>::is_same_v&lt;SrcIterator, reverse_iterator&gt;) &amp;&amp; (<span class="hljs-built_in">std</span>::is_same_v&lt;DstIterator, iterator&gt;) )<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it.base();<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span><font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> it;<font></font>
            }<font></font>
        }<font></font>
        <font></font>
        <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Iterator&gt;
        Iterator <span class="hljs-title">tryDefragment</span><span class="hljs-params">(Iterator start_it, Iterator end_it)</span>
        </span>{
            <span class="hljs-comment">// primitive defragmentation algorithm - connects two neighboring</span>
            <span class="hljs-comment">// free blocks into one with linear complexity</span><font></font>
   <font></font>
            <span class="hljs-keyword">auto</span> current_it = start_it++;
            <span class="hljs-keyword">auto</span> next_it = start_it;
            <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* current_header_address = *current_it;
            <span class="hljs-keyword">if</span> ( (current_it != end_it) &amp;&amp; (next_it != end_it) )<font></font>
            {<font></font>
                <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* next_header_address = *next_it;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> current_block_size = *current_header_address;
                <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* available_current_block_address =
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt;(current_header_address) + HEADER_SIZE + current_block_size);
                <span class="hljs-keyword">if</span> (available_current_block_address == next_header_address)<font></font>
                {<font></font>
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> next_block_size = *next_header_address;
                    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span> new_current_block_size = current_block_size + HEADER_SIZE + next_block_size;<font></font>
                    *current_header_address = new_current_block_size;<font></font>
                    <span class="hljs-keyword">if</span> (new_current_block_size &gt; *m_max_block)<font></font>
                    {<font></font>
                        m_max_block = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;(current_header_address);<font></font>
                    }<font></font>
                            <font></font>
                    <span class="hljs-keyword">auto</span> delete_it = getIterator&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt;::iterator&gt;(next_it);
                    <span class="hljs-keyword">return</span> getIterator&lt;Iterator&gt;(m_free_blocks.erase(delete_it));<font></font>
                }<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-keyword">return</span> current_it;<font></font>
        }<font></font>
    <span class="hljs-keyword">public</span>:
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint8_t</span>*&gt; m_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>*&gt; m_free_blocks;
        <span class="hljs-built_in">std</span>::<span class="hljs-keyword">uint32_t</span>* m_max_block;<font></font>
    };<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ein wenig dar√ºber, wie Sie die Verwendung von Allokatoren zusammen mit Standardbeh√§ltern dekorieren k√∂nnen: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> CHUNK_SIZE = <span class="hljs-number">16'384u</span>&gt;
<span class="hljs-keyword">using</span> CustomAllocator = Allocator&lt;T, CustomAllocationStrategy&lt;CHUNK_SIZE&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithStackChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">1'024u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> CustomAllocatorWithHeapChunks = Allocator&lt;T, CustomAllocationStrategy&lt;<span class="hljs-number">16'384u</span>&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_vector = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_list = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>&lt;T, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">set</span>&lt;T, <span class="hljs-built_in">std</span>::less&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unordered_set = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_set</span>&lt;T, <span class="hljs-built_in">std</span>::hash&lt;T&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;T&gt;, CustomAllocator&lt;T&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;K, V, <span class="hljs-built_in">std</span>::less&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> K, <span class="hljs-keyword">typename</span> V&gt;
<span class="hljs-keyword">using</span> custom_unordered_map = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;K, <span class="hljs-built_in">std</span>::hash&lt;K&gt;, <span class="hljs-built_in">std</span>::equal_to&lt;K&gt;, CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">const</span> K, V&gt;&gt;&gt;;<font></font>
<font></font>
<span class="hljs-keyword">using</span> custom_string = <span class="hljs-built_in">std</span>::basic_string&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">std</span>::char_traits&lt;<span class="hljs-keyword">char</span>&gt;, CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt;&gt;;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen auch Allokatoren mit intelligenten Zeigern verwenden, daf√ºr m√ºssen Sie jedoch eine kleine Ebene schreiben: </font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">using</span> custom_unique_ptr = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>(T*)&gt;&gt;;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class Allocator, <span class="hljs-keyword">typename</span> T </span>= <span class="hljs-keyword">typename</span> Allocator::value_type, <span class="hljs-keyword">typename</span>... Args&gt;
<span class="hljs-function">custom_unique_ptr&lt;T&gt; <span class="hljs-title">make_custom_unique</span><span class="hljs-params">(Allocator allocator, Args&amp;&amp;... args)</span>
</span>{
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> custom_deleter = [allocator](T* ptr) <span class="hljs-keyword">mutable</span><font></font>
    {<font></font>
        allocator.destroy(ptr);<font></font>
        allocator.deallocate(ptr, <span class="hljs-number">1u</span>);<font></font>
    };<font></font>
        <font></font>
    <span class="hljs-keyword">void</span>* memory_block = allocator.allocate(<span class="hljs-number">1u</span>);
    <span class="hljs-keyword">if</span> (memory_block)<font></font>
    {<font></font>
        T* object_block = <span class="hljs-keyword">static_cast</span>&lt;T*&gt;(memory_block);<font></font>
        allocator.construct(object_block, <span class="hljs-built_in">std</span>::forward&lt;Args&gt;(args)...);
        <span class="hljs-keyword">return</span> custom_unique_ptr&lt;T&gt;{ object_block, custom_deleter };<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun und nun endlich ein Beispiel f√ºr die Verwendung all dessen:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span>
</span>{<font></font>
    CustomAllocationStrategy allocation_area{};<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator{ allocation_area };<font></font>
    custom_vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">vector</span>{ custom_int_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0u</span>; i &lt; <span class="hljs-number">100</span>; ++i)<font></font>
    {<font></font>
        <span class="hljs-built_in">vector</span>.push_back(i);
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">vector</span>.at(i) &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-built_in">vector</span>.resize(<span class="hljs-number">16u</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> val : <span class="hljs-built_in">vector</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt; custom_int_allocator_copy = <span class="hljs-built_in">vector</span>.get_allocator();<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr1 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">100</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr2 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">500</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr3 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1000</span>);<font></font>
    custom_unique_ptr&lt;<span class="hljs-keyword">int</span>&gt; ptr4 = make_custom_unique&lt;CustomAllocator&lt;<span class="hljs-keyword">int</span>&gt;&gt;(custom_int_allocator_copy, <span class="hljs-number">1500</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *ptr1 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr2 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr3 &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; *ptr4 &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">float</span>&gt; custom_float_allocator { custom_int_allocator };<font></font>
    custom_list&lt;<span class="hljs-keyword">float</span>&gt; <span class="hljs-built_in">list</span>{ { <span class="hljs-number">10.0f</span>, <span class="hljs-number">11.0f</span>, <span class="hljs-number">12.0f</span>, <span class="hljs-number">13.0f</span>, <span class="hljs-number">14.0f</span>, <span class="hljs-number">15.0f</span> }, custom_float_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">float</span> val : <span class="hljs-built_in">list</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt;&gt; custom_pair_allocator{ allocation_area };<font></font>
    custom_map&lt;<span class="hljs-keyword">double</span>, <span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">map</span>{ { { <span class="hljs-number">1.0</span>, <span class="hljs-number">100.0</span> }, { <span class="hljs-number">2.0</span>, <span class="hljs-number">200.0</span> } }, custom_pair_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span>&amp; it : <span class="hljs-built_in">map</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"{"</span> &lt;&lt; it.first &lt;&lt; <span class="hljs-string">" : "</span> &lt;&lt; it.second &lt;&lt; <span class="hljs-string">"} "</span>;<font></font>
    }<font></font>
    <font></font>
    CustomAllocator&lt;<span class="hljs-keyword">double</span>&gt; custom_double_allocator{ allocation_area };<font></font>
    custom_set&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-built_in">set</span>{ { <span class="hljs-number">1000.0</span>, <span class="hljs-number">2000.0</span>, <span class="hljs-number">3000.0</span> }, custom_double_allocator };
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">double</span> val : <span class="hljs-built_in">set</span>)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-string">" "</span>;<font></font>
    }<font></font>
<font></font>
    CustomAllocator&lt;<span class="hljs-keyword">char</span>&gt; custom_char_allocator{ allocation_area };<font></font>
    custom_string string1{ <span class="hljs-string">"First allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string2{ <span class="hljs-string">"Second allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string string3{ <span class="hljs-string">"Third allocated string without SBO "</span>, custom_char_allocator };<font></font>
    custom_string result_string = string1 + string2 + string3;<font></font>
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; result_string;<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte mich auf die Tatsache konzentrieren, dass diese Implementierung die primitivste ist, aber sie kann leicht in die Richtung erweitert werden, die Sie ben√∂tigen, sodass alles in Ihren H√§nden liegt!</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielen Dank f√ºr Ihre Aufmerksamkeit, ich hoffe wirklich, dass dieser Artikel f√ºr jemanden n√ºtzlich war. </font><font style="vertical-align: inherit;">Ich w√ºnsche allen auch viel Erfolg bei der engen Interaktion mit dem Ged√§chtnis und vergesse vor allem nicht die sehr wichtigen Worte von Donald Knuth: ‚Äû </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorzeitige Optimierung ist die Wurzel aller √úbel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .‚Äú </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Link zum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der vollst√§ndigen Implementierung des Allokators.</font></font><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendete Quellen</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/de/post/274827</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/mtrebi/memory-allocators</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de505614/index.html">Die Einlagens√§tze der gr√∂√üten Banken fielen auf ein historisches Minimum: Wie wirkt sich dies auf die Wirtschaft aus und wo erfolgt der Umtausch?</a></li>
<li><a href="../de505616/index.html">Erkennung des russischen Alphabets: vom Sammeln eines Datensatzes bis zum Erstellen einer GUI</a></li>
<li><a href="../de505618/index.html">GRASP-Vorlagen: Ersteller</a></li>
<li><a href="../de505620/index.html">HackTheBox. Walkthrough Nest. NTFS-Streams, Reverse C # und SMB Walker</a></li>
<li><a href="../de505624/index.html">Wie verarbeite ich einen Datenrahmen mit Milliarden von Datens√§tzen in Sekunden?</a></li>
<li><a href="../de505634/index.html">Proxy-Einstellungen f√ºr WSL (Ubuntu)</a></li>
<li><a href="../de505640/index.html">Publikationsbewertungsobjektivit√§t</a></li>
<li><a href="../de505642/index.html">Transparente Coroutinen</a></li>
<li><a href="../de505644/index.html">Urheberrechtsinhaber haben es versucht: Die Musikvideokurse von YouTube mit dem Parsen der Songs anderer Personen k√∂nnen verschwinden</a></li>
<li><a href="../de505648/index.html">Einsteins zwei Fehler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>