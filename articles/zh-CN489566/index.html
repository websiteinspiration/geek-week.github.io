<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💙 🛡️ 🦏 用bazel构建C ++ 🏇🏿 🌑 👩🏿‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="介绍与动机
 最近，在Habr上出现了cmake和c ++是朋友的帖子，不仅提供了如何收集仅标头的库的示例，而且至少没有概述一些新的构建系统-bazel，buck，gn和其他。如果您像我一样，在2k20中用C ++编写，那么我建议您熟悉bazel作为c ++项目的构建系统。
 
 我们将不再讨论cm...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>用bazel构建C ++</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489566/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍与动机</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，在Habr上出现了cmake和c ++是朋友的帖子，不仅提供了如何收集仅标头的库的示例，而且至少没有概述一些新的构建系统-bazel，buck，gn和其他。</font><font style="vertical-align: inherit;">如果您像我一样，在2k20中用C ++编写，那么我建议您熟悉bazel作为c ++项目的构建系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将不再讨论cmake和其他现有系统的缺点，而是专注于bazel本身可以做什么。</font><font style="vertical-align: inherit;">为了决定最适合您的是什么，我将其留给您。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从定义和动机开始。</font><font style="vertical-align: inherit;">Bazel是一种多语言Google构建系统，可以构建c ++项目。</font><font style="vertical-align: inherit;">为什么我们还要看另一个构建系统？</font><font style="vertical-align: inherit;">首先，因为她已经在进行一些大型项目，例如Tensorflow，Kubernetes和Gtest，因此要与它们集成，她已经需要能够使用bazel。</font><font style="vertical-align: inherit;">其次，除了Google bazel之外，根据其在bazelcon上的表现来判断，它仍然使用spaceX，nvidia和其他公司。</font><font style="vertical-align: inherit;">最后，bazel是github上一个非常受欢迎的开源项目，因此绝对值得一试并尝试一下。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子1.琐碎的</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有main.cc，需要编译：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, habr"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一切都始于工作空间声明。就bazel工作空间而言，这是所有源文件所在的目录。要指定此工作空间，您需要在我们需要的目录（通常是src目录）中创建一个名称为WORKSPACE的空文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在bazel中组织代码的最小单位是包装。该包由源目录和一个特殊的BUILD文件定义，该文件描述了如何组装这些源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将主程序包添加到我们的项目中：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wq/dq/7l/wqdq7lk5ecrf91hqc2u7og0y3do.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在BUILD文件中，我们现在必须描述要从主程序包构建的内容。当然，我们要编译可执行二进制文件，因此我们将使用cc_binary规则。 Bazel已经开箱即用地支持C ++，因此已经存在一些用于构建c ++目标的规则，我们将在以后了解其余内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将cc_binary规则添加到BUILD文件中，它的名称将包含一个可执行文件和一系列将传递给编译器的源。</font><font style="vertical-align: inherit;">所有这些都在starlark中进行了描述，starlark是一个截断的python。</font></font><br>
<br>
<pre><code class="python hljs">cc_binary(<font></font>
  name = <span class="hljs-string">"hello_world"</span>,<font></font>
  srcs = <span class="hljs-string">"main.cc"</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel与cmake不同，Bazel不是基于命令，而是允许通过规则以声明方式描述依赖关系。</font><font style="vertical-align: inherit;">本质上，规则将多个工件与特定操作相关联。</font><font style="vertical-align: inherit;">bazel使用它们来构建命令图，然后将其缓存并执行。</font><font style="vertical-align: inherit;">在我们的例子中，main.cc源文件与一个编译操作相关联，其结果是工件hello_world-一个二进制可执行文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在要获取可执行文件，我们必须转到带有工作空间的目录并键入：</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //main:hello_world
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
构建系统从项目的根开始接受构建命令和实现目标的路径。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成的二进制文件将位于bazel-bin / main / hello_world。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子2.用你的库构建</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，没有人需要这么简单的项目，所以让我们看看如何为我们的项目添加功能。</font><font style="vertical-align: inherit;">添加一个将单独构建并链接到我们的主库的库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设它是Square，它将提供明确的平方函数的库。</font><font style="vertical-align: inherit;">添加新库意味着添加新包，我们也称其为正方形。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/kr/0o/kvkr0o7nryy4fddsibmtge2dabo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> SQUQRE_SQUARE_H_</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SQUQRE_SQUARE_H_</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>;<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// SQUQRE_SQUARE_H_</span></span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方码</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{
  <span class="hljs-keyword">return</span> x * x;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注意头文件的连接，尽管文件位于同一目录中，但我还是通过工作空间的路径来完成头文件的连接。铬代码样式指南中采用了这种方法，该指南继承自google c ++样式指南。此方法使您可以立即了解头文件的连接位置。不用担心，会有一个文件，bazel将添加搜索头文件的路径，但是如果您不遵循此规则，则在bazel构建过程中可能找不到头文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们库的BUILD文件中，我们描述了构建cc_library库的规则：</font></font><br>
<br>
<pre><code class="python hljs">cc_library(<font></font>
  name = <span class="hljs-string">"square"</span>,<font></font>
  srcs = [<span class="hljs-string">"square.cc"</span>],<font></font>
  hdrs = [<span class="hljs-string">"square.h"</span>],<font></font>
  visibility = [<span class="hljs-string">"//visibility:public"</span>]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们分别列出了源文件和头文件，还指定了公共可见性。</font><font style="vertical-align: inherit;">后者是必需的，以便我们可以在项目中的任何地方依赖我们的库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在main.cc中，我们使用我们的库：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, bazel!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Square(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，我提请注意以下事实：我们通过工作空间的路径包含了库的头文件。</font><font style="vertical-align: inherit;">这在这里已经是绝对必要的，因为bazel在引擎盖下使用Linux容器来确保最小程度的组装性，因此，它将安装方库头文件，以便它们从工作空间通过路径定位。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且我们在正方形库中的main的组装规则中描述了依赖性。</font></font><br>
<br>
<pre><code class="python hljs">cc_binary(<font></font>
  name = <span class="hljs-string">"hello_world"</span>,<font></font>
  srcs = [<span class="hljs-string">"main.cc"</span>],<font></font>
  deps = [<span class="hljs-string">"//square:square"</span>]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们整个程序的组装方式与不使用库的方式相同，bazel将了解它所依赖的内容，构建图形，缓存结果并仅重新组装需要重建的内容。</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //main:hello_world
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子3.连接测试</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没有测试如何生活？</font><font style="vertical-align: inherit;">没门！</font><font style="vertical-align: inherit;">要连接到batest GTest（已支持与bazel组装），您需要添加一个外部依赖项。</font><font style="vertical-align: inherit;">这是在WORKSPACE文件中完成的：</font></font><br>
<br>
<pre><code class="python hljs">load(<span class="hljs-string">"@bazel_tools//tools/build_defs/repo:git.bzl"</span>, <span class="hljs-string">"git_repository"</span>)<font></font>
<font></font>
git_repository(<font></font>
  name = <span class="hljs-string">"googletest"</span>,<font></font>
  remote = <span class="hljs-string">"https://github.com/google/googletest"</span>,<font></font>
  tag = <span class="hljs-string">"release-1.8.1"</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像赶时髦的人一样，他们连接了git_repository规则，并告诉bazel要下载哪个版本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们为测试测试创建一个单独的程序包，并将测试添加到我们的库中：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
square_unittest.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"gtest/gtest.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
TEST(SquareTests, Basics) {<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">-1</span>), <span class="hljs-number">1</span>);<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">1</span>), <span class="hljs-number">1</span>);<font></font>
    EXPECT_EQ(Square(<span class="hljs-number">2</span>), <span class="hljs-number">4</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在该为测试定义一个规则了。</font></font><br>
<br>
<pre><code class="python hljs">cc_test(<font></font>
  name = <span class="hljs-string">"unittests"</span>,<font></font>
  srcs = [<span class="hljs-string">"square_unittest.cc"</span>],<font></font>
  deps = [<font></font>
   <span class="hljs-string">"//square:square"</span>,
   <span class="hljs-string">"@googletest//:gtest_main"</span><font></font>
  ]<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在库和gtest_main中添加了相关性，以便gtest库本身可以为我们提供启动器实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用以下命令运行测试：</font></font><br>
<br>
<pre><code class="bash hljs">bazel <span class="hljs-built_in">test</span> //<span class="hljs-built_in">test</span>:unittests
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel将自己下载并构建GTest，链接测试所需的所有内容并自行运行测试。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我提到bazel也知道如何进行代码覆盖：</font></font><br>
<br>
<pre><code class="bash hljs">bazel coverage //<span class="hljs-built_in">test</span>:unittests
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，如果您需要调试测试，则可以使用以下字符在调试模式下编译所有内容：</font></font><br>
<br>
<pre><code class="bash hljs">bazel build //<span class="hljs-built_in">test</span>:unittests --compilation_mode=dbg -s
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子4.连接不知道如何打包的其他库</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，世界并不是仅基于bazel构建的，因此您还需要能够连接其他库。</font><font style="vertical-align: inherit;">最近，在我的项目中，我需要一个库来解析命令行参数。</font><font style="vertical-align: inherit;">好吧，不要在2k20里给我写你自己的这样的库，而从主要工作中分散注意力。</font><font style="vertical-align: inherit;">我真的不想使用诸如getops之类的任何一半措施，也不想将boost拖入我的项目中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不用于广告，我们将连接CLI11库，该库仅使用stl标准C ++ 11，并提供或多或少的方便界面。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
库是仅标头的，这使得连接它特别容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在WORKSPACE中连接外部依赖项：</font></font><br>
<br>
<pre><code class="python hljs">load(<span class="hljs-string">"@bazel_tools//tools/build_defs/repo:http.bzl"</span>, <span class="hljs-string">"http_file"</span>)<font></font>
<font></font>
http_file(<font></font>
  name = <span class="hljs-string">"CLI11"</span>,<font></font>
  downloaded_file_path = <span class="hljs-string">"CLI11.hpp"</span>,<font></font>
  urls = [<span class="hljs-string">"https://github.com/CLIUtils/CLI11/releases/download/v1.9.0/CLI11.hpp"</span>],<font></font>
  sha256 = <span class="hljs-string">"6f0a1d8846ed7fa4c2b66da3eb252aa03d27170258df..."</span>,<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们添加了第三方目录并添加了CLI11包，以便于在此库上建立依赖关系：</font></font><br>
<br>
<pre><code class="python hljs">cc_library(<font></font>
  name = <span class="hljs-string">"CLI11"</span>,<font></font>
  hdrs = [<span class="hljs-string">"@CLI11//file"</span>],<font></font>
  strip_include_prefix = <span class="hljs-string">"/external/CLI11/file"</span>,<font></font>
  include_prefix = <span class="hljs-string">"CLI11"</span>,<font></font>
  linkstatic = <span class="hljs-literal">True</span>,<font></font>
  visibility = [<span class="hljs-string">"//visibility:public"</span>],<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bazel默认情况下将通过路径/ external / CLI11查找库文件，以便我们稍微更改路径以通过CLI11 /连接它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main.cc</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CLI11/CLI11.hpp"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"square/square.h"</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, bazel!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; Square(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据主要情况，添加“ // third_party / CLI11：CLI11”，一切开始工作。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不了解您，但是连接一些不熟悉的库并以这种形式在c ++项目中使用它会让我感到高兴。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是的，使用仅标头的库，您会说一切都很简单，但是对于尚未使用bazel构建的非标头的库，一切都一样简单。</font><font style="vertical-align: inherit;">您只需通过http_archive或git_repository下载它，然后在第三方目录中向其添加外部BUILD文件，即可在其中描述如何构建库。</font><font style="vertical-align: inherit;">Bazel支持通过cmake_external规则调用任何cmd，甚至调用cmake。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例子5.脚本和自动化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谁需要2k20中裸c ++的项目而没有自动化脚本？</font><font style="vertical-align: inherit;">通常，需要这样的脚本来运行性能测试或将工件部署到CI。</font><font style="vertical-align: inherit;">好吧，通常它们是用python编写的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为此，bazel也适用，因为它几乎可以在所有流行语言中使用，并且旨在从实际项目中经常发现的不同编程语言中收集此类solyanka。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们连接将运行我们的main的python脚本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加perf-tests包：</font></font><br>
<br>
<pre><code class="python hljs">py_binary(<font></font>
  name = <span class="hljs-string">"perf_tests"</span>,<font></font>
  srcs = [<span class="hljs-string">"perf_tests.py"</span>],<font></font>
  data = [<font></font>
    <span class="hljs-string">"//main:hello_world"</span>,<font></font>
  ],<font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为数据依赖项，添加hello_world二进制依赖项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
perf_tests.py</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> subprocess
<span class="hljs-keyword">import</span> time<font></font>
<font></font>
start_time = time.time()<font></font>
process = subprocess.run([<span class="hljs-string">'main/hello_world, '</span>param1<span class="hljs-string">', ],
                         stdout=subprocess.PIPE,
                         universal_newlines=True)
end_time = time.time()
print("--- %s seconds ---" % (end_time - start_time))
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了运行我们的测试，我们只需编写：</font></font><br>
<pre><code class="bash hljs">bazel run //perf-tests:perf_tests
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论和未触及的内容</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们简要介绍了bazel及其主要功能，用于组装第三方和我们自己的可执行文件和库。</font><font style="vertical-align: inherit;">就我的口味而言，结果非常简洁，迅速。</font><font style="vertical-align: inherit;">无需受苦，无需寻找一些cmake教程即可完成一些琐碎的事情并清理CmakeCache。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您感兴趣，那么还有很多遗留的东西：连接协议缓冲区，清理程序，设置工具链以针对不同的平台/体系结构进行编译。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感谢您的阅读，希望对您有所帮助。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489554/index.html">java.lang.String的细微差别</a></li>
<li><a href="../zh-CN489556/index.html">在VS中进行调试时，请勿为ThreadPool中的线程命名</a></li>
<li><a href="../zh-CN489558/index.html">关于三星更新了旗舰电视：Q950-新设备的更改，门槛以及预测</a></li>
<li><a href="../zh-CN489560/index.html">使用AWS + Telegram反应本机反馈表单</a></li>
<li><a href="../zh-CN489562/index.html">使用Spock在Kotlin中进行测试</a></li>
<li><a href="../zh-CN489568/index.html">DEFCON 27 Conference。机械钥匙的复制，访问受到限制。第1部分</a></li>
<li><a href="../zh-CN489576/index.html">现代医学的细微差别</a></li>
<li><a href="../zh-CN489582/index.html">寻找哥斯拉。基于交换和“外部”数据的神经网络和预测报价</a></li>
<li><a href="../zh-CN489584/index.html">如何在node.js上改善您的API服务。第1部分</a></li>
<li><a href="../zh-CN489586/index.html">老式灯具上的声音可视化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>