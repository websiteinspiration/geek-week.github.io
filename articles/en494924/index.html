<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®‚Äç‚úàÔ∏è üë®‚Äçüë¶ üñ®Ô∏è The implementation of the watercolor effect in games üéµ ‚úäüèæ üßõüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction
 When in January 2019 we started discussing our new tint game . , we immediately decided that the watercolor effect would be the most imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The implementation of the watercolor effect in games</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494924/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f9b/8bc/7c5/f9b8bc7c53c4d97ed983c428ce53926b.gif" alt="image"></div><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When in January 2019 we started discussing our new </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tint</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;">.</font></em></a><font style="vertical-align: inherit;"> , we immediately decided that the watercolor effect would be the most important element. Inspired by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bulgari</font></font></em></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"> advertisement</font></a><font style="vertical-align: inherit;"> , we realized that the implementation of watercolor painting should be consistent with the high quality of the remaining resources that we planned to create. We found an interesting article by researchers from Adobe </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The watercolor technique described in it looked wonderful, and due to its vector (rather than pixel) nature, it could work even on weak mobile devices. Our implementation is based on this study, we changed and / or simplified parts of it because our performance requirements were different. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tint</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- this is a game, therefore, in addition to the drawing itself, we needed to render the entire 3D environment and execute the game logic in one frame. </font><font style="vertical-align: inherit;">We also sought to ensure that the simulation was performed in real time and the player immediately saw what was drawn.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2e8/277/d95/2e8277d95ed5a29796176e375ecf59c5.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Water-color simulation in tint. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we will share the individual details of the implementation of this technique in the Unity game engine and talk about how we adapted it to work seamlessly on low-end mobile devices. </font><font style="vertical-align: inherit;">We will talk more about the main stages of this algorithm, but without demonstrating the code. </font><font style="vertical-align: inherit;">This implementation was created in Unity 2018.4.2 and later updated to version 2018.4.7.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is tint.?</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tint</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- This is a puzzle game that allows the player to complete the levels, mixing the colors of watercolors to match the colors of origami. </font><font style="vertical-align: inherit;">The game was released in the fall of 2019 at Apple Arcade for iOS, macOS, and tvOS.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb0/630/d46/bb0630d469679d86535ec46fd97c8f0a.png" width="2224" height="1668"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshot tint.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requirements</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The technique described in my article can be divided into three main stages performed in each frame:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generate new spots based on player input and add them to the spots list</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paint simulation for all spots on the list</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spot rendering</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below we will talk in detail about how we implemented each of the stages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We aimed to reach 60 FPS, that is, these stages and all the logic described below are performed 60 times per second.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getting input</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In each frame, we transform the player‚Äôs input (depending on the platform, it can be a touch, the position of the mouse or the virtual cursor) into a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> structure </font><font style="vertical-align: inherit;">that contains the position, motion vector, color and pressure (2). First, we check the player‚Äôs swipe length on the screen and compare it with a given threshold value. With short swipes, we generate one spot per frame at the input position. In the opposite case, we fill the distance between the start and end points of the player‚Äôs swipe with new spots created with a predetermined density (this ensures a constant paint density regardless of the swipe speed). The color indicates the current paint used, and the slope of the movement indicates the direction of the swipe. Created new spots are added to a collection called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which also contains all previously created spots. </font><font style="vertical-align: inherit;">It is used to simulate and render paint in the following steps. </font><font style="vertical-align: inherit;">Each individual spot denotes a ‚Äúdrop‚Äù of paint that needs to be rendered - the main building block of watercolor painting. </font><font style="vertical-align: inherit;">The finished watercolor drawing will be the result of rendering tens / hundreds of intersecting spots. </font><font style="vertical-align: inherit;">In addition, the value of the lifetime (in frames) is assigned to the newly created spot, which determines how long the spot can be simulated.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ccb/e15/628/ccbe15628a553ba6ceb25af2fd2e2e36.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of interpolation of long swipe spots. </font><font style="vertical-align: inherit;">Hollow circles indicate spots created at regular intervals.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like real paint, we need a canvas. </font><font style="vertical-align: inherit;">To implement it, we created a limited area in 3D space that looks like a sheet of paper. </font><font style="vertical-align: inherit;">The player‚Äôs input coordinates and all other operations, such as rendering a mesh, are recorded in the canvas space. </font><font style="vertical-align: inherit;">Similarly, the size in pixels of any buffer used to simulate drawing depends on the size of the canvas. </font><font style="vertical-align: inherit;">The term ‚Äúcanvas‚Äù as used in this article is in no way associated with the Canvas class from Unity UI.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/648/367/1cc/6483671ccaa809a93bcf2a276cdd2471.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The green rectangle shows the canvas area in the game</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spot</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visually, the spot is represented by a round mesh, the edge of which consists of 25 vertices. You can perceive it as a ‚Äúdrop‚Äù that a wet brush leaves on a piece of paper if you touch it for a very short moment. We add a small random offset to the position of each vertex, which ensures the unevenness of the edges of the spots of paint.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9bb/baa/daa/9bbbaadaaf2b6d0fc1b295f5739ff083.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples of mesh meshes.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
For each vertex, we also store the outward velocity vector, which is then used in the simulation phase. We generate several such meshes with small variations between them forms and store their data in skriptuemy object ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a scriptable object</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Each time a player draws a spot in real time, we assign him a mesh randomly selected from this set. It is worth mentioning that at different screen resolutions the canvas has a different size in pixels. So that on all devices the coefficient of the size of the spots is the same, when the game starts, we change the scale in accordance with the size of the canvas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1af/f92/8de/1aff928de51a35f64351fe72f5c10d80.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of spot vectors stored with new spot data.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When a spot mesh is generated, we also save its ‚Äúwetting area‚Äù, which defines a set of pixels that are inside the original spot borders. The wetting area is used to simulate </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">advection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . During the execution of the application at the time of creating each new spot, we mark the canvas under it as wet. When simulating the movement of paint, we allow it to ‚Äúspread‚Äù over those areas of the canvas that have already become wet. We store the moisture content of the canvas in the global </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer </font><font style="vertical-align: inherit;">, which is updated as each new spot is added. In addition to participating in the mixing of two colors, advection plays an important role in the final appearance of the paint stroke itself.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/843/67e/31d84367e786d15bd7fe0f59cbe2e3a5.jpg"></div><br>
<i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filling </font><font style="vertical-align: inherit;">, pixels inside the spot shape (green circle) mark the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer </font><font style="vertical-align: inherit;">(grid) as wet (green). </font><font style="vertical-align: inherit;">The wetmap buffer itself has a much higher resolution. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, each spot also contains an </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opacity</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value </font><font style="vertical-align: inherit;">, which is a function of its area; </font><font style="vertical-align: inherit;">it represents the effect of storing pigment (a constant amount of pigment in the spot). </font><font style="vertical-align: inherit;">When the size of a spot increases during simulation, its opacity decreases, and vice versa.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/870/a5b/a88870a5b213286e20815f3b87ecca5d.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of paint without advection (left) and with it (right).</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/341/069/348/341069348c265951c765843ca792b2c8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Examples of paint advection.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation cycle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the player‚Äôs input in the current frame is received and converted to new spots, the next step is to simulate the spots to simulate the spreading of watercolors. At the beginning of this simulation, we have a list of spots that need to be updated, and an updated </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In each frame, we go around the list of spots and change the positions of all the vertices of the spots using the following equation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b8/6fe/91a/4b86fe91ae4f677697b43e99a3299ecc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
where: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the new motion vector, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the constant correction parameter (0.33), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the motion slope vector = normalized direction of the player‚Äôs swipe, multiplied by 0.3, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the scalar value of the canvas roughness = Random.Range (1,1 + r), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the global roughness parameter, for standard paint we set it to 0.4, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the velocity vector created in advance with the spot mesh, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the velocity factor, the scalar value that we use locally in some situations to accelerate advection, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - potential new vertex position, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - current vertex position, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is the branch roughness vector = (Random.Range (-r, r), Random.Range (-r, r)), </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w (x)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the wetting value in the wetmap buffer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result of such equations is called </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">biased random walk</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , it imitates the behavior of particles in real watercolor paint. We are trying to move each vertex of the spot outward from its center ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), adding randomness. Then the direction of movement changes slightly with the direction of the stroke ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and is again randomized by another roughness component ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">br</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Then this new vertex position is compared with a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetmap</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the canvas in the new position was already wet (value in the </font><em><font style="vertical-align: inherit;">wetmap</font></em><font style="vertical-align: inherit;"> buffer</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">greater than 0), then we give the vertex a new position </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x (t + 1)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , otherwise we do not change its position. </font><font style="vertical-align: inherit;">As a result, the paint will spread only in those areas of the canvas that were already wet. </font><font style="vertical-align: inherit;">At the last stage, we recalculate the spot area, which is used in the rendering cycle to change its opacity.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a69/742/ae4/a69742ae4ee6d91b27bac6397bd317ff.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microscale example of advection simulation between two active spots of paint.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering Cycle - Wet Buffer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After recounting the spots, you can start rendering them. At the output after the emulation stage, the spot meshes often turn out to be deformed (for example, intersections occur), therefore, for their correct rendering without additional costs for repeated triangulation, we use a solution with two-pass stencil buffer. The Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> drawing interface is used to render spots </font><font style="vertical-align: inherit;">, and the rendering cycle is performed inside the Unity </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OnPostRender</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. Spot meshes are rendered to render texture ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) using a separate camera. At the beginning of the cycle, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is cleared and set as a render target using </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphics.SetRenderTarget (wetBuffer)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Next for each active spot from </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we execute the sequence shown in the following diagram:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e7/a09/328/1e7a0932807463744d7fd50a40fddedc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendering cycle diagram. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We start by cleaning the stencil buffer before each spot so that the state of the stencil buffer of the previous spot does not affect the new spot. </font><font style="vertical-align: inherit;">Then we select the material used to draw the spot. </font><font style="vertical-align: inherit;">This material is responsible for the color of the spot, and we select it based on the color index stored in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatData</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> when the player </font><em><font style="vertical-align: inherit;">drew the</font></em><font style="vertical-align: inherit;"> spot. </font><font style="vertical-align: inherit;">Then we change the color opacity (alpha channel) based on the area of ‚Äã‚Äãthe spot mesh calculated in the previous step. </font><font style="vertical-align: inherit;">The rendering itself is performed using a two-pass stencil buffer shader. </font><font style="vertical-align: inherit;">In the first pass (Material.SetPass (0)) we pass the original spot mesh to record the coordinates in which the mesh is filled. </font><font style="vertical-align: inherit;">With this pass </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ColorMask</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assigned a value of 0, so the mesh itself is not rendered. </font><font style="vertical-align: inherit;">In the second pass (Material.SetPass (1)) we use the quadrilateral described around the spot mesh. </font><font style="vertical-align: inherit;">We check the value in the stencil buffer for each pixel of the quadrilateral; </font><font style="vertical-align: inherit;">if the value is one, the pixel is rendered, otherwise it is skipped. </font><font style="vertical-align: inherit;">As a result of this operation, we render the same shape as the spot mesh, but it certainly will not contain unwanted artifacts, for example, self-intersections.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a9/06b/beb/1a906bbeb3f003d057430f6fb28e9257.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The procedure for performing the double stencil buffer technique (from left to right). </font><font style="vertical-align: inherit;">Note that this stencil buffer has a much higher resolution than shown, so it can maintain its original shape with great accuracy.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/15d/3ae/ed515d3aec23cd4eb9041761913afd2c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of three intersecting spots rendered in the traditional way, which led to the appearance of artifacts (left), and using the two-pass stencil buffer technique with the elimination of all artifacts (right).</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
After rendering all the spots in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it is displayed in the game scene. Our canvas uses a makeshift shader combining a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a diffuse paper map, and a paper normal map.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/968/db5/55a/968db555a2a477134013c355e3898e90.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canvas shader: only wetBuffer (left), added paper texture (center), normal map added (right). </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The game supports a mode for people with color blindness, in which separate patterns are superimposed on top of the paint. </font><font style="vertical-align: inherit;">To achieve this, we changed the material of the stains by adding the texture of the pattern with tiling. </font><font style="vertical-align: inherit;">Patterns follow the rules of mixing the colors of the game, for example, blue (bars) + yellow (circles) give green (circles in the bars) at the intersection. </font><font style="vertical-align: inherit;">To seamlessly blend patterns, they must be rendered in the same UV space. </font><font style="vertical-align: inherit;">We adjust the UV coordinates of the quadrilateral used in the second pass of the stencil buffer, dividing the x and y positions (which are specified in the canvas space) by the width and height of the canvas. </font><font style="vertical-align: inherit;">As a result, we get the correct values ‚Äã‚Äãof u, v in the space from 0 to 1.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b5/057/211/7b50572119f116fae451dd321275a920.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of color blindness patterns.</font></font></i><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimization - dried spots buffer</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned above, one of our tasks was to support low-power mobile devices. </font><font style="vertical-align: inherit;">Spot rendering turned out to be the bottleneck of our game. </font><font style="vertical-align: inherit;">Each spot requires three draw calls (call two passes + clear the stencil buffer), and since the paint line contains tens or hundreds of spots, the number of draw calls increases rapidly and leads to a drop in frame rate. </font><font style="vertical-align: inherit;">To cope with this, we applied two optimization techniques: firstly, the simultaneous drawing of all ‚Äúdried‚Äù spots in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and secondly, the local acceleration of the drying of the spots after reaching a certain number of active spots. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Is an additional render texture added to the rendering cycle. As mentioned earlier, each spot has a lifetime (in frames), which decreases with each frame. After the lifespan reaches 0, the stain is considered ‚Äúdried up‚Äù. Dry spots are no longer simulated, their shape does not change, and therefore they do not need to be rendered again in each frame.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b44/afe/714/b44afe714c3be2aed6d853d031e2379a.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DryBuffer in action; the gray spots show the spots copied to dryBuffer.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Each spot whose lifetime reaches 0 is removed from the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">splatList</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and ‚Äúcopied‚Äù to </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . During the copy process, the rendering cycle is reused, and this time </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is set as the target render texture </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proper mixing between </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cannot be achieved by simply overlapping the buffers in the canvas shader, because the render texture of the </font><em><font style="vertical-align: inherit;">wetBuffer</font></em><font style="vertical-align: inherit;"> buffer</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contains spots already rendered with alpha value (which is equivalent to premultiplied alpha). </font><font style="vertical-align: inherit;">We circumvented this problem by adding one step to the start of the rendering cycle before iteratively traversing the spots. </font><font style="vertical-align: inherit;">At this point, we render a quadrilateral the size of a camera trimming pyramid that displays </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Thanks to this, any stain that is rendered in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wetBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will already be mixed with dry, previously painted stains.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/24e/afe/417/24eafe41762bcd3e7b2363e78c8bb9c0.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A mixture of wet and dried spots. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer </font><font style="vertical-align: inherit;">accumulates all ‚Äúdried‚Äù spots and is not cleared between frames. </font><font style="vertical-align: inherit;">Therefore, all memory that is associated with expired stains can be cleared after they are ‚Äúcopied‚Äù to the buffer.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/aa0/5bd/00eaa05bd29ca5c46eb8a845accc0b75.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to the optimization with </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we no longer have limits on the amount of paint a player can apply to the canvas.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Using the </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dryBuffer</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> technique </font><font style="vertical-align: inherit;">separately allows the player to draw with an almost infinite amount of paint, but does not guarantee consistent performance. As mentioned above, the paint stroke has a constant </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thickness</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is achieved by drawing using interpolation of many spots between the start and end points of the swipe. In the case of many fast and long swipes, the player can generate a large number of active spots. These spots will be simulated and rendered over the number of frames specified by their life span, which ultimately leads to lower frame rates.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To ensure a stable frame rate, we changed the algorithm so that the number of active spots was limited by a constant value of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All spots exceeding this value instantly ‚Äúdry out‚Äù. This is realized by reducing the life span of the oldest active spots to 0, which is why they are copied to the dried spots buffer earlier. Since when we shorten the life we ‚Äã‚Äãget a spot in the incomplete state of the simulation (which will look quite interesting), at the same time we increase the speed of spreading of the paint. Due to the increase in speed, the spot reaches almost the same size as at normal speed with a standard lifespan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/c68/4c9/907c684c9c3642f6a109b4cadcf8718c.gif"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/fe2/72b/d79fe272b648131541bfbf423384fc29.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demonstration of maximum 40 (top) and 80 (bottom) active spots. </font><font style="vertical-align: inherit;">Dried spots copied in dryBuffer are shown in gray. </font><font style="vertical-align: inherit;">The value indicates the ‚Äúamount‚Äù of paint that can be simulated at the same time. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The value of </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maxActiveSplats</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the most important performance parameter, it allows us to precisely control the number of draw calls that we can allocate to watercolor rendering. </font><font style="vertical-align: inherit;">We set it at startup, based on the platform and device power. </font><font style="vertical-align: inherit;">You can also change this value during application execution if a decrease in frame rate is detected.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of this algorithm has become an interesting and challenging task. </font><font style="vertical-align: inherit;">We hope readers enjoyed the article. </font><font style="vertical-align: inherit;">You can ask questions in the comments to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">original</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">If you want to appreciate our watercolor in action, then try playing </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tint. </font><font style="vertical-align: inherit;">on the Apple Arcade</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/959/89e/fda/95989efda4d27809e1ce3923b341ac46.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Screenshot of a game running on Apple TV</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1) S. DiVerdi, A. Krishnaswamy, R. M√Ñch and D. Ito, ‚ÄúPainting with Polygons: A Procedural Watercolor Engine,‚Äù in IEEE Transactions on Visualization and Computer Graphics, vol. </font><font style="vertical-align: inherit;">19, no. </font><font style="vertical-align: inherit;">5, pp. </font><font style="vertical-align: inherit;">723‚Äì735, May 2013. doi: 10.1109 / TVCG.2012.295 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(2) Pressure is only taken into account when drawing the Apple Pencil on an iPad.</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en494912/index.html">My contribution to the protection against Covid-19</a></li>
<li><a href="../en494916/index.html">How to sell merchant accounts and ride a wave of interest in online business</a></li>
<li><a href="../en494918/index.html">The third week of the remote - normal flight. Reviews from IT QIWI guys about full-time work from home</a></li>
<li><a href="../en494920/index.html">Bad advice to the developer: what to do to ‚Äúplease‚Äù the management</a></li>
<li><a href="../en494922/index.html">Nizhny Novgorod for an IT specialist: prospects for work and opportunities for life</a></li>
<li><a href="../en494930/index.html">Unity3D: Automatic Script Manager Aggregator</a></li>
<li><a href="../en494932/index.html">Operating a Large Distributed System: What I Learned</a></li>
<li><a href="../en494934/index.html">6 mistakes in English words that are terribly enraging</a></li>
<li><a href="../en494938/index.html">Happy backup day! Don't forget about him</a></li>
<li><a href="../en494940/index.html">DevOps - what is it, why, and how much is it in demand?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>