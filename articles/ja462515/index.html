<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧖🏾 🕒 🌬️ システムキーボードを操作するときのバグ 👨🏽‍🏭 🧟 👩🏻‍🎓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="アプリケーションを操作して、ある時点でシステムキーボードをアクティブにして、メッセージを入力するか、必要なフィールドに入力します。キーボードが表示されているが、メッセージを入力するためのフィールドがない、またはその逆の状況に遭遇しました-テキストを入力するためのキーボードが表示されていませんか？バグ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>システムキーボードを操作するときのバグ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/462515/"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションを操作して、ある時点でシステムキーボードをアクティブにして、メッセージを入力するか、必要なフィールドに入力します。キーボードが表示されているが、メッセージを入力するためのフィールドがない、またはその逆の状況に遭遇しました-テキストを入力するためのキーボードが表示されていませんか？バグは、特定のアプリケーション内の問題や、システムキーボードの一般的な欠点に関連している可能性があります。</font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">Mail.ruのiOS開発者である</font></em></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Mordan</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、自分の仕事のすべてを見ました。iOSのキーボード制御メソッドを分析した後、彼はそれらを検出して修正するために使用した主なバグとアプローチを共有することにしました。</font></font></em><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/wc/xg/fbwcxgdtopdtlj8_u7rkj1vnmne.jpeg" width="400"></div><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：カットの下には、バグを明確に示すために多数のgifを配置しています。</font><font style="vertical-align: inherit;">AppsConfのKonstantin </font><font style="vertical-align: inherit;">の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートには</font><font style="vertical-align: inherit;">、さらに多くの例があります</font><font style="vertical-align: inherit;">。</font></font></i><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムキーボードコールの実装</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なキーボードコールの実装方法を理解することから始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードを使用して、アイカ（サウスパークのキャラクター）をカナダ人全体にアセンブルすることをタスクとするアプリケーションを開発しているとします。</font><font style="vertical-align: inherit;">アイクをお腹に押し付けると、キーボードが離れ、主人公の足を頭まで上げます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクを実装するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InputAccessoryView</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する</font><font style="vertical-align: inherit;">か、システム通知を処理します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">InputAccessoryView</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のオプションを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ViewControllerで、キーボードと一緒に立ち上がるビューを作成し、それにフレームを割り当てます。</font><font style="vertical-align: inherit;">このビューをサブビューとして追加しないことが重要です。</font><font style="vertical-align: inherit;">次に、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canBecomeFirstResponder</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティをオーバーライドして</font><font style="vertical-align: inherit;">trueを返します。</font><font style="vertical-align: inherit;">私たちは、UIResponderプロパティ再定義した後- </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inputAccessoryViewを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、そこにビューを置きます。</font><font style="vertical-align: inherit;">キーボードを閉じるには、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tapGesture</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">し、そのハンドラーで、</font><font style="vertical-align: inherit;">ビューを作成し</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たfirstResponderをリセットし</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ViewController</span>: <span class="hljs-title">UIViewController</span> </span>{
    <span class="hljs-keyword">var</span> tummyView: <span class="hljs-type">UIView</span> {
        <span class="hljs-keyword">let</span> frame = <span class="hljs-type">CGRect</span>(x: x, y: y, width: width, height: height)
        <span class="hljs-keyword">let</span> v = <span class="hljs-type">TummyView</span>(frame: frame)
        <span class="hljs-keyword">return</span> v<font></font>
    }<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> canBecomeFirstResponder: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
    }<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> input <span class="hljs-type">AccessoryView</span>: <span class="hljs-type">UIView?</span> {
        <span class="hljs-keyword">return</span> tummyView<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tapHandler</span> <span class="hljs-params">( )</span></span> {<font></font>
        tummyView.resignFirstResponder ( )<font></font>
    }<font></font>
} </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクが完了し、システム自体がキーボードの状態変化を処理して表示し、それに依存するビューを表示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ew/mu/nd/ewmundnnrpbdgjgwvk_frx4qv6o.gif" width="200"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システム通知処理</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通知を処理する場合は、次のグループからの通知を自分で処理する必要があります。</font></font><br>
<br>
<ul>
<li>  / : keyboardWillShowNotification, keyboardDidShowNotification;</li>
<li>  / : keyboardWillHideNotification, keyboardDidHideNotification;</li>
<li>   / : keyboardWilChangeFrameNotification, keyboardDidChangeFrameNotification.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのケースを実装する</font><font style="vertical-align: inherit;">には、キーボードが表示されているときと非表示になっているときの両方でこの通知が送信されるため、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keyboardWilChangeFrameNotificationを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取ってみましょう</font><font style="vertical-align: inherit;">。</font><em><font style="vertical-align: inherit;">keyboardTracker</font></em></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を作成し、</font><font style="vertical-align: inherit;">その中にサブスクライブして</font><em><font style="vertical-align: inherit;">keyboardWillChangeFrame</font></em><font style="vertical-align: inherit;">通知を受け取り</font><font style="vertical-align: inherit;">、ハンドラーでキーボードフレームを取得し、それを画面座標系からウィンドウ座標系に変換し、キーボードの高さを計算して、キーボードによって発生するビューのY値をこの高さに変更します。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyboardTracker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enable</span> <span class="hljs-params">( )</span></span> {<font></font>
    notificationCenter.add0observer(<span class="hljs-keyword">self</span>,<font></font>
                seletor: #selector( keyboardWillChangeFrame),<font></font>
                name: <span class="hljs-type">UIResponder</span>.keyboardWillChangeFrameNotification,<font></font>
                object: <span class="hljs-literal">nil</span>)<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardWillChangeFrame</span> <span class="hljs-params">( notification: NSNotification)</span></span> {
    <span class="hljs-keyword">let</span> screenCoordinatedKeyboardFrame = <font></font>
    (userInfo [ <span class="hljs-type">UIResponder</span>.keyboardFrameEndUserInfoKey ] <span class="hljs-keyword">as</span>! <span class="hljs-type">NSValue</span> ) .cgRectValue
    <span class="hljs-keyword">let</span> keyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal">nil</span> ) 
    <span class="hljs-keyword">let</span> windowHeight =  window.frame.height
    <span class="hljs-keyword">let</span> keyboardHeight = windowHeight - keyboardFrame.minY<font></font>
    delegate.keyboardWillChange ( keyboardHeight )<font></font>
    }<font></font>
} </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで私たちのタスクが完了し、キーボードが上昇し、Ikeをカナダ人に集めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、どちらの場合もキーボードを使用した実装は非常に簡単なので、適切な方法を自由に選択できます。</font><font style="vertical-align: inherit;">私たちのプロジェクトでは、通知を優先して選択しました。そのため、通知の処理に関連する例や洞察がさらにあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグを探す</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードを呼び出す方法が非常に簡単である場合、バグはどこから発生しますか？もちろん、アプリケーションがキーボードを開いたり閉じたりするためのスクリプトのみを再生する場合は、問題はありません。ただし、通常のコースを変更する場合は、アプリケーションだけでなく他のユーザーもキーボードを使用でき、ユーザーがキーボードを切り替えることもできるので、驚きは避けられません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を見てみましょう。これを行うには、アプリケーションをIkeで使用します。キーボードを開いて、Notesに切り替え、何かを印刷して、アプリケーションに戻ります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どのような問題がすでに見えていますか？まず、App Switcherにはキーボードがありませんが、アプリケーションを最小化すると、その代わりに他のコンテンツが表示されます。次に、アプリケーションに戻ると、キーボードはまだ存在せず、Ikeの脚が画面から落ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動作の理由を見てみましょう。アプリケーションのライフサイクル図から覚えているように、アプリケーションがアクティブ状態から非アクティブ状態に最初にフォアグラウンドで、次にバックグラウンドで遷移するには時間がかかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードのライフサイクルはどうですか？ iOSでは、時間単位ごとに、実行中のアプリケーションの1つだけがキーボードを所有できますが、キーボードのステータスの変更に関する通知は、それらにサブスクライブしているすべてのアプリケーションによって受信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるアプリケーションから別のアプリケーションに切り替えると、システムはそのfirstResponderをリセットします。これは、キーボードを非表示にするトリガーとして機能します。システムは、まずキーボードが消えるようにkeyboardWillHide通知を送信し、次にkeyboardDidHideNotificationを送信します。通知は2番目のアプリケーションに送信されます。新しいアプリケーションでは、キーボードを開きます。システムはキーボードが表示されるようにkeyboardWillShowNotificationを送信し、次に</font><font style="vertical-align: inherit;">サイクルのフェーズを含む</font><font style="vertical-align: inherit;">keyboardDidShowNotification- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デモを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">送信</font><font style="vertical-align: inherit;">します。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">レポートの一部</font></a></font><br>
<br>
<img src="https://habrastorage.org/webt/gk/th/5c/gkth5chvrkyewmvhdrpc7eito9q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を見ると</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（8:39から）、キーボードを非表示にした後、システムがkeyboardDidHideNotificationを送信して最初のアプリケーションを非アクティブ状態にする瞬間が表示されます。</font><font style="vertical-align: inherit;">スポーツアプリに切り替えてキーボードを起動すると、システムはkeyboardWillShowNotificationを送信します。</font><font style="vertical-align: inherit;">ただし、切り替えと開始のプロセスが速く、ライフサイクルのフェーズ間の移行時間が長くなる可能性があるため、受信した通知は、スポーツのアプリケーションだけでなく、まだバックグラウンドに移行できていないビールのアプリケーションも処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理由を理解したところで、Ikeの問題の解決策を見つけましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪い決断</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に頭に浮かぶのは、KeyboardTrackerを有効/無効にすることでアプリケーションを最小化/最大化するときの通知のサブスクライブ解除/サブスクライブのアイデアです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サブスクライブを解除するには、applicationWillResignActiveメソッドまたは同様のシステムからの通知ハンドラを使用します。サブスクライブには、applicationDidBecomeActiveを使用しますが、何かを見逃さないようにするために、アプリケーションがフォアグラウンドに入ったときに呼び出されたがまだアクティブにならないapplicationWillEnterForegroundメソッドにも通知します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションでキーボードを起動すると、ほとんどの場合すべてが成功しますが、たとえば、キーボードを開いて音声ダイヤルを録音しようとするなどのより複雑なテストでは、ソリューションは機能しません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dy/0b/_e/dy0b_eiomhqtkuqimnsdew_es-c.gif" width="200"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どうした </font><font style="vertical-align: inherit;">ボイスメッセージのダイヤルボタンをクリックした後、アプリケーションがfirstResponderをリセットし、キーボードが閉じ、applicationWillResignActiveメソッドが呼び出され、通知のサブスクライブが解除されました。</font><font style="vertical-align: inherit;">アラートを閉じた後、システムはアプリケーションの状態を復元しましたが、applicationWillEnterForegroundメソッド、特にapplicationDidBecomeActiveが呼び出される前に呼び出されました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英断</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の解決策は、保護液（Bool）の使用です。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">var</span> wasTummyViewFirstResponderBeforeApp0idEnterBackground
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willResignActive</span><span class="hljs-params">( notification: NSNotification)</span></span> {<font></font>
    wasTextFieldFirstResponderBeforeAppDidEnterBackground = tummyView.isFirstResponder<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willEnterForeground</span> <span class="hljs-params">( notification: NSNotification)</span></span> {
    <span class="hljs-keyword">if</span> wasTextFieldFirstResponderBeforeAppDidEnterBackground {
        <span class="hljs-type">UIView</span>.performWithourAnimation {<font></font>
            tummyView.becomeFirstResponder ( )<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックの前にキーボードが開かれたかどうか、アプリケーションがアクティブでなくなった方法、およびapplicationWillEnterForegroundメソッドで以前の状態を復元したかどうかを覚えています。</font><font style="vertical-align: inherit;">残っている唯一の修正は、アプリスイッチャーの穴です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jc/sl/oc/jcsloczny6akuricp8x0bzwvbxo.jpeg" width="400"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリスイッチャー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリスイッチャーは、アプリがバックグラウンドになった後にシステムが実行するアプリスナップショットを表示します。</font><font style="vertical-align: inherit;">スクリーンショットは、キーボードがすでに別のアプリケーションで使用されているときに、アプリケーションのスナップショットが作成されたことを示しています。</font><font style="vertical-align: inherit;">これは重要ではありませんが、数回クリックするだけで修正できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良い解決策</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このソリューションは、機密データを隠すことを学んだ銀行アプリケーションから借りることができ、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apple</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からも読み取ることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
applicationDidEnterBackgroundメソッドでデータを非表示にして、スプラッシュスクリーンをぼかして表示し、applicationWillEnterForegroundメソッドで通常のビュー階層に戻ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションは適していません。applicationDidEnterBackgroundメソッドが呼び出されるときまでに、アプリケーションにキーボードがないためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英断</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使い慣れたメソッドwillResignActive、willEnterForeground、didBecomeActiveを使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アプリケーションにはまだキーボードがありますが、willResignActiveメソッドでアプリケーションの独自のスナップショットを作成し、それを階層に配置する必要があります。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willResignActive</span><span class="hljs-params">( notificaton: NSNotification)</span></span> {
    <span class="hljs-keyword">let</span> keyWindow = <span class="hljs-type">UIApplication</span>.shared.keyWindow<font></font>
<font></font>
    imageView = <span class="hljs-type">UIImageView</span>( frame: keyWindow.bounds)<font></font>
    imageView.image = snapshot ( )<font></font>
<font></font>
    <span class="hljs-keyword">let</span> lastSubview = keyWindow.subviews.last<font></font>
    lastSubview( imageView)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
willEnterForegroundメソッドとdidBecomeActiveメソッドで、ビュー階層を復元し、スナップショットを削除します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">willEnterForeground</span><span class="hljs-params">( notification: NSNotification)</span></span> {<font></font>
	imageView.removeFromSuperview( )<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">didBecomeActive</span><span class="hljs-params">( notification: NSNotification)</span></span> {<font></font>
	imageView.removeFromSuperview( )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、両方のケースを修正しました。アプリスイッチャーでは、切り替え時に美しい画像とキーボードがジャンプしなくなりました。</font><font style="vertical-align: inherit;">これらはそれほど重要なことではないように思われますが、製品開発にとってこれらの点は非常に重要です。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪いニュース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ikeの問題に対する私たちの成功した解決策は、アプリケーションを最小化する前にキーボードが開かれた場合に関係していました。</font><font style="vertical-align: inherit;">キーボードを拡張せずに切り替えが発生すると、再びハイクの脚が下に落ちることがわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zm/nr/4n/zmnr4nm4u8tph3bf86jkr05ix5k.gif" width="200"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはアプリケーションの問題であるだけでなく、通知で機能するFacebookや、inputAccessoryViewを使用してキーボードを制御するiMessageでも発生します。</font><font style="vertical-align: inherit;">これは、バックグラウンドに切り替わる前に、アプリケーションが他の人のキーボード通知を処理するためです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">対話的にキーボードを閉じる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ikeを使用してアプリケーションにいくつかの機能を追加し、プログラムにインタラクティブにキーボードを非表示にするように指示します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/g6/cy/1g/g6cy1gparlfmqc0abfaz7rd_rr0.gif" width="200"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪い決断</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能を作成する1つの方法は、キーボードビューのフレームを変更することです。</font><font style="vertical-align: inherit;">panGestureRecognizerを作成し、そのハンドラーで、指の位置に応じてキーボードのY座標の新しい値を計算し、キーボードビューを見つけて、Y座標値で更新します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panGestureHandler</span><span class="hljs-params">( )</span></span> {
    <span class="hljs-keyword">let</span> yPosition: <span class="hljs-type">CGFloat</span> = value<font></font>
    keyboardView( )?.frame.origin.y = yPosition<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードは別のウィンドウに表示されるため、アプリケーションのウィンドウの配列全体を調べ、配列の各要素を確認して、キーボードウィンドウであるかどうかを確認し、そうである場合は、キーボードから表示されるビューを取得します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardView</span><span class="hljs-params">( )</span></span> -&gt; <span class="hljs-type">UIView?</span> {
    <span class="hljs-keyword">let</span> windows = <span class="hljs-type">UIApplication</span>.shared.windows<font></font>
<font></font>
    <span class="hljs-keyword">let</span> view = windows.first { (window) -&gt; <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> keyboardView( fromWindow: window) != <span class="hljs-literal">nil</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> view<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、この解決策はiPhone X以降では正常に機能しません。指を動かすと、アプリケーションを最小化する責任がある下部のインジケーターにわずかに触れる可能性があるためです。</font><font style="vertical-align: inherit;">その後、インタラクティブな非表示が機能しなくなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eg/-o/iv/eg-oiv8yrssufcejelvxqj4ksrq.gif" width="200"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題はウィンドウの配列にあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vc/u6/9o/vcu69oekot0zgl31iikyy_0refo.jpeg" width="600"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェスチャーの後、システムは既存のキーボードウィンドウの上に新しいキーボードウィンドウを作成します。</font><font style="vertical-align: inherit;">考えられないが、本当です。</font><font style="vertical-align: inherit;">その結果、配列には同じ座標を持つ2つのキーボードウィンドウが含まれていることがわかりましたが、最初のウィンドウは非表示になっています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pp/0v/ha/pp0vhay6ionyekifnsg-9jvnpzg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウィンドウの配列を反復処理して、条件を満たしている最初のウィンドウを見つけ、それが非表示であるにもかかわらず、そのウィンドウで作業を開始することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどのように修正されますか？</font><font style="vertical-align: inherit;">ウィンドウの配列を回します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">panGeastureHandler</span><span class="hljs-params">( )</span></span> {
    <span class="hljs-keyword">let</span> yPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0.0</span><font></font>
    keyboardView( )?.frame.origin.y = yPosition<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardView</span><span class="hljs-params">( )</span></span> -&gt; <span class="hljs-type">UIView?</span> {
    <span class="hljs-keyword">let</span> windows = <span class="hljs-type">UIApplication</span>.shared.windows.reversed( )
    <span class="hljs-keyword">let</span> view = windows.first { (window) -&gt; <span class="hljs-type">Bool</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">return</span> keyboardView( fromWindow: window) != <span class="hljs-literal">nil</span><font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> view<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iPadのキーボード機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
iPadのキーボードは、通常の状態に加えて、ドッキングされていない状態になっています。</font><font style="vertical-align: inherit;">ユーザーは、画面上で移動したり、2つの部分に分割したり、スライドオーバーモード（他の上に）でアプリケーションを起動することさえできます。</font><font style="vertical-align: inherit;">もちろん、これらすべてのモードでキーボードがバグなしで機能することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haykeを確認してみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/y1/4x/l5/y14xl5geuyxmkubopbkabplwbz4.gif"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悲しいかな、これは今のケースではありません。</font><font style="vertical-align: inherit;">ユーザーが画面上でキーボードを動かし始めると、アイクの脚は頭の上から飛び出して、次のキーボードを開いた後にのみ表示されます。</font><font style="vertical-align: inherit;">分割キーボードのケースでそれを修正してみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原因</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通知の分析から始めましょう。分割ボタンをクリックすると、2つの通知グループ（keyboardWillChangeFrameNotification、keyboardWillHideNotification、keyboardDidChangeFrameNotification、keyboardDidHideNotification）が表示されます。グループ間の違いは、キーボードの座標のみです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分割ボタンをクリックすると、キーボードが減少し、最初のグループの通知が届きます。キーボードが分かれて2階に上がると、2パック目の通知が届きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なことは、キーボードが消えたという通知を受け取ることですが、表示されたという通知は受け取りません。ちなみに、これはkeyboardWillChangeFrameNotificationの使用を支持するもう1つの利点です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、キーボードを画面上で動かし始めると、なぜIkeの足が飛び去るのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この時点で、システムはkeyboardWillChangeFrameNotificationを送信しますが、そこにある座標は（0.0、0.0、0.0、0.0）です。これは、移動が完了した後、キーボードがどの時点になるかをシステムが認識していないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードフレームの変更を処理する現在のコードでゼロを代入すると、キーボードの高さがウィンドウの高さに等しいことがわかります。</font><font style="vertical-align: inherit;">それがアイクの足が画面から飛び出す理由です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英断</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するために、最初に、キーボードがドッキングされていないモードになっていて、ユーザーが画面上でキーボードを移動できる場合について理解します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、ウィンドウとmaxYキーボードの高さを比較します。</font><font style="vertical-align: inherit;">それらが等しい場合、キーボードは通常の状態にあり、maxYがウィンドウの高さより小さい場合、ユーザーはキーボードを動かします。</font><font style="vertical-align: inherit;">その結果、次のコードがkeyboardTrackerに表示されます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyboardTracker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">enable</span><span class="hljs-params">( )</span></span> {<font></font>
        notificationCenter.addObserver( <span class="hljs-keyword">self</span>,<font></font>
                selector:#selector( keyboardWillChangeFrame),<font></font>
                name:<span class="hljs-type">UIResponder</span>.keyboardWillChangeFrameNotification,<font></font>
                object:<span class="hljs-literal">nil</span>)<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardWillChangeFrame</span><span class="hljs-params">( notification: NSNotification)</span></span> {
        <span class="hljs-keyword">let</span> screenCoordinatedKeyboardFrame = <font></font>
        (userInfo[<span class="hljs-type">UIResponder</span>.keyboardFrameEndUserInfoKey] <span class="hljs-keyword">as</span>! <span class="hljs-type">NSValue</span>).cgRectValue
        <span class="hljs-keyword">let</span> leyboardFrame = window.convert ( screenCoordinatedKeyboardFrame, from: <span class="hljs-literal">nil</span>)
        <span class="hljs-keyword">let</span> windowHeight = window.frame.height
        <span class="hljs-keyword">let</span> keyboardHeight = windowHeight - keyboardFrame.minY
        <span class="hljs-keyword">let</span> isKeyboardUnlocked = isIPad ( ) &amp;&amp; keyboardFrame/maxY &lt; windowHeight
        <span class="hljs-keyword">if</span> isKeyboardUnlocked {<font></font>
            keyboardHeight = <span class="hljs-number">0.0</span><font></font>
        }<font></font>
        delegate.keyboardWillChange ( keyboardHeight)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高さをゼロにカスタム設定し、キーボードが動くと、Ikeの脚が下に下がり、そこで固定されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tx/uv/u_/txuvu_-lhk01nhlzbcyfxc8g3k4.gif" width="400"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残っている唯一の誤解は、キーボードを分割したときに、Ikeの脚がすぐに落ちないという事実です。</font><font style="vertical-align: inherit;">それを修正するには？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
keyboardTrackerがkeyboardWillChangeFrameNotificationだけでなく、keyboardDidChangeFrameでも機能するように教えます。</font><font style="vertical-align: inherit;">新しいコードを記述する必要はありません。不要な計算を行わないように、これがiPadであることのチェックを追加するだけです。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyboardTracker</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardDidChangeFrame</span><span class="hljs-params">( notification: NSNotification)</span></span> {
        <span class="hljs-keyword">if</span> isIPad ( ) == <span class="hljs-literal">false</span> {
            <span class="hljs-keyword">return</span>
        }</code></pre><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/-n/nv/jd-nnvrctruwlczh4ytw2ckfllu.gif" width="400"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグを検出するには？</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">豊富なロギング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロジェクトでは、ログは次の形式で書き込まれます。角括弧内に、ログが属するモジュールとサブモジュールの名前、そしてログ自体のテキスト。</font><font style="vertical-align: inherit;">たとえば、次のように</font></font><br>
<code>[keyboard][tracker] keyboardWillChangeFrame: calculated height - 437.9</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なります。コードでは、次のようになります。ロガーはトップレベルのタグで作成され、トラッカーに渡されます。</font><font style="vertical-align: inherit;">トラッカー内では、クラス内でのロギングに使用される第2レベルのタグを持つロガーがロガーから分離されます。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyboardTracker</span> </span>{
    <span class="hljs-keyword">init</span>(with logger: <span class="hljs-type">Logger</span>) {
        <span class="hljs-keyword">self</span>.trackerLogger = logger.dequeue(withTag: <span class="hljs-string">"[tracker]"</span>)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">keyboardWillChangeFrame</span><span class="hljs-params">(notification: NSNotification)</span></span> {
        <span class="hljs-keyword">let</span> height = <span class="hljs-number">0.0</span><font></font>
<font></font>
        trackerLogger.debug(<span class="hljs-string">"\(#function): calculated height - \(height)"</span>)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで、私はkeyboardTracker全体を誓約しました。</font><font style="vertical-align: inherit;">テスターが問題を見つけた場合、ログファイルを取得して、フレームが適合しない場所を正確に探しました。</font><font style="vertical-align: inherit;">これには時間がかかりすぎたため、ロギングに加えて、他の方法が適用され始めました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">番犬</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロジェクトでは、ウォッチドッグを使用してUIストリームを最適化しています。</font><font style="vertical-align: inherit;">これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、過去のAppsConfの1つでDmitry Kurkinによって伝えられました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウォッチドッグは、</font><font style="vertical-align: inherit;">別のプロセスまたはスレッド</font><font style="vertical-align: inherit;">を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">監視</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するプロセスまたはスレッドです。</font><font style="vertical-align: inherit;">このメカニズムにより、キーボードの状態とそれに依存するビューを監視し、問題を報告できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような機能を実装するために、1秒に1回、ハイクの脚のあるビューが正しく配置されていることを確認するタイマーを作成します。エラーが発生した場合は、これをログに記録します。</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watchdog</span> </span>{
    <span class="hljs-keyword">var</span> timer: <span class="hljs-type">Timer?</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">start</span> <span class="hljs-params">( )</span></span> {<font></font>
        timer = <span class="hljs-type">Timer</span> ( timeInterval: <span class="hljs-number">1.0</span>, repeats: <span class="hljs-literal">true</span>, block: { ( timer ) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">self</span>.woof ( ) <font></font>
        } )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、最終結果だけでなく、中間計算もログに記録できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、豊富なロギング+ Watchdogは問題、キーボードの状態に関する正確なデータを提供し、バグを修正するための時間を短縮しましたが、次のリリースまでエラーに耐えなければならないベータユーザーを支援することはほとんどできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もしウォッチドッグが問題を発見するだけでなく、それらを修正するためにも訓練されるとしたらどうでしょう？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ウォッチドッグがビューの座標が収束しないという結論を出すコードでは、fixTummyPositionメソッドを追加して、座標を自動的に配置します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このオプションでは、多くの有用な情報がログに蓄積され、ユーザーは視覚的な問題にまったく気づきません。これはすばらしいようですが、キーボードの問題を見つけることができなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが検出されたときにテストキャッシュを生成する機能をウォッチドッグメソッドに追加すると役立ちます。</font><font style="vertical-align: inherit;">もちろん、このコードはremoot設定の下に追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、次のリリース後、テストクラッシュの生成をオンにできます。ユーザーがキーボードに問題がある場合、アプリケーションがクラッシュし、収集されたログのおかげで、バグを修正できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ダッシュボード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが紹介した最後のトリックは、wahtchdogが統計を記録した瞬間に統計を送信することです。</font><font style="vertical-align: inherit;">得られたデータに基づいて、検出されたエラーの数をプロットし、最初の反復の後、操作の数を4倍に減らしました。</font><font style="vertical-align: inherit;">もちろん、問題をゼロにすることはできませんでしたが、ユーザーからの主な苦情はなくなりました。</font></font><br>
<br>
<blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Saint AppsConf</a>,        ,     iOS-.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462505/index.html">関数型プログラミングに騙されないでください</a></li>
<li><a href="../ja462507/index.html">メール配信時：iOSでのプッシュ通知の喪失との戦い</a></li>
<li><a href="../ja462509/index.html">Product Fest-行きたいIT製品管理会議</a></li>
<li><a href="../ja462511/index.html">Google Play Instant。生涯のリファクタリング</a></li>
<li><a href="../ja462513/index.html">移転：領域の準備、選択、開発</a></li>
<li><a href="../ja462519/index.html">本「マイクロサービス。開発とリファクタリングのパターン»</a></li>
<li><a href="../ja462523/index.html">LinOTP 2要素認証サーバー</a></li>
<li><a href="../ja462525/index.html">3CXは、エンドツーエンドの音声暗号化を備えたiOSおよびAndroid用の新しいSIPソフトフォンを発売</a></li>
<li><a href="../ja462527/index.html">SincNetニューラルネットワークがバックプロパゲーションを介してサウンドに重要な周波数を割り当てる方法</a></li>
<li><a href="../ja462529/index.html">NASAのルナステーションのアイデアは良くない</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>