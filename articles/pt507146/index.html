<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßû üçù ü•° Janelas multicoloridas: construtor virtual, CRTP e modelos complexos ‚ÜôÔ∏è üèéÔ∏è üíÖüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Por algum tempo, um padr√£o de design n√£o trivial √© conhecido quando uma classe derivada √© passada no par√¢metro base:
 

template<class T> class Base {...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Janelas multicoloridas: construtor virtual, CRTP e modelos complexos</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por algum tempo, um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">padr√£o de design n√£o trivial √©</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conhecido </font><font style="vertical-align: inherit;">quando uma classe derivada √© passada no par√¢metro base:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este modelo tem seu pr√≥prio nome - CRTP: Padr√£o de Modelo Curiosamente Recorrente, que se traduz como "padr√£o estranhamente repetitivo". Acrescentei ainda mais esquisitices a essa constru√ß√£o j√° estranha: generalizei-a a toda uma cadeia de heran√ßas. Sim, isso realmente pode ser feito, mas, para isso, √© preciso </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dar √† alma</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um pre√ßo alto. Para descobrir como eu o fiz e que pre√ßo tenho que pagar, convido voc√™ a ler mais este artigo para obter detalhes.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui vamos lidar </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com terr√≠veis pervers√µes por</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> v√°rios m√©todos estranhos e outras coisas ruins. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero avis√°-lo imediatamente: n√£o tome o material descrito aqui como algo s√©rio. Estou certo de que em 95-99% dos casos tudo isso nunca ser√° √∫til para voc√™ na pr√°tica. Este √© um tipo de matem√°tica divertida, um treino para a mente. Na pr√°tica, √© improv√°vel que seja √∫til, mas √© interessante dedicar tempo a isso. Somente nesse caso a linguagem C ++ e seus recursos agem como matem√°tica. Eu te aviso com anteced√™ncia, porque Se voc√™ est√° procurando algo s√©rio e praticamente orientado aqui, pode ficar desapontado.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sintonize imediatamente o ex√≥tico, como se voc√™ de repente se encontrasse em um pa√≠s onde duas luas, tr√™s s√≥is, folhas de plantas s√£o azuis ou lil√°s, e de fato muitas coisas comuns s√£o meio ... estranhas e incomuns ... Se voc√™ est√° atolado na vida cotidiana cinzenta e h√° pouco tempo ler algo assim, ent√£o voc√™ veio para o endere√ßo ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janelas multicoloridas</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foi h√° muito tempo. </font><font style="vertical-align: inherit;">Quase tr√™s anos atr√°s. </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sentei-</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> me ent√£o </font><s><font style="vertical-align: inherit;">em uma grama pesada e</font></s><font style="vertical-align: inherit;"> compreendi apenas a </font><font style="vertical-align: inherit;">base </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de C ++ 11/14 do livro Meyers S. - "C ++ efetivo e moderno". </font><font style="vertical-align: inherit;">Tamb√©m menciona esse padr√£o. </font><font style="vertical-align: inherit;">Depois disso, como senti que havia </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atingido a ilumina√ß√£o,</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dominei o b√°sico do novo padr√£o e estava pronto para analisar as coisas antigas de uma nova maneira, comecei a atualizar um livro sobre a API do Windows em minha mem√≥ria: Shchupak Yu. - ‚ÄúAPI do Win32. </font><font style="vertical-align: inherit;">Desenvolvimento eficaz de aplicativos. ‚Äù </font><font style="vertical-align: inherit;">No in√≠cio, ele descreve um programa m√≠nimo de linguagem C para criar e exibir uma janela:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu j√° fiz isso muitas vezes, exibindo diferentes janelas no modelo deste livro. </font><font style="vertical-align: inherit;">E de repente pensei: Acabei de ler sobre C ++ ontem! </font><font style="vertical-align: inherit;">Eu posso escrever minha pr√≥pria classe para exibir esta janela! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o antes de dizer que acabou:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura da classe √© trivial: v√°rios construtores s√£o declarados (com a transfer√™ncia dos par√¢metros principais e links para a estrutura WNDCLASSEX mais detalhada), a fun√ß√£o CreateWnd do registro da classe da janela e a pr√≥pria cria√ß√£o da janela, chamada pelos construtores, bem como um conjunto de fun√ß√µes-membro virtuais que executam a√ß√µes processando cada uma das mensagens do Windows dentro do procedimento de retorno de chamada da janela. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os membros dos dados da classe tamb√©m s√£o m√≠nimos: window handle hWnd; Estrutura WNDCLASSEX usada para criar a classe; e a barra de t√≠tulo da janela.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O procedimento de retorno de chamada da janela √© declarado como est√°tico para evitar a passagem impl√≠cita do ponteiro this para o objeto de classe e, assim, violar o acordo sobre o tipo (assinatura) da fun√ß√£o do procedimento de janela aceito no Windows (lembre-se de que n√£o chamaremos essa fun√ß√£o n√≥s mesmos, mas o Windows, porque os par√¢metros e o tipo de retorno dessa fun√ß√£o s√£o estritamente especificados).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Procedimento de janela e esse ponteiro</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â conhecido em C ++: se uma fun√ß√£o de membro √© definida como est√°tica, um ponteiro para um objeto de classe deve ser passado explicitamente para ele. No entanto, n√£o podemos passar um ponteiro para um objeto de classe para um procedimento de janela est√°tica, pois o formato dessa fun√ß√£o n√£o permite essa transfer√™ncia. Nesse contexto, surge um problema fundamental: se existem v√°rios objetos da classe WindowClass, como o √∫nico procedimento est√°tico da janela sabe qual objeto espec√≠fico da classe a mensagem recebeu? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° apenas uma sa√≠da: voc√™ precisa estabelecer essa conex√£o de uma maneira ou de outra.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O Windows identifica uma janela pelo identificador HWND hWnd. O objeto de classe correspondente a esta janela pode ser identificado por um ponteiro para este objeto. Portanto, √© necess√°rio estabelecer a conex√£o hWnd &lt;-&gt; ponteiro para o objeto WindowClass. Por exemplo, um procedimento de janela, ao mesmo tempo em que √© membro de uma classe, pode ter um link ou um ponteiro para alguma estrutura de dados tamb√©m est√°tica que estabelece uma conex√£o entre hWnd e um ponteiro de objeto para cada janela e √© atualizado sempre que um objeto da classe √© criado. A estrutura de dados deve ser est√°tica para que, em primeiro lugar, possa ser acessada de dentro de um procedimento de janela est√°tica sem um ponteiro para qualquer objeto de classe e, em segundo lugar, que seja exclusiva para todos os objetos da classe (que segue logicamente de sua finalidade ) e em terceiro lugar,para que ele ainda esteja vinculado a uma classe com o n√≠vel de acesso apropriado e n√£o seja uma vari√°vel global externa.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, depois de descobrir como descrever essa estrutura e por que ela √© necess√°ria, resta descobrir qual deve ser essa estrutura. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duas matrizes din√¢micas podem ser declaradas: uma para identificadores de janela HWND e a segunda para ponteiros para objetos WindowClass. No entanto, essa n√£o √© a melhor solu√ß√£o: n√£o est√° claro como escolher o tamanho da matriz, quais ser√£o os cen√°rios para o uso do Windows, se as matrizes ficar√£o quase vazias se o tamanho delas for selecionado incorretamente, o que causar√° excesso de mem√≥ria. Ou, pelo contr√°rio, quando, ao criar janelas, o volume estiver esgotado, ser√° necess√°rio aumentar o tamanho, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma solu√ß√£o melhor (e at√© eu diria - ideal) nessa situa√ß√£o √© uma lista ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Uma lista √© uma estrutura de dados din√¢mica que consiste em um conjunto de n√≥s conectados em pares. Cada n√≥ (no caso de uma lista duplamente vinculada) possui ponteiros para os n√≥s anteriores e seguintes da lista, al√©m de dados armazenados adicionais. Em nossa situa√ß√£o, cada n√≥ da janela corresponde a cada uma das janelas, e os dados √∫teis s√£o um identificador de janela e um ponteiro para um objeto da classe WindowClass. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, cada vez que uma nova janela √© criada, um novo n√≥ da lista √© criado e adicionado ao seu final (torna-se o √∫ltimo). Ao fechar, o n√≥ √© exclu√≠do e os ponteiros dos n√≥s anteriores e seguintes s√£o ajustados entre si para substituir o n√≥ remoto. Ao mesmo tempo, n√£o h√° sobrecarga de mem√≥ria - exatamente o n√∫mero de n√≥s criados e o n√∫mero de janelas criadas, e eles tamb√©m s√£o exclu√≠dos ao mesmo tempo em que a janela √© fechada.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, um novo membro est√°tico tamb√©m deve ser adicionado √† classe WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e declare-o privilegiado para permitir o acesso a membros WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Agora n√£o darei aqui uma defini√ß√£o da classe da lista e da classe do n√≥, suas fun√ß√µes, uma vez que isso n√£o se aplica diretamente √† classe WindowClass, e a l√≥gica de implementa√ß√£o dessa classe √© conhecida e bastante trivial.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, o procedimento de janela quando uma nova mensagem chegar, caso seja exibida pertence ao n√∫mero que processa, de acordo com o descritor de janelas hWnd passado a partir do Windows, acessa a lista, procura um n√≥ nele de acordo com o hWnd especificado e, localizando-o, obt√©m o ponteiro necess√°rio para um objeto da classe WindowClass. Em seguida, por ponteiro, ele chama uma fun√ß√£o virtual correspondente √† mensagem que est√° sendo processada: para uma classe substitu√≠da, uma fun√ß√£o virtual com o mesmo nome pode executar outras a√ß√µes.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
H√° um ponto sutil aqui. Diz respeito √† inicializa√ß√£o da classe e ao processamento da mensagem WM_CREATE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar uma janela com a fun√ß√£o CreateWindow, no momento de sua chamada, o identificador de janela hWnd ainda n√£o √© conhecido: a janela ainda n√£o foi criada! Portanto, para poder chamar OnCreate virtual, voc√™ precisa conhecer o ponteiro para o objeto de classe. Isso √© feito passando um pouco arriscado o ponteiro this da fun√ß√£o WindowClass :: CreateWnd para a fun√ß√£o CreateWindow por meio do ponteiro lParam. Ao processar WM_CREATE, o procedimento de janela recebe esse ponteiro do par√¢metro, com sua ajuda inicializa o membro hWnd dentro do objeto e cria um novo n√≥ de lista para esta janela usando o ponteiro para o objeto de classe. Em seguida, ele chama o OnCreate virtual por ponteiro.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para as mensagens restantes, a l√≥gica descrita acima √© executada: procure o n√≥ da lista pelo identificador de janela atual hWnd transferido do Windows e chame a fun√ß√£o virtual desejada pelo ponteiro para o objeto de classe no n√≥ da lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de compilar o programa e garantir que tudo funcione corretamente, eu, esfregando as m√£os </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com a sensa√ß√£o de minha pr√≥pria grandeza</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do trabalho realizado, comecei a ler mais. </font><font style="vertical-align: inherit;">E na pr√≥xima p√°gina √© indicada a fun√ß√£o de alterar as propriedades da janela:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidi imediatamente criar uma nova janela com base na antiga:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe derivada difere da classe base adicionando um contador de janela est√°tico e alterando OnCreate, OnPaint e OnDestroy: a fun√ß√£o OnCreate altera a cor de plano de fundo da janela, o OnPaint exibe uma mensagem diferente e o OnDestroy diminui o contador de janelas est√°ticas. </font><font style="vertical-align: inherit;">Tudo √© muito simples e claro. </font><font style="vertical-align: inherit;">Montado e lan√ßado. </font><font style="vertical-align: inherit;">O texto da mensagem ficou diferente ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mas a cor da janela n√£o mudou.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construtor virtual</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Percebi ent√£o que j√° havia pisado no gelo fino. </font><font style="vertical-align: inherit;">Nem todas as nuances s√£o descritas no material b√°sico dos principais livros. </font><font style="vertical-align: inherit;">Um deles √© um construtor virtual. </font><font style="vertical-align: inherit;">Eu pensei que chamar a fun√ß√£o virtual da classe derivada do construtor √© exatamente o mesmo que em qualquer outro lugar do programa. </font><font style="vertical-align: inherit;">Acabou que isso n√£o p√¥de ser feito.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O problema √© que a fun√ß√£o virtual chamada do construtor √© chamada como n√£o virtual: apenas o objeto da classe base √© criado, e n√£o at√© o final, e o objeto derivado ainda n√£o foi criado e a tabela de fun√ß√µes virtuais n√£o foi gerada. No nosso caso, obtemos a cadeia: construtor derivado -&gt; construtor base -&gt; CreateWnd -&gt; CreateWindow -&gt; procedimento de janela -&gt; OnCreate, ou seja, OnCreate √© realmente chamado do construtor. O objeto derivado ainda n√£o foi criado, portanto, OnCreate √© chamado para a classe base! Sua redefini√ß√£o na derivada, ao que parece, n√£o faz sentido! O que fazer?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabe-se do C ++ que qualquer fun√ß√£o substitu√≠da pode ser chamada por seu nome completo: class_name :: function_name. Um nome de classe n√£o √© apenas um nome: ele se identifica, de fato, o tipo de objeto. Tamb√©m √© conhecido no C ++ que uma classe (e fun√ß√£o) pode ser criada como modelo (modelo) passando-o como par√¢metro. Portanto, se voc√™ criar o modelo de fun√ß√£o do procedimento de janela e passar o tipo da classe derivada para ele de alguma forma, poder√° chamar a fun√ß√£o substitu√≠da desejada diretamente no construtor da </font><font style="vertical-align: inherit;">classe </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para para para !!! Voc√™ n√£o pode fazer o mesmo !!! Uma classe derivada ainda n√£o foi criada, seus dados n√£o foram inicializados: quais fun√ß√µes voc√™ chamar√° aqui? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se voc√™ n√£o pode, mas realmente quer, pode.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, eu n√£o pretendi apelar completamente √† classe derivada. </font><font style="vertical-align: inherit;">Eu pretendia chamar uma </font><font style="vertical-align: inherit;">fun√ß√£o WinAPI de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terceiros</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que n√£o tem nada a ver com a classe. </font><font style="vertical-align: inherit;">"Mas isso pode ser feito de maneiras completamente diferentes, e muito mais f√°cil!" </font><font style="vertical-align: inherit;">- voc√™ diz. </font><font style="vertical-align: inherit;">Sim. </font><font style="vertical-align: inherit;">Pode. </font><font style="vertical-align: inherit;">E vou escrever sobre isso no final do artigo. </font><font style="vertical-align: inherit;">Mas naquele momento eu joguei tudo isso de lado e me concentrei no lado puramente t√©cnico da quest√£o: mas, ainda assim, √© poss√≠vel, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">em princ√≠pio,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chamar algo da derivada no construtor da classe base? </font><font style="vertical-align: inherit;">Era um interesse puramente esportivo, se voc√™ preferir. </font><font style="vertical-align: inherit;">Eu n√£o pensava em nenhum lado pr√°tico naquele momento. </font><font style="vertical-align: inherit;">Era uma tarefa n√£o trivial, e me perguntei se conseguiria resolv√™-la.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe de modelo de janela - m√©todo 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a dificuldade √©: como passar o tipo da classe derivada para o procedimento de janela? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu n√£o queria transformar toda a classe base do WindowClass em uma classe de modelo de uma vez: para cada classe derivada, sua pr√≥pria classe base ser√° gerada. Al√©m disso, como o WindowClass se tornar√° modelo, os n√≥s da lista e a pr√≥pria lista tamb√©m precisar√£o ser criados: eles t√™m ponteiros para objetos de classe e, para usar esses ponteiros, devem conhecer seu tipo, isto √©, WindowClass e com o que ser√° parametrizado. . No momento de definir a classe da lista e a classe do n√≥, isso √© desconhecido; portanto, esse tipo tamb√©m deve ser passado como par√¢metro (de WindowClass). Daqui resulta que, para cada classe derivada, criar√° sua pr√≥pria lista correspondente a </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">essa classe derivada</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(e somente ele)! E agora voc√™ n√£o pode colocar ponteiros para as classes base correspondentes a diferentes derivadas em uma matriz: elas t√™m tipos diferentes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o comecei a procurar uma maneira de passar o tipo da classe derivada, sem parametrizar toda a classe. Um tipo pode ser passado para a classe base apenas atrav√©s do construtor: esta √© a √∫nica fun√ß√£o acessada ao criar o objeto. Portanto, deve ser clich√™. No entanto, descobriu-se que ela obviamente n√£o podia especificar os par√¢metros do modelo: seria como passar par√¢metros para a pr√≥pria classe do modelo, e n√£o para o construtor. Portanto, o tipo s√≥ pode ser inferido a partir dos par√¢metros passados ‚Äã‚Äãpara o construtor. Mas eu n√£o queria adicionar um par√¢metro construtor especial, que serve apenas para infer√™ncia de tipo: bagun√ßando a lista de argumentos com um par√¢metro puramente utilit√°rio. E se o usu√°rio esquecer de transferi-lo, por exemplo,atrav√©s de pelo menos o nullptr trivial (DerivedClass *)? Isso ainda n√£o √© assustador - o compilador exibir√° uma mensagem de erro informando que a classe n√£o pode ser instanciada. Pior ainda, se o usu√°rio criar uma hierarquia de classes e passar um ponteiro para a classe derivada errada: tudo estar√° correto do ponto de vista da compila√ß√£o, no entanto, obteremos um programa de trabalho incorreto com um erro incompreens√≠vel.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em resumo, esse erro de c√°lculo do projeto √© uma solu√ß√£o. </font><font style="vertical-align: inherit;">Assim, a responsabilidade pela instancia√ß√£o correta nem mesmo √© transferida para o criador da classe derivada, mas para quem a usar√°! </font><font style="vertical-align: inherit;">E ele n√£o pode ser um sonho, nem um esp√≠rito a respeito de tais nuances e sinceramente n√£o entende onde est√° o erro. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, desistindo, decidi, no entanto, sem alterar os par√¢metros do construtor, parametrizar o WindowClass em si e ao mesmo tempo a lista associada e as classes de n√≥s da lista. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe de modelo WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe derivada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um procedimento de janela, sendo um membro do modelo de uma classe de modelo e tendo acesso ao tipo passado da classe derivada, chama OnCreate da classe derivada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, chegamos naturalmente ao modelo CRTP. Aqui acabou por si s√≥. Somente muito mais tarde descobri que esse design √© um modelo conhecido com o nome correspondente. Mas ent√£o eu n√£o sabia disso, e me pareceu que a recebi pela primeira vez.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Percebi imediatamente que essa √© apenas metade da solu√ß√£o. </font><font style="vertical-align: inherit;">Posso facilmente criar outra classe com base nesse derivado. </font><font style="vertical-align: inherit;">E √© isso: n√£o √© um clich√™ e n√£o aceita mais par√¢metros. </font><font style="vertical-align: inherit;">Ent√£o, tive a id√©ia de passar a segunda classe derivada pela primeira derivada para a base. </font><font style="vertical-align: inherit;">(O gelo fino sob meus p√©s come√ßou a rachar ... Eu j√° estava indo para onde n√£o havia retorno.) Mas se eu fizer uma vez, posso faz√™-lo quantas vezes quiser: mesmo que eu tenha dez aulas derivadas, posso pegar o d√©cimo consecutivo ( a √∫ltima) para passar ao longo da cadeia at√© a base e chamar√° ali a fun√ß√£o dessa √∫ltima derivada de que preciso (e, em geral, qualquer intermedi√°ria, se desejado). </font><font style="vertical-align: inherit;">A tarefa estava clara. </font><font style="vertical-align: inherit;">Tudo o que restava era faz√™-lo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe de janela parametrizada - m√©todo 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na segunda execu√ß√£o, eu me propus tr√™s tarefas:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, para atender a esses requisitos, voc√™ ainda precisar√° criar um modelo para o designer e adicionar um par√¢metro especial a ele. No entanto, isso significa uma viola√ß√£o de outro requisito. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qual √© a solu√ß√£o aqui? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ pode dividir a classe base original WindowClass em dois componentes: a pr√≥pria WindowClass (vamos cham√°-la WindowClassBase agora), que √© uma base √∫nica e inabal√°vel, e complementando sua classe derivada (que ainda pode ser chamada de mesmo nome original WindowClass). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe complementar √© respons√°vel pela implementa√ß√£o do OnCreate e, al√©m disso, pode ser parametrizada como um todo. E ele em seu construtor passar√° o tipo passado a ele atrav√©s de um par√¢metro especial para o construtor da classe WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De qualquer forma, no WindowClassBase em rela√ß√£o √† fonte, agora voc√™ precisa fazer algumas altera√ß√µes. Primeiro, al√©m de remover o OnCreate dele, voc√™ precisar√° adicionar um membro de ponteiro √† classe que o complementa (e, no futuro, derivados dele), bem como uma fun√ß√£o de chamada que chama OnCreate por esse ponteiro: n√£o podemos chamar o ponteiro para o base, porque o OnCreate n√£o est√° mais nele, e o OnCreate das classes complementares e derivadas √© melhor cham√°-lo pelo ponteiro correto para a classe desejada, em vez de tentar algo com esse ponteiro da base. Por fim, o par√¢metro especial do construtor WindowClassBase ser√° necess√°rio n√£o apenas para infer√™ncia de tipo, mas tamb√©m para salvar e depois chamar a classe necess√°ria atrav√©s do OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, o tipo desse ponteiro teve que ser anulado:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a classe n√£o √© modelo e voc√™ n√£o pode dizer ao compilador para criar um ponteiro com um tipo desconhecido;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muitos derivados s√£o herdados da classe base, todos eles t√™m tipos diferentes - que tipo de ponteiro devo usar?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, acabei de declarar no estilo C: em qualquer situa√ß√£o estranha, use um ponteiro para anular. </font><font style="vertical-align: inherit;">O ponteiro √© fisicamente armazenado como sem tipo, mas no momento da chamada, OnCreate √© convertido para o tipo da classe chamada. </font><font style="vertical-align: inherit;">Isso √© feito em uma fun√ß√£o de chamada de modelo especial que pertence a WindowClassBase e cujo tipo de par√¢metro √© conhecido no momento da chamada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Inicialmente, std :: true_type ou std :: false_type foi usado como o segundo par√¢metro para selecionar a op√ß√£o desejada para substituir a fun√ß√£o. Usando o m√©todo SFINAE, foi verificado no est√°gio de compila√ß√£o se a classe WndCls tem uma fun√ß√£o de membro OnCreate. Se houver, a vers√£o acima da fun√ß√£o ser√° chamada. Caso contr√°rio, a chamada para OnCreate foi feita no formato:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Posteriormente, verificou-se que SFINAE n√£o era necess√°rio: uma classe que complementa WindowClassBase, em qualquer caso, possui uma fun√ß√£o de membro OnCreate; portanto, mesmo que a classe de par√¢metro WndCls passada n√£o possua OnCreate definida, ela est√° em uma das classes base em rela√ß√£o a ela. , e a verifica√ß√£o ser√° verdadeira em todos os casos. Se, por algum milagre, a classe complementar for alterada para que o OnCreate seja removido dela e tamb√©m n√£o exista em todas as suas classes derivadas, n√£o h√° sentido em invoc√°-la da segunda maneira: esse c√≥digo simplesmente n√£o ser√° compilado. Portanto, no final, a op√ß√£o acima √© dada aqui.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A l√≥gica de aceitar e usar o tipo de classe base em WindowClassBase √© bastante simples: o tipo √© derivado do ponteiro para o objeto da classe derivada que √© passado ao construtor WindowClassBase, esse ponteiro √© armazenado nesse construtor e o ponteiro √© passado para o procedimento da janela do modelo, e o LaunchOnCreate acima √© acessado a partir dele. . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a classe WindowClassBase ficar√° agora assim:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, aqui est√° o c√≥digo para o construtor mais curto:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro do procedimento da janela, a chamada para LaunchOnCreate √© a seguinte:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele decidiu remover o pr√≥prio procedimento de janela da classe externa, declarando-o privilegiado na classe WindowClassBase. Talvez isso n√£o fa√ßa muito sentido: que diferen√ßa faz, onde produzir suas instancia√ß√µes - fora ou dentro da classe? O segmento de c√≥digo √© um! Embora, admito, do ponto de vista do mesmo encapsulamento, talvez voc√™ ainda deva deix√°-lo est√°tico dentro da classe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resta definir a classe complementar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A classe possui um construtor que se parece com o WindowClass original antes da divis√£o, ou seja, sem um par√¢metro especial, e esse par√¢metro especial √© gerado internamente ao acessar o construtor WindowClassBase passando o ponteiro this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este WindowClass neste formul√°rio √© quase o equivalente ao WindowClass original. </font><font style="vertical-align: inherit;">Como tal, ele n√£o suporta heran√ßa com substitui√ß√µes OnCreate. </font><font style="vertical-align: inherit;">No entanto, este √© o ponto de partida para dar suporte √† heran√ßa (como ser√° mostrado abaixo). </font><font style="vertical-align: inherit;">Nesta forma:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a classe base WindowClassBase n√£o √© gen√©rica em si mesma, o que significa que ser√° a √∫nica para todas as classes derivadas, quaisquer que sejam; </font><font style="vertical-align: inherit;">a lista para garantir que todas as outras mensagens do Windows sejam processadas corretamente tamb√©m ser√° a √∫nica;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o construtor WindowClass n√£o possui um par√¢metro especial extra.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como voc√™ pode ver, dois dos tr√™s requisitos foram atendidos. </font><font style="vertical-align: inherit;">Resta lidar com o √∫ltimo: com a heran√ßa.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de classe derivada encadeada em WindowClassBase, tipo de controle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, consideraremos a heran√ßa √∫nica, quando a l√≥gica de inicializa√ß√£o do WindowClass n√£o nos conv√©m e queremos alter√°-la atrav√©s da cria√ß√£o de uma classe derivada (por enquanto, pelo menos uma). </font><font style="vertical-align: inherit;">O que precisa ser alterado no WindowClass para garantir isso? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma nova variante da classe complementar torna-se padr√£o. </font><font style="vertical-align: inherit;">Isso n√£o √© assustador, pois ele realmente n√£o cont√©m nenhum dado, mas apenas a fun√ß√£o OnCreate e os construtores:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa classe pega um par√¢metro do tipo DerWndCls e, convertendo esse ponteiro para ele, passa para WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Preste aten√ß√£o ao static_cast. Isso √© importante porque minha convers√£o foi originalmente escrita no estilo C assim:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de traduzi-lo para todo o mundo para static_cast, metade do c√≥digo (veja abaixo) n√£o foi compilado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse tamb√©m √© um ponto sutil: a convers√£o √© realizada no est√°gio de compila√ß√£o, mas essa classe em si tem a fun√ß√£o OnCreate e, ap√≥s a convers√£o, DerWndCls pode ser usado para chamar OnCreate da classe DerWndCls. </font><font style="vertical-align: inherit;">Essa √© a diferen√ßa do caso de convers√£o descrito acima no WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, voc√™ pode criar uma determinada classe WindowClassDerived, substituir OnCreate nela e instancia-la com o WindowClassTemplate descrito acima, implementando novamente o mesmo modelo de repeti√ß√£o estranho original indicado no in√≠cio do artigo:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E o OnCreate deste WindowClassDerived ser√° chamado dentro do WindowClassBase, conforme necess√°rio!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas essa √© uma heran√ßa √∫nica. </font><font style="vertical-align: inherit;">No caso de heran√ßa m√∫ltipla, em vez de WindowClassDerived, por sua vez, voc√™ deve declarar um novo modelo, que potencialmente eleva a classe a um n√≠vel mais alto na hierarquia e a passa para WindowClassTemplate. </font><font style="vertical-align: inherit;">Destaco especificamente dois pontos principais:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Potencialmente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hospede a classe na hierarquia. </font><font style="vertical-align: inherit;">Isso significa que ela pode n√£o aceitar nenhuma classe, ou seja, ela pr√≥pria √© a classe mais alta da hierarquia, para que um objeto possa ser criado a partir dela.</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Par√¢metro de </font><b><font style="vertical-align: inherit;">transmiss√£o</font></b><font style="vertical-align: inherit;"> WindowClassTemplate. </font><font style="vertical-align: inherit;">Isso significa que o argumento do modelo aceito deve ser passado ainda mais de classe para classe, por toda a cadeia de heran√ßa at√© o final, em WindowClassTemplate e da√≠ para WindowClassBase.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ou seja, por um lado, a classe deve ser modelo e usar uma determinada classe como par√¢metro. Por outro lado, ele deve monitorar a situa√ß√£o de que ela pr√≥pria √© uma classe finita (no momento da instancia√ß√£o) e instanciar a classe base por si mesma e n√£o pelo tipo transferido. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com tudo isso, eu gostaria que fosse feito automaticamente pelo compilador: definir uma nova classe com base em uma j√° criada n√£o exigir√° nenhuma modifica√ß√£o da √∫ltima - ent√£o toda a ess√™ncia do polimorfismo de heran√ßa √© perdida. Ou seja: eu crio uma classe que est√° atualmente no topo da hierarquia, mas </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">talvez</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uma nova classe seja criada com base nisso, que substituir√° a atual sem alterar sua defini√ß√£o. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como implementar essa funcionalidade?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resolver o problema de automa√ß√£o e tomada de decis√£o inteligente, o argumento padr√£o para o modelo se sugere: se a classe atual que est√° sendo criada √© a principal e o par√¢metro do modelo n√£o √© passado para ela, devemos atribuir esse par√¢metro a ele. Isso √© realizado usando o argumento padr√£o. Surgem ent√£o as seguintes perguntas: como escolh√™-lo e como relacion√°-lo √† situa√ß√£o do par√¢metro passado explicitamente, al√©m de se transferir se o par√¢metro n√£o for passado? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infelizmente, voc√™ n√£o pode escrever sua pr√≥pria classe definida como um par√¢metro padr√£o. O compilador simplesmente n√£o perder√° o c√≥digo do formul√°rio:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele relata que uma depend√™ncia de tipo recursivo √© muito complexa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos para o outro lado. </font><font style="vertical-align: inherit;">Vamos apresentar uma classe fict√≠cia que n√£o faz nada funcionalmente e n√£o armazena nada, desempenhando o papel de apenas plugues fict√≠cios e sinalizando ao compilador que, no caso de sua apar√™ncia, nada ser√° transferido "de cima":</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E no argumento padr√£o, substitua essa morda√ßa por n√≥s mesmos:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esta op√ß√£o, na situa√ß√£o com o argumento padr√£o, esta classe √© passada para o WindowClassTemplate. </font><font style="vertical-align: inherit;">A classe thisclass n√£o possui uma fun√ß√£o de membro OnCreate; portanto, essa op√ß√£o simplesmente n√£o √© compilada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos tentar introduzir um segundo par√¢metro de controle auxiliar, com base no qual decidiremos qual tipo passar. </font><font style="vertical-align: inherit;">Para fazer isso, √© claro, voc√™ precisa alterar o WindowClassTemplate, por exemplo, assim:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nenhum tipo √© transmitido a ele, mas dois. Com base na combina√ß√£o desses dois tipos, o tipo final √© determinado usando as ferramentas &lt;type_traits&gt;: std :: conditional_t ‚Äã‚Äãe std :: is_same. √â esse tipo que √© passado para o WindowClassBase. A l√≥gica de sele√ß√£o √© descrita nos coment√°rios: se essa classe for passada para ControlType, selecionaremos DerWndCls, caso contr√°rio, ControlType ser√° selecionado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos criar um modelo que o use ao herdar:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro par√¢metro √© inicializado por padr√£o por meio desta classe e o ControlType √© calculado com base no pr√≥prio DerWndCls: se DerWndCls = thisclass, em seguida ControlType: = thisclass, caso contr√°rio ControlType: = DerWndCls (atribui√ß√£o especificamente especificada no estilo Pascal para diferenciar da compara√ß√£o). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, a pr√≥pria classe WndClsDerivedTemplateClass, parametrizada por DerWndCls, ser√° transmitida junto com o tipo de controle calculado (no est√°gio de compila√ß√£o).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se criarmos um objeto dessa classe, ou seja, o pr√≥prio WndClsDerivedTemplateClass ser√° o topo da hierarquia, DerWndCls = ControlType = thisclass e &lt;WndClsDerivedTemplateClass, thisclass&gt; ser√£o aprovados. O fato de WndClsDerivedTemplateClass ser parametrizado por um manequim n√£o importa - esse tipo, e de fato quaisquer DerWndCls passados ‚Äã‚Äãno local, n√£o s√£o usados ‚Äã‚Äãdentro da classe de forma alguma: nenhum objeto √© criado a partir dele e nenhuma fun√ß√£o √© chamada atrav√©s dele. Portanto, formalmente WndClsDerivedTemplateClass pode ser instanciado literalmente com qualquer coisa - o tipo de par√¢metro serve apenas para passar mais adiante na linha de heran√ßa. Mas aqui, em vez de DerWndCls, WndClsDerivedTemplateClass &lt;thisclass ou qualquer outro tipo&gt; foi passado, √© importante: WndClsDerivedTemplateClass tem uma fun√ß√£o OnCreate,que ser√° chamado dentro de WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com essa op√ß√£o, essa classe chega ao WindowClassControlBaseTemplate no lugar do ControlType e o tipo final √© exibido como DerWndCls = WndClsDerivedTemplateClass, que possui a fun√ß√£o OnCreate. √â disso que precisamos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora considere a op√ß√£o quando uma nova classe for criada com base em WindowClassControlBaseTemplate (heran√ßa adicional):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, em WndClsDerivedTemplateClass, algo diferente desta classe substitui DerWndCls e ControlType, vendo essa diferen√ßa, assume o valor passado para DerWndCls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em WindowClassControlBaseTemplate, a seguinte op√ß√£o de parametriza√ß√£o ser√°: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em WindowClassControlBaseTemplate, por sua vez, desde ControlType! = Thisclass, o ControlType em si √© usado, que √© igual a WindowClassDerivedTemplateNext, que √© a classe correta para selecionar OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä primeira vista, com esse esquema, tudo parece estar bem. Mas isso n√£o √© verdade. Constru√≠mos outra classe com base no √∫ltimo:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em WindowClassDerivedTemplateNext, WindowClassDerivedTemplateNext2 substituir√° DerWndCls. ControlType tamb√©m √© produzido como WindowClassDerivedTemplateNext2. Em seguida, WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">ser√° passado para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e ControlType exibir√° o mesmo WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt; nele. Em seguida, os mesmos valores ser√£o transferidos para WindowClassControlBaseTemplate, e ali, em vez do correto WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt;, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNextTerplateDiveTerplateDiveTlassDimeTextDementer </font><font style="vertical-align: inherit;">√© usado para </font><b><font style="vertical-align: inherit;">chamar a</font></b><font style="vertical-align: inherit;"> fun√ß√£o WindowClass.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembro que, com esse esquema de herdar e passar par√¢metros, o tipo da </font><font style="vertical-align: inherit;">classe em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que veio a WindowClassControlBaseTemplate como resultado, √© importante e n√£o com o que √© parametrizado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, para que o tipo para o qual OnCreate ser√° chamado seja exibido corretamente, √© necess√°rio alterar a defini√ß√£o da classe WindowClassDerivedTemplateNext:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, em WndClsDerivedTemplateClass, o valor correto igual a WindowClassDerivedTemplateNext2 ser√° passado para o ControlType em vez de ser exibido no valor errado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, a √∫ltima classe que estamos construindo n√£o deve passar o ControlType, permitindo que a base mais pr√≥xima a produza independentemente, e essa base e todos os subjacentes devem passar o ControlType explicitamente, proibindo sua sa√≠da autom√°tica para o valor errado. Essa abordagem implica uma </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">altera√ß√£o na</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defini√ß√£o da classe base mais pr√≥xima, o que √© poss√≠vel apenas se tivermos o c√≥digo fonte dispon√≠vel ou se o constru√≠mos antes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se esquecemos de fazer isso e violamos essa regra, ao usar o static_cast, obtemos um erro de compila√ß√£o e, se convertermos ponteiros no estilo C dentro de WindowClassControlBaseTemplate, obtemos um </font><font style="vertical-align: inherit;">programa que funciona </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incorretamente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Por exemplo, se tentarmos criar um objeto para uma classe</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o compilador emitir√° um erro: ele n√£o poder√° converter os tipos de ponteiro dentro de WindowClassControlBaseTemplate devido ao fato de que o tipo estava incorreto e n√£o pode ser convertido para (j√° que vamos criar um objeto da classe WindowClassDerivedTemplateNext, assumimos que a pr√≥pria classe WindowClassDerivedTemplateNext est√° na parte superior hierarquia e, neste caso, como mostrado acima, ControlType n√£o deve ser passado). Sem static_cast, o c√≥digo ser√° compilado e apenas chamar√° OnCreate da classe errada. No entanto, remover a transmiss√£o ControlType torna o programa compilado novamente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, tudo isso √© muito complicado, n√£o confi√°vel e requer o c√≥digo fonte de todas as classes. </font><font style="vertical-align: inherit;">Al√©m disso, s√≥ podemos criar objetos da √∫ltima classe derivada e uma de suas classes base n√£o pode ser criada devido √† transfer√™ncia ControlType (ou podemos, se o ponteiro for passado no estilo C, mas esses objetos ser√£o inicializados incorretamente). </font><font style="vertical-align: inherit;">Precisamos de uma solu√ß√£o diferente, mais simples e mais confi√°vel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modelo vari√°vel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, a variante acima da heran√ßa de modelo e a passagem do tipo do objeto criado para a classe WindowClassBase, onde a janela √© criada e o OnCreate √© chamado, apresentam s√©rias desvantagens. Precisamos de outra op√ß√£o mais confi√°vel e eficiente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O C ++ 11 apresenta um novo tipo de modelo: um modelo com um n√∫mero vari√°vel de argumentos ou um modelo vari√°vel. Seus par√¢metros s√£o uma sequ√™ncia de tipos de comprimento anteriormente desconhecido. Em vez de manipula√ß√µes arriscadas com o tipo de controle no exemplo anterior, decidi seguir o outro caminho: para evitar situa√ß√µes em que a classe intermedi√°ria na hierarquia substitui a classe pai na hierarquia por parametriza√ß√£o incorreta (no exemplo acima, era </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;), geralmente voc√™ pode se livrar desse tipo de parametriza√ß√£o simplesmente colocando essas classes em sequ√™ncia uma ao lado da outra. Por exemplo, com tr√™s heran√ßas sucessivas nos par√¢metros do modelo, a lista a seguir ser√° formada: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Processando esta lista, mais precisamente, um de seus elementos finais (dependendo de como voc√™ a comp√¥s), Voc√™ pode extrair a classe desejada na hierarquia e trabalhar com ela. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, em vez dos modelos WindowClassTemplate e WindowClassControlBaseTemplate descritos anteriormente, que s√£o os mais pr√≥ximos do WindowClassBase raiz e formam a base de todas as outras heran√ßas, voc√™ deve escrever uma nova classe de modelo vari√°vel. Na sua vers√£o mais simples, ser√° assim:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, uma descri√ß√£o geral do modelo de classe sem o corpo √© declarada. Em seguida, √© determinada sua especializa√ß√£o, na qual o primeiro tipo √© separado do resto. √â ele quem nos interessa. Isso ocorre quando cada classe subseq√ºente se coloca </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no final da</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lista de par√¢metros </font><font style="vertical-align: inherit;">ao mover a cadeia de hierarquia para WindowClassBase </font><font style="vertical-align: inherit;">. Ent√£o, a aula de que precisamos estar√° no come√ßo e √© muito simples separ√°-la do resto. Voc√™ pode fazer diferente: cada nova classe se colocar√° </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no in√≠cio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lista de op√ß√µes de modelo. Ent√£o a classe no topo da hierarquia ser√° a √∫ltima da lista, e extra√≠-la a partir da√≠ √© muito mais dif√≠cil. Nesse caso espec√≠fico, essas duas abordagens s√£o completamente id√™nticas, mas a primeira √© muito mais f√°cil de implementar (inclusive durante a compila√ß√£o - voc√™ n√£o precisa processar a lista inteira extraindo o √∫ltimo elemento dela), e √© ele quem √© indicado acima. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro elemento, que √© a classe mais alta da hierarquia, √© recuperado da lista e passado para WindowClassBase. Se OnCreate estiver definido para isso, ele ser√° chamado. Caso contr√°rio, o OnCreate da classe base mais pr√≥xima ser√° chamado em rela√ß√£o a ela. Se a lista de par√¢metros vari√°veis ‚Äã‚Äãestiver vazia (estamos tentando criar um objeto a partir de WindowClassVariadicTemplate), a compila√ß√£o falhar√°, exigindo pelo menos um tipo na lista de par√¢metros.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira classe baseada em WindowClassVariadicTemplate ser√° assim:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa classe, tendo aceitado uma lista indefinida de par√¢metros PrevWndClasses, passa-a para a classe base, inserindo-se na frente dela como o primeiro elemento com uma lista vazia de par√¢metros. </font><font style="vertical-align: inherit;">Como essa classe WindowClassVariadic1 em si √© vari√°vel, WindowClassVariadic1 &lt;&gt; tamb√©m ser√° vari√°vel, embora sem par√¢metros, e toda essa sequ√™ncia de classes seja na verdade um modelo de vari√°vel, cada elemento do qual tamb√©m √© um modelo de vari√°vel. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A seguinte classe derivada √©:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a exce√ß√£o de alterar o nome da derivada e da base, a classe tem exatamente a mesma forma que a anterior. </font><font style="vertical-align: inherit;">A pr√≥xima aula √© semelhante:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse √© o significado da heran√ßa m√∫ltipla polim√≥rfica: ao declarar uma classe dessa maneira, garantimos n√£o apenas a cria√ß√£o de objetos desse tipo, mas tamb√©m todos os objetos de todas as outras classes derivadas dela, n√£o importa quanto e o que quer que seja no futuro. Nesse caso, o OnCreate correto sempre ser√° chamado em WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, esse modelo de vari√°vel √© a primeira maneira de resolver o problema de chamar o OnCreate ao criar uma janela que atenda totalmente a todos os requisitos definidos anteriormente.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Olhando para o futuro, onde finalmente foi encontrado o melhor m√©todo na situa√ß√£o, a implementa√ß√£o da heran√ßa por meio de um modelo de vari√°vel permite implementar uma l√≥gica de compila√ß√£o mais complexa no WindowClassBase: tendo acesso a todos os tipos pelos quais a heran√ßa ocorreu, voc√™ pode escolher entre eles, de maneira flex√≠vel, o necess√°rio ou crit√©rios e chame a fun√ß√£o de membro definida nele. </font><font style="vertical-align: inherit;">Mas esse ainda √© um caso um pouco diferente.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe de inicializa√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sem saber da rea√ß√£o de static_cast a tipos derivados, continuei procurando outras maneiras de implementar a transfer√™ncia da classe de v√©rtice da hierarquia para WindowClassBase. </font><font style="vertical-align: inherit;">Em algum momento, pensei em trazer a implementa√ß√£o OnCreate para uma classe separada, criada especialmente para ela:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa classe parametriza outra classe que implementa todas as outras substitui√ß√µes para fun√ß√µes virtuais. </font><font style="vertical-align: inherit;">√â derivado do WindowClassTemplate j√° descrito:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caminho:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heran√ßa de classe ocorre como de costume para fun√ß√µes virtuais;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">somente a classe de inicializa√ß√£o definida especialmente para a implementa√ß√£o do OnCreate √© transferida de classe para classe ao longo da cadeia de heran√ßa.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se essa classe estiver localizada na parte superior da hierarquia, o par√¢metro WndClsInit se tornar√° igual a WindowClassInit1 - a classe de inicializa√ß√£o definida para essa classe e ser√° transferida ainda mais ao longo da cadeia de hierarquia. Se essa classe for intermedi√°ria na cadeia, ela simplesmente aceitar√° a classe passada para ela e a transmitir√°. Ent√£o, essa op√ß√£o se compara favoravelmente com as anteriores, pois os modelos n√£o se transferem, mas transferem alguma classe de terceiros, que √© implementada (e parece) muito mais f√°cil. Um modelo neste formul√°rio tamb√©m √© adequado, sem altera√ß√µes, para a implementa√ß√£o de toda a cadeia de heran√ßa: somente a altera√ß√£o dos nomes das classes ocorrer√°.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, static_cast, diferentemente da convers√£o no estilo C, dentro do WindowClassTemplate n√£o perder√° essa forma de heran√ßa: ele simplesmente n√£o pode ser convertido ao passar isso de (WindowClassTemplate *) para (WindowClassInit1 *). </font><font style="vertical-align: inherit;">E isso √© l√≥gico: WindowClassInit1 √© na verdade uma classe estranha, passada apenas como um tipo para este ponto, n√£o est√° conectado de forma alguma com WindowClassTemplate e toda a cadeia de derivadas, portanto a convers√£o de ponteiro para ela √© inaceit√°vel.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tipo de classe derivada encadeada em WindowClassBase, transfer√™ncia condicional</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, finalmente, foi encontrada a melhor maneira para essa situa√ß√£o transferir o tipo da classe derivada para o WindowClassBase base raiz por toda a cadeia de heran√ßa, desprovida das desvantagens das anteriores e, ao mesmo tempo, mais simples que o modelo de vari√°vel. </font><font style="vertical-align: inherit;">Defina a seguinte classe de modelo com base em WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa classe aceita DerWndCls como um par√¢metro, que por padr√£o √© igual a esta classe. </font><font style="vertical-align: inherit;">Durante a transfer√™ncia, DerWndCls √© comparado com esta classe: em caso de igualdade (o valor padr√£o, ou seja, a classe especificada est√° no topo da hierarquia), ela se passa com uma lista vazia de par√¢metros. </font><font style="vertical-align: inherit;">Caso contr√°rio, os DerWndCls recebidos ser√£o transmitidos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considero que esta solu√ß√£o √© a melhor nesta situa√ß√£o em todos os aspectos:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma √∫nica forma de defini√ß√£o de classe para toda a cadeia de heran√ßa;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l√≥gica simples e transparente de transfer√™ncia de classe ao longo de toda a cadeia de heran√ßa;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nenhuma sobrecarga devido ao modelo de vari√°vel (nesses casos, como nesse caso, quando isso n√£o for necess√°rio).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terr√≠vel retribui√ß√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que tudo isso significa? </font><font style="vertical-align: inherit;">Isso significa que, se voc√™ deseja usar uma forma de heran√ßa n√£o convencional, deve formalizar todas as suas classes de uma maneira estritamente definida, para que elas permitam a transfer√™ncia por si mesmo de um poss√≠vel novo derivado. </font><font style="vertical-align: inherit;">Este √© um requisito muito f√°cil e, se desejar, √© f√°cil de seguir. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas h√° outra quest√£o, muito mais n√£o trivial: a rela√ß√£o entre tipos e ponteiros. </font><font style="vertical-align: inherit;">Pessoas inteligentes escreveram: n√£o brinque com essas coisas no construtor e v√° contra os princ√≠pios da linguagem e a l√≥gica do compilador. </font><font style="vertical-align: inherit;">Mas eu n√£o obedeci e fiz de qualquer maneira. </font><font style="vertical-align: inherit;">Agora vem a retribui√ß√£o natural. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, n√≥s temos 4 classes:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como escrevi acima, seu conte√∫do espec√≠fico e l√≥gica de trabalho s√£o completamente sem import√¢ncia. </font><font style="vertical-align: inherit;">A √∫nica coisa importante √© que no t√≠tulo da defini√ß√£o de classe. </font><font style="vertical-align: inherit;">Com base nessas classes, criamos 4 objetos:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expandimos as defini√ß√µes de seus tipos ocultos entre colchetes vazios usando os argumentos padr√£o. O tipo w1 √© WindowClassDerivedAlternative1. O tipo w2 √© WindowClassDerivedAlternative2 e sua classe base √© WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. O tipo w3 √© WindowClassDerivedAlternative3, sua classe base √© WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt; e sua classe base √© WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. Da mesma forma, para o quarto objeto. Veja o diagrama a seguir:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao criar cada nova classe derivada com base em uma determinada classe base definida desta maneira, voc√™ define n√£o apenas uma nova classe, mas ao mesmo tempo toda a cadeia de sua base novamente. Ser√° paralelo √† cadeia de sua pr√≥pria classe base. Sua classe ter√° suas pr√≥prias classes base e nenhuma delas poder√° levar a nenhuma das classes base originais, apesar do fato de o c√≥digo de gera√ß√£o para todas essas classes ser o mesmo! Parece fantasia real, mas realmente √©! Isso significa que todas as formas usuais de manipular classes e ponteiros herdados n√£o funcionar√£o! Nessa arquitetura espec√≠fica, apenas o WindowClassBase base salva a situa√ß√£o; caso contr√°rio, tamb√©m seria imposs√≠vel criar uma matriz a partir das classes base (por exemplo, com base no WindowClassTemplate),porque todas essas classes t√™m tipos diferentes.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, a defini√ß√£o bem conhecida e compreens√≠vel da forma:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... parar√° de compilar porque voc√™ est√° tentando criar um ponteiro de tipo incompat√≠vel com o tipo do objeto w2, apesar de meia hora atr√°s voc√™ mesmo ter escrito uma classe derivada da classe WindowClassDerivedAlternative1 &lt;&gt; e com base na qual o objeto w2 foi criado.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando as leis habituais param de funcionar, podem causar choque. </font><font style="vertical-align: inherit;">E com tudo isso, na verdade n√£o h√° hacks sujos de compilador, convers√µes de tipo for√ßadas e outras coisas realmente ruins. </font><font style="vertical-align: inherit;">Tudo √© extremamente limpo e legal: modelos, par√¢metros padr√£o e ferramentas da biblioteca de tipos. </font><font style="vertical-align: inherit;">Somente m√©todos familiares de escrita de c√≥digo param de funcionar. </font><font style="vertical-align: inherit;">Usar isso em um projeto real significa declarar uma zona de perigo, que s√≥ pode ser inserida por pessoal especializado qualificado com medidas de prote√ß√£o apropriadas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Experi√™ncias de c√≥digo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para facilitar a todos os interessados ‚Äã‚Äãem experimentar e economizar tempo com a digita√ß√£o, publiquei no GitHub todos os projetos que serviram de base para este artigo: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Basta escolher um projeto por vez como o inicial, caso contr√°rio, voc√™ se afogar√° em um mar de janelas coloridas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclus√£o</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúSe tudo isso √© uma piada, ent√£o, dados os esfor√ßos despendidos, parece muito s√©rio e natural. </font><font style="vertical-align: inherit;">E se n√£o for uma piada, nenhum desenvolvedor normal, em s√£ consci√™ncia, realmente usar√° algo assim. </font><font style="vertical-align: inherit;">E, de qualquer maneira, cara, voc√™ n√£o acabaria sofrendo bobagens e n√£o faria algo </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que traz dinheiro, √©</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫til. ‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ est√° certo, se voc√™ pensa assim. </font><font style="vertical-align: inherit;">Neste artigo, eu apenas mostrei que o C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A quest√£o da aplica√ß√£o pr√°tica dessas estruturas permanece em aberto. E, em geral, √© mais prov√°vel que isso se aplique √† generaliza√ß√£o e metaprograma√ß√£o. Talvez voc√™ n√£o precise criar nenhum objeto dessas classes, mas as pr√≥prias classes podem ser necess√°rias por algum motivo. Sim, e voc√™ nunca sabe quais solu√ß√µes √∫teis voc√™ pode encontrar com base nisso ... O CRTP original √© usado! E nem √© usado em lugar algum, mas na biblioteca padr√£o! Quem n√£o acredita ou n√£o se lembra, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voltando √† tarefa original com janelas ... Especialmente agora, sobriamente </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e sem grama,</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> olhando para tr√°s tudo isso tr√™s anos depois ... Mesmo que descartemos o fato de eu ter tocado em um t√≥pico banal que j√° foi percorrido um milh√£o de vezes, e isso h√° muito tempo n√£o interessa a ningu√©m, porque de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verdade Rapazes</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pessoas normais t√™m </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, eu apenas garantiria que algum objeto funcional fosse passado para a classe window. </font><font style="vertical-align: inherit;">N√£o √© dif√≠cil garantir sua transfer√™ncia atrav√©s da cadeia de heran√ßa, mas ele far√° tudo de forma simples, clara e sem distor√ß√£o, e voc√™ obter√° uma classe previs√≠vel completamente normal, sem quaisquer efeitos colaterais, que voc√™ pode acompanhar e desenvolver para dar a absolutamente qualquer pessoa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O que aconteceu neste artigo √© apenas uma tarefa n√£o trivial interessante, que eu ainda consegui resolver. </font><font style="vertical-align: inherit;">Espero que isso tenha sido interessante para voc√™ tamb√©m.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt507114/index.html">Ode Excel: 34 Anos de Magia</a></li>
<li><a href="../pt507116/index.html">"Udalenka". Notas do desenvolvedor do escrit√≥rio de ontem. Parte 2</a></li>
<li><a href="../pt507124/index.html">O APO n√£o √© apenas pele valiosa</a></li>
<li><a href="../pt507132/index.html">Vladimir Kitov: "√â imposs√≠vel entender como os cientistas pioneiros previram a informatiza√ß√£o universal nos anos 50!"</a></li>
<li><a href="../pt507138/index.html">Geologia do s√©culo XXI como ci√™ncia de dados da Terra</a></li>
<li><a href="../pt507148/index.html">Envie links m√°gicos usando o Node.js</a></li>
<li><a href="../pt507150/index.html">Desenhamos uma imagem de interfer√™ncia em JavaScript</a></li>
<li><a href="../zh-CN486176/index.html">‰ºÅ‰∏öÁîµÂ≠êÈÇÆ‰ª∂ÈÄöËÆØÂ§áÂøòÂΩï</a></li>
<li><a href="../zh-CN486178/index.html">FOSSÊñ∞Èóª1-2020Âπ¥1Êúà27Êó•Ëá≥2Êúà2Êó•ÂÖçË¥πÂíåÂºÄÊ∫êÊñ∞ÈóªÁöÑÂõûÈ°æ</a></li>
<li><a href="../zh-CN486180/index.html">ÂàõÂª∫Êó†ÊúçÂä°Âô®Â∫îÁî®Á®ãÂ∫èÁöÑÊèêÁ§∫ÂíåËµÑÊ∫ê</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>