<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍀 🧛🏽 🏉 JVM TI：仮想マシンのプラグインを作成する方法 🤺 ♍️ 👦🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JVMにいくつかの便利な機能を追加しますか？理論的には、すべての開発者がOpenJDKに貢献できますが、実際には、HotSpotへの重要な変更はあまり歓迎されません。現在のリリースサイクルが短くても、JDKユーザーに機能が表示されるまでに数年かかる場合があります。
 
 それにもかかわらず、場合によ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JVM TI：仮想マシンのプラグインを作成する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/458812/"><img src="https://habrastorage.org/webt/dk/iw/hm/dkiwhmwayxse8--tbyxqszp0xeg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVMにいくつかの便利な機能を追加しますか？理論的には、すべての開発者がOpenJDKに貢献できますが、実際には、HotSpotへの重要な変更はあまり歓迎されません。現在のリリースサイクルが短くても、JDKユーザーに機能が表示されるまでに数年かかる場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、場合によっては、コードに手を加えることなく仮想マシンの機能を拡張することが可能です。 JVMと対話するための標準APIであるJVMツールインターフェースが役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、それを使って何ができるかを具体例で示し、Java 9および11で何が変更されたかを説明し、困難について正直に警告します（ネタバレ：C ++を扱わなければなりません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この資料はJPointでも共有しました。あなたがビデオを好めば、あなたは見ることができます</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポート。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が一流のエンジニアとして働いているソーシャルネットワークOdnoklassnikiは、ほぼすべてJavaで作成されています。</font><font style="vertical-align: inherit;">しかし、今日は、Javaだけではない別の部分についてお話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存知のように、Java開発者に最もよくある問題はNullPointerExceptionです。</font><font style="vertical-align: inherit;">かつて、ポータルでの勤務中にNPEに出会いました。</font><font style="vertical-align: inherit;">エラーには、次のスタック</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/lb/4t/j6lb4tmh3wmmti8tebobo7znwsu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレースの</font><font style="vertical-align: inherit;">ようなものが付随しました。</font><font style="vertical-align: inherit;">もちろん、スタックトレースを使用すると、例外が発生した場所をコードの特定の行までトレースできます。</font><font style="vertical-align: inherit;">この場合にのみ、NPEが次のような多くの場所で対応できるため、気分が良くなりませんでし</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xt/kt/pq/xtktpq4cozo4xvjvllvgtk9cibe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
た。JVMがこのエラーの正確な場所を、たとえば次のように提案した場合、それは素晴らしいことです。</font></font><br>
<code>java.lang.NullPointerException: Called 'getUsers()' method on null object</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、残念ながら、NPEには現在そのようなものは含まれていません。彼らは長い間これを求めてきましたが、少なくともJava 1.4に関しては：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このバグ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は16年前のものです。定期的に、このトピックに関してより多くのバグが開かれましたが、それらは常に「修正されない」として閉じられました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5l/tc/xg/5ltcxgloqnkiiudcadczatl6_ne.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはどこでも起こりません。 SAPのVolker Simonisは、</font><font style="vertical-align: inherit;">この機能をSAP JVMに長い間実装していて、それを2回以上支援してきたと</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">語り</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました。別のSAPの従業員が再び</font><font style="vertical-align: inherit;">OpenJDKのバグを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提出</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、SAP JVMにあるものと同様のメカニズムを実装するよう志願しました。そして、驚いたことに、今回はバグはクローズされませんでした-この機能がJDK 14に入る可能性はあり</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ますか？しかし、いつJDK 14が</font><font style="vertical-align: inherit;">再び</font><font style="vertical-align: inherit;">登場し、いつ切り替えますか？ここで問題を調査したい場合はどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、OpenJDKのフォークを維持することもできます。 NPEレポート機能自体はそれほど複雑ではないので、実装することもできます。しかし同時に、あなた自身のアセンブリをサポートすることのすべての問題があります。この機能を一度実装し、それをプラグインとして任意のバージョンのJVMにプラグインするのは素晴らしいことです。そして、これは本当に可能です！ JVMには特別なAPI（元々はすべての種類のデバッガーとプロファイラー用に開発された）があります：JVMツールインターフェイス。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も重要なのは、このAPIが標準であることです。彼には厳密な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様があり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それに従って機能を実装すると、新しいバージョンのJVMで機能することが確実になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このインターフェースを使用するには、小さな（またはタスクによっては大きな）プログラムを作成する必要があります。</font><font style="vertical-align: inherit;">ネイティブ：通常、CまたはC ++で記述されます。</font><font style="vertical-align: inherit;">標準JDKには、インクルードするヘッダーファイルが付属して</font></font><code>jdk/include/jvmti.h</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムは動的ライブラリーにコンパイルされ</font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、JVMの開始時に</font><font style="vertical-align: inherit;">パラメーターによって接続されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他の同様のパラメータと混同しないようにすることが重要です</font></font><code>-javaagent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、JavaエージェントはJVM TIエージェントの特殊なケースです。</font><font style="vertical-align: inherit;">さらに、「エージェント」という単語の下のテキストでは、正確にネイティブエージェントを意味します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこから始めるか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に、「Hello World」の一種である最も単純なJVM TIエージェントの作成方法を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jvmti.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Agent_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">char</span>* options, <span class="hljs-keyword">void</span>* reserved)</span> </span>{<font></font>
    jvmtiEnv* jvmti;<font></font>
    vm-&gt;GetEnv((<span class="hljs-keyword">void</span>**) &amp;jvmti, JVMTI_VERSION_1_0);<font></font>
<font></font>
    <span class="hljs-keyword">char</span>* vm_name = <span class="hljs-literal">NULL</span>;<font></font>
    jvmti-&gt;GetSystemProperty(<span class="hljs-string">"java.vm.name"</span>, &amp;vm_name);<font></font>
<font></font>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Agent loaded. JVM name = %s\n"</span>, vm_name);<font></font>
    fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の行には同じヘッダーファイルを含めています。</font><font style="vertical-align: inherit;">次に、エージェントに実装する必要がある主な機能があります</font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">仮想マシン自体は、エージェントの起動時にそれを呼び出し、オブジェクトへのポインターを渡します</font></font><code>JavaVM*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを使用すると、TIの環境であるJVMへのポインターを取得できます</font></font><code>jvmtiEnv*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、それを通じて、今度はすでにJVM TI関数を呼び出しています。</font><font style="vertical-align: inherit;">たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetSystemProperty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">、システムプロパティの値を読み取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この「hello world」を実行して</font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイル済みのdllファイル</font><font style="vertical-align: inherit;">に渡すと</font><font style="vertical-align: inherit;">、Javaプログラムが実行を開始する前でも、エージェントによって出力された行がコンソールに表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/cq/eu/rlcqeul7gpb8mahabl0ehgckro8.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NPEの濃縮</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hello Worldは最も興味深い例ではないので、例外に戻りましょう。</font><font style="vertical-align: inherit;">NPEレポートを補完する完全なエージェントコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">発生したすべての例外を通知するよう仮想マシンに依頼したい場合は</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、次のよう</font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">になります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Agent_OnLoad</span><span class="hljs-params">(JavaVM* vm, <span class="hljs-keyword">char</span>* options, <span class="hljs-keyword">void</span>* reserved)</span> </span>{<font></font>
    jvmtiEnv* jvmti;<font></font>
    vm-&gt;GetEnv((<span class="hljs-keyword">void</span>**) &amp;jvmti, JVMTI_VERSION_1_0);<font></font>
<font></font>
    jvmtiCapabilities capabilities = {<span class="hljs-number">0</span>};<font></font>
    capabilities.can_generate_exception_events = <span class="hljs-number">1</span>;<font></font>
    jvmti-&gt;AddCapabilities(&amp;capabilities);<font></font>
<font></font>
    jvmtiEventCallbacks callbacks = {<span class="hljs-number">0</span>};<font></font>
    callbacks.Exception = ExceptionCallback;<font></font>
    jvmti-&gt;SetEventCallbacks(&amp;callbacks, <span class="hljs-keyword">sizeof</span>(callbacks));<font></font>
    jvmti-&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, <span class="hljs-literal">NULL</span>);<font></font>
   <font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、JVM TIに対応する機能（can_generate_exception_events）を要求します。</font><font style="vertical-align: inherit;">機能については個別に説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、例外イベントのサブスクライブです。</font><font style="vertical-align: inherit;">JVMが例外をスローするたびに（キャッチされたかどうかに関係なく）、関数が呼び出され</font></font><code>ExceptionCallback()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、</font></font><code>SetEventNotificationMode()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通知の配信を有効にするための</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionCallbackでは、JVMは例外の処理に必要なすべてを渡します。</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">ExceptionCallback</span><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, jthread thread,
                               jmethodID method, jlocation location,
                               jobject exception,
                               jmethodID catch_method, jlocation catch_location)</span> </span>{<font></font>
    jclass NullPointerException = env-&gt;FindClass(<span class="hljs-string">"java/lang/NullPointerException"</span>);
    <span class="hljs-keyword">if</span> (!env-&gt;IsInstanceOf(exception, NullPointerException)) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    jclass Throwable = env-&gt;FindClass(<span class="hljs-string">"java/lang/Throwable"</span>);<font></font>
    jfieldID detailMessage = env-&gt;GetFieldID(Throwable, <span class="hljs-string">"detailMessage"</span>, <span class="hljs-string">"Ljava/lang/String;"</span>);
    <span class="hljs-keyword">if</span> (env-&gt;GetObjectField(exception, detailMessage) != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">32</span>];
    <span class="hljs-built_in">sprintf</span>(buf, <span class="hljs-string">"at location %id"</span>, (<span class="hljs-keyword">int</span>) location);<font></font>
<font></font>
    env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf));<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここには、例外をスローしたスレッドのオブジェクト（スレッド）、これが発生した場所（メソッド、場所）、例外のオブジェクト（例外）、さらにこの例外をキャッチするコード内の場所（catch_method、catch_location）があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なこと：このコールバックでは、JVM TI環境へのポインターに加えて、JNI環境（env）も渡されます。つまり、その中ですべてのJNI関数を使用できます。つまり、JVM TIとJNIは完全に共存し、互いに補完し合います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のエージェントでは、両方を使用しています。特に、JNIを使​​用して、例外がtype </font></font><code>NullPointerException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">である</font><font style="vertical-align: inherit;">ことを確認し</font><font style="vertical-align: inherit;">、フィールド</font></font><code>detailMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をエラーメッセージ</font><font style="vertical-align: inherit;">に置き換え</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM自体がロケーション（例外が発生したバイトコードインデックス）を渡すので、メッセージのこの場所をここに配置します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ix/h8/pc/ixh8pcrtxcg4rcdwwlg83_gfuam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
番号66は、この例外が発生したバイトコードのインデックスを意味します。</font><font style="vertical-align: inherit;">しかし、手動でバイトコードを分析するのは面倒です。クラスファイルを逆コンパイルし、66番目の命令を探して、それが何をしているかを理解する必要があります...エージェント自身がより人間が読めるものを示すことができればすばらしいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、JVM TIには、この場合にも必要なものがすべて揃っています。</font><font style="vertical-align: inherit;">確かに、JVM TIの追加機能を要求する必要があります。バイトコードと定数プールメソッドを取得します。</font></font><br>
<br>
<pre><code class="cpp hljs">jvmtiCapabilities capabilities = {<span class="hljs-number">0</span>};<font></font>
capabilities.can_generate_exception_events = <span class="hljs-number">1</span>;<font></font>
capabilities.can_get_bytecodes = <span class="hljs-number">1</span>;<font></font>
capabilities.can_get_constant_pool = <span class="hljs-number">1</span>;<font></font>
jvmti-&gt;AddCapabilities(&amp;capabilities);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ExceptionCallbackを拡張します。JVMTI関数</font></font><code>GetBytecodes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">介して</font><font style="vertical-align: inherit;">、メソッドの本体を取得し、ロケーションインデックスによってその中身を確認します。</font><font style="vertical-align: inherit;">次に、大きなスイッチバイトコード命令が続きます。これが配列へのアクセスの場合、1つのエラーメッセージが表示され、フィールドへのアクセスが別のメッセージの場合、メソッド呼び出しが3番目の場合などになります。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionCallbackコード</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">jint bytecode_count;<font></font>
u1* bytecodes;<font></font>
<span class="hljs-keyword">if</span> (jvmti-&gt;GetBytecodes(method, &amp;bytecode_count, &amp;bytecodes) != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">if</span> (location &gt;= <span class="hljs-number">0</span> &amp;&amp; location &lt; bytecode_count) {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* message = get_exception_message(bytecodes[location]);
    <span class="hljs-keyword">if</span> (message != <span class="hljs-literal">NULL</span>) {<font></font>
        ...<font></font>
        env-&gt;SetObjectField(exception, detailMessage, env-&gt;NewStringUTF(buf));<font></font>
    }<font></font>
}<font></font>
<font></font>
jvmti-&gt;Deallocate(bytecodes);<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フィールドまたはメソッドの名前を置き換えるだけです。</font><font style="vertical-align: inherit;">これは、JVM TIのおかげで再び利用できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数プール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取得できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (jvmti-&gt;GetConstantPool(holder, &amp;cpool_count, &amp;cpool_bytes, &amp;cpool) != <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> strdup(<span class="hljs-string">"&lt;unknown&gt;"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次は少し魔法ですが、実際には注意が必要なことは何もありません。</font><font style="vertical-align: inherit;">クラスファイル形式の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に従って</font><font style="vertical-align: inherit;">、定数プールを分析し、そこから行（メソッドの名前）を分離します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数プール分析</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs">u1* ref = get_cpool_at(cpool, get_u2(bytecodes + <span class="hljs-number">1</span>));       <span class="hljs-comment">// CONSTANT_Fieldref</span>
u1* name_and_type = get_cpool_at(cpool, get_u2(ref + <span class="hljs-number">3</span>));   <span class="hljs-comment">// CONSTANT_NameAndType</span>
u1* name = get_cpool_at(cpool, get_u2(name_and_type + <span class="hljs-number">1</span>));  <span class="hljs-comment">// CONSTANT_Utf8</span><font></font>
<font></font>
<span class="hljs-keyword">size_t</span> name_length = get_u2(name + <span class="hljs-number">1</span>);
<span class="hljs-keyword">char</span>* result = (<span class="hljs-keyword">char</span>*) <span class="hljs-built_in">malloc</span>(name_length + <span class="hljs-number">1</span>);
<span class="hljs-built_in">memcpy</span>(result, name + <span class="hljs-number">3</span>, name_length);<font></font>
result[name_length] = <span class="hljs-number">0</span>;
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の重要な点：一部のJVM TI関数（たとえば、</font></font><code>GetConstantPool()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><code>GetBytecodes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）は、ネイティブメモリに特定の構造を割り当てます。これは、処理が完了すると解放される必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">jvmti-&gt;Deallocate(cpool);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
拡張エージェントを使用してソースプログラムを開始しましょう。例外の説明は完全に異なります。これは、nullオブジェクトでlongValue（）メソッドを呼び出したことを報告しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8d/ge/-d/8dge-d_mtmqpdesbk6vm4nwolna.png"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他の用途</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に言えば、開発者は多くの場合、独自の方法で例外を処理したいと考えています。たとえば、JVMが再起動する場合は、自動的に再起動し</font></font><code>StackOverflowError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この願望</font></font><code>StackOverflowError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、それと同じ致命的なエラー</font><font style="vertical-align: inherit;">であるため</font></font><code>OutOfMemoryError</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、発生すると、プログラムの正常な動作を保証できなくなります。または、たとえば、問題を分析するために、例外が発生したときにスレッドダンプまたはヒープダンプを受け取りたい場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hh/8b/zy/hh8bzys2bji12vte4g_fsmlfaky.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
公平に言えば、IBM JDKにはそのような機会がすぐに利用できます。しかし、JVM TIエージェントを使用すると、HotSpotに同じものを実装できることがわかっています。例外コールバックにサブスクライブして例外を分析するだけで十分です。しかし、エージェントからスレッドダンプまたはヒープダンプを削除する方法は？ JVM TIには、この場合に必要なものがすべて揃っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yp/jj/5o/ypjj5o9xn9m7tmhdzmh-z8bo2tk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヒープをバイパスしてダンプを作成するメカニズム全体を実装するのはあまり便利ではありません。しかし、私はそれを簡単かつ迅速にする方法の秘密を共有します。確かに、これは標準のJVM TIには含まれていませんが、Hotspotのプライベート拡張です。</font><font style="vertical-align: inherit;">HotSpotソースから</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘッダーファイル</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jmm.h</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を接続し</font><font style="vertical-align: inherit;">、関数を呼び出す必要があります</font></font><code>JVM_GetManagement()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"jmm.h"</span></span><font></font>
<font></font>
<span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span>* JNICALL <span class="hljs-title">JVM_GetManagement</span><span class="hljs-params">(jint version)</span></span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">ExceptionCallback</span><span class="hljs-params">(jvmtiEnv* jvmti, JNIEnv* env, ...)</span> </span>{<font></font>
    JmmInterface* jmm = (JmmInterface*) JVM_GetManagement(JMM_VERSION_1_0);<font></font>
    jmm-&gt;DumpHeap0(env, env-&gt;NewStringUTF(<span class="hljs-string">"dump.hprof"</span>), JNI_FALSE);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HotSpot管理インターフェイスへのポインタを返します。1回の呼び出しでヒープダンプまたはスレッドダンプが生成されます。例の完全なコードは、</font><font style="vertical-align: inherit;">Stack Overflow </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に対する私の回答</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、例外だけでなく、JVM操作に関連するその他のさまざまなイベント（スレッドの開始/停止、クラスのロード、ガベージコレクション、メソッドのコンパイル、メソッドの開始/終了、Javaオブジェクトの特定のフィールドへのアクセスや変更など）も処理できます。</font><font style="vertical-align: inherit;">多くの標準JVM TIイベントをサブスクライブしてログに記録する</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vmtrace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エージェントの例が</font><font style="vertical-align: inherit;">あります。このエージェントを使用して単純なプログラムを実行すると、詳細なログが表示されます。完了した場合、タイムスタンプが記録されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wu/he/ci/wuhecifrgrrkleshnnkqx6hd9ew.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、単にhello worldを出力するために、何百ものクラスがロードされ、何十、何百ものメソッドが生成されてコンパイルされています。</font><font style="vertical-align: inherit;">Javaの実行に長い時間がかかる理由が明らかになります。</font><font style="vertical-align: inherit;">すべてについてのすべてが200ミリ秒以上かかった。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVM TIができること</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの処理に加えて、JVM TIには他にも多くの機能があります。それらは2つのグループに分けることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つは必須であり、JVM TIをサポートするすべてのJVMが実装する必要があります。これらには、メソッド、フィールド、スレッドの分析操作、クラスパスに新しいクラスを追加する機能などが含まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予備的な機能要求を必要とするオプション機能があります。 JVMはそれらすべてをサポートする必要はありませんが、HotSpotは仕様全体を完全に実装します。オプション機能は2つのサブグループに分かれています。JVMの開始時にのみ接続できる機能（たとえば、ブレークポイントを設定したり、ローカル変数を分析したりする機能）と、いつでも接続できる機能（特に、バイトコードや定数プールなど）です。上記で使用）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/9e/oo/ee9eooqcrrdowlrc1rvqmfuhjs0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能のリストがデバッガの機能に非常に似ていることに気付くでしょう。実際、Javaデバッガーは、JVM TIエージェントの特別な場合にすぎません。JVMTIエージェントは、これらすべての機能を利用し、すべての機能を要求します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつでも有効にできる機能と、起動時にのみ有効な機能への機能の分離は、意図的に行われます。すべての機能が無料であるわけではなく、オーバーヘッドが伴うものもあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能の使用に伴う直接的なオーバーヘッドですべてが明らかである場合、機能を使用しなくても表示される間接的なオーバーヘッドはさらに少なくなりますが、単に機能を通じて、将来的に必要になることを宣言します。これは、仮想マシンがコードを異なる方法でコンパイルしたり、ランタイムにチェックを追加したりできるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、例外をサブスクライブするためにすでに検討されている機能（can_generate_exception_events）は、スローするすべての例外の処理が遅いという事実につながります。優れたJavaプログラムでは例外はまれであるため、原則としてこれはそれほど怖いものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ローカル変数の状況は少し悪いです。いつでもローカル変数の値を取得できるcan_access_local_variablesの場合、いくつかの重要な最適化を無効にする必要があります。特に、Escape Analysisは完全に機能を停止し、具体的なオーバーヘッドが発生する可能性があります（アプリケーションによっては5〜10％）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、結論：デバッグエージェントをオンにしてJavaを実行すると、それを使用しなくても、アプリケーションの実行速度が低下します。とにかく、本番環境にデバッグエージェントを含めることはお勧めできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ブレークポイントを設定したり、メソッドからのすべての入力/出力をトレースしたりするなど、多くの機能には、はるかに深刻なオーバーヘッドがあります。</font><font style="vertical-align: inherit;">特に、一部のJVM TIイベント（FieldAccess、MethodEntry / Exit）はインタープリターでのみ機能します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのエージェントが良い、2つがより良い</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のパラメータを指定するだけで、複数のエージェントを単一のプロセスに接続できます</font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。誰もが独自のJVM TI環境を持っています。つまり、誰もが自分の機能をサブスクライブし、イベントを個別に傍受できるということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、2つのエージェントがBreakpointイベントにサブスクライブし、1つのメソッドにブレークポイントが設定されている場合、このメソッドが実行されると、2番目のエージェントがイベントを受信しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、このような状況は発生しません（少なくともHotSpot JVMでは）。なぜなら、常に1つのエージェントだけが持つことができるいくつかの機能があるからです。これらには、特にbreakpoint_eventsが含まれます。したがって、2番目のエージェントが同じ機能を要求すると、応答としてエラーを受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは重要な結論です。HotSpotで実行していて、すべての機能が利用可能であることを知っている場合でも、エージェントでは機能要求の結果を常に確認する価値があります。</font><font style="vertical-align: inherit;">JVM TI仕様は排他的な機能については何も述べていませんが、HotSpotにはこの実装機能があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、エージェントの分離は常に完全に機能するとは限りません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-profilerの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発中に、</font><font style="vertical-align: inherit;">この問題に遭遇しました。2つのエージェントがあり、1つがメソッドコンパイルイベントの生成を要求すると、すべてのエージェントがこれらのイベントを受け取ります。</font><font style="vertical-align: inherit;">もちろん、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグを報告し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ましたが、エージェントで予期しないイベントが発生する可能性があることを覚えておいてください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常のプログラムでの使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TIは、デバッガーやプロファイラーにとっては非常に特殊なもののように思えるかもしれませんが、通常のJavaプログラムで使用することもできます。</font><font style="vertical-align: inherit;">例を考えてみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非同期である場合、リアクティブプログラミングパラダイムは広く普及していますが、このパラダイムには問題があります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskRunner</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">good</span><span class="hljs-params">()</span> </span>{<font></font>
        CompletableFuture.runAsync(<span class="hljs-keyword">new</span> AsyncTask(GOOD));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bad</span><span class="hljs-params">()</span> </span>{<font></font>
        CompletableFuture.runAsync(<span class="hljs-keyword">new</span> AsyncTask(BAD));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>{<font></font>
        good();<font></font>
        bad();<font></font>
        Thread.sleep(<span class="hljs-number">200</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメーターのみが異なる2つの非同期タスクを実行します。</font><font style="vertical-align: inherit;">そして、何か問題が発生した場合、例外が発生</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ds/me/wx/dsmewxe5rd4lzgq8fgjxn42zh0e.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
します。スタックトレースから、これらのタスクのどれが問題の原因であるかは完全に不明です。</font><font style="vertical-align: inherit;">例外は完全に異なるスレッドで発生するため、コンテキストはありません。</font><font style="vertical-align: inherit;">どのタスクを理解するには？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションの1つとして、非同期タスクのコンストラクターに、それを作成した場所に関する情報を追加できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AsyncTask</span><span class="hljs-params">(String arg)</span> </span>{
    <span class="hljs-keyword">this</span>.arg = arg;
    <span class="hljs-keyword">this</span>.location = getLocation();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、場所を覚えておいてください。コード内の特定の場所で、コンストラクターが呼び出されたところの行までです。</font><font style="vertical-align: inherit;">そして、それを誓約する例外の場合：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">int</span> n = Integer.parseInt(arg);<font></font>
} <span class="hljs-keyword">catch</span> (Throwable e) {<font></font>
    System.err.println(<span class="hljs-string">"ParseTask failed at "</span> + location);<font></font>
    e.printStackTrace();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、例外が発生すると、これがTaskRunnerの14行目（BADパラメーターを持つタスクが作成さ</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v-/tq/0q/v-tq0qa-bnlkakz8dnzxhrjfqvo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
れる場所）で発生したことがわかります。ただし、コンストラクターが呼び出されるコード内の場所を取得する方法は？</font><font style="vertical-align: inherit;">Java 9より前は、これを行う唯一の正当な方法がありました。スタックトレースを取得し、いくつかの無関係なフレームをスキップし、スタックの少し下がコードが呼び出した場所になります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">String <span class="hljs-title">getLocation</span><span class="hljs-params">()</span> </span>{<font></font>
    StackTraceElement caller = Thread.currentThread().getStackTrace()[<span class="hljs-number">3</span>]; 
    <span class="hljs-keyword">return</span> caller.getFileName() + <span class="hljs-string">':'</span> + caller.getLineNumber();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし問題がある。 StackTrace全体を取得するのはかなり時間がかかります。私はこれに専念する全体の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持ってい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが珍しいのであれば、これはそれほど大きな問題ではないでしょう。しかし、たとえば、HTTPリクエストを受け入れるフロントエンドのWebサービスがあります。これは素晴らしいアプリケーションで、数百万行のコードです。そして、レンダリングエラーをキャッチするために、同様のメカニズムを使用します。レンダリング用のコンポーネントでは、それらが作成された場所を覚えています。このようなコンポーネントは数百万あるので、すべてのスタックトレースを取得するには、アプリケーションの起動に1分ではなく具体的​​な時間がかかります。したがって、問題の分析には本番環境で必要ですが、この機能は以前は本番環境では無効にされていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 9は、ストリームスタックをバイパスする新しい方法を導入しました。StackWalkerは、Stream APIを介して、これらすべてをオンデマンドで遅延して実行できます。</font><font style="vertical-align: inherit;">つまり、必要な数のフレームをスキップして、興味のあるフレームを1つだけ取得できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">String <span class="hljs-title">getLocation</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> StackWalker.getInstance().walk(s -&gt; {<font></font>
        StackWalker.StackFrame frame = s.skip(<span class="hljs-number">3</span>).findFirst().get();
        <span class="hljs-keyword">return</span> frame.getFileName() + <span class="hljs-string">':'</span> + frame.getLineNumber(); <font></font>
     });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なスタックトレースを取得するよりも少しはうまくいきますが、1桁も何回もうまくいきません。</font><font style="vertical-align: inherit;">私たちのケースでは、約1.5倍高速であることが判明しました</font><font style="vertical-align: inherit;">。StackWalkerの非最適な実装に関連</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v8/bz/rk/v8bzrkf8szriwvghilzvhrddtzo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">既知の問題</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、</font><font style="vertical-align: inherit;">おそらくJDK 13で修正される可能性もあります。遅くならない？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TIが再び助けになります。</font></font><code>GetStackTrace()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なすべてを実行できる</font><font style="vertical-align: inherit;">関数があり</font><font style="vertical-align: inherit;">ます。指定されたフレームから開始して、指定された長さのスタックトレースのフラグメントを取得し、それ以上は何もしません。</font></font><br>
<br>
<pre><code class="cpp hljs">GetStackTrace(jthread thread,<font></font>
                      jint start_depth,<font></font>
                      jint max_frame_count, <font></font>
                      jvmtiFrameInfo* frame_buffer, <font></font>
                      jint* count_ptr)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残っている質問は1つだけです。JavaプログラムからJVM TI関数を呼び出す方法は？</font><font style="vertical-align: inherit;">他のネイティブメソッドと同様に、メソッド</font></font><code>System.loadLibrary()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のJNI実装が</font><font style="vertical-align: inherit;">ある</font><font style="vertical-align: inherit;">ネイティブライブラリ</font><font style="vertical-align: inherit;">を使用してロードし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackFrame</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> String <span class="hljs-title">getLocation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> depth)</span></span>;<font></font>
<font></font>
    <span class="hljs-keyword">static</span> { <font></font>
        System.loadLibrary(<span class="hljs-string">"stackframe"</span>);<font></font>
    } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TI環境へのポインターは、</font><font style="vertical-align: inherit;">Agent_OnLoad（）からだけでなく、プログラムの実行中にも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得でき</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、通常のネイティブJNIメソッドから引き続き使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT jstring JNICALL
<span class="hljs-title">Java_StackFrame_getLocation</span><span class="hljs-params">(JNIEnv* env, jclass unused, jint depth)</span> </span>{<font></font>
    jvmtiFrameInfo frame;<font></font>
    jint count;<font></font>
    jvmti-&gt;GetStackTrace(<span class="hljs-literal">NULL</span>, depth, <span class="hljs-number">1</span>, &amp;frame, &amp;count);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチはすでに数倍高速であり、アプリケーションの起動に数分を節約することができました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/-u/au/ia-uauyvrmwlvh84rh84rqqwu1s.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真、次のJDK更新で、アプリケーションが突然、非常にゆっくりと起動し始めたという事実に驚きました。調査の結果、スタックトレースを受信するための非常にネイティブなライブラリが生まれました。理解して、バグが私たちの場所ではなくJDKに現れたという結論に達しました。 JDK 8u112以降、メソッドで動作するすべてのJVM TI関数（GetMethodName、GetMethodDeclaringClassなど）が著しく遅くなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を始め、</font><font style="vertical-align: inherit;">少し調べて面白い話を発見しました。いくつかのJVM TI関数はデバッグチェックを追加しましたが、それらが本番コードから呼び出されたことにも気付きませんでした。この使用シナリオは、C ++のソースコードではなく、ファイルにあったため、見つかりませんでした</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jvmtiEnter.xsl</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想像してみてください。HotSpotのコンパイル中に、ソースコードの一部がXSLT変換を介してオンザフライで生成されます。</font><font style="vertical-align: inherit;">このようにして、企業はHotSpotを取り戻しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決策は何でしょうか？</font><font style="vertical-align: inherit;">これらの関数を頻繁に呼び出さないでください。結果をキャッシュしてください。</font><font style="vertical-align: inherit;">つまり、jmethodID情報が受信された場合、それをエージェントのローカルで覚えておいてください。</font><font style="vertical-align: inherit;">このようなキャッシングをエージェントレベルで適用すると、パフォーマンスが以前のレベルに戻りました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的接続</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例として、JVM TIは、通常のネイティブメソッドを使用してJavaコードから直接使用できることを示しました</font></font><code>System.loadLibrary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに</font></font><code>-agentpath</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、JVMの起動時に</font><font style="vertical-align: inherit;">JVM TIエージェントがどのように接続されるかについてはすでに説明しました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、3番目の方法があります：動的接続（動的接続）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アイデアは何ですか？アプリケーションを開始し、将来的に何らかの機能が必要になるとは思わなかった場合、または突然本番環境のバグを調査する必要が生じた場合は、実行時にJVM TIエージェントをロードできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JDK 9以降、これはjcmdユーティリティを使用してコマンドラインから直接実行できるようになりました。</font></font><br>
<br>
<pre><code class="bash hljs">jcmd &lt;pid&gt; JVMTI.agent_load /path/to/agent.so [arguments]
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、古いバージョンのJDKでは、私の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jattach</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーティリティを使用できます</font><font style="vertical-align: inherit;">。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、jattachのおかげで、追加のJVM引数なしで実行されているアプリケーションにオンザフライで接続できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TIエージェントでの動的接続の可能性を利用するには、さらに</font></font><code>Agent_OnLoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、同様の機能を実装する</font><font style="vertical-align: inherit;">必要があり</font><font style="vertical-align: inherit;">ます</font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。唯一の違い</font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、エージェントの起動時にのみ使用できる機能を使用できないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じライブラリを複数回動的に接続できるため、</font></font><code>Agent_OnAttach()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">繰り返し呼び出す</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">ができること</font><font style="vertical-align: inherit;">を覚えておくことが重要です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を挙げて説明します。</font><font style="vertical-align: inherit;">IntelliJ IDEAはプロダクションの役割を果たします。これはJavaアプリケーションでもあります。つまり、オンザフライで接続して何かを行うこともできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDEAのプロセスIDを見つけ、次にjattachユーティリティを使用してpatcher.dll TIライブラリJVMをこのプロセスに接続します。</font></font><br>
<code>jattach 8648 load patcher.dll true</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その場でメニューの色が赤に変わりました</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rv/j7/wm/rvj7wmnfdbo26tjkcsqaix96k74.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。このエージェントは何をしますか？</font><font style="vertical-align: inherit;">指定されたクラス（</font></font><code>javax.swing.AbstractButton</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">すべてのJavaオブジェクトを検索</font><font style="vertical-align: inherit;">し、JNIを介してメソッドを呼び出します</font></font><code>setBackground()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完全なコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 9の新機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TIは長い間存在しており、既存のバグにもかかわらず、長期間変更されていない確立されたデバッグ済みAPIがすでに存在します。最初の重要なイノベーションはJava 9で登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存じのとおり、Java 9は開発者にモジュールに関連する苦痛をもたらしました。まず第一に、JDKの「シークレット」を使用することが難しくなりました。これがないと、原理的には実行できないことがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、JDKでは、Direct ByteBufferをクリアする法的な方法はありません。プライベートAPIを介してのみ：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/qb/ue/wjqbuel-1g3j1qis_bihg0lpn_8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Cassandraでは、すべてのDBMSの作業がMappedByteBufferでの作業に基づいて構築されているため、これらを手動でクリアしないと、JVMはすぐにクラッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、JDK 9で同じコードを実行しようとすると、IllegalAccessErrorが発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/z-/49/coz-496tvv3ogo7kw44viuqtpwq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状況はリフレクションと似ています。プライベートフィールドに手を伸ばすことが難しくなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Linuxのすべてのファイル操作がJavaで使用できるわけではありません。</font><font style="vertical-align: inherit;">したがって、Linux固有の機能の場合、プログラマーはオブジェクトからのリフレクションを介してオブジェクトから</font></font><code>java.io.FileDescriptor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムファイル記述子を</font><font style="vertical-align: inherit;">取得し、その</font><font style="vertical-align: inherit;">上でいくつかのシステム関数と呼ばれるJNIを使​​用しました。</font><font style="vertical-align: inherit;">そして今、これをJDK 9で実行すると、ログに乱用が表示されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/he/xc/6p/hexc6pnrkv0ehoablvlfy11imt0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、必要なプライベートモジュールを開き、プライベートクラスとリフレクションを使用できるようにするJVMフラグがあります。</font><font style="vertical-align: inherit;">ただし、使用するすべてのパッケージを手動で登録する必要があります。</font><font style="vertical-align: inherit;">たとえば、Java 11でCassandraを実行するには、その</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バナー</font><font style="vertical-align: inherit;">を登録する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">--add-exports java.base/jdk.internal.misc=ALL-UNNAMED<font></font>
--add-exports java.base/jdk.internal.ref=ALL-UNNAMED<font></font>
--add-exports java.base/sun.nio.ch=ALL-UNNAMED<font></font>
--add-exports java.management.rmi/com.sun.jmx.remote.internal.rmi=ALL-UNNAMED<font></font>
--add-exports java.rmi/sun.rmi.registry=ALL-UNNAMED<font></font>
--add-exports java.rmi/sun.rmi.server=ALL-UNNAMED<font></font>
--add-exports java.sql/java.sql=ALL-UNNAMED<font></font>
<font></font>
--add-opens java.base/java.lang.module=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.loader=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.ref=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.reflect=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.math=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.module=ALL-UNNAMED<font></font>
--add-opens java.base/jdk.internal.util.jar=ALL-UNNAMED<font></font>
--add-opens jdk.management/com.sun.management.internal=ALL-UNNAMED<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、モジュールとともに</font><font style="vertical-align: inherit;">、それらを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ためのJVM TI </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">関数が表示さ</font></a><font style="vertical-align: inherit;">れました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GetAllModules</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddModuleExports</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AddModuleOpens</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このリストを見ると、ソリューションはそれ自体を示唆しています。JVMがロードされるのを待って、すべてのモジュールのリストを取得し、すべてのパッケージを調べ、すべての人にすべてを開いて楽しむことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Direct ByteBufferの例を示します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{<font></font>
    ByteBuffer buf = ByteBuffer.allocateDirect(<span class="hljs-number">1024</span>);<font></font>
<font></font>
    ((sun.nio.ch.DirectBuffer) buf).cleaner().clean();<font></font>
<font></font>
    System.out.println(<span class="hljs-string">"Buffer cleaned"</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エージェントなしで実行すると、IllegalAccessErrorが発生することが予想されます。</font><font style="vertical-align: inherit;">また、私が作成した</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチモジュール</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エージェントを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">agentpathに</font></a><font style="vertical-align: inherit;">追加すると</font><font style="vertical-align: inherit;">、この例はエラーなしで機能します。</font><font style="vertical-align: inherit;">反射についても同じことが言えます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java 11の新機能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう1つのイノベーションがJava 11に登場しました。これは1つだけですが、なんと！割り当ての軽量プロファイリングの可能性が現れました：新しいイベントが追加されました</font></font><code>SampledObjectAlloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これはサブスクライブでき、割り当てに関する選択的な通知が送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらなる分析に必要なすべてのものはコールバックに転送されます：割り当てるスレッド、選択されたオブジェクト自体、そのクラス、サイズ。別の方法</font></font><code>SetHeapSampingInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、これらの通知の頻度を変更することです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5f/e1/8_/5fe18_nwt5i-zbm4e-vyn4roavm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが必要なのですか？割り当てプロファイリングは、すべての一般的なプロファイラーで以前から使用されていましたが、インスツルメンテーションによって機能しましたが、オーバーヘッドが高くなります。オーバーヘッドの少ないプロファイリングツールは、Java Flight Recorderだけでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しい方法のアイデアは、すべての割り当てではなく、それらの一部のみを計測すること、つまりサンプリングすることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最速かつ最も頻繁なケースでは、ポインタを増やすだけで、スレッドローカルアロケーションバッファ内でアロケーションが行われます。また、TLABにサンプリングを含めることにより、サンプリング周波数に対応する仮想境界が追加されます。次の割り当てがこの境界を超えるとすぐに、オブジェクトの割り当てに関するイベントが送信されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/lm/di/v0lmdimdyk8uvasl3z9gkjlrfqe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TLABに収まらない大きなオブジェクトは、ヒープに直接割り当てられる場合があります。このようなオブジェクトは、JVMランタイムを介した低速の割り当てパスにも沿っており、サンプリングされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、一部のオブジェクトに対してのみサンプリングが実行されるという事実により、本番環境ではオーバーヘッドはすでに許容可能です-ほとんどの場合、5％未満です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、このような機会は、JDK 7の時代以来、Flight Recorderのために特別に作られたものであり、長い年月が経ちました。</font><font style="vertical-align: inherit;">しかし、プライベートHotspot APIを通じて、async-profilerもこれを使用しました。</font><font style="vertical-align: inherit;">そして今、JDK 11以降、このAPIはパブリックになり、JVM TIに入り、他のプロファイラーがそれを使用できます。</font><font style="vertical-align: inherit;">特に、YourKitはすでにその方法を知っています。</font><font style="vertical-align: inherit;">また、このAPIの使用方法については、</font><font style="vertical-align: inherit;">リポジトリに投稿されて</font><font style="vertical-align: inherit;">いる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロファイラーを使用すると、美しい割り当て図を作成できます。</font><font style="vertical-align: inherit;">目立つオブジェクト、目立つオブジェクトの数、そして最も重要なのはどこにあるかを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qi/t1/lw/qit1lwwqv3p7vxhhl-fbcfh5bos.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM TIは、仮想マシンと対話するための優れた方法です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CまたはC ++で記述されたプラグインは、JVMの開始時に開始するか、アプリケーションの実行中に動的に直接接続することができます。</font><font style="vertical-align: inherit;">さらに、アプリケーション自体がネイティブメソッドを通じてJVM TI関数を使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デモの例はすべて</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リポジトリ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">に</font></a><font style="vertical-align: inherit;">投稿されています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">使用し、勉強し、質問します。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458798/index.html">NutrientBot、またはフィットネストレーナーからパンを取りたい方法</a></li>
<li><a href="../ja458800/index.html">ディープラーニング。連携学習</a></li>
<li><a href="../ja458804/index.html">機械学習のダイジェストと人工知能の記事</a></li>
<li><a href="../ja458808/index.html">Habrの死後報告：新聞は落ちた</a></li>
<li><a href="../ja458810/index.html">CorelとParallelsが米国からKKR投資グループに売却</a></li>
<li><a href="../ja458814/index.html">需要が形成されていない製品のサイトを立ち上げる</a></li>
<li><a href="../ja458818/index.html">著名な同時代人</a></li>
<li><a href="../ja458820/index.html">Minecraftプラットフォームでの有名なジャンルの実装について</a></li>
<li><a href="../ja458826/index.html">オーガニックで急激に成長するように古い記事を取り除く方法：+ 6か月間のトラフィックの104％</a></li>
<li><a href="../ja458828/index.html">ValueTaskを使用する理由、理由、および時期</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>