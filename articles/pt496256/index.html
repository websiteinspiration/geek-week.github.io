<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍊 🥞 🐭 Aprendizado de máquina em R: técnicas especializadas para análise preditiva 👨🏽‍🏭 🌄 👌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá, habrozhiteli! A linguagem R oferece um conjunto poderoso de métodos de aprendizado de máquina que permitem realizar rapidamente análises não triv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Aprendizado de máquina em R: técnicas especializadas para análise preditiva</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/496256/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/lf/4u/ao/lf4uaojxjnbk8d6no9t-3j-v7ww.jpeg" align="left" alt="imagem"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá, habrozhiteli! A linguagem R oferece um conjunto poderoso de métodos de aprendizado de máquina que permitem realizar rapidamente análises não triviais de seus dados. O livro é um guia que ajudará a aplicar métodos de aprendizado de máquina para resolver problemas do dia a dia. Brett Lanz ensinará tudo o que você precisa para análise, previsão e visualização de dados. Aqui você encontrará informações sobre bibliotecas novas e aprimoradas, dicas sobre os aspectos éticos do aprendizado de máquina e questões de preconceito, além de treinamento aprofundado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste livro - Fundamentos de aprendizado de máquina e recursos de treinamento em informática em exemplos. </font><font style="vertical-align: inherit;">- Preparação de dados para uso em aprendizado de máquina por meio da linguagem R. - Classificação da significância dos resultados. </font><font style="vertical-align: inherit;">- Previsão de eventos usando árvores de decisão, regras e vetores de referência. </font><font style="vertical-align: inherit;">- Previsão de dados numéricos e avaliação de dados financeiros usando métodos de regressão. </font><font style="vertical-align: inherit;">- Modelar processos complexos usando redes neurais é a base do aprendizado profundo. </font><font style="vertical-align: inherit;">- Avaliação de modelos e melhoria de desempenho. </font><font style="vertical-align: inherit;">- As mais recentes tecnologias para processamento de big data, em particular R 3.6, Spark, H2O e TensorFlow.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para quem é o livro?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O livro é destinado a quem espera usar dados em uma área específica. </font><font style="vertical-align: inherit;">Você já deve estar um pouco familiarizado com o aprendizado de máquina, mas nunca trabalhou com a linguagem R; </font><font style="vertical-align: inherit;">ou, inversamente, você sabe um pouco sobre R, mas quase não sabe sobre aprendizado de máquina. </font><font style="vertical-align: inherit;">De qualquer forma, este livro ajudará você a começar rapidamente. </font><font style="vertical-align: inherit;">Seria útil atualizar um pouco os conceitos básicos de matemática e programação, mas nenhuma experiência anterior seria necessária. </font><font style="vertical-align: inherit;">Tudo que você precisa é um desejo de aprender.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que você lerá na publicação</font></font></b><div class="spoiler_text"> 1 «   »    ,          ,      ,   ,     .<br>
<br>
 2 «    »            R.         ,   ,    .<br>
<br>
 3 « :      »      ,           :     .<br>
<br>
 4 « :      »     ,       .    ,      .<br>
<br>
 5 «  :       »    ,     ,    .      ,    .<br>
<br>
 6 «  :  »     ,    .        ,     ,     .<br>
<br>
 7 « “ ”:      »   ,     .        ,    ,    .<br>
<br>
 8 « :       »  ,    ,      .   -   ,         ,   ,      .<br>
<br>
 9 «  :   k-»      .         -.<br>
<br>
 10 «  »    ,                  .<br>
<br>
 11 «  »  ,  ,        .                ,         .<br>
<br>
 12 «   »    :        R.  ,        ,       R.<br>
</div></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplo: modelando a resistência do concreto usando uma rede neural</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No campo da engenharia civil, é extremamente importante ter estimativas precisas da eficácia dos materiais de construção. </font><font style="vertical-align: inherit;">Essas avaliações são necessárias para desenvolver regras de segurança que regem o uso de materiais na construção de edifícios, pontes e estradas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De particular interesse é a avaliação da resistência do concreto. </font><font style="vertical-align: inherit;">O concreto é usado em praticamente qualquer construção, as características de desempenho do concreto são muito diferentes, pois consiste em um grande número de ingredientes que interagem em um complexo. </font><font style="vertical-align: inherit;">Como resultado, é difícil dizer exatamente qual será a força do produto acabado. </font><font style="vertical-align: inherit;">Um modelo que permita determinar com certeza a resistência do concreto, levando em consideração a composição dos materiais de partida, poderia fornecer um nível mais alto de segurança para os canteiros de obras.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 1. Coleta de Dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esta análise, usaremos os dados concretos da resistência à compressão fornecidos por I-Cheng Yeh ao UCI Machine Learning Repository (http://archive.ics.uci.edu/ml). </font><font style="vertical-align: inherit;">Como Ai-Cheng Ye usou com sucesso redes neurais para modelar esses dados, tentaremos reproduzir seu trabalho aplicando um modelo simples de rede neural em R.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A julgar pelo site, este conjunto de dados contém 1030 registros sobre diferentes marcas de concreto com oito características que descrevem os componentes usados ​​na composição da mistura de concreto. </font><font style="vertical-align: inherit;">Acredita-se que essas características afetem a resistência à compressão final. </font><font style="vertical-align: inherit;">Isso inclui: a quantidade (em quilogramas por metro cúbico) de cimento, água, vários aditivos, agregados grandes e pequenos, como pedras e areia trituradas, usados ​​no produto acabado, bem como o tempo de endurecimento (em dias).</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para executar este exemplo, faça o download do arquivo Concrete.csv e salve-o no diretório de trabalho do R.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 2. Pesquisa e preparação de dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como de costume, iniciamos a análise carregando os dados no objeto R usando a função read.csv () e certifique-se de que o resultado corresponda à estrutura esperada:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete &lt;- read.csv(<span class="hljs-string">"concrete.csv"</span>)<font></font>
&gt; str(concrete)<font></font>
<span class="hljs-string">'data.frame'</span>:        <span class="hljs-number">1030</span> obs. of <span class="hljs-number">9</span> variables:<font></font>
$ cement       : num <span class="hljs-number">141</span> <span class="hljs-number">169</span> <span class="hljs-number">250</span> <span class="hljs-number">266</span> <span class="hljs-number">155</span> ...<font></font>
$ slag            : num <span class="hljs-number">212</span> <span class="hljs-number">42.2</span> <span class="hljs-number">0</span> <span class="hljs-number">114</span> <span class="hljs-number">183.4</span> ...<font></font>
$ ash             : num <span class="hljs-number">0</span> <span class="hljs-number">124.3</span> <span class="hljs-number">95.7</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> ...<font></font>
$ water          : num <span class="hljs-number">204</span> <span class="hljs-number">158</span> <span class="hljs-number">187</span> <span class="hljs-number">228</span> <span class="hljs-number">193</span> ...<font></font>
$ superplastic : num <span class="hljs-number">0</span> <span class="hljs-number">10.8</span> <span class="hljs-number">5.5</span> <span class="hljs-number">0</span> <span class="hljs-number">9.1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">6.4</span> <span class="hljs-number">0</span> <span class="hljs-number">9</span> ...<font></font>
$ coarseagg    : num <span class="hljs-number">972</span> <span class="hljs-number">1081</span> <span class="hljs-number">957</span> <span class="hljs-number">932</span> <span class="hljs-number">1047</span> ...<font></font>
$ fineagg        : num <span class="hljs-number">748</span> <span class="hljs-number">796</span> <span class="hljs-number">861</span> <span class="hljs-number">670</span> <span class="hljs-number">697</span> ...<font></font>
$ age             : <span class="hljs-keyword">int</span> <span class="hljs-number">28</span> <span class="hljs-number">14</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> <span class="hljs-number">90</span> <span class="hljs-number">7</span> <span class="hljs-number">56</span> <span class="hljs-number">28</span> <span class="hljs-number">28</span> ...<font></font>
$ strength      : num <span class="hljs-number">29.9</span> <span class="hljs-number">23.5</span> <span class="hljs-number">29.2</span> <span class="hljs-number">45.9</span> <span class="hljs-number">18.3</span> ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nove variáveis ​​no quadro de dados correspondem a oito características e um resultado esperado, mas ficou óbvio que há um problema. </font><font style="vertical-align: inherit;">As redes neurais funcionam melhor quando os dados de entrada são redimensionados para um intervalo estreito centrado em torno de 0, e aqui vemos valores no intervalo de 0 a mais de 1000.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalmente, a solução para esse problema é dimensionar os dados usando a função de normalização ou padronização. Se a distribuição de dados corresponder a uma curva em forma de sino (distribuição normal, consulte o capítulo 2), poderá fazer sentido usar a padronização usando a função de escala interna (). Se a distribuição dos dados for quase uniforme ou muito diferente do normal, a normalização para o intervalo de 0 a 1. Pode ser mais adequada.Neste caso, usaremos a última opção. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No capítulo 3, criamos nossa própria função normalize ():</font></font><br>
<br>
<pre><code class="java hljs">&gt; normalize &lt;- function(x) {
       <span class="hljs-keyword">return</span>((x - min(x)) / (max(x) — min(x)))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Após a execução desse código, você pode aplicar a função normalize () a todas as colunas do quadro de dados selecionado usando a função lapply (): </font></font><br>
<br>
<code>&gt; concrete_norm &lt;- as.data.frame(lapply(concrete, normalize))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para verificar se a normalização funcionou, é possível verificar se os valores mínimo e máximo do atributo de força são 0 e 1, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete_norm$strength)<font></font>
       Min.     <span class="hljs-number">1</span>st Qu.         Median     Mean      <span class="hljs-number">3</span>rd Qu.      Max.
   <span class="hljs-number">0.0000</span>     <span class="hljs-number">0.2664</span>         <span class="hljs-number">0.4001</span>  <span class="hljs-number">0.4172</span>      <span class="hljs-number">0.5457</span>   <span class="hljs-number">1.0000</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para comparação: os valores mínimo e máximo iniciais deste atributo foram 2,33 e 82,60, respectivamente:</font></font><br>
<br>
<pre><code class="java hljs">&gt; summary(concrete$strength)<font></font>
     Min.       <span class="hljs-number">1</span>st Qu.     Median       Mean      <span class="hljs-number">3</span>rd Qu.       Max.
    <span class="hljs-number">2.33</span>         <span class="hljs-number">23.71</span>       <span class="hljs-number">34.44</span>      <span class="hljs-number">35.82</span>        <span class="hljs-number">46.14</span>      <span class="hljs-number">82.60</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qualquer conversão aplicada aos dados antes de treinar o modelo deve ser aplicada posteriormente na ordem inversa para converter o atributo novamente nas unidades originais. </font><font style="vertical-align: inherit;">Para facilitar o dimensionamento, é recomendável salvar os dados de origem ou pelo menos um resumo das estatísticas dos dados de origem.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seguindo o cenário descrito por Ye no artigo original, dividiremos os dados em um conjunto de treinamento, que inclui 75% de todos os exemplos, e um conjunto de testes, composto por 25%. </font><font style="vertical-align: inherit;">O arquivo CSV usado é classificado em ordem aleatória, portanto, podemos apenas dividi-lo em duas partes: </font><font style="vertical-align: inherit;">
Usaremos um conjunto de dados de treinamento para construir uma rede neural e um conjunto de dados de teste para avaliar quão bem o modelo se generaliza para resultados futuros. </font><font style="vertical-align: inherit;">Como a rede neural é facilmente levada a um estado de reciclagem, essa etapa é muito importante.</font></font><br>
<br>
<code>&gt; concrete_train &lt;- concrete_norm[1:773, ]<br>
&gt; concrete_test &lt;- concrete_norm[774:1030, ]</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 3. Treinando o Modelo em Dados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para modelar a relação entre os ingredientes utilizados na produção de concreto e a resistência do produto acabado, construiremos uma rede neural de distribuição direta multicamada. O pacote neuralnet, desenvolvido por Stefan Fritsch e Frauke Guenther, fornece uma implementação padrão e fácil de usar dessas redes. Este pacote também inclui uma função para criar uma topologia de rede. A implementação da neuralnet é uma boa maneira de obter informações adicionais sobre redes neurais, embora isso não signifique que também não possa ser usado para realizar um trabalho real - como você verá em breve, é uma ferramenta bastante poderosa.</font></font><br>
<br>
<blockquote> R    ,       ,        .  nnet      R,  , ,      .       ,      .    —  RSNNS,       ,     ,     .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como o pacote neuralnet não está incluído na base R, será necessário instalá-lo digitando install.packages ("neuralnet") e faça o download usando o comando library (neuralnet). </font><font style="vertical-align: inherit;">A função neuralnet () no pacote pode ser usada para treinar redes neurais na previsão numérica usando a seguinte sintaxe.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sintaxe de rede neural</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usando a função neuralnet () do pacote neuralnet </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Construindo um modelo:</font></font><br>
<br>
<pre><code class="java hljs">m &lt;- neuralnet(target ~ predictors, data = mydata,<font></font>
                       hidden = <span class="hljs-number">1</span>, act.fct = <span class="hljs-string">"logistic"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• target - um modelo que será construído como resultado do treinamento no quadro de dados mydata; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• preditores - fórmula R que determina as características do quadro de dados mydata a serem usadas na previsão; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• dados - quadro de dados ao qual o alvo e os preditores pertencem; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• oculto - o número de neurônios na camada oculta (o padrão é 1). Nota: para descrever várias camadas ocultas, um vetor de números inteiros é usado, por exemplo, c (2, 2); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• act.fct - função de ativação: "logistic" ou "tanh". Nota: qualquer outra função diferenciável também pode ser usada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função retorna um objeto de rede neural que pode ser usado para previsão. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previsão:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
p &lt;- computação (m, teste)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• m - modelo treinado usando a função neuralnet (); </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
• teste - um quadro de dados contendo dados de teste com as mesmas características que os dados de treinamento usados ​​para construir o classificador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A função retorna uma lista que consiste em dois componentes: $ neurônios, onde os neurônios são armazenados para cada camada de rede, e $ net.result, onde os valores previstos usando este modelo são armazenados.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exemplos:</font></font></h4><br>
<br>
<pre><code class="java hljs">concrete_model &lt;- neuralnet(strength ~ cement + slag + ash,<font></font>
      data = concrete, hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), act.fct = <span class="hljs-string">"tanh"</span>)<font></font>
model_results &lt;- compute(concrete_model, concrete_data)<font></font>
strength_predictions &lt;- model_results$net.result</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos começar treinando a rede de distribuição direta multinível mais simples com parâmetros padrão, que possui apenas um nó oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model &lt;- neuralnet(strength ~ cement + slag<font></font>
         + ash + water + superplastic + coarseagg + fineagg + age,<font></font>
         data = concrete_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, como mostrado na fig. </font><font style="vertical-align: inherit;">7.11, você pode visualizar a topologia de rede usando a função plot () e passando o objeto de modelo resultante:</font></font><br>
<br>
<code>&gt; plot(concrete_model)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/mt/qh/og/mtqhogfq-pcptln4uzbl9ofb8po.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse modelo simples, há um nó de entrada para cada um dos oito recursos, depois há um nó oculto e um nó de saída, o que fornece uma previsão da resistência do concreto. </font><font style="vertical-align: inherit;">O diagrama também mostra os pesos para cada link e o valor do deslocamento indicado para os nós marcados com o número 1. O valor do deslocamento é uma constante numérica que permite alterar o valor no nó especificado para cima ou para baixo, aproximadamente como uma mudança em uma equação linear.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma rede neural com um nó oculto pode ser considerada a “prima” dos modelos de regressão linear discutidos no Capítulo 6. Os pesos entre os nós de entrada e o nó oculto são semelhantes aos coeficientes beta, e o peso do deslocamento é como uma mudança.</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na parte inferior da figura, o número de etapas do treinamento e a magnitude do erro são exibidos - o erro quadrático médio total (Soma dos erros quadrados, SSE), que, como esperado, é a soma das diferenças quadráticas entre os valores previstos e reais. </font><font style="vertical-align: inherit;">Quanto menor o SSE, mais precisamente o modelo corresponde aos dados de treinamento, o que indica a eficácia desses dados, mas diz pouco sobre como o modelo funcionará com dados desconhecidos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 4. Avaliando a eficácia do modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O diagrama de topologia de rede oferece uma oportunidade de examinar a "caixa preta" de uma rede neural, mas não fornece muitas informações sobre o quão bem o modelo corresponde aos dados futuros. Para gerar previsões em um conjunto de dados de teste, você pode usar a </font></font><br>
<br>
<code>&gt; model_results &lt;- compute(concrete_model, concrete_test[1:8])</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
função </font><font style="vertical-align: inherit;">compute (): </font><font style="vertical-align: inherit;">A função compute () funciona de maneira um pouco diferente das funções predição () que usamos até agora. Ele retorna uma lista composta por dois componentes: $ neurônios, onde os neurônios são armazenados para cada camada da rede, e $ net.result, onde os valores previstos são armazenados. É $ net.result que precisamos:</font></font><br>
<br>
<code>&gt; predicted_strength &lt;- model_results$net.result</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como temos a tarefa de previsão numérica, e não de classificação, não podemos usar a matriz de inconsistências para verificar a precisão do modelo. </font><font style="vertical-align: inherit;">Medimos a correlação entre o valor previsto e o verdadeiro valor da resistência do concreto. </font><font style="vertical-align: inherit;">Se os valores previstos e reais se correlacionarem fortemente, provavelmente o modelo será útil para determinar a resistência do concreto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deixe-me lembrá-lo que, para obter a correlação entre dois vetores numéricos, a função cor () é usada:</font></font><br>
<br>
<pre><code class="java hljs">&gt; cor(predicted_strength, concrete_test$strength)<font></font>
                    [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.8064655576</span></code></pre><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Não se assuste se o resultado for diferente do nosso. </font><font style="vertical-align: inherit;">Como a rede neural começa a trabalhar com pesos aleatórios, as previsões apresentadas no livro podem ser diferentes para diferentes modelos. </font><font style="vertical-align: inherit;">Se você deseja corresponder com precisão os resultados, tente o comando set.seed (12345) antes de começar a construir uma rede neural.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a correlação for próxima de 1, isso indica uma forte relação linear entre as duas variáveis. </font><font style="vertical-align: inherit;">Portanto, uma correlação de aproximadamente 0,806 indica uma relação bastante forte. </font><font style="vertical-align: inherit;">Isso significa que o modelo funciona muito bem, mesmo com um único nó oculto. </font><font style="vertical-align: inherit;">Como usamos apenas um nó oculto, é provável que possamos melhorar a eficiência do modelo, o que tentaremos fazer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etapa 5. Melhorando a eficiência do modelo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como redes com uma topologia mais complexa são capazes de estudar conceitos mais complexos, vamos ver o que acontece se você aumentar o número de nós ocultos para cinco. </font><font style="vertical-align: inherit;">Usaremos a função neuralnet (), como antes, mas adicionaremos o parâmetro hidden = 5:</font></font><br>
<br>
<pre><code class="java hljs">&gt; concrete_model2 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train, hidden = <span class="hljs-number">5</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tendo construído o diagrama de rede novamente (Fig. 7.12), veremos um aumento acentuado no número de conexões. Como isso afetou a eficiência? </font></font><br>
<br>
<code>&gt; plot(concrete_model2)</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que o erro resultante (novamente medido como SSE) diminuiu de 5,08 no modelo anterior para 1,63. Além disso, o número de estágios de treinamento aumentou de 4882 para 86.849 - o que não é surpreendente, dada a complexidade do modelo. Quanto mais complexa a rede, mais iterações são necessárias para encontrar os pesos ideais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aplicando as mesmas etapas para comparar os valores previstos com os verdadeiros, obtemos uma correlação de cerca de 0,92, o que é muito melhor em comparação com o resultado anterior de 0,80 para uma rede com um nó oculto:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results2 &lt;- compute(concrete_model2, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength2 &lt;- model_results2$net.result<font></font>
&gt; cor(predicted_strength2, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9244533426</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/x2/57/55/x25755f5wjbx5meuttyzyv0fczi.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar das melhorias significativas, você pode ir ainda mais longe para aumentar a eficácia do modelo. Em particular, é possível introduzir camadas ocultas adicionais e alterar a função de ativação da rede. Ao fazer essas mudanças, estamos lançando as bases para a construção de uma rede neural profunda simples. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A escolha da função de ativação é muito importante para o aprendizado profundo. A melhor função para uma tarefa de aprendizado específica geralmente é encontrada experimentalmente e, em seguida, é amplamente utilizada pela comunidade de pesquisadores de aprendizado de máquina.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recentemente, a função de ativação, chamada função de destilação, ou retificador, tornou-se muito popular devido à sua aplicação bem-sucedida em tarefas complexas, como o reconhecimento de imagens. Um nó de rede neural no qual um retificador é usado como uma função de ativação é chamado de Unidade Linear Retificada (ReLU). Como mostrado na fig. 7.13, a função de ativação do tipo retificador é descrita de maneira que retorne x se x for maior que ou igual a 0 e 0 caso contrário. A importância dessa função é que, por um lado, é não linear e, por outro, possui propriedades matemáticas simples que a tornam computacionalmente barata e altamente eficiente para a descida do gradiente. Infelizmente, para x = 0, a derivada retificadora não está definida,portanto, o retificador não pode ser usado em conjunto com a função neuralnet ().</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em vez disso, você pode usar uma aproximação suavizada da ReLU chamada softplus ou SmoothReLU, uma função de ativação definida como log (1 + ex). </font><font style="vertical-align: inherit;">Como mostrado na fig. </font><font style="vertical-align: inherit;">7.13, a função softplus é próxima de zero para valores de x menores que 0 e aproximadamente igual a x para x maior que 0.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/k9/us/lu/k9uslumivm12vadxdm5d__dhzoq.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para definir a função softplus () em R, usamos o seguinte código: </font></font><br>
<br>
<code>&gt; softplus &lt;- function(x) { log(1 + exp(x)) }</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa função de ativação pode ser fornecida à entrada neuralnet () usando o parâmetro act.fct. </font><font style="vertical-align: inherit;">Além disso, adicionamos uma segunda camada oculta composta por cinco nós, atribuindo ao parâmetro oculto o valor do vetor inteiro c (5, 5). </font><font style="vertical-align: inherit;">Como resultado, obtemos uma rede de duas camadas, cada uma das quais possui cinco nós, e todas elas usam a função de ativação do softplus:</font></font><br>
<br>
<pre><code class="java hljs">&gt; set.seed(<span class="hljs-number">12345</span>)<font></font>
&gt; concrete_model3 &lt;- neuralnet(strength ~ cement + slag +<font></font>
                                               ash + water + superplastic +<font></font>
                                               coarseagg + fineagg + age,<font></font>
                                               data = concrete_train,<font></font>
                                               hidden = c(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<font></font>
                                               act.fct = softplus)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, a rede pode ser visualizada (Fig. 7.14):</font></font><br>
<br>
<code>&gt; plot(concrete_model3)</code><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yw/yy/om/ywyyomaklvohzlzh-jp2ljggypi.png" alt="imagem"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A correlação entre a resistência prevista e real do concreto pode ser calculada da seguinte forma:</font></font><br>
<br>
<pre><code class="java hljs">&gt; model_results3 &lt;- compute(concrete_model3, concrete_test[<span class="hljs-number">1</span>:<span class="hljs-number">8</span>])<font></font>
&gt; predicted_strength3 &lt;- model_results3$net.result<font></font>
&gt; cor(predicted_strength3, concrete_test$strength)<font></font>
                  [,<span class="hljs-number">1</span>]<font></font>
[<span class="hljs-number">1</span>,] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A correlação entre a força prevista e a força real foi de 0,935, que é o melhor indicador obtido até o momento. Curiosamente, na publicação original, Ye relatou uma correlação de 0,885. Isso significa que, com relativamente pouco esforço, fomos capazes de obter um resultado comparável e até superar os resultados de um especialista nesse campo. É verdade que os resultados de Ye foram publicados em 1998, o que nos deu uma vantagem em mais de 20 anos de pesquisas adicionais no campo das redes neurais! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outro detalhe importante deve ser levado em consideração: como normalizamos os dados antes de treinar o modelo, as previsões também estão no intervalo normalizado de 0 a 1. Por exemplo, o código a seguir mostra um quadro de dados que compara linha a linha os valores de resistência do concreto do conjunto de dados inicial com as previsões correspondentes:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths &lt;- data.frame(<font></font>
      actual = concrete$strength[<span class="hljs-number">774</span>:<span class="hljs-number">1030</span>],<font></font>
      pred = predicted_strength3<font></font>
   )<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
      actual        pred<font></font>
<span class="hljs-number">774</span> <span class="hljs-number">30.14</span> <span class="hljs-number">0.2860639091</span>
<span class="hljs-number">775</span> <span class="hljs-number">44.40</span> <span class="hljs-number">0.4777304648</span>
<span class="hljs-number">776</span> <span class="hljs-number">24.50</span> <span class="hljs-number">0.2840964250</span></code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinando a correlação, vemos que a escolha de dados normalizados ou anormais não afeta as estatísticas de desempenho calculadas - assim como antes, a correlação é de 0,935: </font><font style="vertical-align: inherit;">
mas se calculamos outro indicador de desempenho, por exemplo, a diferença absoluta entre os valores previstos e reais, a escolha da escala seria muito importante. </font><font style="vertical-align: inherit;">
Com isso em mente, você pode criar a função unnormalize () que executaria o inverso da normalização do minimax e permitiria converter previsões normalizadas para a escala original:</font></font><br>
<br>
<code>&gt; cor(strengths$pred, strengths$actual)<br>
[1] 0.9348395359</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="java hljs">&gt; unnormalize &lt;- function(x) {
     <span class="hljs-keyword">return</span>((x * (max(concrete$strength)) -<font></font>
           min(concrete$strength)) + min(concrete$strength))<font></font>
   }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois de aplicar a função unnormalize () que escrevemos nas previsões, fica claro que a escala das novas previsões é semelhante aos valores iniciais da resistência do concreto. </font><font style="vertical-align: inherit;">Isso permite calcular o valor significativo do erro absoluto. </font><font style="vertical-align: inherit;">Além disso, a correlação entre os valores de força anormais e iniciais permanece inalterada:</font></font><br>
<br>
<pre><code class="java hljs">&gt; strengths$pred_new &lt;- unnormalize(strengths$pred)<font></font>
&gt; strengths$error &lt;- strengths$pred_new — strengths$actual<font></font>
&gt; head(strengths, n = <span class="hljs-number">3</span>)<font></font>
           actual                pred             pred_new                    error<font></font>
<span class="hljs-number">774</span>          <span class="hljs-number">30.14</span>         <span class="hljs-number">0.2860639091</span>               <span class="hljs-number">23.62887889</span>      -<span class="hljs-number">6.511121108</span>
<span class="hljs-number">775</span>          <span class="hljs-number">44.40</span>         <span class="hljs-number">0.4777304648</span>               <span class="hljs-number">39.46053639</span>      -<span class="hljs-number">4.939463608</span>
<span class="hljs-number">776</span>          <span class="hljs-number">24.50</span>         <span class="hljs-number">0.2840964250</span>               <span class="hljs-number">23.46636470</span>      -<span class="hljs-number">1.033635298</span><font></font>
<font></font>
&gt; cor(strengths$pred_new, strengths$actual)<font></font>
[<span class="hljs-number">1</span>] <span class="hljs-number">0.9348395359</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao aplicar redes neurais aos seus projetos, você precisa seguir uma sequência semelhante de etapas para retornar os dados à sua escala original.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você também pode descobrir que as redes neurais estão se tornando rapidamente mais complexas à medida que são usadas para tarefas de aprendizado cada vez mais difíceis. Por exemplo, você pode encontrar o chamado problema de gradiente pequeno "desaparecendo" e o problema de gradiente "explodindo" intimamente relacionado, quando o algoritmo de propagação traseira não encontra uma solução útil, pois não converge em um tempo razoável. Para resolver esses problemas, você pode tentar alterar o número de nós ocultos, aplicar várias funções de ativação, como ReLU, ajustar a velocidade de aprendizado etc. Na página de ajuda da função neuralnet, você encontrará informações adicionais sobre os vários parâmetros que podem ser configurados. No entanto, isso leva a outro problema,quando o gargalo na construção de um modelo altamente eficiente está verificando um grande número de parâmetros. Esse é o preço do uso de redes neurais e redes de aprendizado ainda mais profundas: seu enorme potencial requer muito tempo e poder de processamento.</font></font><br>
<br>
<blockquote>       ,  ML     .     ,   Amazon Web Services (AWS)  Microsoft Azure,          .       12.</blockquote><br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O método Support Vector Machine (SVM) pode ser representado como uma superfície que forma o limite entre os pontos de dados plotados em um espaço multidimensional que descreve exemplos e valores de seus atributos. O objetivo do SVM é construir uma borda plana - um hiperplano que divide o espaço de maneira que grupos homogêneos se formem nos dois lados. Portanto, o treinamento SVM combina aspectos do treinamento do vizinho mais próximo com base nas instâncias descritas no Capítulo 3 e na modelagem de regressão linear, discutida no Capítulo 6. Essa é uma combinação extremamente poderosa que permite que os SVMs modelem relacionamentos muito complexos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apesar do fato de que a matemática básica subjacente ao SVM existe há décadas, o interesse por esses métodos aumentou significativamente depois que começaram a ser aplicados ao BC. A popularidade desses métodos aumentou após histórias de sucesso de alto perfil na solução de problemas complexos de aprendizado, bem como após o desenvolvimento de algoritmos SVM, que foram premiados e implementados em bibliotecas bem suportadas em muitas linguagens de programação, incluindo R. Depois disso, os métodos SVM foram aceitos por um amplo público. Caso contrário, provavelmente seria impossível aplicar a matemática complexa necessária para implementar o SVM. A boa notícia é que, embora a matemática seja possivelmente complexa, os conceitos básicos são compreensíveis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os métodos SVM podem ser adaptados para usar quase qualquer tipo de tarefa de treinamento, incluindo classificação e previsão numérica. </font><font style="vertical-align: inherit;">Muitos dos principais sucessos desse algoritmo estão relacionados ao reconhecimento de padrões. </font><font style="vertical-align: inherit;">Os aplicativos mais conhecidos para esses métodos incluem o seguinte:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classificação de dados sobre a expressão de genes de microarrays em bioinformática para a detecção de câncer e outras doenças genéticas;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">categorização de texto, como determinar o idioma usado em um documento ou classificar documentos por tópico;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Detecção de eventos raros, mas importantes, como falha de um motor de combustão interna, violação de segurança ou terremoto.</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os métodos SVM são mais fáceis de entender usando a classificação binária como exemplo - é assim que eles geralmente são usados. </font><font style="vertical-align: inherit;">Portanto, nas seções restantes, focaremos apenas nos classificadores SVM. </font><font style="vertical-align: inherit;">Princípios semelhantes aos apresentados aqui também são usados ​​ao adaptar métodos SVM para previsão numérica.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre o autor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brett Lantz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (@DataSpelunking) usa técnicas inovadoras de processamento de dados para estudar o comportamento humano há mais de uma década. </font><font style="vertical-align: inherit;">Sendo sociólogo em treinamento, Brett ficou interessado no aprendizado de máquina enquanto pesquisava um grande banco de dados de perfis de adolescentes em redes sociais. </font><font style="vertical-align: inherit;">Brett é professor no DataCamp e costuma fazer apresentações em conferências e seminários de aprendizado de máquina em todo o mundo. </font><font style="vertical-align: inherit;">Ele é um entusiasta bem conhecido no campo da aplicação prática da ciência de dados no campo do esporte, veículos não tripulados, estudo de línguas e moda estrangeiras, bem como em muitas outras indústrias. </font><font style="vertical-align: inherit;">Brett espera escrever um dia sobre tudo isso no site dataspelunking.com, dedicado ao compartilhamento de conhecimento sobre como encontrar padrões nos dados.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre o Science Editor</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raghav Bali</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Raghav Bali) - pesquisador sênior de uma das maiores organizações de assistência médica do mundo. Ele se dedica à pesquisa e desenvolvimento de soluções corporativas baseadas em aprendizado de máquina, aprendizado profundo e processamento de linguagem natural para uso em saúde e seguros. Em sua posição anterior na Intel, ele participou de iniciativas proativas no campo da tecnologia da informação baseadas em big data, usando processamento de linguagem natural, aprendizado profundo e métodos estatísticos tradicionais. Na American Express, ele trabalhou em engajamento digital e retenção de clientes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav é o autor de vários livros publicados pelos principais editores. </font><font style="vertical-align: inherit;">Seu último livro é sobre o mais recente estudo de transferência. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raghav se formou no Instituto Internacional de Tecnologia da Informação em Bangalore, possui um mestrado (honras). </font><font style="vertical-align: inherit;">Nos raros momentos em que ele não está ocupado resolvendo problemas científicos, Raghav gosta de ler e fotografar tudo em sequência. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Mais informações sobre o livro podem ser encontradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no site da editora</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conteúdo</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trecho</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
do cupom Khabrozhiteley de 25% de desconto no cupom - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aprendizado de máquina</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Após o pagamento da versão impressa do livro, um livro eletrônico é enviado por e-mail.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt496242/index.html">O Cyberpunk já está aqui: crianças em idade escolar estudam no Minecraft e estudantes fazem testes físicos no CS: GO</a></li>
<li><a href="../pt496248/index.html">Desafios, carecas e vinho. Como nós da HFLabs enfrentamos o auto-isolamento</a></li>
<li><a href="../pt496250/index.html">Quão estranho código oculta erros? Análise do TensorFlow.NET</a></li>
<li><a href="../pt496252/index.html">Aeronaves de centragem aerodinamicamente offset</a></li>
<li><a href="../pt496254/index.html">Como a Rostelecom redirecionou por engano o tráfego para o Google, AWS, Cloudflare etc.</a></li>
<li><a href="../pt496258/index.html">Holivar online: um novo formato para a troca de experiências. Este sábado</a></li>
<li><a href="../pt496260/index.html">Dicas de segurança cibernética para trabalhar em casa</a></li>
<li><a href="../pt496262/index.html">Obtendo o ID do CVE</a></li>
<li><a href="../pt496266/index.html">Coronavírus: todos nós vamos morrer?</a></li>
<li><a href="../pt496268/index.html">Produtos e soluções de rede da Huawei Enterprise para clientes corporativos em 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>