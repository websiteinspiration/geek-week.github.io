<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§•ğŸ¿ ğŸ¤¦ğŸ¿ ğŸ§– Mentale reaktive Programmiermodelle fÃ¼r Supervisoren ğŸ‘¼ ğŸ¥– ğŸ™ŒğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel richtet sich an eine Vielzahl von Lesern, die wissen mÃ¶chten, was reaktive Programmierung ist. Der Zweck dieses Artikels besteht darin,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mentale reaktive Programmiermodelle fÃ¼r Supervisoren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel richtet sich an eine Vielzahl von Lesern, die wissen mÃ¶chten, was reaktive Programmierung ist. </font><font style="vertical-align: inherit;">Der Zweck dieses Artikels besteht darin, Ihre grundlegenden mentalen Modelle der reaktiven Programmierung (MM RP) zu erstellen, ohne auf technische Details einzugehen.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haftungsausschluss</font></font></b><div class="spoiler_text"> ( ) â€”    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber lassen Sie uns zunÃ¤chst erklÃ¤ren, was die in der Ãœberschrift des Artikels erwÃ¤hnten mentalen Modelle und Vorgesetzten damit zu tun haben ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ãœber mentale Modelle</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    Â«Â», Â«Â»     Â« Â»    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier sind die Chefs ...</font></font></b><div class="spoiler_text">        .            Â«Â»  Â«Â»     ,            :   . (  ,  Â«Â»    ,      ).<br>
  ,   Â«Â»  ,     ,      ,  ,    , . ,          .   Â«Â»        Â«Â».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () â€” ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum braucht Reactive Programming Ihr Projekt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Leute, die mit RP nicht vertraut sind, stehen ihm zunÃ¤chst skeptisch gegenÃ¼ber und vermuten, dass dies nur eine weitere leere Mode ist, die mit ein paar schÃ¶nen Worten bedeckt ist. </font><font style="vertical-align: inherit;">Besonders wenn sie lernen, dass man RP nur durch Ausprobieren bewerten kann. </font><font style="vertical-align: inherit;">Und es zu versuchen ist wegen der hohen Eintrittsschwelle teuer. </font><font style="vertical-align: inherit;">Wir haben mit OOP gelebt und gelebt, was fehlt daran? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich meinen Standpunkt zu diesem Thema vorstellen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn der Programmierung, als die meisten Programme direkt in Assemblersprache geschrieben wurden, war das Hauptarbeitskonzept (ein Element des mentalen Modells) der Programmierer eine Anweisung oder ein Sprachbefehl. Einige (primitive) Daten werden der Eingabe eines Befehls oder einer Anweisung zugefÃ¼hrt. Die Anweisung verarbeitet und gibt einige Ausgabedaten aus. Das Erscheinen der ersten prozeduralen Programmiersprachen wie Fortran Ã¤nderte nichts an der Essenz der Sache. Nur die Daten und die ausgefÃ¼hrten Operationen (als Folge von Elementarbefehlen) sind komplizierter geworden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Zeit wurde klar, dass dieses Konzept nicht sehr mit den RealitÃ¤ten der Welt Ã¼bereinstimmt. Es kann viele Daten geben, sie kÃ¶nnen schwierig zu strukturieren sein. Sowohl die Daten als auch die FunktionalitÃ¤t um sie herum wÃ¤ren schÃ¶n, in Teile aufzuteilen, separat zu entwickeln und zu warten und zusammen zu verwenden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP hat diese Probleme auf viele Arten gelÃ¶st. Die Einheit des mentalen Modells eines typischen OOP-Programmierers ist ein Objekt mit darin verborgenen (eingekapselten) Daten und einer Zugriffsschnittstelle auf diese Daten als eine Reihe von Funktionen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP hat eine groÃŸe Rolle bei der Automatisierung und Computerisierung vieler Fertigungs- und anderer Prozesse gespielt. Und damit wurden seine SchwÃ¤chen aufgedeckt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider gibt es in OOP kein Konzept fÃ¼r einen Prozess als solchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie versuchten, die Situation auf unterschiedliche Weise zu verbessern, wobei sie sich auf verschiedene Aspekte konzentrierten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wurden ereignisgesteuerte Programmierung [3], Datenflussprogrammierung [4], Stream-Verarbeitung [5] und mehrere andere Paradigmen geboren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wÃ¼rde es wagen, einen Strom von Kritik an den AnhÃ¤ngern und Experten dieser Paradigmen zu erregen und zu versuchen, in einfachen Worten ihr allgemeines Wesen zu vermitteln.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf die eine oder andere Weise arbeiten diese Paradigmen mit InformationsflÃ¼ssen. Gleichzeitig konzentriert sich die ereignisgesteuerte Programmierung, wie der Name schon sagt, auf den Prozess der Entstehung von Informationsflusselementen, die Datenflussprogrammierung - auf die Flusssteuerung (Aufteilen, ZusammenfÃ¼hren, Transformation von FlÃ¼ssen) und die Stream-Verarbeitung zur optimalen Nutzung von Ressourcen in VerarbeitungsflÃ¼ssen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reaktive Programmierung ist ungefÃ¤hr dasselbe, konzentriert sich jedoch auf die spezifischen elementaren Operationen zum Erstellen, Verwalten und Verwenden von Threads. Jene. RP beschreibt, wie Ihr System auf Elemente des Informationsflusses reagiert (Englisch reagiert). In diesem Sinne wÃ¤re es auf Russisch korrekter, den Begriff "Reagenzienprogrammierung" (vom Wort "reagieren") oder "Reaktionsprogrammierung" (vom Wort "Reaktion auf etwas") zu verwenden, wenn das Ohr nicht schneiden wÃ¼rde. und die zweite verursachte keine falschen Assoziationen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich wÃ¼rde es wagen, einen weiteren aufrÃ¼hrerischen Gedanken auszudrÃ¼cken. Was wir heute auf Englisch Reactive Programming (Reactive Programming) nennen. nannte dies aus historischen GrÃ¼nden und neigte zu diesem Begriff die Mehrheitsmeinung.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Paradigma hÃ¤tte anders heiÃŸen kÃ¶nnen. </font><font style="vertical-align: inherit;">Konzentrieren Sie sich daher nicht auf den aktuellen Namen, sondern versuchen Sie, dessen Wesen zu verstehen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und obwohl ich auf einer ziemlich abstrakten Ebene Ã¼ber RP sprechen werde, werde ich die RxJS-Bibliotheks-APIs als konkrete Beispiele anfÃ¼hren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Akronym RxJS steht fÃ¼r Reactive Extension fÃ¼r JavaScript, eine JavaScript-Erweiterung fÃ¼r Reactive Programming-Funktionen. </font><font style="vertical-align: inherit;">Ã„hnliche Erweiterungen gibt es fÃ¼r viele andere Programmiersprachen, wie im folgenden Bild aus [6] zu sehen ist.</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Reaktive Programmiererweiterungen"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum brauchen Mental Models of RP Ihr Projekt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GroÃŸe Projekte werden nicht alleine gemacht. Sie kÃ¶nnen oft lesen oder hÃ¶ren, dass die Projektteilnehmer dieselbe Sprache sprechen mÃ¼ssen. Meine Erfahrung zeigt, dass dies kaum notwendig und mÃ¶glich ist. Es ist jedoch erforderlich, dass die grundlegendsten Konzepte des Projekts von den Projektteilnehmern so gleichmÃ¤ÃŸig wie mÃ¶glich angegeben und verstanden werden. In Bezug auf mentale Modelle (MM) kÃ¶nnen wir sagen, dass MMs der oberen Ebene so Ã¤hnlich wie mÃ¶glich sein sollten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie kÃ¶nnen sie Ã¤hnlich sein, wenn Analysten in Bezug auf Workflow und AnwendungsfÃ¤lle, Architekten in Mustern, Entwickler in Funktionen und Datenstrukturen und Tester in Testszenarien denken?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fordere nicht alle diese Spezialisten auf, gleichzeitig mit den Kategorien der reaktiven Programmierung zu denken, aber ich kann ihnen versprechen, dass die Kenntnis dieser Kategorien die EffektivitÃ¤t ihrer professionellen Kommunikation mit Kollegen vereinfachen und steigern wird. </font><font style="vertical-align: inherit;">Dies sollte geschehen, weil MM-RPs einerseits die zur Beschreibung komplexer Workflows erforderliche Leistung besitzen und MM-RPs andererseits in vielen Programmiersprachen direkt in Code konvertiert werden kÃ¶nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ãœberraschungen, Gefahren oder solche in RP sind nicht so, wie wir es alle gewohnt sind </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir jedoch auf die Beschreibung der mentalen Modelle der reaktiven Programmierung eingehen, mÃ¶chte ich den Leser vor unseren eigenen Erfahrungen warnen, was nicht in ihnen enthalten ist. </font><font style="vertical-align: inherit;">DarÃ¼ber hinaus fÃ¼hrt nicht nur nicht, sondern die bloÃŸe Erwartung eines einfachen und verstÃ¤ndlichen OOP-Verhaltens in der Welt zu traurigen Konsequenzen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mache das nicht, um den Leser einzuschÃ¼chtern, sondern um ihn zu faszinieren.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 1: Anstelle eines Cursormodells ein Rechengraph</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mÃ¶chte vorschlagen, dass viele Leser, wenn sie Ã¼ber die nÃ¤chste zu realisierende Aufgabe nachdenken, ein mentales Modell im Kopf haben, das ich als Cursormodell bezeichne. </font><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass ein schrittweiser Algorithmus in Form einer linearen Liste von Anweisungen erfunden wird, um das Problem zu lÃ¶sen. </font><font style="vertical-align: inherit;">Die AusfÃ¼hrung des Algorithmus reduziert sich auf die schrittweise AusfÃ¼hrung der Anweisungen nacheinander. </font><font style="vertical-align: inherit;">Sie kÃ¶nnen sich so etwas wie einen Zeiger auf die aktuell ausgefÃ¼hrte Anweisung vorstellen. </font><font style="vertical-align: inherit;">Nachdem der Befehl ausgefÃ¼hrt wurde, bewegt sich der Zeiger (Cursor) zum nÃ¤chsten Befehl in der Liste und beginnt mit der AusfÃ¼hrung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb dieses Modells eine Folge von Befehlen, die in einer bedingten objektorientierten Programmiersprache geschrieben sind</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wird das Ergebnis geben</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Cursor-Mental-Modell sagt ein solches Ergebnis perfekt voraus und erklÃ¤rt es. </font><font style="vertical-align: inherit;">Nach der Verarbeitung der dritten Zeile wird der Wert X3 gesetzt und der in Zeile 5 angegebene neue Wert fÃ¼r X1 kann ihn nicht Ã¤ndern. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Welt von RP wird dies abhÃ¤ngig von der Interpretation der â€+â€œ - Operation hÃ¶chstwahrscheinlich das Ergebnis sein</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Welt verbinden die meisten Operationen Eingabeparameter miteinander, wodurch Berechnungsgraphen erstellt werden, durch die Berechnungen "verschoben" werden, wenn ein oder mehrere Parameter geÃ¤ndert werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 2: Asynchrone Operationen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen des Cursor-Mental-Berechnungsmodells kann die nÃ¤chste Operation nicht frÃ¼her als die vorherige beginnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie das folgende Beispiel. </font><font style="vertical-align: inherit;">Angenommen, die Funktion f1 berechnet das Grundgehalt anhand des Werts der Benutzer-ID userId, und die Funktion f2 berechnet den Bonus basierend auf der Benutzer-ID und dem Wert des Gehalts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kann die Berechnung des vollen Gehalts so aussehen</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, ein Mitarbeiter hat ein Grundgehalt von 10.000. </font><font style="vertical-align: inherit;">und ein Bonus von 1000 Einheiten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Cursor-Mental-Modell sagt Ihnen, was Sie drucken sollen.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider kann in der Welt der asynchronen RP das Ergebnis abhÃ¤ngig von der Betriebsdauer sein</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ausnahmen berÃ¼cksichtige ich noch nicht). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sache ist, dass in der asynchron-reaktiven Welt die nÃ¤chste Operation nicht auf das Ende der vorherigen wartet, wenn es die vorherige ist) asynchron. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu veranschaulichen, betrachten wir einige wichtige Details anhand des realistischen Beispiels in der folgenden Abbildung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt die AusfÃ¼hrungszeit von vier voneinander unabhÃ¤ngigen Befehlen L1, L2, L3 und L4 (ihre Nummern sind fÃ¼r uns wichtig, nicht die Schreibweise) im synchronen (oberer Teil des Bildes) und asynchronen (unterer Teil des Bildes) Modus.</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir sehen, "wartet" im ersten Fall jede nachfolgende Anweisung auf das Ende der vorherigen. </font><font style="vertical-align: inherit;">Im asynchronen Fall werden alle Anweisungen gleichzeitig ausgefÃ¼hrt. </font><font style="vertical-align: inherit;">Aufgrund der parallelen AusfÃ¼hrung und Verwendung von Ressourcen werden die meisten Anweisungen im asynchronen Modus lÃ¤nger ausgefÃ¼hrt als im synchronen Modus. </font><font style="vertical-align: inherit;">Gemeinsam werden sie ihre Arbeit jedoch frÃ¼her vererben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reihenfolge der AusfÃ¼hrung der Anweisungen in beiden Modi ist ebenfalls sehr unterschiedlich. </font><font style="vertical-align: inherit;">Synchron:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aber asynchron: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 3: UnvollstÃ¤ndige Ketten (ohne Verbraucher) funktionieren Ã¼berhaupt nicht</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielen traditionellen Programmiersprachen ist es Ã¼blich, Funktionsaufrufe oder Objekteigenschaften mit Punkten zu verknÃ¼pfen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende JavaScript-Funktionsaufrufkette verwandelt beispielsweise das Wort "gut" in "Hund":</font></font><br>
<pre><code class="javascript hljs">â€goodâ€œ.split(â€â€œ).reverse().join(â€â€œ).replace(â€ooâ€œ, â€oâ€œ);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequenzen (Ketten) kÃ¶nnen lang sein. </font><font style="vertical-align: inherit;">Aus GrÃ¼nden der Wiederverwendung oder ZweckmÃ¤ÃŸigkeit kÃ¶nnen sie in StÃ¼cke geschnitten und teilweise ausgefÃ¼hrt werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufteilen einer Kette in RP in zwei Teile und das Aufrufen nur eines davon fÃ¼hrt normalerweise zu einem Mangel an Ergebnissen, da nur die gesamte Kette (mit dem Verbraucher am Ende) ausgefÃ¼hrt wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum das alles?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich stellen sich viele Leser bereits die Frage: â€Sind sie nicht gemeinsam verrÃ¼ckt geworden, diese reaktiven Programmierer? Warum wird eine solche Programmierung benÃ¶tigt? â€œ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich nehme nicht an, vorherzusagen, was die SchÃ¶pfer und Experten der Republik Polen auf diese Frage beantworten wÃ¼rden, aber meine Antwort lautet: Eine solche Programmierung ist notwendig, weil sich viele Objekte der realen Welt einfach so verhalten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen von Grafiken</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - darauf baut Excel auf, worÃ¼ber sich nicht nur Buchhalter, sondern auch Projektmanager freuen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Operationen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie in Ihrer KÃ¼che Kaffee kochen oder Tee kochen, stehen Sie die ganze Zeit in der KÃ¼che und schauen sich Ihre Kaffeekanne oder Teekanne an? Nein. Das GerÃ¤t kocht Wasser und erledigt seine Arbeit, wÃ¤hrend Sie vorerst etwas anderes tun. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplette Betriebskette.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziehen Sie den Netzstecker aus der Steckdose und drÃ¼cken Sie den Schalter. </font><font style="vertical-align: inherit;">Die Lampe leuchtet hiervon nicht auf. </font><font style="vertical-align: inherit;">Dieses Objekt funktioniert nur, wenn es eine vollstÃ¤ndige Kette gibt - von der Quelle bis zum Stromverbraucher. </font><font style="vertical-align: inherit;">Und es gibt viele, wenn nicht die meisten solcher Objekte in der realen Welt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mÃ¶chte Ihnen versichern, dass Ihre Kenntnisse der traditionellen Programmierung und des Cursors MM aufgrund des Auftretens von RP nicht in den Papierkorb geworfen werden sollten. </font><font style="vertical-align: inherit;">Die reaktive Programmierung lieÃŸ sie in Ruhe und erweiterte sie um neue Operationen fÃ¼r neue Objekttypen. </font><font style="vertical-align: inherit;">Wie - wir werden spÃ¤ter darÃ¼ber sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Raum der mentalen Modellprogrammierung und der Platz von MM RP darin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf den Platz von RP in der allgemeinen Programmierlandschaft erwÃ¤hnen die Autoren hÃ¤ufig zwei Dimensionen - die KomplexitÃ¤t der verarbeiteten Objekte und die SynchronitÃ¤t / AsynchronitÃ¤t von Operationen. </font><font style="vertical-align: inherit;">Ein Beispiel fÃ¼r eine solche Klassifizierung finden Sie im Buch â€RxJS in Aktionâ€œ [7] im Kapitel â€Wann und wo RxJS verwendet werden sollâ€œ. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Klassifizierung wird die Dimension von Objekten in einzelne Objekte und mehrere Objekte unterteilt: Arrays, Listen usw. </font><font style="vertical-align: inherit;">Operationen werden in synchron und asynchron unterteilt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit unterteilt diese Klassifizierung die Programmierwelt in vier Bereiche. </font><font style="vertical-align: inherit;">RP ist einer dieser Bereiche, der fÃ¼r die Verarbeitung von Mehrfachobjekten mit asynchronen Operationen verantwortlich ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich finde diese Klassifizierung sehr interessant, mÃ¶chte sie aber unter dem Gesichtspunkt mentaler Modelle betrachten. </font><font style="vertical-align: inherit;">Die folgende Tabelle zeigt sie.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einzelwerte und Objekte</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass die mentalen Modelle von Anweisungen und der Cursor keiner weiteren ErklÃ¤rung bedÃ¼rfen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zyklus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Erweiterung der MM-Anweisungen und des Cursors aufgrund der zusÃ¤tzlichen Anweisungen des Zyklus oder der RÃ¼ckkehr zu einem bestimmten Punkt. Dies ermÃ¶glicht es einem Satz von Verarbeitungsanweisungen fÃ¼r ein einzelnes Objekt, in eine Schleife zu "wickeln" und dadurch viele solcher Objekte zu verarbeiten. In diesem Fall bewegt sich der Cursor wie im vorherigen Modell innerhalb des Zyklus und springt nach Erreichen des Ãœbergangspunkts entweder zum Anfang oder die Verarbeitung des Zyklus stoppt, wenn alle Objekte verarbeitet werden. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Unterschied zwischen diesem mentalen Modell und dem vorherigen besteht darin, dass der Cursor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, der auf das verarbeitete Objekt zeigt, an Ort und Stelle bleibt und die Objekte selbst darÃ¼ber â€laufenâ€œ.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns dies anhand von zwei Beispielen an. Wenn Sie einen Holzzaun streichen, gehen Sie analog zum Cursormodell von Brett zu Brett. Der Arbeiter auf dem FÃ¶rderer bleibt jedoch an Ort und Stelle, und analog zum Strahlmodell nÃ¤hern sich die zu verarbeitenden Teile ihm. Solche Objekte werden hÃ¤ufig mit dem Begriff English Stream bezeichnet, beispielsweise in der Java-Sprache. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semaphor.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieses MM ist am einfachsten mit einer Ampel an einer Kreuzung zu verknÃ¼pfen. Asynchrone Objekte fragen regelmÃ¤ÃŸig den Status einer Ã¶ffentlichen Variablen ab und fÃ¼hren bestimmte Aktionen aus, nachdem sie ihren Status geÃ¤ndert haben. (wie Fahrer vor einer Ampel) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine geeignete Metapher fÃ¼r dieses Modell der mentalen Erwartung ist der Brief auf Papier oder Emall, den Sie erwartet haben, als Sie zuletzt Ihren Job bekommen haben. Es kann eine positive oder negative Antwort geben. Ihr Verhalten nach Erhalt des Briefes hÃ¤ngt stark von dessen Inhalt ab. Der englische Begriff Promise wird hÃ¤ufig verwendet, um diese Art von Objekten zu beschreiben. Dies ist aus Sicht des Nutzers eine Erwartung, fÃ¼r den Auftragnehmer, der die Dienstleistungen erbringt, eher ein Versprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der Beschreibung hervorgeht, bedeutet Bewegung entlang jeder Dimension (von oben nach unten oder von rechts nach links in der Tabelle) eine qualitative Ã„nderung des mentalen Modells.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der Tabelle ersichtlich ist, sind die Jets und Erwartungen Nachbarn links und oben in der fÃ¼r uns interessanten sÃ¼dÃ¶stlichen Zelle. </font><font style="vertical-align: inherit;">Was ist neu in den mentalen Modellen von StrÃ¶mungen, die in der fÃ¼r uns interessanten Zelle leben, im Vergleich zu ihnen?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist die Erweiterung?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erweiterung von Streams im Vergleich zu Expectations besteht darin, dass die erwarteten Informationen nicht nur einmal, sondern in vielen Teilen eintreffen kÃ¶nnen. In diesem Fall kann der Prozess ohne Ende enden. Jene. Nach einer Reihe erfolgreicher Portionen erhalten wir eine Fehlerbenachrichtigung. ZusÃ¤tzlich wird eine weitere Version der Informationen hinzugefÃ¼gt - eine Benachrichtigung Ã¼ber das Ende des Prozesses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet zum Beispiel, dass es mÃ¶glich ist, mehrere (aber nicht alle) Teile der erwarteten Informationen und (ohne Fehlermeldung) eine Nachricht Ã¼ber das Ende der Verarbeitung zu empfangen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie noch einmal daran, dass wir beim Warten nur zwei alternative Optionen fÃ¼r die resultierenden Informationen haben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Mental Jet-Modell eignet sich gut, um den Prozess der Transformation einer Folge von Objekten desselben Typs zu verstehen, zu diskutieren und zu implementieren. MM Stream erweitert es um folgende Aspekte:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann viele Jets geben und wir kÃ¶nnen sie zusammenfÃ¼hren</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die DÃ¼sen kÃ¶nnen heterogen sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kÃ¶nnen die Jets nach verschiedenen Kriterien in neue aufteilen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir kÃ¶nnen sie im Rahmen eines Streams â€schlieÃŸenâ€œ und / oder in neue umwandeln. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir den Platz von MM RP (Streams) im Raum oder in der Landschaft der Objekte der Programmierung bestimmt. </font><font style="vertical-align: inherit;">Lassen Sie uns nun die Vogelperspektive senken und Streams und ihre mentalen Modelle genauer betrachten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams und Phasen ihres Lebenszyklus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In erster NÃ¤herung kÃ¶nnen RP-FlÃ¼sse als WasserflÃ¼sse in Wasserleitungen oder StromflÃ¼sse vorgestellt werden. </font><font style="vertical-align: inherit;">Es sei daran erinnert, dass diese Analogie wie jede andere Analogie ihre Grenzen hat und nicht immer anwendbar ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf den Fluss kÃ¶nnen folgende wichtige Aspekte unterschieden werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Thread entsteht irgendwie</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er bewegt sich irgendwie auf den Verbraucher zu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwegs passiert etwas mit ihm (er verwandelt sich)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann in mehrere Streams aufgeteilt oder mit anderen Streams zusammengefÃ¼hrt werden</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verbraucher nutzt den Fluss irgendwie und hÃ¶rt auf zu existieren.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aufgefÃ¼hrten Aspekte sind gleichzeitig Phasen des Lebenszyklus einzelner Elemente des Flusses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir sie am Beispiel der RxJS-Funktionen genauer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Erstellung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams kÃ¶nnen aus passiven Elementen wie einem Array oder einer Liste von Objekten in Ihrem Programm, Bytes, Dateizeilen usw. erstellt werden. Diese Art von Stromquellen wird als kalt bezeichnet (obwohl es technisch eine genauere Definition von kalten Stromquellen gibt). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sogenannten heiÃŸen Quellen "leben ihr eigenes Leben" und wenn Sie sich nicht rechtzeitig mit ihnen verbinden, gehen die Informationen verloren. Diese Kategorie enthÃ¤lt Informationen zu Benutzeraktionen auf einem Computer, Tablet oder Smartphone, z. B. Informationen zu TastenanschlÃ¤gen, Mausbewegungen oder zum BerÃ¼hren des Bildschirms. Ebenfalls in diese Kategorie fallen Daten, die von verschiedenen Protokollen wie HTTP angefordert werden, Daten von verschiedenen Sensoren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass es sogenannte â€warmeâ€œ Quellen gibt. </font><font style="vertical-align: inherit;">AuÃŸerdem kÃ¶nnen einige â€heiÃŸeâ€œ Quellen â€gekÃ¼hltâ€œ und â€kaltâ€œ â€aufgewÃ¤rmtâ€œ werden. </font><font style="vertical-align: inherit;">Aber darÃ¼ber sollten Sie in der Fachliteratur lesen, zum Beispiel im Buch [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FÃ¼r uns ist es wichtig zu wissen, dass alle VorgÃ¤nge zum Erstellen von Flows Objekte desselben Typs erstellen, die unabhÃ¤ngig vom Inhalt von denselben VorgÃ¤ngen weiterverarbeitet werden kÃ¶nnen. </font><font style="vertical-align: inherit;">In diesem Artikel nennen wir diese Objekte Streams. </font><font style="vertical-align: inherit;">Der entsprechende englische Name lautet Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbraucherbewegung und Flusstransformation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flow-TransformationsvorgÃ¤nge kÃ¶nnen sowohl auf dem Weg zum Verbraucher als auch von ihm selbst durchgefÃ¼hrt werden. </font><font style="vertical-align: inherit;">In beiden FÃ¤llen sind die VerarbeitungsvorgÃ¤nge der StrÃ¶mungselemente streng sequentiell, d.h. </font><font style="vertical-align: inherit;">Die nÃ¤chste Operation wird erst dann gestartet, wenn die vorherige abgeschlossen und das Ergebnis an sie weitergegeben wurde. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Stream, bei dem es sich in einigen Programmiersprachen um Sprachkonstrukte mit eigener Syntax und Semantik handelt, mÃ¼ssen reaktive Erweiterungen wie RxJS in JavaScript die Syntax und die grundlegende Semantik der erweiterbaren Sprache verwenden. </font><font style="vertical-align: inherit;">Daher implementiert RxJs die Funktion pipe (), in der Sie Funktionen aufrufen kÃ¶nnen - Handler sowohl des Streams selbst als auch seiner einzelnen Elemente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass nur spezielle, leitfÃ¤hige Funktionen Flow-Handler sein kÃ¶nnen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"DreiphasenstrÃ¶mung"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Analogie mit ElektrizitÃ¤t fortsetzen, kÃ¶nnen die FlÃ¼sse, die wir betrachten, als dreiphasig bezeichnet werden. Neben dem â€normalen Drahtâ€œ, der die Basisinformationen Ã¼bertrÃ¤gt, gibt es auch einen â€Fehlerdrahtâ€œ und einen â€Stromabschlussdrahtâ€œ. Mit TransformationsvorgÃ¤ngen kann das Objekt nicht nur geÃ¤ndert, sondern auch auf einen anderen â€Drahtâ€œ umgeleitet werden. Diese Technik wird beispielsweise verwendet, wenn mutmaÃŸliche Fehler bei der Arbeit mit Servern mithilfe des HTTP-Protokolls verarbeitet werden. Wenn beispielsweise ein Server nicht antwortet, kÃ¶nnen Sie versuchen, einen anderen anzufordern, ohne den Benutzer Ã¼ber den Fehler beim Anfordern des ersten Servers zu informieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein weiteres sehr wichtiges Element Ihres Mental Flow-Modells. </font><font style="vertical-align: inherit;">Wenn in herkÃ¶mmlichen Programmierparadigmen der Fehler von der Verarbeitungsfunktion als Fehlercode zurÃ¼ckgegeben wird oder als Unterbrechung (Ausnahme) abgefangen werden soll, "flieÃŸt" der Fehler in den FlÃ¼ssen unabhÃ¤ngig vom Hauptkanal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dort kann es verarbeitet werden. </font><font style="vertical-align: inherit;">Wenn ein Benutzer beispielsweise ein falsches Kennwort eingegeben hat, kann ihm zusÃ¤tzlich die MÃ¶glichkeit gegeben werden, es ein- oder mehrmals einzugeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flows aufteilen und zusammenfÃ¼hren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufteilung der StrÃ¶mungen erfolgt in zwei Schritten. In der ersten Phase werden leere Threads gestartet. Dann werden in der zweiten Stufe (Stromverarbeitungsstufe) in einer der Verarbeitungsfunktionen die Elemente analysiert und zum gewÃ¼nschten Strom umgeleitet. Technisch gibt es viele MÃ¶glichkeiten, dies zu tun. Entfernen Sie es beispielsweise aus dem aktuellen Thread oder klonen Sie es, bevor Sie es in einem neuen Thread starten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie kÃ¶nnen mehrere Streams auf Ã¼berraschend groÃŸe Weise zu einem zusammenfÃ¼hren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste MÃ¶glichkeit, die Ihnen in den Sinn kommt, besteht darin, sie in der Reihenfolge des Eingangs zusammenzufÃ¼hren, oder zuerst alle aus dem ersten Stream und dann alle aus dem zweiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die unten in der Abbildung gezeigte Methode ermÃ¶glicht es einem von zwei Streams, einen zu bilden, der geordnete Objektpaare aus dem ersten und zweiten Fluss enthÃ¤lt. </font><font style="vertical-align: inherit;">In diesem Fall wird ein neues Paar gebildet, wenn ein neues Element in einem der FlÃ¼sse erscheint. </font><font style="vertical-align: inherit;">A enthÃ¤lt ein Paar der streng letzten Elemente jedes Streams. </font><font style="vertical-align: inherit;">Dies fÃ¼hrt dazu, dass dasselbe Element in mehreren Paaren enthalten sein kann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in diesem Beispiel verwendete grafische Notation wird als Marmordiagramme bezeichnet und ist sehr effektiv bei der ErlÃ¤uterung der Semantik des Aufteilens und ZusammenfÃ¼hrens von FlÃ¼ssen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie an diesem Thema interessiert sind, empfehle ich Ihnen, die Operationen und ihre Marmordiagramme auf der Ressource zu studieren [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams verwenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Elemente des Streams verwenden zu kÃ¶nnen, muss der Benutzer oder Client ihn zuerst abonnieren. In der Regel sollte er sich am Ende der Verarbeitung abmelden, da Garbage Collectors ein Abonnement mÃ¶glicherweise nicht immer automatisch deaktivieren, wenn sie versuchen, einen Abonnenten zu nutzen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Clients kÃ¶nnen einen Thread abonnieren. In RxJs heiÃŸt die Abonnementfunktion subscribe (). In den meisten FÃ¤llen ist es ratsam, Verarbeitungsaufrufe der "normalen" Elemente des Streams, eines Fehlerhandlers und (relativ selten) eines Stream-Beendigungshandlers zu platzieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder der Abonnenten des Streams erhÃ¤lt seine Kopie des Elements oder einen Klon des ursprÃ¼nglichen Elements. </font><font style="vertical-align: inherit;">Um keine Probleme zu verursachen, wird der Stream so implementiert, dass die zur Verarbeitung empfangenen Elemente unverÃ¤nderlich werden. </font><font style="vertical-align: inherit;">In einigen Situationen kann diese EinschrÃ¤nkung immer noch umgangen werden, es ist jedoch besser, dies nicht zu tun.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GefÃ¤hrlicher Charme der BÃ¤che</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind sehr komplizierte Objekte, die Integralen in der Mathematik Ã¤hneln. Es ist eine Sache zu wissen, dass sie existieren und sich sogar grob vorzustellen, was es ist, und eine ganz andere, sie nutzen zu kÃ¶nnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das VerstÃ¤ndnis der internen Logik ihrer Funktionsweise, die erforderlich ist, um sie in der Praxis gut anzuwenden, erfordert erhebliche intellektuelle Anstrengungen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind eng mit der funktionalen Programmierung verbunden. FÃ¼r die ordnungsgemÃ¤ÃŸe Verwendung von Threads ist es hilfreich zu verstehen, wie Sie Funktionen zweiter Ordnung erstellen und anwenden kÃ¶nnen - Funktionen, die andere Funktionen als Argumente haben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wird Ihnen die SchÃ¶nheit und Eleganz der FlÃ¼sse vollstÃ¤ndig offenbart. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind ansteckend. Nachdem ich ihre SchÃ¶nheit verstanden habe, mÃ¶chte ich sie fÃ¼r alle Aufgaben verwenden, was natÃ¼rlich nicht notwendig ist.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei welchen Aufgaben es ratsam ist, Flows zu verwenden und wo traditionelle Methoden angewendet werden sollten, entscheidet jeder fÃ¼r sich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel habe ich versucht, Ihnen etwas Ã¼ber die mentalen Modelle der reaktiven Programmierung (MM RP) zu erzÃ¤hlen und sie sogar teilweise in Ihr Bewusstsein aufzunehmen. </font><font style="vertical-align: inherit;">Lassen Sie uns die wichtigsten Punkte noch einmal wiederholen.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP sind etwas Besonderes, das den mentalen Modellen der traditionellen Programmierung nicht Ã¤hnlich ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit der reaktiven Programmierung beginnen, mÃ¼ssen wir uns daran erinnern, dass einige in anderen Bereichen des MM gut etablierte Bereiche wie Cursor, Aufrufketten oder Schleifen nicht funktionieren oder nicht so funktionieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das mentale Hauptmodell von RP ist ein "Dreikanal-Stream" mit einem Kanal fÃ¼r "normale" Elemente, Fehler und Informationen Ã¼ber das Ende des Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams kÃ¶nnen endlich und unendlich sein.</font></font></li>
<li>    Â«Â», Â«Â»  Â«Â» .   Â«Â»  Â«Â». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  Â«Â».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie an diesem Thema interessiert sind, kÃ¶nnen Sie mit den auf der Site verfÃ¼gbaren Simulatoren [8] mit Streams "spielen". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Konzepte von RP besser verstehen mÃ¶chten, empfehle ich Ihnen, das Buch [7] durchzuarbeiten und sich natÃ¼rlich mit The Reactive Manifesto [11] vertraut zu machen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie erreichen die nÃ¤chste Stufe bei der Bildung Ihres eigenen MM-RP, indem Sie die BÃ¼cher [9] und [10] Ã¼ber den Entwurf und die Modellierung reaktiver Systeme durcharbeiten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur und Referenzen</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmierung ist die Materialisierung von Ideen. </font><font style="vertical-align: inherit;">(Artikel auf Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reifizierung als Paradigma der Softwareentwicklung. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ereignisgesteuerte Programmierung. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. â€“ 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486614/index.html">Warum eSIM benÃ¶tigt wird. Wie es funktioniert und warum sie so viel darÃ¼ber reden</a></li>
<li><a href="../de486622/index.html">Paralleles Rechenmodell</a></li>
<li><a href="../de486626/index.html">Svelte: Aktionen kennenlernen</a></li>
<li><a href="../de486628/index.html">Der Abstand zwischen Ticks auf einer Achse im Gnuplot wurde korrigiert</a></li>
<li><a href="../de486630/index.html">â€Nicht ins Auge flackernâ€œ: Wie die Technologie der Bildschirmbeleuchtung elektronischer LesegerÃ¤te angeordnet ist</a></li>
<li><a href="../de486634/index.html">MSVC-Backend-Updates in Visual Studio 2019, Version 16.3 und 16.4</a></li>
<li><a href="../de486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 ist jetzt verfÃ¼gbar</a></li>
<li><a href="../de486640/index.html">Die Zusammenfassung interessanter Materialien fÃ¼r den mobilen Entwickler # 331 (27. Januar - 2. Februar)</a></li>
<li><a href="../de486644/index.html">DIY Antenne in 5 Minuten</a></li>
<li><a href="../de486646/index.html">Geh weg von jQuery nach Svelte, ohne Schmerzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>