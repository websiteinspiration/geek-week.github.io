<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧕🏿 🤦🏿 🧖 Mentale reaktive Programmiermodelle für Supervisoren 👼 🥖 🙌🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel richtet sich an eine Vielzahl von Lesern, die wissen möchten, was reaktive Programmierung ist. Der Zweck dieses Artikels besteht darin,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mentale reaktive Programmiermodelle für Supervisoren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Artikel richtet sich an eine Vielzahl von Lesern, die wissen möchten, was reaktive Programmierung ist. </font><font style="vertical-align: inherit;">Der Zweck dieses Artikels besteht darin, Ihre grundlegenden mentalen Modelle der reaktiven Programmierung (MM RP) zu erstellen, ohne auf technische Details einzugehen.</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haftungsausschluss</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber lassen Sie uns zunächst erklären, was die in der Überschrift des Artikels erwähnten mentalen Modelle und Vorgesetzten damit zu tun haben ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über mentale Modelle</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier sind die Chefs ...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum braucht Reactive Programming Ihr Projekt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Leute, die mit RP nicht vertraut sind, stehen ihm zunächst skeptisch gegenüber und vermuten, dass dies nur eine weitere leere Mode ist, die mit ein paar schönen Worten bedeckt ist. </font><font style="vertical-align: inherit;">Besonders wenn sie lernen, dass man RP nur durch Ausprobieren bewerten kann. </font><font style="vertical-align: inherit;">Und es zu versuchen ist wegen der hohen Eintrittsschwelle teuer. </font><font style="vertical-align: inherit;">Wir haben mit OOP gelebt und gelebt, was fehlt daran? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie mich meinen Standpunkt zu diesem Thema vorstellen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn der Programmierung, als die meisten Programme direkt in Assemblersprache geschrieben wurden, war das Hauptarbeitskonzept (ein Element des mentalen Modells) der Programmierer eine Anweisung oder ein Sprachbefehl. Einige (primitive) Daten werden der Eingabe eines Befehls oder einer Anweisung zugeführt. Die Anweisung verarbeitet und gibt einige Ausgabedaten aus. Das Erscheinen der ersten prozeduralen Programmiersprachen wie Fortran änderte nichts an der Essenz der Sache. Nur die Daten und die ausgeführten Operationen (als Folge von Elementarbefehlen) sind komplizierter geworden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Laufe der Zeit wurde klar, dass dieses Konzept nicht sehr mit den Realitäten der Welt übereinstimmt. Es kann viele Daten geben, sie können schwierig zu strukturieren sein. Sowohl die Daten als auch die Funktionalität um sie herum wären schön, in Teile aufzuteilen, separat zu entwickeln und zu warten und zusammen zu verwenden.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP hat diese Probleme auf viele Arten gelöst. Die Einheit des mentalen Modells eines typischen OOP-Programmierers ist ein Objekt mit darin verborgenen (eingekapselten) Daten und einer Zugriffsschnittstelle auf diese Daten als eine Reihe von Funktionen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOP hat eine große Rolle bei der Automatisierung und Computerisierung vieler Fertigungs- und anderer Prozesse gespielt. Und damit wurden seine Schwächen aufgedeckt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider gibt es in OOP kein Konzept für einen Prozess als solchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie versuchten, die Situation auf unterschiedliche Weise zu verbessern, wobei sie sich auf verschiedene Aspekte konzentrierten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So wurden ereignisgesteuerte Programmierung [3], Datenflussprogrammierung [4], Stream-Verarbeitung [5] und mehrere andere Paradigmen geboren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde es wagen, einen Strom von Kritik an den Anhängern und Experten dieser Paradigmen zu erregen und zu versuchen, in einfachen Worten ihr allgemeines Wesen zu vermitteln.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf die eine oder andere Weise arbeiten diese Paradigmen mit Informationsflüssen. Gleichzeitig konzentriert sich die ereignisgesteuerte Programmierung, wie der Name schon sagt, auf den Prozess der Entstehung von Informationsflusselementen, die Datenflussprogrammierung - auf die Flusssteuerung (Aufteilen, Zusammenführen, Transformation von Flüssen) und die Stream-Verarbeitung zur optimalen Nutzung von Ressourcen in Verarbeitungsflüssen.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reaktive Programmierung ist ungefähr dasselbe, konzentriert sich jedoch auf die spezifischen elementaren Operationen zum Erstellen, Verwalten und Verwenden von Threads. Jene. RP beschreibt, wie Ihr System auf Elemente des Informationsflusses reagiert (Englisch reagiert). In diesem Sinne wäre es auf Russisch korrekter, den Begriff "Reagenzienprogrammierung" (vom Wort "reagieren") oder "Reaktionsprogrammierung" (vom Wort "Reaktion auf etwas") zu verwenden, wenn das Ohr nicht schneiden würde. und die zweite verursachte keine falschen Assoziationen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich würde es wagen, einen weiteren aufrührerischen Gedanken auszudrücken. Was wir heute auf Englisch Reactive Programming (Reactive Programming) nennen. nannte dies aus historischen Gründen und neigte zu diesem Begriff die Mehrheitsmeinung.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Paradigma hätte anders heißen können. </font><font style="vertical-align: inherit;">Konzentrieren Sie sich daher nicht auf den aktuellen Namen, sondern versuchen Sie, dessen Wesen zu verstehen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und obwohl ich auf einer ziemlich abstrakten Ebene über RP sprechen werde, werde ich die RxJS-Bibliotheks-APIs als konkrete Beispiele anführen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Akronym RxJS steht für Reactive Extension für JavaScript, eine JavaScript-Erweiterung für Reactive Programming-Funktionen. </font><font style="vertical-align: inherit;">Ähnliche Erweiterungen gibt es für viele andere Programmiersprachen, wie im folgenden Bild aus [6] zu sehen ist.</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="Reaktive Programmiererweiterungen"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum brauchen Mental Models of RP Ihr Projekt?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Große Projekte werden nicht alleine gemacht. Sie können oft lesen oder hören, dass die Projektteilnehmer dieselbe Sprache sprechen müssen. Meine Erfahrung zeigt, dass dies kaum notwendig und möglich ist. Es ist jedoch erforderlich, dass die grundlegendsten Konzepte des Projekts von den Projektteilnehmern so gleichmäßig wie möglich angegeben und verstanden werden. In Bezug auf mentale Modelle (MM) können wir sagen, dass MMs der oberen Ebene so ähnlich wie möglich sein sollten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber wie können sie ähnlich sein, wenn Analysten in Bezug auf Workflow und Anwendungsfälle, Architekten in Mustern, Entwickler in Funktionen und Datenstrukturen und Tester in Testszenarien denken?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich fordere nicht alle diese Spezialisten auf, gleichzeitig mit den Kategorien der reaktiven Programmierung zu denken, aber ich kann ihnen versprechen, dass die Kenntnis dieser Kategorien die Effektivität ihrer professionellen Kommunikation mit Kollegen vereinfachen und steigern wird. </font><font style="vertical-align: inherit;">Dies sollte geschehen, weil MM-RPs einerseits die zur Beschreibung komplexer Workflows erforderliche Leistung besitzen und MM-RPs andererseits in vielen Programmiersprachen direkt in Code konvertiert werden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überraschungen, Gefahren oder solche in RP sind nicht so, wie wir es alle gewohnt sind </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir jedoch auf die Beschreibung der mentalen Modelle der reaktiven Programmierung eingehen, möchte ich den Leser vor unseren eigenen Erfahrungen warnen, was nicht in ihnen enthalten ist. </font><font style="vertical-align: inherit;">Darüber hinaus führt nicht nur nicht, sondern die bloße Erwartung eines einfachen und verständlichen OOP-Verhaltens in der Welt zu traurigen Konsequenzen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mache das nicht, um den Leser einzuschüchtern, sondern um ihn zu faszinieren.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 1: Anstelle eines Cursormodells ein Rechengraph</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte vorschlagen, dass viele Leser, wenn sie über die nächste zu realisierende Aufgabe nachdenken, ein mentales Modell im Kopf haben, das ich als Cursormodell bezeichne. </font><font style="vertical-align: inherit;">Es wird davon ausgegangen, dass ein schrittweiser Algorithmus in Form einer linearen Liste von Anweisungen erfunden wird, um das Problem zu lösen. </font><font style="vertical-align: inherit;">Die Ausführung des Algorithmus reduziert sich auf die schrittweise Ausführung der Anweisungen nacheinander. </font><font style="vertical-align: inherit;">Sie können sich so etwas wie einen Zeiger auf die aktuell ausgeführte Anweisung vorstellen. </font><font style="vertical-align: inherit;">Nachdem der Befehl ausgeführt wurde, bewegt sich der Zeiger (Cursor) zum nächsten Befehl in der Liste und beginnt mit der Ausführung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Innerhalb dieses Modells eine Folge von Befehlen, die in einer bedingten objektorientierten Programmiersprache geschrieben sind</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wird das Ergebnis geben</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Cursor-Mental-Modell sagt ein solches Ergebnis perfekt voraus und erklärt es. </font><font style="vertical-align: inherit;">Nach der Verarbeitung der dritten Zeile wird der Wert X3 gesetzt und der in Zeile 5 angegebene neue Wert für X1 kann ihn nicht ändern. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Welt von RP wird dies abhängig von der Interpretation der „+“ - Operation höchstwahrscheinlich das Ergebnis sein</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Welt verbinden die meisten Operationen Eingabeparameter miteinander, wodurch Berechnungsgraphen erstellt werden, durch die Berechnungen "verschoben" werden, wenn ein oder mehrere Parameter geändert werden.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 2: Asynchrone Operationen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen des Cursor-Mental-Berechnungsmodells kann die nächste Operation nicht früher als die vorherige beginnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie das folgende Beispiel. </font><font style="vertical-align: inherit;">Angenommen, die Funktion f1 berechnet das Grundgehalt anhand des Werts der Benutzer-ID userId, und die Funktion f2 berechnet den Bonus basierend auf der Benutzer-ID und dem Wert des Gehalts. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann kann die Berechnung des vollen Gehalts so aussehen</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, ein Mitarbeiter hat ein Grundgehalt von 10.000. </font><font style="vertical-align: inherit;">und ein Bonus von 1000 Einheiten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser Cursor-Mental-Modell sagt Ihnen, was Sie drucken sollen.</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider kann in der Welt der asynchronen RP das Ergebnis abhängig von der Betriebsdauer sein</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Ausnahmen berücksichtige ich noch nicht). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sache ist, dass in der asynchron-reaktiven Welt die nächste Operation nicht auf das Ende der vorherigen wartet, wenn es die vorherige ist) asynchron. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies zu veranschaulichen, betrachten wir einige wichtige Details anhand des realistischen Beispiels in der folgenden Abbildung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Bild zeigt die Ausführungszeit von vier voneinander unabhängigen Befehlen L1, L2, L3 und L4 (ihre Nummern sind für uns wichtig, nicht die Schreibweise) im synchronen (oberer Teil des Bildes) und asynchronen (unterer Teil des Bildes) Modus.</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir sehen, "wartet" im ersten Fall jede nachfolgende Anweisung auf das Ende der vorherigen. </font><font style="vertical-align: inherit;">Im asynchronen Fall werden alle Anweisungen gleichzeitig ausgeführt. </font><font style="vertical-align: inherit;">Aufgrund der parallelen Ausführung und Verwendung von Ressourcen werden die meisten Anweisungen im asynchronen Modus länger ausgeführt als im synchronen Modus. </font><font style="vertical-align: inherit;">Gemeinsam werden sie ihre Arbeit jedoch früher vererben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Reihenfolge der Ausführung der Anweisungen in beiden Modi ist ebenfalls sehr unterschiedlich. </font><font style="vertical-align: inherit;">Synchron:</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aber asynchron: </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterschied 3: Unvollständige Ketten (ohne Verbraucher) funktionieren überhaupt nicht</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielen traditionellen Programmiersprachen ist es üblich, Funktionsaufrufe oder Objekteigenschaften mit Punkten zu verknüpfen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die folgende JavaScript-Funktionsaufrufkette verwandelt beispielsweise das Wort "gut" in "Hund":</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sequenzen (Ketten) können lang sein. </font><font style="vertical-align: inherit;">Aus Gründen der Wiederverwendung oder Zweckmäßigkeit können sie in Stücke geschnitten und teilweise ausgeführt werden. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Aufteilen einer Kette in RP in zwei Teile und das Aufrufen nur eines davon führt normalerweise zu einem Mangel an Ergebnissen, da nur die gesamte Kette (mit dem Verbraucher am Ende) ausgeführt wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum das alles?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich stellen sich viele Leser bereits die Frage: „Sind sie nicht gemeinsam verrückt geworden, diese reaktiven Programmierer? Warum wird eine solche Programmierung benötigt? “ </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich nehme nicht an, vorherzusagen, was die Schöpfer und Experten der Republik Polen auf diese Frage beantworten würden, aber meine Antwort lautet: Eine solche Programmierung ist notwendig, weil sich viele Objekte der realen Welt einfach so verhalten. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berechnen von Grafiken</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - darauf baut Excel auf, worüber sich nicht nur Buchhalter, sondern auch Projektmanager freuen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchrone Operationen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wenn Sie in Ihrer Küche Kaffee kochen oder Tee kochen, stehen Sie die ganze Zeit in der Küche und schauen sich Ihre Kaffeekanne oder Teekanne an? Nein. Das Gerät kocht Wasser und erledigt seine Arbeit, während Sie vorerst etwas anderes tun. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komplette Betriebskette.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ziehen Sie den Netzstecker aus der Steckdose und drücken Sie den Schalter. </font><font style="vertical-align: inherit;">Die Lampe leuchtet hiervon nicht auf. </font><font style="vertical-align: inherit;">Dieses Objekt funktioniert nur, wenn es eine vollständige Kette gibt - von der Quelle bis zum Stromverbraucher. </font><font style="vertical-align: inherit;">Und es gibt viele, wenn nicht die meisten solcher Objekte in der realen Welt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte Ihnen versichern, dass Ihre Kenntnisse der traditionellen Programmierung und des Cursors MM aufgrund des Auftretens von RP nicht in den Papierkorb geworfen werden sollten. </font><font style="vertical-align: inherit;">Die reaktive Programmierung ließ sie in Ruhe und erweiterte sie um neue Operationen für neue Objekttypen. </font><font style="vertical-align: inherit;">Wie - wir werden später darüber sprechen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Raum der mentalen Modellprogrammierung und der Platz von MM RP darin</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf den Platz von RP in der allgemeinen Programmierlandschaft erwähnen die Autoren häufig zwei Dimensionen - die Komplexität der verarbeiteten Objekte und die Synchronität / Asynchronität von Operationen. </font><font style="vertical-align: inherit;">Ein Beispiel für eine solche Klassifizierung finden Sie im Buch „RxJS in Aktion“ [7] im Kapitel „Wann und wo RxJS verwendet werden soll“. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dieser Klassifizierung wird die Dimension von Objekten in einzelne Objekte und mehrere Objekte unterteilt: Arrays, Listen usw. </font><font style="vertical-align: inherit;">Operationen werden in synchron und asynchron unterteilt. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit unterteilt diese Klassifizierung die Programmierwelt in vier Bereiche. </font><font style="vertical-align: inherit;">RP ist einer dieser Bereiche, der für die Verarbeitung von Mehrfachobjekten mit asynchronen Operationen verantwortlich ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich finde diese Klassifizierung sehr interessant, möchte sie aber unter dem Gesichtspunkt mentaler Modelle betrachten. </font><font style="vertical-align: inherit;">Die folgende Tabelle zeigt sie.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einzelwerte und Objekte</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass die mentalen Modelle von Anweisungen und der Cursor keiner weiteren Erklärung bedürfen. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zyklus</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist eine Erweiterung der MM-Anweisungen und des Cursors aufgrund der zusätzlichen Anweisungen des Zyklus oder der Rückkehr zu einem bestimmten Punkt. Dies ermöglicht es einem Satz von Verarbeitungsanweisungen für ein einzelnes Objekt, in eine Schleife zu "wickeln" und dadurch viele solcher Objekte zu verarbeiten. In diesem Fall bewegt sich der Cursor wie im vorherigen Modell innerhalb des Zyklus und springt nach Erreichen des Übergangspunkts entweder zum Anfang oder die Verarbeitung des Zyklus stoppt, wenn alle Objekte verarbeitet werden. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jet.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Der Unterschied zwischen diesem mentalen Modell und dem vorherigen besteht darin, dass der Cursor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
, der auf das verarbeitete Objekt zeigt, an Ort und Stelle bleibt und die Objekte selbst darüber „laufen“.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns dies anhand von zwei Beispielen an. Wenn Sie einen Holzzaun streichen, gehen Sie analog zum Cursormodell von Brett zu Brett. Der Arbeiter auf dem Förderer bleibt jedoch an Ort und Stelle, und analog zum Strahlmodell nähern sich die zu verarbeitenden Teile ihm. Solche Objekte werden häufig mit dem Begriff English Stream bezeichnet, beispielsweise in der Java-Sprache. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Semaphor.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieses MM ist am einfachsten mit einer Ampel an einer Kreuzung zu verknüpfen. Asynchrone Objekte fragen regelmäßig den Status einer öffentlichen Variablen ab und führen bestimmte Aktionen aus, nachdem sie ihren Status geändert haben. (wie Fahrer vor einer Ampel) </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warten.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine geeignete Metapher für dieses Modell der mentalen Erwartung ist der Brief auf Papier oder Emall, den Sie erwartet haben, als Sie zuletzt Ihren Job bekommen haben. Es kann eine positive oder negative Antwort geben. Ihr Verhalten nach Erhalt des Briefes hängt stark von dessen Inhalt ab. Der englische Begriff Promise wird häufig verwendet, um diese Art von Objekten zu beschreiben. Dies ist aus Sicht des Nutzers eine Erwartung, für den Auftragnehmer, der die Dienstleistungen erbringt, eher ein Versprechen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der Beschreibung hervorgeht, bedeutet Bewegung entlang jeder Dimension (von oben nach unten oder von rechts nach links in der Tabelle) eine qualitative Änderung des mentalen Modells.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie aus der Tabelle ersichtlich ist, sind die Jets und Erwartungen Nachbarn links und oben in der für uns interessanten südöstlichen Zelle. </font><font style="vertical-align: inherit;">Was ist neu in den mentalen Modellen von Strömungen, die in der für uns interessanten Zelle leben, im Vergleich zu ihnen?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was ist die Erweiterung?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erweiterung von Streams im Vergleich zu Expectations besteht darin, dass die erwarteten Informationen nicht nur einmal, sondern in vielen Teilen eintreffen können. In diesem Fall kann der Prozess ohne Ende enden. Jene. Nach einer Reihe erfolgreicher Portionen erhalten wir eine Fehlerbenachrichtigung. Zusätzlich wird eine weitere Version der Informationen hinzugefügt - eine Benachrichtigung über das Ende des Prozesses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet zum Beispiel, dass es möglich ist, mehrere (aber nicht alle) Teile der erwarteten Informationen und (ohne Fehlermeldung) eine Nachricht über das Ende der Verarbeitung zu empfangen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Denken Sie noch einmal daran, dass wir beim Warten nur zwei alternative Optionen für die resultierenden Informationen haben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Mental Jet-Modell eignet sich gut, um den Prozess der Transformation einer Folge von Objekten desselben Typs zu verstehen, zu diskutieren und zu implementieren. MM Stream erweitert es um folgende Aspekte:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann viele Jets geben und wir können sie zusammenführen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Düsen können heterogen sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Jets nach verschiedenen Kriterien in neue aufteilen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können sie im Rahmen eines Streams „schließen“ und / oder in neue umwandeln. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also haben wir den Platz von MM RP (Streams) im Raum oder in der Landschaft der Objekte der Programmierung bestimmt. </font><font style="vertical-align: inherit;">Lassen Sie uns nun die Vogelperspektive senken und Streams und ihre mentalen Modelle genauer betrachten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams und Phasen ihres Lebenszyklus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In erster Näherung können RP-Flüsse als Wasserflüsse in Wasserleitungen oder Stromflüsse vorgestellt werden. </font><font style="vertical-align: inherit;">Es sei daran erinnert, dass diese Analogie wie jede andere Analogie ihre Grenzen hat und nicht immer anwendbar ist. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Bezug auf den Fluss können folgende wichtige Aspekte unterschieden werden:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jeder Thread entsteht irgendwie</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Er bewegt sich irgendwie auf den Verbraucher zu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterwegs passiert etwas mit ihm (er verwandelt sich)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es kann in mehrere Streams aufgeteilt oder mit anderen Streams zusammengeführt werden</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Verbraucher nutzt den Fluss irgendwie und hört auf zu existieren.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die aufgeführten Aspekte sind gleichzeitig Phasen des Lebenszyklus einzelner Elemente des Flusses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir sie am Beispiel der RxJS-Funktionen genauer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Erstellung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams können aus passiven Elementen wie einem Array oder einer Liste von Objekten in Ihrem Programm, Bytes, Dateizeilen usw. erstellt werden. Diese Art von Stromquellen wird als kalt bezeichnet (obwohl es technisch eine genauere Definition von kalten Stromquellen gibt). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die sogenannten heißen Quellen "leben ihr eigenes Leben" und wenn Sie sich nicht rechtzeitig mit ihnen verbinden, gehen die Informationen verloren. Diese Kategorie enthält Informationen zu Benutzeraktionen auf einem Computer, Tablet oder Smartphone, z. B. Informationen zu Tastenanschlägen, Mausbewegungen oder zum Berühren des Bildschirms. Ebenfalls in diese Kategorie fallen Daten, die von verschiedenen Protokollen wie HTTP angefordert werden, Daten von verschiedenen Sensoren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass es sogenannte „warme“ Quellen gibt. </font><font style="vertical-align: inherit;">Außerdem können einige „heiße“ Quellen „gekühlt“ und „kalt“ „aufgewärmt“ werden. </font><font style="vertical-align: inherit;">Aber darüber sollten Sie in der Fachliteratur lesen, zum Beispiel im Buch [7]. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für uns ist es wichtig zu wissen, dass alle Vorgänge zum Erstellen von Flows Objekte desselben Typs erstellen, die unabhängig vom Inhalt von denselben Vorgängen weiterverarbeitet werden können. </font><font style="vertical-align: inherit;">In diesem Artikel nennen wir diese Objekte Streams. </font><font style="vertical-align: inherit;">Der entsprechende englische Name lautet Observable.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbraucherbewegung und Flusstransformation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flow-Transformationsvorgänge können sowohl auf dem Weg zum Verbraucher als auch von ihm selbst durchgeführt werden. </font><font style="vertical-align: inherit;">In beiden Fällen sind die Verarbeitungsvorgänge der Strömungselemente streng sequentiell, d.h. </font><font style="vertical-align: inherit;">Die nächste Operation wird erst dann gestartet, wenn die vorherige abgeschlossen und das Ergebnis an sie weitergegeben wurde. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Gegensatz zu Stream, bei dem es sich in einigen Programmiersprachen um Sprachkonstrukte mit eigener Syntax und Semantik handelt, müssen reaktive Erweiterungen wie RxJS in JavaScript die Syntax und die grundlegende Semantik der erweiterbaren Sprache verwenden. </font><font style="vertical-align: inherit;">Daher implementiert RxJs die Funktion pipe (), in der Sie Funktionen aufrufen können - Handler sowohl des Streams selbst als auch seiner einzelnen Elemente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist wichtig zu beachten, dass nur spezielle, leitfähige Funktionen Flow-Handler sein können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Dreiphasenströmung"</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Analogie mit Elektrizität fortsetzen, können die Flüsse, die wir betrachten, als dreiphasig bezeichnet werden. Neben dem „normalen Draht“, der die Basisinformationen überträgt, gibt es auch einen „Fehlerdraht“ und einen „Stromabschlussdraht“. Mit Transformationsvorgängen kann das Objekt nicht nur geändert, sondern auch auf einen anderen „Draht“ umgeleitet werden. Diese Technik wird beispielsweise verwendet, wenn mutmaßliche Fehler bei der Arbeit mit Servern mithilfe des HTTP-Protokolls verarbeitet werden. Wenn beispielsweise ein Server nicht antwortet, können Sie versuchen, einen anderen anzufordern, ohne den Benutzer über den Fehler beim Anfordern des ersten Servers zu informieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein weiteres sehr wichtiges Element Ihres Mental Flow-Modells. </font><font style="vertical-align: inherit;">Wenn in herkömmlichen Programmierparadigmen der Fehler von der Verarbeitungsfunktion als Fehlercode zurückgegeben wird oder als Unterbrechung (Ausnahme) abgefangen werden soll, "fließt" der Fehler in den Flüssen unabhängig vom Hauptkanal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dort kann es verarbeitet werden. </font><font style="vertical-align: inherit;">Wenn ein Benutzer beispielsweise ein falsches Kennwort eingegeben hat, kann ihm zusätzlich die Möglichkeit gegeben werden, es ein- oder mehrmals einzugeben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flows aufteilen und zusammenführen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aufteilung der Strömungen erfolgt in zwei Schritten. In der ersten Phase werden leere Threads gestartet. Dann werden in der zweiten Stufe (Stromverarbeitungsstufe) in einer der Verarbeitungsfunktionen die Elemente analysiert und zum gewünschten Strom umgeleitet. Technisch gibt es viele Möglichkeiten, dies zu tun. Entfernen Sie es beispielsweise aus dem aktuellen Thread oder klonen Sie es, bevor Sie es in einem neuen Thread starten. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können mehrere Streams auf überraschend große Weise zu einem zusammenführen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Möglichkeit, die Ihnen in den Sinn kommt, besteht darin, sie in der Reihenfolge des Eingangs zusammenzuführen, oder zuerst alle aus dem ersten Stream und dann alle aus dem zweiten.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die unten in der Abbildung gezeigte Methode ermöglicht es einem von zwei Streams, einen zu bilden, der geordnete Objektpaare aus dem ersten und zweiten Fluss enthält. </font><font style="vertical-align: inherit;">In diesem Fall wird ein neues Paar gebildet, wenn ein neues Element in einem der Flüsse erscheint. </font><font style="vertical-align: inherit;">A enthält ein Paar der streng letzten Elemente jedes Streams. </font><font style="vertical-align: inherit;">Dies führt dazu, dass dasselbe Element in mehreren Paaren enthalten sein kann. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die in diesem Beispiel verwendete grafische Notation wird als Marmordiagramme bezeichnet und ist sehr effektiv bei der Erläuterung der Semantik des Aufteilens und Zusammenführens von Flüssen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie an diesem Thema interessiert sind, empfehle ich Ihnen, die Operationen und ihre Marmordiagramme auf der Ressource zu studieren [8].</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams verwenden</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Elemente des Streams verwenden zu können, muss der Benutzer oder Client ihn zuerst abonnieren. In der Regel sollte er sich am Ende der Verarbeitung abmelden, da Garbage Collectors ein Abonnement möglicherweise nicht immer automatisch deaktivieren, wenn sie versuchen, einen Abonnenten zu nutzen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Clients können einen Thread abonnieren. In RxJs heißt die Abonnementfunktion subscribe (). In den meisten Fällen ist es ratsam, Verarbeitungsaufrufe der "normalen" Elemente des Streams, eines Fehlerhandlers und (relativ selten) eines Stream-Beendigungshandlers zu platzieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder der Abonnenten des Streams erhält seine Kopie des Elements oder einen Klon des ursprünglichen Elements. </font><font style="vertical-align: inherit;">Um keine Probleme zu verursachen, wird der Stream so implementiert, dass die zur Verarbeitung empfangenen Elemente unveränderlich werden. </font><font style="vertical-align: inherit;">In einigen Situationen kann diese Einschränkung immer noch umgangen werden, es ist jedoch besser, dies nicht zu tun.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gefährlicher Charme der Bäche</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind sehr komplizierte Objekte, die Integralen in der Mathematik ähneln. Es ist eine Sache zu wissen, dass sie existieren und sich sogar grob vorzustellen, was es ist, und eine ganz andere, sie nutzen zu können. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verständnis der internen Logik ihrer Funktionsweise, die erforderlich ist, um sie in der Praxis gut anzuwenden, erfordert erhebliche intellektuelle Anstrengungen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind eng mit der funktionalen Programmierung verbunden. Für die ordnungsgemäße Verwendung von Threads ist es hilfreich zu verstehen, wie Sie Funktionen zweiter Ordnung erstellen und anwenden können - Funktionen, die andere Funktionen als Argumente haben. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann wird Ihnen die Schönheit und Eleganz der Flüsse vollständig offenbart. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Streams sind ansteckend. Nachdem ich ihre Schönheit verstanden habe, möchte ich sie für alle Aufgaben verwenden, was natürlich nicht notwendig ist.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei welchen Aufgaben es ratsam ist, Flows zu verwenden und wo traditionelle Methoden angewendet werden sollten, entscheidet jeder für sich.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel habe ich versucht, Ihnen etwas über die mentalen Modelle der reaktiven Programmierung (MM RP) zu erzählen und sie sogar teilweise in Ihr Bewusstsein aufzunehmen. </font><font style="vertical-align: inherit;">Lassen Sie uns die wichtigsten Punkte noch einmal wiederholen.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RP sind etwas Besonderes, das den mentalen Modellen der traditionellen Programmierung nicht ähnlich ist. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir mit der reaktiven Programmierung beginnen, müssen wir uns daran erinnern, dass einige in anderen Bereichen des MM gut etablierte Bereiche wie Cursor, Aufrufketten oder Schleifen nicht funktionieren oder nicht so funktionieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das mentale Hauptmodell von RP ist ein "Dreikanal-Stream" mit einem Kanal für "normale" Elemente, Fehler und Informationen über das Ende des Streams.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams können endlich und unendlich sein.</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie an diesem Thema interessiert sind, können Sie mit den auf der Site verfügbaren Simulatoren [8] mit Streams "spielen". </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die Konzepte von RP besser verstehen möchten, empfehle ich Ihnen, das Buch [7] durchzuarbeiten und sich natürlich mit The Reactive Manifesto [11] vertraut zu machen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie erreichen die nächste Stufe bei der Bildung Ihres eigenen MM-RP, indem Sie die Bücher [9] und [10] über den Entwurf und die Modellierung reaktiver Systeme durcharbeiten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur und Referenzen</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmierung ist die Materialisierung von Ideen. </font><font style="vertical-align: inherit;">(Artikel auf Habr. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE: Reifizierung als Paradigma der Softwareentwicklung. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ereignisgesteuerte Programmierung. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486614/index.html">Warum eSIM benötigt wird. Wie es funktioniert und warum sie so viel darüber reden</a></li>
<li><a href="../de486622/index.html">Paralleles Rechenmodell</a></li>
<li><a href="../de486626/index.html">Svelte: Aktionen kennenlernen</a></li>
<li><a href="../de486628/index.html">Der Abstand zwischen Ticks auf einer Achse im Gnuplot wurde korrigiert</a></li>
<li><a href="../de486630/index.html">„Nicht ins Auge flackern“: Wie die Technologie der Bildschirmbeleuchtung elektronischer Lesegeräte angeordnet ist</a></li>
<li><a href="../de486634/index.html">MSVC-Backend-Updates in Visual Studio 2019, Version 16.3 und 16.4</a></li>
<li><a href="../de486638/index.html">Blazor WebAssembly 3.2.0 Preview 1 ist jetzt verfügbar</a></li>
<li><a href="../de486640/index.html">Die Zusammenfassung interessanter Materialien für den mobilen Entwickler # 331 (27. Januar - 2. Februar)</a></li>
<li><a href="../de486644/index.html">DIY Antenne in 5 Minuten</a></li>
<li><a href="../de486646/index.html">Geh weg von jQuery nach Svelte, ohne Schmerzen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>