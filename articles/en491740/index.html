<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçü§ù‚Äçüë©üèº ‚úçÔ∏è üóæ The Internet of Things in Yandex.Cloud: How Yandex IoT Core and Yandex Cloud Functions Services Are Arranged ‚úàÔ∏è üìÜ üíù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In October last year, the first Yandex Yandex Scale cloud conference was held. It announced the launch of many new services, including Yandex IoT Core...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The Internet of Things in Yandex.Cloud: How Yandex IoT Core and Yandex Cloud Functions Services Are Arranged</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/491740/"><img src="https://habrastorage.org/webt/wf/_u/zo/wf_uzobkj9vxp2ddkzxzux7lhbo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In October last year, the first Yandex Yandex Scale cloud conference was held. It announced the launch of many new services, including Yandex IoT Core, which allows you to exchange data with millions of IoT devices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, I‚Äôll talk about why Yandex IoT Core is needed and how it works, as well as how it can interact with other Yandex. Cloud services. You will learn about the architecture, the intricacies of the interaction of components and the features of the implementation of functionality - all this will help you optimize the use of these services.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let us recall the main advantages of public clouds and PaaS - reducing development time and costs, as well as support and infrastructure costs, which is also relevant for IoT projects. But there are a few less obvious useful features that you can get in the cloud. This effective scaling and fault tolerance are important aspects when working with devices, especially in projects for critical information infrastructure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Effective scaling is the ability to freely increase or decrease the number of devices without experiencing technical problems and seeing a predictable change in the cost of the system after the changes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fault tolerance is the confidence that services are designed and deployed in such a way as to ensure the highest possible performance even in the event of a failure of some resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's get into the details.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IoT Script Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, let's see what the overall architecture of the IoT script looks like. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z_/po/yk/z_poykwjdwprirjgwkxmkvjnq0o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Two large parts can be distinguished in it:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is the delivery of data to the storage and the delivery of commands to devices. </font><font style="vertical-align: inherit;">When you build an IoT system, this task must be solved in any case, no matter what project you do.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is working with received data. </font><font style="vertical-align: inherit;">Everything is similar to any other project based on the analysis and visualization of data sets. </font><font style="vertical-align: inherit;">You have a repository with an initial array of information, working with which will allow you to realize your task.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first part is approximately the same in all IoT systems: it is built on general principles and fits into a common scenario suitable for most IoT systems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second part is almost always unique in terms of the functions performed, although it is built on standard components. At the same time, without a high-quality, fault-tolerant and scalable system of interaction with hardware, the effectiveness of the analytical part of the architecture is reduced to almost zero, because there is simply nothing to analyze. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is why the Yandex.Cloud team decided first of all to concentrate on building a convenient ecosystem of services that would quickly, efficiently and reliably deliver data from devices to storages, and vice versa - send commands to devices.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/k8/ug/tqk8ugcmjnp3-s3cscc4ldhmuou.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve these problems, we are working on the functionality and integration of Yandex IoT Core, Yandex Functions and data storage services in the Cloud: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core service is a multi-tenant fail-safe scalable MQTT broker with a set of additional useful functions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Cloud Functions service is a representative of the promising serverless direction and allows you to run your code as a function in a safe, fault-tolerant and automatically scalable environment without creating and maintaining virtual machines.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Object Storage is an effective storage of large data arrays and is very suitable for ‚Äúhistorical‚Äù archive records.</font></font></li>
<li>          ,    ,      Yandex Managed Service for ClickHouse,     ¬´¬ª  .       ¬´¬ª      ,       ,     ,             .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If data storage and analysis services are ‚Äúgeneral-purpose‚Äù services that have already been written about a lot, then Yandex IoT Core and its interaction with Yandex Cloud Functions usually cause a lot of questions, especially for people who are just starting to understand Internet of things and cloud technologies. </font><font style="vertical-align: inherit;">And since these services provide fault tolerance and scaling of work with devices, we will first see what they have under the hood.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How Yandex IoT Core works</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex IoT Core is a specialized platform service for two-way data exchange between the cloud and devices running the MQTT protocol. In fact, this protocol has become the standard for transferring data to IoT. It uses the concept of named queues (topics), where, on the one hand, you can write data, and on the other hand, receive them asynchronously by subscribing to events of this queue. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Yandex IoT Core service is multi-tenant, which means one single entity that is accessible to all users. That is, all devices and all users interact with the same service instance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This allows, on the one hand, to ensure uniformity of work for all users, on the other hand, effective scaling and fault tolerance, in order to maintain a connection with an unlimited number of devices and process an unlimited amount of data both in volume and speed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It follows that the service must have both redundancy mechanisms and the ability to flexibly manage the resources used - in order to respond to load changes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, multi-tenancy requires a special logic of sharing access rights to MQTT topics. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how this is implemented. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Like many other Yandex.Cloud services, Yandex IoT Core is logically divided into two parts - Control Plane and Data Plane:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8a/u0/f3/8au0f3pzmwa1v-hhsxikvo_l_0m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data Plane is responsible for the logic of operation under the MQTT protocol, and Control Plane is responsible for delimiting access rights to certain topics and uses the logical entities Registry and Device for this. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eu/b1/1n/eub11nm0nlmhprrhfqzohfwcyow.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each Yandex.Cloud user can have several registries, each of which can contain its own subset of devices. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Access to topics is provided as follows: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/df/wc/hd/dfwchdy-bdwxs56mkgykrcs0ia4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devices can send data only to their events topic and registry events topic:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and subscribe to messages only from your topic of commands and topic of registry commands:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The registry can send data to all topics of device commands and to the topic of registry commands:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/commands<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/commands</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and subscribe to messages from all topics of device events and the topic of registry events:</font></font><br>
<br>
<pre><code class="xml hljs">$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device1</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$devices/<span class="hljs-tag">&lt;<span class="hljs-name">Device2</span> <span class="hljs-attr">ID</span>&gt;</span>/events<font></font>
$registries/<span class="hljs-tag">&lt;<span class="hljs-name">Registry</span> <span class="hljs-attr">ID</span>&gt;</span>/events</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To work with all the entities described above, Data Plane has a gRPC-protocol and a REST-protocol, on the basis of which access is realized through the GUI-console of Yandex.Cloud and the CLI command-line interface. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As for the Data Plane, it supports the MQTT protocol version 3.1.1. </font><font style="vertical-align: inherit;">However, there are several features:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When connecting, be sure to use TLS.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Only TCP connection is supported. </font><font style="vertical-align: inherit;">WebSocket is not yet available.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authorization is available both by login and password (where login is the device or registry ID, and passwords are set by the user), and using certificates.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Retain flag is not supported, when using which the MQTT broker saves the message marked with the flag and sends it the next time you subscribe to the topic.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persistent Session is not supported, in which the MQTT broker saves information about the client (device or registry) to facilitate reconnection.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With subscribe and publish, only the first two levels of service are supported:</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS0 - At most once. </font><font style="vertical-align: inherit;">There is no delivery guarantee, but there is no re-delivery of the same message.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS1 - At least once. </font><font style="vertical-align: inherit;">Delivery is guaranteed, but there is a chance of re-receiving the same message.</font></font></li>
</ol></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To simplify the connection to Yandex IoT Core, we regularly add new examples for different platforms and languages ‚Äã‚Äãto our repository on GitHub, and also describe scripts in the documentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The service architecture looks like this: The </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6g/ig/4o/6gig4ofj7dksmbn18wvq5swkpuo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
business logic of the service includes four parts:</font></font><br>
<br>
<ol>
<li> Device management ‚Äî     .   Control Plane.</li>
<li> MQTT Broker ‚Äî  MQTT-.  Data Plane.</li>
<li> Triggers ‚Äî     Yandex Cloud Functions.  Data Plane.</li>
<li> Shards ‚Äî      MQTT-    .  Data Plane.</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All interaction with the "outside world" goes through load balancers. Moreover, in accordance with the dogfooding philosophy, Yandex Load Balancer is used, which is available to all Yandex.Cloud users. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each part of the business logic consists of several sets of three virtual machines ‚Äî one in each availability zone (in Scheme A, B, and C). Virtual machines are exactly the same as all Yandex.Cloud users. When the load increases, scaling occurs with the help of the whole set - three machines are added at once within the framework of one part of the business logic. This means that if one set of three MQTT Broker machines cannot handle the load, then another set of three MQTT Broker machines will be added, while the configuration of other parts of the business logic will remain the same.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And only Logbroker is not publicly available. It is a service for efficient fail-safe operation with data streams. It is based on Apache Kafka, but it has many other useful functions: it implements disaster recovery processes (including exactly once semantics when you have a message delivery guarantee without duplication) and service processes (such as cross-center replication, data distribution to clusters of calculation), and also has a mechanism for uniform non-duplicate distribution of data between flow subscribers - a kind of load balancer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The device management features in Control Plane are described above. But with Data Plane, everything is much more interesting.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each instance of MQTT Broker works independently and knows nothing about other instances. All received data (publish from customers) is sent by brokers to Logbroker, from where they are picked up by Shards and Triggers. And it is in shards that synchronization occurs between instances of brokers. Shards know about all MQTT clients and the distribution of their subscriptions (subscribe) across instances of MQTT brokers and determine where to send the received data. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, the MQTT client A is subscribed to the topic from broker A, and the MQTT client B is subscribed to the same topic from broker B. If the MQTT client C makes publish to the same topic, but to broker C, then the shard transfers data from broker C to brokers A and B, as a result of which the data will be received by both MQTT client A and MQTT client B.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/dv/dz/iadvdzgd2cs6o1r3stjkqfhsq6y.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last part of the business logic, triggers (Triggers), also receives all the data received from MQTT clients and, if this is configured by the user, passes them to the triggers of the Yandex Cloud Functions service. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, Yandex IoT Core has a rather complicated architecture and logic of work, which is difficult to repeat on local installations. </font><font style="vertical-align: inherit;">This allows him to withstand the loss of even two of the three availability zones, and work out an unlimited number of connections and unlimited data volumes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Moreover, all this logic is hidden from the user ‚Äúunder the hood‚Äù, but from the outside everything looks very simple - as if you are working with a single MQTT broker.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Triggers and Yandex Cloud Functions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Cloud Functions is a representative of the so-called "serverless" (serverless) services in Yandex.Cloud. The main essence of such services is that the user does not spend his time setting up, deploying and scaling the environment to execute code, but only deals with the most valuable thing for him - writing the code itself that performs the necessary task. In the case of functions, this is the so-called atomic stateless code that can be triggered by some event. ‚ÄúAtomic‚Äù and ‚Äústateless‚Äù mean that this code should perform some relatively small but integral task, while the code should not use any variables in order to store values ‚Äã‚Äãbetween calls.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several ways to call functions: a direct HTTP call, a timer call (cron), or an event subscription. As the latter, the service already supports subscribing to message queues (Yandex Message Queue), events generated by the Object Storage service, and (most valuable for the IoT scenario) subscribing to messages in Yandex IoT Core.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that you can work with Yandex IoT Core using any MQTT-compatible client, Yandex Cloud Functions is one of the most optimal and convenient ways to receive and process data. The reason for this is very simple. A function can be called on every incoming message from any device, and the functions will be executed in parallel to each other (due to atomicity and stateless approach), and the number of their calls will naturally change as the number of incoming messages from devices changes. Thus, the user can completely ignore the issues of setting up the infrastructure and, moreover, unlike the same virtual machines, payment will only occur for the work actually performed.This will allow you to significantly save at low load and get a clear and predictable cost with growth.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mechanism for calling functions on events (subscribing to events) is called a trigger (Trigger). Its essence is depicted in the diagram: A </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5u/yv/bn/5uyvbnyviueygxt4ykzdh9n2nug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
service that generates events for calling functions puts them in a queue in Logbroker. In the case of Yandex IoT Core, Triggers from Data Plane do this. Further, these events are taken by the preprocessor, which is looking for a record in the database for this event indicating the function to be called. If such an entry is found, the preprocessor puts the information about the function call (function ID and call parameters) in the queue in the Yandex Message Queue service, from where the call handler picks it up. The handler, in turn, sends an HTTP request to call the function to the Yandex Cloud Functions service.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, again, in accordance with the dogfooding philosophy, the Yandex Message Queue service, accessible to all users, is used, and the functions are called in exactly the same way that any other users can call their functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say a few words about Yandex Message Queue. Despite the fact that this, like Logbroker, is a queue service, there is one significant difference between them. When processing messages from queues, the handler informs the queue that it has finished and the message can be deleted. This is an important reliability mechanism in such services, but it complicates the logic of working with messages.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yandex Message Queue allows you to "parallelize" the processing of each message within the queue. In other words, the message from the queue that is currently being processed does not block the possibility of another "thread" to pick up the next event from the queue for processing. This is called message-level concurrency. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And LogBroker operates on message groups, and until the whole group is processed, the next group cannot be picked up for processing. This approach is called concurrency at the partition level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And it is precisely the use of Yandex Message Queue that allows you to quickly and efficiently process in parallel a lot of requests to call a function for events from a particular service.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that triggers are a separate independent unit, they are part of the Yandex Cloud Functions service. We just have to figure out exactly how the functions are called.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fb/ew/ke/fbewkedbrp6eyri7zkubwiu6dzu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All requests to call functions (both external and internal) fall into the load balancer, which distributes them to routers in different access zones (AZ), several pieces are deployed in each zone. Upon receiving a request, the router first of all goes to the Identity and Access manager (IAM) service to make sure that the request source has rights to call this function. He then turns to scheduler and asks which worker to run the function on. Worker is a virtual machine with a customized runtime of isolated functions. Further, the router, having received from the scheduler the address of the worker on which to execute the function, sends a command to this worker to start the function with certain parameters.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Where does the worker come from? This is where all the serverless magic happens. Schedulers, analyzing the load (the number and duration of functions), manage (start and stop) virtual machines with a particular runtime. NodeJS and Python are now supported. And here one parameter is extremely important - the speed of launching functions. The service development team has done a great job, and now the virtual machine starts in a maximum of 250 ms, while using the most secure environment for isolating functions from each other - QEMU virtualization, which runs all Yandex. Cloud. At the same time, if there is already a working worker for the incoming request, the function starts almost instantly.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And, in accordance with the same dogfooding approach, the Load Balancer uses a public service accessible to all users, and the worker, scheduler and router are ordinary virtual machines, the same as all users. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, the fault tolerance of the service is implemented at the level of the load balancer and redundancy of the key system components (router and scheduler), and scaling occurs due to the deployment or reduction of the number of workers. </font><font style="vertical-align: inherit;">Moreover, each accessibility zone works independently, which allows surviving the loss of even two of the three zones.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useful links</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In conclusion, I want to give a few links that will allow you to study the services in more detail:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex IoT Core: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud.yandex.ru/services/iot-core</font></font></a> </li>
<li> Yandex Cloud Functions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.yandex.ru/services/functions</a> </li>
<li> Yandex Message Queue: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.yandex.ru/services/message-queue</a> </li>
<li> Yandex Managed Service for ClickHouse: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.yandex.ru/services/managed-clickhouse</a> </li>
<li> Yandex Load Balancer: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.yandex.ru/services/load-balancer</a> </li>
<li> Yandex Object Storage: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">cloud.yandex.ru/services/storage</a> </li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491724/index.html">The book "Laravel. Complete guide. 2nd edition</a></li>
<li><a href="../en491726/index.html">Expand nested columns - lists using the R language (tidyr package and unnest family functions)</a></li>
<li><a href="../en491728/index.html">DRY principle with Laravel</a></li>
<li><a href="../en491732/index.html">Is there life after Scratch, or how to introduce a child to Python</a></li>
<li><a href="../en491736/index.html">TMS1000: the first commercially available microcontroller</a></li>
<li><a href="../en491742/index.html">Sherbet: ergonomic gaming keyboard</a></li>
<li><a href="../en491744/index.html">Iranian hackers exploited vulnerabilities in VPN</a></li>
<li><a href="../en491746/index.html">The history of speech synthesis: the era of electrical solutions</a></li>
<li><a href="../en491748/index.html">Technologies that help the blind learn English</a></li>
<li><a href="../en491750/index.html">We write substring search better than in textbooks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>