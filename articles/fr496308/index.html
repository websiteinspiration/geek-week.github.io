<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛕 😫 🙅🏽 Créez des cartes de bruit fluides 👨🏻‍🍳 🚘 🚘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La création d'une image transparente dans Photoshop est simple: recadrez l'image, saisissez les parties découpées droite et inférieure, puis collez-le...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Créez des cartes de bruit fluides</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496308/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b72/cbf/259/b72cbf2592b2e142259d2cc3f7b13d6f.jpg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La création d'une image transparente dans Photoshop est simple: recadrez l'image, saisissez les parties découpées droite et inférieure, puis collez-les à gauche et en haut à l'aide de l'outil Fondu. Mais pour la bonne mise en œuvre de cartes de bruit homogènes, vous devez bien réfléchir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous avez une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Hugo Elias sur le bruit de Perlin" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compréhension de base du bruit Perlin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , vous savez qu'il se compose de nombres aléatoires interpolés. Il est principalement utilisé en deux dimensions. Mais il est également utile en une dimension (par exemple lors d'un déplacement), en trois dimensions (transformation cylindrique et sphérique d'objets 3D), et même en quatre ou cinq dimensions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le bruit en quatre dimensions peut être utilisé pour créer une image 2D transparente. Il n'est pas très courant pour nous de penser en quatre dimensions, nous allons donc prendre une dimension à la fois.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mes exemples,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai utilisé du </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Bruit simplex sur Wikipédia" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bruit simplex à</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deux octaves. </font><font style="vertical-align: inherit;">Le bruit simplex est plus rapide dans les grandes dimensions et, en raison de sa nature triangulaire, il semble meilleur.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit une petite fonction </font></font><code>drawNoise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour créer une toile et traiter un tableau de pixels en boucle.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit homogène unidimensionnel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans une dimension, le bruit est une ligne lisse infinie (mon implémentation du bruit commence par deux, donc j'utilise une constante comme deuxième paramètre). </font><font style="vertical-align: inherit;">Ici, nous voyons que ce ne sont que des nombres aléatoires interpolés.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// one dimensional line</span>
fNoiseScale = <span class="hljs-number">.02</span>;<font></font>
drawNoise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,x,y</span>)</span>{
    <span class="hljs-keyword">var</span> v = Simplex.noise(
         <span class="hljs-number">123</span>+x*fNoiseScale<font></font>
        ,<span class="hljs-number">137</span> <span class="hljs-comment">// we just need one dimension so this parameter is a constant</span><font></font>
    );<font></font>
    <span class="hljs-keyword">return</span> v*iSize&gt;y?<span class="hljs-number">255</span>:<span class="hljs-number">0</span>;<font></font>
}).img();</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fee/37f/7e1/fee37f7e153a8615cbd8fd6930d61fec.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit unidimensionnel</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Vous pouvez l'utiliser dans l'animation, recalculer la valeur du bruit toutes les millisecondes, mais vous pouvez également créer une boucle et calculer toutes les valeurs à l'avance. </font><font style="vertical-align: inherit;">Les valeurs de l'image ci-dessus ne bouclent pas sur les bords. </font><font style="vertical-align: inherit;">Mais la mise en œuvre de la répétabilité est assez simple, juste une dimension et une boucle de plus ... ou un cercle, pour cela.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boucle unidimensionnelle</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la plupart d'entre vous, le bruit de Perlin ressemble à l'image ci-dessous.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/129/aad/02b129aadc25be9d0e74688ff1c702ff.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous dessinions un cercle ici et comptions les valeurs de bruit sur ce cercle, nous obtiendrions une boucle unidimensionnelle.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/88a/6d9/247/88a6d9247a7dd2a9cbab6cf9ee08463b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bruit avec un cercle pour créer une boucle unidimensionnelle. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En code, cela ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// one dimensional loop</span>
drawNoise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,x,y</span>)</span>{
    <span class="hljs-keyword">var</span> fNX = x/iSize <span class="hljs-comment">// we let the x-offset define the circle</span>
        ,fRdx = fNX*<span class="hljs-number">2</span>*<span class="hljs-built_in">Math</span>.PI <span class="hljs-comment">// a full circle is two pi radians</span>
        ,a = fRdsSin*<span class="hljs-built_in">Math</span>.sin(fRdx)<font></font>
        ,b = fRdsSin*<span class="hljs-built_in">Math</span>.cos(fRdx)<font></font>
        ,v = Simplex.noise(<font></font>
             <span class="hljs-number">123</span>+a*fNoiseScale<font></font>
            ,<span class="hljs-number">132</span>+b*fNoiseScale<font></font>
        )<font></font>
    ;<font></font>
    <span class="hljs-keyword">return</span> v*iSize&gt;y?<span class="hljs-number">255</span>:<span class="hljs-number">0</span>;<font></font>
}).img().div(<span class="hljs-number">2</span>);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3da/43d/f64/3da43df64f677b0f55cfbcdc38a01c3e.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez probablement déjà compris ce que nous allons faire. </font><font style="vertical-align: inherit;">Pour boucler une image bidimensionnelle, nous avons besoin d'une carte de bruit tridimensionnelle (au moins).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte cylindrique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Noise Perlin a été à l'origine créé pour la texturation 3D continue (le film "Tron"). </font><font style="vertical-align: inherit;">La carte d'image n'est pas une feuille de papier enroulée autour d'un objet, mais est calculée par son emplacement dans un champ de bruit tridimensionnel. </font><font style="vertical-align: inherit;">Par conséquent, lors de la découpe de l'objet, nous pouvons toujours calculer la carte pour la surface nouvellement créée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant d'atteindre notre objectif ultime d'une image transparente, nous créons d'abord une image qui se joint de manière transparente à gauche et à droite. </font><font style="vertical-align: inherit;">Ceci est similaire à un cercle bidimensionnel pour une boucle unidimensionnelle, mais avec une dimension supplémentaire: un cylindre.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// three dimensional cylindrical map</span>
drawNoise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,x,y</span>)</span>{
    <span class="hljs-keyword">var</span> fNX = x/iSize<font></font>
        ,fRdx = fNX*<span class="hljs-number">2</span>*<span class="hljs-built_in">Math</span>.PI<font></font>
        ,a = fRdsSin*<span class="hljs-built_in">Math</span>.sin(fRdx)<font></font>
        ,b = fRdsSin*<span class="hljs-built_in">Math</span>.cos(fRdx)<font></font>
        ,v = Simplex.noise(<font></font>
             <span class="hljs-number">123</span>+a*fNoiseScale<font></font>
            ,<span class="hljs-number">132</span>+b*fNoiseScale<font></font>
            ,<span class="hljs-number">312</span>+y*fNoiseScale <span class="hljs-comment">// similar to the one dimensional loop but we add a third dimension defined by the image y-offset</span><font></font>
        )<font></font>
    ;<font></font>
    <span class="hljs-keyword">return</span> v*<span class="hljs-number">255</span>&lt;&lt;<span class="hljs-number">0</span>;<font></font>
}).img().div(<span class="hljs-number">2</span>);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/f0b/55b/ddcf0b55bddba6cbc880300442a8b99e.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte de bruit cylindrique</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image de la carte sphérique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pourriez penser qu'il serait pratique d'utiliser une sphère pour créer une image homogène, mais vous vous trompez. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vais faire une petite digression et montrer comment la carte image sphérique est calculée et à quoi elle ressemble.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// three dimensional spherical map</span>
<span class="hljs-built_in">document</span>.body.addChild(<span class="hljs-string">'h2'</span>).innerText = <span class="hljs-string">'three dimensional spherical map'</span>;<font></font>
fNoiseScale = <span class="hljs-number">.1</span>;
<span class="hljs-keyword">var</span> oSpherical = drawNoise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,x,y</span>)</span>{
    <span class="hljs-keyword">var</span>  fNX = (x+<span class="hljs-number">.5</span>)/iSize <span class="hljs-comment">// added half a pixel to get the center of the pixel instead of the top-left</span>
        ,fNY = (y+<span class="hljs-number">.5</span>)/iSize<font></font>
        ,fRdx = fNX*<span class="hljs-number">2</span>*<span class="hljs-built_in">Math</span>.PI<font></font>
        ,fRdy = fNY*<span class="hljs-built_in">Math</span>.PI <span class="hljs-comment">// the vertical offset of a 3D sphere spans only half a circle, so that is one Pi radians</span>
        ,fYSin = <span class="hljs-built_in">Math</span>.sin(fRdy+<span class="hljs-built_in">Math</span>.PI) <span class="hljs-comment">// a 3D sphere can be seen as a bunch of cicles stacked onto each other, the radius of each of these is defined by the vertical position (again one Pi radians)</span>
        ,a = fRdsSin*<span class="hljs-built_in">Math</span>.sin(fRdx)*fYSin<font></font>
        ,b = fRdsSin*<span class="hljs-built_in">Math</span>.cos(fRdx)*fYSin<font></font>
        ,c = fRdsSin*<span class="hljs-built_in">Math</span>.cos(fRdy)<font></font>
        ,v = Simplex.noise(<font></font>
             <span class="hljs-number">123</span>+a*fNoiseScale<font></font>
            ,<span class="hljs-number">132</span>+b*fNoiseScale<font></font>
            ,<span class="hljs-number">312</span>+c*fNoiseScale<font></font>
        )<font></font>
    ;<font></font>
    <span class="hljs-keyword">return</span> v*<span class="hljs-number">255</span>&lt;&lt;<span class="hljs-number">0</span>;<font></font>
}).img();</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8f/351/5ec/a8f3515eccdd052b51d6e76b530d96ba.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte de bruit sphérique</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/493/7c2/9e7/4937c29e770cc3bcf0790d9ab03d18a7.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sphère avec bruit</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte panoramique cubique</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sphère que nous avons créée peut également être utilisée comme panorama si vous placez une caméra au centre de la sphère. </font><font style="vertical-align: inherit;">Mais la meilleure façon serait d'utiliser un panorama cubique, car il a beaucoup moins de visages. </font><font style="vertical-align: inherit;">La sphère est projetée sur les six côtés du cube, comme illustré dans ce croquis.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b23/c53/119/b23c53119cd34d46d5643b7765a3db8d.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Superposition d'une sphère sur un cube</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour chaque pixel de la surface du cube, nous devons calculer l'intersection entre le point de vue C au centre et la sphère. Cela peut sembler compliqué, mais c'est en fait assez simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons considérer la ligne CA comme un vecteur. Et les vecteurs peuvent être normalisés afin que leur direction ne change pas, mais la longueur diminue à 1. Pour cette raison, tous les vecteurs ensemble ressembleront à une sphère. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La normalisation est également assez simple, il suffit de diviser les valeurs du vecteur par xyz par la longueur totale du vecteur. La longueur du vecteur peut être calculée en utilisant le théorème de Pythagore.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code ci-dessous, le calcul de normalisation est d'abord effectué sur une face. </font><font style="vertical-align: inherit;">Ensuite, le bruit est calculé simultanément pour les six arêtes, car pour obtenir la position de la face suivante, il vous suffit de retourner les valeurs le long de xyz.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// 3D panoramical cube map</span>
<span class="hljs-built_in">document</span>.body.addChild(<span class="hljs-string">'h2'</span>).innerText = <span class="hljs-string">'3D panoramical cube map'</span>;
<span class="hljs-comment">// we're not using the drawNoise function because our canvas is rectangular</span>
<span class="hljs-keyword">var</span> mCubemap = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'canvas'</span>)<font></font>
    ,iW = <span class="hljs-number">6</span>*iSize;<font></font>
mCubemap.width = iW;<font></font>
mCubemap.height = iSize;<font></font>
<span class="hljs-keyword">var</span>  iHSize = iSize/<span class="hljs-number">2</span> <span class="hljs-comment">// half the size of the cube</span>
    ,oCtx = mCubemap.getContext(<span class="hljs-string">'2d'</span>)<font></font>
    ,oImgData = oCtx.getImageData(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,iW,iSize)<font></font>
    ,aPixels = oImgData.data<font></font>
    ,aa = <span class="hljs-number">123</span>
    ,bb = <span class="hljs-number">231</span>
    ,cc = <span class="hljs-number">321</span><font></font>
;<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,l=iSize*iSize;i&lt;l;i++) {
    <span class="hljs-keyword">var</span>  x = i%iSize        <span class="hljs-comment">// x position in image</span>
        ,y = (i/iSize)&lt;&lt;<span class="hljs-number">0</span>    <span class="hljs-comment">// y position in image</span>
        ,a = -iHSize + x+<span class="hljs-number">.5</span>    <span class="hljs-comment">// x position on the cube plane, the added .5 is to get the center of the pixel</span>
        ,b = -iHSize + y+<span class="hljs-number">.5</span> <span class="hljs-comment">// y position on the cube plane</span>
        ,c = -iHSize        <span class="hljs-comment">// z position of the cube plane</span>
        ,fDistanceAB = <span class="hljs-built_in">Math</span>.sqrt(a*a+b*b) <span class="hljs-comment">// to calculate the vectors length we use Pythagoras twice</span>
        ,fDistanceABC = <span class="hljs-built_in">Math</span>.sqrt(fDistanceAB*fDistanceAB+c*c)<font></font>
        ,fDrds = <span class="hljs-number">.5</span>*fDistanceABC <span class="hljs-comment">// adjust the distance a bit to get a better radius in the noise field</span>
        ,v = <span class="hljs-number">1</span><font></font>
    ;<font></font>
    a /= fDrds; <span class="hljs-comment">// normalize the vector</span>
    b /= fDrds; <span class="hljs-comment">// normalize the vector</span>
    c /= fDrds; <span class="hljs-comment">// normalize the vector</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// since we now know the spherical position for one plane we can derive the positions for the other five planes simply by switching the x, y and z values (the a, b and c variables)</span>
    <span class="hljs-keyword">var</span> aNoisePositions = [<font></font>
         [a,b,c]    <span class="hljs-comment">// back</span>
        ,[-c,b,a]    <span class="hljs-comment">// right</span>
        ,[-a,b,-c]    <span class="hljs-comment">// front</span>
        ,[c,b,-a]    <span class="hljs-comment">// left</span>
        ,[a,c,-b]    <span class="hljs-comment">// top</span>
        ,[a,-c,b]    <span class="hljs-comment">// bottom</span><font></font>
    ];<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">6</span>;j++) {<font></font>
        v = Simplex.noise(<font></font>
             aa + aNoisePositions[j][<span class="hljs-number">0</span>]<font></font>
            ,bb + aNoisePositions[j][<span class="hljs-number">1</span>]<font></font>
            ,cc + aNoisePositions[j][<span class="hljs-number">2</span>]<font></font>
        );<font></font>
        <span class="hljs-keyword">var</span> pos = <span class="hljs-number">4</span>*(y*iW+j*iSize+x); <span class="hljs-comment">// the final position of the rgba pixel</span>
        aPixels[pos] = aPixels[pos+<span class="hljs-number">1</span>] = aPixels[pos+<span class="hljs-number">2</span>] = v*<span class="hljs-number">255</span>&lt;&lt;<span class="hljs-number">0</span>;<font></font>
        aPixels[pos+<span class="hljs-number">3</span>] = <span class="hljs-number">255</span>;<font></font>
    }<font></font>
}<font></font>
oCtx.putImageData(oImgData,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);
<span class="hljs-built_in">document</span>.body.addChild(<span class="hljs-string">'img'</span>,{<span class="hljs-attr">src</span>:mCubemap.toDataURL(<span class="hljs-string">"image/jpeg"</span>)});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici six côtés dans une image, ainsi qu'une capture d'écran de son apparence lorsqu'elle est vue à partir d'un cube. </font><font style="vertical-align: inherit;">Le code source a un exemple 3D écrit en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="les troisj de M. Doob sur github" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trois js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34e/e00/0ad/34ee000ada4ac534b92d51e92adaad8c.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte panoramique cubique</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eb3/1a6/c6f/eb31a6c6ffbe85f0d62377d8997225f8.jpg"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Image 2D transparente</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il peut sembler qu'une image 2D transparente soit facile à mettre en œuvre, mais il me semble que c'est la plus difficile des décrites dans l'article, car pour la comprendre, vous devez penser en quatre dimensions. La chose la plus proche était une carte cylindrique (avec répétition horizontale), nous allons donc la prendre comme base. Dans la carte cylindrique, nous avons utilisé la position horizontale de l'image pour le cercle; c'est-à-dire que la position horizontale de l'image nous donne deux coordonnées x et y dans le champ de bruit xyz. La position verticale de l'image correspond à z dans le champ de bruit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voulons que l'image soit transparente et verticale, donc si nous ajoutons une autre dimension, nous pouvons l'utiliser pour créer un deuxième cercle et remplacer la valeur linéaire du champ z. </font><font style="vertical-align: inherit;">Cela revient à créer deux cylindres dans un champ à quatre dimensions. </font><font style="vertical-align: inherit;">J'ai essayé de visualiser cela sur un croquis, c'est inexact, mais j'ai essayé de transmettre le principe général et de ne pas dessiner un cylindre à quatre dimensions.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b72/cbf/259/b72cbf2592b2e142259d2cc3f7b13d6f.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une esquisse de deux cylindres en quatre dimensions</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le code est assez simple: ce ne sont que deux cercles dans un espace de bruit en quatre dimensions.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// four dimensional tile</span>
fNoiseScale = <span class="hljs-number">.003</span>;<font></font>
drawNoise(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">i,x,y</span>)</span>{
    <span class="hljs-keyword">var</span>  fNX = x/iSize<font></font>
        ,fNY = y/iSize<font></font>
        ,fRdx = fNX*<span class="hljs-number">2</span>*<span class="hljs-built_in">Math</span>.PI<font></font>
        ,fRdy = fNY*<span class="hljs-number">2</span>*<span class="hljs-built_in">Math</span>.PI<font></font>
        ,a = fRds*<span class="hljs-built_in">Math</span>.sin(fRdx)<font></font>
        ,b = fRds*<span class="hljs-built_in">Math</span>.cos(fRdx)<font></font>
        ,c = fRds*<span class="hljs-built_in">Math</span>.sin(fRdy)<font></font>
        ,d = fRds*<span class="hljs-built_in">Math</span>.cos(fRdy)<font></font>
        ,v = Simplex.noise(<font></font>
             <span class="hljs-number">123</span>+a*fNoiseScale<font></font>
            ,<span class="hljs-number">231</span>+b*fNoiseScale<font></font>
            ,<span class="hljs-number">312</span>+c*fNoiseScale<font></font>
            ,<span class="hljs-number">273</span>+d*fNoiseScale<font></font>
        )<font></font>
    ;<font></font>
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(<span class="hljs-number">2</span>*(v <span class="hljs-number">-.5</span>)+<span class="hljs-number">.5</span>,<span class="hljs-number">0</span>),<span class="hljs-number">1</span>)*<span class="hljs-number">255</span>)&lt;&lt;<span class="hljs-number">0</span>;<font></font>
}).img().div(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici le résultat:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/421/ea5/5c4/421ea55c40887a7d4fcb846d3ed35db1.jpg" alt="image"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496268/index.html">Produits et solutions de mise en réseau d'entreprise Huawei pour les entreprises en 2020</a></li>
<li><a href="../fr496272/index.html">Confidentialité différentielle: comparaison des bibliothèques</a></li>
<li><a href="../fr496300/index.html">Code asynchrone dans Startup ASP.NET Core: 4 façons de contourner GetAwaiter (). GetResult ()</a></li>
<li><a href="../fr496302/index.html">Comment ne pas donner votre entreprise à un hacker pendant son absence. Conseils aux spécialistes SOC</a></li>
<li><a href="../fr496304/index.html">Comment je continue d'apprendre UE4 tout en créant mon jeu</a></li>
<li><a href="../fr499818/index.html">Marketing de télégramme ouzbek</a></li>
<li><a href="../fr499820/index.html">Pourquoi nous avons choisi Kotlin comme l'une de nos langues cibles. Partie 2: Kotlin Multiplatform</a></li>
<li><a href="../fr499822/index.html">Point d'accès sans fil vs routeur: quelles sont les différences?</a></li>
<li><a href="../fr499824/index.html">Le condensé des événements pour les recruteurs RH et IT en mai 2020</a></li>
<li><a href="../fr499826/index.html">Pression artérielle répartie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>