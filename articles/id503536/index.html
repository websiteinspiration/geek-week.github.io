<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏿 🖕🏼 🎨 Atribut pembersihan 🥚 🎩 🐤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kutipan dari dokumentasi GCC [1]: 
 
 Atribut cleanup digunakan untuk menjalankan fungsi ketika sebuah variabel keluar dari cakupan. Atribut ini hanya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Atribut pembersihan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503536/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kutipan dari dokumentasi GCC [1]: </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut cleanup digunakan untuk menjalankan fungsi ketika sebuah variabel keluar dari cakupan. Atribut ini hanya dapat diterapkan ke variabel otomatis, dan tidak dapat digunakan dengan parameter atau dengan variabel statis. Fungsi harus mengambil satu parameter, pointer ke tipe yang kompatibel dengan variabel. Nilai pengembalian fungsi, jika ada, diabaikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika opsi -fusionions diaktifkan, maka fungsi cleanup_function diluncurkan ketika stack dibatalkan, selama penanganan pengecualian. Perhatikan bahwa atribut pembersihan tidak menangkap pengecualian, tetapi hanya melakukan tindakan. Jika fungsi cleanup_fungsi tidak kembali secara normal, perilaku tidak terdefinisi.</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/qi/dr/gz/qidrgzjppagqdyrqn7c4ykxa2a4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Atribut cleanup didukung oleh kompiler gcc dan dentang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel ini saya akan menjelaskan berbagai opsi untuk penggunaan praktis atribut pembersihan dan mempertimbangkan struktur internal perpustakaan, yang menggunakan pembersihan untuk menerapkan analog std :: unique_ptr dan std :: shared_ptr di C.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba pembersihan untuk alokasi memori:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **ptr)</span> 
</span>{
    <span class="hljs-built_in">free</span>(*ptr); 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cleanup done\n"</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
    __attribute__((cleanup(free_int))) <span class="hljs-keyword">int</span> *ptr_one = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-comment">// do something here</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mulai, program mencetak "pembersihan selesai". </font><font style="vertical-align: inherit;">Semuanya bekerja, tepuk tangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi satu kelemahan segera menjadi jelas: kita tidak bisa begitu saja menulis</font></font><br>
<br>
<pre><code class="cpp hljs">__attribute__((cleanup(free_int)))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
karena fungsi yang dipanggil oleh atribut cleanup harus mengambil pointer ke variabel yang dibebaskan sebagai argumen, dan kita memiliki pointer ke area memori yang dialokasikan, yaitu, kita pasti membutuhkan fungsi yang mengambil pointer ganda. </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita memerlukan fungsi wrapper tambahan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">free_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **ptr)</span> 
</span>{
    <span class="hljs-built_in">free</span>(*ptr); <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kami tidak dapat menggunakan fungsi universal untuk membebaskan variabel apa pun, karena mereka akan membutuhkan berbagai jenis argumen. </font><font style="vertical-align: inherit;">Karena itu, kami menulis ulang fungsinya sebagai berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> _free(<span class="hljs-keyword">void</span> *p) {
    <span class="hljs-built_in">free</span>(*(<span class="hljs-keyword">void</span>**) p);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"cleanup done\n"</span>);  <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang dia bisa menerima petunjuk apa pun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini adalah makro lain yang bermanfaat (dari basis kode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">systemd</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFINE_TRIVIAL_CLEANUP_FUNC(type, func)                 \
        static inline void func##p(type *p) {                   \
                <span class="hljs-meta-keyword">if</span> (*p)                                         \
                        func(*p);                               \
        }                                                       \
        struct __useless_struct_to_allow_trailing_semicolon__</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
yang nantinya bisa digunakan seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">DEFINE_TRIVIAL_CLEANUP_FUNC(FILE*, pclose);
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> _cleanup_pclose_ __attribute__((cleanup(pclosep)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi itu belum semuanya. </font><font style="vertical-align: inherit;">Ada perpustakaan yang mengimplementasikan analog dari unique_ptr dan shared_ptr plus menggunakan atribut ini: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/Snaipe/libcsptr</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Contoh penggunaan (diambil dari [2]):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;csptr/smart_ptr.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;csptr/array.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_int</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">void</span> *meta)</span> </span>{<font></font>
    (<span class="hljs-keyword">void</span>) meta;
    <span class="hljs-comment">// ptr points to the current element</span>
    <span class="hljs-comment">// meta points to the array metadata (global to the array), if any.</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *(<span class="hljs-keyword">int</span>*) ptr);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">// Destructors for array types are run on every element of the</span>
    <span class="hljs-comment">// array before destruction.</span>
    smart <span class="hljs-keyword">int</span> *ints = <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-keyword">int</span>[<span class="hljs-number">5</span>], {<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>}, print_int);
    <span class="hljs-comment">// ints == {5, 4, 3, 2, 1}</span><font></font>
<font></font>
    <span class="hljs-comment">// Smart arrays are length-aware</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; array_length(ints); ++i) {<font></font>
        ints[i] = i + <span class="hljs-number">1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// ints == {1, 2, 3, 4, 5}</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya bekerja dengan luar biasa! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan mari kita lihat apa yang ada di dalam sihir ini. </font><font style="vertical-align: inherit;">Mari kita mulai dengan unique_ptr (dan shared_ptr secara bersamaan):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> shared_ptr(Type, ...) smart_ptr(SHARED, Type, __VA_ARGS__)</span>
<span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> unique_ptr(Type, ...) smart_ptr(UNIQUE, Type, __VA_ARGS__)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lanjutkan dan lihat seberapa dalam lubang kelinci itu:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart_arr(Kind, Type, Length, ...)                                 \
    ({                                                                      \
        struct s_tmp {                                                      \
            CSPTR_SENTINEL_DEC                                              \
            __typeof__(__typeof__(Type)[Length]) value;                     \
            f_destructor dtor;                                              \
            struct {                                                        \
                const void *ptr;                                            \
                size_t size;                                                \
            } meta;                                                         \
        } args = {                                                          \
            CSPTR_SENTINEL                                                  \
            __VA_ARGS__                                                     \
        };                                                                  \
        void *var = smalloc(sizeof (Type), Length, Kind, ARGS_);            \
        <span class="hljs-meta-keyword">if</span> (var != NULL)                                                    \
            memcpy(var, &amp;args.value, sizeof (Type));                        \
        var;                                                                \
    })</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sejauh ini, kejelasan belum meningkat, sebelum kita adalah tumpukan makro dalam tradisi terbaik bahasa ini. </font><font style="vertical-align: inherit;">Tapi kita tidak terbiasa mundur. </font><font style="vertical-align: inherit;">Mengurai kusut:</font></font><br>
<br>
<pre><code class="cpp hljs">define CSPTR_SENTINEL        .sentinel_ = <span class="hljs-number">0</span>,<font></font>
define CSPTR_SENTINEL_DEC <span class="hljs-keyword">int</span> sentinel_;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*f_destructor)</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">void</span> *)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lakukan penggantian:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart_arr(Kind, Type, Length, ...)                                 \
    ({                                                                      \
        struct s_tmp {                                                      \
            int sentinel_;                                                  \
            __typeof__(__typeof__(Type)[Length]) value;                     \
            void (*)(void *, void *) dtor;                                  \
            struct {                                                        \
                const void *ptr;                                            \
                size_t size;                                                \
            } meta;                                                         \
        } args = {                                                          \
            .sentinel_ = 0,                                                 \
            __VA_ARGS__                                                     \
        };                                                                  \
        void *var = smalloc(sizeof (Type), Length, Kind, ARGS_);            \
        <span class="hljs-meta-keyword">if</span> (var != NULL)                                                    \
            memcpy(var, &amp;args.value, sizeof (Type));                        \
        var;                                                                \
    })</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dan mencoba memahami apa yang terjadi di sini. </font><font style="vertical-align: inherit;">Kami memiliki struktur tertentu, yang terdiri dari variabel sentinel_, array tertentu (Tipe) [Panjang], pointer ke fungsi destruktor, yang diteruskan di bagian tambahan (...) dari argumen makro, dan struktur meta, yang juga diisi dengan argumen tambahan. </font><font style="vertical-align: inherit;">Berikutnya adalah panggilan</font></font><br>
<br>
<pre><code class="cpp hljs">smalloc(<span class="hljs-keyword">sizeof</span> (Type), Length, Kind, ARGS_);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa itu smalloc? </font><font style="vertical-align: inherit;">Kami menemukan beberapa keajaiban templat lagi (saya sudah melakukan beberapa pergantian di sini):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> pointer_kind {<font></font>
    UNIQUE,<font></font>
    SHARED,<font></font>
    ARRAY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span><font></font>
};<font></font>
<span class="hljs-comment">//..</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><font></font>
    CSPTR_SENTINEL_DEC<font></font>
    <span class="hljs-keyword">size_t</span> size;
    <span class="hljs-keyword">size_t</span> nmemb;
    <span class="hljs-keyword">enum</span> pointer_kind kind;<font></font>
    f_destructor dtor;<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *data;
        <span class="hljs-keyword">size_t</span> size;<font></font>
    } meta;<font></font>
} s_smalloc_args;<font></font>
<span class="hljs-comment">//...</span>
__attribute__ ((<span class="hljs-built_in">malloc</span>)) <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc</span><span class="hljs-params">(s_smalloc_args *args)</span></span>;
<span class="hljs-comment">//...</span>
<span class="hljs-meta">#  <span class="hljs-meta-keyword">define</span> smalloc(...) \
    smalloc(&amp;(s_smalloc_args) { CSPTR_SENTINEL __VA_ARGS__ })</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nah, itu </font><i><font style="vertical-align: inherit;">sebabnya</font></i><font style="vertical-align: inherit;"> kami mencintai C. Ada juga dokumentasi di perpustakaan (orang suci, saya sarankan semua orang untuk mengambil contoh dari mereka): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">smalloc ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memanggil pengalokasi (malloc (3) secara default), pointer yang dikembalikan adalah pointer "pintar". </font><font style="vertical-align: inherit;">&lt;...&gt; Jika ukurannya 0, NULL dikembalikan. </font><font style="vertical-align: inherit;">Jika nmemb adalah 0, maka smalloc akan mengembalikan pointer pintar ke blok memori setidaknya ukuran byte, dan pointer skalar pintar, jika nmemb tidak sama dengan 0, pointer ke blok memori ukuran setidaknya ukuran * nmemb dikembalikan, dan pointer adalah tipe array.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asli</font></font></b>
                        <div class="spoiler_text">«The <b>smalloc</b>() function calls an allocator (<b>malloc</b> (3) by default), such that the returned pointer is a smart pointer. &lt;...&gt; If <b>size</b> is 0, then <b>smalloc</b>() returns NULL. If <b>nmemb</b> is 0, then <b>smalloc</b> shall return a smart pointer to a memory block of at least <b>size</b> bytes, and the smart pointer is a scalar. Otherwise, it shall return a memory block to at least <b>size * nmemb</b> bytes, and the smart pointer is an array.»<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut adalah sumber smalloc:</font></font><br>
<br>
<pre><code class="cpp hljs">__attribute__ ((<span class="hljs-built_in">malloc</span>)) <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc</span><span class="hljs-params">(s_smalloc_args *args)</span> </span>{
    <span class="hljs-keyword">return</span> (args-&gt;nmemb == <span class="hljs-number">0</span> ? smalloc_impl : smalloc_array)(args);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat kode smalloc_impl, mengalokasikan objek tipe skalar. </font><font style="vertical-align: inherit;">Untuk mengurangi volume, saya menghapus kode yang terkait dengan pointer bersama dan membuat penggantian inline dan makro:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">smalloc_impl</span><span class="hljs-params">(s_smalloc_args *args)</span> </span>{
    <span class="hljs-keyword">if</span> (!args-&gt;size)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
    <span class="hljs-comment">// align the sizes to the size of a word</span>
    <span class="hljs-keyword">size_t</span> aligned_metasize = align(args-&gt;meta.size);
    <span class="hljs-keyword">size_t</span> size = align(args-&gt;size);<font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> head_size = <span class="hljs-keyword">sizeof</span> (s_meta);<font></font>
    s_meta_shared *ptr = <span class="hljs-built_in">malloc</span>(head_size + size + aligned_metasize + <span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">size_t</span>));<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
    <span class="hljs-keyword">char</span> *shifted = (<span class="hljs-keyword">char</span> *) ptr + head_size;
    <span class="hljs-keyword">if</span> (args-&gt;meta.size &amp;&amp; args-&gt;meta.data)
        <span class="hljs-built_in">memcpy</span>(shifted, args-&gt;meta.data, args-&gt;meta.size);<font></font>
<font></font>
    <span class="hljs-keyword">size_t</span> *sz = (<span class="hljs-keyword">size_t</span> *) (shifted + aligned_metasize);<font></font>
    *sz = head_size + aligned_metasize;<font></font>
<font></font>
    *(s_meta*) ptr = (s_meta) {<font></font>
        .kind = args-&gt;kind,<font></font>
        .dtor = args-&gt;dtor,<font></font>
        .ptr = sz + <span class="hljs-number">1</span><font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">return</span> sz + <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita melihat bahwa memori untuk variabel dialokasikan, ditambah header tipe s_meta tertentu ditambah area metadata ukuran args-&gt; meta.size selaras dengan ukuran kata, ditambah satu kata lagi (sizeof (size_t)). </font><font style="vertical-align: inherit;">Fungsi mengembalikan pointer ke area memori variabel: ptr + head_size + aligned_metasize + 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mengalokasikan variabel tipe int, diinisialisasi dengan nilai 42:</font></font><br>
<br>
<pre><code class="cpp hljs">smart <span class="hljs-keyword">void</span> *ptr = <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-keyword">int</span>, <span class="hljs-number">42</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini pintar adalah makro:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta"># <span class="hljs-meta-keyword">define</span> smart __attribute__ ((cleanup(sfree_stack)))</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika pointer meninggalkan ruang lingkup, sfree_stack disebut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">CSPTR_INLINE <span class="hljs-keyword">void</span> <span class="hljs-title">sfree_stack</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>{
    <span class="hljs-keyword">union</span> {
        <span class="hljs-keyword">void</span> **real_ptr;
        <span class="hljs-keyword">void</span> *ptr;<font></font>
    } conv;<font></font>
    conv.ptr = ptr;<font></font>
    sfree(*conv.real_ptr);<font></font>
    *conv.real_ptr = <span class="hljs-literal">NULL</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi bebas (disingkat):</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sfree</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span> </span>{<font></font>
    s_meta *meta = get_meta(ptr);<font></font>
    dealloc_entry(meta, ptr);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi dealloc_entry, pada dasarnya, memanggil destruktor kustom jika kita menentukannya dalam argumen unique_ptr, dan penunjuknya disimpan dalam metadata. </font><font style="vertical-align: inherit;">Jika tidak, hanya gratis (meta) yang dieksekusi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar sumber: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[1] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atribut Variabel Umum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[2] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara yang baik dan idiomatis untuk menggunakan GCC dan membunyikan __attribute __ ((pembersihan)) dan deklarasi pointer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[3] </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan atribut variabel __cleanup__ dalam GCC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id503522/index.html">Dunia setelah 2020 (esai)</a></li>
<li><a href="../id503524/index.html">Sebagai pendaftar domain, Pendaftar P01 menyerahkan pelanggannya</a></li>
<li><a href="../id503526/index.html">Django ORM untuk Pemula | Kami mengoptimalkan permintaan</a></li>
<li><a href="../id503530/index.html">Penurunan profesional Anda akan datang (jauh) lebih cepat dari yang Anda pikirkan</a></li>
<li><a href="../id503532/index.html">Bagaimana belanja online di AS telah berubah karena coronavirus</a></li>
<li><a href="../id503540/index.html">Pergi ke frontend setelah dekrit, jadilah penandatangan di Gitlab dan anggota tim inti Vue.js</a></li>
<li><a href="../id503542/index.html">Pengalaman dengan filter Kalman pada contoh data NMEA</a></li>
<li><a href="../id503544/index.html">Podcast: AR di stadion, pemodelan proses dunia nyata, dan pengembang game multidisiplin</a></li>
<li><a href="../id503546/index.html">Contoh sederhana analisis kluster preferensi alkohol menurut negara untuk R</a></li>
<li><a href="../id503552/index.html">DIT Moskwa saat memeriksa izin menerima izin untuk mengirim iklan selama 10 tahun ke depan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>