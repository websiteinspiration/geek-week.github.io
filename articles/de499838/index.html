<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚗 💪🏿 ⚰️ .NET: Abhängigkeitsbehandlung 🔆 🖕🏽 🤘🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wer hat aufgrund der Baugruppenumleitung keine Probleme festgestellt? Höchstwahrscheinlich wird jeder, der eine relativ große Anwendung entwickelt hat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: Abhängigkeitsbehandlung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer hat aufgrund der Baugruppenumleitung keine Probleme festgestellt? </font><font style="vertical-align: inherit;">Höchstwahrscheinlich wird jeder, der eine relativ große Anwendung entwickelt hat, früher oder später mit diesem Problem konfrontiert sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt arbeite ich bei JetBrains im JetBrains Rider-Projekt und bin an der Migration von Rider zu .NET Core beteiligt. </font><font style="vertical-align: inherit;">Zuvor war er in Circuit, einer Cloud-basierten Anwendungshosting-Plattform, mit der gemeinsamen Infrastruktur beschäftigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter der Zwischensequenz befindet sich das Protokoll meines Berichts von der Moskauer DotNext 2019-Konferenz, auf der ich über die Schwierigkeiten bei der Arbeit mit Baugruppen in .NET sprach und anhand praktischer Beispiele zeigte, was passiert und wie damit umzugehen ist.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Projekten, in denen ich als .NET-Entwickler gearbeitet habe, musste ich mich mit verschiedenen Problemen beim Verbinden von Abhängigkeiten und Laden von Assemblys befassen. </font><font style="vertical-align: inherit;">Wir werden darüber reden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poststruktur:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängigkeitsprobleme</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Rig-Beladung</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindungsumleitungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Benennung</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gemeinsame Frameworks, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängigkeitsmanifest (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks, um JetBrains Rider auf Core auszuführen</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug-Assembly-Downloads</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionsprotokolle</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laufzeitereignisse</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind einige Abhängigkeitsprobleme?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als sie Anfang der 2000er Jahre mit der Entwicklung von .NET Framework begannen, war das Problem der Abhängigkeitshölle bereits bekannt, als Entwickler in allen Bibliotheken wichtige Änderungen zulassen und diese Bibliotheken für die Verwendung mit bereits kompiliertem Code nicht mehr kompatibel sind. </font><font style="vertical-align: inherit;">Wie kann man ein solches Problem lösen? </font><font style="vertical-align: inherit;">Die erste Lösung liegt auf der Hand. </font><font style="vertical-align: inherit;">Behalten Sie immer die Abwärtskompatibilität bei. </font><font style="vertical-align: inherit;">Dies ist natürlich nicht sehr realistisch, da das Brechen von Änderungen sehr einfach in Code zu integrieren ist. </font><font style="vertical-align: inherit;">Zum Beispiel: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen und .NET-Bibliotheken auflösen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein spezielles Beispiel für .NET. Wir haben eine Methode und haben beschlossen, einen Parameter mit einem Standardwert hinzuzufügen. Der Code wird weiterhin kompiliert, wenn wir ihn wieder zusammensetzen, aber binär sind es zwei völlig unterschiedliche Methoden: Eine Methode hat keine Argumente, die zweite Methode hat ein Argument. Wenn der Entwickler innerhalb der Abhängigkeit die Abwärtskompatibilität auf diese Weise unterbrochen hat, können wir den Code, der mit dieser Abhängigkeit von der vorherigen Version kompiliert wurde, nicht verwenden.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Lösung für Abhängigkeitsprobleme besteht darin, die Versionierung von Bibliotheken und Assemblys hinzuzufügen - alles. Möglicherweise gibt es unterschiedliche Versionsregeln. Der Punkt ist, dass wir verschiedene Versionen derselben Bibliothek irgendwie voneinander unterscheiden können und Sie verstehen können, ob das Update nicht funktioniert oder nicht. Sobald wir die Versionen einführen, tritt leider ein anderes Problem auf. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Version Hölle ist die Unfähigkeit, eine Abhängigkeit zu verwenden, die binär kompatibel ist, aber gleichzeitig eine Version hat, die nicht zur Laufzeit passt, oder eine andere Komponente, die diese Versionen überprüft. In .NET ist FileLoadException eine typische Manifestation der Version Hell, obwohl die Datei auf der Festplatte liegt, aber aus irgendeinem Grund nicht mit Laufzeit geladen wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET haben Assemblys viele verschiedene Versionen - sie haben versucht, Versions-Hells auf verschiedene Weise zu reparieren und zu sehen, was passiert ist. Wir haben ein Paket </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Viele Leute kennen ihn. Er hat die neueste Version des NuGet-Pakets 1.6.0. Es enthält eine Bibliothek, eine Assembly mit Version 1.2.4.0. Sie haben erhalten, dass Sie keine Build-Bibliothek Version 1.2.4.0 haben. Wie kann man verstehen, dass es im NuGet-Paket 1.6.0 liegt? Es wird nicht einfach. Zusätzlich zur Assembly-Version verfügt diese Bibliothek über mehrere weitere Versionen. Zum Beispiel Assembly Assembly Version, Assembly Information Version. Dieses NuGet-Paket enthält tatsächlich drei verschiedene Assemblys mit denselben Versionen (für verschiedene Versionen des .NET-Standards). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET-Dokumentation </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild-Standard</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde viel Dokumentation zum Arbeiten mit Assemblys in .NET geschrieben. </font><font style="vertical-align: inherit;">Es gibt einen .NET-Leitfaden für die Entwicklung moderner .NET-Anwendungen, der .NET Framework, .NET Standard, .NET Core, Open Source und alles Mögliche berücksichtigt. </font><font style="vertical-align: inherit;">Etwa 30% des gesamten Dokuments sind dem Laden von Baugruppen gewidmet. </font><font style="vertical-align: inherit;">Wir werden spezifische Probleme und Beispiele analysieren, die auftreten können.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das alles notwendig? </font><font style="vertical-align: inherit;">Erstens, um nicht auf einen Rechen zu treten. </font><font style="vertical-align: inherit;">Zweitens können Sie den Benutzern Ihrer Bibliotheken das Leben erleichtern, da sie mit Ihrer Bibliothek nicht die Abhängigkeitsprobleme haben, an die sie gewöhnt sind. </font><font style="vertical-align: inherit;">Es hilft Ihnen auch bei der Migration komplexer Anwendungen zu .NET Core. </font><font style="vertical-align: inherit;">Und um das Ganze abzurunden, können Sie ein SRE werden. Dies ist ein Senior (Binding) Redirect-Ingenieur, zu dem jeder im Team kommt und fragt, wie er eine weitere Weiterleitung schreiben soll.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Montage Laden</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das strikte Laden von Assemblys ist das Hauptproblem, mit dem Entwickler in .NET Framework konfrontiert sind. </font><font style="vertical-align: inherit;">Es wird ausgedrückt in </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bevor ich mit dem Laden der strengen Baugruppe fortfahre, möchte ich Sie an einige grundlegende Dinge erinnern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine .NET-Anwendung erstellen, erhalten Sie ein Artefakt, das sich normalerweise in Bin / Debug oder Bin / Release befindet und einen bestimmten Satz von Assembly-Assemblys und Konfigurationsdateien enthält. </font><font style="vertical-align: inherit;">Baugruppen beziehen sich auf Namen und Namen der Baugruppe. </font><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, dass sich Assembly-Links direkt in der Assembly befinden, die auf diese Assembly verweist. Es gibt keine magischen Konfigurationsdateien, in die Assembly-Referenzen geschrieben werden. </font><font style="vertical-align: inherit;">Auch wenn es Ihnen so scheint, als ob solche Dateien existieren. </font><font style="vertical-align: inherit;">Referenzen befinden sich in den Baugruppen selbst in binärer Form.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET gibt es einen Prozess zum Auflösen von Assemblys. In diesem Fall wird die Assemblydefinition bereits in eine echte Assembly konvertiert, die sich auf der Festplatte befindet oder irgendwo im Speicher geladen ist. Das Auflösen von Assemblys wird zweimal durchgeführt: In der Build-Phase, wenn Sie Referenzen in * .csproj haben, und zur Laufzeit, wenn Sie Referenzen in den Assemblys haben, und nach einigen Regeln werden sie zu Assemblys, die heruntergeladen werden können. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Einfacher Name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kultur = neutral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Starker Name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kultur = neutral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir zum Problem. Baugruppenname Es gibt zwei Haupttypen. Die erste Art von Baugruppenname ist Einfacher Name. Sie sind leicht daran zu erkennen, dass sie PublicKeyToken = null haben. Es gibt einen starken Namen, es ist leicht, sie daran zu erkennen, dass ihr PublicKeyToken nicht null ist, sondern einen gewissen Wert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir ein Beispiel. Wir haben ein Programm, das von der Bibliothek mit MyUtils-Dienstprogrammen abhängt, und die Version von MyUtils ist 9.0.0.0. Das gleiche Programm hat einen Link zu einer anderen Bibliothek. Diese Bibliothek möchte auch MyUtils verwenden, jedoch Version 6.0.0.0. MyUtils Version 9.0.0.0 und Version 6.0.0.0 haben PublicKeyToken = null, dh sie haben einen einfachen Namen. Welche Version fällt in das binäre Artefakt 6.0.0.0 oder 9.0.0.0? 9. Version. Kann MyLibrary MyUtils Version 9.0.0.0 verwenden, die in das binäre Artefakt gelangt ist?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich kann dies der Fall sein, da MyUtils einen einfachen Namen hat und dementsprechend das Laden der strengen Assembly nicht vorhanden ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderes Beispiel. </font><font style="vertical-align: inherit;">Anstelle von MyUtils haben wir eine vollständige Bibliothek von NuGet, die einen starken Namen hat. </font><font style="vertical-align: inherit;">Die meisten Bibliotheken in NuGet haben einen starken Namen.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Build-Phase wird Version 9.0.0.0 in BIN kopiert, aber zur Laufzeit erhalten wir die berühmte </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit MyLibrary, die Version 6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden soll, Version 9.0.0.0 verwenden kann, müssen Sie die Bindungsumleitung an schreiben </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindungsumleitungen</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Umleiten von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Assemblyversionen</font></a><font style="vertical-align: inherit;"> Es wird angegeben, dass eine Assembly mit einem solchen Namen und einem solchen publicKeyToken von einem solchen Versionsbereich zu einem solchen Versionsbereich umgeleitet werden muss. </font><font style="vertical-align: inherit;">Es scheint eine sehr einfache Aufzeichnung zu sein, aber sie befindet sich hier </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, könnte sich aber in anderen Dateien befinden. </font><font style="vertical-align: inherit;">In </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Framework befindet sich zur Laufzeit </font><font style="vertical-align: inherit;">eine Datei </font><font style="vertical-align: inherit;">, in der einige Standardumleitungen definiert sind, die von Version zu Version von .NET Framework unterschiedlich sein können. </font><font style="vertical-align: inherit;">Es kann vorkommen, dass in 4.7.1 nichts für Sie funktioniert, in 4.7.2 jedoch bereits oder umgekehrt. </font><font style="vertical-align: inherit;">Sie müssen berücksichtigen, dass Weiterleitungen nicht nur von Ihnen stammen </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">können. Dies sollte beim Debuggen berücksichtigt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir vereinfachen das Schreiben von Weiterleitungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Niemand möchte verbindliche Weiterleitungen mit den Händen schreiben. Geben wir diese Aufgabe an MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivieren und Deaktivieren der automatischen Bindungsumleitung</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Einige Tipps zur Vereinfachung der Arbeit mit der Bindungsumleitung. Tipp 1: Aktivieren Sie die automatische Generierung der Bindungsumleitung in MSBuild. Von Eigentum in eingeschaltet </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beim Erstellen eines Projekts fällt es in ein binäres Artefakt </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Weiterleitungen zu Versionen von Bibliotheken anzeigt, die sich im selben Artefakt befinden. Dies funktioniert nur zum Ausführen von Anwendungen, Konsolenanwendungen und WinExe. Für Bibliotheken funktioniert dies nicht, da für Bibliotheken</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meistens ist es einfach nicht relevant, da es für eine Anwendung relevant ist, die Assemblys selbst startet und lädt. Wenn Sie eine Konfiguration für die Bibliothek vorgenommen haben, können sich in der Anwendung auch einige Abhängigkeiten von denen unterscheiden, die beim Erstellen der Bibliothek vorhanden waren, und es stellt sich heraus, dass die Konfiguration für die Bibliothek nicht sehr sinnvoll ist. Trotzdem sind manchmal für Bibliotheken Konfigurationen immer noch sinnvoll. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation, wenn wir Tests schreiben. Tests werden normalerweise in ClassLibrary gefunden und benötigen auch Weiterleitungen. Test-Frameworks können erkennen, dass die Bibliothek mit Tests eine DLL-Konfiguration hat, und die darin enthaltenen Weiterleitungen gegen den Code aus den Tests austauschen. Sie können diese Weiterleitungen automatisch generieren. Wenn wir ein altes Format haben</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im SDK-Stil können Sie auf einfache Weise den OutputType in Exe ändern und einen leeren Einstiegspunkt hinzufügen. Dadurch wird MSBuild gezwungen, Weiterleitungen zu generieren. Sie können den anderen Weg gehen und den Hack verwenden. Sie können eine weitere Eigenschaft hinzufügen </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass MSBuild berücksichtigt, dass für diesen OutputType noch Bindungsumleitungen generiert werden müssen. Obwohl diese Methode wie ein Hack aussieht, können Sie Weiterleitungen für Bibliotheken generieren, die in Exe nicht wiederholt werden können, sowie für andere Arten von Projekten (außer Tests). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das neue Format werden </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterleitungen selbst generiert, wenn Sie modernes Microsoft.NET.Test.Sdk verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dritter Tipp: Verwenden Sie die Bindungsumleitungsgenerierung nicht mit NuGet. NuGet bietet die Möglichkeit, eine Bindungsumleitung für Bibliotheken zu generieren, die von Paketen auf die neuesten Versionen übertragen werden. Dies ist jedoch nicht die beste Option. Alle diese Weiterleitungen müssen hinzugefügt </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und festgeschrieben werden. Wenn Sie mit MSBuild Weiterleitungen generieren, werden während der Erstellung Weiterleitungen generiert. Wenn Sie sie festschreiben, können Zusammenführungskonflikte auftreten. Sie können einfach vergessen, die Bindungsumleitung in der Datei zu aktualisieren, und wenn sie während des Builds generiert werden, werden Sie nicht vergessen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baugruppenreferenz </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auflösen Bindungsumleitungen generieren</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hausaufgaben für diejenigen, die besser verstehen möchten, wie die Generierung von Bindungsumleitungen funktioniert: Finden Sie heraus, wie es funktioniert, lesen Sie dies im Code. Wechseln Sie in das .NET-Verzeichnis und stoßen Sie überall auf die Eigenschaft name, mit der die Generierung aktiviert wird. Dies ist im Allgemeinen ein so gängiger Ansatz. Wenn es eine seltsame Eigenschaft für MSBuild gibt, können Sie die Verwendung nutzen. Glücklicherweise wird Eigenschaft normalerweise in XML-Konfigurationen verwendet, und Sie können ihre Verwendung leicht finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie untersuchen, was in diesen XML-Zielen enthalten ist, werden Sie feststellen, dass diese Eigenschaft zwei MSBuild-Aufgaben auslöst. Die erste Aufgabe wird aufgerufen </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und generiert eine Reihe von Weiterleitungen, die in Dateien geschrieben werden. Die zweite Aufgabe </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schreibt die Ergebnisse der ersten Aufgabe in</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt eine XML-Logik, die den Vorgang der ersten Aufgabe leicht korrigiert und unnötige Weiterleitungen entfernt oder neue hinzufügt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative zu XML-Konfigurationen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht immer bequem, Weiterleitungen in der XML-Konfiguration beizubehalten. </font><font style="vertical-align: inherit;">Es kann vorkommen, dass die Anwendung das Plugin herunterlädt und dieses Plugin andere Bibliotheken verwendet, für die Weiterleitungen erforderlich sind. </font><font style="vertical-align: inherit;">In diesem Fall sind uns möglicherweise die benötigten Weiterleitungen nicht bekannt, oder wir möchten möglicherweise kein XML generieren. </font><font style="vertical-align: inherit;">In einer solchen Situation können wir eine AppDomain erstellen und beim Erstellen immer noch dorthin übertragen, wo sich das XML mit den erforderlichen Weiterleitungen befindet. </font><font style="vertical-align: inherit;">Wir können Fehler beim Laden von Baugruppen auch direkt zur Laufzeit behandeln. </font><font style="vertical-align: inherit;">Rantime .NET bietet eine solche Möglichkeit.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; <font></font>
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es hat ein Ereignis, es heißt </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie dieses Ereignis abonnieren, erhalten wir Fehler zu allen fehlgeschlagenen Assembly-Downloads. Wir erhalten den Namen der Baugruppe, die nicht geladen wurde, und wir erhalten die Baugruppenbaugruppe, die das Laden der ersten Baugruppe angefordert hat. Hier können wir die Assembly manuell von der richtigen Stelle laden, z. B. die Version löschen, sie einfach aus der Datei entnehmen und dieses Ereignis vom Handler zurückgeben. Oder geben Sie null zurück, wenn wir nichts zurückgeben müssen, wenn wir die Assembly nicht laden können. PublicKeyToken sollte gleich sein, Assemblys mit unterschiedlichen PublicKeyToken sind in keiner Weise miteinander befreundet.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Ereignis gilt nur für eine Anwendungsdomäne. </font><font style="vertical-align: inherit;">Wenn unser Plugin eine AppDomain in sich selbst erstellt, funktioniert diese Umleitung in der Laufzeit in ihnen nicht. </font><font style="vertical-align: inherit;">Sie müssen dieses Ereignis in der gesamten AppDomain abonnieren, die das Plugin erstellt hat. </font><font style="vertical-align: inherit;">Wir können dies mit dem AppDomainManager tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager ist eine separate Assembly, die eine Klasse enthält, die eine bestimmte Schnittstelle implementiert. Mit einer der Methoden dieser Schnittstelle können Sie jede neue AppDomain initialisieren, die in der Anwendung erstellt wird. </font><font style="vertical-align: inherit;">Sobald die AppDomain erstellt wurde, wird diese Methode aufgerufen. </font><font style="vertical-align: inherit;">Darin können Sie dieses Ereignis abonnieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Striktes Laden von Assemblys und .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET Core gibt es kein Problem namens "Striktes Laden von Assemblys". Dies liegt daran, dass für signierte Assemblys genau die angeforderte Version erforderlich ist. Es gibt noch eine andere Anforderung. Unabhängig davon, ob sie mit einem starken Namen signiert sind oder nicht, wird für alle Assemblys überprüft, ob die zur Laufzeit geladene Version größer oder gleich der vorherigen ist. Wenn wir uns in einer Situation mit einer Anwendung mit Plugins befinden, kann es vorkommen, dass das Plugin beispielsweise aus einer neuen Version des SDK erstellt wurde und die Anwendung, in die es heruntergeladen wird, die bisherige alte Version des SDK verwendet und nicht auseinanderfällt. Wir können dieses Ereignis auch abonnieren, jedoch bereits in .NET Core, und die vorhandene Assembly laden. Wir können diesen Code schreiben:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;<font></font>
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Namen der Assembly, die nicht gestartet wurde. Wir machen die Version ungültig und rufen sie </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von derselben Version aus auf. Hier findet keine Rekursion statt, da ich die Rekursion bereits überprüft habe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war notwendig, MyUtils Version 0.0.2.0 herunterzuladen. In BIN haben wir MyUtils Version 0.0.1.0. Wir haben eine Umleitung von Version 0.0.2.0 zu Version 0.0 durchgeführt. Version 0.0.1.0 wird bei uns nicht geladen. Ein Exit wird für uns herausfliegen, dass es nicht möglich war, die Assembly mit Version 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu laden </font><font style="vertical-align: inherit;">. 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16–1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span><font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Versionsklasse sind nicht alle Komponenten obligatorisch, und anstelle der optionalen Komponenten –1 werden sie gespeichert. Irgendwo im Inneren tritt jedoch ein Überlauf auf, und es werden </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die 2 </font><sup><font style="vertical-align: inherit;">16–1</font></sup><font style="vertical-align: inherit;"> erhalten </font><font style="vertical-align: inherit;">. Bei Interesse können Sie versuchen, genau herauszufinden, wo der Überlauf auftritt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit Reflection-Assemblys arbeiten und alle Typen abrufen möchten, kann es sein, dass nicht alle Typen Ihre GetTypes-Methode erhalten können. Eine Assembly hat eine Klasse, die von einer anderen Klasse erbt, die sich in einer Assembly befindet, die nicht geladen ist.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall besteht das Problem darin, dass eine ReflectionTypeLoadException ausgelöst wird. </font><font style="vertical-align: inherit;">Im Inneren </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich eine Eigenschaft, in die sich die Typen befinden, die noch geladen werden konnten. </font><font style="vertical-align: inherit;">Nicht alle gängigen Bibliotheken berücksichtigen dies. </font><font style="vertical-align: inherit;">AutoMapper, mindestens eine seiner Versionen, fiel bei ReflectionTypeLoadException einfach aus, anstatt die Typen aus dem Inneren der Ausnahme auszuwählen.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Benennung</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baugruppen mit starken Namen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns darüber sprechen, was das Laden strenger Baugruppen verursacht. Dies ist ein starker Name. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starker Name ist die Signatur der Assembly durch einen privaten Schlüssel mit asymmetrischer Verschlüsselung. PublicKeyToken ist der Public-Key-Hash dieser Assembly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Strong Naming können Sie zwischen verschiedenen Assemblys mit demselben Namen unterscheiden. Zum Beispiel ist MyUtils kein eindeutiger Name. Es kann mehrere Assemblys mit diesem Namen geben. Wenn Sie jedoch Strong Name signieren, haben diese unterschiedliche PublicKeyToken und wir können sie auf diese Weise unterscheiden. Für einige Assembly-Ladeszenarien ist ein starker Name erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel, um eine Assembly im globalen Assemblycache zu installieren oder mehrere Versionen von nebeneinander gleichzeitig herunterzuladen. </font><font style="vertical-align: inherit;">Am wichtigsten ist, dass stark benannte Assemblys nur auf andere stark benannte Assemblys verweisen können. </font><font style="vertical-align: inherit;">Da einige Benutzer ihre Builds mit einem starken Namen signieren möchten, signieren die Bibliotheksentwickler auch ihre Bibliotheken, damit Benutzer sie einfacher installieren können und die Benutzer diese Bibliotheken nicht erneut signieren müssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starker Name: Vermächtnis?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Namens- und .NET-Bibliotheken</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft sagt in MSDN ausdrücklich, dass Sie aus Sicherheitsgründen keinen starken Namen verwenden sollten, sondern nur, um verschiedene Assemblys mit demselben Namen zu unterscheiden. Der Assembly-Schlüssel kann in keiner Weise geändert werden. Wenn Sie ihn geändert haben, werden die Weiterleitungen an alle Benutzer unterbrochen. Wenn Sie einen privaten Teil des Schlüssels für den Namen "Stark" für den öffentlichen Zugriff verloren haben, können Sie diese Signatur in keiner Weise zurückziehen. Das SNK-Dateiformat, in dem sich der starke Name befindet, bietet keine solche Möglichkeit, und andere Formate zum Speichern von Schlüsseln enthalten mindestens einen Link zur Sperrliste für CRL-Zertifikate, anhand derer verstanden werden kann, dass dieses Zertifikat nicht mehr gültig ist. In SNK gibt es nichts Vergleichbares.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Open-Source-Handbuch enthält die folgenden Empfehlungen. Erstens, zusätzlich zu Sicherheitszwecken andere Technologien verwenden. Zweitens wird bei einer Open-Source-Bibliothek im Allgemeinen empfohlen, den privaten Teil des Schlüssels in das Repository zu übernehmen, damit die Benutzer Ihre Bibliothek leichter aufteilen, neu erstellen und in eine vorgefertigte Anwendung einfügen können. Drittens ändern Sie niemals den starken Namen. Zu destruktiv. Trotz der Tatsache, dass es zu destruktiv ist und im Open-Source-Handbuch darüber geschrieben wird, hat Microsoft manchmal Probleme mit seinen eigenen Bibliotheken.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine Bibliothek namens System.Reactive. </font><font style="vertical-align: inherit;">Bisher waren dies mehrere NuGet-Pakete, eines davon ist Rx-Linq. </font><font style="vertical-align: inherit;">Dies ist nur ein Beispiel, das auch für den Rest der Pakete gilt. </font><font style="vertical-align: inherit;">In der zweiten Version wurde es mit einem Microsoft-Schlüssel signiert. </font><font style="vertical-align: inherit;">In der dritten Version wechselte er in das Repository des Projekts </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und erhielt eine .NET Foundation-Signatur. </font><font style="vertical-align: inherit;">Die Bibliothek hat tatsächlich den Namen Strong geändert. </font><font style="vertical-align: inherit;">Das NuGet-Paket wurde umbenannt, aber die Assembly wird im Inneren genauso wie zuvor aufgerufen. </font><font style="vertical-align: inherit;">Wie leite ich von der zweiten Version zur dritten um? </font><font style="vertical-align: inherit;">Diese Weiterleitung kann nicht durchgeführt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Namensvalidierung</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewusst wie: Deaktivieren Sie die Umgehungsfunktion für starke Namen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Argument, dass Strong Name bereits der Vergangenheit angehört und rein formal bleibt, ist, dass sie nicht validiert werden. Wir haben eine signierte Assembly und möchten einen Fehler darin beheben, haben jedoch keinen Zugriff auf die Quellen. Wir können einfach dnSpy verwenden - dies ist ein Dienstprogramm, mit dem Sie bereits kompilierte Assemblys dekompilieren und reparieren können. Alles wird für uns funktionieren. Da standardmäßig die Umgehung der Überprüfung starker Namen aktiviert ist, wird nur überprüft, ob das PublicKeyToken gleich ist, und die Integrität der Signatur selbst wird nicht überprüft. Möglicherweise gibt es Umweltstudien, in denen die Signatur noch überprüft wird, und hier ist IIS ein anschauliches Beispiel. Die Signaturintegrität wird in IIS überprüft (die Umgehung der Validierung starker Namen ist standardmäßig deaktiviert), und alles wird unterbrochen, wenn wir die signierte Assembly bearbeiten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusatz:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die Signaturüberprüfung für die Assembly mithilfe des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">öffentlichen Zeichens</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deaktivieren </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">.</font></a><font style="vertical-align: inherit;"> Damit wird nur der öffentliche Schlüssel zum Signieren verwendet, was die Sicherheit des Assemblynamens gewährleistet. Die von Microsoft verwendeten öffentlichen Schlüssel werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier veröffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Rider kann das öffentliche Zeichen in den Projekteigenschaften aktiviert werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann müssen die Versionen der Dateibaugruppe geändert werden?</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Open-Source-Handbuch bietet auch einige Versionsrichtlinien, mit denen die Anzahl der erforderlichen Bindungsumleitungen und Änderungen für Benutzer im NET Framework verringert werden soll. Diese Versionsrichtlinie besagt, dass wir die Assembly-Version nicht ständig ändern sollten. Dies kann natürlich zu Problemen bei der Installation im GAC führen, sodass das installierte native Image möglicherweise nicht der Assembly entspricht und Sie die JIT-Kompilierung erneut durchführen müssen. Meiner Meinung nach ist dies jedoch weniger schlimm als die Probleme bei der Versionierung. Bei CrossGen werden native Assemblys nicht global installiert - es treten keine Probleme auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das NuGet-Paket Newtonsoft.Json verfügt beispielsweise über mehrere Versionen: 12.0.1, 12.0.2 usw. Alle diese Pakete verfügen über eine Assembly mit Version 12.0.0.0. </font><font style="vertical-align: inherit;">Die Empfehlung lautet, dass die Assembly-Version aktualisiert werden sollte, wenn sich eine Hauptversion des NuGet-Pakets ändert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befolgen Sie die Tipps für .NET Framework: Generieren Sie Weiterleitungen manuell und versuchen Sie, in allen Projekten Ihrer Lösung dieselbe Version von Abhängigkeiten zu verwenden. </font><font style="vertical-align: inherit;">Dies sollte die Anzahl der Weiterleitungen erheblich minimieren. </font><font style="vertical-align: inherit;">Sie benötigen eine starke Benennung nur, wenn Sie ein bestimmtes Build-Ladeszenario haben, in dem es benötigt wird, oder wenn Sie eine Bibliothek entwickeln und das Leben für Benutzer vereinfachen möchten, die eine starke Benennung wirklich benötigen. </font><font style="vertical-align: inherit;">Ändern Sie nicht den starken Namen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Standard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen zu .NET Standard über. Es ist ziemlich eng mit der Version Hell in .NET Framework verwandt. .NET Standard ist ein Tool zum Schreiben von Bibliotheken, die mit verschiedenen Implementierungen der .NET-Plattform kompatibel sind. Implementierungen beziehen sich auf .NET Framework, .NET Core, Mono, Unity und Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Link zur Dokumentation</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die .NET Standard-Unterstützungstabelle für verschiedene Versionen verschiedener Versionen von Laufzeiten. Und hier können wir sehen, dass .NET Framework die .NET Standard Version 2.1 in keiner Weise unterstützt. Die Veröffentlichung von .NET Framework, das .NET Standard 2.1 und höher unterstützt, ist noch nicht geplant. Wenn Sie eine Bibliothek entwickeln und möchten, dass sie für Benutzer in .NET Framework funktioniert, müssen Sie ein Ziel für .NET Standard 2.0 haben. Neben der Tatsache, dass .NET Framework die neueste Version des .NET-Standards nicht unterstützt, sollten wir auf das Sternchen achten. .NET Framework 4.6.1 unterstützt .NET Standard 2.0, jedoch mit einem Sternchen. Es gibt eine solche Fußnote direkt in der Dokumentation, woher ich diese Tabelle habe.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispielprojekt. Eine Anwendung in .NET Framework mit einer Abhängigkeit für den .NET-Standard. So etwas wie das: ConsoleApp und ClassLibrary. Zielbibliothek .NET Standard. Wenn wir dieses Projekt zusammenstellen, wird es in unserem BIN so sein. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden dort hundert DLLs haben, von denen sich nur eine auf die Anwendung bezog, alles andere kam, um den .NET-Standard zu unterstützen. Tatsache ist, dass .NET Standard 2.0 später als .NET Framework 4.6.1 erschien, sich jedoch gleichzeitig als API-kompatibel herausstellte und die Entwickler beschlossen, .NET 4.6.1 um Standard 2.0-Unterstützung zu erweitern. Wir haben es nicht nativ gemacht (durch Aufnahme </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die Laufzeit selbst), sondern so, dass .NET Standard * .dll und alle anderen Baugruppenfassaden direkt in BIN platziert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Abhängigkeiten der Version von .NET Framework ansehen, auf die wir abzielen, und die Anzahl der Bibliotheken, die in die BIN fallen, werden wir feststellen, dass es in 4.7.1 nicht so viele davon gibt, und seit 4.7.2 gibt es überhaupt keine zusätzlichen Bibliotheken und .NET Standard wird dort nativ unterstützt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Tweet von einem der .NET-Entwickler, der dieses Problem beschreibt und die Verwendung von .NET Framework Version 4.7.2 empfiehlt, wenn wir über .NET Standard-Bibliotheken verfügen. </font><font style="vertical-align: inherit;">Nicht einmal mit Version 2.0 hier, sondern mit Version 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn möglich, erhöhen Sie das Ziel-Framework in Ihrem Projekt auf mindestens 4.7.1, vorzugsweise 4.7.2. </font><font style="vertical-align: inherit;">Wenn Sie eine Bibliothek entwickeln, um Bibliotheksbenutzern das Leben zu erleichtern, erstellen Sie ein separates Ziel für .NET Framework. Dadurch wird eine große Anzahl von DLLs vermieden, die mit etwas in Konflikt stehen können.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einer allgemeinen Theorie. </font><font style="vertical-align: inherit;">Wir werden diskutieren, wie wir JetBrains Rider auf .NET Core gestartet haben und warum wir überhaupt darüber sprechen sollten. </font><font style="vertical-align: inherit;">Rider ist ein sehr großes Projekt, es hat eine riesige Unternehmenslösung mit einer großen Anzahl verschiedener Projekte, ein komplexes System von Abhängigkeiten. Sie können es nicht einfach nehmen und gleichzeitig auf eine andere Laufzeit migrieren. </font><font style="vertical-align: inherit;">Dazu müssen wir einige Hacks verwenden, die wir auch analysieren werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core-Anwendung</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie sieht eine typische .NET Core-Anwendung aus? Hängt davon ab, wie genau es bereitgestellt wird und was es letztendlich tun wird. Wir können mehrere Szenarien haben. Die erste ist eine Framework-abhängige Bereitstellung. Dies ist dasselbe wie in .NET Framework, wenn die Anwendung die auf dem Computer vorinstallierte Laufzeit verwendet. Es kann sich um eine eigenständige Bereitstellung handeln. In diesem Fall verfügt die Anwendung über eine Laufzeit. Möglicherweise gibt es eine Bereitstellung mit nur einer Datei. In diesem Fall erhalten wir eine Exe-Datei. Im Fall von .NET Core in dieser Exe-Datei befindet sich jedoch ein Artefakt einer in sich geschlossenen Anwendung. Dies ist ein selbstextrahierendes Archiv. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nur die Framework-abhängige Bereitstellung berücksichtigen. Wir haben eine DLL mit der Anwendung, es gibt zwei Konfigurationsdateien, von denen die erste erforderlich ist, diese </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ab .NET Core 3.0 wird eine exe-Datei generiert, die erforderlich ist, damit die Anwendung bequemer ausgeführt werden kann, sodass Sie unter Windows nicht den Befehl .NET eingeben müssen. </font><font style="vertical-align: inherit;">Abhängigkeiten fallen in dieses Artefakt, beginnend mit .NET Core 3.0. In .NET Core 2.1 müssen Sie eine andere Eigenschaft veröffentlichen oder verwenden </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gemeinsame Frameworks, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enthält die Laufzeiteinstellungen, die zum Ausführen erforderlich sind. Es gibt an, unter welchem ​​Shared Framework die Anwendung gestartet wird, und es sieht so aus. Wir weisen darauf hin, dass die Anwendung unter "Microsoft.NETCore.App" Version 3.0.0 ausgeführt wird. Möglicherweise gibt es ein anderes freigegebenes Framework. Hier können auch andere Einstellungen vorgenommen werden. Sie können beispielsweise den Server Garbage Collector aktivieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">während der Montage des Projekts generiert. Und wenn wir den Server-GC einbinden möchten, müssen wir diese Datei im Voraus irgendwie ändern, noch bevor wir das Projekt zusammenstellen oder von Hand hinzufügen. Hier können Sie Ihre Einstellungen hinzufügen. Wir können entweder Eigenschaften in aufnehmen </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wenn diese Eigenschaften von .NET-Entwicklern bereitgestellt werden, oder wenn Eigenschaften nicht bereitgestellt werden, können wir eine Datei mit dem Namen erstellen</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schreiben Sie hier die notwendigen Einstellungen. Während der Montage werden dieser Vorlage weitere erforderliche Einstellungen hinzugefügt, z. B. dasselbe Shared Framework. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Shared Framework besteht aus einer Reihe von Laufzeitprogrammen und Bibliotheken. In der Tat war das gleiche wie die .NET Framework-Laufzeit, die früher nur einmal auf dem Computer installiert wurde und für alle eine Version war. Shared Framework und im Gegensatz zu einer einzelnen .NET Framework-Laufzeit können verschiedene Anwendungen unterschiedliche Versionen der installierten Laufzeiten verwenden. Auch Shared Framework kann vererbt werden. Das Shared Framework selbst kann an solchen Stellen auf der Festplatte angezeigt werden, die normalerweise auf dem System installiert sind.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mehrere Standard-Shared Frameworks, z. B. Microsoft.NETCore.App, auf dem herkömmliche Konsolenanwendungen ausgeführt werden, AspNetCore.App für Webanwendungen und WindowsDesktop.App, das neue Shared Framework in .NET Core 3, auf dem Desktopanwendungen ausgeführt werden. unter Windows Forms und WPF. Die letzten beiden Shared Frameworks ergänzen im Wesentlichen das erste, das für Konsolenanwendungen benötigt wird, dh sie enthalten keine ganz neue Laufzeit, sondern ergänzen einfach das vorhandene mit den erforderlichen Bibliotheken. Diese Vererbung scheint auch in den Shared Framework-Verzeichnissen vorhanden zu sein, </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in denen das Basis-Shared Framework angegeben ist.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abhängigkeitsmanifest ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardprüfung - .NET Core Die</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
zweite Konfigurationsdatei ist diese </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Datei enthält eine Beschreibung aller Abhängigkeiten der Anwendung oder des Shared Framework oder der Bibliothek, die die Bibliotheken </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch haben. Es enthält alle Abhängigkeiten, einschließlich der transitiven. Das Verhalten der .NET Core-Laufzeit hängt davon ab, ob </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anwendung über diese verfügt oder nicht. Wenn </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht, kann die Anwendung alle Assemblys laden, die sich in ihrem Shared Framework oder in ihrem BIN-Verzeichnis befinden. Wenn dies der Fall </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist, ist die Validierung aktiviert. Wenn eine der in aufgelisteten Assemblys </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht vorhanden ist, wird die Anwendung einfach nicht gestartet. Sie sehen den oben dargestellten Fehler. Wenn die Anwendung versucht, eine Assembly zur Laufzeit zu laden, welche</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie beispielsweise Assembly-Lademethoden verwenden oder während des Auflösungsprozesses von Assemblys, wird ein Fehler angezeigt, der dem Laden strenger Assemblys sehr ähnlich ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrains Fahrer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider ist eine .NET IDE. Nicht jeder weiß, dass Rider eine IDE ist, die aus einem Frontend, das auf IntelliJ IDEA basiert und in Java und Kotlin geschrieben ist, und einem Backend besteht. Das Backend ist im Wesentlichen R #, das mit IntelliJ IDEA kommunizieren kann. Dieses Backend ist jetzt eine plattformübergreifende .NET-Anwendung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wo läuft es? Windows verwendet das .NET Framework, das auf dem Computer des Benutzers installiert ist. Auf anderen Informationssystemen unter Linux und Mac wird Mono verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist keine ideale Lösung, wenn es überall unterschiedliche Laufzeiten gibt, und ich möchte zum nächsten Status übergehen, damit Rider auf .NET Core ausgeführt wird. Um die Leistung zu verbessern, sind in .NET Core alle neuesten Funktionen damit verbunden. Speicherverbrauch reduzieren. Jetzt gibt es ein Problem damit, wie Mono mit dem Speicher arbeitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zu .NET Core wechseln, können Sie ältere, nicht unterstützte Technologien aufgeben und einige Korrekturen für die zur Laufzeit festgestellten Probleme beheben. </font><font style="vertical-align: inherit;">Wenn Sie zu .NET Core wechseln, können Sie die Version der Laufzeit steuern. Das heißt, Rider wird nicht mehr auf dem auf dem Computer des Benutzers installierten .NET Framework ausgeführt, sondern auf einer bestimmten Version von .NET Core, die als eigenständige Bereitstellung gesperrt werden kann. </font><font style="vertical-align: inherit;">Der Übergang zu .NET Core ermöglicht schließlich die Verwendung neuer APIs, die speziell in Core importiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Ziel, einen Prototyp zu starten, ihn zu starten, nur um zu überprüfen, wie er funktioniert, was die potenziellen Fehlerquellen sind, welche Komponenten erneut neu geschrieben werden müssen und welche globale Verarbeitung erforderlich ist.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen, die die Übersetzung von Rider in .NET Core erschweren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stürzt bei großen Lösungen, in denen sich Projekte mit SDK-Stil * .csproj befinden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aus dem Arbeitsspeicher ab</font></a><font style="vertical-align: inherit;"> , auch wenn R # nicht darin installiert ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">SD. -Stil * .csproj ist eine der Hauptbedingungen für eine vollständige .NET Core-Verlagerung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Problem, da Rider auf R # basiert und sich im selben Repository befindet. R # -Entwickler möchten mit Visual Studio ihr eigenes Produkt in ihrem Produkt entwickeln, um daraus Lebensmittel zu machen. </font><font style="vertical-align: inherit;">In R # gibt es Links zu bestimmten Bibliotheken für das Framework, mit denen Sie etwas tun müssen. </font><font style="vertical-align: inherit;">Unter Windows können wir das Framework für Desktop-Anwendungen verwenden, und unter Linux und Mac wird Mock bereits für Windows-Bibliotheken mit minimaler Funktionalität verwendet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns entschlossen, vorerst auf den alten zu bleiben </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und unter dem vollständigen Framework zusammenzustellen. Da die Assemblys von Framework und Core jedoch binär kompatibel sind, führen Sie sie auf Core aus. </font><font style="vertical-align: inherit;">Wir verwenden keine inkompatiblen Funktionen, fügen alle erforderlichen Konfigurationsdateien manuell hinzu und laden ggf. spezielle Versionen von Abhängigkeiten für .NET Core herunter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu welchen Hacks mussten Sie gehen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Hack: Wir möchten eine Methode aufrufen, die nur im Framework verfügbar ist. Diese Methode wird beispielsweise in R # benötigt, nicht jedoch in Core. </font><font style="vertical-align: inherit;">Das Problem ist, dass, wenn es keine Methode gibt, die Methode, die sie während der JIT-Kompilierung aufruft, früher fällt </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das heißt, eine Methode, die nicht existiert, hat die Methode, die sie aufruft, ruiniert.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { <font></font>
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] <font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung ist hier: Wir rufen inkompatible Methoden in separate Methoden auf. Es gibt noch ein weiteres Problem: Eine solche Methode kann inline werden, daher markieren wir sie mit einem Attribut </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack Nummer zwei: Wir müssen in der Lage sein, Assemblys in relativen Pfaden zu laden. Wir haben eine Assembly für das Framework, es gibt eine spezielle Version für .NET Core. Wie laden wir die .NET Core-Version für .NET Core herunter? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden uns helfen </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schauen wir uns </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die System.Diagnostics.PerformanceCounter-Bibliothek an. Eine solche Bibliothek ist bemerkenswert in Bezug auf ihre</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es hat einen Laufzeitabschnitt, in dem eine Version der Bibliothek mit ihrem relativen Pfad angegeben ist. In dieser Bibliothek wird die Assembly zu allen Laufzeiten geladen und nur die Ausführungen ausgelöst. Wenn es beispielsweise unter Linux geladen wird, funktioniert der PerformanceCounter unter Linux nicht mit Design, und von dort aus fliegt eine PlatformNotSupportedException. In diesem </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt </font><font style="vertical-align: inherit;">befindet sich auch </font><font style="vertical-align: inherit;">ein Abschnitt zu runtimeTargets. Hier ist bereits die Version dieser Assembly speziell für Windows angegeben, in der PerformanceCounter funktionieren soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Laufzeitabschnitt nehmen und darin den relativen Pfad zu der Bibliothek schreiben, die wir laden möchten, hilft uns dies nicht weiter. Der Laufzeitabschnitt legt tatsächlich den relativen Pfad innerhalb des NuGet-Pakets fest und nicht relativ zur BIN. Wenn wir diese Assembly in BIN suchen, wird nur der Dateiname von dort verwendet. Der Abschnitt runtimeTargets enthält bereits einen ehrlichen relativen Pfad, einen ehrlichen Pfad relativ zu BIN. Wir werden einen relativen Pfad für unsere Assemblys im Abschnitt runtimeTargets vorgeben. Anstelle der Laufzeitkennung, die hier "win" ist, können wir eine andere nehmen, die uns gefällt. Zum Beispiel schreiben wir die Laufzeitkennung "any" und diese Assembly wird im Allgemeinen auf allen Plattformen geladen. Oder wir schreiben "Unix" und es bootet unter Linux, Mac und so weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nächster Hack: Wir möchten unter Linux und Mac Mock herunterladen, um WindowsBase zu erstellen. Das Problem ist, dass die Assembly mit dem Namen WindowsBase bereits im Shared Framework vorhanden ist </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auch wenn wir nicht unter Windows arbeiten. In Windows Shared Framework </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert WindowsBase die Version neu, in der es sich befindet </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schauen wir uns </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Framework genauer an, genauer gesagt die Abschnitte, die WindowsBase beschreiben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Unterschied: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn einige Bibliothekskonflikte auftreten und in mehreren vorhanden sind </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird das Maximum für das Paar ausgewählt, das aus </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und besteht </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das .NET-Handbuch besagt, dass </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nur benötigt wird, um es im Windows Explorer anzuzeigen, aber nicht, es fällt in</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist der einzige Fall , </font><font style="vertical-align: inherit;">dass ich weiß, wann die Version vorgeschriebenen </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tatsächlich verwendet werden. In allen anderen Fällen stellte ich ein Verhalten fest </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bei dem die Assembly trotzdem geladen wird </font><font style="vertical-align: inherit;">, unabhängig davon, in welchen Versionen </font><font style="vertical-align: inherit;">sie geschrieben wurden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vierter Hack. Aufgabe: Wir haben eine .deps.json-Datei für die beiden vorherigen Hacks und benötigen sie nur für bestimmte Abhängigkeiten. Da sie </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im halbmanuellen Modus generiert werden, haben wir ein Skript, das sie gemäß einer Beschreibung dessen, was dort ankommen soll, während des Builds generiert. Wir möchten dies so </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gering wie möglich halten, damit wir verstehen können, was darin enthalten ist. Wir möchten die Validierung deaktivieren und den Download von Assemblys zulassen, die sich in der BIN befinden, aber nicht in beschrieben sind </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lösung: Aktivieren Sie die benutzerdefinierte Konfiguration in runtimeconfig. </font><font style="vertical-align: inherit;">Diese Einstellung wird tatsächlich für die Abwärtskompatibilität mit .NET Core 1.0 benötigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf .NET Core - das sind Analoga </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie können die gleichen Aktionen ausführen, z. B. Baugruppen auf relative Weise laden. </font><font style="vertical-align: inherit;">Wenn Sie </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es manuell umschreiben, können Sie das Laden von Assemblys in .NET Core anpassen, wenn Sie ein sehr komplexes Szenario haben.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug-Assembly-Downloads</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe über einige Arten von Problemen gesprochen, daher müssen Sie in der Lage sein, Probleme beim Laden von Assemblys zu debuggen. </font><font style="vertical-align: inherit;">Was kann dabei helfen? </font><font style="vertical-align: inherit;">Zunächst schreiben Laufzeiten Protokolle darüber, wie sie Assemblys laden. </font><font style="vertical-align: inherit;">Zweitens können Sie sich die Ausführungen, die zu Ihnen fliegen, genauer ansehen. </font><font style="vertical-align: inherit;">Sie können sich auch auf Laufzeitereignisse konzentrieren.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionsprotokolle</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zurück zu den Grundlagen: Verwenden des Fusion Log Viewer zum Debuggen obskurer Fehler </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Mechanismus zum Laden von Assemblys in .NET Framework heißt Fusion und kann protokollieren, was auf der Festplatte geschehen ist. Um die Protokollierung zu aktivieren, müssen Sie der Registrierung spezielle Einstellungen hinzufügen. Dies ist nicht sehr praktisch, daher ist es sinnvoll, Dienstprogramme zu verwenden, nämlich Fusion Log Viewer und Fusion ++. Fusion Log Viewer ist ein Standarddienstprogramm, das mit Visual Studio geliefert wird und über die Visual Studio-Befehlszeile Visual Studio Developer Command Prompt gestartet werden kann. Fusion ++ ist ein Open-Source-Analogon dieses Tools mit einer schöneren Oberfläche.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fusion Log Viewer sieht so aus. Dies ist schlimmer als WinDbg, da sich dieses Fenster nicht einmal ausdehnt. Trotzdem können Sie hier die Häkchen durchstechen, obwohl nicht immer klar ist, welche Häkchen korrekt sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ verfügt über eine Schaltfläche "Protokollierung starten". Anschließend wird die Schaltfläche "Protokollierung beenden" angezeigt. Darin können Sie alle Datensätze zum Laden von Assemblys anzeigen und die Protokolle darüber lesen, was genau passiert ist. Diese Protokolle sehen auf prägnante Weise ungefähr so ​​aus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine Ausnahme vom strengen Laden von Baugruppen. </font><font style="vertical-align: inherit;">Wenn wir uns die Fusion-Protokolle ansehen, werden wir feststellen, dass wir Version 9.0.0.0 herunterladen mussten, nachdem wir alle Konfigurationen verarbeitet haben. </font><font style="vertical-align: inherit;">Wir haben eine Datei gefunden, in der vermutet wird, dass wir die Baugruppe haben, die wir benötigen. </font><font style="vertical-align: inherit;">Wir haben gesehen, dass sich Version 6.0.0.0 in dieser Datei befindet. </font><font style="vertical-align: inherit;">Wir haben eine Warnung, dass wir die vollständigen Namen der Baugruppen verglichen haben und sie sich in der Hauptversion unterscheiden. </font><font style="vertical-align: inherit;">Und dann ist ein Fehler aufgetreten - Versionsinkongruenz.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laufzeitereignisse</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokollieren von Laufzeitereignissen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Mono können Sie die Protokollierung mithilfe von Umgebungsvariablen aktivieren. Die Protokolle werden schließlich in </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und geschrieben </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nicht so bequem, aber die Lösung funktioniert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardprüfung - .NET Core- </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation / Entwurfsdokumente / Host-Ablaufverfolgung</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. .NET Core verfügt außerdem über eine spezielle Umgebungsvariable, </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die die Anmeldung umfasst </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit .NET Core 3.0 können Sie Protokolle in eine Datei schreiben, indem Sie den Pfad dazu in einer Variablen angeben </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Ereignis, das ausgelöst wird, wenn die Assemblys nicht geladen werden können. Dies ist eine Veranstaltung </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es gibt ein zweites nützliches Ereignis, dieses </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie können es abonnieren und eine Fehlermeldung beim Laden von Assemblys erhalten, selbst wenn jemand try..catch geschrieben und alle Ausführungen an der Stelle verpasst hat, an der</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgetreten. </font><font style="vertical-align: inherit;">Wenn die Anwendung bereits kompiliert wurde, können Sie sie starten </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und .NET-Ausführungen überwachen. Dort finden Sie diejenigen, die sich auf Download-Dateien beziehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übertragen Sie die Arbeit auf Tools, Entwicklungstools, IDE und MSBuild, mit denen Sie Weiterleitungen generieren können. </font><font style="vertical-align: inherit;">Sie können zu .NET Core wechseln, dann werden Sie vergessen, was Strict Assembly Loading ist, und Sie können die neue API genau so verwenden, wie wir es in Rider erreichen möchten. </font><font style="vertical-align: inherit;">Wenn Sie die .NET Standard-Bibliothek verbinden, erhöhen Sie die Zielversion von .NET Framework auf mindestens 4.7.1. </font><font style="vertical-align: inherit;">Wenn Sie sich in einer hoffnungslosen Situation befinden, suchen Sie nach Hacks, verwenden Sie sie oder entwickeln Sie Ihre eigenen Hacks für hoffnungslose Situationen. </font><font style="vertical-align: inherit;">Und rüsten Sie sich mit Debugging-Tools aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich empfehle Ihnen dringend, die folgenden Links zu lesen:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499824/index.html">Die Zusammenfassung der Ereignisse für Personal- und IT-Personalvermittler im Mai 2020</a></li>
<li><a href="../de499826/index.html">Verteilter Blutdruck</a></li>
<li><a href="../de499832/index.html">Wie kann die Remote-Arbeit von Mitarbeitern schnell und sicher organisiert werden? Wir sprechen über verschiedene Ansätze: mit VDI und nicht nur</a></li>
<li><a href="../de499834/index.html">Lernen Sie das Felix Arithmometer kennen</a></li>
<li><a href="../de499836/index.html">Udalenka vs. Büro für das Entwicklungsteam</a></li>
<li><a href="../de499842/index.html">Warum lernen die Leute neu?</a></li>
<li><a href="../de499846/index.html">Wann die separate Speicherbereinigung funktioniert und warum eine Videoüberwachung von Standorten für Speichercontainer erforderlich ist</a></li>
<li><a href="../de499850/index.html">So analysieren Sie Wettbewerber und erstellen in 40 Minuten eine digitale Strategie</a></li>
<li><a href="../de499852/index.html">Englischsprachige Dokumentation für Angular</a></li>
<li><a href="../de499854/index.html">Apache Bigtop und die Wahl der Hadoop-Distribution heute</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>