<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöó üí™üèø ‚ö∞Ô∏è .NET: Abh√§ngigkeitsbehandlung üîÜ üñïüèΩ ü§òüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Wer hat aufgrund der Baugruppenumleitung keine Probleme festgestellt? H√∂chstwahrscheinlich wird jeder, der eine relativ gro√üe Anwendung entwickelt hat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>.NET: Abh√§ngigkeitsbehandlung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/499838/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer hat aufgrund der Baugruppenumleitung keine Probleme festgestellt? </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich wird jeder, der eine relativ gro√üe Anwendung entwickelt hat, fr√ºher oder sp√§ter mit diesem Problem konfrontiert sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt arbeite ich bei JetBrains im JetBrains Rider-Projekt und bin an der Migration von Rider zu .NET Core beteiligt. </font><font style="vertical-align: inherit;">Zuvor war er in Circuit, einer Cloud-basierten Anwendungshosting-Plattform, mit der gemeinsamen Infrastruktur besch√§ftigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/je/f5/e-/jef5e-nc0okqm_ssla0qhniugio.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter der Zwischensequenz befindet sich das Protokoll meines Berichts von der Moskauer DotNext 2019-Konferenz, auf der ich √ºber die Schwierigkeiten bei der Arbeit mit Baugruppen in .NET sprach und anhand praktischer Beispiele zeigte, was passiert und wie damit umzugehen ist.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/fMlTLw1agE0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In allen Projekten, in denen ich als .NET-Entwickler gearbeitet habe, musste ich mich mit verschiedenen Problemen beim Verbinden von Abh√§ngigkeiten und Laden von Assemblys befassen. </font><font style="vertical-align: inherit;">Wir werden dar√ºber reden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poststruktur:</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abh√§ngigkeitsprobleme</font></font></b></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Rig-Beladung</font></font></b></a><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindungsumleitungen</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Benennung</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></a></b> <br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gemeinsame Frameworks, .runtimeconfig.json</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abh√§ngigkeitsmanifest (.deps.json)</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacks, um JetBrains Rider auf Core auszuf√ºhren</font></font></a></li>
</ul><br>
</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug-Assembly-Downloads</font></font></a> </b><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionsprotokolle</font></font></a> </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laufzeitereignisse</font></font></a></li>
</ul><br>
</li>
</ol><br>
<a name="problems"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind einige Abh√§ngigkeitsprobleme?</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als sie Anfang der 2000er Jahre mit der Entwicklung von .NET Framework begannen, war das Problem der Abh√§ngigkeitsh√∂lle bereits bekannt, als Entwickler in allen Bibliotheken wichtige √Ñnderungen zulassen und diese Bibliotheken f√ºr die Verwendung mit bereits kompiliertem Code nicht mehr kompatibel sind. </font><font style="vertical-align: inherit;">Wie kann man ein solches Problem l√∂sen? </font><font style="vertical-align: inherit;">Die erste L√∂sung liegt auf der Hand. </font><font style="vertical-align: inherit;">Behalten Sie immer die Abw√§rtskompatibilit√§t bei. </font><font style="vertical-align: inherit;">Dies ist nat√ºrlich nicht sehr realistisch, da das Brechen von √Ñnderungen sehr einfach in Code zu integrieren ist. </font><font style="vertical-align: inherit;">Zum Beispiel: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/un/gj/tv/ungjtvaiofi7qkm6a4if5cpgh10.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderungen und .NET-Bibliotheken aufl√∂sen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein spezielles Beispiel f√ºr .NET. Wir haben eine Methode und haben beschlossen, einen Parameter mit einem Standardwert hinzuzuf√ºgen. Der Code wird weiterhin kompiliert, wenn wir ihn wieder zusammensetzen, aber bin√§r sind es zwei v√∂llig unterschiedliche Methoden: Eine Methode hat keine Argumente, die zweite Methode hat ein Argument. Wenn der Entwickler innerhalb der Abh√§ngigkeit die Abw√§rtskompatibilit√§t auf diese Weise unterbrochen hat, k√∂nnen wir den Code, der mit dieser Abh√§ngigkeit von der vorherigen Version kompiliert wurde, nicht verwenden.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite L√∂sung f√ºr Abh√§ngigkeitsprobleme besteht darin, die Versionierung von Bibliotheken und Assemblys hinzuzuf√ºgen - alles. M√∂glicherweise gibt es unterschiedliche Versionsregeln. Der Punkt ist, dass wir verschiedene Versionen derselben Bibliothek irgendwie voneinander unterscheiden k√∂nnen und Sie verstehen k√∂nnen, ob das Update nicht funktioniert oder nicht. Sobald wir die Versionen einf√ºhren, tritt leider ein anderes Problem auf. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vg/xc/wu/vgxcwufmesq4jly-ecfrh5p-ko8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Version H√∂lle ist die Unf√§higkeit, eine Abh√§ngigkeit zu verwenden, die bin√§r kompatibel ist, aber gleichzeitig eine Version hat, die nicht zur Laufzeit passt, oder eine andere Komponente, die diese Versionen √ºberpr√ºft. In .NET ist FileLoadException eine typische Manifestation der Version Hell, obwohl die Datei auf der Festplatte liegt, aber aus irgendeinem Grund nicht mit Laufzeit geladen wird.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qy/wg/5m/qywg5mjhpkuogm6yez7uhnxitji.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET haben Assemblys viele verschiedene Versionen - sie haben versucht, Versions-Hells auf verschiedene Weise zu reparieren und zu sehen, was passiert ist. Wir haben ein Paket </font></font><code>System.Collections.Immutable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Viele Leute kennen ihn. Er hat die neueste Version des NuGet-Pakets 1.6.0. Es enth√§lt eine Bibliothek, eine Assembly mit Version 1.2.4.0. Sie haben erhalten, dass Sie keine Build-Bibliothek Version 1.2.4.0 haben. Wie kann man verstehen, dass es im NuGet-Paket 1.6.0 liegt? Es wird nicht einfach. Zus√§tzlich zur Assembly-Version verf√ºgt diese Bibliothek √ºber mehrere weitere Versionen. Zum Beispiel Assembly Assembly Version, Assembly Information Version. Dieses NuGet-Paket enth√§lt tats√§chlich drei verschiedene Assemblys mit denselben Versionen (f√ºr verschiedene Versionen des .NET-Standards). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET-Dokumentation </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Opbuild-Standard</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wurde viel Dokumentation zum Arbeiten mit Assemblys in .NET geschrieben. </font><font style="vertical-align: inherit;">Es gibt einen .NET-Leitfaden f√ºr die Entwicklung moderner .NET-Anwendungen, der .NET Framework, .NET Standard, .NET Core, Open Source und alles M√∂gliche ber√ºcksichtigt. </font><font style="vertical-align: inherit;">Etwa 30% des gesamten Dokuments sind dem Laden von Baugruppen gewidmet. </font><font style="vertical-align: inherit;">Wir werden spezifische Probleme und Beispiele analysieren, die auftreten k√∂nnen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum ist das alles notwendig? </font><font style="vertical-align: inherit;">Erstens, um nicht auf einen Rechen zu treten. </font><font style="vertical-align: inherit;">Zweitens k√∂nnen Sie den Benutzern Ihrer Bibliotheken das Leben erleichtern, da sie mit Ihrer Bibliothek nicht die Abh√§ngigkeitsprobleme haben, an die sie gew√∂hnt sind. </font><font style="vertical-align: inherit;">Es hilft Ihnen auch bei der Migration komplexer Anwendungen zu .NET Core. </font><font style="vertical-align: inherit;">Und um das Ganze abzurunden, k√∂nnen Sie ein SRE werden. Dies ist ein Senior (Binding) Redirect-Ingenieur, zu dem jeder im Team kommt und fragt, wie er eine weitere Weiterleitung schreiben soll.</font></font><a name="assembly"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Strikte Montage Laden</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das strikte Laden von Assemblys ist das Hauptproblem, mit dem Entwickler in .NET Framework konfrontiert sind. </font><font style="vertical-align: inherit;">Es wird ausgedr√ºckt in </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bevor ich mit dem Laden der strengen Baugruppe fortfahre, m√∂chte ich Sie an einige grundlegende Dinge erinnern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine .NET-Anwendung erstellen, erhalten Sie ein Artefakt, das sich normalerweise in Bin / Debug oder Bin / Release befindet und einen bestimmten Satz von Assembly-Assemblys und Konfigurationsdateien enth√§lt. </font><font style="vertical-align: inherit;">Baugruppen beziehen sich auf Namen und Namen der Baugruppe. </font><font style="vertical-align: inherit;">Es ist wichtig zu verstehen, dass sich Assembly-Links direkt in der Assembly befinden, die auf diese Assembly verweist. Es gibt keine magischen Konfigurationsdateien, in die Assembly-Referenzen geschrieben werden. </font><font style="vertical-align: inherit;">Auch wenn es Ihnen so scheint, als ob solche Dateien existieren. </font><font style="vertical-align: inherit;">Referenzen befinden sich in den Baugruppen selbst in bin√§rer Form.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET gibt es einen Prozess zum Aufl√∂sen von Assemblys. In diesem Fall wird die Assemblydefinition bereits in eine echte Assembly konvertiert, die sich auf der Festplatte befindet oder irgendwo im Speicher geladen ist. Das Aufl√∂sen von Assemblys wird zweimal durchgef√ºhrt: In der Build-Phase, wenn Sie Referenzen in * .csproj haben, und zur Laufzeit, wenn Sie Referenzen in den Assemblys haben, und nach einigen Regeln werden sie zu Assemblys, die heruntergeladen werden k√∂nnen. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">// Einfacher Name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyAssembly, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kultur = neutral, PublicKeyToken = null </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
// Starker Name </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Newtonsoft.Json, Version = 6.0.0.0, </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kultur = neutral, PublicKeyToken = 30ad4fe6b2a6aeed // PublicKey</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir zum Problem. Baugruppenname Es gibt zwei Haupttypen. Die erste Art von Baugruppenname ist Einfacher Name. Sie sind leicht daran zu erkennen, dass sie PublicKeyToken = null haben. Es gibt einen starken Namen, es ist leicht, sie daran zu erkennen, dass ihr PublicKeyToken nicht null ist, sondern einen gewissen Wert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/0v/uf/400vuf0e3w-ykw2fkdx2-ufdutq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir ein Beispiel. Wir haben ein Programm, das von der Bibliothek mit MyUtils-Dienstprogrammen abh√§ngt, und die Version von MyUtils ist 9.0.0.0. Das gleiche Programm hat einen Link zu einer anderen Bibliothek. Diese Bibliothek m√∂chte auch MyUtils verwenden, jedoch Version 6.0.0.0. MyUtils Version 9.0.0.0 und Version 6.0.0.0 haben PublicKeyToken = null, dh sie haben einen einfachen Namen. Welche Version f√§llt in das bin√§re Artefakt 6.0.0.0 oder 9.0.0.0? 9. Version. Kann MyLibrary MyUtils Version 9.0.0.0 verwenden, die in das bin√§re Artefakt gelangt ist?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/fs/2x/jsfs2xd1erckl8dkphbrhojfhxk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich kann dies der Fall sein, da MyUtils einen einfachen Namen hat und dementsprechend das Laden der strengen Assembly nicht vorhanden ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kz/tn/a6/kztna61effl0kkiuwnkvi1gpad8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderes Beispiel. </font><font style="vertical-align: inherit;">Anstelle von MyUtils haben wir eine vollst√§ndige Bibliothek von NuGet, die einen starken Namen hat. </font><font style="vertical-align: inherit;">Die meisten Bibliotheken in NuGet haben einen starken Namen.</font></font><br>
<br>
<a name="redirects"></a><img src="https://habrastorage.org/webt/rr/xp/qi/rrxpqilvehdbvemijol2iuutbie.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Build-Phase wird Version 9.0.0.0 in BIN kopiert, aber zur Laufzeit erhalten wir die ber√ºhmte </font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Damit MyLibrary, die Version 6.0.0.0 </font></font><code>Newtonsoft.Json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwenden soll, Version 9.0.0.0 verwenden kann, m√ºssen Sie die Bindungsumleitung an schreiben </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bindungsumleitungen</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/lw/d_/yq/lwd_yq2otb7kqsbpkpglszjlr-y.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Umleiten von </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Assemblyversionen</font></a><font style="vertical-align: inherit;"> Es wird angegeben, dass eine Assembly mit einem solchen Namen und einem solchen publicKeyToken von einem solchen Versionsbereich zu einem solchen Versionsbereich umgeleitet werden muss. </font><font style="vertical-align: inherit;">Es scheint eine sehr einfache Aufzeichnung zu sein, aber sie befindet sich hier </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnte sich aber in anderen Dateien befinden. </font><font style="vertical-align: inherit;">In </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Framework befindet sich zur Laufzeit </font><font style="vertical-align: inherit;">eine Datei </font><font style="vertical-align: inherit;">, in der einige Standardumleitungen definiert sind, die von Version zu Version von .NET Framework unterschiedlich sein k√∂nnen. </font><font style="vertical-align: inherit;">Es kann vorkommen, dass in 4.7.1 nichts f√ºr Sie funktioniert, in 4.7.2 jedoch bereits oder umgekehrt. </font><font style="vertical-align: inherit;">Sie m√ºssen ber√ºcksichtigen, dass Weiterleitungen nicht nur von Ihnen stammen </font></font><code>.App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k√∂nnen. Dies sollte beim Debuggen ber√ºcksichtigt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir vereinfachen das Schreiben von Weiterleitungen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Niemand m√∂chte verbindliche Weiterleitungen mit den H√§nden schreiben. Geben wir diese Aufgabe an MSBuild! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pg/qk/ct/pgqkctk1hwcp0lewpamhi5wn35o.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktivieren und Deaktivieren der automatischen Bindungsumleitung</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Einige Tipps zur Vereinfachung der Arbeit mit der Bindungsumleitung. Tipp 1: Aktivieren Sie die automatische Generierung der Bindungsumleitung in MSBuild. Von Eigentum in eingeschaltet </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Beim Erstellen eines Projekts f√§llt es in ein bin√§res Artefakt </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, das Weiterleitungen zu Versionen von Bibliotheken anzeigt, die sich im selben Artefakt befinden. Dies funktioniert nur zum Ausf√ºhren von Anwendungen, Konsolenanwendungen und WinExe. F√ºr Bibliotheken funktioniert dies nicht, da f√ºr Bibliotheken</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meistens ist es einfach nicht relevant, da es f√ºr eine Anwendung relevant ist, die Assemblys selbst startet und l√§dt. Wenn Sie eine Konfiguration f√ºr die Bibliothek vorgenommen haben, k√∂nnen sich in der Anwendung auch einige Abh√§ngigkeiten von denen unterscheiden, die beim Erstellen der Bibliothek vorhanden waren, und es stellt sich heraus, dass die Konfiguration f√ºr die Bibliothek nicht sehr sinnvoll ist. Trotzdem sind manchmal f√ºr Bibliotheken Konfigurationen immer noch sinnvoll. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ik/g6/6n/ikg66nyqel3ejmqbln9xb1magyq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Situation, wenn wir Tests schreiben. Tests werden normalerweise in ClassLibrary gefunden und ben√∂tigen auch Weiterleitungen. Test-Frameworks k√∂nnen erkennen, dass die Bibliothek mit Tests eine DLL-Konfiguration hat, und die darin enthaltenen Weiterleitungen gegen den Code aus den Tests austauschen. Sie k√∂nnen diese Weiterleitungen automatisch generieren. Wenn wir ein altes Format haben</font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im SDK-Stil k√∂nnen Sie auf einfache Weise den OutputType in Exe √§ndern und einen leeren Einstiegspunkt hinzuf√ºgen. Dadurch wird MSBuild gezwungen, Weiterleitungen zu generieren. Sie k√∂nnen den anderen Weg gehen und den Hack verwenden. Sie k√∂nnen eine weitere Eigenschaft hinzuf√ºgen </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sodass MSBuild ber√ºcksichtigt, dass f√ºr diesen OutputType noch Bindungsumleitungen generiert werden m√ºssen. Obwohl diese Methode wie ein Hack aussieht, k√∂nnen Sie Weiterleitungen f√ºr Bibliotheken generieren, die in Exe nicht wiederholt werden k√∂nnen, sowie f√ºr andere Arten von Projekten (au√üer Tests). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr das neue Format werden </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Weiterleitungen selbst generiert, wenn Sie modernes Microsoft.NET.Test.Sdk verwenden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dritter Tipp: Verwenden Sie die Bindungsumleitungsgenerierung nicht mit NuGet. NuGet bietet die M√∂glichkeit, eine Bindungsumleitung f√ºr Bibliotheken zu generieren, die von Paketen auf die neuesten Versionen √ºbertragen werden. Dies ist jedoch nicht die beste Option. Alle diese Weiterleitungen m√ºssen hinzugef√ºgt </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und festgeschrieben werden. Wenn Sie mit MSBuild Weiterleitungen generieren, werden w√§hrend der Erstellung Weiterleitungen generiert. Wenn Sie sie festschreiben, k√∂nnen Zusammenf√ºhrungskonflikte auftreten. Sie k√∂nnen einfach vergessen, die Bindungsumleitung in der Datei zu aktualisieren, und wenn sie w√§hrend des Builds generiert werden, werden Sie nicht vergessen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fr/zq/yifrzq4fnvwitenrhkteup1cjfq.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baugruppenreferenz </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufl√∂sen Bindungsumleitungen generieren</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hausaufgaben f√ºr diejenigen, die besser verstehen m√∂chten, wie die Generierung von Bindungsumleitungen funktioniert: Finden Sie heraus, wie es funktioniert, lesen Sie dies im Code. Wechseln Sie in das .NET-Verzeichnis und sto√üen Sie √ºberall auf die Eigenschaft name, mit der die Generierung aktiviert wird. Dies ist im Allgemeinen ein so g√§ngiger Ansatz. Wenn es eine seltsame Eigenschaft f√ºr MSBuild gibt, k√∂nnen Sie die Verwendung nutzen. Gl√ºcklicherweise wird Eigenschaft normalerweise in XML-Konfigurationen verwendet, und Sie k√∂nnen ihre Verwendung leicht finden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie untersuchen, was in diesen XML-Zielen enthalten ist, werden Sie feststellen, dass diese Eigenschaft zwei MSBuild-Aufgaben ausl√∂st. Die erste Aufgabe wird aufgerufen </font></font><code>ResolveAssemblyReferences</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und generiert eine Reihe von Weiterleitungen, die in Dateien geschrieben werden. Die zweite Aufgabe </font></font><code>GenerateBindingRedirects</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schreibt die Ergebnisse der ersten Aufgabe in</font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es gibt eine XML-Logik, die den Vorgang der ersten Aufgabe leicht korrigiert und unn√∂tige Weiterleitungen entfernt oder neue hinzuf√ºgt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternative zu XML-Konfigurationen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht immer bequem, Weiterleitungen in der XML-Konfiguration beizubehalten. </font><font style="vertical-align: inherit;">Es kann vorkommen, dass die Anwendung das Plugin herunterl√§dt und dieses Plugin andere Bibliotheken verwendet, f√ºr die Weiterleitungen erforderlich sind. </font><font style="vertical-align: inherit;">In diesem Fall sind uns m√∂glicherweise die ben√∂tigten Weiterleitungen nicht bekannt, oder wir m√∂chten m√∂glicherweise kein XML generieren. </font><font style="vertical-align: inherit;">In einer solchen Situation k√∂nnen wir eine AppDomain erstellen und beim Erstellen immer noch dorthin √ºbertragen, wo sich das XML mit den erforderlichen Weiterleitungen befindet. </font><font style="vertical-align: inherit;">Wir k√∂nnen Fehler beim Laden von Baugruppen auch direkt zur Laufzeit behandeln. </font><font style="vertical-align: inherit;">Rantime .NET bietet eine solche M√∂glichkeit.</font></font><br>
<br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (sender, eventArgs) =&gt; <font></font>
{ <font></font>
   <span class="hljs-keyword">var</span> name = eventArgs.Name; <font></font>
   <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
   <font></font>
   <span class="hljs-keyword">return</span> Assembly.LoadFrom(...); <span class="hljs-comment">// PublicKeyToken should be equal</span><font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es hat ein Ereignis, es hei√üt </font></font><code>CurrentDomain.AssemblyResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie dieses Ereignis abonnieren, erhalten wir Fehler zu allen fehlgeschlagenen Assembly-Downloads. Wir erhalten den Namen der Baugruppe, die nicht geladen wurde, und wir erhalten die Baugruppenbaugruppe, die das Laden der ersten Baugruppe angefordert hat. Hier k√∂nnen wir die Assembly manuell von der richtigen Stelle laden, z. B. die Version l√∂schen, sie einfach aus der Datei entnehmen und dieses Ereignis vom Handler zur√ºckgeben. Oder geben Sie null zur√ºck, wenn wir nichts zur√ºckgeben m√ºssen, wenn wir die Assembly nicht laden k√∂nnen. PublicKeyToken sollte gleich sein, Assemblys mit unterschiedlichen PublicKeyToken sind in keiner Weise miteinander befreundet.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8q/m7/ge/8qm7ge64h4pbldvju9ya91uz8zm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Ereignis gilt nur f√ºr eine Anwendungsdom√§ne. </font><font style="vertical-align: inherit;">Wenn unser Plugin eine AppDomain in sich selbst erstellt, funktioniert diese Umleitung in der Laufzeit in ihnen nicht. </font><font style="vertical-align: inherit;">Sie m√ºssen dieses Ereignis in der gesamten AppDomain abonnieren, die das Plugin erstellt hat. </font><font style="vertical-align: inherit;">Wir k√∂nnen dies mit dem AppDomainManager tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AppDomainManager ist eine separate Assembly, die eine Klasse enth√§lt, die eine bestimmte Schnittstelle implementiert. Mit einer der Methoden dieser Schnittstelle k√∂nnen Sie jede neue AppDomain initialisieren, die in der Anwendung erstellt wird. </font><font style="vertical-align: inherit;">Sobald die AppDomain erstellt wurde, wird diese Methode aufgerufen. </font><font style="vertical-align: inherit;">Darin k√∂nnen Sie dieses Ereignis abonnieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Striktes Laden von Assemblys und .NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In .NET Core gibt es kein Problem namens "Striktes Laden von Assemblys". Dies liegt daran, dass f√ºr signierte Assemblys genau die angeforderte Version erforderlich ist. Es gibt noch eine andere Anforderung. Unabh√§ngig davon, ob sie mit einem starken Namen signiert sind oder nicht, wird f√ºr alle Assemblys √ºberpr√ºft, ob die zur Laufzeit geladene Version gr√∂√üer oder gleich der vorherigen ist. Wenn wir uns in einer Situation mit einer Anwendung mit Plugins befinden, kann es vorkommen, dass das Plugin beispielsweise aus einer neuen Version des SDK erstellt wurde und die Anwendung, in die es heruntergeladen wird, die bisherige alte Version des SDK verwendet und nicht auseinanderf√§llt. Wir k√∂nnen dieses Ereignis auch abonnieren, jedoch bereits in .NET Core, und die vorhandene Assembly laden. Wir k√∂nnen diesen Code schreiben:</font></font><br>
<pre><code class="cs hljs">AppDomain.CurrentDomain.AssemblyResolve += (s, eventArgs) =&gt; <font></font>
{ <font></font>
     CheckForRecursion(); <font></font>
     <span class="hljs-keyword">var</span> name = eventArgs.Name;<font></font>
     <span class="hljs-keyword">var</span> requestingAssembly = eventArgs.RequestingAssembly; <font></font>
    <font></font>
     name.Version = <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <font></font>
     <font></font>
     <span class="hljs-keyword">return</span> Assembly.Load(name); <font></font>
};<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben den Namen der Assembly, die nicht gestartet wurde. Wir machen die Version ung√ºltig und rufen sie </font></font><code>Assembly.Load</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von derselben Version aus auf. Hier findet keine Rekursion statt, da ich die Rekursion bereits √ºberpr√ºft habe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mt/cs/kr/mtcskrokxuvcn8i4gueywowb3_m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es war notwendig, MyUtils Version 0.0.2.0 herunterzuladen. In BIN haben wir MyUtils Version 0.0.1.0. Wir haben eine Umleitung von Version 0.0.2.0 zu Version 0.0 durchgef√ºhrt. Version 0.0.1.0 wird bei uns nicht geladen. Ein Exit wird f√ºr uns herausfliegen, dass es nicht m√∂glich war, die Assembly mit Version 0.0.2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu laden </font><font style="vertical-align: inherit;">. 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16‚Äì1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) == <span class="hljs-keyword">new</span> Version(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>) <font></font>
<font></font>
<span class="hljs-keyword">class</span> <span class="hljs-title">Version</span> { <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Build; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Revision; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Major; <font></font>
     <span class="hljs-keyword">readonly</span> <span class="hljs-keyword">int</span> _Minor; <font></font>
} <font></font>
(<span class="hljs-keyword">ushort</span>) <span class="hljs-number">-1</span> == <span class="hljs-number">65535</span><font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Versionsklasse sind nicht alle Komponenten obligatorisch, und anstelle der optionalen Komponenten ‚Äì1 werden sie gespeichert. Irgendwo im Inneren tritt jedoch ein √úberlauf auf, und es werden </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die 2 </font><sup><font style="vertical-align: inherit;">16‚Äì1</font></sup><font style="vertical-align: inherit;"> erhalten </font><font style="vertical-align: inherit;">. Bei Interesse k√∂nnen Sie versuchen, genau herauszufinden, wo der √úberlauf auftritt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/m5/bl/vl/m5blvl8u1xrfdigr0ay45_ps3q8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie mit Reflection-Assemblys arbeiten und alle Typen abrufen m√∂chten, kann es sein, dass nicht alle Typen Ihre GetTypes-Methode erhalten k√∂nnen. Eine Assembly hat eine Klasse, die von einer anderen Klasse erbt, die sich in einer Assembly befindet, die nicht geladen ist.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> IEnumerable <span class="hljs-title">GetTypesSafe</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> Assembly assembly</span>)</span> <font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    { <font></font>
        <span class="hljs-keyword">return</span> assembly.GetTypes(); <font></font>
    }<font></font>
    <span class="hljs-keyword">catch</span> (ReflectionTypeLoadException e) <font></font>
   { <font></font>
        <span class="hljs-keyword">return</span> e.Types.Where(x =&gt; x != <span class="hljs-literal">null</span>); <font></font>
    } <font></font>
}<font></font>
<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall besteht das Problem darin, dass eine ReflectionTypeLoadException ausgel√∂st wird. </font><font style="vertical-align: inherit;">Im Inneren </font></font><code>ReflectionTypeLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich eine Eigenschaft, in die sich die Typen befinden, die noch geladen werden konnten. </font><font style="vertical-align: inherit;">Nicht alle g√§ngigen Bibliotheken ber√ºcksichtigen dies. </font><font style="vertical-align: inherit;">AutoMapper, mindestens eine seiner Versionen, fiel bei ReflectionTypeLoadException einfach aus, anstatt die Typen aus dem Inneren der Ausnahme auszuw√§hlen.</font></font><a name="name"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Benennung</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baugruppen mit starken Namen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lassen Sie uns dar√ºber sprechen, was das Laden strenger Baugruppen verursacht. Dies ist ein starker Name. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Starker Name ist die Signatur der Assembly durch einen privaten Schl√ºssel mit asymmetrischer Verschl√ºsselung. PublicKeyToken ist der Public-Key-Hash dieser Assembly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Strong Naming k√∂nnen Sie zwischen verschiedenen Assemblys mit demselben Namen unterscheiden. Zum Beispiel ist MyUtils kein eindeutiger Name. Es kann mehrere Assemblys mit diesem Namen geben. Wenn Sie jedoch Strong Name signieren, haben diese unterschiedliche PublicKeyToken und wir k√∂nnen sie auf diese Weise unterscheiden. F√ºr einige Assembly-Ladeszenarien ist ein starker Name erforderlich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Beispiel, um eine Assembly im globalen Assemblycache zu installieren oder mehrere Versionen von nebeneinander gleichzeitig herunterzuladen. </font><font style="vertical-align: inherit;">Am wichtigsten ist, dass stark benannte Assemblys nur auf andere stark benannte Assemblys verweisen k√∂nnen. </font><font style="vertical-align: inherit;">Da einige Benutzer ihre Builds mit einem starken Namen signieren m√∂chten, signieren die Bibliotheksentwickler auch ihre Bibliotheken, damit Benutzer sie einfacher installieren k√∂nnen und die Benutzer diese Bibliotheken nicht erneut signieren m√ºssen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starker Name: Verm√§chtnis?</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Namens- und .NET-Bibliotheken</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Microsoft sagt in MSDN ausdr√ºcklich, dass Sie aus Sicherheitsgr√ºnden keinen starken Namen verwenden sollten, sondern nur, um verschiedene Assemblys mit demselben Namen zu unterscheiden. Der Assembly-Schl√ºssel kann in keiner Weise ge√§ndert werden. Wenn Sie ihn ge√§ndert haben, werden die Weiterleitungen an alle Benutzer unterbrochen. Wenn Sie einen privaten Teil des Schl√ºssels f√ºr den Namen "Stark" f√ºr den √∂ffentlichen Zugriff verloren haben, k√∂nnen Sie diese Signatur in keiner Weise zur√ºckziehen. Das SNK-Dateiformat, in dem sich der starke Name befindet, bietet keine solche M√∂glichkeit, und andere Formate zum Speichern von Schl√ºsseln enthalten mindestens einen Link zur Sperrliste f√ºr CRL-Zertifikate, anhand derer verstanden werden kann, dass dieses Zertifikat nicht mehr g√ºltig ist. In SNK gibt es nichts Vergleichbares.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Open-Source-Handbuch enth√§lt die folgenden Empfehlungen. Erstens, zus√§tzlich zu Sicherheitszwecken andere Technologien verwenden. Zweitens wird bei einer Open-Source-Bibliothek im Allgemeinen empfohlen, den privaten Teil des Schl√ºssels in das Repository zu √ºbernehmen, damit die Benutzer Ihre Bibliothek leichter aufteilen, neu erstellen und in eine vorgefertigte Anwendung einf√ºgen k√∂nnen. Drittens √§ndern Sie niemals den starken Namen. Zu destruktiv. Trotz der Tatsache, dass es zu destruktiv ist und im Open-Source-Handbuch dar√ºber geschrieben wird, hat Microsoft manchmal Probleme mit seinen eigenen Bibliotheken.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/kg/l3/uekgl3iwrexq7ejjbabccq4y4p4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine Bibliothek namens System.Reactive. </font><font style="vertical-align: inherit;">Bisher waren dies mehrere NuGet-Pakete, eines davon ist Rx-Linq. </font><font style="vertical-align: inherit;">Dies ist nur ein Beispiel, das auch f√ºr den Rest der Pakete gilt. </font><font style="vertical-align: inherit;">In der zweiten Version wurde es mit einem Microsoft-Schl√ºssel signiert. </font><font style="vertical-align: inherit;">In der dritten Version wechselte er in das Repository des Projekts </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/dotnet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und erhielt eine .NET Foundation-Signatur. </font><font style="vertical-align: inherit;">Die Bibliothek hat tats√§chlich den Namen Strong ge√§ndert. </font><font style="vertical-align: inherit;">Das NuGet-Paket wurde umbenannt, aber die Assembly wird im Inneren genauso wie zuvor aufgerufen. </font><font style="vertical-align: inherit;">Wie leite ich von der zweiten Version zur dritten um? </font><font style="vertical-align: inherit;">Diese Weiterleitung kann nicht durchgef√ºhrt werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starke Namensvalidierung</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewusst wie: Deaktivieren Sie die Umgehungsfunktion f√ºr starke Namen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Argument, dass Strong Name bereits der Vergangenheit angeh√∂rt und rein formal bleibt, ist, dass sie nicht validiert werden. Wir haben eine signierte Assembly und m√∂chten einen Fehler darin beheben, haben jedoch keinen Zugriff auf die Quellen. Wir k√∂nnen einfach dnSpy verwenden - dies ist ein Dienstprogramm, mit dem Sie bereits kompilierte Assemblys dekompilieren und reparieren k√∂nnen. Alles wird f√ºr uns funktionieren. Da standardm√§√üig die Umgehung der √úberpr√ºfung starker Namen aktiviert ist, wird nur √ºberpr√ºft, ob das PublicKeyToken gleich ist, und die Integrit√§t der Signatur selbst wird nicht √ºberpr√ºft. M√∂glicherweise gibt es Umweltstudien, in denen die Signatur noch √ºberpr√ºft wird, und hier ist IIS ein anschauliches Beispiel. Die Signaturintegrit√§t wird in IIS √ºberpr√ºft (die Umgehung der Validierung starker Namen ist standardm√§√üig deaktiviert), und alles wird unterbrochen, wenn wir die signierte Assembly bearbeiten. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusatz:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die Signatur√ºberpr√ºfung f√ºr die Assembly mithilfe des </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√∂ffentlichen Zeichens</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deaktivieren </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">.</font></a><font style="vertical-align: inherit;"> Damit wird nur der √∂ffentliche Schl√ºssel zum Signieren verwendet, was die Sicherheit des Assemblynamens gew√§hrleistet. Die von Microsoft verwendeten √∂ffentlichen Schl√ºssel werden </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier ver√∂ffentlicht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Rider kann das √∂ffentliche Zeichen in den Projekteigenschaften aktiviert werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vl/_j/ct/vl_jctjjgui-mbcgo5uyzd26lrc.png"><br>
<br>
<img src="https://habrastorage.org/webt/ni/if/hp/niifhpriuvymkfhz78sdeaigs54.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wann m√ºssen die Versionen der Dateibaugruppe ge√§ndert werden?</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Open-Source-Handbuch bietet auch einige Versionsrichtlinien, mit denen die Anzahl der erforderlichen Bindungsumleitungen und √Ñnderungen f√ºr Benutzer im NET Framework verringert werden soll. Diese Versionsrichtlinie besagt, dass wir die Assembly-Version nicht st√§ndig √§ndern sollten. Dies kann nat√ºrlich zu Problemen bei der Installation im GAC f√ºhren, sodass das installierte native Image m√∂glicherweise nicht der Assembly entspricht und Sie die JIT-Kompilierung erneut durchf√ºhren m√ºssen. Meiner Meinung nach ist dies jedoch weniger schlimm als die Probleme bei der Versionierung. Bei CrossGen werden native Assemblys nicht global installiert - es treten keine Probleme auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das NuGet-Paket Newtonsoft.Json verf√ºgt beispielsweise √ºber mehrere Versionen: 12.0.1, 12.0.2 usw. Alle diese Pakete verf√ºgen √ºber eine Assembly mit Version 12.0.0.0. </font><font style="vertical-align: inherit;">Die Empfehlung lautet, dass die Assembly-Version aktualisiert werden sollte, wenn sich eine Hauptversion des NuGet-Pakets √§ndert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Befolgen Sie die Tipps f√ºr .NET Framework: Generieren Sie Weiterleitungen manuell und versuchen Sie, in allen Projekten Ihrer L√∂sung dieselbe Version von Abh√§ngigkeiten zu verwenden. </font><font style="vertical-align: inherit;">Dies sollte die Anzahl der Weiterleitungen erheblich minimieren. </font><font style="vertical-align: inherit;">Sie ben√∂tigen eine starke Benennung nur, wenn Sie ein bestimmtes Build-Ladeszenario haben, in dem es ben√∂tigt wird, oder wenn Sie eine Bibliothek entwickeln und das Leben f√ºr Benutzer vereinfachen m√∂chten, die eine starke Benennung wirklich ben√∂tigen. </font><font style="vertical-align: inherit;">√Ñndern Sie nicht den starken Namen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Standard</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen zu .NET Standard √ºber. Es ist ziemlich eng mit der Version Hell in .NET Framework verwandt. .NET Standard ist ein Tool zum Schreiben von Bibliotheken, die mit verschiedenen Implementierungen der .NET-Plattform kompatibel sind. Implementierungen beziehen sich auf .NET Framework, .NET Core, Mono, Unity und Xamarin. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hk/-a/-u/hk-a-u16d-oitjurhvta7lhafdi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Link zur Dokumentation</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die .NET Standard-Unterst√ºtzungstabelle f√ºr verschiedene Versionen verschiedener Versionen von Laufzeiten. Und hier k√∂nnen wir sehen, dass .NET Framework die .NET Standard Version 2.1 in keiner Weise unterst√ºtzt. Die Ver√∂ffentlichung von .NET Framework, das .NET Standard 2.1 und h√∂her unterst√ºtzt, ist noch nicht geplant. Wenn Sie eine Bibliothek entwickeln und m√∂chten, dass sie f√ºr Benutzer in .NET Framework funktioniert, m√ºssen Sie ein Ziel f√ºr .NET Standard 2.0 haben. Neben der Tatsache, dass .NET Framework die neueste Version des .NET-Standards nicht unterst√ºtzt, sollten wir auf das Sternchen achten. .NET Framework 4.6.1 unterst√ºtzt .NET Standard 2.0, jedoch mit einem Sternchen. Es gibt eine solche Fu√ünote direkt in der Dokumentation, woher ich diese Tabelle habe.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ay/mq/yu/aymqyunvnqjivv13dpqkrzvac6i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein Beispielprojekt. Eine Anwendung in .NET Framework mit einer Abh√§ngigkeit f√ºr den .NET-Standard. So etwas wie das: ConsoleApp und ClassLibrary. Zielbibliothek .NET Standard. Wenn wir dieses Projekt zusammenstellen, wird es in unserem BIN so sein. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fh/62/og/fh62og_vou9gzibnv5gdd2mp_uk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden dort hundert DLLs haben, von denen sich nur eine auf die Anwendung bezog, alles andere kam, um den .NET-Standard zu unterst√ºtzen. Tatsache ist, dass .NET Standard 2.0 sp√§ter als .NET Framework 4.6.1 erschien, sich jedoch gleichzeitig als API-kompatibel herausstellte und die Entwickler beschlossen, .NET 4.6.1 um Standard 2.0-Unterst√ºtzung zu erweitern. Wir haben es nicht nativ gemacht (durch Aufnahme </font></font><code>netstandard.dll</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die Laufzeit selbst), sondern so, dass .NET Standard * .dll und alle anderen Baugruppenfassaden direkt in BIN platziert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/af/15/am/af15amgkrw698xqylhfwemd67uy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir uns die Abh√§ngigkeiten der Version von .NET Framework ansehen, auf die wir abzielen, und die Anzahl der Bibliotheken, die in die BIN fallen, werden wir feststellen, dass es in 4.7.1 nicht so viele davon gibt, und seit 4.7.2 gibt es √ºberhaupt keine zus√§tzlichen Bibliotheken und .NET Standard wird dort nativ unterst√ºtzt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rf/wu/va/rfwuvalfp3bi6zijyw5kjz-wjva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Tweet von einem der .NET-Entwickler, der dieses Problem beschreibt und die Verwendung von .NET Framework Version 4.7.2 empfiehlt, wenn wir √ºber .NET Standard-Bibliotheken verf√ºgen. </font><font style="vertical-align: inherit;">Nicht einmal mit Version 2.0 hier, sondern mit Version 1.5.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn m√∂glich, erh√∂hen Sie das Ziel-Framework in Ihrem Projekt auf mindestens 4.7.1, vorzugsweise 4.7.2. </font><font style="vertical-align: inherit;">Wenn Sie eine Bibliothek entwickeln, um Bibliotheksbenutzern das Leben zu erleichtern, erstellen Sie ein separates Ziel f√ºr .NET Framework. Dadurch wird eine gro√üe Anzahl von DLLs vermieden, die mit etwas in Konflikt stehen k√∂nnen.</font></font><a name="dotnet"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginnen wir mit einer allgemeinen Theorie. </font><font style="vertical-align: inherit;">Wir werden diskutieren, wie wir JetBrains Rider auf .NET Core gestartet haben und warum wir √ºberhaupt dar√ºber sprechen sollten. </font><font style="vertical-align: inherit;">Rider ist ein sehr gro√ües Projekt, es hat eine riesige Unternehmensl√∂sung mit einer gro√üen Anzahl verschiedener Projekte, ein komplexes System von Abh√§ngigkeiten. Sie k√∂nnen es nicht einfach nehmen und gleichzeitig auf eine andere Laufzeit migrieren. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir einige Hacks verwenden, die wir auch analysieren werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core-Anwendung</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie sieht eine typische .NET Core-Anwendung aus? H√§ngt davon ab, wie genau es bereitgestellt wird und was es letztendlich tun wird. Wir k√∂nnen mehrere Szenarien haben. Die erste ist eine Framework-abh√§ngige Bereitstellung. Dies ist dasselbe wie in .NET Framework, wenn die Anwendung die auf dem Computer vorinstallierte Laufzeit verwendet. Es kann sich um eine eigenst√§ndige Bereitstellung handeln. In diesem Fall verf√ºgt die Anwendung √ºber eine Laufzeit. M√∂glicherweise gibt es eine Bereitstellung mit nur einer Datei. In diesem Fall erhalten wir eine Exe-Datei. Im Fall von .NET Core in dieser Exe-Datei befindet sich jedoch ein Artefakt einer in sich geschlossenen Anwendung. Dies ist ein selbstextrahierendes Archiv. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/yi/3c/hxyi3c3yxhavujn9ljcmtxkuvj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden nur die Framework-abh√§ngige Bereitstellung ber√ºcksichtigen. Wir haben eine DLL mit der Anwendung, es gibt zwei Konfigurationsdateien, von denen die erste erforderlich ist, diese </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ab .NET Core 3.0 wird eine exe-Datei generiert, die erforderlich ist, damit die Anwendung bequemer ausgef√ºhrt werden kann, sodass Sie unter Windows nicht den Befehl .NET eingeben m√ºssen. </font><font style="vertical-align: inherit;">Abh√§ngigkeiten fallen in dieses Artefakt, beginnend mit .NET Core 3.0. In .NET Core 2.1 m√ºssen Sie eine andere Eigenschaft ver√∂ffentlichen oder verwenden </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><a name="config"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gemeinsame Frameworks, </font></font><code>.runtimeconfig.json</code></h3><br>
<br>
<img src="https://habrastorage.org/webt/cc/a5/ab/cca5ab5zhb3v6b1itc9jjbsiwje.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enth√§lt die Laufzeiteinstellungen, die zum Ausf√ºhren erforderlich sind. Es gibt an, unter welchem ‚Äã‚ÄãShared Framework die Anwendung gestartet wird, und es sieht so aus. Wir weisen darauf hin, dass die Anwendung unter "Microsoft.NETCore.App" Version 3.0.0 ausgef√ºhrt wird. M√∂glicherweise gibt es ein anderes freigegebenes Framework. Hier k√∂nnen auch andere Einstellungen vorgenommen werden. Sie k√∂nnen beispielsweise den Server Garbage Collector aktivieren. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c5/un/ic/c5unicttj2dp5ol0jiewknhb48i.jpeg"><br>
<br>
<code>.runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w√§hrend der Montage des Projekts generiert. Und wenn wir den Server-GC einbinden m√∂chten, m√ºssen wir diese Datei im Voraus irgendwie √§ndern, noch bevor wir das Projekt zusammenstellen oder von Hand hinzuf√ºgen. Hier k√∂nnen Sie Ihre Einstellungen hinzuf√ºgen. Wir k√∂nnen entweder Eigenschaften in aufnehmen </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wenn diese Eigenschaften von .NET-Entwicklern bereitgestellt werden, oder wenn Eigenschaften nicht bereitgestellt werden, k√∂nnen wir eine Datei mit dem Namen erstellen</font></font><code>runtimeconfig.template.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und schreiben Sie hier die notwendigen Einstellungen. W√§hrend der Montage werden dieser Vorlage weitere erforderliche Einstellungen hinzugef√ºgt, z. B. dasselbe Shared Framework. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/bu/e9/rlbue9y7cikkyzwenefcu2rdxy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Shared Framework besteht aus einer Reihe von Laufzeitprogrammen und Bibliotheken. In der Tat war das gleiche wie die .NET Framework-Laufzeit, die fr√ºher nur einmal auf dem Computer installiert wurde und f√ºr alle eine Version war. Shared Framework und im Gegensatz zu einer einzelnen .NET Framework-Laufzeit k√∂nnen verschiedene Anwendungen unterschiedliche Versionen der installierten Laufzeiten verwenden. Auch Shared Framework kann vererbt werden. Das Shared Framework selbst kann an solchen Stellen auf der Festplatte angezeigt werden, die normalerweise auf dem System installiert sind.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nc/df/7i/ncdf7ioj8afrolkvnlouh77jiaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt mehrere Standard-Shared Frameworks, z. B. Microsoft.NETCore.App, auf dem herk√∂mmliche Konsolenanwendungen ausgef√ºhrt werden, AspNetCore.App f√ºr Webanwendungen und WindowsDesktop.App, das neue Shared Framework in .NET Core 3, auf dem Desktopanwendungen ausgef√ºhrt werden. unter Windows Forms und WPF. Die letzten beiden Shared Frameworks erg√§nzen im Wesentlichen das erste, das f√ºr Konsolenanwendungen ben√∂tigt wird, dh sie enthalten keine ganz neue Laufzeit, sondern erg√§nzen einfach das vorhandene mit den erforderlichen Bibliotheken. Diese Vererbung scheint auch in den Shared Framework-Verzeichnissen vorhanden zu sein, </font></font><code>runtimeconfig.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in denen das Basis-Shared Framework angegeben ist.</font></font><a name="man"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abh√§ngigkeitsmanifest ( </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/sc/qv/qbscqv1sh6jb_r19ps_qrusogfi.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardpr√ºfung - .NET Core Die</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
zweite Konfigurationsdatei ist diese </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diese Datei enth√§lt eine Beschreibung aller Abh√§ngigkeiten der Anwendung oder des Shared Framework oder der Bibliothek, die die Bibliotheken </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch haben. Es enth√§lt alle Abh√§ngigkeiten, einschlie√ülich der transitiven. Das Verhalten der .NET Core-Laufzeit h√§ngt davon ab, ob </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Anwendung √ºber diese verf√ºgt oder nicht. Wenn </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht, kann die Anwendung alle Assemblys laden, die sich in ihrem Shared Framework oder in ihrem BIN-Verzeichnis befinden. Wenn dies der Fall </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist, ist die Validierung aktiviert. Wenn eine der in aufgelisteten Assemblys </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht vorhanden ist, wird die Anwendung einfach nicht gestartet. Sie sehen den oben dargestellten Fehler. Wenn die Anwendung versucht, eine Assembly zur Laufzeit zu laden, welche</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie beispielsweise Assembly-Lademethoden verwenden oder w√§hrend des Aufl√∂sungsprozesses von Assemblys, wird ein Fehler angezeigt, der dem Laden strenger Assemblys sehr √§hnlich ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetbrains Fahrer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rider ist eine .NET IDE. Nicht jeder wei√ü, dass Rider eine IDE ist, die aus einem Frontend, das auf IntelliJ IDEA basiert und in Java und Kotlin geschrieben ist, und einem Backend besteht. Das Backend ist im Wesentlichen R #, das mit IntelliJ IDEA kommunizieren kann. Dieses Backend ist jetzt eine plattform√ºbergreifende .NET-Anwendung. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wo l√§uft es? Windows verwendet das .NET Framework, das auf dem Computer des Benutzers installiert ist. Auf anderen Informationssystemen unter Linux und Mac wird Mono verwendet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist keine ideale L√∂sung, wenn es √ºberall unterschiedliche Laufzeiten gibt, und ich m√∂chte zum n√§chsten Status √ºbergehen, damit Rider auf .NET Core ausgef√ºhrt wird. Um die Leistung zu verbessern, sind in .NET Core alle neuesten Funktionen damit verbunden. Speicherverbrauch reduzieren. Jetzt gibt es ein Problem damit, wie Mono mit dem Speicher arbeitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie zu .NET Core wechseln, k√∂nnen Sie √§ltere, nicht unterst√ºtzte Technologien aufgeben und einige Korrekturen f√ºr die zur Laufzeit festgestellten Probleme beheben. </font><font style="vertical-align: inherit;">Wenn Sie zu .NET Core wechseln, k√∂nnen Sie die Version der Laufzeit steuern. Das hei√üt, Rider wird nicht mehr auf dem auf dem Computer des Benutzers installierten .NET Framework ausgef√ºhrt, sondern auf einer bestimmten Version von .NET Core, die als eigenst√§ndige Bereitstellung gesperrt werden kann. </font><font style="vertical-align: inherit;">Der √úbergang zu .NET Core erm√∂glicht schlie√ülich die Verwendung neuer APIs, die speziell in Core importiert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt ist das Ziel, einen Prototyp zu starten, ihn zu starten, nur um zu √ºberpr√ºfen, wie er funktioniert, was die potenziellen Fehlerquellen sind, welche Komponenten erneut neu geschrieben werden m√ºssen und welche globale Verarbeitung erforderlich ist.</font></font><br>
<br>
<a name="rider"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktionen, die die √úbersetzung von Rider in .NET Core erschweren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Visual Studio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">st√ºrzt bei gro√üen L√∂sungen, in denen sich Projekte mit SDK-Stil * .csproj befinden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">aus dem Arbeitsspeicher ab</font></a><font style="vertical-align: inherit;"> , auch wenn R # nicht darin installiert ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">SD. -Stil * .csproj ist eine der Hauptbedingungen f√ºr eine vollst√§ndige .NET Core-Verlagerung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist ein Problem, da Rider auf R # basiert und sich im selben Repository befindet. R # -Entwickler m√∂chten mit Visual Studio ihr eigenes Produkt in ihrem Produkt entwickeln, um daraus Lebensmittel zu machen. </font><font style="vertical-align: inherit;">In R # gibt es Links zu bestimmten Bibliotheken f√ºr das Framework, mit denen Sie etwas tun m√ºssen. </font><font style="vertical-align: inherit;">Unter Windows k√∂nnen wir das Framework f√ºr Desktop-Anwendungen verwenden, und unter Linux und Mac wird Mock bereits f√ºr Windows-Bibliotheken mit minimaler Funktionalit√§t verwendet.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entscheidung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns entschlossen, vorerst auf den alten zu bleiben </font></font><code>*.csproj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und unter dem vollst√§ndigen Framework zusammenzustellen. Da die Assemblys von Framework und Core jedoch bin√§r kompatibel sind, f√ºhren Sie sie auf Core aus. </font><font style="vertical-align: inherit;">Wir verwenden keine inkompatiblen Funktionen, f√ºgen alle erforderlichen Konfigurationsdateien manuell hinzu und laden ggf. spezielle Versionen von Abh√§ngigkeiten f√ºr .NET Core herunter.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zu welchen Hacks mussten Sie gehen?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Hack: Wir m√∂chten eine Methode aufrufen, die nur im Framework verf√ºgbar ist. Diese Methode wird beispielsweise in R # ben√∂tigt, nicht jedoch in Core. </font><font style="vertical-align: inherit;">Das Problem ist, dass, wenn es keine Methode gibt, die Methode, die sie w√§hrend der JIT-Kompilierung aufruft, fr√ºher f√§llt </font></font><code>MissingMethodException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das hei√üt, eine Methode, die nicht existiert, hat die Methode, die sie aufruft, ruiniert.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Method</span>(<span class="hljs-params"></span>)</span> { <font></font>
  <span class="hljs-keyword">if</span> (NetFramework) <font></font>
     CallNETFrameworkOnlyMethod();<font></font>
<font></font>
  ... <font></font>
} <font></font>
[<span class="hljs-meta">MethodImpl(MethodImplOptions.NoInlining)</span>] <font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CallNETFrameworkOnlyMethod</span>(<span class="hljs-params"></span>)</span> { <font></font>
  NETFrameworkOnlyMethod(); <font></font>
}<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung ist hier: Wir rufen inkompatible Methoden in separate Methoden auf. Es gibt noch ein weiteres Problem: Eine solche Methode kann inline werden, daher markieren wir sie mit einem Attribut </font></font><code>NoInlining</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hack Nummer zwei: Wir m√ºssen in der Lage sein, Assemblys in relativen Pfaden zu laden. Wir haben eine Assembly f√ºr das Framework, es gibt eine spezielle Version f√ºr .NET Core. Wie laden wir die .NET Core-Version f√ºr .NET Core herunter? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qm/zm/w7/qmzmw79gtllee8uyswgrn0oqnum.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden uns helfen </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schauen wir uns </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die System.Diagnostics.PerformanceCounter-Bibliothek an. Eine solche Bibliothek ist bemerkenswert in Bezug auf ihre</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es hat einen Laufzeitabschnitt, in dem eine Version der Bibliothek mit ihrem relativen Pfad angegeben ist. In dieser Bibliothek wird die Assembly zu allen Laufzeiten geladen und nur die Ausf√ºhrungen ausgel√∂st. Wenn es beispielsweise unter Linux geladen wird, funktioniert der PerformanceCounter unter Linux nicht mit Design, und von dort aus fliegt eine PlatformNotSupportedException. In diesem </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abschnitt </font><font style="vertical-align: inherit;">befindet sich auch </font><font style="vertical-align: inherit;">ein Abschnitt zu runtimeTargets. Hier ist bereits die Version dieser Assembly speziell f√ºr Windows angegeben, in der PerformanceCounter funktionieren soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Laufzeitabschnitt nehmen und darin den relativen Pfad zu der Bibliothek schreiben, die wir laden m√∂chten, hilft uns dies nicht weiter. Der Laufzeitabschnitt legt tats√§chlich den relativen Pfad innerhalb des NuGet-Pakets fest und nicht relativ zur BIN. Wenn wir diese Assembly in BIN suchen, wird nur der Dateiname von dort verwendet. Der Abschnitt runtimeTargets enth√§lt bereits einen ehrlichen relativen Pfad, einen ehrlichen Pfad relativ zu BIN. Wir werden einen relativen Pfad f√ºr unsere Assemblys im Abschnitt runtimeTargets vorgeben. Anstelle der Laufzeitkennung, die hier "win" ist, k√∂nnen wir eine andere nehmen, die uns gef√§llt. Zum Beispiel schreiben wir die Laufzeitkennung "any" und diese Assembly wird im Allgemeinen auf allen Plattformen geladen. Oder wir schreiben "Unix" und es bootet unter Linux, Mac und so weiter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√§chster Hack: Wir m√∂chten unter Linux und Mac Mock herunterladen, um WindowsBase zu erstellen. Das Problem ist, dass die Assembly mit dem Namen WindowsBase bereits im Shared Framework vorhanden ist </font></font><code>Microsoft.NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, auch wenn wir nicht unter Windows arbeiten. In Windows Shared Framework </font></font><code>Microsoft.WindowsDesktop.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definiert WindowsBase die Version neu, in der es sich befindet </font></font><code>NETCore.App</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Schauen wir uns </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dieses Framework genauer an, genauer gesagt die Abschnitte, die WindowsBase beschreiben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gc/ox/f3/gcoxf3q7mbfm_a9hzmcujfin5zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist der Unterschied: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5q/pz/wq/5qpzwq-n21m38b_0xedi9txpwoc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn einige Bibliothekskonflikte auftreten und in mehreren vorhanden sind </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, wird das Maximum f√ºr das Paar ausgew√§hlt, das aus </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und besteht </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das .NET-Handbuch besagt, dass </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es nur ben√∂tigt wird, um es im Windows Explorer anzuzeigen, aber nicht, es f√§llt in</font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies ist der einzige Fall , </font><font style="vertical-align: inherit;">dass ich wei√ü, wann die Version vorgeschriebenen </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>assemblyVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>fileVersion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tats√§chlich verwendet werden. In allen anderen F√§llen stellte ich ein Verhalten fest </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, bei dem die Assembly trotzdem geladen wird </font><font style="vertical-align: inherit;">, unabh√§ngig davon, in welchen Versionen </font><font style="vertical-align: inherit;">sie geschrieben wurden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bw/re/j8/bwrej8fa8_gyuyvcjnt3ixvljce.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vierter Hack. Aufgabe: Wir haben eine .deps.json-Datei f√ºr die beiden vorherigen Hacks und ben√∂tigen sie nur f√ºr bestimmte Abh√§ngigkeiten. Da sie </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im halbmanuellen Modus generiert werden, haben wir ein Skript, das sie gem√§√ü einer Beschreibung dessen, was dort ankommen soll, w√§hrend des Builds generiert. Wir m√∂chten dies so </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gering wie m√∂glich halten, damit wir verstehen k√∂nnen, was darin enthalten ist. Wir m√∂chten die Validierung deaktivieren und den Download von Assemblys zulassen, die sich in der BIN befinden, aber nicht in beschrieben sind </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L√∂sung: Aktivieren Sie die benutzerdefinierte Konfiguration in runtimeconfig. </font><font style="vertical-align: inherit;">Diese Einstellung wird tats√§chlich f√ºr die Abw√§rtskompatibilit√§t mit .NET Core 1.0 ben√∂tigt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, </font></font><code>.runtime.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf .NET Core - das sind Analoga </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>App.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie k√∂nnen die gleichen Aktionen ausf√ºhren, z. B. Baugruppen auf relative Weise laden. </font><font style="vertical-align: inherit;">Wenn Sie </font></font><code>.deps.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es manuell umschreiben, k√∂nnen Sie das Laden von Assemblys in .NET Core anpassen, wenn Sie ein sehr komplexes Szenario haben.</font></font><a name="load"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debug-Assembly-Downloads</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe √ºber einige Arten von Problemen gesprochen, daher m√ºssen Sie in der Lage sein, Probleme beim Laden von Assemblys zu debuggen. </font><font style="vertical-align: inherit;">Was kann dabei helfen? </font><font style="vertical-align: inherit;">Zun√§chst schreiben Laufzeiten Protokolle dar√ºber, wie sie Assemblys laden. </font><font style="vertical-align: inherit;">Zweitens k√∂nnen Sie sich die Ausf√ºhrungen, die zu Ihnen fliegen, genauer ansehen. </font><font style="vertical-align: inherit;">Sie k√∂nnen sich auch auf Laufzeitereignisse konzentrieren.</font></font><a name="fusion"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionsprotokolle</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/jl/4v/be/jl4vbeqsyjzmab2rx0xvdg-lpi4.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zur√ºck zu den Grundlagen: Verwenden des Fusion Log Viewer zum Debuggen obskurer Fehler </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Mechanismus zum Laden von Assemblys in .NET Framework hei√üt Fusion und kann protokollieren, was auf der Festplatte geschehen ist. Um die Protokollierung zu aktivieren, m√ºssen Sie der Registrierung spezielle Einstellungen hinzuf√ºgen. Dies ist nicht sehr praktisch, daher ist es sinnvoll, Dienstprogramme zu verwenden, n√§mlich Fusion Log Viewer und Fusion ++. Fusion Log Viewer ist ein Standarddienstprogramm, das mit Visual Studio geliefert wird und √ºber die Visual Studio-Befehlszeile Visual Studio Developer Command Prompt gestartet werden kann. Fusion ++ ist ein Open-Source-Analogon dieses Tools mit einer sch√∂neren Oberfl√§che.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/9h/bt/ou9hbtdgx1yjp6rjjdm3q61efpu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Fusion Log Viewer sieht so aus. Dies ist schlimmer als WinDbg, da sich dieses Fenster nicht einmal ausdehnt. Trotzdem k√∂nnen Sie hier die H√§kchen durchstechen, obwohl nicht immer klar ist, welche H√§kchen korrekt sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gu/h2/by/guh2byfmgazm8yvbxfa_jhf25wo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fusion ++ verf√ºgt √ºber eine Schaltfl√§che "Protokollierung starten". Anschlie√üend wird die Schaltfl√§che "Protokollierung beenden" angezeigt. Darin k√∂nnen Sie alle Datens√§tze zum Laden von Assemblys anzeigen und die Protokolle dar√ºber lesen, was genau passiert ist. Diese Protokolle sehen auf pr√§gnante Weise ungef√§hr so ‚Äã‚Äãaus.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/ep/5m/zfep5myuovdov4t7mmtw4czhwqc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine Ausnahme vom strengen Laden von Baugruppen. </font><font style="vertical-align: inherit;">Wenn wir uns die Fusion-Protokolle ansehen, werden wir feststellen, dass wir Version 9.0.0.0 herunterladen mussten, nachdem wir alle Konfigurationen verarbeitet haben. </font><font style="vertical-align: inherit;">Wir haben eine Datei gefunden, in der vermutet wird, dass wir die Baugruppe haben, die wir ben√∂tigen. </font><font style="vertical-align: inherit;">Wir haben gesehen, dass sich Version 6.0.0.0 in dieser Datei befindet. </font><font style="vertical-align: inherit;">Wir haben eine Warnung, dass wir die vollst√§ndigen Namen der Baugruppen verglichen haben und sie sich in der Hauptversion unterscheiden. </font><font style="vertical-align: inherit;">Und dann ist ein Fehler aufgetreten - Versionsinkongruenz.</font></font><a name="events"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laufzeitereignisse</font></font></h3><br>
<br>
<img src="https://habrastorage.org/webt/pu/np/bn/punpbnrdvfv_mm5bpweej75ofq8.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokollieren von Laufzeitereignissen</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In Mono k√∂nnen Sie die Protokollierung mithilfe von Umgebungsvariablen aktivieren. Die Protokolle werden schlie√ülich in </font></font><code>stdout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und geschrieben </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nicht so bequem, aber die L√∂sung funktioniert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rj/vv/g9/rjvvg9dfv0ji5sbxm_crgu3ok0a.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardpr√ºfung - .NET Core- </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumentation / Entwurfsdokumente / Host-Ablaufverfolgung</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. .NET Core verf√ºgt au√üerdem √ºber eine spezielle Umgebungsvariable, </font></font><code>COREHOST_TRACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die die Anmeldung umfasst </font></font><code>stderr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mit .NET Core 3.0 k√∂nnen Sie Protokolle in eine Datei schreiben, indem Sie den Pfad dazu in einer Variablen angeben </font></font><code>COREHOST_TRACEFILE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<img src="https://habrastorage.org/webt/eo/b5/yf/eob5yf90z7cgilees68uxtrhw0w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt ein Ereignis, das ausgel√∂st wird, wenn die Assemblys nicht geladen werden k√∂nnen. Dies ist eine Veranstaltung </font></font><code>AssembleResolve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Es gibt ein zweites n√ºtzliches Ereignis, dieses </font></font><code>FirstChanceException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie k√∂nnen es abonnieren und eine Fehlermeldung beim Laden von Assemblys erhalten, selbst wenn jemand try..catch geschrieben und alle Ausf√ºhrungen an der Stelle verpasst hat, an der</font></font><code>FileLoadException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aufgetreten. </font><font style="vertical-align: inherit;">Wenn die Anwendung bereits kompiliert wurde, k√∂nnen Sie sie starten </font></font><code>perfview</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und .NET-Ausf√ºhrungen √ºberwachen. Dort finden Sie diejenigen, die sich auf Download-Dateien beziehen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h2> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úbertragen Sie die Arbeit auf Tools, Entwicklungstools, IDE und MSBuild, mit denen Sie Weiterleitungen generieren k√∂nnen. </font><font style="vertical-align: inherit;">Sie k√∂nnen zu .NET Core wechseln, dann werden Sie vergessen, was Strict Assembly Loading ist, und Sie k√∂nnen die neue API genau so verwenden, wie wir es in Rider erreichen m√∂chten. </font><font style="vertical-align: inherit;">Wenn Sie die .NET Standard-Bibliothek verbinden, erh√∂hen Sie die Zielversion von .NET Framework auf mindestens 4.7.1. </font><font style="vertical-align: inherit;">Wenn Sie sich in einer hoffnungslosen Situation befinden, suchen Sie nach Hacks, verwenden Sie sie oder entwickeln Sie Ihre eigenen Hacks f√ºr hoffnungslose Situationen. </font><font style="vertical-align: inherit;">Und r√ºsten Sie sich mit Debugging-Tools aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich empfehle Ihnen dringend, die folgenden Links zu lesen:</font></font><br>
<br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.NET Guide</a>;</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">     .NET Core</a>.</li>
</ul><br>
<br>
<blockquote>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">DotNext 2020 Piter</a> .       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> 8   JUG Ru Group</a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499824/index.html">Die Zusammenfassung der Ereignisse f√ºr Personal- und IT-Personalvermittler im Mai 2020</a></li>
<li><a href="../de499826/index.html">Verteilter Blutdruck</a></li>
<li><a href="../de499832/index.html">Wie kann die Remote-Arbeit von Mitarbeitern schnell und sicher organisiert werden? Wir sprechen √ºber verschiedene Ans√§tze: mit VDI und nicht nur</a></li>
<li><a href="../de499834/index.html">Lernen Sie das Felix Arithmometer kennen</a></li>
<li><a href="../de499836/index.html">Udalenka vs. B√ºro f√ºr das Entwicklungsteam</a></li>
<li><a href="../de499842/index.html">Warum lernen die Leute neu?</a></li>
<li><a href="../de499846/index.html">Wann die separate Speicherbereinigung funktioniert und warum eine Video√ºberwachung von Standorten f√ºr Speichercontainer erforderlich ist</a></li>
<li><a href="../de499850/index.html">So analysieren Sie Wettbewerber und erstellen in 40 Minuten eine digitale Strategie</a></li>
<li><a href="../de499852/index.html">Englischsprachige Dokumentation f√ºr Angular</a></li>
<li><a href="../de499854/index.html">Apache Bigtop und die Wahl der Hadoop-Distribution heute</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>