<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍵 🥓 👨🏾‍⚖️ 如何使用数学算法使生成的图像看起来自然 🤘🏽 🌍 🦄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="他们不时给我写评论，说我的作品看起来不是计算机生成的。对于我来说，这是最好的称赞：我对生成艺术的浓厚兴趣始于当我意识到他能够创作此类作品时。在这里，我将介绍一些我用来提高工作自然性的方法。
 
 这篇文章与语言无关，与框架无关。我们只会谈论技术。
 
 请立即同意：我并不是说看起来自然的作品在某种程...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>如何使用数学算法使生成的图像看起来自然</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506828/"><img src="https://habrastorage.org/webt/vq/01/8y/vq018y5_54yl_m_taaespejunuu.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他们不时给我写评论，说我的作品看起来不是计算机生成的。</font><font style="vertical-align: inherit;">对于我来说，这是最好的称赞：我对生成艺术的浓厚兴趣始于当我意识到他能够创作此类作品时。</font><font style="vertical-align: inherit;">在这里，我将介绍一些我用来提高工作自然性的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章与语言无关，与框架无关。</font><font style="vertical-align: inherit;">我们只会谈论技术。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请立即同意：我并不是说看起来自然的作品在某种程度上要比看起来数字化的作品好。</font><font style="vertical-align: inherit;">无需将自然性作为目标。</font><font style="vertical-align: inherit;">我追她只是因为我喜欢，那是我的品味。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主导原则：根据实际情况为您的工作建模</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如有可能，请考虑如何在纸上描绘您的创作，或在现实世界中的外观。</font><font style="vertical-align: inherit;">对真实的物理过程进行建模很可能会导致看起来逼真的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，自然界通常找不到均匀分布的数据。</font><font style="vertical-align: inherit;">大部分数据类似钟形曲线。</font><font style="vertical-align: inherit;">与从间隙或列表中进行随机选择相比，使用正态分布的随机变量（具有平均值和标准偏差的变量）通常会产生更自然的效果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们的数据类型是段。</font><font style="vertical-align: inherit;">为了绘制它，我们通常这样做：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择起点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">选择终点</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在点之间画一条线</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果是这样的：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aw/ad/bm/awadbm31yfigpdjpnrk2onhheqm.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为太完美了！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机倾斜</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们绘制了几条水平线，并且希望使其更自然。</font><font style="vertical-align: inherit;">首先，您可以稍微移动线的端点。</font><font style="vertical-align: inherit;">我们可以通过使用正态分布移动它们，在x和y方向上具有很小的标准偏差来实现。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t3/0i/jf/t30ijfz_vsem3sx2hkbcp1gtr8u.jpeg" alt="图片"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">波浪摆动</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们的线与原始位置略有偏移。</font><font style="vertical-align: inherit;">并且长度略有不同。</font><font style="vertical-align: inherit;">但是，它们是完全简单的。</font><font style="vertical-align: inherit;">这不像我们在现实世界中遇到的界限。</font><font style="vertical-align: inherit;">让我们减少它们的笔直度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，可以这样完成：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在线的端点之间选择N个点以创建新线。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">转移每一点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">柔和线条并绘制。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此模式有很多变体。</font><font style="vertical-align: inherit;">简单-在起点和终点之间取N个插值点，像以前一样使用静态标准偏差校正每个插值点。</font><font style="vertical-align: inherit;">我将使用算法来更改Chaikin曲线以获得平滑线。</font><font style="vertical-align: inherit;">结果如下：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ak/sy/mu/aksymuzcyqbejr0hwqym0zkcdim.jpeg" alt="图片"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">邻近点的影响</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，有些事情开始对我们起作用。更改标准偏差参数使我们能够控制生产线的“波动”。但是，您可能已经注意到，振荡是相互独立的。线可能会波动，然后靠近附近的上部，然后到达下部线。为了保护自己免受此伤害，我建议使用此选项。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进行调整后，取结果线中每对相邻点的平均值（这是一个非常简单的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">核平滑</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例</font><font style="vertical-align: inherit;">）。您可以多次进行此操作以获得更平滑的线条。现在通过点画一条曲线。现在，每个点都会更自然地影响相邻点。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/nm/m-/oonmm-eioy9tbhjhrqdlzu7vydc.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我要说的是，现在表格看起来还不错。</font><font style="vertical-align: inherit;">如果我试图在纸上画一条直线，它可能看起来像那样。</font><font style="vertical-align: inherit;">我们可以通过手动校正来更改功能中的标准偏差，以便模拟一条直线，好像是多少只精确的手。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：在这种情况下，您仍然可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一维杂讯</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能</font><font style="vertical-align: inherit;">将点沿直线移动。</font><font style="vertical-align: inherit;">结果也将是一条平滑的曲线，但是根据您使用的噪声函数，它会更加可预测。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理线</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们的线看起来很自然。</font><font style="vertical-align: inherit;">但是，当我们调用stroke（）函数时，我们仍在使用完全准确的“笔”进行绘图。</font><font style="vertical-align: inherit;">在现实世界中，当我们使用各种绘画工具时，它们的纹理会有所不同。</font><font style="vertical-align: inherit;">产生这些差异的一种方法是使用由Anders Hoff（又名inconvergent）推广的沙样条技术。</font><font style="vertical-align: inherit;">这个想法很简单：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用正态分布稍微调整线中的每个点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在每对相邻的点之间生成更多的点，并将它们绘制为微小的点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重复几次。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的点非常小，则会得到以下纹理：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/ga/7a/elga7axiyj4vmhhfh9-_dhsvdss.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这只是向线条添加纹理的许多方法之一，但这也是我最喜欢的主题。</font><font style="vertical-align: inherit;">试用您的纹理，看看最适合您的纹理。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dd/sx/bp/ddsxbpy36aevwhjghqawe0tfhem.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沙漠之梦（2018）纹理线条是我许多作品的基础。</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们可以绘制不寻常的线条，让我们继续进行第二个维度-形状。为了简单起见，我们将重点放在四边形上，但是这些技术可以应用于许多其他形状。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以画一个正方形。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d1/zb/v4/d1zbv43idaugnd6ksuywil_vuxs.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以应用已经提到的随机倾斜原理，逐渐改变每个角度。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ze/_b/ew/ze_bewftwc0ijnmkzsokbuuuprm.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以选择并平滑每个相邻坐标之间的点以获得“曲线”正方形。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/r9/qv/pnr9qvimh6iwajma7ixgudbkaee.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以通过平均相邻点来平滑它们。由于该线段现在已关闭，因此您需要小心，以免抓住第一个坐标中的点。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aw/g4/x2/awg4x2ibmdu6toqlxcvrjecov5o.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些都不是新的。实际上，我们在这里只讨论封闭的部分，因为我们只是在拐角处。如何填充空间？我们可以使用fill（）函数，但这有点无聊。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w2/gh/ni/w2ghnig5gkyp9bc47hkjmasdw1y.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了使纹理更有趣，可以用虚线元素填充四边形，并在其中生成许多点*。我们将再次简化图形以使边框更易于理解（您也可以填充复杂的形状，但现在就开始吧）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/yw/ei/muyweijqnmrcewxowaqizgdgn4o.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
*注意：您可以通过将正方形分成两个三角形并使用均匀分布在每个三角形中生成一个点来实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管看起来有些混乱，但是因为均匀分布并不像看起来那样直观。</font><font style="vertical-align: inherit;">为了更自然地分配点，我们可以从我最喜欢的序列之一中获取值-Halton Sequences（2.3）[您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很酷的文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了解到它</font><font style="vertical-align: inherit;">]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
霍尔顿序列（2.3）生成R2中间隔（0，1）×（0，1）的点。</font><font style="vertical-align: inherit;">要用此序列中生成的点填充正方形，我们可以：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到包含“矩形”的最小边界框。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在（2.3）Halton序列中生成N个点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用最小边界框的宽度（或高度）对每个点进行分级。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿着正方形的左上角坐标移动点。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过滤掉所有不在“平方”中的点。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这都可以在支持平方和过滤外部点的任何形状上进行。</font><font style="vertical-align: inherit;">尝试的最简单方法是用虚线元素填充正方形，其中平方和过滤操作很容易。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，（2.3）简单生成Halton序列；</font><font style="vertical-align: inherit;">阅读有关伪维基百科（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eng</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的信息。</font><font style="vertical-align: inherit;">这是10,000点的笔划填充。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_u/qv/qd/_uqvqdbaoey_bmgn9v1op1qjol8.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于（2.3）Halton序列不是随机生成的，因此会创建相同外观的纹理。</font><font style="vertical-align: inherit;">解决此问题的几种方法：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逐渐移动边界框（可选），以移动边界框以移动序列的中心。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从序列的开头删除N点。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从序列中随机丢弃一小部分点（但要小心，这会产生更多噪音）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，这些方法可以组合。</font><font style="vertical-align: inherit;">实验！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成此类纹理的另一种常见方法是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过采样</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个随机过程，但对计算和实现的资源要求也更高。</font><font style="vertical-align: inherit;">但是他很好。</font><font style="vertical-align: inherit;">我在Wire系列中使用了此方法，这是其中之一。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/5c/wn/di/5cwndiec_izug4jolmc_f_2fymm.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">导线T</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
当然，这不是唯一的纹理化方法。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很难感觉到什么颜色相互结合。您可以轻松选择自己认为融合得很好的颜色，但随后意识到它们根本无法融合，使您的作品看起来比黑白差10倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想说，对于生成艺术家来说，这会带来特殊的复杂性。生成艺术中改变颜色的标准方法是手动调整硬编码的变量并不断生成图片，直到您喜欢为止。玩颜色确实是学习如何正确使用它们的最佳方法。我们如何改善它？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我的方法，我从约书亚·戴维斯的想法（https://joshuadavis.com/]重述了。重点：</font></font><br>
<br>
<ol>
<li>   (, ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">AutoDesk SketchBook</a>)        png.</li>
<li> png        ,       ,    (    [0,1])</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法效果很好，您可以轻松地更改渐变，并足够清楚地看到哪些看起来漂亮，哪些没有。有可能进行非常快速的迭代。此外，大多数现代绘图程序都具有模拟减色混合的功能，这在绘制自然外观的过渡时有很大帮助。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用此渐变绘制上一个示例中的点（仅多20倍点）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fr/1t/xj/fr1txj7z56ksu4vufwh6uotgnb8.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用的平滑度函数在y中是线性的。正方形上部的y值表示0，下部表示1。值得注意的是，平滑度函数的结果（介于0和1之间）与正态分布的随机值一起略有偏移。这有助于形成不太均匀的结构。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/z5/ou/qhz5oukl_heojdpnc_ccg9ux8yo.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细。</font><font style="vertical-align: inherit;">这只是一个非常简单的平滑函数（以及我在5分钟内创建的渐变）。</font><font style="vertical-align: inherit;">想象可能性！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">充分利用噪音</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既然我们在谈论平滑函数，那么噪声呢？ Perlin的噪声不太适合此功能，因为其值从-1到1不等。但是通过智能映射，限制无关值，模块化浮点算法和/或其他技巧，我们当然可以将范围缩小到[0,1]。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模块化系列</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之一，其中我使用2D噪声作为颜色平滑度的函数。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c1/em/hc/c1emhcddfnjoaoqvjqzbu4ch5yw.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里的颜色变化几乎不明显，但这就是重点。它们给每种形式“开放”并给予深度，而不会给旁观者带来太大和不必要的复杂性的压力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果仔细看，可以看到阴影线结构也是噪音的一部分。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/qa/d6/hzqad60iieuv4p1i5n7wizo_n8m.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得注意的是，随着时间的流逝，珀林的简单声音似乎开始变得毫无生气。</font><font style="vertical-align: inherit;">尝试用分形布朗运动进行实验，或者开发自己的杂讯功能来玩。</font><font style="vertical-align: inherit;">泰勒·霍布（Tyler Hobb）的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“流场”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">论文</font><font style="vertical-align: inherit;">是需要深入研究的好东西（Perlin噪声形成了无穷的矢量场，流体场是有用的概括）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">感知度</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回到我们的指导原则，我们记得，为了增加工作的自然性，您需要模拟真实的物理学。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在《守则的本质》中已详细涉及了这个想法，我只是向您推荐而未引用Daniel Schiffman。 Daniel将复杂的物理问题分解为易于消化的部分，从而简化了每个想法的实施。进行创作时，我经常会进行一段时间的物理模拟，并在某个时刻拍摄照片，这成为最终照片。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，在图片“ Sweetening Serum”中，重力会影响球，该球会跳过网格中的每个正方形。重力方向由一个附加的噪声场确定，球留下一个标记。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1s/xd/oq/1sxdoqshw7pvgjmgbti-1thkbaa.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“除尘碗”的核心是对口香糖的模拟。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nj/hk/s5/njhks5phzhcnwk5kr-uvtfum_u0.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对我来说，这些照片还活着。</font><font style="vertical-align: inherit;">难怪，真的。</font><font style="vertical-align: inherit;">它们与我们的指导原则紧密相关：</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于现实对您的工作</font></font><br>
</b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
进行建模当我们专注于在代码中模拟自然过程时，我们会得到更多自然的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结一下，我会说遵循我工作的自然性是我喜欢做的。</font><font style="vertical-align: inherit;">让我的计算机花更多的时间在生成纹理和模拟物理上，这对我来说不是负担，因此最终我得到了更生动的创作。</font><font style="vertical-align: inherit;">我希望本文将成为您尝试自然工作的起点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PS没有代码是有原因的。</font><font style="vertical-align: inherit;">这些想法很笼统，适用于许多语言和开发环境;我不想将任何人赶走，迫使我改用其他东西。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506806/index.html">Android MVP-将Moxy用作帮助程序库的好处</a></li>
<li><a href="../zh-CN506812/index.html">选择Wi-Fi接入点的频道。综合指南</a></li>
<li><a href="../zh-CN506814/index.html">酷炫，无管评论Audio-Technica AT-LPW40WN</a></li>
<li><a href="../zh-CN506816/index.html">装置经理 更新和监控</a></li>
<li><a href="../zh-CN506826/index.html">我们用辐射计自己制造一个闪烁光谱仪</a></li>
<li><a href="../zh-CN506830/index.html">Web应用程序：Micro Frontend Module Federation支持的框架</a></li>
<li><a href="../zh-CN506832/index.html">编译器使用多少个处理器指令？</a></li>
<li><a href="../zh-CN506834/index.html">“最后一个程序。” 人工智能网络系列</a></li>
<li><a href="../zh-CN506838/index.html">从立陶宛到纽约：克格勃致力于情报</a></li>
<li><a href="../zh-CN506842/index.html">RPA：自动发票注册流程。最全面的指南</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>