<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∂ üèÇüèø üå¶Ô∏è Rendering optimization for Mobile üëö üìá ü§∫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello dear readers, lovers and professionals of programming graphics! We bring to your attention a series of articles on optimizing rendering for mobi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rendering optimization for Mobile</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/492874/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello dear readers, lovers and professionals of programming graphics! We bring to your attention a series of articles on optimizing rendering for mobile devices: phones and tablets based on iOS and Android. The cycle will consist of three parts. In the first part, we will examine the features of the popular </font><font style="vertical-align: inherit;">GPU </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tile</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> architecture </font><font style="vertical-align: inherit;">on Mobile </font><font style="vertical-align: inherit;">. In the second, we will go over the main families of GPUs presented in modern devices, and consider their strengths and weaknesses. In the third part, we will get acquainted with the features of shader optimization. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, let's get down to the first part.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The development of video cards on desktops and consoles took place in the absence of significant restrictions on power consumption. With the advent of video cards for mobile devices, engineers were faced with the task of ensuring acceptable performance at comparable desktop resolutions, while the power consumption of such video cards should be 2 orders of magnitude lower.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/4fa/969/51e4fa969a3e5ede3b31064499c33226.png"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The solution was found in a special architecture called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Rendering (TBR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . To a programmer with experience in PC development, when he gets acquainted with mobile development, everything seems familiar: a similar OpenGL ES API is used, the same structure of the graphics pipeline. However, the tile architecture of mobile GPUs is significantly different from that used on the PC / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediate Mode</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> consoles </font><font style="vertical-align: inherit;">. Knowing the strengths and weaknesses of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TBR</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will help you make the right decisions and get great performance with Mobile. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Below is a simplified diagram of a classic graphics pipeline used on PCs and consoles for the third decade.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/67b/5e2/28167b5e2eaa4746ebd1ed45f8aa2dfb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the geometry processing stage, the vertex attributes are read from the GPU video memory. After various transformations </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vertex Shader),</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ready-to-render primitives in the original order (FIFO) are passed to the rasterizer, which divides the primitives into pixels. After that, the step of fragment processing of each pixel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Fragment Shader) is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> carried out </font><font style="vertical-align: inherit;">, and the obtained color values ‚Äã‚Äãare written to the screen buffer, which is also located in the video memory. A feature of the traditional architecture of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúImmediate Mode‚Äù</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is the recording of the result of the Fragment Shader in arbitrary sections of the screen buffer when processing a single </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">draw call</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Thus, for each draw call, access to the entire screen buffer may be required. Working with a large array of memory requires an appropriate bus </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bandwidth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">bandwidth</font></b><font style="vertical-align: inherit;"> ) and is associated with high power consumption. Therefore, mobile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> began to take a different approach. On the tile architecture typical of mobile video cards, rendering is done in a small piece of memory corresponding to the part of the screen - the tile. The small size of the tile (e.g. 16x16 pixels for Mali video cards, 32x32 for PowerVR) allows you to place it directly on the video card chip, which makes the access speed comparable to the speed of access to the shader core registers, i.e. very fast.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/7bf/c65/86d7bfc65e53739ab9be0d5ea1242c0e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, since primitives can fall into arbitrary sections of the screen buffer, and the tile covers only a small part of it, an additional step in the graphics pipeline was required. </font><font style="vertical-align: inherit;">The following is a simplified diagram of how the pipeline works with tile architecture.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/ea5/00c/531ea500c507eb47558676582e20c94c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After processing the vertices and constructing the primitives, the latter, instead of being sent to the fragment pipeline, fall into the so-called </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Here the primitives are distributed by tiles, into the pixels of which they fall. </font><font style="vertical-align: inherit;">After such distribution, which, as a rule, covers all draw calls directed to one </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame Buffer Object</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (aka </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), the tiles are sequentially rendered. </font><font style="vertical-align: inherit;">For each tile, the following sequence of actions is performed:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Loading old </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contents </font><font style="vertical-align: inherit;">from system memory ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render of primitives falling into this tile</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uploading new </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> content </font><font style="vertical-align: inherit;">to system memory ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/20b/74b/9ea20b74b9fb716af30d5e0fa4ee1b34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It should be noted that the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation can be considered as an additional superposition of the ‚Äúfull-screen texture‚Äù without compression. </font><font style="vertical-align: inherit;">If possible, avoid this operation, i.e. </font><font style="vertical-align: inherit;">Do not allow </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to switch </font><font style="vertical-align: inherit;">back and forth. </font><font style="vertical-align: inherit;">If </font><font style="vertical-align: inherit;">all its contents are cleared </font><font style="vertical-align: inherit;">before rendering in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation is not performed. </font><font style="vertical-align: inherit;">However, in order to send the correct signal to the driver, the parameters of such cleaning must meet certain criteria:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Must be disabled </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scissor Rect</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recording in all color channels and alpha should be allowed.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To prevent the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation for the depth buffer and stencil, they also need to be cleaned before the start of rendering. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is also possible to avoid the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation </font><font style="vertical-align: inherit;">for the depth / stencil buffer. </font><font style="vertical-align: inherit;">After all, the contents of these buffers are not displayed in any way on the screen. </font><font style="vertical-align: inherit;">Before the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glSwapBuffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation, </font><b><font style="vertical-align: inherit;">you</font></b><font style="vertical-align: inherit;"> can call </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glDiscardFramebufferEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> or </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glInvalidateFramebuffer</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glDiscardFramebufferEXT (GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are rendering scenarios in which the placement of depth / stencil buffers, as well as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffers in the system memory is not required. For example, if the rendering in the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with the depth buffer is continuous, and the depth information from the previous frame is not used, then the depth buffer does not need to be loaded into tile memory before the start of rendering, or unloaded after completion of the rendering. Therefore, the system memory can not be allocated under the depth buffer. Modern graphics APIs such as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allow you to explicitly set the memory mode for your </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> counterparts </font><font style="vertical-align: inherit;"> &nbsp;( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTLStorageModeMemoryless</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT +</font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of particular note is the implementation of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on tile architectures. The high resolution buffer for the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not leave the tile memory by splitting the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> into more tiles. For example, for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA 2x2, </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16x16</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiles </font><font style="vertical-align: inherit;">will be resolved as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8x8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> during the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation, i.e. In total, it will be necessary to process 4 times more tiles. But additional memory for </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA is</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not required, and due to the rendering in fast tile memory there will be no significant </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bandwidth</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> restrictions </font><b><font style="vertical-align: inherit;">.</font></b><font style="vertical-align: inherit;"> However use</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on tile architecture increases the load on </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which can negatively affect the rendering performance of scenes with a lot of geometry. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Summarizing the above, we present the desired scheme of working with FBO on the tile architecture:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// 1.   ,    auxFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);<font></font>
glDepthMask(GL_TRUE);<font></font>
<span class="hljs-comment">// glClear,     </span><font></font>
glClear(GL_COLOR_BUFFER_BIT |&nbsp;GL_DEPTH_BUFFER_BIT |&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_STENCIL_BUFFER_BIT);<font></font>
<font></font>
renderAuxFBO();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
<span class="hljs-comment">//   /      </span>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
<span class="hljs-comment">// 2.   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
<font></font>
glClear(...);<font></font>
<span class="hljs-comment">//   mainFBO    auxFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you switch to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auxFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rendering </font><font style="vertical-align: inherit;">in the middle of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> formation </font><font style="vertical-align: inherit;">, you can get unnecessary </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load &amp; Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operations, which can significantly increase the frame formation time. </font><font style="vertical-align: inherit;">In our practice, we encountered a slowdown in rendering even in the case of idle FBO settings, i.e. </font><font style="vertical-align: inherit;">without the actual render in them. </font><font style="vertical-align: inherit;">Due to the architecture of the engine, our old circuit looked like this:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   </span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
<span class="hljs-comment">//  auxFBO</span><font></font>
renderAuxFBO();<font></font>
<font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   mainFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the lack of gl calls after the first installation of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , on some devices we got extra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load &amp; Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operations and worse performance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To improve our understanding of </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">overhead</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> from using intermediate </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we measured the time loss for switching full-screen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using a synthetic test. The table shows the time spent on the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation when switching </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> multiple times </font><font style="vertical-align: inherit;">in one frame (the time of one such operation is given). </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operation absent due to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glClear</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, i.e. </font><font style="vertical-align: inherit;">a more favorable scenario was measured. </font><font style="vertical-align: inherit;">The permission used on the device contributed. </font><font style="vertical-align: inherit;">It could more or less correspond to the power of the installed GPU. </font><font style="vertical-align: inherit;">Therefore, these figures give only a general idea of ‚Äã‚Äãhow expensive the switching of targets on mobile video cards of various generations is.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">milliseconds</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">milliseconds</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 320</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 512</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.74</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR G6200</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 615</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-400</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 530</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t720</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-g51</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SXG 544</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t830</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.15</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Based on the obtained data, we can come to the recommendation not to use more than one or two FBO switches per frame, at least for older video cards. If the game has a separate code pass for Low-End devices, it is advisable not to use the FBO change there. However, on the Low-End, the issue of lowering the resolution often becomes relevant. On Android, you can lower the rendering resolution without resorting to using an intermediate FBO by calling </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SurfaceHolder.setFixedSize ():</font></font></b><br>
<br>
<pre><code class="java hljs">surfaceView.getHolder().setFixedSize(...)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This method will not work if the game is rendered through the main </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> application (a typical scheme for working with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">If you use the main </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lower resolution can be set by calling the native function </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANativeWindow_setBuffersGeometry.</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_organization_app_AppNativeActivity_setBufferGeometry</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jobject surface, jint width, jint height)</span>
</span>{<font></font>
ANativeWindow* window = ANativeWindow_fromSurface(env, surface);&nbsp;<font></font>
ANativeWindow_setBuffersGeometry(window, width, height, AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM);&nbsp;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBufferGeometry</span><span class="hljs-params">(Surface surface, <span class="hljs-keyword">int</span> width , <span class="hljs-keyword">int</span> height )</span></span>;&nbsp;<font></font>
...<font></font>
<span class="hljs-comment">//   SurfaceHolder.Callback</span>
<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">surfaceChanged</span><span class="hljs-params">(SurfaceHolder holder, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span>
</span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBufferGeometry(holder.getSurface(), <span class="hljs-number">768</span>, <span class="hljs-number">1366</span>); <span class="hljs-comment">/* ... */</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, we mention the convenient ADB command for controlling selected surface buffers on Android:</font></font><br>
<br>
<pre><code class="plaintext hljs">adb shell dumpsys surfaceflinger
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can get a similar conclusion that allows you to estimate the memory consumption for surface buffers:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/2fe/ea6/5242feea615abe186c6c3538c9d60565.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The screenshot shows the system highlighting 3 buffers for triple buffering the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSurfaceView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> game (highlighted in yellow), as well as 2 buffers for the main </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (highlighted in red). </font><font style="vertical-align: inherit;">In the case of rendering through the main Surface, which is the default scheme when using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the allocation of additional buffers can be avoided.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all for now. </font><font style="vertical-align: inherit;">In the following articles, we will classify mobile GPUs, as well as analyze methods for optimizing shaders for them.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en492862/index.html">15 best Oracle APEX performance tuning tips for developers</a></li>
<li><a href="../en492864/index.html">Can I hack a ship?</a></li>
<li><a href="../en492866/index.html">The book "Machine Learning without words"</a></li>
<li><a href="../en492868/index.html">String optimization in ClickHouse. Yandex Report</a></li>
<li><a href="../en492872/index.html">How to organize remote access and not suffer from hackers</a></li>
<li><a href="../en492878/index.html">Geek slippers: looking for positive in temporary office closures</a></li>
<li><a href="../en492880/index.html">What should we build a smart home?</a></li>
<li><a href="../en492884/index.html">Receiving messages from youtube broadcasts + google authorization in PHP</a></li>
<li><a href="../en492886/index.html">Mass recruitment testers recipe</a></li>
<li><a href="../en492888/index.html">Why you should not use WireGuard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>