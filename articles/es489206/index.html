<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌉 🛫 🥈 Historias de bloqueo con Patroni, o Cómo soltar un clúster PostgreSQL 👾 👏🏻 🧕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="PostgreSQL no tiene alta disponibilidad fuera de la caja. Para lograr HA, debe poner algo, configurarlo, hacer un esfuerzo. Existen varias herramienta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Historias de bloqueo con Patroni, o Cómo soltar un clúster PostgreSQL</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/489206/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL no tiene alta disponibilidad fuera de la caja. Para lograr HA, debe poner algo, configurarlo, hacer un esfuerzo. Existen varias herramientas que pueden ayudar a aumentar la disponibilidad de PostgreSQL, y una de ellas es Patroni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, al poner a Patroni en un entorno de prueba, puede ver qué gran herramienta es y cómo maneja fácilmente nuestros intentos de romper el clúster. Pero en la práctica, en un entorno de producción, no todo sucede siempre de manera tan bella y elegante. Data Egret comenzó a usar Patroni a fines de 2018 y ganó algo de experiencia: cómo diagnosticarlo, configurarlo y cuándo no confiar en el archivador automático. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En HighLoad ++, Alexei Lesovsky describió en detalle, utilizando ejemplos y análisis de registros, los problemas típicos que surgen al trabajar con Patroni y las mejores prácticas para superarlos.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lqh1eJwVPtk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El artículo no: Instrucciones de instalación de Patroni y ejemplos de configuración; </font><font style="vertical-align: inherit;">problemas fuera de Patroni y PostgreSQL; </font><font style="vertical-align: inherit;">historias basadas en las experiencias de otras personas, pero solo aquellos problemas que Data Egret descubrió por sí mismos.</font></font><br>
<a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sobre el orador:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Alexey Lesovsky (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lesovsky</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) comenzó como administrador del sistema (administrador del sistema Linux), trabajó en desarrollo web (administrador de bases de datos PostgreSQL). </font><font style="vertical-align: inherit;">Desde 2014 trabaja en Data Egret. </font><font style="vertical-align: inherit;">Data Egret se dedica a la consultoría en el campo de PostgreSQL, ayuda a muchas compañías a usar PostgreSQL correctamente y, por supuesto, ha adquirido una amplia experiencia en el funcionamiento de la base de datos. </font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El informe en el que se basa este artículo se llama "Historias de fallas de Patroni o Cómo bloquear su clúster PostgreSQL", aquí hay un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enlace a la presentación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de que empieces</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Déjame recordarte qué es Patroni, para qué está destinado y qué puede hacer. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni es una plantilla para construir HA fuera de la caja.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por lo tanto, está escrito en la documentación y, desde mi punto de vista, esta es una aclaración muy correcta. Es decir, Patroni no es una bala de plata que estableció y resolverá todos los problemas. Es necesario hacer esfuerzos para que comience a funcionar y traer beneficios. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni - servicio de agente.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se instala en cada servidor con una base de datos y es una especie de sistema de inicio para PostgreSQL: se inicia, se detiene, se reinicia, cambia la configuración y la topología del clúster. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni almacena el "estado del clúster" en DCS.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para almacenar el estado del clúster, su vista actual, necesita almacenamiento. </font><font style="vertical-align: inherit;">Patroni almacena el estado en un sistema externo: un repositorio de configuración distribuido. </font><font style="vertical-align: inherit;">Esta puede ser una de las opciones: Etcd, Consul, ZooKeeper o Etcd Kubernetes. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni AutoFile está habilitado de forma predeterminada. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obtiene un archivador automático de la caja, inmediatamente después de instalar Patroni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, hay muchas otras cosas, como: mantenimiento de configuraciones, creación de nuevas réplicas, copia de seguridad, etc. </font><font style="vertical-align: inherit;">Pero esta vez permanecerá fuera del alcance del informe.</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El objetivo principal de Patroni es proporcionar un archivador automático confiable.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patroni no tiene que monitorear el equipo, enviar notificaciones, hacer cosas complicadas sobre la posible prevención de accidentes, etc. </font><font style="vertical-align: inherit;">Es necesario que el clúster permanezca operativo y que la aplicación pueda continuar trabajando con la base de datos, independientemente de cualquier cambio en la topología del clúster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero cuando comenzamos a usar Patroni con PostgreSQL, nuestro sistema se vuelve un poco más complicado. </font><font style="vertical-align: inherit;">Ahora, además de la base de datos en sí, cuando falla el maestro o la réplica, Patroni mismo, el almacenamiento distribuido de los estados del clúster o la red pueden fallar. </font><font style="vertical-align: inherit;">Considere todas las opciones a medida que se vuelven más complicadas en términos de lo difícil que es comprender sus causas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 1. DBMS y DCS en el mismo clúster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere el caso más simple: tomamos un clúster de base de datos e implementamos DCS en el mismo clúster. </font><font style="vertical-align: inherit;">Este error común no solo está relacionado con los errores de implementación de PostgreSQL y Patroni. </font><font style="vertical-align: inherit;">Esto es un error en la construcción general de arquitecturas, ya que combina muchos componentes diferentes en un solo lugar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, hubo una conmutación por error. </font><font style="vertical-align: inherit;">Comenzamos a entender lo que pasó. </font><font style="vertical-align: inherit;">Aquí nos interesa saber cuándo ocurrió el feylover, es decir, el </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">momento en que cambió el estado del clúster.</font></font></strong><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuándo ocurrió la conmutación por error?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un faylover no siempre ocurre instantáneamente; puede llevar mucho tiempo. </font><font style="vertical-align: inherit;">Por lo tanto, tiene una hora de inicio y una hora de finalización. </font><font style="vertical-align: inherit;">Todos los eventos se dividen en "antes", "durante" y "después" del feylover. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, cuando ocurrió el feylover, estamos buscando la razón.</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2<font></font>
pgdb-2 patroni: INFO: updated leader lock during promote<font></font>
pgdb-2 patroni: server promoting<font></font>
pgdb-2 patroni: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arriba están los registros estándar de Patroni, donde informa que la función del servidor ha cambiado y la función del asistente se ha movido de otro a este nodo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué ocurrió la conmutación por error?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A continuación, debe comprender qué eventos hicieron que la función del maestro pasara de un nodo a otro, qué sucedió con el maestro anterior.</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: patroni.utils.RetryFailedError: 'Exceeded retry deadline'<font></font>
pgdb-2 patroni: ERROR: Error communicating with DCS<font></font>
pgdb-2 patroni: INFO: demoted self because DCS is not accessible and i was a leader<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, todo es simple: </font></font><code>Error communicating with DCS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- un error al interactuar con el sistema de almacenamiento de configuración. </font><font style="vertical-align: inherit;">El maestro se dio cuenta de que no podía trabajar con DCS y dijo que ya no podía ser maestro y renunció. </font></font><code>demoted self</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habla sobre esto</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué precedió al feylover?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observa los eventos que precedieron al feylover, puede ver las razones que se convirtieron en un problema para que el asistente continúe:</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: ERROR: touch_member<font></font>
                ... python trace <font></font>
pgdb-2 patroni: socket.timeout: timed out <font></font>
pgdb-2 patroni: During handling of the above exception, another exception occurred:<font></font>
                ... python trace <font></font>
pgdb-2 patroni:   raise ReadTimeoutError(self, url, "Read timed out. (read timeout=%s)" % timeout_value) <font></font>
pgdb-2 patroni: urllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='127.0.0.1', port=8500): Read timed out. (read timeout=3.3333333333333335) <font></font>
pgdb-2 patroni: During handling of the above exception, another exception occurred:<font></font>
                ... python trace <font></font>
pgdb-2 patroni:     raise MaxRetryError(_pool, url, error or ResponseError(cause)) <font></font>
pgdb-2 patroni: urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8500): Max retries exceeded with url: /v1/kv/service/pgdb/members/pgdb-2?acquire=19598b72-c0d5-f066-5d24-09c1a9ad61ee&amp;dc=maindb (Caused by ReadTimeoutError("HTTPConnectionPool(host='127.0.0.1', port=8500): Read timed out. (read timeout=3.3333333333333335)",)) <font></font>
pgdb-2 patroni: INFO: no action.  i am the leader with the lock <font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los registros de Patroni muestran muchos errores de tiempo de espera diferentes. </font><font style="vertical-align: inherit;">El Agente Patroni no pudo trabajar con DCS (en este caso, es Consul, puerto = 8500). </font><font style="vertical-align: inherit;">Patroni y la base de datos se ejecutaban en el mismo host, y los servidores de Consul se ejecutaban en el mismo host. </font><font style="vertical-align: inherit;">Habiendo creado la carga en el servidor, también creamos problemas para el servidor Consul, por lo que no podían comunicarse normalmente.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo ha vuelto como estaba</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de un tiempo, cuando la carga disminuyó, nuestro Patroni pudo comunicarse nuevamente con los agentes, todo se reanudó:</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-2 patroni: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2<font></font>
pgdb-2 patroni: INFO: updated leader lock during promote<font></font>
pgdb-2 patroni: server promoting<font></font>
pgdb-2 patroni: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-2 patroni: INFO: Lock owner: pgdb-2; I am pgdb-2</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mismo servidor pgdb-2 nuevamente se convirtió en maestro. </font><font style="vertical-align: inherit;">Hubo un pequeño "tirón": en un tiempo relativamente corto renunció a sí mismo como maestro, y luego volvió a tomarlos sobre sí mismo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto puede considerarse como un falso positivo o como el hecho de que Patroni hizo todo bien.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidimos por nosotros mismos que el problema es que los servidores de Consul están en el mismo hardware que las bases de datos. </font><font style="vertical-align: inherit;">En consecuencia, cualquier carga en la CPU y los discos (solicitud de E / S pesada, archivos temporales, aspiradoras automáticas, migraciones, copias de seguridad, etc.) también afecta la interacción con el clúster Consul. </font><font style="vertical-align: inherit;">Decidimos que esto no debería vivir en el mismo equipo con la base de datos, y asignamos un grupo separado para el Cónsul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como alternativa, puede girar los parámetros </font></font><code>ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>loop_wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>retry_timeout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, intenta debido a su aumento de sobrevivir a los picos de carga a corto plazo. </font><font style="vertical-align: inherit;">Pero si la carga es larga, iremos más allá de estos parámetros y el método no funcionará.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 2. Interrupciones</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segundo problema es similar al primero en que nuevamente tenemos problemas para interactuar con el sistema DCS:</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: ERROR: get_cluster <font></font>
maindb-1 patroni: Traceback (most recent call last):<font></font>
                ... python trace <font></font>
maindb-1 patroni: RetryFailedError: 'Exceeded retry deadline' <font></font>
maindb-1 patroni: ERROR: Error communicating with DCS <font></font>
maindb-1 patroni: INFO: closed patroni connection to the postgresql cluster <font></font>
maindb-1 patroni: INFO: postmaster pid=214121 <font></font>
... <font></font>
... <font></font>
maindb-1 patroni: INFO: demoted self because DCS is not accessible and i was a leader <font></font>
maindb-1 patroni: WARNING: Loop time exceeded, rescheduling immediately.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroni nuevamente dice que no puede interactuar con DCS, por lo que el maestro actual deja de ser un maestro y entra en modo de réplica. </font><font style="vertical-align: inherit;">El viejo maestro se convierte en una réplica:</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: INFO: Lock owner: maindb-2; I am maindb-1 <font></font>
maindb-1 patroni: INFO: does not have lock <font></font>
maindb-1 patroni: INFO: running pg_rewind from maindb-2 <font></font>
maindb-1 patroni: INFO: running pg_rewind from user=postgres host=192.168.11.18 port=5432 ... <font></font>
maindb-1 patroni: servers diverged at WAL location 1FA/A38FF4F8 on timeline 6 <font></font>
maindb-1 patroni: rewinding from last common checkpoint at 1FA/A38FF450 on timeline 6 <font></font>
maindb-1 patroni: INFO: Lock owner: maindb-2; I am maindb-1 <font></font>
maindb-1 patroni: INFO: running pg_rewind from maindb-2 in progress <font></font>
maindb-1 patroni: Done!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí Patroni funciona como debería: se inicia </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para rebobinar el registro de transacciones, luego se conecta al nuevo maestro y ya se pone al día con el nuevo maestro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué precedió al feylover?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encontremos lo primero que precedió al feylover: los errores que lo causaron. </font><font style="vertical-align: inherit;">Los registros de Patroni son convenientes a este respecto: escribe los mismos mensajes con cierto intervalo. </font><font style="vertical-align: inherit;">Puede desplazarlos rápidamente y ver cuándo han cambiado los registros. </font><font style="vertical-align: inherit;">En este punto, comenzaron algunos problemas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En una situación normal, los registros de Patroni se ven así:</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 patroni: INFO: Lock owner: maindb-1; I am maindb-1<font></font>
maindb-1 patroni: INFO: no action. i am the leader with the lock<font></font>
maindb-1 patroni: INFO: Lock owner: maindb-1; I am maindb-1<font></font>
maindb-1 patroni: INFO: no action. i am the leader with the lock</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El propietario del bloqueo se verifica, si cambia, pueden ocurrir eventos a los que Patroni debe responder. En este caso, todo está en orden con nosotros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de desplazarse al lugar donde comenzaron a aparecer los errores, vemos que se produjo un archivador automático. Dado que los errores estaban relacionados con la interacción con DCS, también miramos los registros del Cónsul, lo que sucedió allí. Comparando aproximadamente el tiempo del faylover y el tiempo en los registros del cónsul, vemos que los vecinos del grupo de cónsules comenzaron a dudar de la existencia de otros participantes:</font></font><br>
<br>
<pre><code class="xml hljs">maindb-2 consul[11581]: serf: EventMemberFailed: maindb-1 192.168.11.19<font></font>
maindb-2 consul[11581]: [INFO] serf: EventMemberFailed: maindb-1 192.168.11.19<font></font>
maindb-2 consul[11581]: memberlist: Suspect maindb-1 has failed, no acks received<font></font>
maindb-2 consul[11581]: [INFO] memberlist: Suspect maindb-1 has failed, no acks received</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observa los registros de otros agentes del Cónsul, también muestra que hay un colapso de la red: todos los miembros del grupo Cónsul dudan entre sí. </font><font style="vertical-align: inherit;">Este fue el impulso para el feylover. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si observamos entradas anteriores, veremos que el sistema de Cónsul para el agente PostgreSQL tiene dificultades con la comunicación ( </font></font><code>deadline reached</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>RPC failed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="xml hljs">maindb-1 consul: memberlist: Suspect lbs-4 has failed, no acks received<font></font>
maindb-1 consul: [ERR] yamux: keepalive failed: i/o deadline reached<font></font>
maindb-1 consul: yamux: keepalive failed: i/o deadline reached<font></font>
maindb-1 consul: [ERR] consul: "KVS.List" RPC failed to server 192.168.11.115:8300: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] http: Request GET /v1/kv/service/sam_prod/?recurse=1, error: rpc error making call: EOF from=192.168.11.19<font></font>
maindb-1 consul: [ERR] consul: "KVS.List" RPC failed to server 192.168.11.115:8300: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] agent: Coordinate update error: rpc error making call: EOF<font></font>
maindb-1 consul: [ERR] http: Request GET /v1/kv/service/sam_prod/?recurse=1, error: rpc error making call: EOF from=192.168.11.19</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La respuesta más simple es </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reparar la red</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es fácil aconsejar, pero las circunstancias pueden ser diferentes, y esto no siempre es posible. </font><font style="vertical-align: inherit;">El sistema puede vivir en un centro de datos, donde no podemos influir en el equipo. </font><font style="vertical-align: inherit;">Necesito otras opciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay opciones de solución sin trabajar con una red:</font></font><br>
<br>
<ul>
<li><strong> Consul-</strong> — <code>checks: []</code>.<br>
   ,     .    ,    Consul-    .           .</li>
<li><strong></strong> <code>raft_multiplier</code>.<br>
   Consul-,     5 (      staging-).         Consul-.  -   .</li>
<li><strong></strong> <code>renice -n -10 consul</code>.<br>
        .  renice   .          Consul-,             .</li>
<li><strong>   consul?</strong><br>
Consul-         . Patroni   Consul-    ,     :    - ,  Patroni      .   etcd,     ,    etcd   . Patroni      etcd-.    -  ,     ,   ,     Consul.</li>
<li><strong>  </strong> <code>ttl, loop_wait, retry_timeout</code>.<br>
     ,         .     Patroni       .</li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 3. Pérdida de nodo</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está utilizando Patroni, entonces está familiarizado con el comando patronictl list, que muestra el estado actual del clúster:</font></font><br>
<br>
<pre><code class="xml hljs">$ patronictl list<font></font>
<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
|     Cluster     |          Member         |     Host     |  Role  |  State  | Lag in MB |<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
| patroni_cluster | pg01.dev.zirconus.local | 10.202.1.101 |        | running |    0.0    |<font></font>
| patroni_cluster | pg03.dev.zirconus.local | 10.202.1.103 | Leader | running |    0.0    |<font></font>
+-----------------+-------------------------+--------------+--------+---------+-----------+<font></font>
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primera vista, tal conclusión puede parecer normal: hay un maestro, réplicas, pero no hay retraso de replicación. </font><font style="vertical-align: inherit;">Pero esta imagen es normal exactamente hasta que sepamos que en este grupo debería haber 3 nodos, y no 2.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Por qué ocurrió la conmutación por error?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entendemos que se produjo un archivador automático y luego desapareció una réplica. </font><font style="vertical-align: inherit;">Necesitamos averiguar por qué desapareció y traerla de vuelta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estudiamos los registros nuevamente para comprender por qué se produjo el archivador automático:</font></font><br>
<br>
<pre><code class="xml hljs">pg02 patroni[1425]: ERROR: failed to update leader lock<font></font>
pg02 patroni[1425]: INFO: demoted self because failed to update leader lock in DCS<font></font>
pg02 patroni[1425]: WARNING: Loop time exceeded, rescheduling immediately.<font></font>
pg02 patroni[1425]: INFO: Lock owner: None; I am pg02.dev.zirconus.local<font></font>
pg02 patroni[1425]: INFO: not healthy enough for leader race<font></font>
pg02 patroni[1425]: INFO: starting after demotion in progress</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El maestro pg02 no pudo actualizar la clave maestra </font></font><code>ERROR: failed to update leader lock</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Luego, la segunda réplica de db03 se convirtió en el maestro, todo está en orden aquí:</font></font><br>
<br>
<pre><code class="xml hljs">pg03 patroni[9648]: INFO: promoted self to leader by acquiring session lock<font></font>
pg03 patroni[9648]: server promoting<font></font>
pg03 patroni[9648]: INFO: cleared rewind state after becoming the leader</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué hay del viejo maestro?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pg02, decidiendo convertirse en una réplica, comenzó rebobinando el registro de transacciones. </font><font style="vertical-align: inherit;">Aquí tenemos que mirar los registros de réplica, que no está en el clúster. </font><font style="vertical-align: inherit;">Abra los registros de Patroni y vea que durante el proceso de conexión al clúster, surgió un problema en la etapa </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="xml hljs">pg02 patroni[1425]: INFO: running pg_rewind from pg03<font></font>
pg02 patroni[1425]: INFO: running pg_rewind from user=postgres host=10.202.1.103 port=5432 ...<font></font>
pg02 patroni[1425]: servers diverged at WAL location 33F/68E6AD10 on timeline 28<font></font>
pg02 patroni[1425]: could not open file "/data/pgdb/11/pg_wal/0000001C0000033F00000059": No such file or directory<font></font>
pg02 patroni[1425]: could not find previous WAL record at 33F/59FFE368 pg02 patroni[1425]: Failure, exiting<font></font>
pg02 patroni[1425]: ERROR: Failed to rewind from healty master: pg03<font></font>
pg02 patroni[1425]: WARNING: Postgresql is not running.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para conectarse al clúster, el nodo debe solicitar el registro de transacciones del asistente y capturarlo. </font><font style="vertical-align: inherit;">En este caso, no hay registro de transacciones ( </font></font><code>No such file or directory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y la réplica no puede iniciarse. </font><font style="vertical-align: inherit;">En consecuencia, PostgreSQL se detiene con un error. </font><font style="vertical-align: inherit;">Debe comprender por qué no había registro de transacciones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veamos qué tiene el nuevo maestro en WAL:</font></font><br>
<br>
<pre><code class="xml hljs">LOG: checkpoint complete:<font></font>
wrote 62928 buffers (16.0%); 0 WAL file(s) added, 0 removed, 23 recycled;<font></font>
write=12.872 s, sync=0.020 s, total=13.001 s;<font></font>
sync files=16, longest=0.009 s, average=0.001 s;<font></font>
distance=520220 kB, estimate=520220 kB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resulta que mientras se estaba ejecutando </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se produjo un punto de control y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se cambió el nombre de algunos de los registros de transacciones anteriores</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cuando el viejo maestro intentó conectarse al nuevo maestro y solicitar estos registros, ya se les cambió el nombre, simplemente no existían. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Según la marca de tiempo, el tiempo entre estos eventos es literalmente de 150 ms.</font></font><br>
<br>
<pre><code class="xml hljs">2019-08-26 00:06:11,369 LOG: checkpoint complete<font></font>
2019-08-26 00:06:11,517 INFO: running pg_rewind</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero esto fue suficiente para que la réplica no pueda conectarse y ganar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, utilizamos ranuras de replicación. Esta solución nos pareció buena, aunque en la primera etapa de la operación apagamos las ranuras. Pensamos que si las ranuras acumularan muchos segmentos de pared, el maestro podría caerse. Habiendo sufrido durante un tiempo sin espacios, nos dimos cuenta de que los necesitábamos y los devolvimos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema es que cuando el asistente ingresa al estado de réplica, el asistente elimina las ranuras y los segmentos wal junto con ellos. Para nivelar este problema, aumentamos el parámetro </font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Por defecto, es igual a 8 segmentos, nos </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planteamos </font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a 1.000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Asignamos 16 GB </font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y ahora, al cambiar, siempre tenemos 16 GB de registros de transacciones en todos los nodos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto también es cierto para las tareas de mantenimiento a largo plazo. </font><font style="vertical-align: inherit;">Supongamos que necesitamos actualizar una de las réplicas (software, sistema operativo, algo más) y queremos desactivarla. </font><font style="vertical-align: inherit;">Cuando apagamos la réplica, la ranura también se elimina. </font><font style="vertical-align: inherit;">Si utiliza un valor de parámetro pequeño </font></font><code>wal_keep_segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, durante una larga ausencia de una réplica, solicitará los registros de transacciones que ni siquiera aparezcan en el asistente; entonces la réplica no podrá conectarse. </font><font style="vertical-align: inherit;">Por lo tanto, mantenemos una gran oferta de revistas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 4. Pérdida de datos</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hubo una conmutación por error en una base de producción. </font><font style="vertical-align: inherit;">Verificamos el clúster: todo está en orden, todas las réplicas están en su lugar, no hay retraso de replicación y tampoco hay errores en los registros. </font><font style="vertical-align: inherit;">Pero el equipo del producto informa que no </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hay suficientes datos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en la </font><strong><font style="vertical-align: inherit;">base de datos</font></strong><font style="vertical-align: inherit;"> : están en una fuente, pero no en la base de datos. </font><font style="vertical-align: inherit;">Necesitas entender lo que les pasó. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inmediatamente nos dimos cuenta de que era </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">su mermelada, pero tenemos que averiguar por qué.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Cuándo ocurrió la conmutación por error?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siempre podemos encontrar en los registros cuándo ocurrió el feylover, quién se convirtió en el nuevo maestro, quién era el maestro antes y cuándo quería convertirse en una réplica.</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-1 patroni[17836]: INFO: promoted self to leader by acquiring session lock<font></font>
pgdb-1 patroni[17836]: server promoting<font></font>
pgdb-1 patroni[17836]: INFO: cleared rewind state after becoming the leader<font></font>
pgdb-1 patroni[17836]: INFO: Lock owner: pgdb-1; I am pgdb-1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A partir de los registros, podemos determinar cuántos registros de transacciones se han perdido. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fue así: el viejo asistente se reinició, después de que se reiniciara con la ejecución automática, se lanzó Patroni, que luego lanzó PostgreSQL. </font><font style="vertical-align: inherit;">PostgreSQL decidió convertirse en miembro del clúster Patroni y lanzó un proceso </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que a su vez borró parte de los registros de transacciones, descargó nuevos y se conectó. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroni trabajó exactamente como estaba previsto. </font><font style="vertical-align: inherit;">El grupo se recuperó: había 3 nodos, después del feylover, 3 nodos y se fueron. </font><font style="vertical-align: inherit;">Pero parte de los datos se pierden y debe comprender de qué parte se trata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encuentra en los registros del viejo maestro el momento en que sucedió </font></font><code>pg_rewind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni[4149]: INFO: running pg_rewind from pgdb-1<font></font>
pgdb-2 patroni[4149]: Lock owner: pgdb-1; I am pgdb-2<font></font>
pgdb-2 patroni[4149]: Deregister service pgdb/pgdb-2<font></font>
pgdb-2 patroni[4149]: running pg_rewind from pgdb-1 in progress<font></font>
pgdb-2 patroni[4149]: running pg_rewind from user=replica host=10.10.1.31 port=5432 ...<font></font>
pgdb-2 patroni[4149]: servers diverged at WAL location 0/5AD1BFD8 on timeline 66<font></font>
pgdb-2 patroni[4149]: rewinding from last common checkpoint at 0/59DD1070 on timeline 66<font></font>
pgdb-2 patroni[4149]: Done!</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe encontrar la posición en el registro de transacciones, que detuvo al antiguo maestro.</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-2 patroni[4149]: INFO: Local timeline=66 lsn=0/5BDA8EB8<font></font>
pgdb-2 patroni[4149]: INFO: master_timeline=67<font></font>
...<font></font>
pgdb-2 patroni[4149]: servers diverged at WAL location 0/5AD1BFD8 on timeline 66<font></font>
postgres=# select pg_wal_lsn_diff('0/5BDA8EB8','0/5AD1BFD8');<font></font>
pg_wal_lsn_diff<font></font>
----------------<font></font>
17354464</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, es la marca 0 / 5BDA8EB8. </font><font style="vertical-align: inherit;">La segunda marca, 0 / 5AD1BFD8, es necesaria para encontrar la distancia en la que el antiguo maestro difiere del nuevo. </font><font style="vertical-align: inherit;">Usando la función </font></font><code>pg_wal_lsn_diff </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comparamos estas dos marcas, obtenemos 17 MB. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya sea que haya una gran pérdida de 17 MB de datos, todos deciden por sí mismos. </font><font style="vertical-align: inherit;">Para algunos, esto es insignificante, pero para alguien es inaceptable. </font><font style="vertical-align: inherit;">Cada uno por sí mismo determina individualmente de acuerdo con las necesidades del negocio.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En primer lugar, debe decidir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si el inicio automático de Patroni siempre es necesario después de reiniciar el sistema</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Muy a menudo, deberíamos ir al antiguo maestro, ver qué tan diferente es del estado actual, quizás inspeccionar los segmentos del registro de transacciones. Debe comprender si estos datos se pueden perder o si necesita ejecutar el asistente anterior en modo independiente para extraer los datos. Solo después de eso, decida qué hacer con los datos y conecte este nodo como una réplica a nuestro clúster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, hay un parámetro</font></font><code>maximum_lag_on_failover</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, su valor predeterminado es 1 Mb. Funciona así: si la réplica está 1 MB detrás del retraso de replicación, entonces esta réplica no participa en las elecciones. Si de repente ocurre una conmutación por error, Patroni observa qué réplicas están rezagadas, y aquellas que están rezagadas detrás de una gran cantidad de registros de transacciones no pueden convertirse en maestros. Esta es una buena característica de seguridad que le impide perder demasiados datos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero hay un problema: el retraso de replicación se actualiza en un intervalo determinado, el valor </font></font><code>ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">predeterminado es 30 s. Es muy posible que el valor del retraso de replicación para las réplicas en DCS sea uno, pero de hecho es completamente diferente o no hay ningún retraso. Este no es un valor en tiempo real; no siempre refleja la imagen real y no vale la pena vincularle una lógica compleja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El riesgo de "pérdidas" siempre permanece:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el peor de los casos: </font></font><code>maximum_lag_on_failover + ttl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En el caso promedio: </font></font><code>maximum_lag_on_failover + (loop_wait / 2)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando planea implementar Patroni y evaluar la cantidad de datos que puede perder, considere estas fórmulas para representar aproximadamente posibles pérdidas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La buena noticia es que puede haber una WAL de procesos en segundo plano en las "pérdidas". </font><font style="vertical-align: inherit;">Estos datos se pueden ignorar y perder fácilmente, no hay problema. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Así es como se ven los registros si están configurados </font></font><code>maximum_lag_on_failover</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, se produjo un feylover y debe seleccionar un nuevo asistente:</font></font><br>
<br>
<pre><code class="xml hljs">pgdb-1 patroni[6202]: INFO: Lock owner: None; I am pgdb-1<font></font>
pgdb-1 patroni[6202]: INFO: not healthy enough for leader race<font></font>
pgdb-1 patroni[6202]: INFO: changing primary_conninfo and restarting in progress<font></font>
...<font></font>
pgdb-1 patroni[6202]: INFO: following a different leader because i am not the healthiest node<font></font>
pgdb-1 patroni[6202]: INFO: following a different leader because i am not the healthiest node</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La réplica simplemente ve que ella </font></font><code>not healthy enough for leader race</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es y se niega a participar en la carrera de liderazgo. </font><font style="vertical-align: inherit;">Por lo tanto, simplemente espera a que se seleccione un nuevo asistente para conectarse a él. </font><font style="vertical-align: inherit;">Esta es una medida adicional contra la pérdida de datos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 5. Unidades</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El equipo del producto escribió que la aplicación tiene problemas para trabajar con PostgreSQL. </font><font style="vertical-align: inherit;">Al mismo tiempo, no puede ingresar al maestro, porque no está disponible a través de SSH, pero el archivador automático tampoco ocurre. </font><font style="vertical-align: inherit;">Luego, el host se reinició por la fuerza y, por lo tanto, lanzó el archivador automático. </font><font style="vertical-align: inherit;">Aunque fue posible hacer un feylover manual. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después del reinicio, vamos a ver qué pasó con el maestro. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_1/2u/rj/_12urj0aobgqg0pp2gkkuolhjog.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sabíamos de antemano los problemas con los discos; al monitorear sabíamos dónde cavar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En los registros de PostgreSQL, vemos lo siguiente:</font></font><br>
<br>
<pre><code class="xml hljs">[COMMIT] LOG: duration: 1138.868 ms statement: COMMIT<font></font>
...<font></font>
[] WARNING: autovacuum worker started without a worker entry<font></font>
...<font></font>
[SELECT] LOG: temporary file: path "base/pgsql_tmp/pgsql_tmp11247.983", size 532996096<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la cara están todos los indicadores de problemas con los discos: confirmaciones que duran un segundo, el vacío automático se ejecuta muy largo y extraño, y los archivos temporales en el disco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinamos el sistema dmesg, el registro de mensajes del núcleo, y vimos un problema con uno de los discos:</font></font><br>
<br>
<pre><code class="xml hljs">md/raid10:md2: sde3: rescheduling sector 351273392<font></font>
blk_update_request: I/O error, dev sde, sector 64404728<font></font>
md/raid10:md2: sde3: rescheduling sector 63161592<font></font>
blk_update_request: I/O error, dev sde, sector 64404760<font></font>
...<font></font>
md2 : active raid10 sda3[0] sdc3[2] sdd3[3] sdb3[1] sdh3[7] sdf3[5] sdg3[6]<font></font>
      15623340032 blocks super 1.2 512K chunks 2 near-copies [8/7] [UUUUUUU_]<font></font>
      bitmap: 58/59 pages [232KB], 131072KB chunk</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El subsistema de disco en el servidor era un Raid de software de 8 discos, pero faltaba uno. </font></font><code>sda3[0] sdc3[2] sdd3[3] sdb3[1] sdh3[7] sdf3[5] sdg3[6]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falta la </font><font style="vertical-align: inherit;">línea </font></font><code>sde[4]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Relativamente hablando, un disco se cayó, esto causó problemas de disco, y la aplicación tuvo problemas para trabajar con el clúster PostgreSQL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decisión</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, Patroni no podría ayudar, porque Patroni no tiene la tarea de monitorear el estado del servidor y los discos. </font><font style="vertical-align: inherit;">Durante los problemas, Patroni continuó interactuando con el clúster DCS y no vio ninguna dificultad. </font><font style="vertical-align: inherit;">Para tales situaciones, se necesita monitoreo externo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problema 6. Simulador de clúster</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es uno de los problemas más extraños. </font><font style="vertical-align: inherit;">Lo estudié durante mucho tiempo, releí muchos registros y lo llamé "Simulador de clúster". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema era que el viejo maestro no podía convertirse en una señal normal. </font><font style="vertical-align: inherit;">Patroni lo ejecutó, mostró que este nodo está presente como una réplica, pero al mismo tiempo no era una réplica normal, ahora verá por qué. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo comenzó, como en el caso anterior, con problemas de disco:</font></font><br>
<br>
<pre><code class="xml hljs">14:48:55.601 [COMMIT] LOG: duration: 1478.118 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1290.203 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1778.465 ms statement: COMMIT<font></font>
14:48:56.287 [COMMIT] LOG: duration: 1778.449 ms statement: COMMIT</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hubo conexiones rotas:</font></font><br>
<br>
<pre><code class="xml hljs">14:48:58.078 [idle in transaction] LOG: could not send data to client: Broken pipe<font></font>
14:48:58.078 [idle] LOG: could not send data to client: Broken pipe<font></font>
14:48:58.078 [idle] FATAL: connection to client lost<font></font>
14:48:58.107 [idle in transaction] FATAL: connection to client lost</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Había largas expectativas de una respuesta y bloqueo de diversa gravedad:</font></font><br>
<br>
<pre><code class="xml hljs">14:49:26.929 [UPDATE waiting] LOG: process 4298 acquired ExclusiveLock on tuple (2,10) of relation 52082 of database 50587 after 52487.463 ms<font></font>
14:49:26.929 [UPDATE waiting] STATEMENT: UPDATE sessions SET lastaccess='1565005714' WHERE sessionid=...<font></font>
14:49:27.929 [UPDATE waiting] LOG: process 4298 still waiting for ShareLock on transaction 364118337 after 1000.088 ms<font></font>
14:49:27.929 [UPDATE waiting] DETAIL: Process holding the lock: 4294. Wait queue: 4298.</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, hay problemas obvios con los discos, incluidos los archivos temporales nuevamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero lo más misterioso para mí: voló </font></font><code>immediate shutdown request</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="xml hljs">14:49:34.102 MSK 5335 @ from [] LOG: received immediate shutdown request<font></font>
14:49:34.689 [authentication] WARNING: terminating connection because of crash of another server process<font></font>
14:49:34.689 [authentication] DETAIL: The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQL tiene tres modos de apagado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agraciado cuando esperamos que todos los clientes se desconecten solos.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rápido, cuando les decimos a los clientes que se desconecten, porque vamos a cerrar.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inmediato, que no le dice a los clientes que es necesario desconectarse, sino que simplemente lo apaga y envía un mensaje RST a todos los clientes (señal TCP de que la conexión se interrumpió).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los procesos en segundo plano de PostgreSQL no se envían señales de solicitud de apagado inmediato, sino que solo responden a ellos. </font><font style="vertical-align: inherit;">Este es un reinicio de emergencia, y quién lo envió no está claro. </font><font style="vertical-align: inherit;">Si lo fuera </font></font><code>kill -9</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lo vería en los registros, pero no estaba allí. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comprendiendo más, vi que Patroni no escribió en el registro durante bastante tiempo, simplemente no hubo mensajes durante 54 segundos. </font><font style="vertical-align: inherit;">Durante este tiempo, una de las réplicas se hizo "promocionar" y se produjo un archivador automático:</font></font><br>
<br>
<pre><code class="xml hljs">pgsql03 patroni: 14:48:25,000 INFO: Lock owner: pgsql03; I am pgsql03 <font></font>
pgsql03 patroni: 14:48:25,013 INFO: no action.  i am the leader with the lock <font></font>
pgsql03 patroni: 14:48:37,159 INFO: Lock owner: pgsql03; I am pgsql03 <font></font>
pgsql03 patroni: 14:49:31,155 WARNING: Exception hened during processing of request from 10.1.0.12 <font></font>
pgsql03 patroni: 14:49:31,297 WARNING: Exception hened during processing of request from 10.1.0.11 <font></font>
pgsql03 patroni: 14:49:31,298 WARNING: Exception hened during processing of request from 10.1.0.11</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroni volvió a funcionar perfectamente aquí, el viejo maestro no estaba disponible, por lo que comenzó la elección de un nuevo maestro.</font></font><br>
<br>
<pre><code class="xml hljs">pgsql01 patroni: 14:48:57,136 INFO: promoted self to leader by acquiring session lock<font></font>
pgsql01 patroni: server promoting<font></font>
pgsql01 patroni: 14:48:57,214 INFO: cleared rewind state after becoming the leader<font></font>
pgsql01 patroni: 14:49:05,013 INFO: Lock owner: pgsql01; I am pgsql01<font></font>
pgsql01 patroni: 14:49:05,023 INFO: updated leader lock during promote</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pgsql01 se convirtió en el nuevo líder, y solo hubo problemas con la segunda réplica. </font><font style="vertical-align: inherit;">Honestamente trató de reconfigurar:</font></font><br>
<br>
<pre><code class="xml hljs">pgsql02 patroni: 14:48:57,124 INFO: Could not take out TTL lock <font></font>
pgsql02 patroni: 14:48:57,137 INFO: following new leader after trying and failing to obtain lock <font></font>
pgsql02 patroni: 14:49:05,014 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:05,025 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:15,011 INFO: Lock owner: pgsql01; I am pgsql02<font></font>
pgsql02 patroni: 14:49:15,014 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:25,011 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:25,014 INFO: changing primary_conninfo and restarting in progress <font></font>
pgsql02 patroni: 14:49:35,011 INFO: Lock owner: pgsql01; I am pgsql02 <font></font>
pgsql02 patroni: 14:49:35,014 INFO: changing primary_conninfo and restarting in progress</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intentó cambiar recovery.conf, reiniciar PostgreSQL, conectarse al nuevo asistente. </font><font style="vertical-align: inherit;">Cada 10 segundos hay mensajes que está intentando, pero no puede. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mientras tanto, la misma señal de apagado inmediato voló hacia el viejo maestro. </font><font style="vertical-align: inherit;">El asistente inició un reinicio de emergencia, la recuperación también se detiene. </font><font style="vertical-align: inherit;">La réplica no se puede conectar al maestro porque está en modo de apagado.</font></font><br>
<br>
<pre><code class="xml hljs">14:49:34.293 [idle] LOG:  received replication command: IDENTIFY_SYSTEM <font></font>
WARNING:  terminating connection because of crash of another server process <font></font>
DETAIL:  The postmaster has commanded this server process to roll back the current transaction and exit, because another server process exited abnormally and possibly corrupted shared memory. <font></font>
14:49:35.232 FATAL:  could not receive data from WAL stream: server closed the connection unexpectedly             <font></font>
        This probably means the server terminated abnormally <font></font>
        before or while processing the request. <font></font>
14:49:35.232 LOG:  record with incorrect prev-link 142D46/315602C at 14CF/CF38C160 <font></font>
14:49:35.305 FATAL: could not connect to the primary server: FATAL: the database system is shutting down <font></font>
14:49:40.241 FATAL: could not connect to the primary server: FATAL: the database system is shutting down</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En algún momento, la réplica funcionó, pero la réplica no comenzó.</font></font><br>
<br>
<pre><code class="xml hljs">14:50:14.024 [] LOG:  record with incorrect prev-link 142D46/315602C at 14CF/CF38C160 <font></font>
14:50:14.028 [] LOG:  fetching timeline history file for timeline 72 from primary server <font></font>
14:50:14.104 [] FATAL:  could not start WAL streaming: ERROR:  requested starting point 14CF/CF000000 on timeline 71 is not in this server's history        <font></font>
DETAIL:  This server's history forked from timeline 71 at 14CF/CEC32E40. <font></font>
14:50:14.104 [] LOG:  new timeline 72 forked off current database system timeline 71 before current recovery point 14CF/CF38C160</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tengo una sola hipótesis: en recovery.conf era la dirección del viejo maestro. </font><font style="vertical-align: inherit;">Cuando ya apareció un nuevo maestro, la segunda réplica intentó conectarse al viejo maestro. </font><font style="vertical-align: inherit;">Cuando Patroni comenzó en la segunda réplica, el nodo se inició, pero no pudo conectarse a través de la replicación. </font><font style="vertical-align: inherit;">Se formó un retraso de replicación que se parecía a esto:</font></font><br>
<br>
<pre><code class="xml hljs">+-----------------+----------+--------------+--------+---------+-----------+<font></font>
|     Cluster     |  Member  |     Host     |  Role  |  State  | Lag in MB |<font></font>
+-----------------+----------+--------------+--------+---------+-----------+<font></font>
| patroni_cluster |  pgsql01 | 10.2.200.151 | Leader | running |       0.0 |<font></font>
| patroni_cluster |  pgsql02 | 10.2.200.152 |        | running |    9153.0 |<font></font>
| patroni_cluster |  pgsql03 | 10.2.200.153 |        | running |       0.0 |<font></font>
+-----------------+----------+--------------+--------+---------+-----------+</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, los tres nodos estaban en su lugar, pero el segundo nodo estaba detrás. </font><font style="vertical-align: inherit;">La replicación no pudo comenzar porque los registros de transacciones eran diferentes. </font><font style="vertical-align: inherit;">Los registros de transacciones ofrecidos por el asistente, indicados en recovery.conf, simplemente no se ajustaban al nodo actual. </font><font style="vertical-align: inherit;">PostgreSQL reportó un error cada 5 segundos</font></font><br>
<br>
<pre><code class="xml hljs">14:50:44.143 FATAL:  could not start WAL streaming: ERROR:  requested starting point 14CF/CF000000 on timeline 71 is not in this server's history        <font></font>
         DETAIL:  This server's history forked from timeline 71 at 14CF/CEC32E40. <font></font>
14:50:44.143 LOG:  new timeline 72 forked off current database system timeline 71 before current recovery point 14CF/ CF38C160</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí cometí un error y no probé mi hipótesis de que nos estamos conectando con el maestro equivocado. </font><font style="vertical-align: inherit;">Acabo de reiniciar Patroni en la réplica. </font><font style="vertical-align: inherit;">Honestamente, ya le puse fin y pensé que tendría que rehacerlo, pero aun así decidí intentar reiniciarlo.</font></font><br>
<br>
<pre><code class="xml hljs">15:14:13.511 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:14:13.511 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La recuperación comenzó, e incluso la base de datos abierta, estaba lista para aceptar la conexión, comenzó la replicación:</font></font><br>
<br>
<pre><code class="xml hljs">15:14:17.072 LOG: record with incorrect prev-link 142D46/315602C at 14CF/CF38C160<font></font>
15:14:17.077 LOG: started streaming WAL from primary at 14CF/CF000000 on timeline 72<font></font>
15:14:17.536 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero un minuto después se cayó con un error </font></font><code>terminating walreceiver process due to administrator command</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: la réplica decía que los registros de transacciones no eran adecuados para ella.</font></font><br>
<br>
<pre><code class="xml hljs">15:15:27.823 FATAL: terminating walreceiver process due to administrator command<font></font>
15:15:27.895 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1<font></font>
15:15:27.895 LOG: invalid record length at 14CF/CF38C160: wanted 24, got 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y no reinicié PostgreSQL, pero fue Patroni el que se reinició con la esperanza de que lanzara mágicamente la base de datos. </font><font style="vertical-align: inherit;">La replicación comenzó nuevamente, pero la base de datos se abrió en el mismo lugar:</font></font><br>
<br>
<pre><code class="xml hljs">15:17:33.553 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:17:33.554 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las marcas en el registro de transacciones eran diferentes, eran diferentes que en el intento de lanzamiento anterior; la posición del registro de transacciones era anterior:</font></font><br>
<br>
<pre><code class="xml hljs">15:17:37.299 LOG: invalid contrecord length 5913 at 14CF/CEFFF7B0<font></font>
15:17:37.304 LOG: started streaming WAL from primary at 14CF/CE000000 on timeline 72</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La replicación se detuvo nuevamente, y el mensaje de error fue diferente y nuevamente no muy informativo:</font></font><br>
<br>
<pre><code class="xml hljs">15:18:12.208 FATAL: terminating walreceiver process due to administrator command<font></font>
15:18:12.240 LOG: record with incorrect prev-link 60995000/589DF000 at 14CF/CEFFF7B0<font></font>
15:18:12.240 LOG: record with incorrect prev-link 60995000/589DF000 at 14CF/CEFFF7B0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para el experimento, reiniciado nuevamente, la base se abrió en el mismo lugar:</font></font><br>
<br>
<pre><code class="xml hljs">15:21:25.135 LOG: consistent recovery state reached at 14CF/A3F657B0<font></font>
15:21:25.135 LOG: database system is ready to accept read only connections</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces se me ocurrió la idea: que si reinicio PostgreSQL, en este punto del asistente actual, haré un punto de control para mover el punto en el registro de transacciones un poco más adelante y la recuperación comenzará en otro momento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lanzó Patroni, hizo un par de puntos de control en el maestro, un par de puntos de reinicio en la réplica cuando se abrió:</font></font><br>
<br>
<pre><code class="xml hljs">15:22:43.727 LOG: invalid record length at 14D1/BCF3610: wanted 24, got 0<font></font>
15:22:43.731 LOG: started streaming WAL from primary at 14D1/B000000 on timeline 72</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Funcionó: la replicación comenzó desde un lugar diferente y ya no se rompió. </font><font style="vertical-align: inherit;">Pero para mí este es uno de los problemas más misteriosos sobre los que todavía me estoy estrujando el cerebro. </font><font style="vertical-align: inherit;">Especialmente esa extraña solicitud de cierre inmediato. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De esto podemos concluir: Patroni puede funcionar según lo planeado y sin errores, pero esto no es una garantía absoluta de que todo esté realmente en orden. </font><font style="vertical-align: inherit;">Después del feylover, siempre debe verificar que todo esté bien con el clúster: la cantidad correcta de réplicas, sin retraso de replicación.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resumen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a estos y muchos otros problemas similares, formulé recomendaciones generales que le aconsejo que tenga en cuenta al operar Patroni.</font></font><br>
<br>
<blockquote><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuando usa Patroni, debe tener monitoreo. </font><font style="vertical-align: inherit;">Siempre necesita saber cuándo se produjo un archivo automático, porque si no sabe que tiene un archivo automático, no controla el clúster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&nbsp;Después de cada feylover siempre verifique un clúster. </font><font style="vertical-align: inherit;">Debe asegurarse de que: las réplicas sean siempre el número actual; </font><font style="vertical-align: inherit;">sin retraso de replicación; </font><font style="vertical-align: inherit;">no hay errores en los registros relacionados con la replicación de transmisión, con Patroni, con el sistema DCS.</font></font></li>
</ul></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Patroni es una muy buena herramienta, pero no importa cómo diga que no es una bala de plata. </font><font style="vertical-align: inherit;">La automatización puede funcionar con éxito, pero al mismo tiempo, los objetos de automatización pueden estar en un estado de trabajo medio. </font><font style="vertical-align: inherit;">De todos modos, debe tener una idea de cómo funcionan PostgreSQL y la replicación, cómo Patroni administra PostgreSQL y cómo se garantiza la interacción entre los nodos. </font><font style="vertical-align: inherit;">Esto es necesario para poder reparar los problemas que surgen con sus manos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pasos de diagnóstico</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dio la casualidad de que trabajamos con diferentes clientes, en su mayor parte no tienen una pila ELK, y debe ordenar los registros abriendo 2 pestañas y 6 consolas: en una pestaña Patroni para cada nodo, en el otro: registros Consul o PostgreSQL. </font><font style="vertical-align: inherit;">Diagnosticar todo esto es difícil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He desarrollado el siguiente enfoque. </font><font style="vertical-align: inherit;">Siempre miro cuando se produce una conmutación por error. </font><font style="vertical-align: inherit;">Para mí es una especie de cuenca hidrográfica. </font><font style="vertical-align: inherit;">Miro lo que sucedió antes, durante y después de la fiebre. </font><font style="vertical-align: inherit;">La conmutación por error tiene dos marcas de tiempo: inicio y fin. </font><font style="vertical-align: inherit;">En los registros, miro lo que precedió al feylover, es decir, estoy buscando razones. </font><font style="vertical-align: inherit;">Esto proporciona una comprensión de la imagen de lo que sucedió y lo que se puede hacer en el futuro para que el feylover no ocurra en las mismas circunstancias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esto, miro:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En primer lugar, los registros de Patroni.</font></font></li>
<li>  PostgreSQL   DCS    ,     Patroni.</li>
<li>  —     ,    .</li>
</ul><br>
<h3></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay muchos otros productos para el archivador automático: stolon, repmgr, pg_auto_failover, PAF. Probé las 4 herramientas y, en mi opinión, Patroni es la mejor que hay en el mercado hoy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Recomiendo Patroni? Definitivamente, sí, porque me gusta Patroni, creo que aprendí a cocinarlo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si está interesado en ver qué otros problemas hay con Patroni, además de los descritos en el artículo, siempre puede ir a la página </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/zalando/patroni/issues</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Hay muchas historias diferentes. A pesar de que la mitad de ellos son de usuarios analfabetos que hacen preguntas estúpidas sin molestarse en molestarse con una simple búsqueda, también se discuten problemas interesantes allí y, como resultado de las discusiones, se abren tareas para corregir errores si es necesario.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias a Zalando por desarrollar este proyecto, así como a las dos personas que comenzaron a trabajar en este producto: Alexander Kukushkin y Alexey Klyukin. Muchas gracias a todos los contribuyentes de Patroni. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Después de este informe, grabamos una breve entrevista en la que Alex intentó incluir su informe en un consejo y le dijimos por qué participar y hablar en las conferencias. Toma las armas y ven a comprobar el enfoque en Saint HighLoad ++.</font></font></i><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/lnw02pCpgRw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<blockquote> HighLoad++   6-7 .      ,    .          ,        ( ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="> </a>).      -  <strong></strong>     ,  ,     ,     .<br>
<br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saint HighLoad++</a>!    ,  ,      PostgreSQL:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>,     PostgreSQL    JSON    ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>   PostgreSQL 13,  ;   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="></a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es489194/index.html">Cómo OpenShift está cambiando la estructura organizativa de una organización de TI. La evolución de los modelos organizacionales al pasar a PaaS</a></li>
<li><a href="../es489196/index.html">Humo Mágico: Microcontroladores vs. Reguladores Lineales</a></li>
<li><a href="../es489198/index.html">Cómo no dispararte en el pie con Liquibase</a></li>
<li><a href="../es489200/index.html">Qué startups está buscando Y Combinator en 2020</a></li>
<li><a href="../es489204/index.html">Una mirada al interior de la fiabilidad de los servicios de Facebook</a></li>
<li><a href="../es489210/index.html">Prueba de rendimiento del código de Linux con ejemplos</a></li>
<li><a href="../es489212/index.html">1C-Bitrix evita la cancelación de la suscripción al boletín por el requisito de enviar sus datos personales</a></li>
<li><a href="../es489214/index.html">Enfoque moderno para probar la localización en iOS</a></li>
<li><a href="../es489218/index.html">Es ingenuo. Super: código y arquitectura de un juego simple</a></li>
<li><a href="../es489226/index.html">Métodos para optimizar consultas LINQ en C # .NET</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>