<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💐 ☸️ 🏕️ 使用递归神经网络的时间序列预测 🧓🏽 ➗ 🤪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在普遍自我隔离的背景下进行远程操作会导致非常严重的后果。和情感倦怠-不管走到哪里，它毕竟离屋顶都不远。在这方面，他和许多人一样，试图通过分配时间安排其他课程来“镇定”自己，并开始将最有趣的文章从英语翻译成俄语：“您将机器学习带给大众！”。如果您对俄语读者有关于语义内容和此文本翻译的建议，请参加讨论。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>使用递归神经网络的时间序列预测</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495884/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在普遍自我隔离的背景下进行远程操作会导致非常严重的后果。和情感倦怠-不管走到哪里，它毕竟离屋顶都不远。在这方面，他和许多人一样，试图通过分配时间安排其他课程来“镇定”自己，并开始将最有趣的文章从英语翻译成俄语：“您将</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器学习</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带给大众！”。如果您对俄语读者有关于语义内容和此文本翻译的建议，请参加讨论。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3d7/fe4/946/3d7fe49466cad76814b37e73ec1bc49a.jpg" alt="图片"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，这是</font><font style="vertical-align: inherit;">来自tensorflow手册部分</font><font style="vertical-align: inherit;">的</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间序列预测</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面的翻译</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">link</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我所添加的内容以及翻译插图旨在帮助理解ML和计量经济学中最有趣的领域之一，即预测时间序列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
翻译前的小介绍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该手册是对基于一维时间序列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（单变量时间序列）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和多元时间序列</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（多变量时间序列）的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">气温预测的描述</font><font style="vertical-align: inherit;">。对于每个部分，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入数据</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该做相应的准备。考虑到本指南中考虑的气象数据集，分离如下所示：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/8fa/31a/a75/8fa31aa7531d8589dcee2ae93454a430.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于有关</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取</font><font style="vertical-align: inherit;">什么和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取</font><font style="vertical-align: inherit;">什么的问题</font><font style="vertical-align: inherit;">，即如何为有监督训练的课程准备数据的问题，从以下插图中将显而易见。我只注意到用于一维和多维时间序列的目标向量（Y）的形成是相同的：目标向量是根据符号</font><i><font style="vertical-align: inherit;">T（degC）进行</font></i><font style="vertical-align: inherit;">编译的</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（气温）。它们之间的差异被“埋没”在形成一组输入到模型输入的特征中：对于预测未来温度的一维时间序列，输入矢量（X）包含一个特征：实际上是气温；并且对于多维-大于一个：除了空气温度外，在本指南的示例中还使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p（mbar）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（大气压）和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rho（g / m ** 3）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（湿度）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，从使用多维输入的角度来看，一个温度预测的例子看起来很浅，令人信服：对于温度预测，最相关的符号是温度。但是，绝对不是这样：为了对空气温度进行定性预测，必须考虑许多因素，包括地球表面的空气摩擦等。另外，在实践中，有些事情远非显而易见，目标向量可能是大杂烩（或罗宋汤）的形式。在这方面，探索性的数据分析以及为后续形成多维输入而选择最相关的特征是唯一正确的决定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，下面介绍了手册的翻译。附加文本将以</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">斜体显示</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间序列预测</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本指南是使用递归神经网络（RNS，来自英语</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归神经网络，RNN</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font><font style="vertical-align: inherit;">时间序列预测的简介</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它由两部分组成：第一部分描述基于一维时间序列的气温预测，第二部分基于多维时间序列。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<font></font>
<font></font>
mpl.rcParams[<span class="hljs-string">'figure.figsize'</span>] = (<span class="hljs-number">8</span>, <span class="hljs-number">6</span>)<font></font>
mpl.rcParams[<span class="hljs-string">'axes.grid'</span>] = <span class="hljs-literal">False</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一组气象数据</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">生物地球化学研究所的</font></a><font style="vertical-align: inherit;">水文</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">气象台上</font></a><font style="vertical-align: inherit;">记录</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的人工使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的气象数据时间序列的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有示例</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">均以 </font><font style="vertical-align: inherit;">马克斯·普朗克</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此数据集包括自2003年以来每10分钟进行的14种不同气象指标的测量（例如气温，大气压，湿度）。</font><font style="vertical-align: inherit;">为了节省时间和内存使用量，本手册将使用2009年至2016年的数据。</font><font style="vertical-align: inherit;">数据集的这一部分是由FrançoisChollet为他的书《</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python深度学习》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">准备的</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">zip_path = tf.keras.utils.get_file(<font></font>
    origin=<span class="hljs-string">'https://storage.googleapis.com/tensorflow/tf-keras-datasets/jena_climate_2009_2016.csv.zip'</span>,<font></font>
    fname=<span class="hljs-string">'jena_climate_2009_2016.csv.zip'</span>,<font></font>
    extract=<span class="hljs-literal">True</span>)<font></font>
csv_path, _ = os.path.splitext(zip_path)<font></font>
</code></pre><br>
<pre><code class="python hljs">df = pd.read_csv(csv_path)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看我们有什么。</font></font><br>
<br>
<pre><code class="python hljs">df.head()
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/d5d/bfa/539/d5dbfa539de3da5ca04103b2db380a70.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
观察记录周期为10分钟的事实可以通过上表验证。因此，在一小时内您将获得6个观测值。反过来，每天会收集144个（6x24）观测值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设您要预测温度，该温度将在未来6小时内出现。您根据一定时期内的数据进行此预测：例如，您决定使用5天的观察时间。因此，要训练模型，必须创建一个包含最后720个（5x144）观测值的时间间隔（由于可能有不同的配置，因此该数据集是进行实验的良好基础）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的函数返回上述训练模型的时间间隔。争论</font></font><code>history_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是最后一个时间间隔的大小，</font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-一个参数，确定模型应该学会预测的未来时间。</font><font style="vertical-align: inherit;">换句话说，</font></font><code>target_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是需要预测的目标向量。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">univariate_data</span>(<span class="hljs-params">dataset, start_index, end_index, history_size, target_size</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i)<font></font>
    <span class="hljs-comment"># Reshape data from (history_size,) to (history_size, 1)</span>
    data.append(np.reshape(dataset[indices], (history_size, <span class="hljs-number">1</span>)))<font></font>
    labels.append(dataset[i+target_size])<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本手册的两个部分中，前300,000行数据都将用于训练模型，其余的行将用于验证（验证）模型。</font><font style="vertical-align: inherit;">在这种情况下，培训数据量约为2100天。</font></font><br>
<br>
<pre><code class="python hljs">TRAIN_SPLIT = <span class="hljs-number">300000</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为确保结果可重复，设置了种子功能。</font></font><br>
<br>
<pre><code class="python hljs">tf.random.set_seed(<span class="hljs-number">13</span>)
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分。基于一维时间序列的预测</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一部分中，您将仅使用一个属性（温度）训练模型。</font><font style="vertical-align: inherit;">经过训练的模型将用于预测未来的温度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们仅从数据集中提取温度。</font></font><br>
<br>
<pre><code class="python hljs">uni_data = df[<span class="hljs-string">'T (degC)'</span>]<font></font>
uni_data.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
uni_data.head()<font></font>
</code></pre><br>
<code>Date Time<br>
01.01.2009 00:10:00 -8.02<br>
01.01.2009 00:20:00 -8.41<br>
01.01.2009 00:30:00 -8.51<br>
01.01.2009 00:40:00 -8.31<br>
01.01.2009 00:50:00 -8.27<br>
Name: T (degC), dtype: float64<br>
</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看这些数据如何随时间变化。</font></font><br>
<br>
<pre><code class="python hljs">uni_data.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/208/b35/242/208b35242d3ce1ed30bd25d12d956703.jpg" alt="图片"><br>
<br>
<pre><code class="python hljs">uni_data = uni_data.values
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在训练人工神经网络（以下简称ANN）之前，重要的一步是数据缩放。</font><font style="vertical-align: inherit;">进行缩放的常见方法之一是标准化（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardization</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），方法是减去平均值并除以每个特性的标准偏差。</font><font style="vertical-align: inherit;">您也可以使用将</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">tf.keras.utils.normalize</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值缩放到[0,1]范围</font><font style="vertical-align: inherit;">的方法</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：只能使用培训数据进行标准化。</font></font><br>
<br>
<pre><code class="python hljs">uni_train_mean = uni_data[:TRAIN_SPLIT].mean()<font></font>
uni_train_std = uni_data[:TRAIN_SPLIT].std()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们执行数据标准化。</font></font><br>
<br>
<pre><code class="python hljs">uni_data = (uni_data-uni_train_mean)/uni_train_std
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，使用一维输入为模型准备数据。</font><font style="vertical-align: inherit;">记录的最后20个温度观测值将输入到模型的入口，并且必须训练模型以预测下一步的温度。</font></font><br>
<br>
<pre><code class="python hljs">univariate_past_history = <span class="hljs-number">20</span>
univariate_future_target = <span class="hljs-number">0</span><font></font>
<font></font>
x_train_uni, y_train_uni = univariate_data(uni_data, <span class="hljs-number">0</span>, TRAIN_SPLIT,<font></font>
                                           univariate_past_history,<font></font>
                                           univariate_future_target)<font></font>
x_val_uni, y_val_uni = univariate_data(uni_data, TRAIN_SPLIT, <span class="hljs-literal">None</span>,<font></font>
                                       univariate_past_history,<font></font>
                                       univariate_future_target)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
函数应用的结果</font></font><code>univariate_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history'</span>)
<span class="hljs-keyword">print</span> (x_train_uni[<span class="hljs-number">0</span>])
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict'</span>)
<span class="hljs-keyword">print</span> (y_train_uni[<span class="hljs-number">0</span>])
</code></pre><br>
<code>Single window of past history<br>
[[-1.99766294]<br>
 [-2.04281897]<br>
 [-2.05439744]<br>
 [-2.0312405 ]<br>
 [-2.02660912]<br>
 [-2.00113649]<br>
 [-1.95134907]<br>
 [-1.95134907]<br>
 [-1.98492663]<br>
 [-2.04513467]<br>
 [-2.08334362]<br>
 [-2.09723778]<br>
 [-2.09376424]<br>
 [-2.09144854]<br>
 [-2.07176515]<br>
 [-2.07176515]<br>
 [-2.07639653]<br>
 [-2.08913285]<br>
 [-2.09260639]<br>
 [-2.10418486]]<br>
<br>
Target temperature to predict<br>
-2.1041848598100876<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外：下图示意性地显示了为具有一维输入的模型准备数据（为方便起见，在此图和后续图中，数据在标准化之前以“原始”形式显示，并且也没有“日期时间”属性作为索引）：</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fa0/d0f/530/fa0d0f530b3496324425eeb5e52baff7.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
现在，数据经过适当准备，请考虑一个具体示例。</font><font style="vertical-align: inherit;">传输到ANN的信息以蓝色突出显示，红叉表示ANN应该预测的未来值。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_time_steps</span>(<span class="hljs-params">length</span>):</span>
  <span class="hljs-keyword">return</span> list(range(-length, <span class="hljs-number">0</span>))
</code></pre><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_plot</span>(<span class="hljs-params">plot_data, delta, title</span>):</span>
  labels = [<span class="hljs-string">'History'</span>, <span class="hljs-string">'True Future'</span>, <span class="hljs-string">'Model Prediction'</span>]<font></font>
  marker = [<span class="hljs-string">'.-'</span>, <span class="hljs-string">'rx'</span>, <span class="hljs-string">'go'</span>]<font></font>
  time_steps = create_time_steps(plot_data[<span class="hljs-number">0</span>].shape[<span class="hljs-number">0</span>])
  <span class="hljs-keyword">if</span> delta:<font></font>
    future = delta<font></font>
  <span class="hljs-keyword">else</span>:<font></font>
    future = <span class="hljs-number">0</span><font></font>
<font></font>
  plt.title(title)<font></font>
  <span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> enumerate(plot_data):
    <span class="hljs-keyword">if</span> i:<font></font>
      plt.plot(future, plot_data[i], marker[i], markersize=<span class="hljs-number">10</span>,<font></font>
               label=labels[i])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      plt.plot(time_steps, plot_data[i].flatten(), marker[i], label=labels[i])<font></font>
  plt.legend()<font></font>
  plt.xlim([time_steps[<span class="hljs-number">0</span>], (future+<span class="hljs-number">5</span>)*<span class="hljs-number">2</span>])<font></font>
  plt.xlabel(<span class="hljs-string">'Time-Step'</span>)
  <span class="hljs-keyword">return</span> plt
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Sample Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/589/38c/574/58938c5740abfb08ed0074a1233f512f.jpg" alt="图片"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本解决方案（不涉及机器学习）</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在开始模型训练之前，我们将安装一个简单的基本解决方案（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基线</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。它包含以下内容：对于给定的输入向量，基本求解方法“扫描”整个历史记录，并预测下一个值作为最后20个观察值的平均值。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">baseline</span>(<span class="hljs-params">history</span>):</span>
  <span class="hljs-keyword">return</span> np.mean(history)
</code></pre><br>
<pre><code class="python hljs">show_plot([x_train_uni[<span class="hljs-number">0</span>], y_train_uni[<span class="hljs-number">0</span>], baseline(x_train_uni[<span class="hljs-number">0</span>])], <span class="hljs-number">0</span>,
           <span class="hljs-string">'Baseline Prediction Example'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/bed/941/0ef/bed9410ef6b96ad25ab68a0a3ebac05a.jpg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看是否可以使用递归神经网络超越“平均”的结果。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">递归神经网络</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
递归神经网络（RNS）是一种非常适合解决时间序列问题的ANN。 RNS逐步处理数据的时间序列，对数据元素进行排序，并保留通过处理之前的元素而获得的内部状态。您可以在以下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指南中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到有关RNS的更多信息</font><font style="vertical-align: inherit;">。本指南将使用称为</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">长期短时记忆（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LSTM</font></font></a></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的RNC专门层</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进一步使用</font></font><code><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">tf.data</a></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随机播放，批处理和缓存数据集。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">补充：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
更多关于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tensorflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">页面上的随机，批处理和缓存方法</font><font style="vertical-align: inherit;">：</font></font></i><br>
<br>
<pre><code class="python hljs">BATCH_SIZE = <span class="hljs-number">256</span>
BUFFER_SIZE = <span class="hljs-number">10000</span><font></font>
<font></font>
train_univariate = tf.data.Dataset.from_tensor_slices((x_train_uni, y_train_uni))<font></font>
train_univariate = train_univariate.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_univariate = tf.data.Dataset.from_tensor_slices((x_val_uni, y_val_uni))<font></font>
val_univariate = val_univariate.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下可视化效果应帮助您了解批处理后数据的外观。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/002/e4b/3ed/002e4b3ed48fa5d17f34ccee2cbfc40d.jpg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以看出，LSTM需要某种形式的数据输入，并提供给它。</font></font><br>
<br>
<pre><code class="python hljs">simple_lstm_model = tf.keras.models.Sequential([<font></font>
    tf.keras.layers.LSTM(<span class="hljs-number">8</span>, input_shape=x_train_uni.shape[<span class="hljs-number">-2</span>:]),<font></font>
    tf.keras.layers.Dense(<span class="hljs-number">1</span>)<font></font>
])<font></font>
<font></font>
simple_lstm_model.compile(optimizer=<span class="hljs-string">'adam'</span>, loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查模型输出。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">1</span>):<font></font>
    print(simple_lstm_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般来说，RNS与序列一起使用。</font><font style="vertical-align: inherit;">这意味着提供给模型输入的数据应具有以下形式：</font></font><br>
<br>
<code>[,  , - ]</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有一维输入的模型的训练数据的形式</font><font style="vertical-align: inherit;">应具有</font><font style="vertical-align: inherit;">以下形式：</font></font></i><br>
<br>
<code>print(x_train_uni.shape)<br>
(299980, 20, 1)</code><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们将研究模型。</font><font style="vertical-align: inherit;">由于数据集很大，并且为了节省时间，每个历元将仅执行200步（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steps_per_epoch = 200</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），而不是通常的完整训练数据。</font></font><br>
<br>
<pre><code class="python hljs">EVALUATION_INTERVAL = <span class="hljs-number">200</span>
EPOCHS = <span class="hljs-number">10</span><font></font>
<font></font>
simple_lstm_model.fit(train_univariate, epochs=EPOCHS,<font></font>
                      steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                      validation_data=val_univariate, validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 2s 11ms/step - loss: 0.4075 - val_loss: 0.1351<br>
Epoch 2/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.1118 - val_loss: 0.0360<br>
Epoch 3/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0490 - val_loss: 0.0289<br>
Epoch 4/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0444 - val_loss: 0.0257<br>
Epoch 5/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0299 - val_loss: 0.0235<br>
Epoch 6/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0317 - val_loss: 0.0224<br>
Epoch 7/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0287 - val_loss: 0.0206<br>
Epoch 8/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0263 - val_loss: 0.0200<br>
Epoch 9/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0254 - val_loss: 0.0182<br>
Epoch 10/10<br>
200/200 [==============================] - 1s 4ms/step - loss: 0.0228 - val_loss: 0.0174<br>
</code><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用简单的LSTM模型</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
进行</font><b><font style="vertical-align: inherit;">预测</font></b><font style="vertical-align: inherit;">在完成</font><b><font style="vertical-align: inherit;">简单的LSTM模型</font></b><font style="vertical-align: inherit;">准备之后，我们将进行一些预测。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_univariate.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    simple_lstm_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">0</span>, <span class="hljs-string">'Simple LSTM model'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/cf8/0f6/810/cf80f681038da62889884ae5de86722d.jpg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它看起来比基本水平更好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在您已经熟悉了基础知识，让我们继续第二部分，它描述了使用多维时间序列。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2部分：多维时间序列预测</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，原始数据集包含14种不同的气象指标。</font><font style="vertical-align: inherit;">为了简单和方便起见，在第二部分中仅考虑了其中三个-空气温度，大气压和空气密度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用更多功能，必须将其名称添加到</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">feature_considered</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列表中</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">features_considered = [<span class="hljs-string">'p (mbar)'</span>, <span class="hljs-string">'T (degC)'</span>, <span class="hljs-string">'rho (g/m**3)'</span>]
</code></pre><br>
<pre><code class="python hljs">features = df[features_considered]<font></font>
features.index = df[<span class="hljs-string">'Date Time'</span>]<font></font>
features.head()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/1f8/589/b51/1f8589b51d64dcd9ba10e5f072df503e.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看看这些指标如何随时间变化。</font></font><br>
<br>
<pre><code class="python hljs">features.plot(subplots=<span class="hljs-literal">True</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/7be/266/b59/7be266b59f38be1e4c365ee8562dffcd.jpg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
和以前一样，第一步是通过计算训练数据的平均值和标准偏差来标准化数据集。</font></font><br>
<br>
<pre><code class="python hljs">dataset = features.values<font></font>
data_mean = dataset[:TRAIN_SPLIT].mean(axis=<span class="hljs-number">0</span>)<font></font>
data_std = dataset[:TRAIN_SPLIT].std(axis=<span class="hljs-number">0</span>)
</code></pre><br>
<pre><code class="python hljs">dataset = (dataset-data_mean)/data_std
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在手册中，我们将进一步讨论点和区间预测。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
底线如下。如果您需要模型来预测将来的一个值（例如，12小时后的温度值）（单步/单步模型），则必须对模型进行训练，使其将来只能预测一个值。如果任务是预测未来的值范围（例如未来12小时的每小时温度）（多步模型），则还应训练该模型以预测将来的值范围。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/906/953/08e/90695308e69c21c37e772d98553209a4.png" alt="图片"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点预测</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这种情况下，训练模型基于一些可用历史记录来预测将来的一个值。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下面的函数执行组织时间间隔的相同任务，所不同的是，这里的函数基于给定的步长选择最新的观测值。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multivariate_data</span>(<span class="hljs-params">dataset, target, start_index, end_index, history_size,
                      target_size, step, single_step=False</span>):</span><font></font>
  data = []<font></font>
  labels = []<font></font>
<font></font>
  start_index = start_index + history_size<font></font>
  <span class="hljs-keyword">if</span> end_index <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
    end_index = len(dataset) - target_size<font></font>
<font></font>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(start_index, end_index):<font></font>
    indices = range(i-history_size, i, step)<font></font>
    data.append(dataset[indices])<font></font>
<font></font>
    <span class="hljs-keyword">if</span> single_step:<font></font>
      labels.append(target[i+target_size])<font></font>
    <span class="hljs-keyword">else</span>:<font></font>
      labels.append(target[i:i+target_size])<font></font>
<font></font>
  <span class="hljs-keyword">return</span> np.array(data), np.array(labels)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本指南中，ANN会处理最近五（5）天的数据，即720个观测值（6x24x5）。</font><font style="vertical-align: inherit;">假设数据选择不是每10分钟执行一次，而是每小时进行一次：在60分钟之内，预计不会出现急剧变化。</font><font style="vertical-align: inherit;">因此，最近五天的历史包括120个观测值（720/6）。</font><font style="vertical-align: inherit;">对于执行斑点预测的模型，目标是在将来的12小时后读取温度。</font><font style="vertical-align: inherit;">在这种情况下，目标向量将是72次（12x6）观测后的温度（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请参阅以下附加内容-近似转换器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<pre><code class="python hljs">past_history = <span class="hljs-number">720</span>
future_target = <span class="hljs-number">72</span>
STEP = <span class="hljs-number">6</span><font></font>
<font></font>
x_train_single, y_train_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                   TRAIN_SPLIT, past_history,<font></font>
                                                   future_target, STEP,<font></font>
                                                   single_step=<span class="hljs-literal">True</span>)<font></font>
x_val_single, y_val_single = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                               TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                               future_target, STEP,<font></font>
                                               single_step=<span class="hljs-literal">True</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查时间间隔。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_single[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
</code><br>
<pre><code class="python hljs">train_data_single = tf.data.Dataset.from_tensor_slices((x_train_single, y_train_single))<font></font>
train_data_single = train_data_single.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_single = tf.data.Dataset.from_tensor_slices((x_val_single, y_val_single))<font></font>
val_data_single = val_data_single.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<pre><code class="python hljs">single_step_model = tf.keras.models.Sequential()<font></font>
single_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                           input_shape=x_train_single.shape[<span class="hljs-number">-2</span>:]))<font></font>
single_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">1</span>))<font></font>
<font></font>
single_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在训练和验证阶段检查样本并得出损耗曲线。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">1</span>):<font></font>
  print(single_step_model.predict(x).shape)<font></font>
</code></pre><br>
<code>(256, 1)<br>
</code><br>
<pre><code class="python hljs">single_step_history = single_step_model.fit(train_data_single, epochs=EPOCHS,<font></font>
                                            steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                            validation_data=val_data_single,<font></font>
                                            validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 4s 18ms/step - loss: 0.3090 - val_loss: 0.2646<br>
Epoch 2/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2624 - val_loss: 0.2435<br>
Epoch 3/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2616 - val_loss: 0.2472<br>
Epoch 4/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2567 - val_loss: 0.2442<br>
Epoch 5/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2263 - val_loss: 0.2346<br>
Epoch 6/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2416 - val_loss: 0.2643<br>
Epoch 7/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2411 - val_loss: 0.2577<br>
Epoch 8/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2410 - val_loss: 0.2388<br>
Epoch 9/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2447 - val_loss: 0.2485<br>
Epoch 10/10<br>
200/200 [==============================] - 2s 9ms/step - loss: 0.2388 - val_loss: 0.2422<br>
</code><br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_train_history</span>(<span class="hljs-params">history, title</span>):</span>
  loss = history.history[<span class="hljs-string">'loss'</span>]<font></font>
  val_loss = history.history[<span class="hljs-string">'val_loss'</span>]<font></font>
<font></font>
  epochs = range(len(loss))<font></font>
<font></font>
  plt.figure()<font></font>
<font></font>
  plt.plot(epochs, loss, <span class="hljs-string">'b'</span>, label=<span class="hljs-string">'Training loss'</span>)<font></font>
  plt.plot(epochs, val_loss, <span class="hljs-string">'r'</span>, label=<span class="hljs-string">'Validation loss'</span>)<font></font>
  plt.title(title)<font></font>
  plt.legend()<font></font>
<font></font>
  plt.show()<font></font>
</code></pre><br>
<pre><code class="python hljs">plot_train_history(single_step_history,
                   <span class="hljs-string">'Single Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/baa/481/4df/baa4814df5d278c7be5a4daf629ec8e0.jpg" alt="图片"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外：</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下图示意性地显示了具有多维输入执行点预测的模型的数据准备。</font><font style="vertical-align: inherit;">为了方便起见和更直观地表示数据准备，自变量</font></font><code>STEP</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为1。请注意，在给定的生成器函数中，自</font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font></font><code>STEP </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅用于形成历史</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而不用于目标向量。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/bfd/c0b/ef1/bfdc0bef1203da6840adcb4311455645.png" alt="图片"><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，它</font></font><code>x_train_single</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有的形式</font></font><code>(299280, 720, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当为时</font></font><code>STEP=6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该表单将采用以下形式：</font></font><code>(299280, 120, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且函数的速度将显着提高。</font><font style="vertical-align: inherit;">通常，您需要感谢程序员：手册中介绍的生成器在内存消耗方面非常繁琐。</font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行点预测</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在已经对模型进行了训练，我们将执行几个测试预测。每小时选择一次（时间间隔= 120）最近5天观察到的3个信号的历史记录被输入到模型输入中。由于我们的目标是仅预测温度，因此过去的温度值（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">历史记录</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">在图表上以蓝色显示</font><font style="vertical-align: inherit;">。预测是在未来半天进行的（因此，历史记录与预测值之间存在差距）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_single.take(<span class="hljs-number">3</span>):<font></font>
  plot = show_plot([x[<span class="hljs-number">0</span>][:, <span class="hljs-number">1</span>].numpy(), y[<span class="hljs-number">0</span>].numpy(),<font></font>
                    single_step_model.predict(x)[<span class="hljs-number">0</span>]], <span class="hljs-number">12</span>,
                   <span class="hljs-string">'Single Step Prediction'</span>)<font></font>
  plot.show()<font></font>
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/6ac/a5b/ce3/6aca5bce3fef9de56f1fac299da5527c.jpg" alt="图片"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间隔预测</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这种情况下，根据一些可用的历史记录，训练模型以预测未来值的间隔。</font><font style="vertical-align: inherit;">因此，与仅预测未来一个值的模型相反，该模型预测未来的一系列值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设与执行点预测的模型一样，对于执行间隔预测的模型，训练数据是最近五天（720/6）的每小时测量值。</font><font style="vertical-align: inherit;">但是，在这种情况下，必须训练模型以预测接下来12小时的温度。</font><font style="vertical-align: inherit;">由于每10分钟记录一次观察，因此模型的输出应包含72个预测。</font><font style="vertical-align: inherit;">要完成此任务，有必要再次准备数据集，但要使用不同的目标间隔。</font></font><br>
<br>
<pre><code class="python hljs">future_target = <span class="hljs-number">72</span>
x_train_multi, y_train_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>], <span class="hljs-number">0</span>,<font></font>
                                                 TRAIN_SPLIT, past_history,<font></font>
                                                 future_target, STEP)<font></font>
x_val_multi, y_val_multi = multivariate_data(dataset, dataset[:, <span class="hljs-number">1</span>],<font></font>
                                             TRAIN_SPLIT, <span class="hljs-literal">None</span>, past_history,<font></font>
                                             future_target, STEP)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查选择。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">print</span> (<span class="hljs-string">'Single window of past history : {}'</span>.format(x_train_multi[<span class="hljs-number">0</span>].shape))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'\n Target temperature to predict : {}'</span>.format(y_train_multi[<span class="hljs-number">0</span>].shape))
</code></pre><br>
<code>Single window of past history : (120, 3)<br>
<br>
Target temperature to predict : (72,)<br>
</code><br>
<pre><code class="python hljs">train_data_multi = tf.data.Dataset.from_tensor_slices((x_train_multi, y_train_multi))<font></font>
train_data_multi = train_data_multi.cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE).repeat()<font></font>
<font></font>
val_data_multi = tf.data.Dataset.from_tensor_slices((x_val_multi, y_val_multi))<font></font>
val_data_multi = val_data_multi.batch(BATCH_SIZE).repeat()<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外：下图显示了“间隔模型”与“点模型”的目标矢量的形成差异。</font></font></i><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/190/5c6/845/1905c6845d2746a1f0bc6ae88f913b99.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将准备可视化。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">multi_step_plot</span>(<span class="hljs-params">history, true_future, prediction</span>):</span>
  plt.figure(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">6</span>))<font></font>
  num_in = create_time_steps(len(history))<font></font>
  num_out = len(true_future)<font></font>
<font></font>
  plt.plot(num_in, np.array(history[:, <span class="hljs-number">1</span>]), label=<span class="hljs-string">'History'</span>)<font></font>
  plt.plot(np.arange(num_out)/STEP, np.array(true_future), <span class="hljs-string">'bo'</span>,<font></font>
           label=<span class="hljs-string">'True Future'</span>)
  <span class="hljs-keyword">if</span> prediction.any():<font></font>
    plt.plot(np.arange(num_out)/STEP, np.array(prediction), <span class="hljs-string">'ro'</span>,<font></font>
             label=<span class="hljs-string">'Predicted Future'</span>)<font></font>
  plt.legend(loc=<span class="hljs-string">'upper left'</span>)<font></font>
  plt.show()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此图和后续类似的图表上，历史记录和将来的数据按小时排列。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_data_multi.take(<span class="hljs-number">1</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], np.array([<span class="hljs-number">0</span>]))
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/245/beb/236/245beb236bc1f87f2d611ce8d2c0bc81.jpg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于此任务比上一个任务复杂一些，因此该模型将由两个LSTM层组成。</font><font style="vertical-align: inherit;">最后，由于执行了72个预测，因此输出层具有72个神经元。</font></font><br>
<br>
<pre><code class="python hljs">multi_step_model = tf.keras.models.Sequential()<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">32</span>,<font></font>
                                          return_sequences=<span class="hljs-literal">True</span>,<font></font>
                                          input_shape=x_train_multi.shape[<span class="hljs-number">-2</span>:]))<font></font>
multi_step_model.add(tf.keras.layers.LSTM(<span class="hljs-number">16</span>, activation=<span class="hljs-string">'relu'</span>))<font></font>
multi_step_model.add(tf.keras.layers.Dense(<span class="hljs-number">72</span>))<font></font>
<font></font>
multi_step_model.compile(optimizer=tf.keras.optimizers.RMSprop(clipvalue=<span class="hljs-number">1.0</span>), loss=<span class="hljs-string">'mae'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在训练和验证阶段检查样本并得出损耗曲线。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">1</span>):
  <span class="hljs-keyword">print</span> (multi_step_model.predict(x).shape)
</code></pre><br>
<code>(256, 72)<br>
</code><br>
<pre><code class="python hljs">multi_step_history = multi_step_model.fit(train_data_multi, epochs=EPOCHS,<font></font>
                                          steps_per_epoch=EVALUATION_INTERVAL,<font></font>
                                          validation_data=val_data_multi,<font></font>
                                          validation_steps=<span class="hljs-number">50</span>)
</code></pre><br>
<code>Train for 200 steps, validate for 50 steps<br>
Epoch 1/10<br>
200/200 [==============================] - 21s 103ms/step - loss: 0.4952 - val_loss: 0.3008<br>
Epoch 2/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3474 - val_loss: 0.2898<br>
Epoch 3/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.3325 - val_loss: 0.2541<br>
Epoch 4/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.2425 - val_loss: 0.2066<br>
Epoch 5/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1963 - val_loss: 0.1995<br>
Epoch 6/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.2056 - val_loss: 0.2119<br>
Epoch 7/10<br>
200/200 [==============================] - 18s 91ms/step - loss: 0.1978 - val_loss: 0.2079<br>
Epoch 8/10<br>
200/200 [==============================] - 18s 89ms/step - loss: 0.1957 - val_loss: 0.2033<br>
Epoch 9/10<br>
200/200 [==============================] - 18s 90ms/step - loss: 0.1977 - val_loss: 0.1860<br>
Epoch 10/10<br>
200/200 [==============================] - 18s 88ms/step - loss: 0.1904 - val_loss: 0.1863<br>
</code><br>
<pre><code class="python hljs">plot_train_history(multi_step_history, <span class="hljs-string">'Multi-Step Training and validation loss'</span>)
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/479/600/430/4796004305bd5b839ead7c35120ddc69.png" alt="图片"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行间隔预测</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
因此，让我们找出训练有素的</font><b><font style="vertical-align: inherit;">人工</font></b><font style="vertical-align: inherit;">神经网络如何成功应对未来温度值的预测。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> val_data_multi.take(<span class="hljs-number">3</span>):<font></font>
  multi_step_plot(x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>], multi_step_model.predict(x)[<span class="hljs-number">0</span>])
</code></pre><br>
<img src="https://habrastorage.org/getpro/habr/post_images/a3a/2fa/3cd/a3a2fa3cd17ec79c04d9ab44a3d3ad2c.jpg" alt="图片"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本指南是使用RNS进行时间序列预测的简要介绍。现在，您可以尝试预测股票市场并成为亿万富翁</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（最初就是这样：）。 - 注意译者）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，您可以编写自己的生成器来准备数据，而不是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uni / multivariate_data函数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以便更有效地使用内存。您还可以熟悉“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间序列窗口</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”的工作，并将其思想引入本指南。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了进一步理解，建议您阅读</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">《使用Scikit-Learn，Keras和TensorFlow的应用机器学习》</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Aurelien Geron，第二版）和本书的第6章第15章。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Python深度学习”</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Francois Scholl）。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后补充</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您待在家里时，不仅要注意身体健康，还要对被截断的数据集执行本手册中的示例，以怜悯计算机。</font><font style="vertical-align: inherit;">例如，考虑到70x30的比例（训练/测试），您可以按以下方式对其进行限制：</font></font></i><br>
<br>
<pre><code class="python hljs">dataset = features[<span class="hljs-number">300000</span>:].values<font></font>
TRAIN_SPLIT = <span class="hljs-number">85000</span></code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495858/index.html">远程与自我隔离：太空经验帮助地球人</a></li>
<li><a href="../zh-CN495862/index.html">可信类型-一种保护Web应用程序代码免受XSS攻击的新方法</a></li>
<li><a href="../zh-CN495870/index.html">在繁忙的项目中与Ceph合作的提示和技巧</a></li>
<li><a href="../zh-CN495880/index.html">该书“头先。学习围棋»</a></li>
<li><a href="../zh-CN495882/index.html">2020年3月9种最佳开源资源</a></li>
<li><a href="../zh-CN495888/index.html">PyCon俄罗斯已经为未来的演讲者开放了CFP。参与表格和预期主题</a></li>
<li><a href="../zh-CN495890/index.html">在Docker Swarm中配置Nginx / LetsEncrypt捆绑软件</a></li>
<li><a href="../zh-CN495892/index.html">你真的知道什么是数组吗？</a></li>
<li><a href="../zh-CN495894/index.html">JavaScript性能评估</a></li>
<li><a href="../zh-CN495896/index.html">使用声音包：React应用程序中的声音效果</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>