<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔁 👏🏾 👩🏾‍🏭 Apprentissage automatique: par où commencer ou comment construire le premier modèle 🗻 🤰🏽 👨🏼‍🎤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En tant que première tâche de l'apprentissage automatique, nous prenons quelque chose de clair et simple, par exemple, une prévision du coût du logeme...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Apprentissage automatique: par où commencer ou comment construire le premier modèle</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/505516/"><img src="https://habrastorage.org/webt/cn/mg/fr/cnmgfrvs-ej5ldlqz9cmmdjdcrk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que première tâche de l'apprentissage automatique, nous prenons quelque chose de clair et simple, par exemple, une prévision du coût du logement. L'ensemble de données prêt peut être trouvé sur le site Web de kaggle. Dans les premières étapes de la formation, vous ne devez pas prendre d'ensembles de données avec un grand nombre de variables, par exemple, "Prix des maisons: Techniques de régression avancées" comprend 80 variables et régression avancée, nous nous arrêterons à "Ventes de maisons dans le comté de King, États-Unis" avec 21 paramètres. Téléchargez les données et analysez la description fournie. Date disponible, prix, nombre de chambres, salles de bains, surface totale et habitable, nombre d'étages, évaluation de la vue, vue sur la mer, évaluation de l'état général, grade (évaluation de la construction et de la conception), surface au-dessus et en dessous du niveau du sol, année de construction, dernière année réparation, indicatif régional, coordonnées (longitude et latitude), données sur la superficie des maisons de 15 voisins.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc choisi une tâche et sommes prêts à commencer à la résoudre. La solution comprendra deux étapes: l'analyse des données et la construction du modèle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1. Travaillez avec les données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Écartons-nous et notons séparément l'importance de l'analyse des données. Actuellement, tous les algorithmes plus ou moins populaires sont déjà écrits sous forme de bibliothèques et la construction directe du modèle est réduite à plusieurs lignes de code, par exemple, k-voisins les plus proches de sklearn en python:</font></font><a name="habracut"></a><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn .neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<font></font>
clf_KNN = KNeighborsClassifier()       <span class="hljs-comment"># </span>
clf_KNN.fit(X_train, Y_train)          <span class="hljs-comment"># </span>
Y_KNN = clf_KNN.predict(X_test)        <span class="hljs-comment">#    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seulement quatre lignes de code pour obtenir le résultat. Quelle est donc la difficulté? La difficulté réside dans l'obtention du très X_train - les données qui sont fournies à l'entrée du modèle. Le principe bien connu «garbage in» = «garbage in» (Eng. Garbage in - garbage out (GIGO)) dans la modélisation fonctionne à plus de 100% et la qualité de la solution obtenue au problème d'apprentissage automatique dépendra largement du travail avec les données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant - à la bataille! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'analyse des données, nous utiliserons des pandas, pour comprendre et évaluer «à l'œil», nous utilisons des graphiques simples de seaborn. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous importons les bibliothèques, lisons les données, dérivons plusieurs enregistrements du tableau de données, examinons les types de données et leurs omissions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code et sortie</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<font></font>
df = pd.read_csv(<span class="hljs-string">'…/train.csv'</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/1q/cy/og/1qcyogx0fmdgtibrhx1l2b5mdty.png"><br>
<br>
<pre><code class="python hljs">df.info()</code></pre><br>
<pre><code class="plaintext hljs">RangeIndex: 21613 entries, 0 to 21612<font></font>
Data columns (total 21 columns):<font></font>
id 21613 non-null int64<font></font>
date 21613 non-null object<font></font>
price 21613 non-null float64<font></font>
bedrooms 21613 non-null int64<font></font>
bathrooms 21613 non-null float64<font></font>
sqft_living 21613 non-null int64<font></font>
sqft_lot 21613 non-null int64<font></font>
floors 21613 non-null float64<font></font>
waterfront 21613 non-null int64<font></font>
view 21613 non-null int64<font></font>
condition 21613 non-null int64<font></font>
grade 21613 non-null int64<font></font>
sqft_above 21613 non-null int64<font></font>
sqft_basement 21613 non-null int64<font></font>
yr_built 21613 non-null int64<font></font>
yr_renovated 21613 non-null int64<font></font>
zipcode 21613 non-null int64<font></font>
lat 21613 non-null float64<font></font>
long 21613 non-null float64<font></font>
sqft_living15 21613 non-null int64<font></font>
sqft_lot15 21613 non-null int64<font></font>
dtypes: float64(5), int64(15), object(1)<font></font>
memory usage: 3.5+ MB</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau de données se compose de 21613 enregistrements sans lacunes dans les données et contient une seule date de champ de texte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous travaillerons avec chaque signe plus en détail et commencerons par le plus simple - jetez l'identifiant (ne contient pas d'informations utiles), le code postal (le code de la zone où se trouve la maison) et les coordonnées (lat et long), car nous ne nous familiarisons qu'avec l'apprentissage automatique et la conversion correcte de la géographie Les données sont trop spécifiques pour un spécialiste débutant.</font></font><br>
<br>
<pre><code class="python hljs">df=df.drop([<span class="hljs-string">'id'</span>,<span class="hljs-string">'zipcode'</span>,<span class="hljs-string">'lat'</span>,<span class="hljs-string">'long'</span>], axis=<span class="hljs-number">1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant la date de l'annonce. Le format de date est défini sur YYYYMMDDTT000000, en général, il peut également être supprimé du jeu de données, mais nous avons les champs année de construction (yr_built) et dernière année de réparation (yr_renovated), qui sont spécifiés au format année (YYYY), ce qui n'est pas très informatif. En utilisant la date d'annonce, vous pouvez convertir l'année en âge par soustraction (année d'annonce - année de construction / année de réparation). Nous notons que l'année de réparation est 0 pour certaines maisons, et en supposant que cela signifie qu'il n'y a pas de réparation du bâtiment, nous remplaçons les zéros de l'année de réparation par l'année de construction, en nous assurant d'abord que les données ne contiennent pas d'enregistrements incorrects lorsque l'année de réparation est inférieure à l'année de construction:</font></font><br>
<br>
<pre><code class="python hljs">df[(df[<span class="hljs-string">'yr_renovated'</span>]&lt;df[<span class="hljs-string">'yr_built'</span>])&amp;df[<span class="hljs-string">'yr_renovated'</span>]!=<span class="hljs-number">0</span>]</code></pre><br>
<img src="https://habrastorage.org/webt/l7/wo/ii/l7woii1rk3buxzexbab2i4uokmq.png"><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'yr_renovated'</span>]==<span class="hljs-number">0</span>, [<span class="hljs-string">'yr_renovated'</span>]]=df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_built'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_built'</span>]<font></font>
df[<span class="hljs-string">'yr_renovated'</span>]=df[<span class="hljs-string">'date'</span>].str[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>].astype(int)-df[<span class="hljs-string">'yr_renovated'</span>]<font></font>
df=df.drop(<span class="hljs-string">'date'</span>, axis=<span class="hljs-number">1</span>)<font></font>
df.head(<span class="hljs-number">5</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/4z/za/uw/4zzauwyidq18e0lq_8x5-up5e88.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous analyserons le prix avec le paramètre suivant et utiliserons le «Box plot» pour cela. Une boîte à moustache est un graphique simple et pratique montrant une distribution de probabilité unidimensionnelle ou, plus simplement, la concentration des données. Dessine la médiane (ligne au centre), les quartiles supérieur et inférieur (côtés de la boîte), les bords de l'échantillon statistiquement significatif ("moustache") et les valeurs aberrantes (points derrière la "moustache"). Il est facile à comprendre à partir de l'image sur la distribution normale (à droite). Le graphique vous permet d'évaluer rapidement où se trouvent la plupart des données (50% sont à l'intérieur de la boîte), leur symétrie (le décalage médian d'un côté de la boîte et / ou la longueur de la "moustache") et le degré de dispersion - variance (taille de la boîte, taille de la moustache et nombre de points - émissions).</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bi/bh/uw/bibhuwyeeexpszcl7sahfpdo8le.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est possible de construire une distribution de cette caractéristique uniquement sur l'ensemble du tableau, mais il sera plus informatif d'utiliser 2 axes - par exemple, le prix et le nombre de chambres, qui à leur tour montrera également la présence d'une connexion entre les signes:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'price'</span>, data=df)			<span class="hljs-comment"># price</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)	<span class="hljs-comment">#price &amp; bedrooms</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prix ​​et chambres: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/za/oh/ta/zaohtajsfsedoz8lagkzjto-oa0.png"><br>
<br>
<img src="https://habrastorage.org/webt/fn/em/4g/fnem4gwwbubwzkrhi25i4ly3j4k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le graphique montre immédiatement la présence de valeurs extrêmes de prix et de chambres (imaginez une maison avec 33 chambres! J). La présence de telles valeurs (autrement appelées valeurs aberrantes) dans le prix cible de l'attribut conduit souvent à un recyclage du modèle, car elles donneront une grosse erreur, que les algorithmes tentent de minimiser. On peut voir sur le graphique que la majorité (si calculée - 93,22%) se situe dans la plage de 0-1mn, et sur 2 mln - seulement 198 valeurs (0,92%). Vous pouvez vous débarrasser de 1% de l'ensemble de données presque sans douleur, donc, après avoir appelé une simple visualisation de 217 enregistrements, après les avoir triés par prix, nous verrons le prix souhaité de 19655000 et supprimer tout ce qui est supérieur à ce prix.</font></font><br>
<br>
<pre><code class="python hljs">df.sort_values (by=<span class="hljs-string">'price'</span>, ascending=<span class="hljs-literal">False</span>).head(<span class="hljs-number">217</span>) <font></font>
df=df[df[<span class="hljs-string">'price'</span>]&lt;=<span class="hljs-number">1965000</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Réfléchissons un peu au signe des chambres. </font><font style="vertical-align: inherit;">Nous voyons 13 maisons avec chambres = 0, ainsi qu'un étrange record d'une maison avec 33 chambres. </font><font style="vertical-align: inherit;">Nous ferons la même chose que pour le prix, en supprimant les zéros des chambres (et des salles de bain en même temps):</font></font><br>
<br>
<pre><code class="python hljs">df=df[(df[<span class="hljs-string">'bedrooms'</span>]!=<span class="hljs-number">0</span>)&amp;(df[<span class="hljs-string">'bathrooms'</span>]!=<span class="hljs-number">0</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ce qui concerne la maison avec 33 chambres - compte tenu du prix, nous pouvons supposer qu'il s'agit d'une faute de frappe et que les chambres sont en fait 3. Comparons la surface habitable de cette maison (1620) avec la surface habitable moyenne des maisons de 3 chambres (1798.2), ce qui est probablement notre supposition, par conséquent, remplacez simplement cette valeur par 3 et générez à nouveau le diagramme à cases précédent:</font></font><br>
<br>
<pre><code class="python hljs">df.loc[df[<span class="hljs-string">'bedrooms'</span>]==<span class="hljs-number">33</span>,[<span class="hljs-string">'bedrooms'</span>]]=<span class="hljs-number">3</span> 
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/qi/wd/fs/qiwdfscthapolbucfyjqy-uoggc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, beaucoup mieux. </font><font style="vertical-align: inherit;">De même, les chambres regardent les salles de bains. </font><font style="vertical-align: inherit;">Nous avons supprimé les valeurs nulles, il n'y a pas d'autres valeurs extrêmes dans le champ:</font></font><br>
<br>
<pre><code class="python hljs">sns.boxplot(y=<span class="hljs-string">'bathrooms'</span>, x=<span class="hljs-string">'bedrooms'</span>, data=df)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les champs sqft_living, étages, front de mer, vue, état, grade, sqft_living15 également toutes les valeurs sont plus ou moins réelles, nous ne les toucherons pas:</font></font><br>
<br>
<pre><code class="python hljs">plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">2</span>,<span class="hljs-number">3</span> 			<span class="hljs-comment"># </span>
sns.boxplot(y=<span class="hljs-string">'sqft_living'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'floors'</span>,color=<span class="hljs-string">'#2ecc71'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'sqft_living15'</span>,color=<span class="hljs-string">'#9b59b6'</span>, data=df) <font></font>
plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">4</span>,<span class="hljs-number">4</span>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'waterfront'</span>, data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'view'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'condition'</span> , data=df)<font></font>
sns.boxplot(y=<span class="hljs-string">'price'</span>, x=<span class="hljs-string">'grade'</span> , data=df)</code></pre><br>
<img src="https://habrastorage.org/webt/oq/uw/h8/oquwh8x-cln4tbaz9xrzqyk9szs.png"><br>
<br>
<img src="https://habrastorage.org/webt/yl/ns/bz/ylnsbzq_kx2dtvrvjy8iytxudve.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais avec sqft_lot et sqft_lot15, vous devez trouver quelque chose et en raison des grandes valeurs, le logarithme est tout à fait approprié:</font></font><br>
<br>
<pre><code class="python hljs">df[<span class="hljs-string">'sqft_lot'</span>]=np.log(df[<span class="hljs-string">'sqft_lot'</span>])<font></font>
df[<span class="hljs-string">'sqft_lot15'</span>]=np.log(df[<span class="hljs-string">'sqft_lot15'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_lot avant et après: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yr/up/g2/yrupg24jwmfsptci9hf8uaq6wmu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sqft_above et sqft_basement sont des composants de sqft_living, nous ne les toucherons donc pas non plus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cela, nous terminerons par une analyse préliminaire et examinerons la carte thermique des corrélations:</font></font><br>
<br>
<pre><code class="python hljs">sns.heatmap(df.corr(),  cmap = <span class="hljs-string">'viridis'</span>,annot = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/ny/yi/uq/nyyiuqa9zbilc9l6gqzljfe35xu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir examiné la carte de corrélation, nous constatons que parfois les attributs sont fortement corrélés les uns avec les autres, nous supprimons donc certains des attributs avec une forte corrélation - sqft_lot15 (laissez sqft_lot), yr_built (laissez yr_renovated), sqft_above (sqft_living). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceci termine le travail avec les données et procède à la création du modèle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. Modélisation </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette partie, nous allons construire 2 modèles: régression linéaire et arbre de décision. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les modèles dont nous avons besoin sont contenus dans la bibliothèque sklearn. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Premièrement, nous séparons la variable cible du reste des données pour la formation, et divisons également les échantillons en formation (70%) et test (30%, sur lesquels nous vérifierons le fonctionnement du modèle):</font></font><br>
<br>
<pre><code class="python hljs">Y=df[<span class="hljs-string">'price'</span>]<font></font>
X=df.drop (<span class="hljs-string">'price'</span>,axis=<span class="hljs-number">1</span>) 
<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<font></font>
X_train, X_test, Y_train, Y_test  = train_test_split(X, Y, test_size = <span class="hljs-number">0.3</span>, shuffle = <span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, à partir de sklearn, pour évaluer le modèle, nous téléchargeons 3 mesures: mean_absolute_error (erreur absolue moyenne), mean_squared_error (écart-type), r2_score (coefficient de détermination):</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par la régression linéaire:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<font></font>
LR = LinearRegression() 				<span class="hljs-comment"># </span>
LR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_LR = LR.predict(X_test)				<span class="hljs-comment">#       </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_LR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_LR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_LR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 124477.452 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√MSE 175205.645 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.627 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arbre de </font><font style="vertical-align: inherit;">décision </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<font></font>
TR = DecisionTreeRegressor()				<span class="hljs-comment"># </span>
TR.fit(X_train, Y_train)				<span class="hljs-comment"># </span>
Y_TR=TR.predict(X_test)  				<span class="hljs-comment">#   </span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'MAE:'</span>, round (mean_absolute_error(Y_test, Y_TR),<span class="hljs-number">3</span>))		<span class="hljs-comment">#</span>
<span class="hljs-keyword">print</span> (<span class="hljs-string">'√MSE:'</span>, round (mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>),<span class="hljs-number">3</span>))
<span class="hljs-keyword">print</span> (<span class="hljs-string">'R2_score:'</span>, round (r2_score(Y_test, Y_TR),<span class="hljs-number">3</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MAE: 151734.906 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√MSE 220856.721 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
R2_score: 0.407 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur la base des métriques, nous pouvons conclure que la régression linéaire a montré le meilleur résultat, il est donc plus logique de le choisir. Cependant, nous n'avons pas demandé en quoi consiste l'erreur de modèle, si le modèle est recyclé, etc. Il est fort probable que ce soit un recyclage qui a conduit à la détérioration du résultat de DecisionTreeRegressor, car nous n'avons même pas limité la profondeur de l'arbre dans les paramètres du modèle. Nous pouvons facilement vérifier cela en triant la profondeur des arbres dans un cycle court:</font></font><br>
<br>
<pre><code class="python hljs">dep,score=[],[]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>,<span class="hljs-number">16</span>):<font></font>
    TR = DecisionTreeRegressor(max_depth=i)<font></font>
    TR.fit(X_train, Y_train)<font></font>
    Y_TR=TR.predict(X_test)<font></font>
    dep.append(i)<font></font>
    score.append(mean_squared_error(Y_test, Y_TR)**(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>))	<span class="hljs-comment">#  √MSE</span>
		plt.rcParams[<span class="hljs-string">'figure.figsize'</span>]=<span class="hljs-number">6</span>,<span class="hljs-number">3</span>
		plt.plot(dep, score)</code></pre><br>
<img src="https://habrastorage.org/webt/ar/fn/yt/arfnytm068lhpknk_ifnpshupgq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Évidemment, le meilleur indicateur est à max_depth = 7, et, en regardant les métriques (MAE: 124861.441, √MSE 175322.737, R2_score: 0.626), il devient clair qu'un modèle avec une telle restriction est similaire à une régression linéaire de la qualité. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons également essayer d'évaluer quels attributs étaient les plus importants pour le modèle de prévision des coûts: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/x1/qx/qw/x1qxqwlhqbfotpp45hhyr4nz0uc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
sur la base du graphique, il est clair que la note affecte le plus le coût - une évaluation subjective générale de la maison par la société immobilière (qui, en passant, indique la compétence de l'évaluation :-))), en deuxième place se trouve la surface de la maison et en troisième - l'année de la dernière réparation. Les indicateurs ont considéré le nombre de chambres, salles de bains, étages que le modèle considérait comme non significatif pour la prévision.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour mieux comprendre les résultats, nous calculons l'erreur moyenne en% - selon la régression linéaire, l'erreur moyenne est de 27,5%, c'est-à-dire que le modèle fait un peu plus d'erreur qu'un quart lors de la prévision du coût d'une maison, ce qui est beaucoup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les résultats peuvent-ils être améliorés? </font><font style="vertical-align: inherit;">Oui, bien sûr, au stade actuel, nous n'avons reçu qu'une solution de base - un point de départ pour la comparaison sera des modèles meilleurs ou pires que nous pouvons créer avec des méthodes plus sophistiquées ou en utilisant un traitement de données plus complexe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'avons abordé que légèrement la question du recyclage et n'avons pas du tout abordé en quoi consiste l'erreur de modèle et de nombreux autres aspects de la création de modèle. </font><font style="vertical-align: inherit;">En règle générale, différentes méthodes de validation de modèle sont utilisées pour répondre à ces questions et trouver la solution optimale, mais nous écrirons à ce sujet dans les articles suivants.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr505498/index.html">Comment nous résolvons le problème de la mémoire de pile non initialisée dans Windows</a></li>
<li><a href="../fr505502/index.html">Omnicanal dans le service client: que rechercher et comment tout faire correctement?</a></li>
<li><a href="../fr505506/index.html">Il ne mord pas: comment rendre les robots industriels sûrs pour les travailleurs</a></li>
<li><a href="../fr505508/index.html">Non seulement la technologie sans pilote: l'avenir de l'industrie automobile</a></li>
<li><a href="../fr505510/index.html">Rationalisation de l'API Check Point avec le SDK Python</a></li>
<li><a href="../fr505522/index.html">Monétisation dans les jeux en ligne: comment utiliser l'expérience de quelqu'un d'autre pour vos propres besoins</a></li>
<li><a href="../fr505528/index.html">La chose la plus importante dans le Wi-Fi 6. Non, sérieusement</a></li>
<li><a href="../fr505530/index.html">Google fabrique son processeur et AMD s'apprête à détruire Qualcomm</a></li>
<li><a href="../fr505532/index.html">Chaînes de télégramme sur le développement de jeux: partie 2</a></li>
<li><a href="../fr505536/index.html">Comment cuisiner le suivi des appels: l'expérience cyan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>