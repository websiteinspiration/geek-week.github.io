<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌥️ 👩🏻‍🎤 👱🏿 Android-Insets: Umgang mit Ängsten und Vorbereitung auf Android Q. 👩🏿‍🤝‍👨🏼 📞 🤺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android Q ist die zehnte Version von Android mit API-Level 29. Eine der Hauptideen der neuen Version ist das Konzept von Rand zu Rand, wenn Anwendunge...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Android-Insets: Umgang mit Ängsten und Vorbereitung auf Android Q.</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android Q ist die zehnte Version von Android mit API-Level 29. </font><font style="vertical-align: inherit;">Eine der Hauptideen der neuen Version ist das Konzept von Rand zu Rand, wenn Anwendungen den gesamten Bildschirm von unten nach oben einnehmen. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Statusleiste und die Navigationsleiste transparent sein müssen. </font><font style="vertical-align: inherit;">Wenn sie jedoch transparent sind, gibt es keine Systembenutzeroberfläche - sie überlappt die interaktiven Komponenten der Anwendung. </font><font style="vertical-align: inherit;">Dieses Problem wird mit Einsätzen gelöst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mobile Entwickler vermeiden Insets, sie verursachen Angst in ihnen. </font><font style="vertical-align: inherit;">In Android Q ist es jedoch nicht möglich, Insets zu umgehen - Sie müssen sie studieren und anwenden. </font><font style="vertical-align: inherit;">Insets sind in der Tat nicht kompliziert: Sie zeigen, welche Bildschirmelemente sich mit der Systemschnittstelle überschneiden, und schlagen vor, wie das Element so verschoben werden soll, dass es nicht mit der Systembenutzeroberfläche in Konflikt steht. </font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></strong><font style="vertical-align: inherit;"> wird erzählen, wie Insets funktionieren und wie sie nützlich sind</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terrakok</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) arbeitet in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ist seit 10 Jahren mit Android beschäftigt und hat viel Erfahrung in verschiedenen Projekten gesammelt, in denen es keinen Platz für Insets gab. Sie haben es immer geschafft, irgendwie herumzukommen. </font><font style="vertical-align: inherit;">Konstantin wird über eine lange Geschichte der Vermeidung des Insets-Problems, über das Studium und den Kampf gegen Android berichten. </font><font style="vertical-align: inherit;">Er wird typische Aufgaben aus seiner Erfahrung betrachten, bei denen Einfügungen angewendet werden könnten, und zeigen, wie man aufhört, Angst vor der Tastatur zu haben, ihre Größe erkennt und auf das Erscheinungsbild reagiert. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis. </font><font style="vertical-align: inherit;">Der Artikel basiert auf einem Bericht von Konstantin auf der </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In dem Bericht wurden Materialien aus mehreren Artikeln zu Einsätzen verwendet. </font><font style="vertical-align: inherit;">Link zu diesen Materialien am Ende.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Typische Aufgaben</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Farbstatusleiste. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In vielen Projekten zeichnet der Designer eine Farbstatusleiste. </font><font style="vertical-align: inherit;">Es wurde in Mode, als Android 5 mit dem neuen Material Design kam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie male ich die Statusleiste? </font><font style="vertical-align: inherit;">Elementar - hinzufügen </font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und die Farbe wird ersetzt.</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Android über der fünften Version (API ab 21) können Sie im Thema spezielle Parameter festlegen:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mehrfarbige Statusleiste</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Manchmal zeichnen Designer auf verschiedenen Bildschirmen die Statusleiste in verschiedenen Farben. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist in Ordnung, der einfachste Weg, mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verschiedenen Themen in verschiedenen Aktivitäten zu arbeiten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der interessantere Weg ist, die Farben </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkt zur Laufzeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu ändern </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter wird durch ein spezielles Flag geändert. </font><font style="vertical-align: inherit;">Die Hauptsache ist jedoch, nicht zu vergessen, die Farbe wieder zu ändern, wenn der Benutzer den Bildschirm wieder verlässt. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transparente Statusleiste. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist schwieriger. </font><font style="vertical-align: inherit;">In den meisten Fällen ist Transparenz mit Karten verbunden, da Transparenz auf Karten am besten sichtbar ist. </font><font style="vertical-align: inherit;">In diesem Fall setzen wir wie bisher einen speziellen Parameter:</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier gibt es natürlich einen bekannten Trick - höher einzurücken, sonst wird die Statusleiste über das Symbol gelegt und es wird hässlich.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber auf anderen Bildschirmen bricht alles. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie löse ich das Problem? Die erste Methode, die mir in den Sinn kommt, sind verschiedene Aktivitäten: Wir haben verschiedene Themen, verschiedene Parameter, sie funktionieren unterschiedlich. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbeiten Sie mit der Tastatur.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir vermeiden Einfügungen nicht nur in der Statusleiste, sondern auch bei der Arbeit mit der Tastatur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Niemand mag die Option auf der linken Seite, aber um sie in eine Option auf der rechten Seite zu verwandeln, gibt es eine einfache Lösung.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Größe der Aktivität kann jetzt geändert werden, wenn die Tastatur angezeigt wird. Es funktioniert einfach und streng. Aber vergessen Sie nicht einen anderen Trick - wickeln Sie alles ein </font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Plötzlich nimmt die Tastatur den gesamten Bildschirm ein und es wird ein kleiner Streifen darüber sein? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Zeiten, in denen wir das Layout ändern möchten, wenn die Tastatur angezeigt wird. Ordnen Sie beispielsweise die Schaltflächen anders an oder verbergen Sie das Logo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben so viele Krücken mit einer Tastatur und einer transparenten Statusleiste trainiert, dass es jetzt schwer ist, uns aufzuhalten. Gehen Sie zu StackOverflow und kopieren Sie den schönen Code.</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier wird sogar die Wahrscheinlichkeit des Auftretens der Tastatur berechnet. </font><font style="vertical-align: inherit;">Der Code funktioniert, in einem der Projekte haben wir ihn sogar verwendet, aber für eine lange Zeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Krücken in den Beispielen sind mit der Verwendung verschiedener Aktivitäten verbunden. </font><font style="vertical-align: inherit;">Aber sie sind nicht nur schlecht, weil sie Krücken sind, sondern auch aus anderen Gründen: dem Problem des „Kaltstarts“, der Asynchronität. </font><font style="vertical-align: inherit;">Ich habe die Probleme ausführlicher im Artikel „ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Führerschein für ein Auto oder warum Anwendungen eine Einzelaktivität sein sollten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> “ beschrieben. </font><font style="vertical-align: inherit;">Aus der Dokumentation von Google geht außerdem hervor, dass der empfohlene Ansatz eine Einzelaktivitätsanwendung ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was haben wir vor Android 10 gemacht?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir (bei Redmadrobot) entwickeln Anwendungen von ziemlich hoher Qualität, haben jedoch Einfügungen lange vermieden. Wie haben wir es geschafft, sie ohne große Krücken und in einer Aktivität zu vermeiden? </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis. Screenshots und Code aus meinem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lieblingsprojekt GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Stellen Sie sich den Anwendungsbildschirm vor. Als wir unsere Anwendungen entwickelten, hätten wir nie gedacht, dass es darunter eine transparente Navigationsleiste geben könnte. Gibt es unten einen schwarzen Balken? Also, Benutzer sind daran gewöhnt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben setzen wir zunächst den Parameter, dass die Statusleiste schwarz mit Transparenz ist. Wie sieht es in Bezug auf Layout und Code aus?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Abbildung Abstraktion: Der rote Block ist die Aktivität der Anwendung, der blaue Block ist ein Fragment mit einem Navigationsbot (mit Registerkarten), und darin werden grüne Fragmente mit Inhalt gewechselt. Es ist ersichtlich, dass sich die Symbolleiste nicht unter der Statusleiste befindet. Wie haben wir das erreicht? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android hat eine knifflige Flagge </font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn Sie den Wert auf "true" setzen, fügt der Container sich selbst eine Auffüllung hinzu, sodass nichts in ihm unter die Statusleiste fällt. Ich glaube, diese Flagge ist die offizielle Krücke von Google für diejenigen, die Angst vor Einsätzen haben. Verwenden Sie alles funktioniert relativ gut ohne Einsätze. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Flag </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fügt dem von Ihnen angegebenen Container eine Auffüllung hinzu. Die Hierarchie ist jedoch wichtig: Wenn einer der Elternteile dieses Flag auf „true“ setzt, wird seine Verteilung nicht berücksichtigt, da der Container die Einrückung bereits angewendet hat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Flagge funktioniert, aber ein anderes Problem tritt auf. </font><font style="vertical-align: inherit;">Stellen Sie sich einen Bildschirm mit zwei Registerkarten vor. </font><font style="vertical-align: inherit;">Beim Umschalten wird eine Transaktion gestartet, die ein </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fragment untereinander verursacht, und alles bricht zusammen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für das zweite Fragment ist ebenfalls ein Flag gesetzt </font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, und dies sollte nicht passieren. </font><font style="vertical-align: inherit;">Aber was ist passiert, warum? </font><font style="vertical-align: inherit;">Die Antwort ist, dass dies eine Krücke ist und manchmal nicht funktioniert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben jedoch eine Lösung für den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stapelüberlauf gefunden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Verwenden Sie root nicht für Fragmente </font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sondern </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es wurde für andere Zwecke erstellt, funktioniert aber hier.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum funktioniert es?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mal sehen, in was in der Quelle passiert </font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen einen schönen Kommentar, dass hier Einsätze benötigt werden, aber nicht. </font><font style="vertical-align: inherit;">Wir müssen sie erneut fragen, wenn wir ein Fenster anfordern. </font><font style="vertical-align: inherit;">Wir haben herausgefunden, dass Insets irgendwie im Inneren funktionieren, aber wir wollen nicht mit ihnen arbeiten und gehen </font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Frühjahr 2019 haben wir die Anwendung entwickelt. Zu diesem Zeitpunkt ist Google I / O gerade vorbei. </font><font style="vertical-align: inherit;">Wir haben noch nicht alles herausgefunden und haben weiterhin an Vorurteilen festgehalten. </font><font style="vertical-align: inherit;">Wir haben jedoch festgestellt, dass das Wechseln der Registerkarten unten etwas langsam ist, da wir ein komplexes Layout haben, das mit einer Benutzeroberfläche geladen ist. </font><font style="vertical-align: inherit;">Wir finden einen einfachen Weg, um dies zu lösen - wechseln Sie </font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zu, </font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit Sie das Layout nicht jedes Mal neu erstellen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir ändern uns und wieder funktioniert nichts - alles ist kaputt! </font><font style="vertical-align: inherit;">Anscheinend ist es einfach nicht möglich, Krücken zu streuen. Sie müssen verstehen, warum sie funktioniert haben. </font><font style="vertical-align: inherit;">Wir studieren den Code und es stellt sich heraus, dass jede ViewGroup auch mit Insets arbeiten kann.</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine solche Logik: Wenn mindestens jemand bereits Insets verarbeitet hat, werden diese von allen nachfolgenden Ansichten in der ViewGroup nicht empfangen. </font><font style="vertical-align: inherit;">Was bedeutet das für uns? </font><font style="vertical-align: inherit;">Lassen Sie mich Ihnen ein Beispiel für unser FrameLayout zeigen, das die Tabs wechselt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Inneren befindet sich das erste Fragment, für das das Flag gesetzt ist </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass das erste Fragment Einfügungen verarbeitet. </font><font style="vertical-align: inherit;">Danach nennen wir das </font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Fragment und das </font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zweite. </font><font style="vertical-align: inherit;">Der erste bleibt jedoch im Layout - seine Ansicht bleibt nur versteckt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Container geht durch seine Ansicht: Er nimmt das erste Fragment, gibt ihm Einfügungen und daraus </font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- er hat sie genommen und verarbeitet. </font><font style="vertical-align: inherit;">Perfekt sah FrameLayout so aus, als ob die Einfügungen verarbeitet wurden, und gab sie nicht an das zweite Fragment weiter. </font><font style="vertical-align: inherit;">Alles funktioniert wie es sollte. </font><font style="vertical-align: inherit;">Aber das passt nicht zu uns, was sollen wir tun?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir schreiben unsere eigene ViewGroup</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kamen aus Java und dort OOP in seiner ganzen Pracht, also beschlossen wir zu erben. </font><font style="vertical-align: inherit;">Wir haben unsere eigene ViewGroup geschrieben, aus der wir die Methode neu definiert haben </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es funktioniert so, wie wir es brauchen: Es gibt den Kindern immer die Einsätze zurück, die gekommen sind, unabhängig davon, ob wir sie verarbeitet haben oder nicht.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Custom ViewGroup funktioniert, auch das Projekt ist alles, was wir brauchen. </font><font style="vertical-align: inherit;">Aber er erreicht immer noch keine allgemeine Lösung. </font><font style="vertical-align: inherit;">Als wir herausfanden, was sie uns auf Google IO mitgeteilt haben, stellten wir fest, dass wir nicht mehr so ​​handeln können.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10 zeigte uns zwei wichtige UI-Konzepte, deren Einhaltung unbedingt empfohlen wird: Edge-to-Edge- und Gesten-Navigation. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kante an Kante.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dieses </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konzept</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> legt nahe, dass der Inhalt der Anwendung den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesamten möglichen Platz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf dem Bildschirm </font><font style="vertical-align: inherit;">einnehmen sollte </font><font style="vertical-align: inherit;">. Für uns als Entwickler bedeutet dies, dass Anwendungen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unter den Systemfenstern Statusleiste und Navigationsleiste</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> platziert werden sollten </font><strong><font style="vertical-align: inherit;">.</font></strong></font><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bisher konnten wir dies irgendwie ignorieren oder nur unter der Statusleiste platziert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Listen sollten nicht nur zum letzten Element, sondern auch weiter </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gescrollt werden, um nicht unter der Navigationsleiste zu bleiben.</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gestische Navigation. </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dieses zweite wichtige Konzept ist die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gesten-Navigation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie können die Anwendung mit Ihren Fingern vom Bildschirmrand aus steuern. </font><font style="vertical-align: inherit;">Der Gestenmodus ist nicht Standard, alles sieht anders aus, aber jetzt können Sie nicht zwischen zwei verschiedenen Navigationsleisten wechseln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Moment haben wir festgestellt, dass nicht alles so einfach ist. </font><font style="vertical-align: inherit;">Es wird nicht möglich sein, Einfügungen weiter zu vermeiden, wenn wir Qualitätsanwendungen entwickeln wollen. </font><font style="vertical-align: inherit;">Es ist Zeit, die Dokumentation zu studieren und zu verstehen, was Einschübe sind.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einschübe </font><font style="vertical-align: inherit;">Was müssen Sie über sie wissen?</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Insets wurden erstellt, um Entwickler zu erschrecken.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie haben dies perfekt gemacht, seit es in Android 5 erschien. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich ist nicht alles so beängstigend. Das Konzept der Einschübe ist einfach: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie melden eine Systemoberflächenüberlagerung auf dem Anwendungsbildschirm.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dies kann eine Navigationsleiste, eine Statusleiste oder eine Tastatur sein. Die Tastatur ist auch eine normale Systembenutzeroberfläche, die über der Anwendung liegt. Es ist nicht notwendig, es mit Krücken zu verarbeiten, sondern nur mit Einsätzen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Ziel von Insets ist die Lösung von Konflikten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Befindet sich beispielsweise ein anderes Element über unserer Schaltfläche, können wir die Schaltfläche verschieben, damit der Benutzer die Anwendung weiterhin verwenden kann. </font><font style="vertical-align: inherit;">Verwenden Sie </font><font style="vertical-align: inherit;">für Android 10 und </font><font style="vertical-align: inherit;">andere Versionen </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um </font><strong><font style="vertical-align: inherit;">mit dem Einschub umzugehen</font></strong><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">
Es gibt </font><strong><font style="vertical-align: inherit;">5 verschiedene Arten von Insets</font></strong><font style="vertical-align: inherit;"> in Android 10</font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und ein "Bonus", der nicht Einschub genannt wird, sondern anders. </font><font style="vertical-align: inherit;">Wir werden uns mit allen Typen befassen, da die meisten nur eines wissen - Systemfenster-Einfügungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemfenstereinfügungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eingeführt in Android 5.0 (API 21). </font><font style="vertical-align: inherit;">Durch die Methode erhalten </font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist die Hauptart von Insets, mit denen Sie lernen müssen, wie man arbeitet, da der Rest auf die gleiche Weise funktioniert. </font><font style="vertical-align: inherit;">Sie werden benötigt, um zuerst die Statusleiste und dann die Navigationsleiste und die Tastatur zu verarbeiten. </font><font style="vertical-align: inherit;">Sie lösen beispielsweise ein Problem, wenn sich die Navigationsleiste über der Anwendung befindet. </font><font style="vertical-align: inherit;">Wie im Bild: Die Schaltfläche blieb unter der Navigationsleiste, der Benutzer kann nicht darauf klicken und ist sehr unglücklich.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gewindeschneidbare Elementeinsätze</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erscheint nur in Android 10. Erhalten durch die Methode </font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einfügungen sind </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur für die Handhabung verschiedener Navigationsleistenmodi</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nützlich </font><font style="vertical-align: inherit;">. Wie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Bane</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selbst sagt </font><font style="vertical-align: inherit;">, können Sie diese Art von Insets vergessen und nur Systemfenster-Insets umgehen. Wenn Sie jedoch möchten, dass die Anwendung 100% cool und nicht zu 99,9% cool ist, sollten Sie sie verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sehen Sie das Bild an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben zeigt die purpurrote Farbe Systemfenster-Einfügungen an, die in verschiedenen Modi der Navigationsleiste angezeigt werden. Es ist zu sehen, dass sie rechts und links der Navigationsleiste entsprechen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erinnern Sie sich daran, wie die Gesten-Navigation funktioniert: Im richtigen Modus klicken wir nie auf ein neues Bedienfeld, sondern ziehen unsere Finger immer von unten nach oben. </font><font style="vertical-align: inherit;">Dies bedeutet, dass die Schaltflächen nicht entfernt werden können. </font><font style="vertical-align: inherit;">Wir können weiterhin unsere FAB-Taste (Floating Action Button) drücken, niemand wird sich einmischen. </font><font style="vertical-align: inherit;">Daher </font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird es leer, da FAB zum Bewegen nicht erforderlich ist. </font><font style="vertical-align: inherit;">Aber wenn wir uns etwas höher bewegen, ist das okay. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Unterschied tritt nur bei der Gesten-Navigation und der transparenten Navigationsleiste</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Farbanpassung) auf. </font><font style="vertical-align: inherit;">Dies ist keine sehr angenehme Situation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles wird funktionieren, aber es sieht unangenehm aus. </font><font style="vertical-align: inherit;">Der Benutzer kann durch die Nähe der Elemente verwirrt sein. </font><font style="vertical-align: inherit;">Es kann erklärt werden, dass einer für Gesten und der andere für das Drücken ist, aber immer noch nicht schön. </font><font style="vertical-align: inherit;">Erhöhen Sie daher entweder den FAB höher oder lassen Sie ihn rechts.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Systemgesteneinsätze</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erscheint nur in Android 10. Erhalten durch die Methode </font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einfügungen beziehen sich auf die Gesten-Navigation. Ursprünglich wurde angenommen, dass die Systembenutzeroberfläche über der Anwendung gezeichnet wird. Systemgesteneinfügungen besagen jedoch, dass nicht die Benutzeroberfläche gezeichnet wird, sondern das System selbst die Gesten verarbeitet. Sie beschreiben, wo das System standardmäßig Gesten verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Bereiche dieser Einschübe sind ungefähr diejenigen, die im Diagramm gelb markiert sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich möchte Sie warnen - sie werden nicht immer so sein. Wir werden nie wissen, welche neuen Bildschirme Samsung und andere Hersteller entwickeln werden. Es gibt bereits Geräte, bei denen sich der Bildschirm nach allen Seiten befindet. Vielleicht sind die Einsätze überhaupt nicht dort, wo wir sie erwarten. Daher müssen Sie mit ihnen wie mit einer gewissen Abstraktion arbeiten: Es gibt solche Einfügungen in Systemgesten-Einfügungen, in denen das System selbst Gesten verarbeitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Einschübe können überschrieben werden. </font><font style="vertical-align: inherit;">Sie entwickeln beispielsweise einen Fotoeditor. </font><font style="vertical-align: inherit;">An einigen Stellen möchten Sie selbst mit Gesten umgehen, auch wenn sie sich in der Nähe des Bildschirmrandes befinden. </font><font style="vertical-align: inherit;">Geben Sie dem System an, dass Sie den Punkt auf dem Bildschirm in der Ecke des Fotos selbst verarbeiten möchten. </font><font style="vertical-align: inherit;">Es kann neu definiert werden, indem man dem System sagt: "Ich werde das Quadrat um den Punkt immer selbst verarbeiten."</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obligatorische Systemgesteneinsätze</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wird nur in Android 10 angezeigt. Dies ist ein Untertyp von Systemgesten-Insets, die jedoch von der Anwendung nicht überschrieben werden können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden die Methode </font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, um den Bereich zu bestimmen, in dem sie nicht funktionieren. </font><font style="vertical-align: inherit;">Dies wurde absichtlich gemacht, so dass es unmöglich war, eine „hoffnungslose“ Anwendung zu entwickeln: Definieren Sie die Navigationsgeste von unten nach oben neu, sodass Sie die Anwendung auf dem Hauptbildschirm beenden können. </font><font style="vertical-align: inherit;">Hier </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verarbeitet das System immer die Gesten selbst</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es muss sich nicht unbedingt auf der Unterseite des Geräts befinden und muss nicht unbedingt diese Größe haben. </font><font style="vertical-align: inherit;">Arbeite damit als Abstraktion. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies waren relativ neue Arten von Einsätzen. </font><font style="vertical-align: inherit;">Aber es gibt solche, die schon vor Android 5 erschienen und anders genannt wurden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stabile Einsätze</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eingeführt mit Android 5.0 (API 21). Durch die Methode erhalten </font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selbst erfahrene Entwickler können nicht immer sagen, warum sie gebraucht werden. Ich werde Ihnen ein Geheimnis verraten: Diese Einfügungen sind nur für Vollbildanwendungen nützlich: Videoplayer, Spiele. Im Wiedergabemodus ist beispielsweise jede Systembenutzeroberfläche ausgeblendet, einschließlich der Statusleiste, die über den Bildschirmrand hinausgeht. Es lohnt sich jedoch, den Bildschirm zu berühren, da die Statusleiste oben angezeigt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie eine BACK-Schaltfläche oben auf dem Bildschirm platzieren, während die Systemfenster-Einfügungen korrekt verarbeitet werden, wird mit jeder Registerkarte eine Benutzeroberfläche von oben auf dem Bildschirm angezeigt, und die Schaltfläche springt nach unten. Wenn Sie den Bildschirm eine Weile nicht berühren, verschwindet die Statusleiste und die Schaltfläche springt hoch, weil die Systemfenster-Einfügungen verschwunden sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In solchen Fällen sind stabile Einfügungen genau richtig. </font><font style="vertical-align: inherit;">Sie sagen, dass jetzt kein Element in Ihrer Anwendung gezeichnet ist, aber es kann. </font><font style="vertical-align: inherit;">Mit diesen Einsätzen können Sie beispielsweise den Wert der Statusleiste in diesem Modus im Voraus ermitteln und die Schaltfläche an der gewünschten Stelle positionieren. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis. </font><font style="vertical-align: inherit;">Die Methode wurde </font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur mit API 21 angezeigt. Bisher gab es mehrere Methoden für jede Seite des Bildschirms.&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben 5 Arten von Einsätzen untersucht, aber es gibt noch einen, der nicht direkt für Einsätze gilt. </font><font style="vertical-align: inherit;">Es hilft beim Umgang mit Pony und Ausschnitten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pony und Ausschnitte</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bildschirme sind nicht mehr quadratisch. </font><font style="vertical-align: inherit;">Sie sind länglich, mit einem oder mehreren Ausschnitten für die Kamera und Pony auf allen Seiten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bis zu 28 APIs konnten wir nicht verarbeiten. </font><font style="vertical-align: inherit;">Ich musste durch Einfügungen erraten, was dort geschah. </font><font style="vertical-align: inherit;">Aber mit der 28 API und darüber hinaus (vom vorherigen Android) erschien die Klasse offiziell </font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Es befindet sich in denselben Einsätzen, aus denen Sie alle anderen Typen erhalten können. </font><font style="vertical-align: inherit;">Mit der Klasse können Sie die Position und Größe von Artefakten ermitteln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu den Standortinformationen wird dem Entwickler eine Reihe von y-Flags bereitgestellt </font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mit ihnen können Sie verschiedene Verhaltensweisen in Ausschnitte einbeziehen. </font><font style="vertical-align: inherit;">Ihre Inhalte werden möglicherweise um sie herum angezeigt oder nicht: im Quer- und Hochformat auf unterschiedliche Weise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Flaggen</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Im Hochformat gibt es und im Querformat standardmäßig einen schwarzen Balken.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Überhaupt nicht - ein schwarzer Streifen.</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - ist es immer.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anzeige kann gesteuert werden, aber wir arbeiten mit ihnen genauso wie mit allen anderen Insets.</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rückruf mit Insets mit einem Array kommt zu uns </font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dann können wir es durchgehen und alle Ausschnitte und Pony verarbeiten, die in der Anwendung enthalten sind. </font><font style="vertical-align: inherit;">Weitere </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informationen zum</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Umgang mit ihnen finden Sie </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">im Artikel</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verstanden mit 6 Arten von Einsätzen. </font><font style="vertical-align: inherit;">Lassen Sie uns nun darüber sprechen, wie es funktioniert.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wie es funktioniert</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einfügungen werden vor allem dann benötigt, wenn etwas über die Anwendung gezeichnet wird, z. B. die Navigationsleiste. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ohne Einschübe verfügt die Anwendung nicht über eine transparente Navigationsleiste und Statusleiste. </font><font style="vertical-align: inherit;">Seien Sie nicht überrascht, dass Sie nicht kommen </font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dies passiert.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einsätze verteilen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die gesamte UI-Hierarchie sieht aus wie ein Baum mit einer Ansicht am Ende. </font><font style="vertical-align: inherit;">Knoten sind normalerweise eine ViewGroup. </font><font style="vertical-align: inherit;">Sie erben auch von View, sodass Einfügungen auf besondere Weise zu ihnen kommen </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ausgehend von der Stammansicht sendet das System Einfügungen im gesamten Baum. </font><font style="vertical-align: inherit;">Mal sehen, wie View in diesem Fall funktioniert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das System ruft die Methode auf, </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in die die Insets kommen. </font><font style="vertical-align: inherit;">Zurück in dieser Ansicht sollte etwas zurückgegeben werden. </font><font style="vertical-align: inherit;">Was tun, um mit diesem Verhalten umzugehen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Einfachheit halber betrachten wir nur WindowInsets.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umgang mit Einsätzen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zunächst scheint eine Neudefinition der Methode </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Implementierung innerhalb ihrer eigenen Logik </font><font style="vertical-align: inherit;">logisch </font><font style="vertical-align: inherit;">: Einfügungen kamen, wir haben alles innerhalb implementiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie die View-Klasse öffnen und sich das Javadoc ansehen, das über dieser Methode geschrieben wurde, sehen Sie: "Überschreiben Sie diese Methode nicht!"</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir behandeln Insets durch Delegation oder Vererbung.</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delegierung verwenden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Google bot die Möglichkeit, einen eigenen Delegierten zu entlarven, der für den Umgang mit Insets verantwortlich ist. </font><font style="vertical-align: inherit;">Sie können es über die Methode installieren </font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir setzen einen Rückruf, der diese Einfügungen behandelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies aus irgendeinem Grund nicht zu uns passt, können Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von View erben und eine andere Methode überschreiben</font></font></strong> <code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wir ersetzen unsere eigenen Einfügungen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google hat nicht zwischen Delegierung und Vererbung gewählt, sondern alles zusammen machen dürfen. </font><font style="vertical-align: inherit;">Dies ist großartig, da wir nicht alle Symbolleisten oder ListView neu definieren müssen, um Einfügungen zu verarbeiten. </font><font style="vertical-align: inherit;">Wir können jede vorgefertigte Ansicht, auch eine Bibliotheksansicht, verwenden und dort den Delegaten festlegen, der Einfügungen ohne Neudefinition verarbeitet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was sollen wir zurückgeben?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum etwas zurückgeben?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu müssen Sie verstehen, wie die Verteilung von Insets, d. H. ViewGroup, funktioniert. </font><font style="vertical-align: inherit;">Was macht sie in sich? </font><font style="vertical-align: inherit;">Schauen wir uns das Standardverhalten anhand des zuvor gezeigten Beispiels genauer an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben und unten befanden sich Systemeinfügungen, beispielsweise jeweils 100 Pixel. </font><font style="vertical-align: inherit;">Die ViewGroup sendet sie an die erste Ansicht, die sie hat. </font><font style="vertical-align: inherit;">Diese Ansicht hat sie irgendwie behandelt und gibt Einfügungen zurück: oben wird sie auf 0 verringert, unten wird sie verlassen. </font><font style="vertical-align: inherit;">Oben fügte sie Polsterung oder Rand hinzu, aber unten berührte sie nicht und berichtete dies. </font><font style="vertical-align: inherit;">Als Nächstes übergibt die ViewGroup Einfügungen an die zweite Ansicht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die nächste Ansicht verarbeitet und rendert Einfügungen. </font><font style="vertical-align: inherit;">Jetzt sieht die ViewGroup, dass die Insets sowohl oben als auch unten verarbeitet werden - es ist nichts mehr übrig, alle Parameter sind Null. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die dritte Ansicht weiß nicht einmal, dass es einige Einfügungen gab und etwas passierte</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">ViewGroup gibt Insets an denjenigen zurück, der sie freigelegt hat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als wir anfingen, uns mit diesem Thema zu befassen, haben wir die Idee für uns selbst aufgeschrieben - geben Sie immer die gleichen Einfügungen zurück, die gekommen sind. </font><font style="vertical-align: inherit;">Wir wollten eine solche Situation vermeiden, in der einige View nicht einmal erkannten, dass es Einfügungen gab. </font><font style="vertical-align: inherit;">Die Idee sah logisch aus. </font><font style="vertical-align: inherit;">Aber es stellte sich heraus, dass nein. </font><font style="vertical-align: inherit;">Google hat Insets nicht umsonst Verhalten hinzugefügt, wie im Beispiel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist erforderlich, damit Einfügungen immer die gesamte Hierarchie der Ansicht erreichen und Sie immer mit ihnen arbeiten können. </font><font style="vertical-align: inherit;">In diesem Fall gibt es keine Situation, wenn wir zwei Fragmente wechseln, eines verarbeitet und das zweite noch nicht empfangen hat. </font><font style="vertical-align: inherit;">Im Übungsabschnitt werden wir auf diesen Punkt zurückkommen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trainieren</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Theorie ist fertig. </font><font style="vertical-align: inherit;">Mal sehen, wie es im Code aussieht, denn theoretisch ist immer alles glatt. </font><font style="vertical-align: inherit;">Wir werden AndroidX verwenden. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis. </font><font style="vertical-align: inherit;">In </font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist bereits alles im Code implementiert, volle Unterstützung für alle Extras des neuen Android. </font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">stattdessen immer die </font></em><em><font style="vertical-align: inherit;">Version von AndroidX </font></em><em><font style="vertical-align: inherit;">, um Android-Versionen nicht zu überprüfen und nicht nach dem erforderlichen Insets-Typ zu suchen </font></em></font><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt einen Bildschirm mit einer dunklen Navigationsleiste. </font><font style="vertical-align: inherit;">Es überlappt kein Element oben. </font><font style="vertical-align: inherit;">Alles ist so, wie wir es gewohnt sind.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es stellt sich heraus, dass wir es jetzt transparent machen müssen. </font><font style="vertical-align: inherit;">Wie?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie die Transparenz ein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, im Betreff anzugeben, dass die Statusleiste und die Navigationsleiste transparent sind.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Moment beginnt sich alles von oben und von unten zu überlappen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Interessanterweise gibt es zwei Flags und es gibt immer drei Optionen. Wenn Sie Transparenz für die Navigationsleiste angeben, wird die Statusleiste von selbst transparent - eine solche Einschränkung. </font><font style="vertical-align: inherit;">Sie können nicht die erste Zeile schreiben, aber ich liebe immer Klarheit, also schreibe ich 2 Zeilen, damit die Follower verstehen können, was passiert, und nicht darin graben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie diese Methode wählen, werden die Navigationsleiste und die Statusleiste mit Transparenz schwarz. </font><font style="vertical-align: inherit;">Wenn die Anwendung weiß ist, können Sie Farben nur aus dem Code hinzufügen. </font><font style="vertical-align: inherit;">Wie kann man das machen?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schalten Sie die Transparenz mit Farbe ein</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist gut, dass wir eine Anwendung für eine einzelne Aktivität haben, also setzen wir zwei Flags in eine Aktivität.</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt dort viele Flags, aber es sind diese beiden, die dazu beitragen, Transparenz in der Navigationsleiste und der Statusleiste zu schaffen. </font><font style="vertical-align: inherit;">Die Farbe kann über das Thema festgelegt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist das seltsame Verhalten von Android: etwas durch das Thema und etwas durch die Flaggen. </font><font style="vertical-align: inherit;">Wir können jedoch Parameter sowohl im Code als auch im Betreff angeben. </font><font style="vertical-align: inherit;">Dies ist nicht so schlecht für Android, nur bei älteren Android-Versionen wird das im Thema angegebene Flag ignoriert. </font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird hervorgehoben, dass dies unter Android 5 nicht der Fall ist, aber alles wird zusammenkommen. </font><font style="vertical-align: inherit;">In GitFox habe ich anhand des Codes die Farbe der Navigationsleiste festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben Betrug durchgeführt - angezeigt, dass die Navigationsleiste weiß mit Transparenz ist. </font><font style="vertical-align: inherit;">Jetzt sieht die Anwendung so aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was könnte einfacher sein als die Handhabung von Einsätzen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tat elementar.</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen die Methode </font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und geben sie weiter </font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir sagen, wenn die Einsätze kommen, installieren Sie die untere Polsterung, die hereingekommen ist </font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir wollen es darunter haben, aber alle unsere anklickbaren Elemente sind oben. </font><font style="vertical-align: inherit;">Wir geben vollständig eingefügte Elemente zurück, sodass alle anderen Ansichten in unserer Hierarchie diese ebenfalls erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles sieht gut aus.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt einen Haken. </font><font style="vertical-align: inherit;">Wenn wir im Layout unten in der Navigationsleiste eine Art Polsterung angegeben haben, wurde diese hier gelöscht - setzen Sie die </font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügungen gleich. </font><font style="vertical-align: inherit;">Unser Layout sieht nicht so aus, wie wir es gerne hätten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Werte aus dem Layout zu speichern, müssen Sie zuerst speichern, was sich in der unteren Auffüllung befindet. </font><font style="vertical-align: inherit;">Wenn später Einfügungen eintreffen, fügen Sie die resultierenden Werte hinzu und legen Sie sie fest.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist unpraktisch, so zu schreiben: Überall im Code, wo Sie Einfügungen verwenden, müssen Sie den Wert aus dem Layout speichern und dann zur Benutzeroberfläche hinzufügen. </font><font style="vertical-align: inherit;">Aber es gibt Kotlin, und das ist wunderbar - Sie können Ihre eigene Erweiterung schreiben, die all dies für uns erledigt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlin hinzufügen!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erinnern uns </font></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und geben es dem Handler, wenn neue Insets (zusammen mit ihnen) kommen. </font><font style="vertical-align: inherit;">Dies wird ihnen helfen, sich irgendwie zu addieren oder eine Art Logik von oben aufzubauen.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen das Lambda neu definieren. </font><font style="vertical-align: inherit;">Es hat nicht nur Einsätze, sondern auch Polster. </font><font style="vertical-align: inherit;">Wir können sie nicht nur von unten, sondern auch von oben hinzufügen, wenn es sich um eine Symbolleiste handelt, die die Statusleiste verarbeitet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Etwas vergessen!</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird eine unverständliche Methode aufgerufen.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt an der Tatsache, dass Sie nicht nur hoffen können, dass das System Ihnen Einfügungen sendet. </font><font style="vertical-align: inherit;">Wenn wir eine Ansicht aus dem Code erstellen oder </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwas später </font><font style="vertical-align: inherit;">installieren, </font><font style="vertical-align: inherit;">übergibt das System selbst möglicherweise nicht den letzten Wert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen überprüfen, ob die Ansicht auf dem Bildschirm angezeigt wird. Wir haben dem System mitgeteilt: "Die Einfügungen sind eingetroffen, wir möchten sie verarbeiten." </font><font style="vertical-align: inherit;">Wir stellen den Listener ein und müssen eine Anfrage stellen </font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. "</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir einen Ansichtscode erstellt und noch nicht an unser Layout angehängt haben, müssen wir den Zeitpunkt abonnieren, zu dem wir dies tun. </font><font style="vertical-align: inherit;">Erst dann fordern wir Einschübe an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber andererseits gibt es Kotlin: Sie haben eine einfache Erweiterung geschrieben und wir müssen nicht mehr darüber nachdenken.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView verfeinern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun über die Fertigstellung der RecyclerView sprechen. Das letzte Element fällt unter die Navigationsleiste und bleibt darunter - hässlich. Es ist auch unpraktisch, darauf zu klicken. Wenn dies kein neues Panel ist, sondern das alte, ein großes, dann kann im Allgemeinen das gesamte Element darunter verschwinden. Was zu tun ist? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Idee besteht darin, unten ein Element hinzuzufügen und die Höhe so einzustellen, dass sie in die Einfügungen passt. Wenn wir jedoch eine Anwendung mit Hunderten von Listen haben, müssen wir irgendwie jede Liste für Einschübe abonnieren, dort ein neues Element hinzufügen und die Höhe festlegen. Darüber hinaus ist RecyclerView asynchron, es ist nicht bekannt, wann es funktionieren wird. Es gibt viele Probleme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber es gibt noch einen anderen offiziellen Hack. Überraschenderweise funktioniert es effizient.</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt eine solche Flagge im Layout </font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Standardmäßig ist es immer wahr. Dies bedeutet, dass Sie keine Elemente zeichnen müssen, die dort angezeigt werden, wo die Polsterung freigelegt ist. Aber wenn gesetzt </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Sie zeichnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie nun das Auffüllen nach unten setzen, funktioniert dies in RecyclerView folgendermaßen: Das Auffüllen wird nach unten gesetzt, und das Element wird darüber gezeichnet, bis wir einen Bildlauf durchführen. Sobald das Ende erreicht ist, scrollt RecyclerView die Elemente an die Position, die wir benötigen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Setzen eines solchen Flags können wir mit RecyclerView wie mit einer normalen Ansicht arbeiten. Denken Sie nicht, dass es Elemente gibt, die scrollen - stellen Sie einfach die Auffüllung unten ein, wie zum Beispiel in der unteren Navigationsleiste.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt haben wir immer Einfügungen zurückgegeben, als ob sie nicht verarbeitet worden wären. </font><font style="vertical-align: inherit;">Die ganzen Einsätze kamen zu uns, wir machten etwas mit ihnen, stellten die Polster ein und gaben alle ganzen Einsätze wieder zurück. </font><font style="vertical-align: inherit;">Dies ist erforderlich, damit jede ViewGroup diese Einfügungen immer an alle Views weitergibt. </font><font style="vertical-align: inherit;">Es klappt.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungsfehler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In vielen Anwendungen bei Google Play, die bereits Einschübe verarbeitet haben, ist mir ein kleiner Fehler aufgefallen. Jetzt erzähle ich von ihm. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Keller befindet sich ein Bildschirm mit Navigation. Auf der rechten Seite befindet sich derselbe Bildschirm, auf dem die Hierarchie angezeigt wird. Das grüne Fragment zeigt den Inhalt auf dem Bildschirm an und enthält eine RecyclerView. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wer hat hier mit den Einsätzen umgegangen? Symbolleiste: Er hat oben eine Auffüllung angebracht, damit sein Inhalt unter die Statusleiste verschoben wird. Dementsprechend wurden in der unteren Navigationsleiste Einfügungen von unten angebracht und über der Navigationsleiste angehoben. RecyclerView behandelt Insets jedoch in keiner Weise, es fällt nicht unter sie, es muss keine Insets verarbeiten - alles wird korrekt ausgeführt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier stellt sich jedoch heraus, dass wir das grüne RecyclerView-Fragment an einer anderen Stelle verwenden möchten, an der die untere Navigationsleiste nicht mehr vorhanden ist. Zu diesem Zeitpunkt beginnt RecyclerView bereits mit der Verarbeitung von Einfügungen von unten. Wir müssen Polster darauf anwenden, um unter der Navigationsleiste richtig zu scrollen. Daher fügen wir in RecyclerView auch die Verarbeitung von Einfügungen hinzu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir kehren zu unserem Bildschirm zurück, auf dem alle Einfügungen verarbeiten. Erinnerst du dich, niemand berichtet, dass er sie verarbeitet hat? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen diese Situation: RecyclerView verarbeitete Einfügungen von unten, obwohl sie die Navigationsleiste nicht erreichen - unten wurde ein Leerzeichen angezeigt. Ich habe dies in Anwendungen bemerkt und war ziemlich groß und beliebt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies der Fall ist, erinnern wir uns, dass wir alle Einfügungen zur Verarbeitung zurückgeben. Also (es stellt sich heraus!) Es muss gemeldet werden, dass die Einfügungen verarbeitet werden: Die Navigationsleiste sollte melden, dass die Einfügungen verarbeitet wurden. Sie sollten nicht zu RecyclerView gelangen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Installieren Sie dazu die untere Navigationsleiste </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Subtrahieren Sie, </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dass sie nicht verarbeitet werden, und geben Sie 0 zurück.</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir geben neue Einfügungen zurück, in denen alle alten Parameter gleich, aber </font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich 0 sind. Es scheint, dass alles in Ordnung ist. </font><font style="vertical-align: inherit;">Wir fangen an und wieder Unsinn - RecyclerView behandelt aus irgendeinem Grund immer noch Einfügungen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe nicht sofort verstanden, dass das Problem darin besteht, dass der Container für diese drei Ansichten LinearLayout ist. </font><font style="vertical-align: inherit;">Darin befindet sich eine Symbolleiste, ein Snippet mit einer RecyclerView und am unteren Rand der unteren Navigationsleiste. </font><font style="vertical-align: inherit;">LinearLayout nimmt seine Kinder in Ordnung und wendet Einfügungen auf sie an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellt sich heraus, dass die untere Navigationsleiste die letzte ist. </font><font style="vertical-align: inherit;">Er sagte jemandem, dass er alle Einschübe bearbeitet habe, aber es sei zu spät. </font><font style="vertical-align: inherit;">Alle Einschübe wurden von oben nach unten verarbeitet, RecyclerView hat sie bereits erhalten, und dies rettet uns nicht. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was zu tun ist? </font><font style="vertical-align: inherit;">LinearLayout funktioniert nicht so, wie ich es möchte, es überträgt sie von oben nach unten, und ich muss zuerst das untere erhalten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alle neu definieren</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Java-Entwickler hat in mir gespielt - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alles</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muss neu </font><strong><font style="vertical-align: inherit;">definiert werden</font></strong><font style="vertical-align: inherit;"> ! </font><font style="vertical-align: inherit;">Nun, jetzt </font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neu definieren, setzen </font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, was immer von unten nach oben geht. </font><font style="vertical-align: inherit;">Er sendet zuerst die unteren Navigationsleisten und dann alle anderen.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber ich blieb rechtzeitig stehen und erinnerte mich an den Kommentar, dass diese Methode nicht neu definiert werden musste. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etwas höher ist hier die Rettung: ViewGroup sucht nach einem Delegaten, der die Einfügungen verarbeitet, ruft dann die Supermethode in View auf und enthält eine eigene Verarbeitung. </font><font style="vertical-align: inherit;">In diesem Code erhalten wir Einfügungen, und wenn sie noch nicht verarbeitet wurden, beginnen wir mit der Standardlogik für unsere Kinder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe eine einfache Erweiterung geschrieben. </font><font style="vertical-align: inherit;">In </font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer Ansicht können Sie angeben, an wen diese Einfügungen übergeben werden.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier entspricht es </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">standardmäßig derselben Ansicht, auf die wir uns beziehen </font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir können es neu definieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An meinem LinearLayout habe ich einen solchen Handler aufgehängt und vorbeigegangen als </font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- dies ist meine untere Navigationsleiste.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zuerst wird er die unteren Navigationsleisten einfügen.&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das wird Einfügungen verarbeiten, wird Null unten zurückgeben.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Außerdem werden sie standardmäßig von oben nach unten verschoben: Symbolleiste, Fragment mit RecyclerView.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dann wird er vielleicht wieder Einfügungen unterer Navigationsleiste senden. </font><font style="vertical-align: inherit;">Aber das ist nicht mehr wichtig, alles wird so gut funktionieren.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe genau das erreicht, was ich wollte: Alle Einsätze werden in der Reihenfolge verarbeitet, in der sie benötigt werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wichtig</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein paar wichtige Dinge zu beachten. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tastatur ist die Systemoberfläche über Ihrer Anwendung.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Keine Notwendigkeit, sie auf besondere Weise zu behandeln. Wenn Sie sich die Google-Tastatur ansehen, handelt es sich nicht nur um ein Layout mit Schaltflächen, auf die Sie klicken können. Es gibt Hunderte von Modi für diese Tastatur: Suche nach Gifs und Memes, Spracheingabe, Größenänderung von 10 Pixel Höhe auf Bildschirmgröße. Denken Sie nicht an die Tastatur, sondern abonnieren Sie Insets. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Navigation Drawer unterstützt die Gesten-Navigation immer noch nicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bei Google IO versprachen sie, dass alles sofort funktionieren würde. </font><font style="vertical-align: inherit;">In Android 10 unterstützt Navigation Drawer dies jedoch immer noch nicht. </font><font style="vertical-align: inherit;">Wenn Sie auf Android 10 aktualisieren und die Navigation mit Gesten aktivieren, fällt die Navigationsleiste ab. </font><font style="vertical-align: inherit;">Jetzt müssen Sie auf das Hamburger-Menü klicken, um es anzuzeigen, oder eine Kombination von zufälligen Umständen ermöglicht es Ihnen, es zu dehnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Pre-Alpha-Version von Android funktioniert Navigation Drawer, aber ich habe mich nicht getraut, ein Update durchzuführen - dies ist Pre-Alpha. </font><font style="vertical-align: inherit;">Selbst wenn Sie die neueste Version von GitFox aus dem Repository installieren, befindet sich dort eine Navigationsleiste, die jedoch nicht abgerufen werden kann. </font><font style="vertical-align: inherit;">Sobald der offizielle Support herauskommt, werde ich aktualisieren und alles wird gut funktionieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checkliste zur Vorbereitung auf Android 10</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Legen Sie die Transparenz der Navigationsleiste und der Statusleiste zu Beginn des Projekts fest</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google empfiehlt dringend, eine transparente Navigationsleiste beizubehalten. Für uns ist dies ein wichtiger praktischer Teil. Wenn das Projekt funktioniert, Sie es jedoch nicht aktiviert haben, wählen Sie die Zeit für die Unterstützung von Android 10. Aktivieren Sie sie zuerst im Betreff, z. B. durchscheinend, und korrigieren Sie das Layout, in dem es beschädigt wurde. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie Kotlin Erweiterungen hinzu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - mit ihnen ist es einfacher. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie der gesamten Symbolleiste über dem Abstand hinzu.</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Symbolleisten befinden sich immer oben, und genau das müssen Sie tun. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie für alle RecyclerViews eine Auffüllung von unten</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die Möglichkeit zum Scrollen hinzu </font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Denken Sie an alle Schaltflächen an den Bildschirmrändern </font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(FAB)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . FABs werden höchstwahrscheinlich nicht dort sein, wo Sie es erwarten.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überschreiben oder erstellen Sie keine eigenen Implementierungen für alle LinearLayout-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und ähnliche Fälle. Machen Sie den Trick wie in GitFox oder nehmen Sie meine vorgefertigte Erweiterung, um zu helfen. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überprüfen Sie die Gesten an den Bildschirmrändern auf benutzerdefinierte Ansicht</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Navigation Drawer unterstützt dies nicht. Es ist jedoch nicht so schwierig, es mit Ihren Händen zu unterstützen und Einfügungen für Gesten auf dem Bildschirm mit Navigation Drawer neu zu definieren. Vielleicht haben Sie Bildbearbeitungsprogramme, in denen Gesten funktionieren. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Scrollen in ViewPager funktioniert nicht vom Rand aus, sondern nur von der Mitte nach rechts und links</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Google sagt, das sei normal. Wenn Sie den ViewPager vom Rand ziehen, wird dies als Drücken der Taste "Zurück" empfunden. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schließen Sie in ein neues Projekt sofort die gesamte Transparenz ein</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sie können Designern mitteilen, dass Sie keine Navigationsleiste und keine Statusleiste haben. </font><font style="vertical-align: inherit;">Das ganze Quadrat ist Ihr Anwendungsinhalt. </font><font style="vertical-align: inherit;">Und die Entwickler werden bereits herausfinden, wo und was sie ansprechen müssen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nützliche Links:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">@rmr_spb in einem Telegramm - Aufzeichnungen der internen Mitaps von Redmadrobot SPb.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der gesamte Quellcode in diesem Artikel und noch mehr in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es gibt einen separaten Android 10-Zweig, in dem Sie sehen können, wie ich zu all dem gekommen bin und wie ich das neue Android unterstützt habe.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Banes Insetter Library</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es enthält 5-6 Erweiterungen, die ich gezeigt habe. </font><font style="vertical-align: inherit;">Wenden Sie sich zur Verwendung in Ihrem Projekt an die Bibliothek. Wahrscheinlich wird sie auf Android Jetpack verschoben. </font><font style="vertical-align: inherit;">Ich habe sie in meinem Projekt entwickelt und sie scheinen mir besser geworden zu sein.</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Banes </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Artikel</font></a><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488160/index.html">Windows Server 2019 vs. VMware-Snapshots mit Ruhezustand: eine elegante Lösung für das Problem</a></li>
<li><a href="../de488162/index.html">Je höher die Bewertung, desto mehr Geld und umgekehrt</a></li>
<li><a href="../de488164/index.html">SEC-Kampf gegen Telegramm</a></li>
<li><a href="../de488190/index.html">Noch einmal über emotionales Burnout</a></li>
<li><a href="../de488194/index.html">Warum schreiben wir Programme von so schlechter Qualität?</a></li>
<li><a href="../de488198/index.html">Wovor haben die Timlids Angst und warum sollten sie damit aufhören?</a></li>
<li><a href="../de488200/index.html">Die Debatte um die erste Programmiersprache: die endgültige Entscheidung</a></li>
<li><a href="../de488202/index.html">PVS-Studio ist jetzt in Chocolatey: Chocolatey von Azure DevOps überprüfen</a></li>
<li><a href="../de488208/index.html">Jubiläum DUMP2020 - 4 Tage, die Sie nicht vergessen werden</a></li>
<li><a href="../de488210/index.html">Erkennen von Objekten auf Android mit TensorFlow: von der Datenaufbereitung bis zum Start auf dem Gerät</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>