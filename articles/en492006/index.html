<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üî≠ üë≤üèø ‚úçüèº The power of PWA: A video surveillance system with a 300-line neural network JS code üëÇüèø ‚ôêÔ∏è ü•™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! 
 
 Web browsers slowly but surely implement most of the features of the operating system, and there is less and less reason to develop a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>The power of PWA: A video surveillance system with a 300-line neural network JS code</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492006/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Web browsers slowly but surely </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> most of the features of the operating system, and there is less and less reason to develop a native application if you can write a web version (PWA). Cross-platform, rich API, high development speed on TS / JS, and even the performance of the V8 engine - all this is a plus. Browsers have long been able to work with a video stream and run neural networks, that is, we have all the components for creating a video surveillance system with object recognition. Inspired by this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I decided to bring the demo to the level of practical application, which I want to share. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The application records video from the camera, periodically sending frames for recognition in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COCO-SSD</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and if a person is detected, video fragments in portions of 7 seconds begin to be sent to the specified email via the Gmail-API. As in adult systems, prerecording is performed, that is, we save one fragment until the moment of detection, all fragments with detection, and one after. If the Internet is unavailable, or an error occurs while sending, the videos are saved in the local Downloads folder. Using the email allows you to do without the server side, instantly notify the owner, and if an attacker took possession of the device and cracked all the passwords, it will not be able to delete mail from the recipient. Of the minuses - traffic overrun due to Base64 (although it‚Äôs enough for one camera), and the need to collect the final video file from many emails. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The working demo is here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The problems encountered are as follows:</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) The neural network heavily loads the processor, and if you run it in the main thread, lags appear on the videos. Therefore, recognition is placed in a separate thread (worker), although not everything is smooth here. On dual-core prehistoric Linux, everything is perfectly parallel, but on some fairly new 4-core mobile phones - at the moment of recognition (in the worker), the main thread also starts to lag, which is noticeable in the user interface. Fortunately, this does not affect the quality of the video, although it reduces the recognition frequency (it automatically adjusts to the load). This problem is probably related to how different versions of Android distribute threads by core, the presence of SIMD, available video card functions, etc. I can‚Äôt figure it out on my own, I don‚Äôt know the insides of TensorFlow, and I will be grateful for the information.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) FireFox. </font><font style="vertical-align: inherit;">The application works fine under Chrome / Chromium / Edge, however, recognition in FireFox is noticeably slower, in addition, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageCapture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is still not implemented </font><font style="vertical-align: inherit;">(of course, this can be bypassed by capturing a frame from &lt;video&gt;, but it‚Äôs a shame for the fox, because it‚Äôs standard API). </font><font style="vertical-align: inherit;">In general, there was no complete cross-browser accessibility either. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, everything in order.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Getting a camera and microphone</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.video = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'video'</span>)
<span class="hljs-keyword">this</span>.canvas = <span class="hljs-keyword">this</span>.querySelectorAll(<span class="hljs-string">'canvas'</span>)[<span class="hljs-number">0</span>]<font></font>
<font></font>
<span class="hljs-keyword">this</span>.stream = <span class="hljs-keyword">await</span> navigator.mediaDevices.getUserMedia(<font></font>
   {<span class="hljs-attr">video</span>: {<span class="hljs-attr">facingMode</span>: {<span class="hljs-attr">ideal</span>: <span class="hljs-string">"environment"</span>}}, <span class="hljs-attr">audio</span>: <span class="hljs-literal">true</span>}<font></font>
)<font></font>
<span class="hljs-keyword">this</span>.video.srcObject = <span class="hljs-keyword">this</span>.stream
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.video.onloadedmetadata = <span class="hljs-function">(<span class="hljs-params">_</span>) =&gt;</span> resolve()<font></font>
})<font></font>
<span class="hljs-keyword">this</span>.W = <span class="hljs-keyword">this</span>.bbox.width = <span class="hljs-keyword">this</span>.canvas.width = <span class="hljs-keyword">this</span>.video.videoWidth
<span class="hljs-keyword">this</span>.H = <span class="hljs-keyword">this</span>.bbox.height = <span class="hljs-keyword">this</span>.canvas.height = <span class="hljs-keyword">this</span>.video.videoHeight
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we select the main camera of the mobile phone / tablet (or the first one on the computer / laptop), display the stream in a standard video player, after which we wait for the metadata to load and set the dimensions of the service canvas. </font><font style="vertical-align: inherit;">Since the entire application is written in the style of async / await, you have to convert callback-APIs (and there are quite a lot of them) to Promise for uniformity.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video capture</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are two ways to capture video. </font><font style="vertical-align: inherit;">The first is to directly read the frames from the incoming stream, display them on the canvas, modify them (for example, add geo and timestamps), and then take the data from the canvas - for the recorder as an outgoing stream, and for a neural network as separate images. </font><font style="vertical-align: inherit;">In this case, you can do without the &lt;video&gt; element.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.capture = <span class="hljs-keyword">new</span> ImageCapture(<span class="hljs-keyword">this</span>.stream.getVideoTracks()[<span class="hljs-number">0</span>])
<span class="hljs-keyword">this</span>.recorder = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.canvas.captureStream(), {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})<font></font>
<font></font>
grab_video()<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.capture.grabFrame(), <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)
	<span class="hljs-keyword">const</span> img = <span class="hljs-keyword">this</span>.canvas.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.W, <span class="hljs-keyword">this</span>.H)<font></font>
	... <span class="hljs-comment">//    -   img</span>
	... <span class="hljs-comment">//   -    </span>
        <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-keyword">this</span>.grab_video.bind(<span class="hljs-keyword">this</span>))<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second way (working in FF) is to use a standard video player to capture. </font><font style="vertical-align: inherit;">By the way, it consumes less processor time, unlike frame-by-frame display on canvas, but we cannot add an inscription.</font></font><br>
<br>
<pre><code class="javascript hljs">...<font></font>
async <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">grab_video</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">this</span>.canvas.drawImage(<span class="hljs-keyword">this</span>.video, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
	...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The application uses the first option, as a result of which the video player can be turned off during the recognition process. </font><font style="vertical-align: inherit;">In order to save processor, recording is carried out from the incoming stream, and drawing frames on canvas is used only to obtain an array of pixels for a neural network, with a frequency depending on the recognition speed. </font><font style="vertical-align: inherit;">We draw the frame around the person on a separate canvas placed on the player.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neural network loading and human detection</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's all indecently simple. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We start the worker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , after loading the model (for a rather long time) we send an empty message to the main thread, where in the onmessage event we show the start button, after which the worker is ready to receive images. </font><font style="vertical-align: inherit;">Full worker code:</font></font><br>
<br>
<pre><code class="javascript hljs">(<span class="hljs-keyword">async</span> () =&gt; {<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js'</span>)<font></font>
  self.importScripts(<span class="hljs-string">'https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd'</span>)<font></font>
<font></font>
  <span class="hljs-keyword">let</span> model = <span class="hljs-keyword">await</span> cocoSsd.load()<font></font>
  self.postMessage({})<font></font>
<font></font>
  self.onmessage = <span class="hljs-keyword">async</span> (ev) =&gt; {
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> model.detect(ev.data)
    <span class="hljs-keyword">const</span> person = result.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.class === <span class="hljs-string">'person'</span>)
    <span class="hljs-keyword">if</span> (person) <font></font>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bbox</span>: person.bbox})
    <span class="hljs-keyword">else</span>
      self.postMessage({<span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>, <span class="hljs-attr">bbox</span>: <span class="hljs-literal">null</span>})<font></font>
  }<font></font>
})()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the main thread, we </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start the grab_video ()</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function </font><font style="vertical-align: inherit;">only after receiving the previous result from the worker, that is, the detection frequency will depend on the system load.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video recording</font></font></h4><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">this</span>.recorder.rec = <span class="hljs-keyword">new</span> MediaRecorder(<span class="hljs-keyword">this</span>.stream, {<span class="hljs-attr">mimeType</span> : <span class="hljs-string">"video/webm"</span>})
<span class="hljs-keyword">this</span>.recorder.rec.ondataavailable = <span class="hljs-function">(<span class="hljs-params">ev</span>) =&gt;</span> {
   <span class="hljs-keyword">this</span>.chunk = ev.data
   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.detected) {
      <span class="hljs-keyword">this</span>.send_chunk()<font></font>
   } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.recorder.num &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">this</span>.send_chunk()
      <span class="hljs-keyword">this</span>.recorder.num--<font></font>
   }<font></font>
}<font></font>
...<font></font>
this.recorder.rec.start()<font></font>
<span class="hljs-keyword">this</span>.recorder.num = <span class="hljs-number">0</span>
<span class="hljs-keyword">this</span>.recorder.interval = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
   <span class="hljs-keyword">this</span>.recorder.rec.stop()
   <span class="hljs-keyword">this</span>.recorder.rec.start()<font></font>
}, CHUNK_DURATION)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each time the recorder is stopped (we use a fixed interval), the ondataavailable event is raised, where the recorded fragment in the Blob format is transferred, saved in this.chunk and sent asynchronously. Yes, this.send_chunk () returns a promise, but the function takes a long time (encoding in Base64, sending an email or saving the file locally), and we do not wait for it to be executed and do not process the result - therefore there is no await. Even if it turns out that new video clips appear more often than they can be sent, the JS engine arranges the line of promises transparently for the developer, and all the data will be sent / written sooner or later. The only thing worth paying attention to is inside the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">send_chunk ()</font></a><font style="vertical-align: inherit;"> function</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> before the first await, you need to clone the Blob with the slice () method, since the this.chunk link is rubbed every CHUNK_DURATION seconds.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gmail API</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Used to send letters. </font><font style="vertical-align: inherit;">The API is quite old, partly on promises, partly on callbacks, documentation and examples are not plentiful, so I will give the full code. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Authorization</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">we get the application and client keys in the Google developer console. </font><font style="vertical-align: inherit;">In a pop-up authorization window, Google reports that the application has not been verified, and you will have to click "advanced settings" to enter. </font><font style="vertical-align: inherit;">Checking the application in Google turned out to be a non-trivial task, you need to confirm the ownership of the domain (which I do not have), correctly arrange the main page, so I decided not to bother.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'https://apis.google.com/js/api.js'</span>)<font></font>
gapi.load(<span class="hljs-string">'client:auth2'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> gapi.client.init({
         <span class="hljs-attr">apiKey</span>: API_KEY,
         <span class="hljs-attr">clientId</span>: CLIENT_ID,
         <span class="hljs-attr">discoveryDocs</span>: [<span class="hljs-string">'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'</span>],
         <span class="hljs-attr">scope</span>: <span class="hljs-string">'https://www.googleapis.com/auth/gmail.send'</span><font></font>
      }) <font></font>
      <span class="hljs-keyword">if</span> (!gapi.auth2.getAuthInstance().isSignedIn.je) {
         <span class="hljs-keyword">await</span> gapi.auth2.getAuthInstance().signIn()<font></font>
      }<font></font>
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">''</span>
      <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'nav'</span>).style.display = <span class="hljs-string">''</span>
   } <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">this</span>.msg.innerHTML = <span class="hljs-string">'Gmail authorization error: '</span> + <span class="hljs-built_in">JSON</span>.stringify(e, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)<font></font>
   }<font></font>
})<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Email sending</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Base64 encoded strings cannot be concatenated, and this is inconvenient. </font><font style="vertical-align: inherit;">How to send video in binary format, I still did not understand. </font><font style="vertical-align: inherit;">In the last lines, we convert the callback to a promise. </font><font style="vertical-align: inherit;">Unfortunately this has to be done quite often.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> send_mail(subject, mime_type, body) {
   <span class="hljs-keyword">const</span> headers = {
      <span class="hljs-string">'From'</span>: <span class="hljs-string">''</span>,
      <span class="hljs-string">'To'</span>: <span class="hljs-keyword">this</span>.email,
      <span class="hljs-string">'Subject'</span>: <span class="hljs-string">'Balajahe CCTV: '</span> + subject,
      <span class="hljs-string">'Content-Type'</span>: mime_type,
      <span class="hljs-string">'Content-transfer-encoding'</span>: <span class="hljs-string">'base64'</span><font></font>
   }<font></font>
   <span class="hljs-keyword">let</span> head = <span class="hljs-string">''</span>
   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(headers)) head += k + <span class="hljs-string">': '</span> + v + <span class="hljs-string">'\r\n'</span>
   <span class="hljs-keyword">const</span> request = gapi.client.gmail.users.messages.send({
      <span class="hljs-string">'userId'</span>: <span class="hljs-string">'me'</span>,
      <span class="hljs-string">'resource'</span>: { <span class="hljs-string">'raw'</span>: btoa(head + <span class="hljs-string">'\r\n'</span> + body) }<font></font>
   })<font></font>
   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
      request.execute(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
         <span class="hljs-keyword">if</span> (!res.code) <font></font>
            resolve() <font></font>
         <span class="hljs-keyword">else</span> <font></font>
            reject(res)<font></font>
      })<font></font>
   })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saving a video clip to disk. </font><font style="vertical-align: inherit;">We use a hidden hyperlink.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'a'</span>)<font></font>
URL.revokeObjectURL(a.href)<font></font>
a.href = URL.createObjectURL(chunk)<font></font>
a.download = name<font></font>
a.click()</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">State management in the world of web components</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuing the idea presented in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , I brought it to the </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">absurdity of the</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logical end (for the lulz only) and turned the control of the state upside down. </font><font style="vertical-align: inherit;">If usually JS variables are considered as a state, and the DOM is only the current display, then in my case the data source is the DOM itself (since web components are the long-lived DOM nodes), and for using data on the JS side, the web components provide getters / setters for each form field. </font><font style="vertical-align: inherit;">So, for example, instead of uncomfortable checkboxes in styling, simple &lt;button&gt; are used, and the button ‚Äúvalue‚Äù (true is pressed, false is pressed) is the value of the class attribute, which allows you to style it like this:</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-tag">button</span><span class="hljs-selector-class">.true</span> {<span class="hljs-attribute">background-color</span>: red}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
and get the value like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">get</span> <span class="hljs-title">detecting</span>() { <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.querySelector(<span class="hljs-string">'#detecting'</span>).className === <span class="hljs-string">'true'</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I can not advise using this in production, because this is a good way to ditch productivity. </font><font style="vertical-align: inherit;">Although ... the virtual DOM is also not free, and I did not do benchmarks.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offline mode</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, add a little PWA, namely, install a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">service worker</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> who will cache all network requests and allow the application to work without access to the Internet. </font><font style="vertical-align: inherit;">A small nuance - in articles about service workers, they usually give the following algorithm:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the install event - create a new version of the cache and add all the necessary resources to the cache.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the activate event - delete all versions of the cache except the current one.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the fetch event - first we try to take the resource from the cache, and if we did not find it, we send a network request, the result of which is added to the cache.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In practice, such a scheme is inconvenient for two reasons. Firstly, in the worker's code you need to have an up-to-date list of all the necessary resources, and in large projects using third-party libraries, try to keep track of all the attached imports (including dynamic ones). The second problem - when changing any file, you need to increase the version of the service worker, which will lead to the installation of a new worker and invalidation of the previous one, and this will happen ONLY when the browser is closed / opened. A simple page refresh will not help - the old worker with the old cache will work. And where is the guarantee that my clients will not keep the browser tab forever? Therefore, first we make a network request, we add the result to the cache asynchronously (without waiting for the permission resolution cache.put (ev.request, resp.clone ())), and if the network is unavailable, then we get it from the cache. Better to lose a daythen fly in 5 minutes ¬©.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unresolved issues</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On some mobile phones, the neural network slows down, maybe in my case, COCO-SSD is not the best choice, but I'm not an ML expert, and I took the first one that was heard.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did not find an example of how to send video via GAPI not in Base64 format, but in the original binary. </font><font style="vertical-align: inherit;">This would save both processor time and network traffic.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I did not understand security. </font><font style="vertical-align: inherit;">For local debugging purposes, I added the localhost domain to the Google application, but if someone starts using the application keys to send spam - will Google block the keys themselves or the sender's account?</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would be grateful for the feedback. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources on github. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thank you for the attention.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en491994/index.html">Migrating from Cocoapods to Swift Package Manager</a></li>
<li><a href="../en491996/index.html">More about Coroutines in C ++</a></li>
<li><a href="../en492000/index.html">Product very first. Burnout</a></li>
<li><a href="../en492002/index.html">Light-Absorbing Wings: The Secret to Super Black Butterflies</a></li>
<li><a href="../en492004/index.html">How to grow from a programmer to a manager (‚ÄúI want to be the mistress of the sea‚Äù)</a></li>
<li><a href="../en492008/index.html">Results of IT motivation research: are developers happy with their work?</a></li>
<li><a href="../en492010/index.html">The dark side of the design system and what to do with it</a></li>
<li><a href="../en492012/index.html">Gyenno stabilization cookware compensates for up to 80% tremor</a></li>
<li><a href="../en492016/index.html">ABP and everything, everything, everything: automatic reserve entry in the data center</a></li>
<li><a href="../en492018/index.html">Exceeding speed: risks and vulnerabilities in the field of intelligent transport systems</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>