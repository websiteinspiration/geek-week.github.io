<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☝🏿 👨🏽‍✈️ 🍆 時間の重い負担。Yandexは時間を扱う際の一般的な間違いについて報告しています 🐭 🌶️ 🍧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="さまざまなプロジェクトのコードでは、多くの場合、アプリケーションのロジックをユーザーの現在の時刻に関連付けるなど、時間どおりに操作する必要があります。シニアインターフェース開発者Victor Khomyakovビクターホミヤコフさまざまな作者によるJava、C＃、JavaScriptのプロジェクトで...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>時間の重い負担。Yandexは時間を扱う際の一般的な間違いについて報告しています</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/463203/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなプロジェクトのコードでは、多くの場合、アプリケーションのロジックをユーザーの現在の時刻に関連付けるなど、時間どおりに操作する必要があります。</font><font style="vertical-align: inherit;">シニアインターフェース開発者Victor Khomyakov</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビクターホミヤコフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな作者によるJava、C＃、JavaScriptのプロジェクトで発生した典型的なエラーについて説明しました。彼らは同じタスクに直面しました：現在の日時を取得する、間隔を測定する、またはコードを非同期で実行します。</font><font style="vertical-align: inherit;">
-Yandexの前は、他の食品会社で働いていました。それはフリーランサーのようなものではありません-私は書き、合格し、忘れました。 1つのコードベースで作業するには非常に長い時間がかかります。そして私は実際にさまざまな言語で多くのコードを見て、読んで、書いて、そして興味深いものをたくさん見ました。その結果、この物語のテーマが生まれました。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/na/mz/ir/namzirvbhnouwgv9_d4qv2xubbw.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、さまざまな言語のさまざまなプロジェクトで、同じまたは非常によく似たタスクが発生することを確認しました-日付、時刻での作業。このような作業自体に加えて、日付と時刻のオブジェクトを含むコードのポップアップ操作にすることもできます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/72/sz/6t72szwcjb1qeuqxrka34otqyqu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがフロントエンドかバックエンドかに関係なく、非同期コードを操作するための同様のタスクがあることがわかります。バックエンドにいる場合、これらはデータベースへのクエリ、リモート呼び出しです。フロントエンドなら-あなたは当然AJAXを持っています。さまざまなプロジェクトのさまざまな人々がこれらの問題をほぼ同じ方法で解決します。これが人間の本質です。同様のタスクで、あなたが考える言語に関係なく、同様の決定をします。そして同時に、あなた-私たち-が非常によく似た間違いをすることは論理的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に何を話したいですか？あなたが書いた言語に関係なく発生するこれらの繰り返しパターン、簡単にできるエラー、そしてどのようにしないかについて。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分は、実際には、時間に専念しています。ご存知のように、時間が移動します。例：昨日、丸一日分のレポートを作成する必要があります。データベースにリクエストを行い、日付が昨日以上で今日未満のすべてのレコードを取得する必要があります。つまり、「今日から1日を引いた日」から、今日を除いた今日の日付までを開始します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/uv/2e/vsuv2eoscmtsccq9me53z1ewlx4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、一般的には、直線的にコードを記述します。開始日-今日から1日を引いた日、終了日-今日。すべてが機能しているように見えますが、正確には真夜中に奇妙なことが起こります。開始日はこちらです。開始日から1日を引いた値-これが判明します。その後、何らかの理由で、レポートの終了日が完全に異なります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s7/8b/yq/s78byqfcjbyziwbvnofbrm5zzcu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなた、またはあなたの上司は、1日ではなく2日間レポートを受け取ります。テクニカルマネージャーとマネージャーが来て、不満を言い、6か月後に別のチームに切り替えるよう丁寧に指示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c3/tp/om/c3tpom_hfq_dgh6qkmbmbi8ygwu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、あなたは新しい知識で豊かになります。あなたは時間が止まらないことを理解しています。つまり、Date.now（）を2回呼び出すか、新しいDate（）を取得しても、同じ値を取得することを望んでいません。時々同じかもしれませんが、同じではないかもしれません。したがって、メソッドが1つ、ロジックが1つしかない場合、現在の時点でのDate.now（）の呼び出しまたは新しいDate（）の取得は1回のみである可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、もう一方で、データ処理ストリームでは、意味によって関連するすべての値（レポートの最初と最後）を1つのオブジェクトから厳密に計算する必要があります。たとえば、似たような2つからではなく、1つからのものです。あなたはこの新しい知識で豊かになり、新しいチームに移動します。そこでは、人々はコードのスピードとパフォーマンスについてもっと心配しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/qh/bf/mrqhbf7xune8sjfofoe9vnzjnn4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コードにロギングをオーバーレイし、操作の実行にかかる時間を測定することを提案しています。これが難しい操作である場合は、クライアントの速度が低下しないことが重要です。ノード上でバックエンドに何かを書き込むと、それも難しいトランザクションであり、「ログに記録にかかる時間を書き込んでください。そうすれば、ユーザーエージェントに応じて顧客の動作を計算します。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、すでに2人の新しいボスがあなたのところにやって来て、ログにエントリを表示します。そこで、突然マイナスの時間を記録します。また、6か月後に別のチームに切り替えるよう丁寧に指示しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/36/y7/bh/36y7bhc9hjrkcj0nwuozz5-xhsg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際には、使用する日付と時刻を取得する方法についての貴重な知識を得ることができます。これらの方法は、オペレーティングシステムの時計の現在の状態を示すだけです。また、一律の変更を保証するものでもありません。つまり、リアルタイムの2番目の場合、Date.now（）は1秒間ジャンプし、もう少し-少し少なくなります。そして原則として、彼らは一般的に変化の単調さを保証しない。つまり、この例のように、突然減少する場合があり、Date.now（）の値が突然減少する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理由は何ですか？時間同期。 Linuxのようなシステムには、NTPデーモンなどがあります。これは、オペレーティングシステムのクロックをインターネット上の正確なクロックと同期させます。ラグやリードがあると、人為的に時計の速度が遅くなったり、速くなったり、非常に大きな時間差がある場合に、目立たないステップでジャンプしたり、1回のジャンプだけでは適切な時間を捉えられないことを理解します。それを変更します。その結果、時計の読み取り値にギャップが生じます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、非常に複雑にすることもできます。時計を制御できるユーザー自身が、時計を変更することもできます。彼は本当にしたかった。そして私たちは彼を止める権利はありません。そして、ログでは休憩をとります。したがって、この問題の解決策もすでに存在しています。それは簡単です：時間プロバイダーがあります。ブラウザを使用している場合、これはperformance.now（）です。Nodeで記述している場合、高解像度タイマーがあり、どちらも均一性と単調性のこれらのプロパティを持っています。つまり、タイムスタンプのこれらのサプライヤは、常に増加するだけであり、同時にリアルタイムの1秒で均等に増加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h6/ul/c5/h6ulc5xuufzdzxy3mjvzykkergg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バックエンドにも同じ問題があります。どの言語を書いてもかまいません。たとえば、単調で一貫性のある時計を検索すると、問題が発生し、ほとんどすべての言語が表現されます。 Rustにも同じ問題があります。また、PythonやJava、その他の言語を使用しているプログラマーの苦痛もあります。これらの言語では、人々は熊手も踏んでいます、この問題は既知です、解決策があります。たとえば、Javaの場合、均一性と単調性の同じプロパティを持つ呼び出しがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ファッショナブルなマイクロサービスなどの分散システムを使用している場合は、さらに複雑になります。 N種類のマシンにはN種類のサービスがあり、一般に、時計は原則として1つの表示に収束することさえできず、期待することすらありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ロギングアクションに問題がある場合は、時間ベクトルのみをログに記録できます。結局のところ、1つの要求の処理に関与するN個のシステムからN回ログを記録します。または、単純に増加する抽象カウンターに移動します。1、2、3、4、5だけです。このマシンでは、各操作で均等に刻みます。そして、さまざまなマシンでのリクエスト処理のこれらすべての段階をリンクし、いつ、何が、どのような順序で発生するかについてある程度理解するために、そのようなカウンターを記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、忘れないでください。フロントエンドまたはバックエンドで、フロントエンドと密接に連携している場合、フロントエンドとバックエンドも分散システムです。また、クライアントの作業のある種の複雑なセッションにも興味がある場合は、まず、混同しないようにしてください。ログを確認すると、何時に表示されますか。「ここに、この操作が何度も発生した記録があります。 「-サーバー時間またはクライアント時間はわかりますか？」そして、2番目に、両方の時間を収集してみます。これは、前述のとおり、時間は異なる方向に進む可能性があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間の十分。 2番目の部分はより不安定です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/l-/qb/6_/l-qb6_jajxvvpdtl-zjoqnv8buw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに例があります。ユーザーが自分が何を望んでいるのか正確にわからない場合は、非常に便利なインターフェース要素があります。これは提案、またはオートコンプリートと呼ばれます。リクエストを続行するオプションを彼に伝えることができます。つまり、ユーザーにとってこれは非常に大きなメリットです。何をさらに募集できるかがわかっていることをすぐに彼に示すと、彼が働くほうがはるかに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、残念なことに、少し遅いネットワークを取得した場合、または回答、継続オプションを提供するバックエンドがスローダウンした場合、そのような興味深い効果を得ることができます。ユーザーがタイプしてタイプすると、正しい答えが出て、それが表示され、すべてが壊れます。どういうわけか、私たちが見たかったものをまったく見ていません。ここでは、正しい答えが表示され、すぐにある種の中間状態に対してナンセンスになります。繰り返しますが、まったくの痛みと苦しみ。上司が来て、このバグを修正するように頼みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m9/or/5k/m9or5ke01ifxiy_u3peyvcgnpeg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは理解し始めます。何を手に入れますか？ユーザーがテキストを入力すると、順次非同期リクエストが生成されます。つまり、彼がなんとかタイプしたものを、バックエンドに送信します。彼はさらにダイヤルし、バックエンドの2番目の要求を送信します。コールバックがまったく同じシーケンスで呼び出されることを誰も保証していません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j7/g2/5x/j7g25x0vqaoqeaisui8_cygciuk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、可能なクエリとコールバックのオプションです。私たちが書くときに最も明白なことは、最初の要求を送信し、最初の応答を受信し、2番目の要求を送信し、回答を受信したことです。ユーザーが非常にすばやくタイプする場合、最初の要求を送信するために管理した2番目のオプションを考え出すことができます。ユーザーは最初の回答を受け取る前に何かをタイプすることができました。その後、最初の答え、2番目の答えが来ました。そして、これがビデオで見たものです。提案が正しく機能しなかった場合、これは3番目のオプションです。これはしばしば忘れられがちですが、一般的に、誰も答えの順序を保証しません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_x/n1/9w/_xn19w1mud_c-xro52pcybgtacs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、フロントエンドベンダーでは、インターフェイスを開発している場合、この問題は非常に一般的です。特に、先ほど見たサジェストとオートコンプリートの例です。つまり、要求のストリームがあり、非同期に到着する応答のストリームがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タブがある場合。手を挙げて、GitHubでこれまでに少なくとも1つのプルリクエストを行ったのは誰ですか？実際には、タブ付きのインターフェースがベースになっていることを覚えています。つまり、コメントのシーケンスがあるタブがあり、コミットのあるタブがあり、コード自体のあるタブがあります。これはそのようなタブ付きインターフェースです。また、隣接するタブに切り替えると、そのコンテンツは初めて非同期で読み込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のタブをすばやくクリックすると、タブがオンになり、コンテンツのロードが点滅する場合があります。そして、結局のところ、正しいタブのコンテンツが表示されることは事実ではありません。もちろん、正しい場合は、独自のタブを記述しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、店舗がある場合、商品をバスケットにすばやくドラッグします。迅速で鋭いユーザーが10個の商品をドラッグしたところ、価格が急上昇しており、相対的に100ルーブル、10ルーブル、50ルーブル、75ルーブルで、1ルーブルで止まっています。彼はあなたを信じていない、彼はあなたが下手に書いていて、あなたは彼をだまそうとしていると思って、何も買わずにあなたの店を去ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例。スクラムやかんばんなどの種類があり、電子ボードを使用してカードをドラッグアンドドロップする場合、カードをドラッグしたときに少なくとも1回はカードを逃し、間違った列にドロップしました。これは起こりましたか？もちろん、あなたは自分を捕まえて、すぐにそれを鋭くつかんで、それがあるべき場所にドラッグします。この場合、非常に迅速に2つのクエリを生成します。そして別のシステムではその直後に発生するバグがあります。あなたはそれを正しい列にドラッグしました-答えは最初のリクエストになり、カードは再びそれを転送した列にジャンプします。それは非常に醜いことが判明しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ss/v-/um/ssv-um8sifk1wwoisjwjtaikwc0.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
道徳とは何ですか？同じタイプのリクエストのソースがあるとします。次に、可能であれば、次のリクエストが到着した場合は、リソースを無駄にしないようにすべての不完全なリクエストを中断して、バックエンドが認識できるようにします-もう必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、応答を処理するときに、すべてを制御することもできます。また、不要な前のリクエストで応答が届いた場合も、明示的に無視します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cy/f5/2d/cyf52drbcswd_tva97qt3wrujtg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、問題は古くから存在しており、解決策もすでに存在しています。たとえば、RxJSライブラリ。これはドキュメンテーションの例であり、正しいHello world、正しいオートコンプリートの記述方法です。箱から出してすぐに、古い誤った要求に対する回答は無視されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k5/fu/n0/k5fun031njwsqo4jllunepiuqli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReduxとRedux-Sagaについて書いている場合、それも一般にあり、すべてドキュメントにも記載されています。しかし、そこには深く埋もれており、そのようなバグであるとは明らかに言われていません。そのように修正します。説明だけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactに移動したので、さらにそれに近づきます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/a7/an/w-/a7anw-a_ssygckkmxzmolykeau8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、リポジトリにある実際のコードの一部です。誰かが私たちと一緒にカードを引きます。また、地図を取得する際には、ユーザーのいる場所にマークを表示することをお勧めします。しかし、これはすべてブラウザで行われています。つまり、地理位置情報が有効になっている場合は、座標を取得し、地図上の位置を直接示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジオロケーションが許可されていない場合、またはそこで何らかのエラーが発生した場合は、エラーのある種類のダイスを表示することをお勧めします。つまり、ここでは、あなたがどこにいるかを示すことができなかったサイコロを表示し、3秒後にそれを削除して、このサイコロを削除します。おそらくなんとか読みました。また、移動式の物体は、引き込み式のダイのように消えていくと、すぐに注目を集め、すぐに気づき、読むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このコードで何が起きているかを注意深く見れば、3秒後にコンポーネントの状態が変更されます。この3秒間に何かが発生する可能性があります。ユーザーを含めると、このカードを長時間閉じることができ、コンポーネントがマウント解除され、その状態が消去されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bh/lp/x_/bhlpx_dihsf2ls_0cppixopyhfk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、あなたは自分の足を撃ち、3秒で終了する弾道弾道を撃ちます。そして、何をすべきですか？このような保留中の操作を行う場合は、unmountで正しくクリーンアップできることを忘れないでください。そして、他のライフサイクルメソッドを持つ他のフレームワークでも、同じことが論理的です。ある種の破壊、破壊、その他の何かを行ったり、マウントを解除したりするときは、そのようなものをきれいにすることを正しく覚えておく必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qw/xh/5o/qwxh5oamlezktvcvte5oa-dow_0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブラウザのどこからコードを延期できますか？スロットルとデバウンスのようなものがあります。それらには、内部でsetTimeout、setIntervalがあり、すでに説明したとおりです。まだrequestAnimationFrameがあり、requestIdleCallbackがあります。また、AJAXリクエストも-AJAXリクエストのコールバックは遅延して呼び出すことができます。それらのことも忘れないでください、それらも掃除する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/13/vj/fi/13vjfi_winr86dmuuwt2rrxv0lq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてさらに1レベル進んだ場合、最初は問題全体が抽象化され、ある種のライフサイクルを持つある種のコンポーネントが存在することを理解し、コールを延期します。元のオブジェクトよりも寿命の長い、長生きするオブジェクトの内部で作成します。つまり、ライフサイクルが一致せず、ライフスパンが一致しないオブジェクトが2つあります。そして、この2つのバグからすぐに流れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目は私たちが今持っているものです。すでに死んでいますが、長命のオブジェクトが関数へのリンクを保持してそれを呼び出します。 2つ目は、付随するメモリのリークです。つまり、繰り返しますが、長期間有効なオブジェクトはコードへのリンクを保持しており、メモリから収集してクリーンアップすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目の部分は2番目の部分の反対です。逆に、彼女は同期についてです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_e/ug/7p/_eug7prdbbmnkh0bypu1h8f64as.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつものように、約束の連鎖があります-それから、それから、そこに何かがあります。そして、このコードでは、あなたが見れば、あなたがきれいに書いているか、あなたが支持者であるか、少なくとも機能的アプローチ、クリーンな関数、副作用の欠如について聞いたことがあれば、このコードで何かができることが理解できますスピードアップ。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの要求は非同期であるため、明らかに互いに独立しています。これについて確信が持てない場合は、何か間違っていることを書いていることを意味します。つまり、明らかに何らかの副作用やグローバルな状態などがあるということです。うまく書けば、すぐにわかります。ちなみに、ここでは副作用の欠如から、機能の純粋さから明らかな利益があります。なぜなら、このコードを読むと、並列化できることがわかります。それらは互いに独立しています。そして、一般的には、場所によっても交換できる可能性が高いです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/82/bm/g8/82bmg8vj0qjb2vhwr2_vrr0olue.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはこのように行われます。 2つのクエリを並行して実行し、それらが完了するのを待ってから、次のコードを実行します。つまり、利益は何ですか？最初に、コードの実行が速くなるという事実では、1つの要求が2番目の要求を開始するのを待ちません。そして、我々はより速く落ちるでしょう。 2番目のリクエストでエラーが発生した場合、最初のリクエストが実行されるのを待って時間を無駄にすることはなく、すぐに2番目のリクエストに分類されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/mh/uw/ve/mhuwvecacjcdubinn7cbonc9et0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全を期すために、Promise APIには他に何がありますか？ Promise.all（）は、すべてのリクエストを並行して実行し、実行を待ちます。最初に成功するのを待っているPromise.race（）があります。そして、一般的に、標準APIには他に何もありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oh/dc/j_/ohdcj_thprjxpwq0v-7jovrqxq0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題がある場合は、誰かがすでに問題を解決してくれていることをすでに理解しています。非同期タスクを管理するための非常に豊富な選択肢を持つ非同期ライブラリがあります。非同期タスクを並行して実行する方法があります。順次実行する方法があります。非同期イテレータを整理する方法があります。つまり、たとえばforEach（）を実行できる配列があることがわかります。ただし、forEach（）で非同期関数を呼び出す必要がある場合は、すぐに問題が発生し、forEach（）を拒否して自分で何かを作成するか、同じ非同期のものを使用する準備ができている既成のライブラリーを使用します。わかりました、非同期のイテレータの一種でmap（）を呼び出し、forEach（）を呼び出します-すでにボックスに入っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cj/11/88/cj1188ljs2zlifjl11asukrwtk8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の選択肢は、bluebirdライブラリです。彼らが言うように、正しいPromise.any（）があります。つまり、次のようなタスクがあるとします。N個のサイト、N個のURL、および最初に応答したURLにpingを実行する必要がある場合は、それを使用します。たとえば、彼はあなたに近いです、なぜなら彼のpingはより短いからです。そして、残りはまったく答えないかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Promise.race（）を使用すると、Promiseが拒否された場合、実際には、Promise全体が拒否されます。ここでは使用できません。そしてここにPromise.any（）があります-拒否を無視します。つまり、そのようなタスクのためだけのものです。彼はすべての拒否を無視し、最初の解決は成功し、それをさらにあなたに返し、他の人を待つことはありません。非同期タスクを一定の競争度で即座に並行して実行する興味深い方法もあります。つまり、並行するプロミスは5つ以下にする必要があります。1つのパラメーターで書き留めてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じ非同期の反復とコレクションに対して、マップ、削減、それぞれ、フィルターなどを実行できるものがあります。つまり、APIは非同期JSのように配列上に作成されますが、さらに強力です。そこでpromiseのpromise配列を読み込むことができます。このすべてが展開されるまで待機し、それ自体がpromiseを返す非同期イテレーターで反復します。かなり難しい。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、なぜ約束が必要なのでしょうか。私たちはすでに来ています、非同期/待機があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sk/g8/yk/skg8ykh4v7whmiodqt56tt2h_qy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あきらめているようです。簡単なコードを書きます。これがサンプルコードです。これもまた、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ハーマイオニー</font></a><font style="vertical-align: inherit;">と呼ばれる内部ツールです</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Webドライバーに基づいて、ブラウザーでのテスト用に設計されています。再び、ブラウザーを起動し、コードからいくつかのコマンドをブラウザーに転送し、その実行を待って結果を取得します。しかし、コアでは、すべてが非常によく似ています。つまり、これはドライバーのアドオンです。基本的に、すべてがwebdriverと非常によく似ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、再びawaitを使用して、新しいファッショナブルな言語で書いています。つまり、定義チームは非同期です。ブラウザが応答するのを待つ必要があります。しかし、私たちはawaitを使用し、すべてが順調に進んでいるように見えます。ただし、新機能を使用しない場合よりもゆっくりと新機能を使用して作成した点が異なります。私たちは再び待機点を持っているので。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/qa/dy/3qqadyikzcuaokpg9xfephpstbg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちはすでに正しい答えを知っています-Promise.all（）。ここでも、待機中に書き込まれた内容を並列化できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jd/c8/-6/jdc8-6d3yw-_jpvwujdwoaxhx9m.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
道徳性：awaitは、約束よりもシーケンスよりも書くのが簡単です。</font><font style="vertical-align: inherit;">しかし、予期しない追加の同期を行うのも簡単です。これにより、見落としがちです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてもちろん、コードに注意してください。</font><font style="vertical-align: inherit;">単純なルール：互いに独立しているように見える2つの待機が隣にある場合、それらを並列化してコードの実行を高速化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここに私が収集したいくつかの興味深いリンク、ドキュメントへのリンクがあります：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mozilla Developer Network </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">のPromiseの説明</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github上の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">非同期ライブラリ</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブルーバードライブラリー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RxJS 4</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリ</font><font style="vertical-align: inherit;">、&nbsp; </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RxJS 5+</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowsおよびPOSIXの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単調クロック-WindowsおよびPOSIX互換システムのさまざまなオペレーティングシステムにおける単調クロックのドキュメント。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ntpdが時計で何をどのように実行するかを選択するときの時刻の調整方法に関する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ドキュメント</font></a><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、生産中の人々が本当の熊手を持っていたときの叙事詩の失敗、叙事詩の興味深い選択：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、人のNTPデーモンの時刻修正が原因でHadoopクラスターがどのように本番環境に落ちたのかについて説明しています。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間の不均一性が原因で、1秒</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">以内に</font></a><font style="vertical-align: inherit;">発生</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">したCloudflare DNSの問題</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VKontakteでさえ、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味深いバグ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">許可Cookieは1時間の有効期限で記録されました。</font><font style="vertical-align: inherit;">また、タイムゾーンと時間が正しく設定されていない人は、Cookieがすぐに期限切れになり、ログインできず、すぐに捨てられました。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に言いたいことは？</font><font style="vertical-align: inherit;">オープンソースを含む高品質のコードを学びましょう-Lodash、RxJSなど。そこには興味深いことがたくさん書かれており、興味深い問題が解決されています。</font><font style="vertical-align: inherit;">誰かがすでに会って解決した一般的な間違いを避けます。</font><font style="vertical-align: inherit;">ホイールを再発明しないでください。</font><font style="vertical-align: inherit;">そして、あなたがそれを発明した場合、少なくとも車輪は丸いはずであることを知っています。</font><font style="vertical-align: inherit;">私が言いたかったのはそれだけです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja463185/index.html">ボリビアの地震が地下660キロの深さで山を発見した方法</a></li>
<li><a href="../ja463189/index.html">インターネット上の匿名性、生活とその相対性について</a></li>
<li><a href="../ja463193/index.html">非負行列分解を使用して白黒画像をASCIIグラフィックに変換します</a></li>
<li><a href="../ja463195/index.html">Tele2インターネットはどうなりますか</a></li>
<li><a href="../ja463197/index.html">Blazor + MVVM = Silverlightが反撃し、古代の悪は無敵です</a></li>
<li><a href="../ja463205/index.html">最初は動作しない：Windows 10のラップトップと32ギガバイトのドライブで生き残る方法</a></li>
<li><a href="../ja463207/index.html">チャットボットの開発（電報+ YouTube）</a></li>
<li><a href="../ja463213/index.html">初心者C＃開発者の誤解。標準的な質問に答えようとする</a></li>
<li><a href="../ja463215/index.html">エンジニアと建築家はすでに月の集落を設計しています</a></li>
<li><a href="../ja463221/index.html">太陽を見る：5種類のガジェット、5ドルから5,000ドル</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>