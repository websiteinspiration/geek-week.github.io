<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍺 👨🏾‍✈️ 💙 QSerializer: solution pour une sérialisation JSON / XML simple ㊙️ 👩🏿‍⚕️ 🐘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! 
 
 Je pensais que cela se révélait injustement - en Java, C #, Go, Python, etc. Il existe des bibliothèques pour une sérialisation con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QSerializer: solution pour une sérialisation JSON / XML simple</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496836/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pensais que cela se révélait injustement - en Java, C #, Go, Python, etc. </font><font style="vertical-align: inherit;">Il existe des bibliothèques pour une sérialisation confortable des données d'objet en JSON et XML désormais à la mode, mais en C ++, ils ont oublié, ou ne voulaient pas, ou n'en avaient pas vraiment besoin, ou si tout cela est compliqué, ou peut-être tous ensemble. </font><font style="vertical-align: inherit;">J'ai donc décidé de réparer ce truc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les détails, comme d'habitude, sous la coupe.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/cp/vw/j9cpvwvjh9gfvhqxigysyx7m78c.png" alt="image"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contexte</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois de plus, j'ai décidé de reprendre le prochain projet pour animaux de compagnie, dont l'essence était l'échange client-serveur, tandis que le serveur préféré de beaucoup était RaspberryPi. Entre autres choses, je m'intéressais à la question de la création de «points de sauvegarde» - afin que je puisse le plus simplement possible, dans le cadre du prototype, enregistrer l'état de l'objet avant de quitter et de récupérer au prochain démarrage. En raison de mon hostilité déraisonnable envers Python et de mon attitude très chaleureuse envers Qt, j'ai choisi Qt &amp; C ++. Écrire des classes et des fonctions spaghetti pour analyser JSON est toujours un plaisir, j'avais besoin d'une solution universelle et en même temps facile à mon problème. "Nous devons comprendre", me suis-je dit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, un peu sur les termes:</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La sérialisation est le processus de traduction d'une structure de données en une séquence de bits. </font><font style="vertical-align: inherit;">L'inverse de l'opération de sérialisation est l'opération de désérialisation (structuration) - la restauration de l'état initial de la structure de données à partir d'une séquence de bits.</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go a un package d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encodage / json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> «natif» très utile </font><font style="vertical-align: inherit;">qui vous permet de terminer la sérialisation de l'objet en utilisant la méthode Marshal et la structuration inverse en utilisant Unmarshal (à cause de cette bibliothèque, j'ai d'abord eu une idée incorrecte sur le marshaling, mais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desine sperare qui hic intras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) . </font><font style="vertical-align: inherit;">En suivant les concepts de ce paquet, j'ai trouvé une autre bibliothèque pour Java - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui s'est avérée être un produit très agréable, c'était un plaisir de l'utiliser.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai réfléchi à ce que j'aime de ces bibliothèques et suis arrivé à la conclusion que c'était leur facilité d'utilisation. Fonctionnalité flexible et tout en un appel, pour la sérialisation en JSON, il suffisait d'appeler la méthode toJson et de lui passer l'objet sérialisable. Cependant, C ++ lui-même n'a pas, par défaut, les capacités de métaobjet appropriées pour fournir suffisamment d'informations sur les champs d'une classe, comme cela se fait, par exemple, en Java (ClassName.class). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'aimais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QJson que pour la</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> plate </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">forme Qt </font><font style="vertical-align: inherit;">, mais cela ne correspondait pas tout à fait à ma compréhension de la facilité d'utilisation générée par les bibliothèques susmentionnées. Le projet est donc apparu, qui sera discuté ici. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Petit avertissement:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de tels mécanismes ne résoudront pas pour vous le problème de l'interprétation des données. </font><font style="vertical-align: inherit;">Tout ce que vous pouvez en tirer, c'est la conversion des données sous une forme plus pratique pour vous.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure du projet QSerializer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le projet et les exemples peuvent être consultés sur GitHub ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien vers le référentiel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Des instructions d'installation détaillées y sont également fournies. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anticipant le suicide architectural, je ferai une réserve que ce n'est pas la version finale. </font><font style="vertical-align: inherit;">Les travaux se poursuivront malgré les pierres abandonnées, mais en tenant compte des souhaits.</font></font><br>
<img src="https://habrastorage.org/webt/lg/rp/op/lgrpopckj4waexmewif_u2zngf4.png" alt="Dépendances structurelles générales de la bibliothèque QSerializer"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'objectif principal de ce projet est de rendre la sérialisation à l'aide d'un format de données convivial en C ++ accessible et élémentaire. </font><font style="vertical-align: inherit;">La clé du développement de la qualité et de la maintenance du produit est son architecture. </font><font style="vertical-align: inherit;">Je n'exclus pas que d'autres modes de mise en œuvre puissent apparaître dans les commentaires de cet article, j'ai donc laissé un peu «d'espace pour la créativité». </font><font style="vertical-align: inherit;">Si vous modifiez l'implémentation, vous pouvez soit ajouter une nouvelle implémentation de l'interface PropertyKeeper, soit modifier les méthodes d'usine afin de ne rien changer dans les fonctions QSerializer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déclaration de champ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une façon de collecter des informations sur les méta-objets dans Qt est de les décrire dans le système de méta-objets de Qt lui-même. </font><font style="vertical-align: inherit;">C'est peut-être le moyen le plus simple. </font></font><abbr title="Compilateur de méta-objets"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOC</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> générera toutes les métadonnées nécessaires au moment de la compilation. </font><font style="vertical-align: inherit;">Vous pouvez appeler la méthode metaObject sur l'objet décrit, qui renverra une instance de la classe QMetaObject, avec laquelle nous devons travailler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour déclarer des champs à sérialiser, vous devez hériter la classe de QObject et y inclure la macro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_OBJECT</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , afin d'indiquer clairement au MOC la qualification du type de classe en tant que type de base de QObject. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la macro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décrit les membres de la classe. </font><font style="vertical-align: inherit;">Nous appellerons la </font><font style="vertical-align: inherit;">propriété propriété </font><font style="vertical-align: inherit;">décrite dans </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">QSerializer ignorera la propriété sans que l'indicateur USER soit défini sur true.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi le drapeau USER</font></font></b>
                        <div class="spoiler_text">     , ,  QML.        . ,   <font color="#FF1493">Q_PROPERTY</font>  QML   QSerializer     .<br>
</div>
                    </div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> :</span> <span class="hljs-keyword">public</span> QObject<font></font>
{<font></font>
Q_OBJECT<font></font>
<span class="hljs-comment">// Define data members to be serialized</span>
Q_PROPERTY(QString name MEMBER name USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">int</span> age MEMBER age USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(QString email MEMBER email USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone MEMBER phone USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">bool</span> vacation MEMBER vacation USER <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// Make base constructor</span><font></font>
  User() { }<font></font>
 <font></font>
  QString name;<font></font>
  <span class="hljs-keyword">int</span> age{<span class="hljs-number">0</span>};<font></font>
  QString email;<font></font>
  <span class="hljs-keyword">bool</span> vacation{<span class="hljs-literal">false</span>};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone; <font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour déclarer des types d'utilisateurs non standard dans le système de méta-objets Qt, je suggère d'utiliser la macro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est définie dans qserializer.h. </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> automatise le processus d'enregistrement des variations de type. </font><font style="vertical-align: inherit;">Cependant, vous pouvez utiliser la méthode classique d'enregistrement de types avec qRegisterMetaType &lt; </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; (). </font><font style="vertical-align: inherit;">Pour un système de méta-objet, le type de classe ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et le pointeur de classe ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *) sont des types complètement différents; ils auront des identifiants différents dans la liste des types généraux.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_METATYPE(Type) qRegisterMetaType<span class="hljs-meta-string">&lt;Type&gt;(#Type) ;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_REGISTER(Type)       \
QS_METATYPE(Type)               \
QS_METATYPE(Type*)              \
QS_METATYPE(std::vector<span class="hljs-meta-string">&lt;Type*&gt;) \</span></span>
QS_METATYPE(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Type&gt;)  \
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// define user-type in Qt meta-object system</span><font></font>
QS_REGISTER(User)<font></font>
...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espace de noms QSerializer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir sur le diagramme UML, QSerializer contient un certain nombre de fonctions de sérialisation et de structuration. </font><font style="vertical-align: inherit;">L'espace de noms reflète conceptuellement l'essence déclarative de QSerializer. </font><font style="vertical-align: inherit;">La fonctionnalité intégrée est accessible via le nom de QSerializer, sans avoir besoin de créer un objet n'importe où dans le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant l'exemple de construction de JSON basé sur l'objet de la classe User décrit ci-dessus, il vous suffit d'appeler la méthode QSerializer :: toJson:</font></font><br>
<br>
<pre><code class="cpp hljs">User u;<font></font>
u.name = <span class="hljs-string">"Mike"</span>;<font></font>
u.age = <span class="hljs-number">25</span>;<font></font>
u.email = <span class="hljs-string">"example@exmail.com"</span>;<font></font>
u.phone.push_back(<span class="hljs-string">"+12345678989"</span>);<font></font>
u.phone.push_back(<span class="hljs-string">"+98765432121"</span>);<font></font>
u.vacation = <span class="hljs-literal">true</span>;<font></font>
QJsonObject json = QSerializer::toJson(&amp;u);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici le JSON résultant:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mike"</span>,
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"example@exmail.com"</span>,
    <span class="hljs-attr">"phone"</span>: [
        <span class="hljs-string">"+12345678989"</span>,
        <span class="hljs-string">"+98765432121"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"vacation"</span>: <span class="hljs-literal">true</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe deux façons de structurer un objet:</font></font><br>
<br>
<ul>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous devez modifier un objet</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">User u;<font></font>
QJsonObject userJson;<font></font>
QSerializer::fromJson(&amp;u, userJson);</code></pre></div>
                    </div></li>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous avez besoin d'obtenir un nouvel objet</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">QJsonObject userJson;<font></font>
User * u = QSerializer::fromJson&lt;User&gt;(userJson);</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Plus d'exemples et de résultats peuvent être vus dans le dossier d' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemples</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gardiens</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour organiser l'écriture et la lecture pratiques des propriétés déclarées, QSerializer utilise des classes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keepers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , chacune d'entre elles stockant un pointeur sur un objet (descendant de QObject) et l'un de ses QMetaProperty. </font><font style="vertical-align: inherit;">QMetaProperty lui-même n'a pas de valeur particulière, en fait, c'est seulement un objet avec une description de la classe de propriétés qui a été déclarée pour le MOC. </font><font style="vertical-align: inherit;">Pour lire et écrire, vous avez besoin d'un objet de classe spécifique, où cette propriété est décrite - c'est la principale chose dont vous devez vous souvenir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chaque champ sérialisable pendant la sérialisation est transmis au dépositaire du type correspondant. </font><font style="vertical-align: inherit;">Des gardiens sont nécessaires pour encapsuler la fonctionnalité de sérialisation et de structuration pour une implémentation spécifique pour un type spécifique de données décrites. </font><font style="vertical-align: inherit;">J'ai mis en évidence 4 types:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaSimpleKeeper - gardien de propriété avec des types de données primitifs</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaArrayKeeper - gardien de propriété avec des tableaux de données primitives</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectKeeper - gardien des objets imbriqués</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectArrayKeeper - gardien des tableaux d'objets imbriqués </font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/dw/ao/0d/dwao0de8yeaqdcdb5zfkbuoof-k.png" alt="Flux de données"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au cœur des dépositaires de données primitifs se trouve la conversion des informations de JSON / XML vers QVariant et vice versa, car QMetaProperty fonctionne avec QVariant par défaut.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaSimpleKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonValue result = QJsonValue::fromVariant(prop.read(linkedObj));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(QString(prop.name()), result);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaSimpleKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;val)</span>
</span>{<font></font>
    prop.write(linkedObj, QVariant(val));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les conservateurs d'objets sont basés sur le transfert d'informations de JSON / XML vers une série d'autres conservateurs et vice versa. </font><font style="vertical-align: inherit;">Ces dépositaires travaillent avec leur propriété en tant qu'objet distinct, qui peut également avoir ses propres dépositaires, leur tâche consiste à collecter des données sérialisées à partir de l'objet propriété et à structurer l'objet propriété en fonction des données disponibles.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaObjectKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;json)</span>
</span>{<font></font>
    ...<font></font>
    QSerializer::fromJson(linkedObj, json.toObject());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaObjectKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonObject result = QSerializer::toJson(linkedObj);;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(prop.name(),QJsonValue(result));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les gardiens implémentent l'interface PropertyKeeper, dont la classe abstraite de base des gardiens est héritée. </font><font style="vertical-align: inherit;">Cela vous permet d'analyser et de composer des documents au format XML ou JSON séquentiellement de haut en bas, en descendant simplement les propriétés stockées décrites et en approfondissant lorsque vous descendez dans les objets incorporés, le cas échéant, dans les propriétés décrites, sans entrer dans les détails de l'implémentation.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface PropertyKeeper</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyKeeper</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~PropertyKeeper() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">toJson</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue&amp;)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QDomNode&gt; <span class="hljs-title">toXml</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromXml</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QDomNode &amp;)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Guardian Factory</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que tous les dépositaires implémentent une interface, toutes les implémentations sont masquées derrière un écran pratique, et un ensemble de ces implémentations est fourni par la fabrique KeepersFactory. </font><font style="vertical-align: inherit;">À partir de l'objet transféré à l'usine, vous pouvez obtenir une liste de toutes les propriétés déclarées via son QMetaObject, en fonction du type de dépositaire déterminé.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mise en œuvre de KeepersFactory Factory</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">int</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">bool</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">double</span>&gt;(),<font></font>
        qMetaTypeId&lt;QString&gt;(),<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">array_of_simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;(),<font></font>
    };<font></font>
...<font></font>
<span class="hljs-function">PropertyKeeper *<span class="hljs-title">KeepersFactory::getMetaKeeper</span><span class="hljs-params">(QObject *obj, QMetaProperty prop)</span>
</span>{
    <span class="hljs-keyword">int</span> t_id = QMetaType::type(prop.typeName());
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">simple_t</span>.begin(), <span class="hljs-keyword">simple_t</span>.end(), t_id) != <span class="hljs-keyword">simple_t</span>.end())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaSimpleKeeper(obj,prop);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">array_of_simple_t</span>.begin(),<span class="hljs-keyword">array_of_simple_t</span>.end(), t_id) != <span class="hljs-keyword">array_of_simple_t</span>.end())<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>( t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">int</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;QString&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">double</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">bool</span>&gt;(obj, prop);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        QObject * castobj = qvariant_cast&lt;QObject *&gt;(prop.read(obj));<font></font>
        <span class="hljs-keyword">if</span>(castobj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectKeeper(castobj,prop);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QString(prop.typeName()).contains(<span class="hljs-string">"std::vector&lt;"</span>))<font></font>
        {<font></font>
            QString t = QString(prop.typeName()).remove(<span class="hljs-string">"std::vector&lt;"</span>).remove(<span class="hljs-string">"&gt;"</span>);
            <span class="hljs-keyword">int</span> idOfElement = QMetaType::type(t.toStdString().c_str());
            <span class="hljs-keyword">if</span>(QMetaType::typeFlags(idOfElement).testFlag(QMetaType::PointerToQObject))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectArrayKeeper(obj, prop);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">throw</span> QSException(UnsupportedPropertyType);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper *&gt; <span class="hljs-title">KeepersFactory::getMetaKeepers</span><span class="hljs-params">(QObject *obj)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper*&gt; keepers;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj-&gt;metaObject()-&gt;propertyCount(); i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(obj-&gt;metaObject()-&gt;property(i).isUser(obj))<font></font>
            keepers.push_back(getMetaKeeper(obj, obj-&gt;metaObject()-&gt;property(i)));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> keepers;<font></font>
}<font></font>
...<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une caractéristique clé de la fabrique de gardiens est la possibilité de fournir une série complète de gardiens pour un objet, et vous pouvez étendre la liste des types primitifs pris en charge en modifiant des collections constantes avec des identificateurs de type. </font><font style="vertical-align: inherit;">Chaque série de gardiens est une sorte de carte pour les propriétaires de l'objet. </font><font style="vertical-align: inherit;">Lorsqu'un objet KeepersFactory est détruit, la mémoire allouée à la série de keepers qu'il fournit est libérée.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limitations et comportement</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situation</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comportement</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tenter de sérialiser un objet dont le type n'est pas hérité de QObject</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erreur de compilation</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Type non déclaré lors d'une tentative de sérialisation / struturisation</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exception QSException :: UnsupportedPropertyType</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une tentative de sérialiser / structurer un objet avec un type primitif différent de celui décrit dans les collections simple_t et array_of_simple_t.</font></font></td>
<td> QSException::UnsupportedPropertyType.    ,     —     ,   </td>
</tr>
<tr>
<td> JSON/XML   </td>
<td>  </td>
</tr>
<tr>
<td>   propertyes,    JSON/XML</td>
<td> propertyes .       —  propertyes          </td>
</tr>
<tr>
<td>      JSON  property </td>
<td> QSException</td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À mon avis, le projet s'est avéré utile, car cet article a été écrit. </font><font style="vertical-align: inherit;">Pour ma part, j'ai conclu qu'il n'y a pas de solutions universelles, il faut toujours sacrifier quelque chose. </font><font style="vertical-align: inherit;">En développant une flexibilité, en termes d'utilisation, de fonctionnalité, vous tuez la simplicité, et vice versa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne vous conseille pas d'utiliser QSerializer, mon objectif est plutôt mon propre développement en tant que programmeur. </font><font style="vertical-align: inherit;">Bien sûr, je poursuis également l'objectif d'aider quelqu'un, mais en premier lieu - simplement me faire plaisir. </font><font style="vertical-align: inherit;">Sois positif)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr496824/index.html">Votre environnement de travail nordique</a></li>
<li><a href="../fr496826/index.html">Des millions de sprites à plus de 120 images par seconde</a></li>
<li><a href="../fr496828/index.html">Où trouver des freelances qui seront amusants? (Spoiler: pas Upwork)</a></li>
<li><a href="../fr496830/index.html">Qu'est-ce que la communication émergente et pourquoi vous devez savoir</a></li>
<li><a href="../fr496832/index.html">Visite photo: que font-ils dans le laboratoire de nanophotonique hybride et d'optoélectronique du New Physics Institute ITMO</a></li>
<li><a href="../fr496838/index.html">Méthodologie de déploiement de projet utilisée par Slack</a></li>
<li><a href="../fr496840/index.html">Musk pense que 12 000 satellites n'interféreront pas avec les astronomes. Son opinion n'est pas conforme au modèle</a></li>
<li><a href="../fr496842/index.html">Un modèle épidémique simple avec des outils de base Python</a></li>
<li><a href="../fr496846/index.html">Mécanique du langage des piles et des pointeurs</a></li>
<li><a href="../fr496848/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 340 (du 6 au 12 avril)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>