<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧤 👨🏼‍🍳 👈🏽 Delta: Plattform für Datensynchronisation und -anreicherung 🍷 📨 🏠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Vorgriff auf den Start eines neuen Streams im Data Engineer- Kurs haben wir eine Übersetzung von interessantem Material vorbereitet.
 
 
 
 
 
 Übe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Delta: Plattform für Datensynchronisation und -anreicherung</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/487460/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Vorgriff auf den Start eines neuen Streams im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Engineer-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurs </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">haben wir</font></a><font style="vertical-align: inherit;"> eine Übersetzung von interessantem Material vorbereitet.</font></font><br>
</b></i><br>
<br>
<img src="https://habrastorage.org/webt/pg/_y/c6/pg_yc6ttjvtbnkh2-rhe_eq1dnw.png"><br>
<br>
<hr><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Überblick</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Wir werden über ein ziemlich beliebtes Muster sprechen, nach dem Anwendungen mehrere Datenspeicher verwenden, wobei jeder Speicher für seine eigenen Zwecke verwendet wird, um beispielsweise die kanonische Form von Daten (MySQL usw.) zu speichern und erweiterte Suchfunktionen (ElasticSearch usw.) bereitzustellen. .), Caching (Memcached usw.) und andere. Wenn Sie mehrere Datenspeicher verwenden, fungiert normalerweise einer als Hauptspeicher und der andere als Derivatspeicher. Das einzige Problem ist, wie diese Datenspeicher synchronisiert werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben uns verschiedene Muster angesehen, mit denen versucht wurde, das Problem der Synchronisierung mehrerer Repositorys zu lösen, z. B. doppelte Eingabe, verteilte Transaktionen usw. </font><font style="vertical-align: inherit;">Diese Ansätze weisen jedoch erhebliche Einschränkungen hinsichtlich der tatsächlichen Verwendung, Zuverlässigkeit und Wartung auf. </font><font style="vertical-align: inherit;">Zusätzlich zur Datensynchronisation müssen einige Anwendungen Daten durch Aufrufen externer Dienste anreichern.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um diese Probleme zu lösen, wurde Delta entwickelt. </font><font style="vertical-align: inherit;">Delta ist letztendlich eine konsistente, ereignisgesteuerte Plattform zum Synchronisieren und Anreichern von Daten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bestehende Lösungen</font></font></h3><br>
 <h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doppelte Einreise</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Um zwei Datenspeicher zu synchronisieren, können Sie die doppelte Aufzeichnung verwenden, die in einen Speicher schreibt und dann sofort in einen anderen schreibt. Der erste Datensatz kann wiederholt werden, und der zweite kann unterbrochen werden, wenn der erste nach Erschöpfung der Anzahl der Versuche fehlschlägt. Zwei Datenspeicher werden jedoch möglicherweise nicht mehr synchronisiert, wenn das Schreiben in den zweiten Speicher fehlschlägt. Dieses Problem wird normalerweise gelöst, indem ein Wiederherstellungsverfahren erstellt wird, mit dem Daten regelmäßig vom ersten Speicher in den zweiten Speicher übertragen werden können, oder dies nur, wenn Unterschiede in den Daten festgestellt werden. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Durchführen eines Wiederherstellungsvorgangs ist ein bestimmter Job, der nicht wiederverwendet werden kann. </font><font style="vertical-align: inherit;">Darüber hinaus bleiben die Daten zwischen den Speichern nicht synchron, bis der Wiederherstellungsvorgang abgeschlossen ist. </font><font style="vertical-align: inherit;">Die Lösung ist kompliziert, wenn mehr als zwei Datenspeicher verwendet werden. </font><font style="vertical-align: inherit;">Schließlich kann das Wiederherstellungsverfahren die ursprüngliche Datenquelle belasten.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protokolltabelle ändern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Wenn Änderungen in einer Reihe von Tabellen auftreten (z. B. Einfügen, Aktualisieren und Löschen von Datensätzen), werden Änderungsdatensätze als Teil derselben Transaktion zur Protokolltabelle hinzugefügt. Ein anderer Thread oder Prozess fordert ständig Ereignisse aus der Protokolltabelle an und schreibt sie in einen oder mehrere Datenspeicher, wenn Ereignisse nach Bestätigung des Datensatzes durch alle Speicher aus der Protokolltabelle gelöscht werden müssen. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dieses Muster sollte als Bibliothek implementiert werden und im Idealfall ohne den Anwendungscode zu ändern, der es verwendet. In einer polyglotten Umgebung muss die Implementierung einer solchen Bibliothek in einer beliebigen Sprache vorhanden sein, es ist jedoch sehr schwierig, die Koordination der Funktionen und des Verhaltens zwischen den Sprachen sicherzustellen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Problem besteht darin, Schemaänderungen in Systemen zu erhalten, die keine Transaktionsschemaänderungen unterstützen [1] [2], wie z. B. MySQL. </font><font style="vertical-align: inherit;">Daher funktioniert eine Vorlage zum Vornehmen einer Änderung (z. B. zum Ändern eines Schemas) und zum Schreiben in die Änderungsprotokolltabelle nicht immer.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verteilte Transaktionen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Verteilte Transaktionen können verwendet werden, um eine Transaktion auf mehrere heterogene Datenspeicher aufzuteilen, sodass der Vorgang entweder in allen verwendeten Speichern festgeschrieben oder in keinem von ihnen festgeschrieben wird. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Probleme:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verteilte Transaktionen sind ein sehr großes Problem für heterogene Data Warehouses. </font><font style="vertical-align: inherit;">Sie können sich naturgemäß nur auf den kleinsten gemeinsamen Nenner der beteiligten Systeme verlassen. </font><font style="vertical-align: inherit;">Beispielsweise blockieren XA-Transaktionen die Ausführung, wenn während des Vorbereitungsprozesses ein Fehler auftritt. </font><font style="vertical-align: inherit;">Darüber hinaus bietet XA keine Deadlock-Erkennung und unterstützt keine optimistischen Parallelitätsverwaltungsschemata. </font><font style="vertical-align: inherit;">Darüber hinaus unterstützen einige Systeme wie ElasticSearch weder XA noch ein anderes heterogenes Transaktionsmodell. </font><font style="vertical-align: inherit;">Daher bleibt es für Anwendungen eine sehr schwierige Aufgabe, die Atomizität der Aufzeichnung in verschiedenen Datenspeichertechnologien sicherzustellen [3].</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delta</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Delta wurde entwickelt, um die Einschränkungen bestehender Datensynchronisationslösungen zu beseitigen und Daten im laufenden Betrieb anzureichern. Unser Ziel war es, all diese komplexen Punkte von Anwendungsentwicklern zu abstrahieren, damit sie sich voll und ganz auf die Implementierung von Geschäftsfunktionen konzentrieren können. Als nächstes beschreiben wir "Movie Search", den eigentlichen Anwendungsfall für Netflix's Delta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Netflix nutzt die Microservice-Architektur in großem Umfang und jeder Microservice bedient normalerweise einen Datentyp. Die Hauptinformationen über den Film werden in einem Mikrodienst namens Movie Service herausgenommen, und verwandte Daten, wie Informationen über Produzenten, Schauspieler, Anbieter usw., werden von mehreren anderen Mikrodiensten verwaltet (nämlich Deal Service, Talent Service und Vendor Service).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Geschäftsanwender in Netflix Studios müssen häufig nach verschiedenen Kriterien nach Filmen suchen, weshalb es für sie sehr wichtig ist, alle Daten zu Filmen durchsuchen zu können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor Delta musste das Filmsuche-Team Daten von mehreren Microservices abrufen, bevor Filmdaten indiziert werden konnten. Darüber hinaus musste das Team ein System entwickeln, das den Suchindex regelmäßig aktualisiert und Änderungen von anderen Microservices anfordert, auch wenn überhaupt keine Änderungen vorgenommen wurden. Dieses System wurde schnell von Komplexität überwachsen und schwer zu warten. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tc/kb/t9/tckbt9vwkwiqmilkt4y18gjqbjs.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1. Abfragesystem vor Delta</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Nach der Verwendung von Delta wurde das System zu einem ereignisgesteuerten System vereinfacht, wie in der folgenden Abbildung dargestellt. CDC-Ereignisse (Change-Data-Capture) werden über den Delta-Connector an Keystone Kafka-Themen gesendet. Eine Delta-Anwendung, die mit dem Delta Stream Processing Framework (basierend auf Flink) erstellt wurde, empfängt CDC-Ereignisse aus dem Thema, bereichert sie, ruft andere Microservices auf und übergibt die angereicherten Daten schließlich an den Suchindex in Elasticsearch. Der gesamte Prozess findet fast in Echtzeit statt, dh sobald Änderungen im Data Warehouse erfasst werden, werden die Suchindizes aktualisiert. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bz/lg/t4/bzlgt47eyfuw8wlbzv2dsx6i3ge.png"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2. Datenpipeline mit Delta</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In den folgenden Abschnitten beschreiben wir die Arbeit des Delta-Connector, der eine Verbindung zum Repository herstellt und CDC-Ereignisse auf Transportebene veröffentlicht. Hierbei handelt es sich um eine Echtzeit-Datenübertragungsinfrastruktur, die CDC-Ereignisse zu Kafka-Themen leitet. </font><font style="vertical-align: inherit;">Ganz am Ende werden wir über das Delta-Stream-Verarbeitungsframework sprechen, das Anwendungsentwickler für die Verarbeitungs- und Anreicherungslogik verwenden können.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CDC (Change-Data-Capture)</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Wir haben einen CDC-Dienst namens Delta-Connector entwickelt, der festgeschriebene Änderungen aus dem Datenspeicher in Echtzeit erfassen und in den Stream schreiben kann. </font><font style="vertical-align: inherit;">Änderungen in Echtzeit werden aus dem Transaktionsprotokoll und den Speicherabbildern übernommen. </font><font style="vertical-align: inherit;">Dumps werden verwendet, da in Transaktionsprotokollen normalerweise nicht der gesamte Änderungsverlauf gespeichert wird. </font><font style="vertical-align: inherit;">Änderungen werden normalerweise als Delta-Ereignisse serialisiert, sodass sich der Empfänger keine Gedanken darüber machen muss, woher die Änderung stammt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delta-Connector unterstützt mehrere zusätzliche Funktionen, wie z.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Möglichkeit, benutzerdefinierte Ausgaben nach Kafka zu schreiben.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Möglichkeit, manuelle Speicherauszüge jederzeit für alle Tabellen, eine bestimmte Tabelle oder für bestimmte Primärschlüssel zu aktivieren.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dumps können von Brocken aufgenommen werden, sodass Sie im Falle eines Fehlers nicht noch einmal von vorne beginnen müssen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es ist nicht erforderlich, Tabellen zu sperren, was sehr wichtig ist, damit der Schreibverkehr in die Datenbank von unserem Service niemals blockiert wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hohe Verfügbarkeit aufgrund von Backups in AWS Availability Zones.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit unterstützen wir MySQL und Postgres, einschließlich Bereitstellungen für AWS RDS und Aurora. </font><font style="vertical-align: inherit;">Wir unterstützen auch Cassandra (Multi-Master). </font><font style="vertical-align: inherit;">Weitere Informationen zum Delta-Connector finden Sie in diesem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka und Transportniveau</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Delta Event Transport-Schicht basiert auf dem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keystone-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Plattform-Messaging-Dienst </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Vergangenheit wurde das Posten auf Netflix eher für eine höhere Verfügbarkeit als für eine lange Lebensdauer optimiert (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorherigen Artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Ein Kompromiss war die mögliche Inkonsistenz der Maklerdaten in verschiedenen Grenzszenarien. Zum Beispiel ist die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wahl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des </font><i><font style="vertical-align: inherit;">unreinen Führers</font></i><font style="vertical-align: inherit;"> dafür verantwortlich, dass der Empfänger möglicherweise Ereignisse dupliziert oder verliert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit Delta wollten wir stärkere Garantien für die Haltbarkeit erhalten, um die Lieferung von CDC-Ereignissen an Derivatspeicher sicherzustellen. Zu diesem Zweck haben wir einen speziell entwickelten Kafka-Cluster als Objekt der ersten Klasse vorgeschlagen. In der folgenden Tabelle können Sie sich einige Broker-Einstellungen ansehen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/70/hn/ri70hnpnr5wmiedci0_n5clwlwc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Keystone Kafka-Clustern </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> normalerweise eine </font><i><font style="vertical-align: inherit;">unsaubere Leader-Wahl</font></i><font style="vertical-align: inherit;"> aktiviert, um die Verfügbarkeit von Publishern sicherzustellen. Dies kann zu einem Nachrichtenverlust führen, wenn ein nicht synchronisiertes Replikat als Anführer ausgewählt wird. Für den neuen hochzuverlässigen Kafka-Cluster ist die Option für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsaubere</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Führerwahlen </font><font style="vertical-align: inherit;">deaktiviert, um den Verlust von Nachrichten zu verhindern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben auch den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replikationsfaktor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von 2 auf 3 und die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minimalen Insync-Replikate erhöht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">von 1 bis 2. Publisher, die in diesen Cluster schreiben, benötigen Bestätigungen von allen anderen, um sicherzustellen, dass 2 von 3 Replikaten die aktuellsten vom Publisher gesendeten Nachrichten erhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die Brokerinstanz beendet wird, ersetzt die neue Instanz die alte. Der neue Broker muss jedoch nicht synchronisierte Replikate nachholen, was mehrere Stunden dauern kann. Um die Wiederherstellungszeit für dieses Szenario zu verkürzen, haben wir begonnen, den Amazon Elastic Block Store anstelle der lokalen Broker-Festplatten zu verwenden. Wenn eine neue Instanz eine abgeschlossene Brokerinstanz ersetzt, hängt sie das EBS-Volume an, über das die abgeschlossene Instanz verfügt, und beginnt, neue Nachrichten einzuholen. Dieser Prozess reduziert die Zeit zum Beseitigen des Rückstands von mehreren Stunden auf einige Minuten, da die neue Instanz nicht mehr aus einem leeren Zustand repliziert werden muss. Im Allgemeinen reduzieren separate Speicher- und Brokerlebenszyklen die Auswirkungen des Brokerwechsels erheblich.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Garantie für die Datenübermittlung weiter zu erhöhen, haben wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein Nachrichtenverfolgungssystem verwendet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um den Verlust von Nachrichten unter extremen Bedingungen (z. B. Taktsynchronisation im Abschnittsleiter) zu erkennen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stream-Verarbeitungs-Framework</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Verarbeitungsebene bei Delta basiert auf der Netflix SPaaS-Plattform, die die Integration von Apache Flink in das Netflix-Ökosystem ermöglicht. Die Plattform bietet eine Benutzeroberfläche, die die Bereitstellung von Flink-Jobs und die Orchestrierung von Flink-Clustern auf unserer Titus-Containerverwaltungsplattform steuert. Die Schnittstelle verwaltet auch Jobkonfigurationen und ermöglicht es Benutzern, Konfigurationsänderungen dynamisch vorzunehmen, ohne Flink-Jobs neu kompilieren zu müssen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delta bietet ein Stream-Verarbeitungsframework für Flink- und SPaaS- </font><b><i><font style="vertical-align: inherit;">basierte</font></i></b><font style="vertical-align: inherit;"> Daten, das </font><b><i><font style="vertical-align: inherit;">annotationsbasiert</font></i></b><font style="vertical-align: inherit;"> verwendet</font></font><b><i><font style="vertical-align: inherit;"></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DSL (Domain Specific Language) zur Zusammenfassung technischer Details. Um beispielsweise den Schritt zu bestimmen, um den Ereignisse durch Aufrufen externer Dienste angereichert werden, müssen Benutzer das nächste DSL schreiben, und das Framework erstellt darauf basierend ein Modell, das Flink ausführt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fu/l2/kn/ful2knsuaqitsat9p69qhitq-a4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3. Beispiel für eine DSL-Anreicherung in Delta</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Das Verarbeitungsframework verkürzt nicht nur die Lernkurve, sondern bietet auch allgemeine Flussverarbeitungsfunktionen wie Deduplizierung, Schematisierung sowie Flexibilität und Fehlertoleranz zur Lösung häufiger Probleme bei der Arbeit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Delta Stream Processing Framework besteht aus zwei Schlüsselmodulen, dem DSL- und API-Modul und dem Runtime-Modul. Das DSL- und API-Modul stellt die DSL- und UDF-APIs (User-Defined-Function) bereit, damit Benutzer ihre eigene Verarbeitungslogik (z. B. Filterung oder Transformationen) schreiben können. Das Runtime-Modul bietet eine Implementierung des DSL-Parsers, der eine interne Darstellung der Verarbeitungsschritte in DAG-Modellen erstellt. Die Ausführungskomponente interpretiert DAG-Modelle, um die tatsächlichen Flink-Anweisungen zu initialisieren und schließlich die Flink-Anwendung zu starten. Die Architektur des Frameworks ist in der folgenden Abbildung dargestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/9_/gm/on/9_gmono77zxzhhorwhyghdkgdqq.png"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4. Architektur des Delta Stream Processing Framework</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dieser Ansatz bietet mehrere Vorteile:</font></font><br>
<br>
<ul>
<li>     -      Flink   SPaaS.</li>
<li>      ,         -     (UDF).</li>
<li>  Delta   ,             ,     .</li>
</ul><br>
<br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Delta ist seit über einem Jahr in Produktion und spielt in vielen Netflix Studio-Anwendungen eine Schlüsselrolle. </font><font style="vertical-align: inherit;">Es half Teams bei der Implementierung von Anwendungsfällen wie Suchindizierung, Datenspeicherung und ereignisgesteuerten Workflows. </font><font style="vertical-align: inherit;">Das Folgende ist eine Übersicht über die allgemeine Architektur der Delta-Plattform. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/im/rf/dq/imrfdqholl1umfrm_pb4nqwy064.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 5. Die allgemeine Architektur von Delta.</font></font></i><br>
 <br>
 <h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Danksagung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Wir möchten den folgenden Personen danken, die zur Schaffung und Entwicklung von Delta bei Netflix beigetragen haben: Allen Wang, Charles Zhao, Jaebin Yoon, Josh Snyder, Kasturi Chatterjee, Mark Cho, Olof Johansson, Piyush Goyal, Prashanth Ramdas, Raghuram Onti Srinivasan und Sandeep Gupta , Steven Wu, Tharanga Gamaethige, Yun Wang und Zhenzhong Xu.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellen</font></font></h3><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dev.mysql.com/doc/refman/5.7/en/implicit-commit.html</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dev.mysql.com/doc/refman/5.7/de/cannot-roll-back.html</font></font></a></li>
<li>Martin Kleppmann, Alastair R. Beresford, Boerge Svingen: Online event processing. Commun. ACM 62(5): 43–49 (2019). DOI: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">doi.org/10.1145/3312527</a></li>
</ol><br>
<b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   </a>: «Data Build Tool   Amazon Redshift».</b></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de487460/">https://habr.com/ru/post/de487460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de487444/index.html">"Während Sie Kaffee trinken, in Rechnung gestellt und einen Push for Payment erhalten" - Innovationen, mit denen Sie rund um die Uhr Geschäfte abwickeln können</a></li>
<li><a href="../de487446/index.html">Kann ein Unternehmen Farbe „besitzen“?</a></li>
<li><a href="../de487448/index.html">Superkräfte ultradünner Materialien: In der Materialwissenschaft ist 2D das neue 3D</a></li>
<li><a href="../de487450/index.html">Wir konfigurieren WireGuard auf einem Mikrotik-Router, auf dem OpenWrt ausgeführt wird</a></li>
<li><a href="../de487454/index.html">Wer sind diese Leute? Warum brauchen sie mich? und andere Scrum Master Probleme</a></li>
<li><a href="../de487462/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anfängers. Teil 4. Mit Daten arbeiten. CRUD</a></li>
<li><a href="../de487470/index.html">Calibry: 3D-Durchbruch Preisdurchbruch</a></li>
<li><a href="../de487486/index.html">Sega Dreamcast Anatomy: Konsole Second Life</a></li>
<li><a href="../de487488/index.html">Fälle für die Anwendung von Tools zur Analyse von Netzwerkanomalien: Erkennen der Verbreitung von Schadcode</a></li>
<li><a href="../de487490/index.html">XSL-Transformation unter MS SQL ohne CLR</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>