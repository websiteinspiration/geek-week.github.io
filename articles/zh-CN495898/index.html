<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕜 📶 📡 处理Node.js中内存泄漏的实用指南 🤭 💆🏼 🕔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="内存泄漏类似于寄生在应用程序上的实体。它们首先悄悄地渗透到系统中，而不会造成任何伤害。但是，如果泄漏证明足够严重，则会使应用程序遭受灾难。例如-强烈放慢速度或简单地“杀死”它。 这篇文章的作者（我们今天将要翻译的译本）建议谈论JavaScript中的内存泄漏。特别是，我们将讨论JavaScript中...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>处理Node.js中内存泄漏的实用指南</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/495898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存泄漏类似于寄生在应用程序上的实体。</font><font style="vertical-align: inherit;">它们首先悄悄地渗透到系统中，而不会造成任何伤害。</font><font style="vertical-align: inherit;">但是，如果泄漏证明足够严重，则会使应用程序遭受灾难。</font><font style="vertical-align: inherit;">例如-强烈放慢速度或简单地“杀死”它。</font><font style="vertical-align: inherit;">
这篇文章的作者（我们今天将要翻译的译本）建议谈论JavaScript中的内存泄漏。</font><font style="vertical-align: inherit;">特别是，我们将讨论JavaScript中的内存管理，如何识别实际应用程序中的内存泄漏以及如何处理内存泄漏。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ut/sj/t-/utsjt-d80r9mqkvrexbbkws-eae.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">什么是内存泄漏？</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从广义上讲，内存泄漏是分配给该应用程序不再需要的应用程序的一块内存，但是无法将其返回给操作系统以供将来使用。</font><font style="vertical-align: inherit;">换句话说，它是由应用程序捕获的存储块，无意在将来使用此存储。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内存管理</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存管理是一种用于将系统内存分配给需要它的应用程序的机制，也是一种用于将不必要的内存返回给操作系统的机制。</font><font style="vertical-align: inherit;">内存管理有很多方法。</font><font style="vertical-align: inherit;">使用哪种方法取决于所使用的编程语言。</font><font style="vertical-align: inherit;">以下是几种常见的内存管理方法的概述：</font></font><br>
<br>
<ul>
<li>  .           .         .       ,    .        C  C++.   ,   ,   <code>malloc</code>  <code>free</code>,      .</li>
<li>   . ,      ,   ,       .   ,  ,    ,        . ,     ,  ,      ,   .         .  — JavaScript, ,   JVM (Java, Scala, Kotlin), Golang, Python, Ruby  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用内存所有权的概念。</font><font style="vertical-align: inherit;">使用这种方法，每个变量都应具有自己的所有者。</font><font style="vertical-align: inherit;">一旦所有者超出范围，变量中的值就会被破坏，从而释放内存。</font><font style="vertical-align: inherit;">这个想法被用在Rust中。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有其他用于不同编程语言的内存管理方法。</font><font style="vertical-align: inherit;">例如，C ++ 11使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">习惯用法</font><font style="vertical-align: inherit;">，而Swift使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机制</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是谈论它已经超出了本文的范围。</font><font style="vertical-align: inherit;">为了比较上面的内存管理方法，以了解它们的优缺点，我们需要另外一篇文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript是一种Web程序员无法想象的语言，它使用垃圾回收的思想。</font><font style="vertical-align: inherit;">因此，我们将更多地讨论这种机制的工作原理。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript垃圾回收</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，JavaScript是一种使用垃圾回收概念的语言。</font><font style="vertical-align: inherit;">在JS程序运行期间，会定期启动一种称为垃圾收集器的机制。</font><font style="vertical-align: inherit;">他发现可以从应用程序代码访问分配的内存的哪些部分。</font><font style="vertical-align: inherit;">也就是说，引用了哪些变量。</font><font style="vertical-align: inherit;">如果垃圾收集器发现不再可以从应用程序代码访问某个内存，它将释放该内存。</font><font style="vertical-align: inherit;">可以使用两种主要算法来实现上述方法。</font><font style="vertical-align: inherit;">第一种是所谓的标记和扫描算法。</font><font style="vertical-align: inherit;">它在JavaScript中使用。</font><font style="vertical-align: inherit;">第二个是引用计数。</font><font style="vertical-align: inherit;">它用于Python和PHP。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/8ac/c60/3ee8acc608afe85e6a4c6f202cb1e8fe.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标记和扫描</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
算法的</font><i><font color="#999999"><font style="vertical-align: inherit;">标记（标记）和扫描（清理）阶段</font></font></i><font style="vertical-align: inherit;">在实施标记算法时，</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先创建一个</font><font style="vertical-align: inherit;">由全局环境变量表示的根节点列表（这是浏览器中的一个对象</font><font style="vertical-align: inherit;">），然后将结果树从根爬到标记有所有元素的叶节点在途中遇到物体。</font><font style="vertical-align: inherit;">释放堆中未被标签对象占用的内存。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js应用程序中的内存泄漏</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
迄今为止，我们已经分析了与内存泄漏和垃圾回收相关的足够的理论概念。</font><font style="vertical-align: inherit;">所以-我们准备看一下它们在实际应用程序中的外观。</font><font style="vertical-align: inherit;">在本节中，我们将编写一个存在内存泄漏的Node.js服务器。</font><font style="vertical-align: inherit;">我们将尝试使用各种工具来识别此泄漏，然后将其消除。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with熟悉存在内存泄漏的代码</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了演示，我编写了一个具有内存泄漏路由的Express服务器。</font><font style="vertical-align: inherit;">我们将调试该服务器。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个数组</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">超出了API请求处理代码的范围。</font><font style="vertical-align: inherit;">结果，每次执行相应的代码时，都会将新元素简单地添加到数组中。</font><font style="vertical-align: inherit;">永远不会清除该数组。</font><font style="vertical-align: inherit;">由于退出请求处理程序后，指向该数组的链接不会消失，因此垃圾收集器永远不会释放其使用的内存。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍通话内存泄漏</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里我们来最有趣的。已经写了很多文章，介绍了使用</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">炮兵之</font></a></font><code>node --inspect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类的请求填充服务器后，</font><font style="vertical-align: inherit;">如何使用它</font><font style="vertical-align: inherit;">来调试服务器内存泄漏</font><font style="vertical-align: inherit;">。但是这种方法有一个重要的缺点。假设您有一个具有数千个端点的API服务器。他们每个人都有很多参数，将要调用的特定代码取决于其功能。结果，在实际情况下，如果开发人员不知道内存泄漏在哪里，他将不得不使用所有可能的参数组合来多次访问每个API，以填充内存。对于我来说，这样做并不容易。但是，通过使用类似的方法可以简化此问题的解决方案</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goreplay-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种允许您记录和“播放”实际流量的系统。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决我们的问题，我们将在生产中进行调试。</font><font style="vertical-align: inherit;">也就是说，我们将允许我们的服务器在实际使用期间使内存溢出（因为它会收到各种API请求）。</font><font style="vertical-align: inherit;">在发现分配给它的内存量可疑增加之后，我们将进行调试。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍堆转储</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了了解什么是堆转储，我们首先需要找出堆概念的含义。如果您尽可能简单地描述此概念，那么事实证明堆是分配内存的所有内容所在的地方。所有这些都在堆上，直到垃圾收集器从其中删除了所有不必要的东西。堆转储只是堆当前状态的快照。转储包含所有内部变量和程序员声明的变量。它代表接收到转储时在堆上分配的所有内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，如果我们能够以某种方式将刚开始的服务器的堆转储与已经运行了很长时间并且内存溢出的服务器堆的转储进行比较，那么我们就可以识别出应用程序不需要但可被垃圾收集器删除的可疑对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在继续对话之前，让我们谈谈如何创建堆转储。</font><font style="vertical-align: inherit;">为了解决这个问题，我们将使用npm包</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heapdump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它允许您以编程方式获取服务器堆的转储。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安装软件包：</font></font><br>
<br>
<pre><code class="bash hljs">npm i heapdump
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将对服务器代码进行一些更改，以允许我们使用此程序包：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">"heapdump"</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.get(<span class="hljs-string">'/heapdump'</span>, (req, res) =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDump-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a bloated server written to"</span>, filename);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">msg</span>: <span class="hljs-string">"successfully took a heap dump"</span>})<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDumpAtServerStart.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a fresh server written to"</span>, filename);<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们使用此软件包来转储新启动的服务器。</font><font style="vertical-align: inherit;">我们还创建了一个API，</font></font><code>/heapdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旨在在访问堆时创建一个堆。</font><font style="vertical-align: inherit;">当我们意识到服务器开始消耗过多内存时，我们将使用此API。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您的服务器在Kubernetes集群中运行，那么如果不付出额外的努力，您将无法转向其服务器正在运行的那个pod占用了太多内存。</font><font style="vertical-align: inherit;">为此，您可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">端口转发</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此外，由于将无法访问下载转储文件所需的文件系统，因此最好将这些文件上传到外部云存储（如S3）。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍内存泄漏检测</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，服务器已部署。他已经工作了几天。它接收到很多请求（在我们的例子中，只有相同类型的请求），并且我们注意到服务器消耗的内存量的增加。可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express Status Monitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clinic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等监视工具检测内存泄漏</font><font style="vertical-align: inherit;">。之后，我们调用API来转储堆。此转储将包含垃圾收集器无法删除的所有对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是查询创建转储的样子：</font></font><br>
<br>
<pre><code class="bash hljs">curl --location --request GET <span class="hljs-string">'http://localhost:3000/heapdump'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建堆转储时，将强制运行垃圾收集器。因此，我们不必担心将来可能被垃圾收集器删除但仍在堆上的那些对象。那就是-关于在工作时不会发生内存泄漏的对象。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们都可以使用两个转储（一个新启动的服务器的转储和已经工作了一段时间的服务器的转储）之后，我们可以开始比较它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获取内存转储是一项阻塞操作，需要大量内存才能完成。因此，必须谨慎执行。您可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阅读有关此操作过程中可能遇到的问题的更多信息</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
启动Chrome，然后按键。</font></font><code>F12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将导致开发人员工具的发现。</font><font style="vertical-align: inherit;">在这里，您需要转到选项卡</font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并加载两个内存快照。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/252/992/5c125299224be08bb5bb73f74842f0b8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载内存的Chrome开发者工具的内存选项卡上转储</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
下载这两个快照之后，您需要更改</font></font><code>perspective</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><code>Comparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并单击，未来一段时间工作的服务器的内存的快照。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7c7/224/a997c7224ac3d053651be9e848380e75.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始比较快照</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这里，我们可以分析该列</font></font><code>Constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并查找垃圾收集器无法删除的对象。</font><font style="vertical-align: inherit;">这些对象中的大多数将由节点使用的内部链接表示。</font><font style="vertical-align: inherit;">在这里使用一个技巧很有用，其中包括按field对列表进行排序</font></font><code>Alloc. Size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将快速找到使用最多内存的对象。</font><font style="vertical-align: inherit;">如果先扩展block</font></font><code>(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后再</font><font style="vertical-align: inherit;">扩展</font><font style="vertical-align: inherit;">-</font></font><code>(object elements)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，您将看到一个</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含大量对象</font><font style="vertical-align: inherit;">的数组</font><font style="vertical-align: inherit;">，这些对象无法使用垃圾回收器删除。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/02c/0a2/e8502c0a2dcd1cf635f229eaef8d9e90.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对可疑数组的分析</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
此技术将使我们能够进入数组，</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并了解使用错误的操作会导致内存泄漏。</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍修复内存泄漏</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们知道“罪魁祸首”是一个数组</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们可以分析代码并发现问题在于数组是在请求处理程序之外声明的。</font><font style="vertical-align: inherit;">结果，事实证明从不删除指向它的链接。</font><font style="vertical-align: inherit;">解决此问题非常简单-只需将数组的声明传输到处理程序即可：</font></font><br>
<br>
<pre><code class="javascript hljs">app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了验证所采取措施的有效性，重复上述步骤并再次比较堆映像就足够了。</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内存泄漏以不同的语言发生。</font><font style="vertical-align: inherit;">特别是-使用垃圾回收机制的垃圾回收站。</font><font style="vertical-align: inherit;">例如，在JavaScript中。</font><font style="vertical-align: inherit;">通常，修复泄漏并不困难-真正的困难只有在您搜索它时才会出现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，您熟悉了内存管理的基础知识以及如何用不同的语言组织内存管理。</font><font style="vertical-align: inherit;">在这里，我们再现了内存泄漏的真实情况，并描述了一种故障排除方法。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亲爱的读者们！</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您是否在Web项目中遇到内存泄漏？</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495888/index.html">PyCon俄罗斯已经为未来的演讲者开放了CFP。参与表格和预期主题</a></li>
<li><a href="../zh-CN495890/index.html">在Docker Swarm中配置Nginx / LetsEncrypt捆绑软件</a></li>
<li><a href="../zh-CN495892/index.html">你真的知道什么是数组吗？</a></li>
<li><a href="../zh-CN495894/index.html">JavaScript性能评估</a></li>
<li><a href="../zh-CN495896/index.html">使用声音包：React应用程序中的声音效果</a></li>
<li><a href="../zh-CN495902/index.html">验证码：终止转换</a></li>
<li><a href="../zh-CN495904/index.html">可以预测流行吗？</a></li>
<li><a href="../zh-CN495908/index.html">奖励之路</a></li>
<li><a href="../zh-CN495910/index.html">在Ubuntu单板IMG映像中安装ROS</a></li>
<li><a href="../zh-CN495912/index.html">智能重播贴纸</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>