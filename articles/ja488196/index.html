<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎤 👵🏽 🧑🏼‍🤝‍🧑🏼 Androidインセット：恐れへの対処とAndroid Qの準備 🧗🏼 👨‍🏭 👈🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Android Qは、APIレベル29のAndroidの10番目のバージョンです。新しいバージョンの主なアイデアの1つは、アプリケーションが画面全体を下から上に占有する場合のエッジツーエッジの概念です。つまり、ステータスバーとナビゲーションバーは透明でなければなりません。ただし、それらが透過的である...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Androidインセット：恐れへの対処とAndroid Qの準備</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/488196/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android Qは、APIレベル29のAndroidの10番目のバージョンです。</font><font style="vertical-align: inherit;">新しいバージョンの主なアイデアの1つは、アプリケーションが画面全体を下から上に占有する場合のエッジツーエッジの概念です。</font><font style="vertical-align: inherit;">つまり、ステータスバーとナビゲーションバーは透明でなければなりません。</font><font style="vertical-align: inherit;">ただし、それらが透過的である場合、システムUIはありません。アプリケーションのインタラクティブコンポーネントと重複しています。</font><font style="vertical-align: inherit;">この問題はインセットで解決されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モバイル開発者は差し込みを避け、恐れを引き起こします。</font><font style="vertical-align: inherit;">ただし、Android Qでは、インセットを回避することはできません。インセットを調査して適用する必要があります。</font><font style="vertical-align: inherit;">実際、インセットについて複雑なことは何もありません。それらは、どの画面要素がシステムインターフェイスと交差するかを示し、システムUIと競合しないように要素を移動する方法を提案します。</font><strong><font style="vertical-align: inherit;">Konstantin Tskhovrebov</font></strong><font style="vertical-align: inherit;">は、はめ込みがどのように機能し、どのように役立つかを説明します</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/6Djql74drwk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンスタンチン・ツホブレボフ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テラコク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redmadrobotで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">10年以上Androidに携わっており、インセットの場所がなかったさまざまなプロジェクトで多くの経験を積んでいます。</font><font style="vertical-align: inherit;">コンスタンティンは、Androidの研究と戦うことについて、インセット問題を回避する長い歴史について語ります。</font><font style="vertical-align: inherit;">彼は、インセットを適用できる経験からの典型的なタスクを検討し、キーボードを恐れることをやめ、そのサイズを認識し、外観に応答する方法を示します。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">この記事は、</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saint AppsConf 2019での</font></font></em></a><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;"> Konstantinのレポートに基づいて作成されました</font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">レポートでは、差し込みに関するいくつかの記事の資料を使用しました。</font><font style="vertical-align: inherit;">最後にこれらの資料にリンクします。</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型的なタスク</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色ステータスバー。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのプロジェクトで、デザイナーは色のステータスバーを描画します。</font><font style="vertical-align: inherit;">Android 5が新しいマテリアルデザインとともに登場したとき、それは流行になりました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9l/ii/76/9lii76jdfrbb5i0vq8-ecv2ikby.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステータスバーをペイントするには？</font><font style="vertical-align: inherit;">基本-追加</font></font><code>colorPrimaryDark</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、色を置き換えます。</font></font><br>
<br>
<pre><code class="kotlin hljs"> &lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"colorPrimaryDark"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5番目のバージョン（21以降のAPI）以降のAndroidの場合、トピックで特別なパラメーターを設定できます。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;<font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:statusBarColor"</span>&gt;<span class="hljs-meta">@color</span>/colorAccent&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチカラーステータスバー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">異なる画面のデザイナーは、ステータスバーを異なる色で描画することがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uo/ev/nl/uoevnldknz2rtfq5lcqpn1mpj4g.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大丈夫です。最も簡単な方法は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまなアクティビティのさまざまなトピックを使用</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する</font><strong><font style="vertical-align: inherit;">ことです</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
より興味深い方法は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実行時に直接</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色を変更すること</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateView</span><span class="hljs-params">(...)</span></span>: View {<font></font>
    requireActivity().window.statusBarColor = requireContext().getColor(R.color.colorPrimary)<font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータは特別なフラグによって変更されます。</font><font style="vertical-align: inherit;">ただし、主なことは、ユーザーが画面を終了したときに色を元に戻すことを忘れないことです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明なステータスバー。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは難しいです。</font><font style="vertical-align: inherit;">ほとんどの場合、透明度が最もよく見えるのはマップ上であるため、透明度はマップに関連付けられています。</font><font style="vertical-align: inherit;">この場合、以前と同様に、特別なパラメーターを設定します。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.AppCompat.Light.NoActionBar"</span>&gt;    <font></font>
    ...<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    ...<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、ここにはよく知られているトリックがあります。それ以上インデントすると、ステータスバーがアイコンに重なって醜くなります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/49/8f/c8/498fc8wuip6i-o4eutfnviumuio.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、他の画面ではすべてが壊れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/if/-0/0q/if-00qq6b7zidoz-_nfyehlev7s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題を解決するには？頭に浮かぶ最初の方法は、さまざまなアクティビティです。さまざまなトピック、さまざまなパラメーターがあり、それらはさまざまに機能します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーボードを操作します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスバーだけでなく、キーボードを操作するときにも、インセットを回避します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s-/jk/mz/s-jkmzxzi-5xqr1ei0ku6pfubpy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もが左側のオプションを好きではありませんが、それを右側のオプションに変えるには、簡単な解決策があります。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;activity<font></font>
    ...<font></font>
    android:windowSoftInputMode=<span class="hljs-string">"adjustResize"</span>&gt;<font></font>
    ...<font></font>
&lt;/activity&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードが表示されたときにアクティビティのサイズを変更できるようになりました。それは単純かつ厳しく機能します。しかし、別のトリックを忘れないでください-すべてをでラップしてください</font></font><code>ScrollView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。突然、キーボードが画面全体を占め、上部に小さなストリップが表示されますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードが表示されたときにレイアウトを変更したい場合は、さらに難しいことがあります。たとえば、それ以外の場合はボタンを配置するか、ロゴを非表示にします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q3/ia/zl/q3iazltlnajt-cpvdzc0u2i8zcs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キーボードと透明なステータスバーを使って多くの松葉杖を訓練しましたが、今ではやめられません。 StackOverflowに移動し、美しいコードをコピーします。</font></font><br>
<br>
<pre><code class="kotlin hljs">boolean isOpened = <span class="hljs-literal">false</span>;<font></font>
<font></font>
<span class="hljs-keyword">public</span> void setListenerToRootView() {
    <span class="hljs-keyword">final</span> View activityRootView = getWindow().getDecorView().findViewById(android.R.id.content);<font></font>
    activityRootView.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {<font></font>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-keyword">public</span> void onGlobalLayout() {<font></font>
    <font></font>
            int heightDiff = activityRootView.getRootView().getHeight() - activityRootView.getHeight();      <font></font>
            <span class="hljs-keyword">if</span> (heightDiff &gt; <span class="hljs-number">100</span>) { <span class="hljs-comment">// 99% of the time the height diff will be due to a keyboard.       </span>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"Gotcha!!! softKeyboardup"</span>, <span class="hljs-number">0</span>).show();<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">false</span>) {
                   <span class="hljs-comment">//Do two things, make the view top visible and the editText smaller</span><font></font>
                }<font></font>
                isOpened = <span class="hljs-literal">true</span>;<font></font>
            } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOpened == <span class="hljs-literal">true</span>) {<font></font>
                Toast.makeText(getApplicationContext(), <span class="hljs-string">"softkeyborad Down!!!"</span>, <span class="hljs-number">0</span>).show();<font></font>
                isOpened = <span class="hljs-literal">false</span>;<font></font>
            }    <font></font>
        }<font></font>
    });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、キーボードの出現確率も計算されます。</font><font style="vertical-align: inherit;">コードは、私たちが使用したプロジェクトの1つでも機能しますが、長い間機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例の多くの松葉杖は、さまざまな活動の使用に関連しています。</font><font style="vertical-align: inherit;">しかし、それらは松葉杖であるというだけでなく、他の理由でも悪いです：「コールドスタート」の問題、非同期。</font><font style="vertical-align: inherit;">問題については、記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">車を運転するためのライセンス、またはアプリケーションが単一アクティビティであるべき理由</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で詳しく説明しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、Googleのドキュメントでは、推奨されるアプローチはシングルアクティビティアプリケーションであることが示されています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10より前は何をしていましたか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは（Redmadrobotで）かなり高品質のアプリケーションを開発していますが、長い間インセットを避けてきました。大きな松葉杖を使わずに1つのアクティビティでどうやってそれらを回避できたのでしょうか。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。私のペットプロジェクト</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取得したスクリーンショットとコード</font><font style="vertical-align: inherit;">。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アプリケーション画面を想像してみてください。アプリケーションを開発したとき、下に透明なナビゲーションバーがあるとは思いもしませんでした。下に黒いバーがありますか？つまり、ユーザーはそれに慣れています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ce/ab/6v/ceab6v6m5dqnbl9zpotdi1vqmre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上部では、最初にステータスバーが透明で黒であるというパラメーターを設定します。レイアウトとコードの観点からどのように見えますか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0g/tu/of/0gtuoffisoeudtgxlnmqd-jicnk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では、抽象化：赤のブロックはアプリケーションのアクティビティ、青はナビゲーションボット（タブ付き）を含むフラグメント、その内部ではコンテンツを含む緑のフラグメントが切り替えられています。ツールバーがステータスバーの下にないことがわかります。どうやってこれを達成したのですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidにはトリッキーなフラグがあり</font></font><code>fitSystemWindow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これをtrueに設定すると、コンテナ自体にパディングが追加され、コンテナ内の何もステータスバーに分類されなくなります。私はこの旗が差し込みを恐れている人たちのためのグーグルからの公式の松葉杖だと思います。すべてを使用すると、インセットがなくても比較的うまく機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグ</font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、指定したコンテナにパディングを追加します。ただし、階層は重要です。親のいずれかがこのフラグを「true」に設定した場合、コンテナはすでにインデントを適用しているため、その分布は考慮されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグは機能しますが、別の問題が発生します。</font><font style="vertical-align: inherit;">2つのタブがある画面を想像してください。</font><font style="vertical-align: inherit;">切り替えると、トランザクションが起動し、</font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメント</font><font style="vertical-align: inherit;">が発生し、</font><font style="vertical-align: inherit;">すべてが壊れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lv/02/_u/lv02_ui9sepxlvi7djz_xpem2sy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のフラグメントにもフラグセット</font></font><code>FitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、これは発生しません。</font><font style="vertical-align: inherit;">しかし、何が起こったのか、なぜですか？</font><font style="vertical-align: inherit;">答えは、これは松葉杖であり、時には機能しないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Overflowで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解決策を見つけました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">フラグメント</font></font><code>FrameLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">はなくルートを使用して</font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font><font style="vertical-align: inherit;">他の目的のために作成されましたが、ここでは機能します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ機能するのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースで何が起こっているのか見てみましょう</font></font><code>CoordinatorLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> void onAttachedToWindow() {   
    <span class="hljs-keyword">super</span>.onAttachedToWindow();<font></font>
    ...    <font></font>
    <span class="hljs-keyword">if</span> (mLastInsets == <span class="hljs-literal">null</span> &amp;&amp; ViewCompat.getFitsSystemWindows(<span class="hljs-keyword">this</span>)) {         
        <span class="hljs-comment">// We're set to fitSystemWindows but we haven't had any insets yet...</span>
        <span class="hljs-comment">// We should request a new dispatch of window insets</span>
        ViewCompat.requestApplyInsets(<span class="hljs-keyword">this</span>);<font></font>
    }     <font></font>
    ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここにはインセットが必要であるという美しいコメントが表示されていますが、必要ではありません。</font><font style="vertical-align: inherit;">ウィンドウをリクエストした場合は、再度尋ねる必要があります。</font><font style="vertical-align: inherit;">インセットは何とか内部で機能することがわかりましたが、インセットを使用して離れたくありません</font></font><code>Coordinator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019年春にアプリケーションを開発しましたが、その時点でGoogle I / Oが合格しました。</font><font style="vertical-align: inherit;">まだすべてを把握していないため、偏見を持ち続けました。</font><font style="vertical-align: inherit;">しかし、UIがロードされた複雑なレイアウトがあるため、下部のタブの切り替えがいくらか遅いことに気付きました。</font><font style="vertical-align: inherit;">これを解決する簡単な方法を見つけます-に変更</font></font><code>replace</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font></font><code>show/hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、毎回レイアウトを再作成しないようにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/7l/vz/hx7lvzsl8-kfv3qqac2pbvllt8q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは変わります、そして再び何もうまくいきません-すべてが壊れました！</font><font style="vertical-align: inherit;">どうやら松葉杖をまき散らすことは不可能であるように思われます。松葉杖が機能した理由を理解する必要があります。</font><font style="vertical-align: inherit;">コードを調査したところ、どのViewGroupもインセットを操作できることがわかりました。</font></font><br>
<br>
<pre><code class="kotlin hljs">
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {    <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {         
        <span class="hljs-keyword">final</span> int count = getChildCount();        
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);             <font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {          
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部にはそのようなロジックがあります。少なくとも誰かがすでにインセットを処理している場合、ViewGroup内の後続のすべてのビューはそれらを受け取りません。</font><font style="vertical-align: inherit;">これは私たちにとって何を意味しますか？</font><font style="vertical-align: inherit;">タブを切り替えるFrameLayoutの例を紹介しましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h1/fo/nn/h1fonnc4qrqpmj_x-fc8m47ptci.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部には、フラグが設定されている最初のフラグメントがあり</font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">つまり、最初のフラグメントはインセットを処理します。</font><font style="vertical-align: inherit;">その後、</font></font><code>HIDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のフラグメントと</font></font><code>SHOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2番目の</font><font style="vertical-align: inherit;">フラグメント</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、最初のビューはレイアウトに残ります-彼のビューはそのままで、非表示になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナはそのビューを通過します。最初のフラグメント</font></font><code>fitSystemWindow=”true”</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取得し、</font><font style="vertical-align: inherit;">インセットを提供し、そこから</font><font style="vertical-align: inherit;">-彼はそれらを取得して処理しました。</font><font style="vertical-align: inherit;">完全に、FrameLayoutはインセットが処理されたように見え、2番目のフラグメントには渡されませんでした。</font><font style="vertical-align: inherit;">すべてが正常に機能します。</font><font style="vertical-align: inherit;">しかし、これは私たちに合わないのですが、どうすればよいでしょうか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のViewGroupを作成します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはJavaから来ており、その栄光にOOPがあったので、継承することにしました。</font><font style="vertical-align: inherit;">独自のViewGroupを作成し、そこからメソッドを再定義しました</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それは私たちがそれを必要とする方法で機能します：それを処理したかどうかに関係なく、それは常に来たインセットを子供に返します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowInsetFrameLayout</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
    context: Context,      <font></font>
    attrs: AttributeSet? = <span class="hljs-literal">null</span>,     <font></font>
    defStyleRes: <span class="hljs-built_in">Int</span> = <span class="hljs-number">0</span><font></font>
) : FrameLayout(context, attrs, defStyleRes) {<font></font>
<font></font>
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dispatchApplyWindowInsets</span><span class="hljs-params">(insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets { 
        <span class="hljs-keyword">for</span> (child <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> until childCount)) {<font></font>
            getChildAt(child).dispatchApplyWindowInsets(insets)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> insets.consumeSystemWindowInsets()<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムViewGroupが機能し、プロジェクトも必要なものすべてです。</font><font style="vertical-align: inherit;">しかし、彼はまだ一般的な解決策に達していません。</font><font style="vertical-align: inherit;">彼らがGoogle IOで私たちに言ったことを理解したとき、私たちはもうそのように行動することができないことに気づきました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10は、厳守することを強くお勧めする2つの重要なUI概念、つまりエッジツーエッジとジェスチャーナビゲーションを示しました。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">隅々まで。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、アプリケーションのコンテンツが</font><font style="vertical-align: inherit;">画面上の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての可能なスペース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">占有</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">することを</font></a><font style="vertical-align: inherit;">示唆して</font><font style="vertical-align: inherit;">います。開発者としての私たちにとって、これは、アプリケーションが</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステータスバーとナビゲーションバーのシステムパネルの下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に配置される必要があることを意味します</font><strong><font style="vertical-align: inherit;">。</font></strong></font><br>
<br>
<img src="https://habrastorage.org/webt/cr/gl/nh/crglnh9iw__fu4lct0gavaibqey.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
以前は、どういうわけかこれを無視するか、ステータスバーの下にのみ配置できました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストについては、最後の要素までスクロールするだけでなく</font><strong><font style="vertical-align: inherit;">、ナビゲーションバーの下にとどまらないように</font></strong><font style="vertical-align: inherit;">さらにスクロールする必要があり</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></strong><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/tl/pl/it/tlplit1o65rn55edkixuuojxtha.png" width="350"></div><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェスチャーナビゲーション。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この2番目の重要な概念は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェスチャーナビゲーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">画面の端から指でアプリケーションを制御できます。</font><font style="vertical-align: inherit;">ジェスチャーモードは非標準であり、すべてが異なって見えますが、2つの異なるナビゲーションバーを切り替えることはできなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、すべてがそれほど単純ではないことに気づきました。</font><font style="vertical-align: inherit;">高品質のアプリケーションを開発したい場合、インセットをさらに回避することはできません。</font><font style="vertical-align: inherit;">ドキュメントを調べて、インセットとは何かを理解する時が来ました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセット </font><font style="vertical-align: inherit;">それらについて何を知る必要がありますか？</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットは開発者を怖がらせるために作成されました。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 5に登場して以来、彼らはこれを完璧に行っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、すべてがそれほど怖いわけではありません。インセットのコンセプトは単純</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。アプリケーション画面にシステムUIオーバーレイを報告します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナビゲーションバー、ステータスバー、またはキーボードを使用できます。キーボードは通常のシステムUIでもあり、アプリケーションの上に重ねて表示されます。松葉杖でそれを処理することを試みる必要はなく、はめ込みだけです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットの目標は、競合を解決すること</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。たとえば、ボタンの上に別の要素がある場合は、ボタンを移動して、ユーザーがアプリケーションを使い続けることができるようにします。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットを処理</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するには</font></font><code>Windowlnsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Android 10および</font></font><code>WindowInsetsCompat</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のバージョン</font><strong><font style="vertical-align: inherit;">に</font></strong><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10には</font><strong><font style="vertical-align: inherit;">5種類のインセット</font></strong><font style="vertical-align: inherit;">があります</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう1つは、インセットではなく、別の方法で呼ばれる「ボーナス」です。</font><font style="vertical-align: inherit;">ほとんどの場合、システムウィンドウインセットという1つのことしか知らないため、すべてのタイプを扱います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムウィンドウインセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 5.0（API 21）で導入されました。</font><font style="vertical-align: inherit;">メソッドによって取得され</font></font><code>getSystemWindowInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りは同じように機能するので、これは、操作方法を学ぶために必要なインセットの主なタイプです。</font><font style="vertical-align: inherit;">これらは、まずステータスバーを処理し、次にナビゲーションバーとキーボードを処理するために必要です。</font><font style="vertical-align: inherit;">たとえば、ナビゲーションバーがアプリケーションの上にあるときに問題を解決します。</font><font style="vertical-align: inherit;">図のように、ボタンはナビゲーションバーの下に残り、ユーザーはボタンをクリックできず、非常に不満です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/yj/tt/nxyjttdppbkrnrnqkspovzp4hko.png" width="350"></div><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タップ可能な要素インセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10でのみ表示されます。メソッドによって取得され</font></font><code>getTappableElementInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインセットは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、さまざまなナビゲーションバーモードを処理する</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合に</font><strong><font style="vertical-align: inherit;">のみ</font></strong><font style="vertical-align: inherit;">役立ち</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Bane</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自身が言うように</font><font style="vertical-align: inherit;">、このタイプのインセットを忘れて、システムウィンドウインセットのみを回避できます。しかし、アプリケーションを99.9％ではなく100％クールにしたい場合は、それを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
写真を見てください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/yd/fk/rlydfkwy39pfrc7jfhizhqdkg0q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一番上の色は、ナビゲーションウィンドウのさまざまなモードで表示されるシステムウィンドウのインセットを示しています。右側と左側はナビゲーションバーと同じであることがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェスチャーナビゲーションのしくみを思い出してください。正しいモードでは、新しいパネルをクリックするのではなく、常に指を下から上にドラッグします。</font><font style="vertical-align: inherit;">つまり、ボタンは削除できません。</font><font style="vertical-align: inherit;">FAB（フローティングアクションボタン）ボタンを押し続けることができます。誰も邪魔しません。</font><font style="vertical-align: inherit;">したがって、</font></font><code>TappableElementInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FABを移動する必要がない</font><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">空になります。</font><font style="vertical-align: inherit;">しかし、もう少し上に移動しても問題ありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いは、ジェスチャーナビゲーションと透明なナビゲーションバー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（色順応）で</font><strong><font style="vertical-align: inherit;">のみ表示されます</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは非常に楽しい状況ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zv/ei/qz/zveiqz33n9dc290ib9yhrrjl09u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが機能しますが、不快に見えます。</font><font style="vertical-align: inherit;">ユーザーは、要素の近さによって混乱する可能性があります。</font><font style="vertical-align: inherit;">1つはジェスチャー用でもう1つは押すためであると説明できますが、それでも美しくはありません。</font><font style="vertical-align: inherit;">したがって、FABを高くするか、右側のままにします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムジェスチャーインセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 10でのみ表示されます。メソッドによって取得され</font></font><code>getSystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインセットは、ジェスチャーナビゲーションに関連しています。最初は、システムUIがアプリケーションの上に描画されると想定されていましたが、システムジェスチャーインセットは、描画されるのはUIではなく、システム自体がジェスチャーを処理すると言います。システムがデフォルトでジェスチャーを処理する場所を記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインセットの領域は、図で黄色でマークされている領域とほぼ同じです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/8d/jl/vv8djlgxe4cnjchozbllrysagd0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私はあなたに警告したいです-彼らはいつもそのようではありません。サムスンや他のメーカーがどのような新しい画面を思いつくかは決してわかりません。画面が四方を向いているデバイスはすでにあります。おそらく、差し込みは、私たちが期待するところにはまったくないでしょう。したがって、いくつかの抽象化と同様に、それらを使用する必要があります。システム自体がジェスチャーを処理するシステムジェスチャーインセットには、そのようなインセットがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのインセットは上書きできます。</font><font style="vertical-align: inherit;">たとえば、フォトエディタを開発しているとします。</font><font style="vertical-align: inherit;">一部の場所では、画面の端に近くても、自分でジェスチャーを処理したい場合があります。</font><font style="vertical-align: inherit;">写真の隅にある画面上のポイントを自分で処理することをシステムに指示します。</font><font style="vertical-align: inherit;">これは、システムに「私は常に自分でポイントの周りの正方形を処理する」と言うことで再定義できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必須システムジェスチャーインセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはAndroid 10でのみ表示されます。これはシステムジェスチャーインセットのサブタイプですが、アプリケーションでオーバーライドすることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドを使用して</font></font><code>getMandatorySystemGestureInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それらが機能しない領域を決定します。</font><font style="vertical-align: inherit;">これは意図的に行われたため、「絶望的な」アプリケーションを開発することは不可能でした。ナビゲーションジェスチャを下から上に再定義することで、アプリケーションを終了してメイン画面に戻ることができます。</font><font style="vertical-align: inherit;">ここでは、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">システムは常にジェスチャー自体を処理します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/89/gl/df/89gldfknoq8z9dje_naytwp0pti.png" width="450"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必ずしもデバイスの下部にあるわけではなく、必ずしもこのサイズではありません。</font><font style="vertical-align: inherit;">抽象化として使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは比較的新しい種類のはめ込みでした。</font><font style="vertical-align: inherit;">しかし、Android 5より前に登場し、異なる方法で呼び出されたものもあります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定したインセット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android 5.0（API 21）で導入されました。メソッドによって取得され</font></font><code>getStableInsets()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
経験豊富な開発者でさえ、なぜそれが必要なのかを常に言えるわけではありません。秘密をお話しします。これらのインセットは、フルスクリーンアプリケーション（ビデオプレーヤー、ゲーム）でのみ役立ちます。たとえば、再生モードでは、ステータスバーを含め、システムのUIは非表示になり、画面の端を超えて移動します。ただし、ステータスバーが上部に表示されるため、画面をタッチする価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面の上部に[戻る]ボタンを配置すると、システムウィンドウインセットが正しく処理されますが、タブごとに上から画面にUIが表示され、ボタンが下にジャンプします。画面にしばらく触れないと、ステータスバーが消え、システムウィンドウのインセットが消えたため、ボタンが跳ね上がります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような場合、Stable Insetsが適切です。</font><font style="vertical-align: inherit;">彼らは今、あなたのアプリケーションには何の要素も描かれていないと言いますが、それは可能です。</font><font style="vertical-align: inherit;">これらのインセットを使用すると、たとえば、このモードでステータスバーの値を事前に把握し、ボタンを必要な場所に配置できます。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">このメソッド</font></font></em><code><em>getStableInsets()</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はAPI 21でのみ表示されました。以前は、画面の両側にいくつかのメソッドがありました。&nbsp;</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5種類のインセットについて検討しましたが、インセットに直接適用できないものがあります。</font><font style="vertical-align: inherit;">前髪や切り欠きの扱いに役立ちます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前髪とネックライン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面は正方形ではなくなりました。</font><font style="vertical-align: inherit;">それらは長方形で、カメラ用に1つ以上のカットアウトがあり、すべての側に前髪があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ls/kv/sc/lskvscp_j-hy2gesyynicb346cq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大28のAPIを処理できませんでした。</font><font style="vertical-align: inherit;">何が起こっているのかを、はめ込みを通して推測しなければなりませんでした。</font><font style="vertical-align: inherit;">しかし、28以前のAPI（以前のAndroidからのもの）以降では、クラスが正式に登場しました</font></font><code>DisplayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他のすべてのタイプを取得できるのと同じインセットにあります。</font><font style="vertical-align: inherit;">クラスを使用すると、アーティファクトの場所とサイズを確認できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
位置情報に加えて、開発者向けに一連のyフラグが用意されてい</font></font><code>WindowManager.LayoutParams</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">カットアウトの周りにさまざまな動作を含めることができます。</font><font style="vertical-align: inherit;">コンテンツは周囲に表示される場合と表示されない場合があります。横向きと縦向きのモードで表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
旗</font></font><code>window.attributes.layoutInDisplayCutoutMode =</code><br>
<br>
<ul>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">縦向き-横向き-デフォルトでは黒いバーがあります。</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">全然ない-黒のストライプ。</font></font></li>
<li><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -常にです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示は制御できますが、他のインセットと同じように操作します。</font></font><br>
<br>
<pre><code class="kotlin hljs">insets.displayCutout<font></font>
    .boundingRects<font></font>
    .forEach { rect -&gt; ... }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列付きのインセットを使用したコールバックが実現し</font></font><code>displayCutout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、それを実行し、アプリケーションにあるすべてのカットアウトと前髪を処理します。</font><font style="vertical-align: inherit;">それら</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法の詳細について</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">は、記事を参照してください</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6種類のインセットで理解。</font><font style="vertical-align: inherit;">それがどのように機能するかについて話しましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使い方</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何よりもまず、アプリケーションの上に何かを描画する場合、たとえば、ナビゲーションバーなどのインセットが必要です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ft/ct/_w/ftct_wh_dc64t9rw6ir_7zpqg8m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インセットがない場合、アプリケーションには透明なナビゲーションバーとステータスバーがありません。</font><font style="vertical-align: inherit;">あなたが来ないことに驚かないでください</font></font><code>SystemWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、これは起こります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットを広げる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
UI階層全体は、ビューが端にあるツリーのように見えます。</font><font style="vertical-align: inherit;">ノードは通常ViewGroupです。</font><font style="vertical-align: inherit;">また、ビューから継承するため、インセットは特別な方法で表示され</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ルートビューから開始すると、システムはツリー全体にインセットを送信します。</font><font style="vertical-align: inherit;">この場合のViewの動作を見てみましょう。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/jy/rw/hk/jyrwhkavrimytpqs4je0ltfn7-w.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムは</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、インセットが入る</font><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このビューに戻ると、何かが返されます。</font><font style="vertical-align: inherit;">この動作を処理するにはどうすればよいですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単にするため、WindowInsetsのみを考慮します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットの処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、メソッドの再定義と</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のロジック内の実装</font><font style="vertical-align: inherit;">は論理的に見えます</font><font style="vertical-align: inherit;">。差し込みが来て、すべてを内部に実装しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viewクラスを開いて、このメソッドの上に書かれたJavadocを見ると、「このメソッドをオーバーライドしないでください！」</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委任または継承を通じてインセットを処理します。</font></font></blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委任を使用し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">Googleは、インセットの処理を担当する自身のデリゲートを公開する機会を提供しました。</font><font style="vertical-align: inherit;">次の方法でインストールでき</font></font><code>setOnApplyWindowInsetsListener(listener)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これらのインセットを処理するコールバックを設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの理由でこれが適切でない場合は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Viewから継承して別のメソッドをオーバーライド</font></font></strong> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でき</font><strong><font style="vertical-align: inherit;">ます</font></strong></font><code>onApplyWindowInsets(WindowInsets insets)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">独自のインセットをそれに置き換えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グーグルは委任と継承のどちらかを選択しませんでしたが、すべてを一緒に行うことを許可しました。</font><font style="vertical-align: inherit;">インセットを処理するためにすべてのツールバーまたはリストビューを再定義する必要がないため、これは素晴らしいことです。</font><font style="vertical-align: inherit;">ライブラリのビューを含め、既製のビューを取得し、そこにデリゲートを設定できます。デリゲートは、再定義せずにインセットを処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を返しましょうか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ何かを返すのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、インセットの分布、つまりViewGroupがどのように機能するかを理解する必要があります。</font><font style="vertical-align: inherit;">彼女は自分の中で何をしていますか。</font><font style="vertical-align: inherit;">前に示した例を使用して、デフォルトの動作を詳しく見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムのインセットは上部と下部にあり、それぞれ100ピクセルなどです。</font><font style="vertical-align: inherit;">ViewGroupは、最初のビューにそれらを送信します。</font><font style="vertical-align: inherit;">このビューはそれらを何らかの方法で処理し、インセットを返します。上部は0に減少しますが、下部は残ります。</font><font style="vertical-align: inherit;">上部にパディングまたはマージンを追加しましたが、下部には触れず、これを報告しました。</font><font style="vertical-align: inherit;">次に、ViewGroupはインセットを2番目のビューに渡します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tj/-a/rw/tj-arwxjkus-n6xnvl099lqbqqg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のビューはインセットを処理してレンダリングします。</font><font style="vertical-align: inherit;">これで、ViewGroupは、インセットが上と下の両方で処理されることを確認します。何も残っておらず、すべてのパラメーターがゼロです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3番目のビューは、いくつかのインセットがあり、何かが起こっていたことさえ知りません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ViewGroupは、インセットをそれらを公開したインセットに戻します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックに取り掛かったとき、私たちは自分自身のためにアイデアを書き留めました-いつも来たのと同じインセットを返します。</font><font style="vertical-align: inherit;">一部のビューが差し込みの存在を認識していないような状況を回避したかったのです。</font><font style="vertical-align: inherit;">アイデアは論理的に見えました。</font><font style="vertical-align: inherit;">しかし、そうではないことがわかりました。</font><font style="vertical-align: inherit;">Googleは、例のように、インセットに追加された動作を無効にしていない。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、インセットが常にビューの階層全体に到達し、いつでも作業できるようにするために必要です。</font><font style="vertical-align: inherit;">この場合、2つのフラグメントを切り替えても、1つは処理され、もう1つはまだ受信されていません。</font><font style="vertical-align: inherit;">練習セクションでは、この時点に戻ります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">練習</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論が完了しました。</font><font style="vertical-align: inherit;">理論上はすべてが常にスムーズであるため、コードでそれがどのように見えるかを見てみましょう。</font><font style="vertical-align: inherit;">AndroidXを使用します。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font><font style="vertical-align: inherit;">で</font></font></em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFox、</font></font></em></a><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてがすでに、コードに新しいアンドロイドからのすべてのグッズを完全にサポートして実装されています。</font><font style="vertical-align: inherit;">Androidのバージョンをチェックしたり、必要なタイプのインセットを検索したりしないようにするために、常に</font></font></em><code><em>view.setOnApplyWindowInsetsListener { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AndroidX </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">の</font></em><em><font style="vertical-align: inherit;">バージョンを</font></em><em><font style="vertical-align: inherit;">使用して</font></em></font><code><em>ViewCompat.setOnApplyWindowInsetsListener(view) { v, insets -&gt; ... }</em></code><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暗いナビゲーションバーのある画面があります。</font><font style="vertical-align: inherit;">上の要素とは重なりません。</font><font style="vertical-align: inherit;">すべてが私たちが慣れている方法です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3r/wq/sp/3rwqspgcdlgie2m00lmedkwzgi8.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、今、それを透明にする必要があることがわかりました。</font><font style="vertical-align: inherit;">どうやって？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">透明化をオンにする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単なことは、ステータスバーとナビゲーションバーが透明であることを件名に示すことです。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentStatus"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:windowTranslucentNavigation"</span>&gt;<span class="hljs-literal">true</span>&lt;/item&gt;<font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このとき、上からも下からもすべてが重なり始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、フラグは2つあり、オプションは常に3つあります。ナビゲーションバーに透明度を指定すると、ステータスバー自体が透明になります-このような制限があります。</font><font style="vertical-align: inherit;">あなたは最初の行を書くことはできませんが、私は常に明快さが大好きなので、フォロワーが何が起こっているのかを理解できるように2行を書きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法を選択すると、ナビゲーションバーとステータスバーが透明になり、黒になります。</font><font style="vertical-align: inherit;">アプリケーションが白の場合、コードからのみ色を追加できます。</font><font style="vertical-align: inherit;">どうやってするの？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色付きの透明度をオンにする</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルアクティビティアプリケーションがあるのは良いことなので、1つのアクティビティに2つのフラグを配置します。</font></font><br>
<br>
<pre><code class="kotlin hljs">rootView.systemUiVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE or  <font></font>
    View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION<font></font>
<font></font>
&lt;style name=<span class="hljs-string">"AppTheme"</span> parent=<span class="hljs-string">"Theme.MaterialComponents.Light"</span>&gt;<font></font>
    &lt;!-- Set the navigation bar to <span class="hljs-number">50</span>% translucent white --&gt;<font></font>
    &lt;item name=<span class="hljs-string">"android:navigationBarColor"</span>&gt;#<span class="hljs-number">80F</span>FFFFF&lt;/item&gt; <font></font>
&lt;/style&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこには多くのフラグがありますが、ナビゲーションバーとステータスバーを透明にするのに役立つのはこれら2つです。</font><font style="vertical-align: inherit;">色はテーマで指定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはAndroidの奇妙な振る舞いです。テーマによるものとフラグによるものです。</font><font style="vertical-align: inherit;">ただし、コードとサブジェクトの両方でパラメーターを指定できます。</font><font style="vertical-align: inherit;">これはAndroidではないので、古いバージョンのAndroidでは、トピックで指定されたフラグが無視されます。</font></font><code>navigationBarColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはAndroid 5ではそうではないことを強調していますが、すべてがまとまります。</font><font style="vertical-align: inherit;">GitFoxでは、コードからナビゲーションバーの色を設定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詐欺を実施しました-ナビゲーションバーは透明で白です。</font><font style="vertical-align: inherit;">これで、アプリケーションは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/eo/vs/mz/eovsmz1tczlc9vl_kg2yihxs0u0.png" width="350"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットを処理するよりも簡単なことは何ですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、小学校。</font></font><br>
<br>
<pre><code class="kotlin hljs">ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;  <font></font>
        view.updatePadding(bottom = insets.systemWindowInsetBottom) <font></font>
        insets<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドを受け取り、</font></font><code>setOnApplyWindowInsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それに渡し</font></font><code>bottomNav</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">差し込みが来たら、下にあるパッドを取り付けます</font></font><code>systemWindowInsetBottom</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下に配置したいのですが、クリック可能な要素はすべて上にあります。</font><font style="vertical-align: inherit;">完全なインセットを返すため、階層内の他のすべてのビューもそれらを受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが素晴らしく見えます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zl/8e/ku/zl8ekuc_pvpc2wrmeop-khxmomg.png" width="350"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、落とし穴があります。</font><font style="vertical-align: inherit;">レイアウトで、下のナビゲーションバーにある種のパディングを示した場合は、ここで削除されました- </font></font><code>updatePadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インセットを等しく</font><font style="vertical-align: inherit;">設定し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">レイアウトが希望どおりに表示されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイアウトから値を保存するには、まず下のパディングにあるものを保存する必要があります。</font><font style="vertical-align: inherit;">後でインセットが到着したら、結果の値を追加して設定します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">val</span> bottomNavBottomPadding = bottomNav.paddingBottom<font></font>
ViewCompat<font></font>
    .setOnApplyWindowInsetsListener(bottomNav) { view, insets -&gt;                 <font></font>
        view.updatePadding(<font></font>
        bottom = bottomNavBottomPadding + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    Insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このように書くのは不便です。インセットを使用するコードのすべての場所で、レイアウトから値を保存して、UIに追加する必要があります。</font><font style="vertical-align: inherit;">しかし、Kotlinがあります。これは素晴らしいことです。独自の拡張機能を記述できます。これにより、これらすべてが実行されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コトリンを追加！</font></font></h3><br><font style="vertical-align: inherit;"></font><code>initialPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいインセットが（それらと一緒に）到着したときに、それ</font><font style="vertical-align: inherit;">
を覚え</font><font style="vertical-align: inherit;">てハンドラーに渡します。</font><font style="vertical-align: inherit;">これは、どういうわけかそれらを一緒に追加したり、上からある種のロジックを構築するのに役立ちます。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {    <font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
<font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
    <font></font>
    requestApplyInsetsWhenAttached()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
   Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)<font></font>
<font></font>
  .<font></font>
<font></font>
bottomNav.doOnApplyWindowInsets { view, insets, padding -&gt;   <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    ) <font></font>
    insets<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ラムダを再定義する必要があります。</font><font style="vertical-align: inherit;">インセットだけでなく、パディングもあります。</font><font style="vertical-align: inherit;">ステータスバーを処理するツールバーの場合は、下からだけでなく上からも追加できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忘れられた何か！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理解できないメソッドへの呼び出しがあります。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">doOnApplyWindowInsets</span><span class="hljs-params">(block: (<span class="hljs-type">View</span>, <span class="hljs-type">WindowInsetsCompat</span>, <span class="hljs-type">Rect</span>) -&gt; <span class="hljs-type">WindowInsetsCompat</span>)</span></span> {<font></font>
<font></font>
    <span class="hljs-keyword">val</span> initialPadding = recordInitialPaddingForView(<span class="hljs-keyword">this</span>)<font></font>
     <font></font>
    ViewCompat.setOnApplyWindowInsetsListener(<span class="hljs-keyword">this</span>) { v, insets -&gt;        <font></font>
        block(v, insets, initialPadding)<font></font>
    }<font></font>
      <font></font>
    requestApplyInsetsWhenAttached() <font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">recordInitialPaddingForView</span><span class="hljs-params">(view: <span class="hljs-type">View</span>)</span></span> =<font></font>
      Rect(view.paddingLeft, view.paddingTop, view.paddingRight, view.paddingBottom)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、システムがインセットを送信することだけを期待することができないためです。</font><font style="vertical-align: inherit;">コードからビューを作成するか、</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">少し後で</font><font style="vertical-align: inherit;">インストールする</font><font style="vertical-align: inherit;">と、システム自体が最後の値を渡さない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビューが画面に表示されているときに、システムに「インセットが到着したので、処理したい」と伝えたことを確認する必要があります。</font><font style="vertical-align: inherit;">リスナーを設定し、リクエストを行う必要があり</font></font><code>requestsApplyInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。」</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">requestApplyInsetsWhenAttached</span><span class="hljs-params">()</span></span> {    
    <span class="hljs-keyword">if</span> (isAttachedToWindow) {        <font></font>
        requestApplyInsets()<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
        addOnAttachStateChangeListener(<span class="hljs-keyword">object</span> : View.OnAttachStateChangeListener {            
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewAttachedToWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {<font></font>
                v.removeOnAttachStateChangeListener(<span class="hljs-keyword">this</span>)<font></font>
                v.requestApplyInsets()           <font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onViewDetachedFromWindow</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> = <span class="hljs-built_in">Unit</span><font></font>
        })<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viewコードを作成し、それをレイアウトにまだアタッチしていない場合、それを行う時間をサブスクライブする必要があります。</font><font style="vertical-align: inherit;">その後、インセットをリクエストします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、もう一度、Kotlinがあります。彼らは簡単な拡張機能を作成したので、もう考える必要はありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerViewの改良</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、RecyclerViewのファイナライズについて説明します。最後の要素はナビゲーションバーの下にあり、下に残ります-醜いです。クリックするのも不便です。これが新しいパネルではなく古いパネルである場合、一般に、要素全体がその下に表示されなくなる可能性があります。何をすべきか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jc/qa/f7/jcqaf7okahkrhrrnols54exqhdu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のアイデアは、下に要素を追加し、インセットに合うように高さを設定することです。しかし、何百ものリストを持つアプリケーションがある場合、どういうわけか各リストをインセットにサブスクライブし、そこに新しい要素を追加して高さを設定する必要があります。さらに、RecyclerViewは非同期であり、いつ機能するかは不明です。多くの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、別の公式ハックがあります。驚くべきことに、それは効率的に動作します。</font></font><br>
<br>
<pre><code class="kotlin hljs">&lt;androidx.recyclerview.widget.RecyclerView <font></font>
        android:id=<span class="hljs-string">"@+id/recyclerView"</span>        
    android:layout_width=<span class="hljs-string">"match_parent"</span>    
    android:layout_height=<span class="hljs-string">"match_parent"</span>             
    android:clipToPadding=<span class="hljs-string">"false"</span> /&gt;<font></font>
<font></font>
recyclerView.doOnApplyWindowInsets { view, insets, padding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = padding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイアウトにはそのようなフラグがあります</font></font><code>clipToPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。デフォルトでは、常にtrueです。これは、パディングが露出している場所に現れる要素を描画する必要がないことを示唆しています。ただし、を設定すると</font></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、描画できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、下にパディングを設定すると、RecyclerViewでは次のように機能します。パディングは下に設定され、スクロールするまで要素がその上に描画されます。最後に到達すると、RecyclerViewは要素を必要な位置までスクロールします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなフラグを1つ設定することで、通常のビューと同じようにRecyclerViewを操作できます。スクロールする要素があるとは思わないでください。たとえば、下のナビゲーションバーのように、下のパディングを設定するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在は、処理されていないかのように常にインセットを返していました。</font><font style="vertical-align: inherit;">インセット全体が私たちのところに来て、私たちはそれらを使って何かを行い、パディングを設定して、インセット全体を再び返しました。</font><font style="vertical-align: inherit;">これは、任意のViewGroupが常にこれらのインセットをすべてのViewに渡すために必要です。</font><font style="vertical-align: inherit;">できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションのバグ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既にインセットを処理しているGoogle Playの多くのアプリケーションで、小さなバグに気付きました。今、私は彼について話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地下にナビゲーション付きの画面があります。右側は、階層を表示する同じ画面です。緑のフラグメントは画面にコンテンツを表示し、内部にはRecyclerViewがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hl/e6/jo/hle6jod0ws19fydq734lqnuaixu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでインセットを処理したのは誰ですか？ツールバー：コンテンツがステータスバーの下に移動するように、上部にパディングを適用しました。したがって、下部ナビゲーションバーは下からインセットを適用し、ナビゲーションバーの上に上昇しました。ただし、RecyclerViewはインセットをまったく処理せず、インセットも含まれません。インセットを処理する必要はありません。すべてが正しく行われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/r3/xc/qi/r3xcqipovgqu-zbbxruxsy-wqvk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、ここでは、Bottom Navigation Barがもう存在しない別の場所で緑のRecyclerViewフラグメントを使用したいことがわかります。この時点で、RecyclerViewはすでに下からインセットの処理を開始しています。ナビゲーションバーの下から適切にスクロールするには、それにパディングを適用する必要があります。したがって、RecyclerViewでは、インセット処理も追加します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ve/ws/m-/vewsm-_o80cw7mbn9tyk0bu_mfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面に戻り、全員がインセットを処理します。覚えておいて、彼がそれらを処理したと誰も報告していませんか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/um/vd/x8/umvdx8faxxk48r-inx-cxhkjqdm.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況を確認します。RecyclerViewは下からインセットを処理しましたが、ナビゲーションバーに到達していません-下部にスペースが表示されています。アプリケーションでこれに気づき、非常に大きく人気があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i9/3_/ar/i93_arxauyvbitayfpyonkxnudy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、すべてのインセットを処理に戻すことを覚えています。つまり、インセットが処理されたことを報告する必要があります。ナビゲーションバーは、インセットが処理されたことを報告する必要があります。彼らはRecyclerViewにアクセスすべきではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jf/r2/vi/jfr2vi8jpsas_ptxjjqh_qhg1vk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、下部ナビゲーションバーをインストールし</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理されていないことを</font><font style="vertical-align: inherit;">減算</font><font style="vertical-align: inherit;">して、0を返します。</font></font><br>
<br>
<pre><code class="kotlin hljs">doOnApplyWindowInsets { view, insets, initialPadding -&gt;    <font></font>
    view.updatePadding(<font></font>
        bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
    )<font></font>
    insets.replaceSystemWindowInsets(<font></font>
        Rect(<font></font>
            insets.systemWindowInsetLeft,            <font></font>
            insets.systemWindowInsetTop,            <font></font>
            insets.systemWindowInsetRight,<font></font>
            <span class="hljs-number">0</span><font></font>
        )<font></font>
    )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いインセットはすべて</font></font><code>bottom + insets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等しいが0に等しい</font><font style="vertical-align: inherit;">新しいインセットを返します</font><font style="vertical-align: inherit;">。すべてが問題ないようです。</font><font style="vertical-align: inherit;">私たちは最初から何度もナンセンスです-RecyclerViewは依然として何らかの理由でインセットを処理します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/lp/yw/ut/lpywut3fvlk5w-nwbd3-wnrceaw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題がこれら3つのビューのコンテナがLinearLayoutであることはすぐにはわかりませんでした。</font><font style="vertical-align: inherit;">それらの内部には、ツールバー、RecyclerViewを備えたスニペットがあり、下部ナビゲーションバーの下部にあります。</font><font style="vertical-align: inherit;">LinearLayoutは子を順番に受け取り、インセットをそれらに適用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボトムナビゲーションバーが最後になることがわかりました。</font><font style="vertical-align: inherit;">彼は誰かにインセットをすべて処理したと言ったが、遅すぎた。</font><font style="vertical-align: inherit;">すべてのインセットは上から下に処理され、RecyclerViewはすでにそれらを受け取っており、これは私たちを救いません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/mm/jd/ujmmjdgumv0bl6e0ewydx7ueq5g.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何をすべきか？</font><font style="vertical-align: inherit;">LinearLayoutは希望どおりに機能せず、上から下に転送します。最初に下から取得する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてを再定義</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java開発者が私の中で遊んだ- </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">再定義する</font></strong><font style="vertical-align: inherit;">必要がある</font><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">さて、ここで</font></font><code>dispatchApplyWindowInsets</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再定義、設定します</font></font><code>yLinearLayout</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは常に下から上に移動します。</font><font style="vertical-align: inherit;">彼は最初にインセットボトムナビゲーションバーを送信し、次に他の全員に送信します。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> WindowInsets dispatchApplyWindowInsets(WindowInsets insets) {     <font></font>
    insets = <span class="hljs-keyword">super</span>.dispatchApplyWindowInsets(insets);     
    <span class="hljs-keyword">if</span> (!insets.isConsumed()) {        
        <span class="hljs-keyword">final</span> int count = getChildCount();
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; count; i++) {<font></font>
            insets = getChildAt(i).dispatchApplyWindowInsets(insets);<font></font>
            <span class="hljs-keyword">if</span> (insets.isConsumed()) {
                <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> insets;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この方法を再定義する必要はないというコメントを思い出して、やがて立ち止まりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、少し高いのが救いです。ViewGroupは、インセットを処理するデリゲートをチェックし、Viewのスーパーメソッドを呼び出して、独自の処理を有効にします。</font><font style="vertical-align: inherit;">このコードでは、インセットを取得し、インセットがまだ処理されていない場合は、子の標準ロジックを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単な拡張機能を書きました。</font></font><code>InsetsListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのビュー</font><font style="vertical-align: inherit;">に適用</font><font style="vertical-align: inherit;">して、これらのインセットがだれに渡されるかを言う</font><font style="vertical-align: inherit;">ことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword">fun</span> View.<span class="hljs-title">addSystemBottomPadding</span><span class="hljs-params">(    
    targetView: <span class="hljs-type">View</span> = this
)</span></span> {<font></font>
    doOnApplyWindowInsets { _, insets, initialPadding -&gt;           <font></font>
        targetView.updatePadding(<font></font>
            bottom = initialPadding.bottom + insets.systemWindowInsetBottom<font></font>
        )<font></font>
        insets.replaceSystemWindowInsets(<font></font>
            Rect(<font></font>
                insets.systemWindowInsetLeft,<font></font>
                insets.systemWindowInsetTop,     <font></font>
                insets.systemWindowInsetRight,<font></font>
                <span class="hljs-number">0</span><font></font>
            )<font></font>
        )<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで</font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、デフォルトで、適用する同じビューと同じです</font></font><code>addSystemBottomPadding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">再定義できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のLinearLayoutで、そのようなハンドラーをぶら下げて、次のように渡しました</font></font><code>targetView</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これが私の下部ナビゲーションバーです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まず、インセットの下部ナビゲーションバーを提供します。&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはインセットを処理し、ボトムゼロを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに、デフォルトでは上から下に移動します：ツールバー、RecyclerViewのフラグメント。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、おそらく、彼は再びインセットボトムナビゲーションバーを送信します。</font><font style="vertical-align: inherit;">しかし、これはもはや重要ではなく、すべてがとてもうまくいくでしょう。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は望んだとおりに達成しました。すべてのインセットは、必要な順に処理されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/b0/nc/s3b0nc07bayude3nvrvevkxnwyc.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えておくべきいくつかの重要な事柄。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キーボードは、アプリケーションの上にあるシステムUIです。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別な方法で彼女を扱う必要はありません。 Googleキーボードを見ると、それはクリックできるボタンのある単なるレイアウトではありません。このキーボードには何百ものモードがあります：gifとミームの検索、音声入力、高さ10ピクセルから画面サイズへのサイズ変更。キーボードについて考えるのではなく、インセットをサブスクライブします。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ナビゲーションドロワーはまだジェスチャーナビゲーションをサポートしていません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Google IOでは、すべてがそのままで機能することを約束しました。</font><font style="vertical-align: inherit;">ただし、Android 10では、Navigation Drawerはまだこれをサポートしていません。</font><font style="vertical-align: inherit;">Android 10にアップグレードして、ジェスチャーによるナビゲーションを有効にすると、ナビゲーションドロワーが落ちます。</font><font style="vertical-align: inherit;">次に、ハンバーガーメニューをクリックして表示するか、ランダムな状況の組み合わせで拡大することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Androidのプレアルファ版では、Navigation Drawerは機能しますが、あえて更新しませんでした。これはプレアルファ版です。</font><font style="vertical-align: inherit;">そのため、リポジトリから最新バージョンのGitFoxをインストールしても、そこにナビゲーションドロワーがありますが、プルすることはできません。</font><font style="vertical-align: inherit;">公式サポートが出次第、アップデートし、すべてが正常に動作します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android 10準備チェックリスト</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトの最初からナビゲーションバーとステータスバーの透明度を設定し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。透明なナビゲーションバーを維持することを強くお勧めします。私たちにとって、これは重要な実用的な部分です。プロジェクトは機能するがオンにしていない場合は、時間をかけてAndroid 10をサポートしてください。まず、半透明などのサブジェクトでオンにして、壊れたレイアウトを修正します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kotlinに拡張機能を追加</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します-簡単です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パディングの上にあるすべてのツールバーに追加します。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツールバーは常に一番上にあり、それを行う必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのRecyclerViewで、下からパディングを追加し、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクロール機能を</font><strong><font style="vertical-align: inherit;">追加します</font></strong></font><code>clipToPadding="false"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面の端にあるすべてのボタン</font></font></strong><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（FAB）</font></font></strong><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">について考えてください</font></strong><font style="vertical-align: inherit;">。 FABはおそらくあなたが期待するところにはありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのLinearLayout</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびその他の同様のケース</font><strong><font style="vertical-align: inherit;">について、独自の実装をオーバーライドまたは作成しないでください</font></strong><font style="vertical-align: inherit;">。 GitFoxのようにトリックを実行するか、既成の拡張機能を手伝ってください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面の端にあるジェスチャーでカスタムビューを確認します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 Navigation Drawerはこれをサポートしていません。しかし、手でそれをサポートすること、ナビゲーションドロワーで画面上のジェスチャーのインセットを再定義することはそれほど難しくありません。おそらく、ジェスチャーが機能する画像エディターがあるでしょう。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ViewPagerでのスクロールは端からではなく、中央から左右にのみ機能し</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。グーグルはこれは正常であると言います。 ViewPagerを端から引っ張ると、「戻る」ボタンを押したと認識されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいプロジェクトでは、すぐにすべての透明性を含めます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ナビゲーションバーとステータスバーがないことを設計者に伝えることができます。</font><font style="vertical-align: inherit;">四角全体がアプリケーションのコンテンツです。</font><font style="vertical-align: inherit;">そして、開発者はすでにどこで何を調達するかを理解します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク：</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">電報内の@rmr_spb-Redmadrobot SPb内部ミタップ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この記事のすべてのソースコード、さらに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitFoxの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソースコード</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">別のAndroid 10ブランチがあり、ここで私がこれにすべて着手した方法と、新しいAndroidをどのようにサポートしたかをコミットすることで確認できます。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chris Baneの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Insetter Library</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それは私が示した5-6の拡張機能を含んでいます。</font><font style="vertical-align: inherit;">プロジェクトで使用するには、ライブラリに連絡してください。ほとんどの場合、Android Jetpackに移動します。</font><font style="vertical-align: inherit;">私は自分のプロジェクトでそれらを開発しました、そして、それは私には思えます、彼らは良くなりました。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリスベインの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記事</font></a><font style="vertical-align: inherit;">。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>   FunCorn,    ,      .</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Why would I want to fitsSystemWindows?</a>»  .</li>
</ul><br>
<blockquote>    AppConf,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">youtube-</a>      .            ,     - .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">AppsConf</a>     ,            .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>, stay tuned!</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja488186/index.html">私のQAエンジニアパス：バーンアウトから高度なテストまで</a></li>
<li><a href="../ja488188/index.html">火事後の森林再生：ナノ粒子がいかにして樹木マイクロクローンを保護するか</a></li>
<li><a href="../ja488190/index.html">もう一度感情的なバーンアウトについて</a></li>
<li><a href="../ja488192/index.html">Helmデバイスとその落とし穴</a></li>
<li><a href="../ja488194/index.html">なぜこんなに質の悪いプログラムを書いているのですか？</a></li>
<li><a href="../ja488198/index.html">ティムリッドは何を恐れており、なぜこれをやめるべきか</a></li>
<li><a href="../ja488200/index.html">最初のプログラミング言語に関する議論：最終決定</a></li>
<li><a href="../ja488202/index.html">PVS-StudioがChocolateyになりました：Azure DevOpsからChocolateyをチェックしています</a></li>
<li><a href="../ja488208/index.html">アニバーサリーDUMP2020-忘れられない4日間</a></li>
<li><a href="../ja488210/index.html">TensorFlowを使用したAndroid上のオブジェクトの認識：データの準備からデバイスでの起動まで</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>