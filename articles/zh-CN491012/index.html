<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⏯️ 👨🏼‍🍳 🥒 异步编程与异步/等待 🈁 🚵🏿 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="朋友们，美好的一天！
 
 相对而言，新增的JavaScript是异步函数和await关键字。这些功能基本上是对Promise（承诺）的语法补充，使编写和读取异步代码变得容易。它们使异步代码看起来像同步的。本文将帮助您弄清楚是什么。
 
 条件：基本的计算机知识，JS基础知识，理解异步代码和Prom...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>异步编程与异步/等待</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">朋友们，美好的一天！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相对而言，新增的JavaScript是异步函数和await关键字。</font><font style="vertical-align: inherit;">这些功能基本上是对Promise（承诺）的语法补充，使编写和读取异步代码变得容易。</font><font style="vertical-align: inherit;">它们使异步代码看起来像同步的。</font><font style="vertical-align: inherit;">本文将帮助您弄清楚是什么。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
条件：基本的计算机知识，JS基础知识，理解异步代码和Promise的基础。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目的：了解如何作出承诺以及如何使用它们。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待基础</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用异步/等待有两个部分。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步关键字</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们有async关键字，该关键字放在函数声明之前以使其异步。</font><font style="vertical-align: inherit;">异步功能是一种预期可以使用await关键字运行异步代码的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尝试在浏览器控制台中键入以下内容：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数将返回“ Hello”。</font><font style="vertical-align: inherit;">没什么特别的，对吧？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，如果我们将其转换为异步函数呢？</font><font style="vertical-align: inherit;">请尝试以下操作：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，函数调用将返回一个Promise。</font><font style="vertical-align: inherit;">这是异步函数的功能之一-它们返回保证被转换为Promise的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以创建异步函数表达式，如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> hello() }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还可以使用箭头功能：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有这些功能都做同样的事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了获得完成的承诺的价值，我们可以使用.then（）块：</font></font><br>
<br>
<pre><code class="javascript hljs">hello().then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...甚至是这样：</font></font><br>
<br>
<pre><code class="javascript hljs">hello().then(<span class="hljs-built_in">console</span>.log)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，添加async关键字会使函数返回promise而不是值。</font><font style="vertical-align: inherit;">另外，它允许同步功能避免与运行和支持使用await相关的任何开销。</font><font style="vertical-align: inherit;">在功能之前简单添加异步功能，即可通过JS引擎自动优化代码。</font><font style="vertical-align: inherit;">凉！</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待关键字</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您将异步功能与await关键字结合使用时，异步功能的优势变得更加明显。</font><font style="vertical-align: inherit;">可以在任何基于promise的函数之前添加它，以使其等待promise完成，然后返回结果。</font><font style="vertical-align: inherit;">之后，将执行下一个代码块。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在调用任何返回承诺的函数（包括Web API函数）时使用await。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个简单的示例：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> greeting = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello'</span>)<font></font>
}<font></font>
<font></font>
hello().then(alert)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，上面的代码是没有用的，它仅用作语法的演示。</font><font style="vertical-align: inherit;">让我们继续看一个真实的例子。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用异步/等待在Promise上重写代码</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上一篇文章的获取示例为例：</font></font><br>
<br>
<pre><code class="javascript hljs">fetch(<span class="hljs-string">'coffee.jpg'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.blob())<font></font>
.then(<span class="hljs-function"><span class="hljs-params">myBlob</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There has been a problem with your fetch operation: '</span> + e.message)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该已经了解了什么是Promise以及它们如何工作，但是让我们使用async / await重写此代码，看看它有多简单：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">let</span> myBlob = <span class="hljs-keyword">await</span> response.blob()<font></font>
<font></font>
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}<font></font>
<font></font>
myFetch().catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There has been a problem with your fetch operation: '</span> + e.message)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这使代码更加简单易懂-没有.then（）块！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用async关键字将功能转换为一个承诺，因此我们可以使用从承诺到等待的混合方法，在单独的块中突出显示该功能的第二部分，以提高灵活性：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.blob()<font></font>
}<font></font>
<font></font>
myFetch().then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(blob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'image'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以重写示例或运行我们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时演示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（另请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是它是如何工作的呢？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将代码包装在函数中，并在function关键字之前添加了async关键字。您需要创建一个异步函数来确定将在其中运行异步代码的代码块。 await仅在异步函数中起作用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再一次：await仅在异步函数中起作用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在myFetch（）函数内部，代码非常类似于promise上的版本，但是有一些区别。不必在每个基于promise的方法之后使用.then（）块，而只需在调用该方法之前添加await关键字并将一个值分配给该变量。关键字await使JS引擎在给定的行上暂停代码执行，从而允许另一个代码执行，直到异步函数返回结果为止。一旦执行，代码将从下一行继续执行。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当给定值可用时，将fetch（）承诺返回的值分配给响应变量，并且解析器将在该行停止，直到承诺完成为止。</font><font style="vertical-align: inherit;">一旦该值变为可用，解析器便移至创建Blob的下一行代码。</font><font style="vertical-align: inherit;">该行还调用了基于Promise的异步方法，因此在这里我们也使用await。</font><font style="vertical-align: inherit;">当操作结果返回时，我们从myFetch（）函数返回它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着，当我们调用myFetch（）函数时，它将返回一个promise，因此我们可以在其中添加.then（），以在其中处理屏幕上图像的显示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会认为“太好了！”而且您是对的-较少用于包装代码的.then（）块，它们看起来都像是同步代码，因此很直观。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加错误处理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要添加错误处理，则有几种选择。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以将同步try ... catch结构与async / await一起使用。</font><font style="vertical-align: inherit;">此示例是上面代码的扩展版本：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
        <span class="hljs-keyword">let</span> myBlob = <span class="hljs-keyword">await</span> response.blob()<font></font>
<font></font>
        <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
        <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
        image.src = objectURL<font></font>
        <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
myFetch()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
catch（）{}块接受一个错误对象，我们将其命名为“ e”；</font><font style="vertical-align: inherit;">现在我们可以将其输出到控制台，这将使我们能够接收到有关代码中错误发生位置的消息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要使用上面显示的代码的第二版，则应继续使用混合方法，并在.then（）调用的末尾添加.catch（）块，如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fecth(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.blob()<font></font>
}<font></font>
<font></font>
myFetch().then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是可能的，因为.catch（）块将捕获异步函数和promise链中都发生的错误。</font><font style="vertical-align: inherit;">如果在此处使用try / catch块，将无法处理调用myFetch（）函数时发生的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在GitHub上找到两个示例：</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple-fetch-async-await-try-catch.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple-fetch-async-await-promise-catch.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等待Promise.all（）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步/等待基于承诺，因此您可以充分利用后者。</font><font style="vertical-align: inherit;">这些特别包括Promise.all（）-您可以轻松地向Promise.all（）添加await以类似于同步代码的方式写入所有返回值。</font><font style="vertical-align: inherit;">同样，以上</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一篇文章为例</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">保持打开的标签页与下面显示的代码进行比较。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用async / await（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时演示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），它看起来像这样：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAndDecode</span>(<span class="hljs-params">url, type</span>)</span>{
    <span class="hljs-keyword">let</span> repsonse = <span class="hljs-keyword">await</span> fetch(url)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> content<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'blob'</span>){<font></font>
        content = <span class="hljs-keyword">await</span> response.blob()<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'text'</span>){<font></font>
        content = <span class="hljs-keyword">await</span> response.text()<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> content<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayContent</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> coffee = fetchAndDecode(<span class="hljs-string">'coffee.jpg'</span>, <span class="hljs-string">'blob'</span>)
    <span class="hljs-keyword">let</span> tea = fetchAndDecode(<span class="hljs-string">'tea.jpg'</span>, <span class="hljs-string">'blob'</span>)
    <span class="hljs-keyword">let</span> description = fetchAndDecode(<span class="hljs-string">'description.txt'</span>, <span class="hljs-string">'text'</span>)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([coffee, tea, description])<font></font>
<font></font>
    <span class="hljs-keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">let</span> descText = values[<span class="hljs-number">2</span>]<font></font>
<font></font>
    <span class="hljs-keyword">let</span> image1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)
    <span class="hljs-keyword">let</span> image2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image1.src = objectURL1<font></font>
    image2.src = objectURL2<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image1)
    <span class="hljs-built_in">document</span>.body.appendChild(image2)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)<font></font>
    para.textContent = descText<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(para)<font></font>
}<font></font>
<font></font>
displayContent()<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们很容易通过一些更改使fetchAndDecode（）函数异步。</font><font style="vertical-align: inherit;">注意这一行：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> values = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([coffee, tea, description])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用await，我们以类似于同步代码的方式获得变量值中三个promise的结果。</font><font style="vertical-align: inherit;">我们必须将整个函数包装在一个新的异步函数displayContent（）中。</font><font style="vertical-align: inherit;">我们没有实现强大的代码缩减，但是能够从.then（）块中提取大多数代码，这提供了有用的简化，并使代码更具可读性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了处理错误，我们在对displayContent（）的调用中添加了.catch（）块；</font><font style="vertical-align: inherit;">它处理两个函数的错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住：您还可以使用.finally（）块获取有关该操作的报告-您可以在我们的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实时演示中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看到它的运行情况</font><font style="vertical-align: inherit;">（另请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">异步/等待劣势</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步/等待有两个缺陷。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步/等待使代码看起来像同步的，从某种意义上讲，使其行为更加同步。与同步操作中发生的情况一样，关键字await阻止其后的代码执行，直到承诺完成为止。这允许您执行其他任务，但是您自己的代码已锁定。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着您的代码可能会因大量的未决承诺而被放慢速度。每次等待都将等待上一个的完成，而我们希望同时实现承诺，就好像我们没有使用异步/等待一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一种设计模式可以缓解此问题-通过将Promise对象存储在变量中然后等待它们来禁用所有promise过程。</font><font style="vertical-align: inherit;">让我们看看这是如何实现的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们有两个示例</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可供使用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">slow-async-await.html</font></a><font style="vertical-align: inherit;">（请参阅</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast-async-await.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">源代码</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">这两个示例均以promise函数开头，该函数使用setTimeout（）模仿异步操作：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeoutPromise</span>(<span class="hljs-params">interval</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<font></font>
            resolve(<span class="hljs-string">'done'</span>)<font></font>
        }, interval)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后是异步函数timeTest（），该函数希望对timeoutPromise（）进行三个调用：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对timeTest（）的三个调用中的每一个都以记录完成承诺的时间结束，然后记录完成整个操作所花费的时间：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> startTime = <span class="hljs-built_in">Date</span>.now()<font></font>
timeTest().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> finishTime = <span class="hljs-built_in">Date</span>.now()
    <span class="hljs-keyword">let</span> timeTaken = finishTime - startTime<font></font>
    alert(<span class="hljs-string">'Time taken in milliseconds: '</span> + timeTaken)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在每种情况下，timeTest（）函数都不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在slow-async-await.html中，timeTest（）如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们只希望对timeoutPromise进行三个调用，每次设置3秒的延迟。</font><font style="vertical-align: inherit;">每个调用都等待上一个调用的完成-如果运行第一个示例，则将在9秒钟左右看到一个模态窗口。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在fast-async-await.html中，timeTest（）如下所示：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> timeoutPromise1 = timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">const</span> timeoutPromise2 = timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">const</span> timeoutPromise3 = timeoutPromise(<span class="hljs-number">3000</span>)<font></font>
<font></font>
    <span class="hljs-keyword">await</span> timeoutPromise1
    <span class="hljs-keyword">await</span> timeoutPromise2
    <span class="hljs-keyword">await</span> timeoutPromise3<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们将三个Promise对象保存在变量中，这将导致与其关联的进程同时运行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们期望他们的结果-当诺言同时开始履行时，诺言也将同时完成；</font><font style="vertical-align: inherit;">当您运行第二个示例时，您将在3秒钟左右看到一个模态窗口！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该仔细测试代码，并在降低性能的同时牢记这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另一个不便之处是需要将预期的承诺包装在异步函数中。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对类使用异步/等待</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总之，我们注意到您甚至可以在用于创建类的方法中添加异步，以便它们返回promise并在其中等待promise。</font><font style="vertical-align: inherit;">从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有关面向对象JS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">文章中</font></a><font style="vertical-align: inherit;">获取代码</font><font style="vertical-align: inherit;">，并将其与使用async修改的版本进行比较：</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(first, last, age, gender, interests){
        <span class="hljs-keyword">this</span>.name = {<font></font>
            first,<font></font>
            last<font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.gender = gender
        <span class="hljs-keyword">this</span>.interests = interests<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">async</span> greeting(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hi! I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span>`</span>)<font></font>
    }<font></font>
<font></font>
    farewell(){<font></font>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span> has left the building. Bye for now!`</span>)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> han = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Han'</span>, <span class="hljs-string">'Solo'</span>, <span class="hljs-number">25</span>, <span class="hljs-string">'male'</span>, [<span class="hljs-string">'Smuggling'</span>])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该类方法可以如下使用：</font></font><br>
<br>
<pre><code class="javascript hljs">han.greeting().then(<span class="hljs-built_in">console</span>.log)
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">浏览器支持</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用异步/等待的障碍之一是缺乏对较旧浏览器的支持。</font><font style="vertical-align: inherit;">几乎所有现代浏览器都可以使用此功能。</font><font style="vertical-align: inherit;">Internet Explorer和Opera Mini中存在一些问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要使用async / await，但需要较旧浏览器的支持，则可以使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BabelJS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库</font><font style="vertical-align: inherit;">-它允许您使用最新的JS，并将其转换为适合特定浏览器的JS。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
异步/等待允许您编写易于阅读和维护的异步代码。</font><font style="vertical-align: inherit;">尽管与其他异步代码编写方法相比，对async / await的支持更差，但是绝对值得探索。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
感谢您的关注。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编码愉快！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN490998/index.html">SIBUR中的硬件测试</a></li>
<li><a href="../zh-CN491000/index.html">在没有JavaScript的情况下（几乎）对Select-Option进行样式设置</a></li>
<li><a href="../zh-CN491006/index.html">Intel NUC通过Unity3D</a></li>
<li><a href="../zh-CN491008/index.html">好被遗忘的老</a></li>
<li><a href="../zh-CN491010/index.html">机器学习文章精选：2020年2月的案例，指南和研究</a></li>
<li><a href="../zh-CN491016/index.html">第32期：IT培训-领先公司的当前问题和挑战</a></li>
<li><a href="../zh-CN491018/index.html">在Nuxt.js上创建在线商店2演练第2部分</a></li>
<li><a href="../zh-CN491028/index.html">蝇王</a></li>
<li><a href="../zh-CN491030/index.html">在Debian上部署Mediawiki（非常简单）</a></li>
<li><a href="../zh-CN491032/index.html">“ RTFM，伙计！”，或者免费的奶酪花了我5美元。或者可能是$ 80 +</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>