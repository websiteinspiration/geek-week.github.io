<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜 🕺🏾 👩🏽‍🌾 3D faça você mesmo. Parte 1: pixels e linhas 👩‍🔬 💆🏾 👨🏾‍⚕️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Quero dedicar esta série de artigos aos leitores que desejam explorar o mundo da programação 3D do zero, às pessoas que desejam aprender o básico da c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3D faça você mesmo. Parte 1: pixels e linhas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494094/"><img src="https://habrastorage.org/webt/-u/-n/6a/-u-n6axbw6fowganklzotzai0sk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quero dedicar esta série de artigos aos leitores que desejam explorar o mundo da programação 3D do zero, às pessoas que desejam aprender o básico da criação do componente 3D de jogos e aplicativos. </font><font style="vertical-align: inherit;">Implementaremos cada operação do zero para entender todos os aspectos, mesmo que já exista uma função pronta que a torne mais rápida. </font><font style="vertical-align: inherit;">Tendo aprendido, mudaremos para as ferramentas internas para trabalhar com 3D. </font><font style="vertical-align: inherit;">Depois de ler a série de artigos, você entenderá como criar cenas tridimensionais complexas com luz, sombras, texturas e efeitos, como fazer tudo isso sem profundo conhecimento de matemática e muito mais. </font><font style="vertical-align: inherit;">Você pode fazer tudo isso de forma independente e com a ajuda de ferramentas prontas.</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Na primeira parte, consideraremos:</font></font><br>
</b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conceitos de renderização (software, hardware)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que é um pixel / superfície?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análise detalhada da saída de linha</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para não perder seu precioso tempo lendo artigos, que podem ser incompreensíveis para uma pessoa despreparada, voltarei imediatamente para os requisitos. Você pode começar a ler artigos em 3D com segurança, se conhece os conceitos básicos de programação em qualquer idioma, porque Vou me concentrar apenas no estudo da programação 3D, e não no estudo dos recursos da linguagem e dos conceitos básicos da programação. Quanto à preparação matemática, você não deve se preocupar aqui, embora muitos não desejem estudar 3D, porque eles ficam assustados com cálculos complexos e fórmulas furiosas por causa dos quais os pesadelos mais tarde sonham, mas, na verdade, não há com o que se preocupar. Vou tentar explicar da forma mais clara possível tudo o que é necessário para 3D, você só precisa multiplicar, dividir, adicionar e subtrair. Portanto, se você passou nos critérios de seleção, pode começar a ler.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Antes de começar a explorar o mundo interessante do 3D, vamos escolher uma linguagem de programação para exemplos, bem como um ambiente de desenvolvimento. Qual idioma devo escolher para programar gráficos 3D? Qualquer um, você pode trabalhar onde estiver mais confortável, a matemática será a mesma em todos os lugares. Neste artigo, todos os exemplos serão mostrados no contexto de JS (aqui os tomates voam para mim). Por que js? É simples - ultimamente tenho trabalhado principalmente com ele e, portanto, posso transmitir com mais eficácia a essência a você. Vou ignorar todos os recursos de JS nos exemplos, porque precisamos apenas dos recursos mais básicos que qualquer idioma possui, portanto, prestaremos atenção especificamente ao 3D. Mas você escolhe o que ama, porque nos artigos, todas as fórmulas não estarão vinculadas aos recursos de qualquer linguagem de programação. Qual ambiente escolher? Isso não importa,no caso de JS, qualquer editor de texto é adequado, você pode usar o que estiver mais perto de você.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os exemplos usarão telas para pintura, como com ele, você pode começar a desenhar muito rapidamente, sem análise detalhada. O Canvas é uma ferramenta poderosa, com muitos métodos prontos para desenhar, mas com todas as suas características, pela primeira vez, usaremos apenas a saída de pixels!&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as tridimensionais são exibidas na tela usando pixels. Mais adiante, nos artigos, você verá como isso acontece. Será que vai desacelerar? Sem aceleração de hardware (por exemplo, aceleração por uma placa de vídeo) - será. No primeiro artigo, não usaremos acelerações, escreveremos tudo do zero para entender os aspectos básicos do 3D. Vejamos alguns termos que serão mencionados em artigos futuros:</font></font><br>
<br>
<ul>
<li><i> (Rendering)</i> —    3D-    . ,     3D-     ,        ,        .</li>
<li><i>  (Software Rendering) </i> —     .  ,  , ,    -  .       ,     .       3D-   ,    —  .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderização de hardware</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Um processo de renderização assistida por hardware. </font><font style="vertical-align: inherit;">Eu uso jogos e aplicativos. </font><font style="vertical-align: inherit;">Tudo funciona muito rápido, porque </font><font style="vertical-align: inherit;">muita computação de rotina assume a placa de vídeo, projetada para isso.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não aspiro ao título "definição do ano" e tento declarar todas as descrições de termos da maneira mais clara possível. </font><font style="vertical-align: inherit;">O principal é entender a idéia, que pode ser desenvolvida de forma independente. </font><font style="vertical-align: inherit;">Também quero chamar a atenção para o fato de que todos os exemplos de código que serão mostrados nos artigos geralmente não são otimizados para velocidade, a fim de manter a facilidade de entendimento. </font><font style="vertical-align: inherit;">Quando você entende o principal - como os gráficos 3D funcionam, você pode otimizar tudo sozinho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, crie um projeto, para mim é apenas um </font><font style="vertical-align: inherit;">arquivo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html de</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texto </font><font style="vertical-align: inherit;">, com o seguinte conteúdo:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>3D it’s easy. Part 1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">&lt;!--         --&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"surface"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"600"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    </span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não vou me concentrar muito em JS e canvas agora - esses não são os personagens principais deste artigo. </font><font style="vertical-align: inherit;">Mas, para uma compreensão geral, vou esclarecer que &lt;canvas ...&gt; é um retângulo (no meu caso, tamanho de 800 x 600 pixels) no qual exibirei todos os gráficos. </font><font style="vertical-align: inherit;">Registrei a tela uma vez e não a alterarei mais.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> … <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Script - um elemento no qual escreveremos toda a lógica para renderizar gráficos 3D com nossas próprias mãos (em JavaScript).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando analisamos a estrutura do arquivo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do </font><font style="vertical-align: inherit;">projeto recém-criado, começaremos a lidar com gráficos 3D.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quando desenhamos algo na janela, isso na contagem final se transforma em pixels, porque são eles que o monitor exibe. Quanto mais pixels, mais nítida a imagem, mas o computador também carrega mais. Como é armazenado o que desenhamos na janela? Os gráficos em qualquer janela podem ser representados como uma matriz de pixels, e o próprio pixel é apenas uma cor. Ou seja, uma resolução de tela de 800x600 significa que nossa janela contém 600 linhas de 800 pixels cada, ou seja, 800 * 600 = 480000 pixels, muito, não é? Os pixels são armazenados em uma matriz. Vamos pensar em qual matriz armazenaríamos os pixels. Se tivermos 800 por 600 pixels, a opção mais óbvia é uma matriz bidimensional de 800 por 600. E essa é quase a opção certa, ou melhor, a opção completamente correta. Mas, como os pixels da janela, é melhor armazenar em uma matriz unidimensional de 480.000 elementos (se a resolução for de 800 por 600),só porque é mais rápido trabalhar com uma matriz unidimensional, porque Ele é armazenado na memória em uma seqüência contínua de bytes (tudo fica próximo e, portanto, é fácil obtê-lo). Em uma matriz bidimensional (por exemplo, no caso de JS), cada linha pode ser espalhada em diferentes locais da memória, portanto, o acesso aos elementos dessa matriz levará mais tempo. Além disso, para iterar em uma matriz unidimensional, é necessário apenas 1 ciclo e, para números inteiros bidimensionais 2, dada a necessidade de fazer dezenas de milhares de iterações do ciclo, a velocidade é importante aqui. O que é um pixel nessa matriz? Como mencionado acima - esta é apenas uma cor, ou melhor, 3 de seus componentes (vermelho, verde, azul). Qualquer imagem, mesmo a mais colorida, é apenas uma matriz de pixels de cores diferentes. Um pixel na memória pode ser armazenado como desejar, em uma matriz de 3 elementos ou em uma estrutura em que vermelho, verde,azul; ou alguma outra coisa. Uma imagem que consiste em uma matriz de pixels que acabamos de analisar, continuarei chamando a superfície. Acontece que, como tudo o que é exibido na tela é armazenado em uma matriz de pixels, alterando os elementos (pixels) nessa matriz - alteraremos pixel por pixel a imagem na tela. É exatamente isso que faremos neste artigo.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não há função de desenho de pixel na tela, mas é possível acessar uma matriz unidimensional de pixels, que discutimos acima. </font><font style="vertical-align: inherit;">Como fazer isso é mostrado no exemplo abaixo (este e todos os exemplos no futuro estarão apenas dentro do elemento de script):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ()    </span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">document</span>
.getElementById(<span class="hljs-string">'surface'</span>)<font></font>
.getContext(<span class="hljs-string">'2d'</span>)<font></font>
<font></font>
<span class="hljs-comment">//     ,   &nbsp;</span>
<span class="hljs-comment">// +       </span>
<span class="hljs-keyword">const</span> imageData = ctx.createImageData(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo, imageData é um objeto no qual existem 3 propriedades:</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">height and width</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - números inteiros que armazenam a altura e a largura da janela para desenhar</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - array inteiro não assinado de 8 bits (você pode armazenar números no intervalo de 0 a 255)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A matriz de dados possui uma estrutura simples, mas explicativa. </font><font style="vertical-align: inherit;">Essa matriz unidimensional armazena dados de cada pixel, que exibiremos na tela no seguinte formato:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os 4 primeiros elementos da matriz (índices 0,1,2,3) são os dados do primeiro pixel na primeira linha. Os segundos 4 elementos (índices 4, 5, 6, 7) são os dados do segundo pixel da primeira linha. Quando chegamos ao 800º pixel da primeira linha, desde que a janela tenha 800 pixels de largura - o 801º pixel já pertencerá à segunda linha. Se mudarmos, na tela veremos que o 1º pixel da 2ª linha foi alterado (embora pela contagem na matriz seja o 801º pixel). Por que existem 4 elementos para cada pixel na matriz? Isso ocorre porque, na tela, além de alocar 1 elemento para cada cor - vermelho, verde, azul (são 3 elementos), mais 1 elemento para transparência (eles também dizem canal alfa ou opacidade). O canal alfa, como a cor, é definido no intervalo de 0 (transparente) a 255 (opaco). Com essa estrutura, obtemos uma imagem de 32 bits,porque cada pixel consiste em 4 elementos de 8 bits. Para resumir: cada pixel contém: cores vermelha, verde, azul e canal alfa (transparência). Esse esquema de cores é chamado ARGB (Alpha Red Green Blue). E o fato de cada pixel ocupar 32 bits diz que temos uma imagem de 32 bits (eles também dizem uma imagem com uma profundidade de cor de 32 bits).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por padrão, toda a matriz de pixels imageData.data (data é uma propriedade na qual a matriz de pixels e imageData é apenas um objeto) é preenchida com os valores 0 e, se tentássemos produzir essa matriz, não veríamos nada de interessante na tela, porque 0 , 0, 0 é preto, mas como a transparência aqui também será 0, e essa é uma cor completamente transparente, nem veremos preto na tela!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É inconveniente trabalhar diretamente com uma matriz unidimensional; portanto, escreveremos uma classe na qual criaremos métodos para desenhar. Vou nomear a classe - Gaveta. Essa classe armazenará apenas os dados necessários e executará os cálculos necessários, abstraindo o máximo possível da ferramenta usada para renderização. É por isso que colocaremos todos os cálculos e trabalharemos com a matriz. E a própria chamada para o método de exibição na tela, colocaremos fora da classe, porque pode haver algo mais em vez de tela. Nesse caso, nossa classe não precisará ser alterada. Para trabalhar com uma matriz de pixels (superfície), é mais conveniente salvá-lo na classe Drawer, bem como na largura e altura da imagem, para que possamos acessar corretamente o pixel desejado. Portanto, a classe Drawer, preservando os dados mínimos necessários para desenhar, fica assim para mim:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;surface = <span class="hljs-literal">null</span>
&nbsp;&nbsp;&nbsp;&nbsp;width = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;height = <span class="hljs-number">0</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(surface, width, height) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface = surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.width = width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.height = height<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode ver no construtor, a classe Drawer pega todos os dados necessários e os salva. </font><font style="vertical-align: inherit;">Agora você pode criar uma instância dessa classe e passar uma matriz de pixels, largura e altura para ela (já temos todos esses dados, porque os criamos acima e os armazenamos em imageData):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> drawer = <span class="hljs-keyword">new</span> Drawer(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.data,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.width,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.height<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na classe Drawer, escreveremos várias funções de desenho, para facilitar o trabalho no futuro. </font><font style="vertical-align: inherit;">Teremos uma função para desenhar um pixel, uma função para desenhar uma linha e, em outros artigos, funções para desenhar um triângulo e outras formas aparecerão. </font><font style="vertical-align: inherit;">Mas vamos começar com o método de desenho de pixels. </font><font style="vertical-align: inherit;">Vou chamá-lo de drawPixel. </font><font style="vertical-align: inherit;">Se desenharmos um pixel, ele deverá ter coordenadas e cores:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b)&nbsp; { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Observe que a função drawPixel não aceita o parâmetro alfa (transparência) e, acima, descobrimos que a matriz de pixels consiste em 3 parâmetros de cor e 1 parâmetro de transparência. Não indiquei especificamente transparência, pois absolutamente não precisamos dela para obter exemplos. Por padrão, definiremos 255 (ou seja, tudo será opaco). Agora vamos pensar em como escrever a cor desejada em uma matriz de pixels em coordenadas x, y. Como temos todas as informações sobre a imagem, elas são armazenadas em uma matriz unidimensional, na qual 1 pixel (8 bits) é alocado para cada pixel. Para acessar o pixel desejado na matriz, primeiro precisamos determinar o índice de localização vermelho, porque qualquer pixel começa com ele (por exemplo, [r, g, b, a]). Uma pequena explicação da estrutura da matriz:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/4j/8o/uz4j8olujyuhzo3z1anuexucnoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A tabela em verde indica como os componentes de cores são armazenados em uma matriz de superfície unidimensional. Seus índices na mesma matriz são indicados em azul e as coordenadas do pixel que aceita as funções drawPixel, que precisamos converter em índices na matriz unidimensional, indicam r, g, b, a para o pixel em azul. Assim, a partir da tabela, pode-se ver que, para cada pixel, o componente vermelho da cor vem primeiro, vamos começar com ele. Suponha que desejemos alterar o componente vermelho da cor do pixel nas coordenadas X1Y1 com um tamanho de imagem de 2 por 2 pixels. Na tabela, vemos que esse é o índice 12, mas como calculá-lo? Primeiro, encontramos o índice da linha que precisamos, para isso multiplicamos a largura da imagem por Y e por 4 (o número de valores por pixel) - este será:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 <font></font>
//  :<font></font>
2 * 1 * 4 = 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos que a segunda linha começa com o índice 8. Se compararmos com a placa, o resultado converge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora você precisa adicionar um deslocamento de coluna ao índice de linha encontrado para obter o índice vermelho desejado. </font><font style="vertical-align: inherit;">Para fazer isso, adicione X vezes 4. ao índice de linhas.A fórmula completa será:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 + x * 4 <font></font>
//     :<font></font>
(width * y + x) * 4<font></font>
//  :<font></font>
(2 * 1 + 1) * 4 = 12</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora comparamos 12 com a tabela e vemos que o pixel X1Y1 realmente começa com o índice 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para encontrar os índices de outros componentes de cores, você precisa adicionar um deslocamento de cor ao índice vermelho: +1 (verde), +2 (azul), +3 (alfa) . </font><font style="vertical-align: inherit;">Agora podemos implementar o método drawPixel dentro da classe Drawer usando a fórmula acima:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset] = r
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse método drawPixel, renderizei a parte repetitiva da fórmula na constante de deslocamento. Também é visto que em alpha eu apenas escrevo 255, porque está na estrutura, mas agora não precisamos gerar pixels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É hora de testar o código e finalmente ver o primeiro pixel na tela. Aqui está um exemplo usando o método de renderização de pixel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Drawer</span>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
<font></font>
<span class="hljs-comment">//         canvas</span>
ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No exemplo acima, eu desenho 2 pixels, um vermelho 255, 0, 0 e o outro azul 0, 0, 255. Mas as alterações na matriz imageData.data (também é a superfície dentro da classe Drawer) não aparecerão na tela. Para desenhar, você precisa chamar ctx.putImageData (imageData, 0, 0), em que imageData é o objeto no qual a matriz de pixels e a largura / altura da área de desenho e 0, 0 é o ponto relativo ao qual a matriz de pixels será exibida (sempre deixe 0, 0 ) Se você fez tudo corretamente, terá a seguinte imagem no canto superior esquerdo do elemento de tela na janela do navegador: Você viu os </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/xn/cz/d8xnczchpgfg-9amhgdlyrpvzma.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pixels? Eles são tão pequenos e quanto trabalho foi feito.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, vamos tentar adicionar um pouco de dinâmica ao exemplo, por exemplo, para que a cada 10 milissegundos nosso pixel mude para a direita (alteramos X pixels por +1 a cada 10 milissegundos), corrigimos o código de desenho de pixel por um de cada vez:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Neste exemplo, deixei apenas a saída do pixel azul e envolvi a função setInterval com o parâmetro 10. Em JavaScript, o que significa que o código será chamado aproximadamente a cada 10 milissegundos. Se você seguir esse exemplo, verá que, em vez de um pixel se deslocar para a direita, terá algo assim: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/0v/uu/8o0vuuurtmmqgu8uy7sufdka16o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma faixa (ou traço) tão longa permanece porque não limpamos a cor do pixel anterior na matriz de superfície, portanto, a cada chamada para o intervalo que adicionamos um pixel. Vamos escrever um método que limpe a superfície ao seu estado original. Em outras palavras, preencha a matriz com zeros. Adicione o método clearSurface à classe Drawer:</font></font><br>
<br>
<pre><code class="javascript hljs">clearSurface() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não há lógica nessa matriz, apenas preenchendo com zeros. </font><font style="vertical-align: inherit;">É recomendável que você chame esse método todas as vezes antes de desenhar uma nova imagem. </font><font style="vertical-align: inherit;">No caso de animação de pixel, antes de desenhar esse pixel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.clearSurface()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, se você executar este exemplo, o pixel será deslocado para a direita, um por um - sem um rastreamento desnecessário das coordenadas anteriores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última coisa que implementamos no primeiro artigo é o método de desenho de linha. </font><font style="vertical-align: inherit;">Adicione-o, é claro, à classe Drawer. </font><font style="vertical-align: inherit;">O método que chamarei de drawLine. </font><font style="vertical-align: inherit;">O que ele vai levar? </font><font style="vertical-align: inherit;">Ao contrário de um ponto, a linha ainda tem as coordenadas nas quais termina. </font><font style="vertical-align: inherit;">Em outras palavras, a linha tem um começo, fim e cor, que passaremos para o método:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qualquer linha consiste em pixels, resta apenas preenchê-la corretamente com pixels de x1, y1 a x2, y2. Para começar, como a linha consiste em pixels, então a produziremos pixel por pixel no loop, mas como calcular quantos pixels produzir? Por exemplo, para desenhar uma linha de [0, 0] a [3, 0], é intuitivamente claro que você precisa de 4 pixels ([0, 0], [1, 0], [2, 0], [3, 0]) . Mas de [12, 6] a [43, 14], ainda não está claro quanto tempo a linha será (quantos pixels exibir) e quais coordenadas terão. Para fazer isso, lembre-se de um pouco de geometria. Portanto, temos uma linha que começa em x1, y1 e termina em x2, y2.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/z7/ip/ouz7ipd2uiokmmijlro7wldayzw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos desenhar uma linha pontilhada do começo e do fim para obter um triângulo (figura acima). </font><font style="vertical-align: inherit;">Veremos que na junção das linhas desenhadas um ângulo de 90 graus se formou. </font><font style="vertical-align: inherit;">Se o triângulo tiver esse ângulo, o triângulo será chamado de retangular, e seus lados, entre os quais o ângulo é de 90 graus, serão chamados de pernas. </font><font style="vertical-align: inherit;">A terceira linha sólida (que estamos tentando desenhar) é chamada hipotenusa em um triângulo. </font><font style="vertical-align: inherit;">Usando essas duas pernas introduzidas (c1 e c2 na figura), podemos calcular o comprimento da hipotenusa usando o teorema de Pitágoras. </font><font style="vertical-align: inherit;">Vamos ver como fazer isso. </font><font style="vertical-align: inherit;">A fórmula para o comprimento da hipotenusa (ou comprimento da linha) será a seguinte:&nbsp;</font></font><br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x433;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x438;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43F;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43D;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x443;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x437;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mo>=</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="31.778ex" height="4.759ex" viewBox="0 -1401.3 13682.2 2049.1" role="img" focusable="false" style="vertical-align: -1.505ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(376,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1345,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1776,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2152,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2535,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3019,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3450,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3790,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-3D" x="4499" y="0"></use><g transform="translate(5555,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJSZ2-221A" x="0" y="87"></use><rect stroke="none" width="7126" height="60" x="1000" y="1178"></rect><g transform="translate(1000,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(430,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1237,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1620,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1997,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-31" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-32" x="707" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-2B" x="3173" y="0"></use><g transform="translate(4174,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(4605,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5035,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5412,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5795,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(6171,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhjP0QQmibMlZUshvnH31jSQelvVrA#MJMAIN-32" x="707" y="583"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mo>=</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> = \sqrt{1^2 + 2^2}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como obter as duas pernas também é visto a partir do triângulo. </font><font style="vertical-align: inherit;">Agora, usando a fórmula acima, encontramos a hipotenusa, que será a linha longa (o número de pixels):</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Já sabemos quantos pixels desenhar para desenhar uma linha. Mas ainda não sabemos como os pixels são deslocados. Ou seja, precisamos desenhar uma linha de x1, y1 a x2, y2, sabemos que o comprimento da linha será, por exemplo, 20 pixels. Podemos desenhar o primeiro pixel em x1, y1 e o último em x2, y2, mas como encontrar as coordenadas dos pixels intermediários? Para fazer isso, precisamos saber como mudar cada próximo pixel em relação a x1, y1 para obter a linha desejada. Vou dar mais um exemplo para entender melhor de que tipo de deslocamento estamos falando. Temos pontos [0, 0] e [0, 3], precisamos desenhar uma linha neles. A partir do exemplo, é claramente visto que o próximo ponto após [0, 0] será [0, 1] e, em seguida, [0, 2] e, finalmente, [0, 3]. Ou seja, X de cada ponto não foi deslocado, ou podemos dizer que foi deslocado por 0 pixels, e Y foi deslocado por 1 pixel, esse é o deslocamento,pode ser escrito como [0, 1]. Outro exemplo: temos um ponto [0, 0] e um ponto [3, 6], vamos tentar calcular em nossa mente como eles mudam, o primeiro será [0, 0], depois [0,5, 1] ​​e depois [1, 2] depois [1,5, 3] e assim por diante a [3, 6]; neste exemplo, o deslocamento será [0,5, 1]. Como calcular?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Você pode usar a seguinte fórmula:</font></font><br>
<br>
<pre><code class="javascript hljs">   = <span class="hljs-number">2</span> /  <font></font>
  Y = <span class="hljs-number">1</span> /  &nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No código do programa, teremos o seguinte:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> xStep = c2 / length
<span class="hljs-keyword">const</span> yStep = c1 / length</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos os dados já estão lá: comprimento da linha, deslocamento de pixels ao longo de X e Y. Começamos no ciclo para desenhar:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como coordenada X da função Pixel, transferimos o início da linha X + deslocamento X * i, obtendo assim a coordenada do i-ésimo pixel, calculamos também a coordenada Y. Math.trunc é um método em JS que permite descartar a parte fracionária de um número. </font><font style="vertical-align: inherit;">Todo o código do método fica assim:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> xStep = c2 / length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A primeira parte chegou ao fim, um longo mas emocionante caminho para compreender o mundo 3D. </font><font style="vertical-align: inherit;">Ainda não havia nada tridimensional, mas realizamos operações preparatórias para desenhar: implementamos as funções de desenhar um pixel, uma linha, limpar uma janela e aprendemos alguns termos. </font><font style="vertical-align: inherit;">Todo o código da classe Drawer pode ser visualizado no spoiler:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Código de classe da gaveta</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
  surface = <span class="hljs-literal">null</span>
  width = <span class="hljs-number">0</span>
  height = <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(surface, width, height) {
    <span class="hljs-keyword">this</span>.surface = surface
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height<font></font>
  }<font></font>
<font></font>
  drawPixel(x, y, r, g, b)  {<font></font>
    <span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
    <span class="hljs-keyword">this</span>.surface[offset] = r
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span><font></font>
  }<font></font>
<font></font>
  drawLine(x1, y1, x2, y2, r, g, b) {<font></font>
    <span class="hljs-keyword">const</span> c1 = y2 - y1
    <span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> xStep = c2 / length
    <span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; length ; i++) {
        <span class="hljs-keyword">this</span>.drawPixel(
          <span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
          <span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
          r, g, b,<font></font>
        )<font></font>
    }<font></font>
  }<font></font>
<font></font>
  clearSurface() {<font></font>
    <span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
      <span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qual é o próximo?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No próximo artigo, veremos como uma operação tão simples como a saída de um pixel e uma linha pode se transformar em objetos 3D interessantes. </font><font style="vertical-align: inherit;">Vamos nos familiarizar com matrizes e operações nelas, exibir um objeto tridimensional em uma janela e até adicionar animação.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt494076/index.html">Análise: estratégias de comportamento do investidor durante quedas no mercado de ações</a></li>
<li><a href="../pt494082/index.html">Dalenka: os artigos mais úteis sobre o trabalho eficaz em casa</a></li>
<li><a href="../pt494084/index.html">Coronavírus: serviços de informação online</a></li>
<li><a href="../pt494090/index.html">Limitação do aipo - configuração do limite de taxa para filas</a></li>
<li><a href="../pt494092/index.html">Degradação da estrutura conectada</a></li>
<li><a href="../pt494096/index.html">Implantação da intranet. Experiência, erros, recomendações</a></li>
<li><a href="../pt494098/index.html">Abordagem imperativa para dados reativos no exemplo de Jetbrains KTor e R2DBC</a></li>
<li><a href="../pt494100/index.html">O que você precisa para criar o modelo ideal de um centro educacional para treinar especialistas em TI</a></li>
<li><a href="../pt494114/index.html">Como reduzir o número e aumentar a legibilidade do código em react-redux, redux-saga</a></li>
<li><a href="../pt494118/index.html">COVID-19 Telegram-bot // Respondemos perguntas frequentes automaticamente</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>