<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕎 🔀 📻 Rust、Haskell、C ++、Python、Scala、OCamlで同じプロジェクトを比較する 🖋️ 🤞 ⬅️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大学の前学期に、CS444コンパイラコースを選びました。そこでは、1〜3人の各グループが、x86のJavaの実質的なサブセットからコンパイラを作成する必要がありました。グループを選択する言語。これは、非常に有能なプログラマがさまざまな言語で作成した同じ機能の大規模なプログラムの実装を比較し、設計と言...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rust、Haskell、C ++、Python、Scala、OCamlで同じプロジェクトを比較する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456638/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大学の前学期に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、CS444コンパイラコース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を選びまし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">。そこでは、1〜3人の各グループが、x86のJavaの実質的なサブセットからコンパイラを作成する必要がありました。グループを選択する言語。これは、非常に有能なプログラマがさまざまな言語で作成した同じ機能の大規模なプログラムの実装を比較し、設計と言語の選択の違いを比較するまれな機会でした。そのような比較は多くの興味深い考えを引き起こしました。言語のそのような制御された比較はめったに見られません。それは完璧ではありませんが、プログラミング言語についての人々の意見が基づくほとんどの主観的な物語よりもはるかに優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはRustコンパイラーを作成し、最初にそれをHaskellチームプロジェクトと比較しました。彼らのプログラムはもっと短くなると思っていましたが、同じサイズかそれ以上であることがわかりました。 OCamlについても同様です。次に、C ++コンパイラーと比較したところ、主にヘッダー、合計タイプの欠如、パターンマッチングにより、コンパイラーが約30％大きくなることがかなり予想されました。次の比較は、Pythonで自分でコンパイラを作成し、メタプログラミングと動的型の能力により、私たちと比較してコードの半分未満を使用した私のガールフレンドとの比較です。別の友人が小さなScalaプログラムを持っていました。私を最も驚かせたのは、Rustを使用した別のチームとの比較でしたが、設計上の決定が異なるため、3倍のコードがあることがわかりました。最終的に、コード量の最大の違いは同じ言語内にありました！</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが良い比較であると考える理由を説明し、各プロジェクトに関する情報を提供し、コンパイラーのサイズに違いがあるいくつかの理由を説明します。</font><font style="vertical-align: inherit;">また、各比較から結論を導き出します。</font><font style="vertical-align: inherit;">これらのリンクを使用して、興味のあるセクションに進んでください。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h1><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが意味があると思うのか</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さび（比較の基準）</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haskell</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：興味深い理由により、カウント方法に応じて1.0〜1.6サイズ</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：明らかな理由から1.4サイズ</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：派手なメタプログラミングにより0.5サイズ！</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">錆（別グループ）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：デザイン違いでサイズが3倍！</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：0.7サイズ</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OCaml</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：Haskellと同様に、カウント方法に応じて1.0〜1.6サイズ</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜそれが意味があると思うのか</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの量（文字列とバイトの両方を比較した）がひどいメトリックであると言う前に、この場合は十分に理解できることに注意したいと思います。</font><font style="vertical-align: inherit;">少なくともこれは、私が聞いたり読んだりした同じ大きなプログラムを異なるチームが作成する最も適切に制御された例です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このパラメーターを測定することを誰も（私も含めて）知らなかったため、メトリックを再生しようとする人は誰もいなかった。誰もがプロジェクトを迅速かつ正確に終了しようとしただけだ。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべて（後で説明するPythonプロジェクトを除く）は、同じ自動テストスイートに同時に合格することのみを目的としてプログラムを実装したため、さまざまな問題を解決するグループによって結果が大きく歪むことはありません。</font></font><br>
</li>
<li>      ,  ,         ,    .  ,       .<br>
</li>
<li>   ,        ,      ,      Java   ,    .<br>
</li>
<li> ,   ,  ,     ,       .  ,         ,      .<br>
</li>
<li>   ,    .       .  ,          ,   ,      .<br>
</li>
<li>   — ,       .        ,  ,   ,     .       7-13    ,         .<br>
</li>
<li>   ,      ,    .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コードの量は、各プロジェクトを長期的にサポートするためにどれだけの労力が必要かを適切に理解できると思います。</font><font style="vertical-align: inherit;">プロジェクト間の違いがあまり多くなくても、たとえば、Haskellコンパイラーが言語のおかげでC ++の半分以上になるという、私が読んだいくつかの異常なステートメントを否定することができると思います。</font></font><br>
<br>
<a name="1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さび（比較の基準）</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私と私の仲間の1人は、以前Rustで1万行以上を書き、3人目の同僚はおそらく500行をいくつかのハッカソンで書きました。コンパイラーは6806行</font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ソースの5900行（スペースとコメントなし）、および220 KBで出力されました</font></font><code>wc -c</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のプロジェクトでは、いくつかの例外を除いて、これらの比率がほぼ尊重されていることに気付きました。記事の残りの部分では、線または量を参照するときはを意味</font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しますが、それは問題ではなく（違いに気付かない場合）、係数で変換できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">たちのデザインを説明する別の記事</font></a><font style="vertical-align: inherit;">を書いた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての公開テストと秘密テストに合格した人。</font><font style="vertical-align: inherit;">また、テストに合格するためではなく、楽しみのために行ったいくつかの追加機能も含まれています。</font><font style="vertical-align: inherit;">また、約500行の単体テストがあります。</font></font><br>
<br>
<a name="2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハスケル</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellチームには、おそらくそれぞれ数千行のHaskellを書いた2人の友人が含まれており、Haskellや、OCamlやLeanなどの他の同様の関数型言語に関するオンラインコンテンツをたくさん読んでいました。彼らには私がよく知らない別のチームメイトがいましたが、以前は強力なプログラマーがHaskellを使用していたようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らのコンパイラは合計で9,750 </font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">行のコード、357 KBおよび7777行のコード（SLOC）でした。このチームには、これらの比率の間の唯一の大きな違いもあります。それらのコンパイラーは、行でのコンパイラーの1.4倍、SLOCで1.3倍、バイトで1.6倍です。彼らは追加の機能を実装せず、公開テストと秘密テストの100％に合格しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストを含めることは、何よりもこのチームに影響を与えたことに注意することが重要です。彼らはコードの正確さに注意深く取り組んだため、1,600行のテストが含まれていました。彼らは私たちのチームがキャッチしなかったいくつかの境界線の状況をキャッチしましたが、これらのケースはコーステストによって単にチェックされませんでした。したがって、両側でテストを行わない場合（6.3千行対8.1千行）、コンパイラーは私たちのものよりも30％だけ多くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ボリューム比較のより合理的な尺度としてバイトを使用します。Haskellプロジェクトでは、1つの閉じ角かっこからの行数が多くないため、平均して長い行があり、</font></font><code>rustfmt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一行の関数チェーンが複数の行に分割されないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のチームメイトの1人と話し合った後、この違いについて次の説明を思いつきました。</font></font><br>
<br>
<ul>
<li>        ,  &nbsp;—   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">NFA</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">DFA</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">LR-</a>,          AST (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  </a>,    ).      : 2677      1705,   1000  .<br>
</li>
<li>    AST,      ,       .       , , ,    AST   500  ,   ,      struct    <code>Option&lt;_&gt;</code>      .<br>
</li>
<li>    400    ,       ,         ,        .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの違いとテストは、ボリュームのすべての違いを説明します。実際、定数の折りたたみとコンテキスト解決のためのファイルは、サイズが非常に近いです。しかし、それでも、文字列が長いためにバイトに多少の違いがあります。おそらく、各パスでツリー全体を書き換えるには、より多くのコードが必要になるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として、私の判断では、RustとHaskellは設計上の決定を脇に置いて表現力を高めていますが、便利なときに変異を簡単に使用できるため、Rustにはわずかな利点があります。私の再帰的降下法と手書きの字句解析器の選択が報われたことを知ることも興味深いことでした：教授の推奨事項と指示に矛盾するのはリスクでしたが、それはより簡単で正しいと判断しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haskellのファンは、そのチームはおそらくHaskellを十分に活用していなかったと主張し、言語をよりよく理解していれば、より少ないコードでプロジェクトを実行できただろう。私は同意します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エドワード・クメットの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような誰か</font><font style="vertical-align: inherit;">が同じコンパイラをはるかに少ない量で書くことができます。確かに、私の友人のチームは、多くの豪華な高度な抽象概念や、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">レンズ</font></a><font style="vertical-align: inherit;">などの豪華なコンビネーターライブラリを使用していませんでした。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ただし、これはすべてコードの読みやすさに影響します。チームの全員は経験豊富なプログラマーであり、Haskellが非常に奇妙なことを実行できることを知っていましたが、理解するためには保存するよりも多くの時間を必要とし、他の人がコードを理解するのが困難になるため、それらを使用しないことにしました。これは私にとって本当に妥協のようであり、Haskellがコンパイラーに魔法のように適しているという主張は、「Haskellに熟練していない人々のコードサポートを気にしない場合、Haskellはコンパイラーを書くために非常に高い資格が必要である」のようなものになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各プロジェクトの最初に、教授は、学生は大学のサーバーで実行される任意の言語を使用できるが、Haskellのチームは他のチームとは異なることを警告していることに注意することも興味深いです。</font><font style="vertical-align: inherit;">多くの人は自分の能力を過大評価しており、Haskellのチームは最も成績が悪いですが、私の友達のようにうまくやっている人もいます。</font></font><br>
<br>
<a name="3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、C ++チームの友達と話しました。私はこのチームの1人しか知りませんでしたが、C ++は私たちの大学のいくつかのコースで使用されているので、おそらくチームの全員がC ++の経験がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らのプロジェクトは8733行と280 KBで構成され、テストコードは含まれていませんが、約500行の追加関数が含まれています。これにより、テストなしのコードの1.4倍になり、追加の関数が約500行あります。彼らは公開テストの100％に合格しましたが、秘密テストの90％だけに合格しました。おそらく、仕様で必要とされるファンシーなvtables配列を実装していなかったためと思われ、おそらく50〜100行のコードを必要とします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのサイズの違いについては、あまり深く掘り下げませんでした。これは主に次の理由によると思います：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再帰降下法の代わりに、LRパーサーとツリーリライターを使用します。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++には合計タイプとパターン比較がないため、広く使用されており、非常に便利でした。</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ヘッダーファイルのすべての署名を複製する必要がありますが、Rustの場合はそうではありません。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイル時間も比較しました。</font><font style="vertical-align: inherit;">私のラップトップでは、コンパイラーのクリーンデバッグビルドには9.7秒、ネットリリースには12.5秒、インクリメンタルデバッグビルドには3.5秒を要します。</font><font style="vertical-align: inherit;">私の友人は、C ++ビルド（並列makeを使用）のタイミングを手元にありませんでしたが、数は似ていると言いました。ただし、長い時間を犠牲にして、署名の重複を減らすために、ヘッダーファイルに多くの小さな関数の実装を配置しました（つまり、したがって、ヘッダーファイルのネットラインオーバーヘッドを測定できません）。</font></font><br>
<br>
<a name="4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイソン</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常に優れたプログラマーである私の友人は、このプロジェクトをPythonだけで作成することにしました。彼女はまた、レジスター割り当てやその他の最適化を備えた中間のSSAビューなど、他のどのチームよりも（楽しみのために）より高度な機能を実装しました。一方、それは単独で機能し、多くの追加機能を実装したため、コードの品質にはほとんど注意を払いませんでした。たとえば、次のようなエラータイプと対応するメッセージを実装する代わりに、すべてのエラーに対して未分化の例外をスローします（デバッグはバックトレースに依存します）。我ら。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼女のコンパイラーは4581行で構成され、すべての公開テストと秘密テストに合格しました。彼女はまた、他のどのコマンドよりも高度な関数を実装しましたが、追加の関数の多くは、定数の折りたたみやコードの生成など、誰もが実装する必要がある単純なもののより強力なバージョンだったため、どれだけ余分なコードが必要だったかを判断することは困難です。追加の関数は、少なくとも1000〜2000行になる可能性が高いため、そのコードは少なくとも2倍の表現力があると確信しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この違いの大きな部分は、おそらく動的型付けです。私たちだけで</font></font><code>ast.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">500行の型定義、およびコンパイラーの他の場所で定義されたさらに多くの型。また、常に型システム自体に限定されます。たとえば、ASTを通過して後でアクセスするときに、人間工学的にASTに新しい情報を追加するためのインフラストラクチャが必要です。 Pythonでは、ASTノードに新しいフィールドを設定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
強力なメタプログラミングも違いの一部を説明しています。たとえば、彼女は再帰降下法の代わりにLRパーサーを使用しましたが、私の場合、ツリーの書き換えを行う代わりに、彼女のLR文法にASTを構築するためのPythonコードの断片が含まれていたため、ジェネレーターがPython関数に変換できるため、コードが少なくなったと思います経由して</font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 LRパーサーを使用しなかった理由の1つは、ツリーを書き直さずにASTを構築するには、文法をRustコードのフラグメントに関連付けるために（Rustファイルまたは手続き型マクロを作成する）多くの式が必要になるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メタプログラミングと動的型付けの強力さのもう1つの例は、400行のファイルです</font></font><code>visit.rs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、基本的に、一連のAST構造にビジターを実装する繰り返し定型コードです。 Pythonでは、これは約10行の短い関数になる可能性があり、ASTノードのフィールドを再帰的にイントロスペクトし、（属性を使用して</font></font><code>__dict__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">それらを訪問します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rustと静的に型付けされた言語のファンとして、私は型システムがエラーの防止とパフォーマンスに非常に役立つことを指摘する傾向があります。</font><font style="vertical-align: inherit;">また、異常なメタプログラミングにより、コードの動作を理解するのが難しくなる場合もあります。</font><font style="vertical-align: inherit;">しかし、この比較は、コード量の違いがそれほど大きくなるとは予想していなかったことに驚いた。</font><font style="vertical-align: inherit;">全体としての違いが実際に2倍のコードを書く必要があることに近い場合でも、Rustは適切な妥協案であると思いますが、それでも半分のコードが議論であり、将来的にはRuby / Pythonで何かをする傾向がありますあなただけで何かを素早く構築し、それを捨てる必要がある場合。</font></font><br>
<br>
<a name="5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さび（別のグループ）</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私にとって最も興味深い比較は、Rustで1人のチームメイト（知らなかった）とプロジェクトを行っていた友人との比較でした。私の友人は良い錆の経験をしました。彼はRustコンパイラーの開発に貢献し、多くのことを読みました。私は彼の同志について何も知りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らのプロジェクトは、17,211の生の行、15,000のソース行、および637 KBで構成されていましたが、テストコードと生成されたコードは含まれていません。追加の機能はなく、仕様のより奇妙な部分を実装するための期限までに十分な時間がなかったため、コード生成のための10の秘密テストのうち4つとパブリックテストの90％のみに合格しました。彼らのプログラムは私たちのプログラムの3倍で、同じ言語で書かれており、機能性は低くなっています！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この結果は私にとって本当に素晴らしいものであり、これまでに勉強してきた言語間のすべての違いを覆い隠しました。そのため、ファイルサイズのリストを比較し、</font></font><code>wc -l</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードサイズが異なる特定のことをどのように実装したかを確認しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはすべて、さまざまな設計決定の一貫した採用に帰着するようです。たとえば、フロントエンド（字句解析、解析、ASTの構築）は2164に対して7597行かかります。DFA字句アナライザーとLALRパーサー（1）を使用しましたが、他のグループはそれほど多くのコードなしで同様のことを行いました。それらのウィーダーファイルを見て、私たちとは異なる多くの設計上の決定に気づきました。</font></font><br>
<br>
<ul>
<li>                . ,                    .<br>
</li>
<li>    <code>tryfrom</code>          AST    .     10-20-  <code>impl</code>.     ,   <code>Result</code>,    ,        ,     .  ,       <code>match</code>,      10-  <code>impl</code>.<br>
</li>
<li>   ,   . ,     <code>is_abstract</code>, <code>is_native</code>  <code>is_static</code>,        :    void-         return,   .       <code>void</code>    ,       <code>mode</code>  <code>visibility</code>,      ,          match,      <code>mode</code>  <code>visibility</code>.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は彼らのコンパイラの分析のパスのコードを見ていませんでしたが、それらも素晴らしいです。私は私の友人と話しました、そして彼らは私たちのもののような訪問者のインフラストラクチャーと同様のものを実装していなかったようです。これは、他のいくつかの小さな設計の違いとともに、このパーツのサイズの違いを説明していると思います。訪問者は、分析パスがAST構造全体でパターンを照合するのではなく、必要なASTの部分のみに焦点を当てることを許可します。これは多くのコードを節約します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らのコード生成部分は3594行と1560行で構成されています。私はそれらのコードを見て、ほとんどすべての違いは、直接アセンブラー出力に文字列フォーマットを使用したアセンブラー命令の中間データ構造を選択したことです。 。使用するすべての命令とオペランドの型について、型と出力関数を定義する必要がありました。また、アセンブリ命令の作成には、より多くのコードが必要でした。</font></font><code>mov ecx, [edx]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巨大な演算子を必要とする</font><font style="vertical-align: inherit;">ような短い指示を伴うフォーマット演算子があった場所</font></font><code>rustfmt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、6行に分割されており、最大6レベルのネストされた角かっこを含むオペランドのネストされた中間型の束で命令を構築しました。また、関数のプリアンブルなどの関連する命令のブロックを1つの形式ステートメントで出力することもできます。この場合、各命令の完全な構造を指定する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのチームは、そのような抽象化を彼らのものとして使用することを検討していました。テキストアセンブリを出力するか、マシンコードを直接発行する方が簡単でしたが、これはコースの要件ではありませんでした。同じことは、以下の</font></font><code>X86Writer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなメソッド</font><font style="vertical-align: inherit;">を持つトレイト</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して、少ないコードとより良いパフォーマンスで実行できます</font></font><code>push(reg: Register)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これによりデバッグとテストが簡単になることも考慮に入れましたが</font><font style="vertical-align: inherit;">、コメントを自由に挿入する</font><font style="vertical-align: inherit;">と、生成されたテキストアセンブラを表示して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スナップショット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストを使用して実際に読みやすくテストできることがわかりました</font><font style="vertical-align: inherit;">。しかし、私たちは（明らかに正しく）追加のコードが大量に必要になると予測しており、実際のニーズを考えると、実際のメリットはないため、心配する必要はありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを、C ++チームが余分な関数として使用した中間表現と比較すると、500行しか追加されません。彼らは、Javaが必要とするものに近い操作を使用する非常に単純な構造（単純な型定義とビルドコード用）を使用しました。これは、呼び出しやキャストなどの多くの言語操作が多くのアセンブラー命令に拡張されたため、中間表現が結果のアセンブラーよりもはるかに小さい（したがって必要なビルドコードが少ない）ことを意味しました。彼らはまた、多くのゴミを取り除き、読みやすさを改善したので、それが本当にデバッグを助けたと言っています。より高いレベルのビューでは、中間ビューで簡単な最適化を行うこともできました。C ++チームは、非常に優れた設計を考案しました。これにより、はるかに少ないコードでより多くの利益を得ることができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、ボリュームが3倍異なる一般的な理由は、より多くのコードに向けて、大小さまざまな設計上の決定を一貫して採用しているためです。彼らは私たちがしなかったいくつかの抽象化を実装しました-彼らはより多くのコードを追加し、コードの量を減らすためにいくつかの抽象化をスキップしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この結果は私を本当に驚かせました。設計上の決定が重要であることは知っていましたが、有能なプログラマーであると私が考える人だけを調べたので、それらがこのサイズの違いにつながることを事前に推測することはなかったでしょう。すべての比較結果の中で、これは私にとって最も重要です。このコースに進む前にコンパイラの書き方をよく読んだので、おそらく助かったので、ASTの訪問者や再帰的降下法など、他の人が思いついてうまく機能することがわかったスマートプロジェクトを使用できました。私たちのコースで。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が本当に考えさせられたのは、抽象化のコストです。抽象化は、将来の拡張を促進したり、特定のタイプのエラーから保護したりできますが、理解とリファクタリングのために3倍のコードを取得でき、エラーの可能性のある場所の3倍、テストのための時間を短縮できるため、それらを考慮する必要があります。開発。私たちのトレーニングコースは現実の世界とは異なりました。開発後にコードに触れることは絶対にありません。これにより、プロアクティブな抽象化の利点がなくなります。ただし、後で説明する任意の関数で拡張するコンパイラを選択する必要がある場合は、自分が熟知していることを考慮せずに、コンパイラを選択します。理解するコードがはるかに少ないため、要件に最適な抽象化を選択できる可能性があります（たとえば、C ++コマンドの中間表現）特定の要件を知っているとき。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、私の見解では、抽象化の分類法が強化されました。ビジターテンプレートのように、現在の要件のみを考慮してコードを削減するものや、コードを追加するが、拡張性、デバッグ、または正確さの利点を提供する抽象化があります。</font></font><br>
<br>
<a name="6"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scala</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、前学期にScalaでプロジェクトを行った友人とも話しましたが、プロジェクトとテストはまったく同じでした。</font><font style="vertical-align: inherit;">コンパイラーは4141行と最大160 KBのコードで構成され、テストは含まれません。</font><font style="vertical-align: inherit;">彼らは、10個中8個の秘密テストと100％オープンテストに合格し、追加機能を実装していませんでした。</font><font style="vertical-align: inherit;">したがって、追加の関数やテストがない5906ラインと比較すると、コンパイラーは30％少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
小さな設計要素の1つは、解析への異なるアプローチでした。このコースでは、LRテーブルジェネレーターのコマンドラインツールを使用できました。このチーム以外は誰も使用していません。これにより、LRテーブルジェネレーターを実装する必要がなくなりました。彼らはまた、150行のPythonスクリプトを使用してLR文法を書くことを避け、インターネットで見つけたJava文法のWebページをスクレイピングしてジェネレーターの入力形式に変換しました。 Scalaでなんらかのツリーを作成する必要がありましたが、一般に、解析段階は1443と比較して1073行になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のコンパイラーも私たちのものより小さく、明らかな大きな設計上の違いはありませんでしたが、コードを掘り下げませんでした。</font><font style="vertical-align: inherit;">これはScalaとRustの表現力の違いによるものだと思います。</font><font style="vertical-align: inherit;">ScalaとRustには、パターンマッチングなどのコンパイラーに役立つ同様のプログラミング機能がありますが、Scalaのマネージメモリは、ボローチェッカーがRustで機能するために必要なコードを節約します。</font><font style="vertical-align: inherit;">さらに、ScalaにはRustよりも多様な構文糖があります。</font></font><br>
<br>
<a name="7"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OCaml</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのチームのすべてのメンバーは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェーンストリート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（テクノロジートレーディング会社-約）で</font><font style="vertical-align: inherit;">インターンシップを受けるので</font><font style="vertical-align: inherit;">、コンパイラーを作成するためにOCamlを選んだ他の元ジェーンストリートインターンの結果に特に興味がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラは10,914行、377 KBで、少量のテストコードを含み、追加機能はありませんでした。彼らは9/10の秘密のテストとすべての公開テストに合格しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のグループと同様に、サイズの主な違いは、ツリーの解析と書き換えにLRパーサーを使用していることと、字句解析に正規表現-&gt; NFA-&gt; DFA変換パイプラインを使用しているためと思われます。それらのフロントエンド（字句解析、解析、AST構築）は5548行で、2164行で、バイトの比率は同じです。彼らはまた</font><font style="vertical-align: inherit;">、予想される出力をコードの外側に置くスナップショットテストと同様であることを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">期待</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font><font style="vertical-align: inherit;">、パーサーの</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">テスト</font></a><font style="vertical-align: inherit;">を使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">まし</font></a><font style="vertical-align: inherit;">た。その</font><font style="vertical-align: inherit;">ため、パーサーテストは合計の約600行になり、私たちのテストは約200行になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、残りのコンパイラ用に5366行（そのうちの461行が型宣言のあるインターフェイスファイル）および4642行が残ります。インターフェイスファイルを数えると、差はわずか15％ですが、サイズはほぼ同じです。</font><font style="vertical-align: inherit;">私たちの解析設計の決定は別として、OCamlがフロントエンドファイルを必要とし、Rustはそうではないことを除いて、RustとOCamlは同等に表現力豊かに見えます。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、この比較を行ってよかったと思います。多くのことを学び、何度も驚きました。</font><font style="vertical-align: inherit;">一般的な結論は、デザインの決定は言語よりもはるかに重要であると思いますが、言語はさまざまなデザインを実装するためのツールを提供するため重要です。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456622/index.html">クラスI保護に従って認定されたOSを作成する方法</a></li>
<li><a href="../ja456624/index.html">便利なPythonツール</a></li>
<li><a href="../ja456630/index.html">Airflowを導入してiviでSparkジョブを管理する：希望と松葉杖</a></li>
<li><a href="../ja456632/index.html">RESTinioでC ++テンプレートの4階を構築しています。なぜ、どうやって？</a></li>
<li><a href="../ja456634/index.html">Nginxレシピ：CAS（中央承認サービス）</a></li>
<li><a href="../ja456640/index.html">PHDays 9での競争情報コンテストの分析</a></li>
<li><a href="../ja456642/index.html">JetBrainsコーポレートマスタープログラムとITMO大学の最初の卒業</a></li>
<li><a href="../ja456644/index.html">より安価なフォトポリマー3DプリンターがKickstarterに登場</a></li>
<li><a href="../ja456646/index.html">インダルジェンス-タスクの負債を取り除く方法</a></li>
<li><a href="../ja456650/index.html">バジェットポケットオシロスコープの選択</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>