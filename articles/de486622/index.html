<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📪 👩🏾‍🤝‍👩🏽 😛 Paralleles Rechenmodell 👋🏼 🛀🏻 👈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Einleitung. Wettbewerbskorutinismus
 Frühere Artikel zum Thema automatische Programmierung waren nur „Blumen“. Die "Beere" der automatischen Progra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Paralleles Rechenmodell</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Einleitung. </font><font style="vertical-align: inherit;">Wettbewerbskorutinismus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frühere Artikel zum Thema automatische Programmierung waren nur „Blumen“. Die "Beere" der automatischen Programmierung, d.h. Für das, was Sie tun müssen, ist ein Modell des parallelen Rechnens basierend auf dem Zustandsmaschinenmodell. Also, lass uns gehen ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der C ++ - Standard enthielt die lang erwartete Unterstützung für Multithreading [1]. Aber wir werden es weder bewundern noch kritisieren, weil Die Arbeit mit Threads wird durch so viele Bedingungen, Vorbehalte und Funktionen belastet, dass eine Diskussion über Multithread-Programmierung ohne Beispiele aus der Praxis, die Multithreading-Probleme aufzeigen, nicht nur voreilig, sondern auch ziemlich voreingenommen sein wird. Daher im Folgenden hauptsächlich nicht über Flüsse, sondern über Automaten, wobei natürlich die ersten berücksichtigt werden.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die C ++ - Sprache ist weit von der ersten entfernt und wird durch Parallelitätskonstrukte ergänzt. In den 60er Jahren des letzten Jahrhunderts schlug N. Wirth eine parallele Erweiterung der ALGOL-Sprache vor [2]. Die nächsten 60 Jahre haben jedoch nicht geklärt, was als paralleler Algorithmus und was das Modell des parallelen Rechnens sein sollte. Anscheinend ist damit auch eine solche verspätete Erweiterung der C ++ - Sprache verbunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sowohl die langjährigen Konstrukte der ALGOL-Sprache als auch ihre moderneren Analoga in der C ++ - Sprache sind nur strukturelle Parallelisierungsmethoden, die kein paralleles algorithmisches Modell einführen. Um dies zu rechtfertigen, kann gesagt werden, dass die in der vergangenen Zeit unternommenen Versuche, ein solches formales Berechnungsmodell zu erstellen, gescheitert sind. Es genügt zu sagen, dass dieselben Petri-Netze die großen Hoffnungen, die auf sie gesetzt wurden, nicht rechtfertigten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen scheint die „Spirale“ der Parallelitätsentwicklung zu ihrer Quelle zurückgekehrt zu sein, da sie nur eine „terminologische Entwicklung“ durchlaufen hat. </font><font style="vertical-align: inherit;">Ehemalige triviale Coroutinen wurden plötzlich zu fortgeschrittenen „Coroutinen“ (Transparentpapier der englischen Coroutine), und die Verwechslung mit den Konzepten der Parallelität und Gleichzeitigkeit im englischsprachigen Segment der parallelen Programmierung führt manchmal zu paradoxen Dingen. </font><font style="vertical-align: inherit;">Beispielsweise unterscheidet sich die erste Ausgabe des Buches [1] von der zweiten Ausgabe, indem die Begriffe "parallel" durch "wettbewerbsfähig" und "multithreaded" durch "parallel" ersetzt werden. </font><font style="vertical-align: inherit;">Finden Sie dies in der Situation „Wer ist wer?“ Heraus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Paralleles Automatenmodell von Berechnungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich wird niemand bestreiten, dass der nächste qualitative Schritt in der Entwicklung der Programmierung mit dem Übergang zu einem parallelen Rechenmodell verbunden ist. Ob dies jedoch aufgrund der evolutionären Entwicklung des bestehenden Rechenmodells geschehen wird oder ob es sich um ein grundlegend anderes Modell handelt, wird derzeit noch diskutiert. Und wenn Theoretiker immer noch streiten, dann verwendet der praktisch motivierte Teil der Programmierer bereits strukturelle Methoden zur Parallelisierung von Programmen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgabentrennung und Produktivitätssteigerung werden als einzige Gründe für die Verwendung von Parallelität angesehen. Zumindest für sie oder ihre Kombinationen reduzieren oder versuchen letztendlich alle anderen zu reduzieren [1]. Es gibt jedoch einen Grund, über den selten gesprochen wird, weshalb es sich im Allgemeinen lohnt, parallel zu programmieren. In der Tat kann die Geschwindigkeit durch reine Hardwaremethoden erhöht werden, und die Aufgabentrennung mit Parallelität ist auf die gleiche Weise verbunden wie die tägliche Arbeit der Bankangestellten mit einer Liste ihrer offiziellen Aufgaben. Und nur parallele Algorithmen sind eine Strategie, mit der wir die Komplexität von Aufgaben überwinden und die Zuverlässigkeit von Programmen erhöhen können. Und all dies widerspricht der vorherrschenden Meinung bezüglich der Multithread-Programmierung, die jedes parallele Programm in ein komplexes und unzuverlässiges Softwareprodukt verwandelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein paralleles System, das aus vielen parallel funktionierenden und aktiv interagierenden Komponenten, Objekten, Agenten usw. besteht, implementiert einen Algorithmus, der in vielerlei Hinsicht nicht durch die Algorithmen der einzelnen Komponenten (obwohl natürlich auch), sondern durch die Anzahl der Komponenten, die Anzahl und bestimmt wird Art von Verbindungen zwischen ihnen. Um diese Komplexität zu kontrollieren und den Algorithmus des parallelen Systems zu verstehen, benötigen Sie nicht nur ein paralleles Rechenmodell, sondern ein Modell, das unter anderem und vor allem eine geeignete Theorie aufweist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die These, dass „ein paralleles Programm oft schwieriger zu verstehen ist ... und daher die Anzahl der Fehler zunimmt“, um es milde auszudrücken, ist umstritten. </font><font style="vertical-align: inherit;">Ja, der Parallelprogrammalgorithmus kann ziemlich schwer zu verstehen sein, aber wenn es eine Theorie gibt, kann er unter Verwendung von Komponentenalgorithmen formal "berechnet" werden. </font><font style="vertical-align: inherit;">Unter dem Gesichtspunkt des Entwurfs, der Implementierung und der Wartung der Komponentenalgorithmen ist dies viel einfacher als der Algorithmus des gesamten Systems. </font><font style="vertical-align: inherit;">Beim Entwerfen einfacherer Komponenten machen wir offensichtlich weniger Fehler als beim Entwerfen eines Systems in einem Stück. </font><font style="vertical-align: inherit;">Darüber hinaus können debuggte Komponenten Teil anderer Systeme sein, wodurch die Komplexität verringert, die Zuverlässigkeit erhöht und die Konstruktionskosten minimiert werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Serielle Parallelität</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel [3] beschrieb die Parallelität eines separaten Modells einer endlichen Zustandsmaschine. Seine Kanäle auf der Ebene der Ausführung von Übergängen spezifizieren die parallele Ausführung der damit verbundenen Funktionen / Methoden - Prädikate und Aktionen. Gleichzeitig gibt es keine Einschränkungen für die Prädikatparallelität. Bei der Arbeit stehen sie nicht in Konflikt miteinander, weil Beeinflussen Sie nicht den Inhalt des Speichers. Parallel arbeitende Aktionen können gemeinsame Eingabe- und Ausgabedaten haben und diese unabhängig voneinander ändern. All dies kann zu Unsicherheiten im Wert der Ausgabedaten führen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die korrekte Ausführung von Aktionen in den oben beschriebenen Situationen bietet Schattenspeicher. </font><font style="vertical-align: inherit;">Durch Speichern neuer Werte können dieselben Daten innerhalb einer einzigen Aktion sowohl als Eingabe als auch als Ausgabe verwendet werden. </font><font style="vertical-align: inherit;">Ein Beispiel ist das Modell eines Rechteckimpulsgenerators, beschrieben als y =! Y, wobei y der Ausgang des Generators ist. </font><font style="vertical-align: inherit;">Der C ++ - Code in der VKPa-Umgebung ist in Listing 1 dargestellt, und die Ergebnisse des Programms sind in Abb. 1 dargestellt. </font><font style="vertical-align: inherit;">1.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 1. Rechteckiger Impulsgeber</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 1. Simulation des Betriebs des Rechteckimpulsgenerators im VKPA</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Fall hat die Maschine einen Zustand mit einem bedingungslosen Übergang (ein Übergang mit einem Strich anstelle der Eingangsbedingung) in Form einer Schleife, die durch die Aktion y1 gekennzeichnet ist und die Inversion der Ausgangsvariablen implementiert, die in der Dynamik einen Rechteckimpuls bildet. Im Rahmen des Automatenmodells kann die Frequenz des Impulssignals gesteuert werden, indem der Taktwert der diskreten Zeit des Automatenraums eingestellt wird, in den der Automat geladen wird.</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Fähigkeit, die diskrete Zeit des Automaten zu steuern, und das Vorhandensein vieler Automatenräume sind nicht die einzigen, aber wichtigen charakteristischen Eigenschaften der VKPa-Umgebung. </font><font style="vertical-align: inherit;">Mit ihnen können Sie die Leistung eines Parallelprogramms optimieren. </font><font style="vertical-align: inherit;">Beispielsweise sollten Maschinen, die Datenvisualisierung und Benutzerdialoge implementieren, in langsamen Automatenräumen platziert werden, und Anwendungsprozesse sollten entsprechend den Prioritäten und ihrer gewünschten Geschwindigkeit usw. auf Automatenräume verteilt werden. </font><font style="vertical-align: inherit;">usw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Rahmen eines Automatenmodells kann der Wert der Generatorleistung leicht mit dem aktuellen Zustand des Modells in Beziehung gesetzt werden. </font><font style="vertical-align: inherit;">Der Code für das Generatormodell, das bereits zwei Zustände aufweist, von denen jeder den Zustand des Generatorausgangs widerspiegelt, ist in Listing 2 dargestellt.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 2. Rechteckwellengenerator für Zustände</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem neuen Modell ersetzen Zustände die Ausgangsvariable, und dies hat, wie zu sehen ist, das Generatormodell dramatisch vereinfacht. </font><font style="vertical-align: inherit;">Als Ergebnis haben wir eine "nackte" Maschine erhalten, die nur durch eine Konvertierungstabelle dargestellt wird. </font><font style="vertical-align: inherit;">Um den aktuellen Status „s1“ in VKPa zu überwachen, wurde für die Maschine mit dem Namen SWGenState eine Variable vom Typ fsa (Status) mit dem Namen SWGenState (S1) erstellt. </font><font style="vertical-align: inherit;">Es nimmt den wahren Wert im Zustand s1 und den falschen Wert an, wenn sich die Maschine in einem anderen Zustand befindet. </font><font style="vertical-align: inherit;">Ferner wird diese Variable bereits mittels der Anzeige der Daten der VKPA-Umgebung verwendet (siehe den Signaltrend in Fig. 2). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="Bild"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. </font><font style="vertical-align: inherit;">2. Modellierung des Zustandsgenerators</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Paralleles Rechensteuerungsmodell</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um ein Modell paralleler Prozesse zu erstellen, ist es ferner logisch, viele gleichzeitig funktionierende und interagierende Finite-State-Maschinen zu verwenden, d. H. Netzwerk von Automaten. In diesem Fall tritt das Problem der Auswahl eines Netzwerkzeitmodells auf, das für alle Maschinen gleich oder im Einzelfall für jede Maschine gleich sein kann. In VKPa wurde die Wahl zugunsten eines einzelnen Zeitpunkts getroffen (weitere Einzelheiten zu synchronen Netzwerken von Automaten siehe [5]).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch die Auswahl eines einzelnen Zeitpunkts können Sie eine Algebra von Automaten mit Operationen zum Zusammensetzen und Zerlegen von Automaten erstellen. Mit dem ersten können Sie den resultierenden Automaten finden, der eine genaue Vorstellung vom Betrieb eines parallelen Systems gibt. Und hier sei an die obige These über die "Komplexität des Verständnisses" paralleler Programme erinnert. Das Vorhandensein der Kompositionsoperation ermöglicht es uns, das "Problem des Verstehens" des Parallelprogramms zu lösen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich kann der resultierende Automat für ein Netzwerk einer großen Anzahl von Komponenten sehr umfangreich sein. Glücklicherweise ist jedoch häufiger ein Verständnis der Funktionsweise von Subsystemen oder Netzwerken einer kleinen Anzahl von Komponenten erforderlich, für die das Auffinden des resultierenden Automaten keine großen Probleme verursacht. Das folgende Beispiel eines RS-Flip-Flop-Modells zeigt dies.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das RS-Trigger-Modell ist ein Beispiel für ein einfaches paralleles System. Es ist besonders interessant bei Kreuzrückkopplungen. Rückkopplungen oder auf andere Weise zyklische Ketten, Schleifen, algebraische Schleifen usw. sind derzeit ein ernstes Problem für Strukturmodelle paralleler Systeme. Im allgemeinen Fall ist dies durch Einführen von Speicherelementen in die Lückenschleifen zulässig. Dies ist die von der Automatentheorie vorgeschlagene Standardlösung [4]. Die gleiche Ausgabe wird in der Person von MATLAB empfohlen. Die VKPa-Umgebung unterscheidet sich darin, dass solche zusätzlichen Elemente für die Implementierung von Schleifen nicht eingeführt werden müssen. Beachten Sie, und dies ist sehr wichtig, dass echte Schaltungen sie auch nicht benötigen (siehe die RS-Flip-Flop-Schaltung).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. </font><font style="vertical-align: inherit;">Abbildung 3 zeigt das einfachste Modell des AND-NOT-Elements, aus dem die RS-Triggerschaltung besteht. </font><font style="vertical-align: inherit;">Elementverzögerungen sowie deren Art (Transport- oder Trägheitsverzögerungen) werden nicht berücksichtigt. </font><font style="vertical-align: inherit;">Es enthält jedoch immer noch mindestens einen Verzögerungsschlag. </font><font style="vertical-align: inherit;">Dies ist die Zeit des Übergangs von einem Zustand in einen anderen. </font><font style="vertical-align: inherit;">Listing 3 zeigt den Modellcode </font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="Bild"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">3. Das Modell des Elements UND NICHT</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 3. Elementmodell UND NICHT</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. Fig. 4 zeigt ein Diagramm eines RS-Flipflops und seines Modells in Form einer Finite-State-Maschine. Die Pfeile auf dem Modell geben die Verbindungen zwischen den Automaten des Netzwerks an. Hier spiegeln einerseits die Zustände der Modelle die Zustände der Ausgänge des Elements wider und andererseits werden sie auch als Signale zum Organisieren von Informationsverbindungen zwischen parallelen Prozessen verwendet. Es ist diese Form des Modells (mit Synchronisation durch Zustände), die es ziemlich einfach macht, den resultierenden Automaten des Netzwerks zu finden. Es ist in Abb. 1 dargestellt. 5 (Informationen zum Auffinden des resultierenden Automaten finden Sie in [6] für weitere Einzelheiten).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergleichen Sie den [resultierenden] Algorithmus des parallelen RS-Flip-Flop-Programms und den Operationsalgorithmus eines separaten AND-NOT-Elements. Der Unterschied ist auffällig. In diesem Fall werden die Komponentenalgorithmen durch "Handles" erstellt, und der parallele Systemalgorithmus wird implizit erstellt - durch die "künstliche Intelligenz" des Netzwerks. Dies ist der qualitative Unterschied zwischen parallelen und sequentiellen Programmen: Wenn nur die Kommunikation (mindestens eines) geändert wird, erhalten wir einen völlig anderen Arbeitsalgorithmus. Und es wird definitiv kein RS-Trigger mehr sein. Und übrigens ein weiterer resultierender Automat. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 4. Schema des RS-FF- und Netzwerkmodells </font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 5. Der resultierende Maschinennetzwerkmodell-RS-Trigger</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Analyse des resultierenden Automaten in Abb. 5 gibt das folgende "Verständnis" des Parallelprogramms (und natürlich des eigentlichen Auslösers). Erstens durchläuft der Trigger beim Wechsel von einem Zustand in einen anderen notwendigerweise den „verbotenen“ Zustand der Ausgänge (und was sagen die Lehrbücher dazu?). Zweitens, wenn der Trigger in einen einzelnen Ausgangszustand (im Zustand "s1w1") getrieben wird und dann zwei Einheiten den Eingängen zugeführt werden, tritt er in den Erzeugungsmodus ein, d.h. zyklisches Umschalten zwischen den Zuständen „s1w1“ und „s0w0“ und (und haben Sie schon von Triggergenerierung gehört?).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Übergang durch einen verbotenen Zustand erfolgt auch in einem realen Trigger, aber der Erzeugungsmodus ist aufgrund der unterschiedlichen Verzögerungen realer Elemente unmöglich. Feige. Abbildung 6 zeigt den Generierungsmodus des Trigger-Trigger-Modells, der existiert, solange die Einheiten an den Eingängen gespeichert sind. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bemerkung 2. Eine typische Beschreibung der Funktionsweise des RS-Triggers wird in den allermeisten Fällen in Form einer Wahrheitstabelle gegeben. Wenn Sie jedoch verstehen, dass ein Auslöser ein sequentielles Schema ist, werden diejenigen, die sich mit diesem Thema befassen, absichtlich irregeführt. Nun, kein Auslöser kann keine "verbotenen Zustände" haben! Aber aus irgendeinem Grund beschließen nur wenige, diese Wahrheit zu entdecken und insbesondere das Problem ihrer Entstehung zu diskutieren (siehe zum Beispiel [7]).</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Feige. Fig. 7 zeigt das Umschalten eines Triggermodells zwischen seinen stabilen Zuständen. Hier behält ein einzelner Zustand der Triggereingänge den aktuellen Zustand der Triggereingänge bei, und wenn dieser oder jener Eingang auf Null gesetzt wird, wechselt er in den entgegengesetzten Zustand. Zur gleichen Zeit, wenn der Trigger geschaltet wird, nehmen seine Ausgänge im Moment, die einer diskreten Maßnahme entsprechen, gleichzeitig einen einzelnen (von wem verbotenen?) Zustand an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 6. RS-Trigger-Generierungsmodus </font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 7. RS-Trigger zwischen Zuständen umschalten</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein anderes RS-Trigger-Modell, das aus einem Zustand und einer Aktion besteht, d. H. </font><font style="vertical-align: inherit;">ähnlich dem Modell in Listing 1. Sein Code wird in Listing 4 gezeigt. Dieses Modell hat wie das Generatormodell keine Prädikate und die Signalwerte ohne Zwischentransformationen werden in die Aktion y1 eingegeben. </font><font style="vertical-align: inherit;">Ist das gut oder schlecht? </font><font style="vertical-align: inherit;">Einerseits scheint es gut zu sein, weil </font><font style="vertical-align: inherit;">Der Code ist einfacher geworden, aber andererseits ... nicht wirklich. </font><font style="vertical-align: inherit;">Und wir werden jetzt die Gründe dafür verstehen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Listing 4. NAND-Elementmodell aus einer Aktion</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir das neue Modell im "Schattenspeicher" -Modus testen, werden wir keine Unterschiede in seiner Funktionsweise gegenüber dem vorherigen feststellen, d. H. und beim Umschalten durchläuft es die verbotenen Zustände und wechselt regelmäßig in den Generierungsmodus. Wenn wir die Arbeit mit Daten im üblichen Modus einrichten, erhalten wir die in Abb. 1 gezeigten Ergebnisse. 8 und Abb. 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="Bild"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 8. Ausfall des Generierungsmodus des RS-Trigger-Modells </font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 9. Verbotene Zustände durch das RS-Trigger-</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Modell überspringen Warum zeigt das erste Modell, unabhängig von der Art der Arbeit mit dem Speicher, stabile Ergebnisse und das zweite - ändert das Verhalten? Der Grund sind Prädikate. Das zweite Modell hat keine Prädikate, und dies ist entscheidend für sein Verhalten. Aber wie und warum wirkt sich das Vorhandensein / Fehlen von Prädikaten auf den Algorithmus für den parallelen Programmbetrieb aus?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programmmodell eines AND-NOT-Elements hat wie ein Automatprogramm zwei Eingangskanäle und einen Ausgangskanal. Sie müssen zwei Prädikaten und einer Aktion entsprechen. Das erste Programm stimmt voll und ganz damit überein. Der VKPa-Kernel, der die Automatenbeschreibung interpretiert, führt zunächst alle Prädikate nicht nur eines bestimmten Automaten, sondern auch des gesamten Automatenraums aus und startet dann alle Aktionen. In diesem Fall hängen die Ergebnisse von Prädikaten für den aktuellen Taktzyklus des Automaten nicht von ihnen ab (Aktionen), unabhängig davon, in welcher Reihenfolge die Aktionen ausgeführt wurden, um Parallelität zu simulieren und in welchem ​​Modus sie mit dem Speicher arbeiteten. Daher erzeugt das erste Programm das gleiche Ergebnis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das zweite Programm liest, obwohl es direkt mit den Eingangskanälen der Maschine arbeitet, die Eingangssignale als Teil der Aktion. </font><font style="vertical-align: inherit;">Aktionen, die mit Eingabedaten im Schattenspeichermodus arbeiten, schreiben neue Werte in den Schattenspeicher und arbeiten dabei mit Daten, die zu Beginn eines diskreten Taktzyklus gültig sind. </font><font style="vertical-align: inherit;">Im üblichen Modus „erfassen“ sie die zum Zeitpunkt ihrer Änderung festgelegten Momentanwerte, und somit wird der Algorithmus von den Momenten der Speicheränderung abhängig. </font><font style="vertical-align: inherit;">Eine ähnliche Abhängigkeit zeigt das zweite Programm. </font><font style="vertical-align: inherit;">Und selbst wenn Prädikatenmethoden in das zweite Modell eingeführt würden, hätte dies keine Auswirkungen auf die Ergebnisse seiner Arbeit. </font><font style="vertical-align: inherit;">Entscheidend ist hier nicht die Existenz von Prädikatenmethoden, sondern die Merkmale ihrer Arbeit im Rahmen des Automatenprogrammiermodells.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Schlussfolgerungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Beispiel des parallelen RS-Trigger-Programms haben wir einige der Eigenschaften eines parallelen Programms untersucht. </font><font style="vertical-align: inherit;">Wir werden weiterhin bestimmte allgemeine Aspekte der Funktionsweise paralleler Programme als Beispiel für logische (digitale) Schaltungen betrachten. </font><font style="vertical-align: inherit;">Die Wahl des Themas der Modellierung digitaler Schaltungen ist hier kein Zufall. </font><font style="vertical-align: inherit;">Tatsächlich repräsentieren sie in „verfeinerter Form“ die Arbeit paralleler Prozesse. </font><font style="vertical-align: inherit;">Dies ermöglicht die Analyse der Nuancen von Parallelität, Rasse, Synchronisation, Sackgassen usw. </font><font style="vertical-align: inherit;">usw. transparent, klar und einfach.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig davon, wie Sie die Programmierung als "wettbewerbsfähig" oder parallel bezeichnen, unabhängig davon, ob Sie "Coroutinen", Coroutinen, Threads oder Maschinen zum Programmieren verwenden, sollte das Ergebnis des [parallelen] Programms in allen Implementierungen gleich sein. </font><font style="vertical-align: inherit;">Das automatische Modell paralleler Programme im Rahmen der KPdSU verfolgt dieses und nur dieses Ziel.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig davon, welche Annahmen hinsichtlich der Implementierung des Kerns der Interpretation der Automaten der VKPa-Umgebung getroffen würden, wären dies alles „Spekulationen“, weil Das Ergebnis der Arbeit automatischer Programme sollte nicht mit der Implementierung eines Rechenmodells in Verbindung gebracht werden. Es kann Software (wie es jetzt ist) oder Hardware (wie ich in Zukunft hoffe) sein, die auf einem Kern oder auf ihrem Set implementiert ist, in Single-Threaded- oder Multi-Threaded-Version usw. usw. All dies sollte die Ergebnisse paralleler automatischer Programme in keiner Weise beeinflussen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und anscheinend wurde das Ziel erreicht. </font><font style="vertical-align: inherit;">Das RS-Trigger-Modell als einer der möglichen Tests von Parallelitätssystemen [8] überzeugt uns davon ... Wie das Leben gezeigt hat, funktionieren alle anderen parallelen Programme, sofern die Umgebung die Implementierung des RS-Trigger-Testparallelismus erfolgreich bestanden hat, genauso korrekt, zuverlässig und stabil . </font><font style="vertical-align: inherit;">Übrigens hat der gleiche MATLAB „RS-Trigger-Test“ nicht bestanden, und das sagt schon viel aus ...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Literatur</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. – .:  , 2012. – 672 . <br>
2.  .    : .  . – .: , 1981. – 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . – 2- ., .  . – .:  , 1988. – 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . – .: , 2004. – 432.<br>
8.  ..   ? “ ”, №10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de486622/">https://habr.com/ru/post/de486622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de486598/index.html">Mikrocontroller-Experimente in Jupyter Notebook</a></li>
<li><a href="../de486602/index.html">Svelte Community Materials Digest (16. Januar - 1. Februar)</a></li>
<li><a href="../de486604/index.html">Nein, dynamische Systeme sind im Wesentlichen nicht mehr offen</a></li>
<li><a href="../de486608/index.html">Wesentliche Assistenten für die Intelligenz des effektivsten Geheimdienstes der Welt (Teil 2)</a></li>
<li><a href="../de486614/index.html">Warum eSIM benötigt wird. Wie es funktioniert und warum sie so viel darüber reden</a></li>
<li><a href="../de486626/index.html">Svelte: Aktionen kennenlernen</a></li>
<li><a href="../de486628/index.html">Der Abstand zwischen Ticks auf einer Achse im Gnuplot wurde korrigiert</a></li>
<li><a href="../de486630/index.html">„Nicht ins Auge flackern“: Wie die Technologie der Bildschirmbeleuchtung elektronischer Lesegeräte angeordnet ist</a></li>
<li><a href="../de486632/index.html">Mentale reaktive Programmiermodelle für Supervisoren</a></li>
<li><a href="../de486634/index.html">MSVC-Backend-Updates in Visual Studio 2019, Version 16.3 und 16.4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>