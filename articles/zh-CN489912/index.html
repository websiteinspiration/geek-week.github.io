<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏽 🍂 👨🏾 在Web开发中调试微服务时的痛苦和痛苦 ➕ 🚵🏽 ⛑️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在IT中，您很少会见到从未听说过微服务的人。在Internet上以及与此主题相关的专门站点上，有很多文章通常可以很好地解释整体服务与实际上微服务之间的差异。一位经验不足的Java开发人员阅读了“什么是Web应用程序的微服务以及它们所吃的东西”类别的文章，他充满了喜悦和信心，因为现在一切都会变得美好。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>在Web开发中调试微服务时的痛苦和痛苦</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489912/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在IT中，您很少会见到从未听说过微服务的人。在Internet上以及与此主题相关的专门站点上，有很多文章通常可以很好地解释整体服务与实际上微服务之间的差异。一位经验不足的Java开发人员阅读了“什么是Web应用程序的微服务以及它们所吃的东西”类别的文章，他充满了喜悦和信心，因为现在一切都会变得美好。毕竟，主要目标是“锯穿”巨大的整体（通常是战争/耳朵文件的最终人工制品），该整体在一系列单独的生活服务上执行大量工作，每个服务都将执行仅与之相关的严格定义的功能，并会做好。除此之外，还有水平可伸缩性-只需</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">扩展即可</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相应的节点，一切都会很棒。</font><font style="vertical-align: inherit;">已有更多用户到达或需要更多容量-仅添加了5-10个新服务实例。</font><font style="vertical-align: inherit;">大致来说，这就是它的工作原理，但是，正如您所知，魔鬼在细节上，而经过仔细研究，最初看起来很简单的问题可能会变成最初没有人考虑的问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这篇文章中，Rexoft的Java实践的同事分享了他们如何调试Web微服务的经验。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/ls/xd/silsxdh5v-rwgybittlu4bvbcz0.png"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何实现交易数据的完整性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在尝试将架构从整体服务转移到微服务时，以前没有这种经验的团队通常会开始将服务拆分为域模型的顶级对象，例如：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户/客户/员工</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。在将来，通过更详细的研究，人们会发现，这样更方便地分解成更大的块，这些块将域内的多个对象聚合在一起。因此，您可以避免不必要地调用第三方服务。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个重点是对事务数据完整性的支持。在整体中，此问题是通过应用程序服务器解决的，在该服务器中，争吵不休，容器实际上在其中概述了事务的边界。在微服务的情况下，事务的边界是模糊的，除了编写业务逻辑代码外，还需要能够管理数据完整性，维持系统不同部分之间的一致性。这是一项非常重要的任务。解决此类体系结构问题的建议可以在Internet和相关技术社区中找到。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我们将尝试描述团队尝试使用微服务时出现的特定技术难题，以及解决这些难题的方法。我立即注意到，提出的选择并不是唯一的选择。也许会有更多优雅的服务，但是我将给出的建议在实践中经过了检验，可以准确地解决现有的困难，以及是否使用它们是每个人的个人问题。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与微服务的主要问题是，他们是非常容易在本地运行（例如，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spring.io</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntelliJ IDEA的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这可以在短短的5分钟内完成，甚至更少）。但是，当尝试在</font><b><font style="vertical-align: inherit;">Kubernetes中</font></b><font style="vertical-align: inherit;">执行相同</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作时</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集群（如果您以前没有使用过该集群的经验），则</font><font style="vertical-align: inherit;">在访问特定端点时</font><font style="vertical-align: inherit;">简单启动控制器并打印</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ Hello World”</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可能需要半天。</font><font style="vertical-align: inherit;">在整体式的情况下，情况更简单。</font><font style="vertical-align: inherit;">每个开发人员都有一个本地应用程序服务器。</font><font style="vertical-align: inherit;">部署过程也非常简单-您需要</font><font style="vertical-align: inherit;">手动或使用</font><b><font style="vertical-align: inherit;">IDE</font></b><font style="vertical-align: inherit;">将最终的War / ear工件复制到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Server中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的正确位置</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常这不是问题。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试细节</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个重点是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调试</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在具有整体的情况下，假定开发人员在其机器上有一个Application Server，并在其中部署了他的</font><b><font style="vertical-align: inherit;">War /</font></b><font style="vertical-align: inherit;"> Ear</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您始终可以进行调试，因为所需的一切都在手边。使用微服务，一切都会变得有些复杂，服务通常本身就是一件事。通常，他拥有自己的数据库方案（数据位于其中），执行特定于他的特定功能，与其他服务的所有通信都通过同步HTTP调用（例如通过RestTemplate或Feign），异步（例如Kafka或RabbitMQ）进行组织。因此，通常在微服务方法中，保存或验证以前在单个war / ear文件中某个位置实现的某个对象的基本简单任务通常以微服务的方式表示：转到一个或N个相邻服务，无论是数据获取操作例如某些参考值或保存相邻实体的操作，在我们的服务中执行业务逻辑所需的数据。在这种情况下，编写业务逻辑变得更加困难。</font></font><br>
<br>
<u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，解决方案选项如下</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写您的业务逻辑代码。</font><font style="vertical-align: inherit;">与此同时，所有的外部调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嘲笑</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -外部合同仿真，测试，写为假设的一部分，外部合同是正义的，那么有一个部署进行验证电路。</font><font style="vertical-align: inherit;">有时很幸运，并且集成马上就可以进行，有时很不幸运-您必须重做业务逻辑代码第n次，因为在我们实现功能期间，相邻服务中的代码已更新，API签名已更改，我们需要重做任务的一部分在一边。</font></font></li>
<li>     <b></b>.     ,  ,         <b>Kubernetes</b>, . .  ,       —     ,     <b>remote debug</b>  .      ,     <b>runtime</b> ,   ,    . -,      ,          2–5 , . .         ,  <b>Kubernetes</b> ,        . -,           (<b>Per thread</b>),    ,      .</li>
</ol><br>
<h2>     Kubernetes</h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，解决此问题的方法就是网</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">可能还有其他类似的程序，但是只有他个人经历，他才能建立自己的积极基础。</font><font style="vertical-align: inherit;">通常，操作原理如下：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本地计算机上，开发人员</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安装远程呈现</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，配置</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kubectl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以访问相应的Kubernetes群集（将循环配置添加到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">〜/ .kube / config</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">之后，网</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">，它实际上</font><font style="vertical-align: inherit;">是本地开发人员计算机和</font><b><font style="vertical-align: inherit;">Kubernetes</font></b><font style="vertical-align: inherit;">之间的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代理</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有不同的启动选项，最好在官方指南中更详细地查看，但在最基本的情况下，它可以分为两个步骤：</font></font><br>
<br>
<ol>
<li><b>Sudo telepresence</b> (,     Linux-  ,     sudo  .  ,        root/).          Kubernetes    deployment   <b>telepresence</b>  .  deployment          Kubernetes.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，在开发人员的本地计算机上启动服务实例。</font><font style="vertical-align: inherit;">但是，在这种情况下，他将可以访问Kubernetes集群的整个基础结构，包括</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务发现（Eureka，领事），Api网关（Zuul），Kafka</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其队列（如果有）等等。</font><font style="vertical-align: inherit;">也就是说，实际上，我们需要的所有集群环境都可以使用，但可以在本地使用。</font><font style="vertical-align: inherit;">好处是可以进行本地调试，但是在集群环境中，它已经快得多了，因为实际上，我们位于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">（通过隧道），并且不通过端口从外部访问它进行远程调试。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此解决方案有几个缺点：</font></font><br>
<br>
<ol>
<li><b>Telepresence</b>    Linux  Mac,   Windows     VFS,  ,  issue  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GitHub</a>.          .   ,    - Linux/Mac,      .</li>
<li>      ,      <b>Service Discovery (Eureka, Consul) </b>      —                 <b>Round Robin</b>  ,         endpoint  ,  ,   ,    : </li>
</ol><br>
<ul>
<li>       kubernetes -&gt;   .   <b>telepresence</b>      deployment  ,      «»     Eureka   <b>ip-address:port/service-name</b>  <b>dns-name:port/service-name</b>    ,  . .   Kubernetes        ,      timeout;</li>
<li>      deployment     -  Kubernetes    , <b> </b>      (   )           (Round Robin),    ;</li>
<li>  endpoint,      <b>feature</b>,     HTTP 404    endpoint  <b>Gateway</b>,          <b>Service Discovery</b>     ,    <b>Round Robin</b> .         Service Discovery  endpoint  ,    HTTP 404.</li>
<li> ,    ,        <b> </b> .</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动态查询路由意味着</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">网关API（Zuul）</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够在我们需要的同一服务的多个实例中进行选择。在一般情况下，可以通过添加谓词来解决此问题，该谓词允许您在请求处理阶段从具有相同名称的公共服务池中选择所需的服务。自然地，我们希望能够动态路由的服务中的每个服务都必须具有某种包含数据的元信息，该数据将用于确定是否需要此服务。</font><font style="vertical-align: inherit;">例如，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Cloud</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在Eureka的情况下）允许您通过在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的特殊元数据块中指定来执行此操作</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">eureka:<font></font>
  instance:<font></font>
    preferIpAddress: true<font></font>
    metadata-map:<font></font>
      service.label: develop</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在服务发现中的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com.netflix.appinfo.InstanceInfo＃getMetadata中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注册了这样的服务后，</font><font style="vertical-align: inherit;">将有一个带有键</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">service.label</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的标签</font><font style="vertical-align: inherit;">和值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">develop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，可以在运行时获取它。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务开始时的重要一点是检查</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务实例是否存在具有此类元信息的服务发现中，以避免潜在的冲突。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路由选项</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
之后，可以将问题的解决方案简化为两个选项：</font></font><br>
<br>
<ol>
<li>API Gateway        .         , ,          , ,  Headers: <b>DestionationService: feature/PRJ-001</b>.     ,       ,           Header        .       ,         — - API Gateway.</li>
<li>  API Gateway,        , . ., ,    ,     <b>Zuul 1</b>    endpoint-  <b>/api/users/</b>…       user,      <b>feature/PRJ-001</b>,    <b>Zuul 2</b>    endpoint- <b> /api/users/</b>…       user,      <b>feature/PRJ-002</b>.       ,         N API Gateway  N , . .        , . .   feature — ,  ,  ,             ,    ,     ,        .          <b>API Gateway</b>, , . .,  ,   ,     —   ,     .</li>
</ol><br>
<img src="https://habrastorage.org/webt/si/ls/xd/silsxdh5v-rwgybittlu4bvbcz0.png"><br>
<br>
<i>   </i><br>
<br>
<h2>       </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为Gateway API的一部分，还值得提供一种机制，使您能够在运行时更改路由规则。最好将这些设置放在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">config-map中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在这种情况下，只需重写新路由并在Kubernetes中重新启动Gateway API来更新路由，或者使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spring Boot Actuator</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（假设Gateway API中存在相应的依赖关系）</font><font style="vertical-align: inherit;">就足够了</font><font style="vertical-align: inherit;">-调用端点/刷新，这实际上是重新读取的配置地图中的数据，并将更新路由。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要的一点是，相对而言，应该有一个服务的参考实例（例如，标记为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">develop</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将从服务开发的主分支中收集）和单独的主Gateway API（将始终在访问该服务的设置中指定）。本质上，我们为自己提供了一个独立的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暂存</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">环境，该</font><b><font style="vertical-align: inherit;">暂存</font></b><font style="vertical-align: inherit;">环境将始终在动态路由的上下文中运行。</font><font style="vertical-align: inherit;">包含路由设置的Gateway API </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配置映射</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">块</font><font style="vertical-align: inherit;">的示例（此处仅是其外观的示例，为了正确操作，它需要在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API Gateway</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务的后端侧以代码形式进行相应的绑定</font><b><font style="vertical-align: inherit;">）</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="plaintext hljs">{<font></font>
  "kind": "ConfigMap",<font></font>
  "apiVersion": "v1",<font></font>
  "metadata": {<font></font>
    ...<font></font>
  },  <font></font>
"data": {<font></font>
    ...        <font></font>
    "rules.meta.user": "develop",<font></font>
    "rules.meta.client": "develop",<font></font>
    "rules.meta.notification": "feature/PRJ-010",<font></font>
    ...    <font></font>
  }<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rules.meta</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是包含服务路由规则的映射。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用户/客户端/通知</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -在Eureka中注册服务的名称。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">development / feature / PRJ-010-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相应服务的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">application.yml中的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务标签</font><font style="vertical-align: inherit;">，如果</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实例不止一个，则将在</font><b><font style="vertical-align: inherit;">Service Discovery中</font></b><font style="vertical-align: inherit;">具有相同名称的所有可用服务中选择所需</font><font style="vertical-align: inherit;">的服务。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像这个世界上的一切一样，IT中的工具和解决方案也不是完美的。</font><font style="vertical-align: inherit;">不要以为如果更改体系结构，所有问题都会立即消失。</font><font style="vertical-align: inherit;">只有详细地沉浸于所使用的技术和您自己的经验中，您才能真正了解正在发生的事情。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望这些材料可以帮助您解决问题。</font><font style="vertical-align: inherit;">有趣的任务，无错误出售！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN489898/index.html">关于wc的另一篇文章</a></li>
<li><a href="../zh-CN489900/index.html">PostgreSQL反模式：绕过触发器更改数据</a></li>
<li><a href="../zh-CN489902/index.html">如何衡量投资组合的有效性：3种实用方法</a></li>
<li><a href="../zh-CN489904/index.html">我们为什么以及如何测试更新</a></li>
<li><a href="../zh-CN489906/index.html">OpenCV中的虚拟试衣间</a></li>
<li><a href="../zh-CN489914/index.html">Proxmox VE中的群集</a></li>
<li><a href="../zh-CN489916/index.html">Protobuf还是JSON结构的前端通信协议？</a></li>
<li><a href="../zh-CN489918/index.html">我们如何实施虚拟加油卡项目</a></li>
<li><a href="../zh-CN489920/index.html">站点，转到IPv6，两个</a></li>
<li><a href="../zh-CN489924/index.html">Elasticsearch从哪里开始</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>