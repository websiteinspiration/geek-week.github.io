<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛎ 🎓 📑 Web UIアーキテクチャ：木製の過去、奇妙な現在、そして明るい未来 🔓 🗺️ 🔑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="現代の開発者コミュニティは今やファッションやトレンドの影響を受けています。これは特にフロントエンド開発の世界に当てはまります。私たちのフレームワークと新しい慣行が主な価値であり、ほとんどの履歴書、求人、会議プログラムはそれらをリストすることで構成されています。また、アイデアやツールの開発自体は否定的...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Web UIアーキテクチャ：木製の過去、奇妙な現在、そして明るい未来</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456794/"><img src="https://habrastorage.org/webt/g1/rr/97/g1rr97vliagp-2dndxhmubahvrg.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現代の開発者コミュニティは今やファッションやトレンドの影響を受けています。これは特にフロントエンド開発の世界に当てはまります。</font><font style="vertical-align: inherit;">私たちのフレームワークと新しい慣行が主な価値であり、ほとんどの履歴書、求人、会議プログラムはそれらをリストすることで構成されています。</font><font style="vertical-align: inherit;">また、アイデアやツールの開発自体は否定的ではありませんが、開発者はとらえどころのない傾向に従うことを常に望んでいるため、アプリケーションアーキテクチャに関する一般的な理論的知識の重要性を忘れ始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論とベストプラクティスの知識に対するチューニング値の普及により、今日のほとんどの新しいプロジェクトのメンテナンスレベルが非常に低くなり、開発者（コードの調査と変更は常に非常に複雑）と顧客（低レートと高い開発コスト）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日の状況に何らかの形で影響を与えるために、今日は、優れたアーキテクチャとは何か、それがWebインターフェースにどのように適用できるか、そして最も重要なことは、時間とともにどのように進化するかについてお話ししたいと思います。</font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB</font></font></b>:          ,      ,       React  Redux. ,   ,             -       .</i><br>
<br>
<a name="habracut"></a><h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、用語自体を取り上げましょう。簡単に言うと、システムのアーキテクチャは、そのコンポーネントの定義とそれらの間の相互作用のスキームです。これは一種の概念的な基盤であり、その上に後で実装が構築されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャのタスクは、設計されたシステムの外部要件を満たすことです。これらの要件はプロジェクトごとに異なり、非常に具体的な場合がありますが、一般的なケースでは、開発されたソリューションの変更と拡張のプロセスを促進するためのものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの品質に関しては、それは通常、次のプロパティで表現される：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">伴奏</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：研究と変形に対するシステムの前述の素因（検出及び訂正のエラーを、機能を拡張する、別の環境や条件に対する解決策を適応することの困難）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">互換</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：他の要素に影響を与えることなく、システムの任意の要素の実装を変更する能力</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト容易</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：要素の正しい動作を検証する能力（要素を制御してその状態を監視</font><font style="vertical-align: inherit;">する機能</font><font style="vertical-align: inherit;">）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移植性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：他のシステム内で要素を再利用する機能</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使いやすさ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：エンドユーザーが操作したときのシステムの全体的な利便性の程度</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、質の高いアーキテクチャを構築するための重要な原則の1つである</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">懸念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">分離の</font></a><font style="vertical-align: inherit;">原則についても触れています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、システムの任意の要素が1つの単一タスク（アプリケーションコードに偶然に適用される：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一責任の原則を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">に対してのみ責任を負うべきであるという事実にあります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの概念についてのアイデアがわかったところで、インターフェイスのコンテキストでアーキテクチャデザインパターンが提供できるものを見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も重要な3つの単語</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターフェース開発の最も有名なパターンの1つはMVC（Model-View-Controller）です。その主要な概念は、インターフェースロジックを3つの別々の部分に分割することです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -データの受信、保存、処理を</font><font style="vertical-align: inherit;">担当します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビュー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -データの視覚化を担当します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3 。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントローラ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -モデルを管理し、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターン</font><font style="vertical-align: inherit;">を表示します。</font><font style="vertical-align: inherit;">このパターンには、それらの間の相互作用のスキームの説明も含まれますが、ここでは、特定の公開時間がこのパターンの改良された変更によって表された後、MVP（Model-View -Presenter）、これはこの初期の相互作用スキームを大幅に簡素化しました：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sv/j_/r2/svj_r22lb39syciykkximzlk-vy.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にWebインターフェースについて話しているので、これらのパターンの実装に通常付随するもう1つのかなり重要な要素であるルーターを使用しました。そのタスクは、URLを読み取り、それに関連付けられたプレゼンターを呼び出すことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のスキームは次のように機能します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1.ルーターがURLを読み取り、関連するPresenter </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2-5 </font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。 Presenterがモデルに連絡し、モデルから必要なデータを受信します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。6。Presenterがモデルからビューにデータを転送し、ビューを実装します</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。7。ユーザーインターフェイスと対話すると、ビューはこれについてPresenterに通知し、2番目のポイントに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に示したように、MVCとMVPは理想的で普遍的なアーキテクチャではありませんが、それでも1つの非常に重要な役割を果たします。これらは3つの重要な責任領域を示し、それがないとインターフェイスを何らかの形で実装できません。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：概して、コントローラーとプレゼンターの概念は同じ意味であり、名前の違いは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、通信</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">実装</font></a><font style="vertical-align: inherit;">のみが異なる前述のパターンを区別するためにのみ必要</font><font style="vertical-align: inherit;">です。</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MVCとサーバーのレンダリング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MVCはクライアントを実装するためのパターンであるという事実にもかかわらず、そのアプリケーションはサーバー上でも検出されます。さらに、サーバーのコンテキストでは、その動作原理を実証するのが最も簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WebサーバーのタスクがユーザーのHTMLページを生成することである従来の情報サイトを扱っている場合、MVCはかなり簡潔なアプリケーションアーキテクチャを整理することもできます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ルーターは受信したHTTPリクエストからデータを読み取ります</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（GET /ユーザー-profile / 1）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および関連付けられたコントローラーを呼び出します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（UsersController.getProfilePage（1））</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -データベースから必要な情報を取得するためにモデルを呼び出すコントローラー</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（UsersModel.get（1））</font></font></i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -コントローラーは受信したデータをビューに転送します</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（View.render（ 'users / profile'、user））</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、HTMLマークアップを取得し、クライアントに返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、Viewは通常、次のように実装されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1j/q6/_f/1jq6_frux0usp6akgw91lj3bq5o.png" alt="画像"><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> templates = {
  <span class="hljs-string">'users/profile'</span>: <span class="hljs-string">`
    &lt;div class="user-profile"&gt;
      &lt;h2&gt;{{ name}}&lt;/h2&gt;
      &lt;p&gt;E-mail: {{ email }}&lt;/p&gt;
      &lt;p&gt;
        Projects: 
        {{#each projects}}
          &lt;a href="/projects/{{id}}"&gt;{{name}}&lt;/a&gt;
        {{/each}}
      &lt;/p&gt;
      &lt;a href=/user-profile/1/edit&gt;Edit&lt;/a&gt;
    &lt;/div&gt;
  `</span><font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">View</span> </span>{<font></font>
  render(templateName, data) {<font></font>
    <span class="hljs-keyword">const</span> htmlMarkup = TemplateEngine.render(templates[templateName], data);
    <span class="hljs-keyword">return</span> htmlMarkup;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意：上記のコードは、例として使用するために意図的に簡略化されています。実際のプロジェクトでは、テンプレートは個別のファイルにエクスポートされ、使用前にコンパイル段階を通過します（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handlebars.compile（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_.template（）を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参照）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ここでは、いわゆるテンプレートエンジンが使用されています。これは、テキストテンプレートを簡単に説明するためのツールと、テンプレート内の実際のデータを置き換えるためのメカニズムを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビューの実装に対するこのようなアプローチは、責任の理想的な区分を示すだけでなく、高度なテスト容易性も提供します。表示の正確さを確認するには、参照行をテンプレートエンジンから取得した行と比較するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、MVCを使用すると、ほぼ完全なアーキテクチャが得られます。このアーキテクチャの各要素には非常に特定の目的があり、最小限の接続性があり、高レベルのテスト容易性と移植性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバーによるHTMLマークアップの生成によるアプローチについては、UXが低いため、このアプローチは徐々にSPAに置き換わり始めました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バックボーンとMVP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示ロジックを完全にクライアントに提供する最初のフレームワークの1つは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Backbone.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でした。</font><font style="vertical-align: inherit;">ルーター、プレゼンター、モデルの実装はかなり標準的ですが、Viewの新しい実装は注意に値します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e6/iv/ye/e6ivye6jq6mo0gq_r1re8fua5uq.png" alt="画像"><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> UserProfile = Backbone.View.extend({
  <span class="hljs-attr">tagName</span>: <span class="hljs-string">'div'</span>,
  <span class="hljs-attr">className</span>: <span class="hljs-string">'user-profile'</span>,
  <span class="hljs-attr">events</span>: {
    <span class="hljs-string">'click .button.edit'</span>:   <span class="hljs-string">'openEditDialog'</span>,<font></font>
  },<font></font>
  <span class="hljs-attr">openEditDialog</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{
    <span class="hljs-comment">// ...</span><font></font>
  },<font></font>
  <span class="hljs-attr">initialize</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.model, <span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>.render);<font></font>
  },<font></font>
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">`
    &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
      &lt;p&gt;E-mail: &lt;%= email %&gt;&lt;/p&gt;
      &lt;p&gt;
        Projects: 
        &lt;% _.each(projects, project =&gt; { %&gt;
           &lt;a href="/projects/&lt;%= project.id %&gt;"&gt;&lt;%= project.name %&gt;&lt;/a&gt;
        &lt;% }) %&gt;
      &lt;/p&gt;
      &lt;button class="edit"&gt;Edit&lt;/button&gt;
  `</span>),
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.$el.html(<span class="hljs-keyword">this</span>.template(<span class="hljs-keyword">this</span>.model.attributes));<font></font>
  }<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、マッピングの実装ははるかに複雑になりました-モデルとDOMからのイベントをリッスンすること、およびそれらの処理のロジックが基本的な標準化に追加されました。さらに、インターフェースの変更を表示するには、Viewを完全に再レンダリングするのではなく、特定のDOM要素を（通常はjQueryを使用して）より細かく処理することが非常に望ましいため、多くの追加コードを記述する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viewの実装は一般的に複雑なため、テストはより複雑になりました。現在、DOMツリーを直接操作しているため、テストのために、ブラウザー環境を提供またはエミュレートする追加のツールを使用する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、新しいView実装の問題はそこで終わりませんでした：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記に加えて、互いにネストされたビューを使用することはかなり困難です。時間が経つにつれて、この問題はの助けを借りて解決された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地域</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Marionette.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、その前に、開発者は、このかなりシンプルでしばしば生じる問題を解決するために、独自のトリックを考案しなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後。この方法で設計されたインターフェースは、データが同期されない傾向がありました。すべてのモデルが異なるプレゼンターのレベルで分離して存在していたため、インターフェースの一部でデータを変更しても、通常、別の部分では更新されませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらの問題にもかかわらず、このアプローチは現実的ではなく、前述の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">マリオネット</font></a><font style="vertical-align: inherit;">形式のバックボーンの開発</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> それでもSPAの開発にうまく適用できます。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反応して無効にする</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
信じがたいことですが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">最初にリリースされたとき、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">React.js</font></a><font style="vertical-align: inherit;">は開発者コミュニティの間で多くの懐疑を引き起こしていました。</font><font style="vertical-align: inherit;">この懐疑論は非常に大きかったので、長い間、次のテキストが公式Webサイトに投稿されていました。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Give It 5 Minutes </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactは多くの従来の知恵に挑戦し、一見するといくつかのアイデアはクレイジーに見えるかもしれません。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これは、競合他社や前任者のほとんどとは異なり、Reactは本格的なフレームワークではなく、DOMでのデータの表示を容易にするための単なる小さなライブラリであったという事実にもかかわらず：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reactは、FacebookおよびInstagramによるユーザーインターフェイスを作成するためのJavaScriptライブラリです。</font><font style="vertical-align: inherit;">多くの人々は、ReactをMVCのVと考えることを選択します。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactが提供する主な概念はコンポーネントの概念であり、実際には、Viewを実装する新しい方法を提供します。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{<font></font>
  handleEdit() {<font></font>
    <span class="hljs-comment">// ..</span><font></font>
  }<font></font>
  render() {<font></font>
    <span class="hljs-keyword">const</span> { name, email, projects } = <span class="hljs-keyword">this</span>.props;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"user-profile"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{name}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>E-mail: {email}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
        Projects: 
        {
          projects.map(project =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/projects/{project.id}"</span>&gt;</span>{project.name}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>) 
        }
      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.handleEdit}</span>&gt;</span>Edit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactは非常に楽しく使用できました。その</font><b><font style="vertical-align: inherit;">議論の</font></b><font style="vertical-align: inherit;">余地のない利点の中には、今日まで残ったものがあります：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">宣言性と反応性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。表示されるデータを変更するときに、DOMを手動で更新する必要がなくなりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントの構成</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ビューツリーの構築と探索は、完全に初歩的なアクションになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、残念ながら、Reactには多くの問題があります。最も重要なことの1つは、Reactが本格的なフレームワークではないため、その実装にアプリケーションアーキテクチャも本格的なツールも提供していないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜこれが欠陥に書かれているのですか？はい、今反応するためには、Webアプリケーションを開発するための最も人気のあるソリューション（ある</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">証拠は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別の証拠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしてもう一つの証拠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、それは新しいフロントエンド開発者のためのエントリポイントであるが、同時にそれは提供しないとどんなアーキテクチャを促進しない、またいずれかが接近し、本格的なアプリケーションを構築するためのベストプラクティス。さらに、彼は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HOC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フック</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など、Reactエコシステムの外では使用されない</font><font style="vertical-align: inherit;">独自のカスタムアプローチを発明し、推進し</font><font style="vertical-align: inherit;">ています。その結果、各Reactアプリケーションは独自の方法で典型的な問題を解決し、通常は最も正確な方法で解決しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題は、コンポーネントの乱用にあるReact開発者の最も一般的なエラーの1つを使用して実証できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたが持っている唯一の道具がハンマーである場合、すべてが釘のように見え始めます。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者は彼らの助けを借りて、データの視覚化の範囲をはるかに超えた、まったく考えられない範囲のタスクを解決します。</font><font style="vertical-align: inherit;">実際、コンポーネントの助けを借りて、</font><font style="vertical-align: inherit;">CSSから</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ルーティング</font></a><font style="vertical-align: inherit;">までの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メディアクエリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">すべてのものを完全に実装</font><font style="vertical-align: inherit;">し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反応と還元</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reactアプリケーションの構造の再構築は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduxの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">登場と普及によって大幅に促進されました</font><font style="vertical-align: inherit;">。 ReactがMVPからのビューである場合、Reduxはモデルのかなり便利なバリエーションを提供してくれました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reduxの主なアイデアは、データの転送と、それらを使用して単一の集中型データウェアハウス（いわゆるStore）に作業するロジックです。このアプローチは、少し前に説明したデータの重複と非同期化の問題を完全に解決します。また、アプリケーションのデータの現在の状態を簡単に調査できるなど、他の多くの機能も提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に重要なもう1つの機能は、ストアとアプリケーションの他の部分との間の通信方法です。ストアまたはそのデータに直接アクセスする代わりに、いわゆるアクション（イベントまたはチームを説明する単純なオブジェクト）を使用することを提案します。これ</font><font style="vertical-align: inherit;">は、ストアとイベントソース間の</font><font style="vertical-align: inherit;">弱いレベルの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">疎結合</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を提供し</font><font style="vertical-align: inherit;">、それによってプロジェクトの保守性の度合いを大幅に高めます。したがって、Reduxを使用すると、開発者はより適切なアーキテクチャアプローチを使用できるようになるだけでなく、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">イベントソーシングの</font></a><font style="vertical-align: inherit;">さまざまな利点を活用できるようになります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-デバッグプロセスでは、アプリケーションのアクションの履歴、データへの影響を簡単に確認でき、必要に応じてこの情報をすべてエクスポートできます。これは、本番環境のエラーを分析する際にも非常に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React / Reduxを使用するアプリケーションの一般的なスキームは、次のように表すことができます</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rw/x6/8f/rwx68f3sxe_rrnh609ul6rmgrsw.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。Reactコンポーネントはデータの表示を担当します。理想的には、これらのコンポーネントはクリーンで機能的である必要がありますが、必要に応じて、ローカル状態と関連ロジック（たとえば、特定の要素の非表示/表示やユーザーアクションの基本的な前処理を実装するため）を備えている場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーがインターフェースでアクションを実行すると、コンポーネントは対応するハンドラー関数を呼び出すだけで、表示するデータとともに外部から受け取ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆるコンテナコンポーネントは、私たちにとってプレゼンターとして機能します。これらは、表示コンポーネントとデータとの相互作用を制御するコンポーネントです。それらは</font><font style="vertical-align: inherit;">、それに転送されるコンポーネントの機能を拡張</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する接続</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用して作成さ</font><font style="vertical-align: inherit;">れ、ストア内のデータを変更するサブスクリプションを追加し、どのデータとイベントハンドラーに渡すかを決定させます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここのデータですべてが明確な場合（データをストレージから予想される「小道具」にマップするだけです）、イベントハンドラーについて詳しく説明したいと思います。アクションをストアに送信するだけでなく、イベントを処理するための追加のロジックが含まれている可能性もあります-たとえば、分岐を含めたり、自動リダイレクトを実行したり、発表者固有のその他の作業を実行したりします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーコンポーネントに関するもう1つの重要なポイント：HOCを通じて作成されるため、開発者は1つのモジュール内に表示コンポーネントとコンテナーコンポーネントを記述し、コンテナーのみをエクスポートすることがよくあります。これは適切なアプローチではありません。表示コンポーネントをテストして再利用できるようにするためには、コンテナから完全に分離し、できれば別のファイルに入れる必要があるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私たちがまだ検討していない最後のものはストアです。これは、モデルのかなり具体的な実装として機能し、いくつかのコンポーネントで構成されます：状態（すべてのデータを含むオブジェクト）、ミドルウェア（受信したすべてのアクションを前処理する一連の関数）、レデューサー（状態のデータを変更する関数）、およびいくつかまたは、非同期操作（外部システムへのアクセスなど）の実行を担当する副作用ハンドラー。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで最も一般的な問題は、私たちの国家の形態です。正式には、Reduxは私たちに制限を課すことはなく、このオブジェクトがどうあるべきかについての推奨もしません。開発者はその中にあらゆるデータを保存できます（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ルーターから</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のフォーム</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">情報の</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">状態を</font></a><font style="vertical-align: inherit;">含む）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、このデータは任意のタイプ（</font><font style="vertical-align: inherit;">関数やオブジェクトのインスタンスを格納することも</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">禁止され</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">いません</font></a><font style="vertical-align: inherit;">）であり、任意のレベルの入れ子を持つことができます。実際、これはまた、プロジェクトごとに、Stateを使用するためのまったく異なるアプローチを取得するという事実につながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そもそも、すべてのアプリケーションデータを絶対に状態に保持する必要がないことに同意します。これは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、ドキュメントに</font></a><font style="vertical-align: inherit;">明確に</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示されています</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。コンポーネントの状態内にデータの一部を保存すると、デバッグプロセス中にアクションの履歴をナビゲートするときに特定の不都合が生じます（コンポーネントの内部状態は常に変更されないままです）が、このデータをStateに転送するとさらに困難が生じます-これによりサイズが大幅に増加し、さらに多くの作成が必要になりますアクションとレデューサー。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のローカルデータをStateに格納する場合、通常は、キーと値のペアのセットである一般的なインターフェイス構成を扱います。この場合、1つの単純なオブジェクトとそのためのレデューサーで簡単に行うことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、外部ソースからのデータの保存について話している場合、インターフェイスの開発では、大部分のケースで従来のCRUDを扱うという事実に基づいて、サーバーからのデータを保存する場合、StateをRDBMSとして扱うことは理にかなっています。キーは名前です。リソース、およびそれらの後ろには、読み込まれたオブジェクトの格納された配列（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入れ子なし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とそれらへのオプション情報（たとえば、ページ付けを作成するためのサーバー上のレコードの総数）があります。このデータの一般的な形式は可能な限り統一する必要があります。これにより、リソースのタイプごとにレデューサーの作成を簡略化できます。</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getModelReducer = <span class="hljs-function"><span class="hljs-params">modelName</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">models = [], action</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> isModelAction = modelActionTypes.includes(action.type);
  <span class="hljs-keyword">if</span> (isModelAction &amp;&amp; action.modelName === modelName) {
    <span class="hljs-keyword">switch</span> (action.type) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">'ADD_MODELS'</span>:
        <span class="hljs-keyword">return</span> collection.add(action.models, models);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'CHANGE_MODEL'</span>:
        <span class="hljs-keyword">return</span> collection.change(action.model, models);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'REMOVE_MODEL'</span>:
        <span class="hljs-keyword">return</span> collection.remove(action.model, models);
      <span class="hljs-keyword">case</span> <span class="hljs-string">'RESET_STATE'</span>:
        <span class="hljs-keyword">return</span> [];<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> models;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、私がReduxを使用する上で議論したいもう1つのポイントは、副作用の実装です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず第一に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux Thunkを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全に忘れてください</font><font style="vertical-align: inherit;">-彼が提案したアクションを副作用のある関数に変換しますが、これは実用的なソリューションですが、アーキテクチャの基本概念が混在しており、その利点は何にもなりません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux Saga</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、副作用を実装するためのより正確なアプローチを提供します</font><font style="vertical-align: inherit;">が、その技術的な実装に関していくつかの質問があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、サーバーにアクセスする副作用をできる限り統一するようにしてください。</font><font style="vertical-align: inherit;">Stateフォームとリデューサーのように、単一のハンドラーを使用してサーバーへのリクエストを作成するロジックをほぼ常に実装できます。</font><font style="vertical-align: inherit;">たとえば、RESTful APIの場合、これは次のような一般化されたアクションをリッスンすることで実現できます。</font></font><br>
<br>
<pre><code class="javascript hljs">{ 
  <span class="hljs-attr">type</span>: <span class="hljs-string">'CREATE_MODEL'</span>, 
  <span class="hljs-attr">payload</span>: { 
    <span class="hljs-attr">model</span>: <span class="hljs-string">'reviews'</span>, 
    <span class="hljs-attr">attributes</span>: {
      <span class="hljs-attr">title</span>: <span class="hljs-string">'...'</span>,
      <span class="hljs-attr">text</span>: <span class="hljs-string">'...'</span><font></font>
    }<font></font>
  } <font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...そしてそれらに同じ一般化されたHTTPリクエストを作成します： </font></font><br>
<br>
<pre><code class="plaintext hljs">POST /api/reviews<font></font>
<font></font>
{<font></font>
  title: '...',<font></font>
  text: '...'<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてのヒントを意識的にたどることにより、理想的なアーキテクチャではないにしても、少なくともそれに近いアーキテクチャを得ることができます。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るい未来</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webインターフェースの最新の開発は本当に大きな前進を遂げており、現在、主要な問題のかなりの部分がすでに何らかの方法で解決されている時代に生きています。しかし、これは将来的に新しい革命が起こらないことを決して意味しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来を調べようとすると、おそらく次のようになります</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。1. JSXを使用しないコンポーネントアプローチ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンポーネントの概念は非常に成功していることが証明されており、おそらく、それらの普及がさらに進むでしょう。しかし、JSX自体は死ぬ可能性があり、死ぬ必要があります。はい、使用するのは本当に便利ですが、それでも、一般に受け入れられている標準でも、有効なJSコードでもありません。インターフェースを実装するためのライブラリーは、それらがどんなに優れていても、開発者向けのあらゆる可能な開発ツールキットに何度も何度も実装しなければならない新しい標準を生み出すべきではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Reduxのない状態コンテナーRedux</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
によって提案された一元化されたデータウェアハウスを使用することも非常に成功したソリューションであることが判明し、将来的にはインターフェイス開発の一種の標準になるはずですが、その内部アーキテクチャと実装は特定の変更と簡略化の対象となる可能性があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.ライブラリの互換性の強化</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
フロントエンドの開発者コミュニティは、時間の経過とともに、ライブラリの互換性を最大化するメリットを実感し、小さなエコシステムに閉じ込められることはなくなると信じています。</font><font style="vertical-align: inherit;">アプリケーションのすべてのコンポーネント-ルーター、ステートコンテナーなど-それらは非常に普遍的である必要があり、それらの交換は大量のリファクタリングまたはアプリケーションをゼロから書き直す必要がないはずです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれなのか</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の情報を一般化して、より単純で短い形式にすると、かなり一般的なポイントがいくつか得られます。- </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 アプリケーション開発を成功させるには、言語とフレームワークの知識だけでは十分ではありません。アプリケーションのアーキテクチャ、ベストプラクティス、パターンに注意を払う必要があります。設計。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 「唯一の定数は変化です。」</font><font style="vertical-align: inherit;">耕うんと開発のアプローチは変化し続けるため、大規模で長寿命のプロジェクトはアーキテクチャに適切な注意を払う必要があります。これがないと、新しいツールや手法を導入することは非常に困難になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、おそらくこれですべてです。</font><font style="vertical-align: inherit;">最後まで記事を読む力を見つけてくれた皆さんに感謝します。</font><font style="vertical-align: inherit;">質問やコメントがありましたら、コメントしてください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja456770/index.html">軍拡競争</a></li>
<li><a href="../ja456774/index.html">Kotlin / Scalaを使用した後にJavaで見逃したもの</a></li>
<li><a href="../ja456782/index.html">モデル指向の設計-チェルノブイリを繰り返さない方法</a></li>
<li><a href="../ja456790/index.html">PostgreSQLニュースダイジェスト。第16号</a></li>
<li><a href="../ja456792/index.html">Kubesprayを使用してOpenStackにKubernetesクラスターをデプロイする</a></li>
<li><a href="../ja456796/index.html">スバールバル諸島-販売前の「私は捕らわれた」プロジェクトの新しい名前</a></li>
<li><a href="../ja456798/index.html">SDL 2チュートリアル：レッスン5-テクスチャ</a></li>
<li><a href="../ja456804/index.html">お金に従ってください：RTMグループが暗号ウォレットでCおよびCサーバーのアドレスを隠し始めた方法</a></li>
<li><a href="../ja456806/index.html">すべての心配事から1つのボット</a></li>
<li><a href="../ja456808/index.html">フロントエンドWebアプリケーションのパフォーマンスを向上させる方法：5つのヒント</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>