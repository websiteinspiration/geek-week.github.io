<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👨🏿‍🤝‍👨🏾 👪 Why Discord Migrates from Go to Rust 👨🏽‍🍳 🔪 🌷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust is becoming a first-class language in a wide range of fields. We at Discord successfully use it on both the server and client side. For example, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Why Discord Migrates from Go to Rust</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487116/"><img src="https://habrastorage.org/getpro/habr/post_images/84a/0f1/d61/84a0f1d6126d5fd59b9c708f19c84692.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rust is becoming a first-class language in a wide range of fields. </font><font style="vertical-align: inherit;">We at Discord successfully use it on both the server and client side. </font><font style="vertical-align: inherit;">For example, on the client side in the video encoding pipeline for Go Live, and on the server side for the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elixir NIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Native Implemented Functions) functions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We recently dramatically improved the performance of a single service, rewriting it from Go to Rust. </font><font style="vertical-align: inherit;">This article will explain why it made sense for us to rewrite the service, how we did it and how much productivity improved.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Read State Tracking Service (Read States)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our company is built around one product, so let's start with some context, what exactly we transferred from Go to Rust. This is a Read States service. Her only task is to keep track of which channels and messages you read. Read States is accessed every time you connect to Discord, every time you send a message, and every time you read the message. In short, states are read continuously and are on a “hot path”. We want to make sure that Discord is always fast, so state checking should be fast.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The implementation of the service on Go did not meet all the requirements. </font><font style="vertical-align: inherit;">Most of the time it worked quickly, but every few minutes there were strong delays, noticeable to users. </font><font style="vertical-align: inherit;">After examining the situation, we determined that the delays are explained by Go's key features: its memory model and garbage collector (GC).</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why Go Doesn’t Meet Our Performance Goals</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To explain why Go doesn’t meet our performance targets, we first need to discuss data structures, scale, access patterns, and service architecture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To store state information, we use a data structure, which is called: Read State. There are billions of them in Discord: one state for each user per channel. Each state has several counters, which must be atomically updated and often reset to zero. For example, one of the counters is the number </font></font><code>@mention</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the channel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To quickly update the atomic counter, each Read States server has a Least Recently Used (LRU) cache. Each cache has millions of users and tens of millions of states. The cache is updated hundreds of thousands of times per second.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For safety, the cache is synchronized with the Cassandra database cluster. </font><font style="vertical-align: inherit;">When a key is pushed out of the cache, we enter the states of this user in the database. </font><font style="vertical-align: inherit;">In the future, we plan to update the database within 30 seconds with each state update. </font><font style="vertical-align: inherit;">This is tens of thousands of records in the database every second. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The graph below shows the response time and CPU load at the peak time interval for the Go </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><sup><font style="vertical-align: inherit;">1</font></sup></a><font style="vertical-align: inherit;"> service</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><sup><font style="vertical-align: inherit;"></font></sup></a><a name="1_1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">It can be seen that delays and bursts of load on the CPU occur approximately every two minutes.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/90d/37b/89f/90d37b89f25eab54420107e63c086c44.png"><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So where does the growth of delays every two minutes come from?</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go, memory is not freed immediately when a key is pushed out of the cache. Instead, the garbage collector runs periodically and looks for unused portions of memory. This is a lot of work that can slow down a program. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is very likely that periodic slowdowns of our service are associated with garbage collection. But we wrote a very efficient Go code with a minimal amount of memory allocation. There should not be much trash left. What is the matter? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rummaging through the Go source code, we learned that Go forcibly starts garbage collection </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at least every two minutes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Regardless of the heap size, if the GC did not start for two minutes, Go will force it to start.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We decided that if you run GC more often, you can avoid these peaks with large delays, so we set an endpoint in the service to change the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GC Percent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> value on the fly </font><font style="vertical-align: inherit;">. Unfortunately, the configuration of GC Percent did not affect anything. How could this happen? It turns out that GC did not want to start more often, because we did not allocate memory often enough.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We began to dig further. It turned out that such large delays do not occur due to the huge amount of freed memory, but because the garbage collector scans the entire LRU cache to check all the memory. Then we decided that if we decrease the LRU cache, then the scan volume will decrease. Therefore, we added one more parameter to the service to change the size of the LRU cache, and changed the architecture, breaking the LRU into many separate caches on each server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so it happened. With smaller caches, peak delays are reduced. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unfortunately, the compromise with decreasing LRU cache raised the 99th percentile (that is, the average value for a sample of 99% of the delays increased, excluding peak ones). This is because decreasing the cache reduces the likelihood that the user's Read State will be in the cache. If it is not here, then we must turn to the database.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After a large amount of load testing on different cache sizes, we kind of found an acceptable setting. </font><font style="vertical-align: inherit;">Although not ideal, it was a satisfactory solution, so we left the service for a long time to work like that. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the same time, we implemented Rust very successfully in other Discord systems, and as a result we made a collective decision to write frameworks and libraries for new services only in Rust. </font><font style="vertical-align: inherit;">And this service seemed to be a great candidate for porting to Rust: it is small and autonomous, and we hoped that Rust would fix these spikes with delays and ultimately make the service more pleasant for users </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup></a><a name="2_2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Management in Rust</font></font></h1><br>
<blockquote><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust is incredibly fast and efficient with memory: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the absence of a runtime environment and garbage collector,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> it is suitable for high-performance services, embedded applications and integrates easily with other languages. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup></a><a name="3_3"></a></i></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rust does not have a garbage collector, so we decided that there would be no such delays, like Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In memory management, he uses a rather unique approach with the idea of ​​"owning" memory. </font><font style="vertical-align: inherit;">In short, Rust keeps track of who has the right to read from and write to memory. </font><font style="vertical-align: inherit;">He knows when a program uses memory, and immediately frees it as soon as memory is no longer needed. </font><font style="vertical-align: inherit;">Rust enforces memory rules at compile time, which virtually eliminates the possibility of memory errors at run time. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></sup></a><a name="4_4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You do not need to manually track the memory. </font><font style="vertical-align: inherit;">The compiler will take care of this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, in the Rust version, when Read State is excluded from the LRU cache, memory is freed immediately. </font><font style="vertical-align: inherit;">This memory does not sit and does not wait for the garbage collector. </font><font style="vertical-align: inherit;">Rust knows that it is no longer in use and immediately releases it. </font><font style="vertical-align: inherit;">There is no process in runtime for scanning which memory to free.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Rust</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But there was one problem with the Rust ecosystem. At the time of implementation of our service, there were no decent asynchronous functions in the stable branch of Rust. For a network service, asynchronous programming is a must. The community has developed several libraries, but with a non-trivial connection and very stupid error messages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, the Rust team worked hard to simplify asynchronous programming, and it was already available on the unstable channel (Nightly).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discord was never afraid to learn promising new technologies. For example, we were one of the first users of Elixir, React, React Native, and Scylla. If some technology looks promising and gives us an advantage, then we are ready to face the inevitable difficulty of implementation and the instability of advanced tools. This is one of the reasons that we have so quickly reached an audience of 250 million users with less than 50 programmers in the state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The introduction of new asynchronous functions from the unstable Rust channel is another example of our willingness to adopt a new, promising technology. The engineering team decided to implement the necessary functions without waiting for their support in the stable version. Together with other representatives of the community, we have overcome all the problems that have arisen, and now </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asynchronous Rust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maintained in a stable branch. </font><font style="vertical-align: inherit;">Our rate has paid off.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementation, stress testing and launch</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just rewriting the code was easy. We started with a rough broadcast, then reduced it to places where it made sense. For example, Rust has an excellent type system with extensive support for generics (for working with data of any type), so we quietly threw away the Go code, which compensated for the lack of generics. In addition, the Rust memory model takes into account the memory security in different threads, so we threw away the protective goroutines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Load testing immediately showed an excellent result. Service performance on Rust turned out to be as high as that of the Go version, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">but without these bursts of increased delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically, we practically did not optimize the Rust version. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But even with the simplest optimizations, Rust was able to outperform a carefully tuned version of Go.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is an eloquent proof of how easy it is to write effective Rust programs compared to going deep into Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But we did not satisfy the simple performance quo. </font><font style="vertical-align: inherit;">After a little profiling and optimization, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we surpassed Go in all respects</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Delay, CPU and memory - everything got better in the Rust version. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rust performance optimizations included:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Switching to BTreeMap instead of HashMap in the LRU cache to optimize memory usage.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replacing the original library of metrics with a version with support for modern concurrency Rust.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decrease the number of copies in memory.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Satisfied, we decided to deploy the service. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The launch went pretty smoothly, as we conducted stress tests. </font><font style="vertical-align: inherit;">We connected the service to one test node, discovered and fixed several borderline cases. </font><font style="vertical-align: inherit;">Soon after, they rolled a new version to the entire server park. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results are shown below. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The purple graph is Go, the blue graph is Rust.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/yb/-v/mi/yb-vmise0bioz33f8yfrockjr_0.png"></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Increase cache size</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the service successfully worked for several days, we decided to increase the LRU cache again. </font><font style="vertical-align: inherit;">As mentioned above, in the Go version, this could not be done, because the time for garbage collection increased. </font><font style="vertical-align: inherit;">Since we no longer do garbage collection, you can increase the cache counting on an even greater increase in performance. </font><font style="vertical-align: inherit;">So, we have increased the memory on the servers, optimized the data structure for less memory usage (for fun) and increased the cache size to 8 million Read State states. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results below speak for themselves. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note that average time is now measured in microseconds, and maximum delay </font></font><code>@mention</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is measured in milliseconds.</font></font></b><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/93f/55a/500/93f55a500413c691a4e711e4c90ceada.png"></div><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ecosystem development</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, Rust has a wonderful ecosystem that is growing rapidly. </font><font style="vertical-align: inherit;">For example, recently a new version of the asynchronous runtime that we use is Tokio 0.2. </font><font style="vertical-align: inherit;">We updated, and without any effort on our part, automatically reduced the load on the CPU. </font><font style="vertical-align: inherit;">In the graph below, you can see how the load has decreased since about January 16th.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/128/490/e5f12849036cfea0b9e9246a1e321ed0.png"></div><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final thoughts</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Discord currently uses Rust in many parts of the software stack: for GameSDK, capturing and encoding video in Go Live, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Elixir NIF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , several backend services, and many more. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When starting a new project or software component, we are definitely considering using Rust. Of course, only where it makes sense. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to performance, Rust provides developers with many other benefits. For example, its type safety and borrow checker (borrow checker) greatly simplify refactoring as you change product requirements or introduce new language features. The ecosystem and tools are excellent and are developing rapidly. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fun fact: the Rust team also uses Discord to coordinate. There is even a very useful</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rust community server</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , where we sometimes chat.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><div style="text-align:center;"><img src="https://habrastorage.org/webt/br/pc/l_/brpcl_fl4bwj8fcmaeodxotfw5s.png"></div></a><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Footnotes</font></font></h4><br>
<font color="gray"><ol>
<li><a name="1"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Charts taken from Go version 1.9.2. </font><font style="vertical-align: inherit;">We tried versions 1.8, 1.9 and 1.10 without any improvements. </font><font style="vertical-align: inherit;">The initial migration from Go to Rust was completed in May 2019. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[to return]</font></font></a><br>
</li>
<li><a name="2"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For clarity, we do not recommend rewriting everything in Rust for no reason. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[to return]</font></font></a><br>
</li>
<li><a name="3"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quote from the official site. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[to return]</font></font></a><br>
</li>
<li><a name="4"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, until you use </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsafe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[to return]</font></font></a></li>
</ol></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487100/index.html">State-of-the-art immutable data structures</a></li>
<li><a href="../en487106/index.html">PVS-Studio analyzer RunUO check</a></li>
<li><a href="../en487108/index.html">Mobile Gamer Profile: MyTracker Research</a></li>
<li><a href="../en487110/index.html">Slurm SRE. A complete experiment with experts from Booking.com and Google.com</a></li>
<li><a href="../en487112/index.html">Edge of Madness: The Basic Circle</a></li>
<li><a href="../en487118/index.html">Loki - collecting logs using the Prometheus approach</a></li>
<li><a href="../en487120/index.html">How to distribute kittens</a></li>
<li><a href="../en487122/index.html">Google JavaScript Style Guide Translation</a></li>
<li><a href="../en487124/index.html">Interview with Borey Yangel about Yandex self-drive and Alice’s creation story</a></li>
<li><a href="../en487126/index.html">How corporate development teams use GitLab and Mattermost ChatOps to speed development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>