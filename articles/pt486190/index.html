<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏻‍🤝‍🧑🏻 👩🏿‍🎤 🔹 Nossa experiência no desenvolvimento de um driver CSI em Kubernetes para Yandex.Cloud 🤫 👶🏻 ☸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Temos o prazer de anunciar que o Flant está reabastecendo sua contribuição para as ferramentas de código aberto do Kubernetes, lançando uma versão alf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Nossa experiência no desenvolvimento de um driver CSI em Kubernetes para Yandex.Cloud</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/486190/"><img src="https://habrastorage.org/webt/1y/to/tn/1ytotnf73zepbwfalhzoropf9qa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Temos o prazer de anunciar que o Flant está reabastecendo sua contribuição para as ferramentas de código aberto do Kubernetes, lançando uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versão alfa do driver CSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Container Storage Interface) para Yandex.Cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas antes de passarmos aos detalhes da implementação, responderemos à pergunta de por que isso é necessário quando o Yandex já possui o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serviço Serviço Gerenciado para Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introdução</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que é isso?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dentro da nossa empresa, desde o início da operação do Kubernetes em produção (ou seja, por vários anos), nossa própria ferramenta (deckhouse) está em desenvolvimento, que, a propósito, também planejamos disponibilizar como projeto de código aberto em um futuro próximo. Com sua ajuda, configuramos e configuramos uniformemente todos os nossos clusters e, no momento, existem mais de 100 deles, além disso, nas mais diversas configurações de ferro e em todos os serviços em nuvem disponíveis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os clusters nos quais o deckhouse é usado têm todos os componentes necessários para o trabalho: balanceadores, monitoramento com gráficos, métricas e alertas convenientes, autenticação do usuário através de provedores externos para acessar todos os painéis e assim por diante. </font><font style="vertical-align: inherit;">Não faz sentido colocar um cluster "bombeado" em uma solução gerenciada, pois muitas vezes é impossível ou levará à necessidade de desativar metade dos componentes. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NB</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Esta é a nossa experiência, e é bastante específica. </font><font style="vertical-align: inherit;">De maneira alguma afirmamos que todos devem se envolver independentemente na implantação do cluster Kubernetes em vez de usar soluções prontas. </font><font style="vertical-align: inherit;">A propósito, não temos experiência real na operação do Kubernetes a partir do Yandex e não faremos nenhuma avaliação deste serviço neste artigo.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que é e para quem?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Então, nós já conversamos sobre a abordagem moderna de armazenamento no Kubernetes: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como o CSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funciona </font><font style="vertical-align: inherit;">e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">como a comunidade chegou</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a essa abordagem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atualmente, muitos grandes provedores de serviços em nuvem desenvolveram drivers para usar suas unidades em nuvem como um volume persistente no Kubernetes. Se o fornecedor não tiver esse driver, mas ao mesmo tempo todas as funções necessárias forem fornecidas por meio da API, nada o impedirá de implementar o driver por conta própria. E assim aconteceu com o Yandex.Cloud. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como base para o desenvolvimento, adotamos o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">driver CSI para a nuvem DigitalOcean</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e algumas idéias do </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">driver para GCP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , já que a interação com a API dessas nuvens (Google e Yandex) tem várias semelhanças. Em particular, a API e</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retornam um objeto </font></font><code>Operation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para rastrear o status de operações demoradas (por exemplo, criando um novo disco). </font><font style="vertical-align: inherit;">Para interagir com a API </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex.Cloud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">SDK</font></a><font style="vertical-align: inherit;"> do </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">Yandex.Cloud Go é usado</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O resultado do trabalho realizado é </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publicado no GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e pode ser útil para quem, por algum motivo, usa sua própria instalação do Kubernetes nas máquinas virtuais Yandex.Cloud (mas não é um cluster gerenciado pronto) e gostaria de usar (solicitar) discos via CSI.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementação</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Características principais</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atualmente, o driver suporta as seguintes funções:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordenando discos em todas as zonas do cluster de acordo com a topologia de nós no cluster;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Removendo discos encomendados anteriormente;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redimensionamento offline para discos (o Yandex. Cloud </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">não suporta o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aumento de discos montados em uma máquina virtual). </font><font style="vertical-align: inherit;">Sobre como modificar o driver para redimensionar o mais simples possível, veja abaixo.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No futuro, está planejado implementar o suporte para a criação e remoção de discos de captura instantânea.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A principal dificuldade e sua superação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A falta de capacidade de expandir discos em tempo real na API Yandex.Cloud é uma limitação que complica a operação de redimensionamento do PV (Volume Persistente): nesse caso, é necessário que o pod do aplicativo que usa o disco seja parado e isso pode causar uma simples formulários. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De acordo com </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a especificação CSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , se o controlador CSI relatar que só pode redimensionar os discos "offline" ( </font></font><code>VolumeExpansion.OFFLINE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), o processo de aumento do disco deve ser assim:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se o plugin tiver apenas </font></font><code>VolumeExpansion.OFFLINE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de expansão e o volume estiver atualmente publicado ou disponível em um nó, </font></font><code>ControllerExpandVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DEVE ser chamado SOMENTE após:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O plug-in tem </font></font><code>PUBLISH_UNPUBLISH_VOLUME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de </font><font style="vertical-align: inherit;">controlador </font><font style="vertical-align: inherit;">e </font></font><code>ControllerUnpublishVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi chamado com sucesso.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SE NÃO</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O plug-in NÃO possui </font></font><code>PUBLISH_UNPUBLISH_VOLUME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de </font><font style="vertical-align: inherit;">controlador </font><font style="vertical-align: inherit;">, o plug-in tem </font></font><code>STAGE_UNSTAGE_VOLUME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de </font><font style="vertical-align: inherit;">nó </font><font style="vertical-align: inherit;">e </font></font><code>NodeUnstageVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi concluído com êxito.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SE NÃO</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O plug-in NÃO possui </font></font><code>PUBLISH_UNPUBLISH_VOLUME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de </font><font style="vertical-align: inherit;">controlador </font><font style="vertical-align: inherit;">, nem </font></font><code>STAGE_UNSTAGE_VOLUME</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">capacidade de </font><font style="vertical-align: inherit;">nó </font><font style="vertical-align: inherit;">, e </font></font><code>NodeUnpublishVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi concluída com êxito.</font></font></li>
</ul></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em essência, isso significa a necessidade de desconectar o disco da máquina virtual antes de aumentá-lo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, infelizmente, a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementação da</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especificação CSI através do side-car não atende a estes requisitos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No sidecar-container </font></font><code>csi-attacher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que deve ser responsável pela presença do espaço necessário entre as montagens, essa funcionalidade simplesmente não é implementada com o redimensionamento offline. </font><font style="vertical-align: inherit;">Uma discussão sobre isso foi iniciada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O que é um contêiner lateral neste contexto? </font><font style="vertical-align: inherit;">O próprio plug-in CSI não interage com a API do Kubernetes, mas responde apenas às chamadas de gRPC que os contêineres laterais enviam para ele. </font><font style="vertical-align: inherit;">Estes últimos estão </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sendo desenvolvidos pela</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comunidade Kubernetes.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso (plugin CSI), a operação para aumentar o disco é a seguinte:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recebemos uma chamada de gRPC </font></font><code>ControllerExpandVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estamos tentando aumentar o disco na API, mas obtemos um erro sobre a impossibilidade de executar a operação, pois o disco está montado;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salvamos o identificador de disco no mapa que contém os discos para os quais você precisa executar uma operação de aumento. </font><font style="vertical-align: inherit;">Por questões de brevidade, chamaremos este mapa como </font></font><code>volumeResizeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exclua manualmente o pod que usa o disco. </font><font style="vertical-align: inherit;">O Kubernetes irá reiniciá-lo. </font><font style="vertical-align: inherit;">Para que o disco não tenha tempo de montar ( </font></font><code>ControllerPublishVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) antes da conclusão da operação de aumento ao tentar montar, verificamos se esse disco ainda está dentro </font></font><code>volumeResizeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e retornamos um erro;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O driver CSI está tentando executar novamente a operação de redimensionamento. </font><font style="vertical-align: inherit;">Se a operação foi bem-sucedida, exclua o disco de </font></font><code>volumeResizeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Porque </font><font style="vertical-align: inherit;">está faltando o identificador de disco </font></font><code>volumeResizeRequired</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ControllerPublishVolume</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">é bem-sucedido, o disco está montado e o pod é iniciado.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo parece bastante simples, mas como sempre, existem armadilhas. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O redimensionador externo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está envolvido na </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">expansão do</font></a><font style="vertical-align: inherit;"> disco </font><font style="vertical-align: inherit;">, que, em caso de erro durante a operação, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usa uma fila</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com um aumento exponencial no tempo limite de espera até 1000 segundos:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DefaultControllerRateLimiter</span><span class="hljs-params">()</span> <span class="hljs-title">RateLimiter</span></span> {
  <span class="hljs-keyword">return</span> NewMaxOfRateLimiter(<font></font>
  NewItemExponentialFailureRateLimiter(<span class="hljs-number">5</span>*time.Millisecond, <span class="hljs-number">1000</span>*time.Second),
  <span class="hljs-comment">// 10 qps, 100 bucket size.  This is only for retry speed and its only the overall factor (not per item)</span>
  &amp;BucketRateLimiter{Limiter: rate.NewLimiter(rate.Limit(<span class="hljs-number">10</span>), <span class="hljs-number">100</span>)},<font></font>
  )<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Periodicamente, isso pode levar ao fato de que a operação de aumentar o disco é estendida por mais de 15 minutos e, portanto, a inacessibilidade do pod correspondente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A única opção que nos permitiu reduzir o tempo de inatividade potencial de maneira fácil e indolor foi usar nossa versão do redimensionador externo com um limite de tempo limite máximo de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 segundos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
 <br>
<pre><code class="go hljs">workqueue.NewItemExponentialFailureRateLimiter(<span class="hljs-number">5</span>*time.Millisecond, <span class="hljs-number">5</span>*time.Second)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Não consideramos necessário iniciar urgentemente uma discussão e corrigir o redimensionador externo, porque os discos de redimensionamento offline são um atavismo que em breve desaparecerá de todos os provedores de nuvem.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como começar a usar?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O driver é suportado no Kubernetes versão 1.15 e superior. </font><font style="vertical-align: inherit;">Para o driver funcionar, os seguintes requisitos devem ser atendidos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O sinalizador é </font></font><code>--allow-privileged</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definido como o valor </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para o servidor da API e o kubelet;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluído </font></font><code>--feature-gates=VolumeSnapshotDataSource=true,KubeletPluginsWatcher=true,CSINodeInfo=true,CSIDriverRegistry=true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para servidor de API e kubelet;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Montagem de propagação ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propagação de montagem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) deve ser incluída no cluster. </font><font style="vertical-align: inherit;">Ao usar o Docker, o daemon deve ser configurado para permitir montagens compartilhadas.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as etapas necessárias para a instalação em si são </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descritas em README</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Instalação é a criação de objetos no Kubernetes a partir de manifestos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que o driver funcione, você precisará do seguinte:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indique o identificador do diretório de catálogo Yandex.Cloud ( </font></font><code>folder-id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">no manifesto </font><font style="vertical-align: inherit;">( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consulte a documentação</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> );</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para interagir com a API Yandex.Cloud no driver CSI, uma conta de serviço é usada. </font><font style="vertical-align: inherit;">No manifesto secreto, você deve passar as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaves autorizadas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para a conta de serviço. </font><font style="vertical-align: inherit;">A documentação </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descreve</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como criar uma conta de serviço e obter as chaves.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">experimente</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e teremos o maior prazer em receber feedback e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">novos problemas,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se você encontrar algum problema!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suporte adicional</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, gostaríamos de observar que implementamos esse driver CSI não por um grande desejo de se divertir escrevendo aplicativos no Go, mas por causa da necessidade urgente dentro da empresa. </font><font style="vertical-align: inherit;">Não parece aconselhável oferecer suporte à nossa própria implementação; portanto, se o Yandex mostrar interesse e decidir continuar dando suporte ao driver, teremos o prazer de transferir o repositório à sua disposição. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, provavelmente, o Yandex no cluster gerenciado Kubernetes possui sua própria implementação do driver CSI, que pode ser lançado em código aberto. </font><font style="vertical-align: inherit;">Essa opção de desenvolvimento também parece favorável para nós - a comunidade poderá usar o driver comprovado do provedor de serviços e não de uma empresa de terceiros.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leia também no nosso blog:</font></font><br>
<br>
<ul>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Kubernetes CCM (Cloud Controller Manager)  .</a>»;</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     Kubernetes:  Flexvolume  CSI</a>»;</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Container Storage Interface ( Kubernetes   )</a>»;</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> Kubernetes-   ?  addon-operator</a>»;</li>
<li> «<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   Kubernetes (   )</a>».</li>
</ul></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt486190/">https://habr.com/ru/post/pt486190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt486178/index.html">FOSS News No. 1 - revisão de notícias gratuitas e de código aberto de 27 de janeiro a 2 de fevereiro de 2020</a></li>
<li><a href="../pt486180/index.html">Dicas e fontes para criar aplicativos sem servidor</a></li>
<li><a href="../pt486184/index.html">Como usar a pesquisa efetivamente</a></li>
<li><a href="../pt486186/index.html">Nuvem catastrófica: como funciona</a></li>
<li><a href="../pt486188/index.html">Apresentando o sistema de backup PostgreSQL wal-g</a></li>
<li><a href="../pt486192/index.html">Ciber fraudadores hackear operadoras de telefonia móvel para obter números de telefone de assinantes</a></li>
<li><a href="../pt486194/index.html">Sobre backups no Proxmox VE</a></li>
<li><a href="../pt486198/index.html">Falar é difícil. Ensaios sobre Comunicação com Não Programadores</a></li>
<li><a href="../pt486200/index.html">Dicas do Docker: limpe sua máquina contra o lixo</a></li>
<li><a href="../pt486202/index.html">Alpine coleta Docker constrói sob Python 50 vezes mais devagar e imagens 2 vezes mais pesadas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>