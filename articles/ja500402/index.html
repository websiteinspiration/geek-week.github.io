<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏾 🚇 🛀🏼 [パート1/2] FFmpegとSDLのガイド、または1000行未満でビデオプレーヤーを作成する方法 💞 🕵🏽 🍭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この情報は既に古くなっていますが、FFmpegのトピックに関するさまざまな有用なコンテンツのインスピレーションの人気のある情報源は、元の資料です。ただし、原文からロシア語への完全な翻訳はまだありません。迷惑な脱落を修正します。
 
 そして、試みましたが、そのような膨大なテキストでは翻訳の難しさが避...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[パート1/2] FFmpegとSDLのガイド、または1000行未満でビデオプレーヤーを作成する方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/500402/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/8g/lm/9b/8glm9bxivqkvscmah31ojdjmzci.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この情報は既に古くなっていますが、FFmpegのトピックに関するさまざまな有用なコンテンツのインスピレーションの人気のある情報源は、元の資料です。</font><font style="vertical-align: inherit;">ただし、原文からロシア語への完全な翻訳はまだありません。</font><font style="vertical-align: inherit;">迷惑な脱落を修正します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、試みましたが、そのような膨大なテキストで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は翻訳の難しさが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">避けられません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">バグを報告する（できればプライベートメッセージで）-一緒に改善しましょう。</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目次</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序文</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン1：スクリーンキャップの作成</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン2：レッスンの表示</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3：サウンドの再生</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン4：マルチスレッド</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン5：ビデオの同期</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> 6:  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> 7: </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> 1.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> 2.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><a name="preamble"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="EDISONソフトウェア-ウェブ開発"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISONソフトウェア-ウェブ開発"></a><br clear="right">
     EDISON.<br>
<br>
        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">     </a>,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">      C  C++</a>.<br>
<br>
     ! ;-)</blockquote><br>
<h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン1：スクリーンキャプチャの作成">→</a></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：このガイドは2015年2月の時点で更新されています。</font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ビデオアプリケーションや汎用ユーティリティを作成するための優れたライブラリです。 FFmpegは、ビデオ処理ルーチン全体を処理し、すべてのデコード、エンコード、多重化、および逆多重化を実行します。これにより、メディアアプリケーションの作成が大幅に簡略化されます。すべてが非常にシンプルですばやく、Cで記述されています。現在利用可能なほとんどすべてのコーデックをデコードしたり、他のいくつかの形式にエンコードしたりできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一の問題は、ドキュメントがほとんど見つからないことです。チュートリアルが1つあります（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナルには、存在しないWebページへのリンクがあります-ノートトランスレータ）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、FFmpegの基本とdoxygenドックの自動生成について説明します。そして、それ以上。したがって、FFmpegを使用して動作するデジタルビデオおよびオーディオアプリケーションを作成する方法を独自に理解すると同時に、プロセスを文書化し、教科書の形で提示することにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFmpegに付属するFFplayプログラムがあります。それはシンプルで、Cで書かれ、FFmpegを使用して本格的なビデオプレーヤーを実装します。私の最初のレッスンは、Martin Boehmeによるオリジナルのレッスンの更新バージョンです（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オリジナルでは、すでに無効になっているWebページへのリンク-翻訳者のメモ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-そこからいくつかの部分をドラッグしました。また、一連のレッスンでは、</font><b><font style="vertical-align: inherit;">ffplay.cに</font></b><font style="vertical-align: inherit;">基づいて動作するビデオプレーヤーを作成するプロセスを示します</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファブリス・ベラード。各レッスンは、その実装の説明とともに新しいアイデア（または2つ）を提示します。各章には、独自にコンパイルして実行できるCリストが付属しています。ソースファイルは、このプログラムがどのように機能するか、個々の部分がどのように機能するかを示し、このガイドではカバーされていない技術的な詳細についても示します。完了すると、動作するビデオプレーヤーが1000行未満のコードで記述されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーヤーを作成するときは、SDLを使用してオーディオおよびビデオメディアファイルを出力します。 SDLは、MPEG再生プログラム、エミュレーター、および多くのビデオゲームで使用される優れたクロスプラットフォームマルチメディアライブラリです。このガイドのプログラムをコンパイルするには、システムにSDLライブラリをダウンロードしてインストールする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルは、プログラミングの経験が豊富な人を対象としています。少なくとも、Cを理解している必要があり、キュー、ミューテックスなどの概念も理解している必要があります。マルチメディアについてある程度の理解が必要です。たとえば、波形などです。ただし、レッスンで多くの概念を説明するため、これらの問題の第一人者である必要はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dranger Doggy Gmail dot Comで、エラーメッセージ、質問、コメント、アイデア、機能などを自由に送ってください。</font></font><a name="screencaps"></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EDISON社</font><font style="vertical-align: inherit;">のブログも</font><font style="vertical-align: inherit;">ご覧ください。</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libavマニュアル</font></font></b></a><br>
<hr><hr><hr><hr><hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン1：スクリーン</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title=" "><font style="vertical-align: inherit;">キャップの</font></a><font style="vertical-align: inherit;">作成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="序文"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン2：ディスプレイ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリスト：tutorial01.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial01.c</span>
<span class="hljs-comment">// Code based on a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101 </span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span><font></font>
<font></font>
<span class="hljs-comment">// A small sample program that shows how to use libavformat and libavcodec to</span>
<span class="hljs-comment">// read video from a file.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lswscale -lz</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed</span>
<span class="hljs-comment">// your system).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// tutorial01 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to write the first five frames from "myvideofile.mpg" to disk in PPM</span>
<span class="hljs-comment">// format.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
  <span class="hljs-comment">// Initalizing these to NULL prevents segfaults!</span>
  AVFormatContext   *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>               i, videoStream;<font></font>
  AVCodecContext    *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext    *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec           *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrameRGB = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket          packet;<font></font>
  <span class="hljs-keyword">int</span>               frameFinished;
  <span class="hljs-keyword">int</span>               numBytes;
  <span class="hljs-keyword">uint8_t</span>           *buffer = <span class="hljs-literal">NULL</span>;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please provide a movie file\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
  pFrameRGB=av_frame_alloc();<font></font>
  <span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
  numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
			      pCodecCtx-&gt;height);<font></font>
  buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));<font></font>
  <font></font>
  <span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
  <span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
  <span class="hljs-comment">// of AVPicture</span><font></font>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
		 pCodecCtx-&gt;width, pCodecCtx-&gt;height);<font></font>
  <font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_RGB24,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {
	<span class="hljs-comment">// Convert the image from its native format to RGB</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
	<span class="hljs-comment">// Save the frame to disk</span>
	<span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
	  SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <font></font>
		    i);<font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the RGB image</span><font></font>
  av_free(buffer);<font></font>
  av_frame_free(&amp;pFrameRGB);<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概観</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
映画ファイルにはいくつかの主要なコンポーネントがあります。まず、ファイル自体は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ、</font><b><font style="vertical-align: inherit;">コンテナー</font></b><font style="vertical-align: inherit;">の種類によって、ファイル内でのデータの表現方法が決まります。コンテナの例としては、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quicktimeがあり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。さらに、ファイルにはいくつかのスレッドがあります。特に、通常は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオストリーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオストリームがあります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 （「ストリーム」とは、「タイムラインに従って利用可能な一連のデータ項目」の面白い単語です。）ストリーム内のデータ項目は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><font style="vertical-align: inherit;">ます。各ストリームは、1つまたは別のタイプの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーデックで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンコードされ</font><font style="vertical-align: inherit;">ます。コーデックは、実際のデータ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのよう</font><b><font style="vertical-align: inherit;">に</font></b><font style="vertical-align: inherit;"> diruyutsyaおよび</font><b><font style="vertical-align: inherit;">Decemberに</font></b><font style="vertical-align: inherit;">決定するかを決定します</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">監査済み-コーデックの名前。</font><font style="vertical-align: inherit;">コーデックの例は、DivXとMP3です。</font><font style="vertical-align: inherit;">次に、パケットがストリームから読み取られます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パケット</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、生のフレームにデコードされる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データのビットを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含むことができるデータの一部であり</font><font style="vertical-align: inherit;">、アプリケーションで最終的に操作できます。</font><font style="vertical-align: inherit;">ここでは、各パケットにフルフレーム（またはオーディオの場合は複数のフレーム）が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオストリームとオーディオストリームの操作は、最も基本的なレベルでも非常に簡単です。</font></font><br>
<br>
<pre><code class="vbscript hljs"><span class="hljs-number">10</span> OPEN video_stream FROM video.avi
<span class="hljs-number">20</span> READ packet FROM video_stream INTO frame
<span class="hljs-number">30</span> <span class="hljs-keyword">IF</span> frame <span class="hljs-keyword">NOT</span> COMPLETE <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span>
<span class="hljs-number">40</span> <span class="hljs-keyword">DO</span> SOMETHING <span class="hljs-keyword">WITH</span> frame
<span class="hljs-number">50</span> <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFmpegを使用したマルチメディアの操作は、このプログラムの場合とほとんど同じくらい簡単ですが、一部のプログラムでは、「MAKE [...]」ステップが非常に難しい場合があります。</font><font style="vertical-align: inherit;">このチュートリアルでは、ファイルを開いて、その中のビデオストリームをカウントし、「MAKE [...]」でフレームをPPMファイルに書き込みます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルを開く</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず最初に、ファイルを開いたときに最初に何が起こるか見てみましょう。</font><font style="vertical-align: inherit;">FFmpegを使用して、最初に目的のライブラリを初期化します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ffmpeg/swscale.h&gt;</span></span><font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, charg *argv[])</span> </span>{<font></font>
av_register_all();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、使用可能なすべてのファイル形式とコーデックがライブラリに登録されるため、適切な形式/コーデックでファイルを開くときに、それらが自動的に使用されます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_register_all</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は1回だけ</font><font style="vertical-align: inherit;">呼び出す必要がある</font><font style="vertical-align: inherit;">ので、ここでは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）で</font><font style="vertical-align: inherit;">呼び出します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">必要に応じて、選択可能なファイル形式とコーデックのみを登録できますが、通常、特別な理由はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次にファイルを開きます。</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Open video file</span>
<span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の引数からファイル名を取得します。</font><font style="vertical-align: inherit;">この関数は、ファイルヘッダーを読み取り、</font><font style="vertical-align: inherit;">渡し</font><font style="vertical-align: inherit;">た</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造にファイル形式情報を格納します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後の3つの引数は、ファイル形式、バッファーサイズ、および形式パラメーターを指定するために使用されます。</font><font style="vertical-align: inherit;">それらをNULLまたは0に設定すると、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libavformat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はすべてを自動的に検出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数はヘッダーのみを確認するため、ファイル内のストリーム情報を確認する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Retrieve stream information</span>
<span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、</font><font style="vertical-align: inherit;">有効なデータ</font><font style="vertical-align: inherit;">を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><b><font style="vertical-align: inherit;">渡し</font></b><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">便利なデバッグ機能に慣れ、内部を表示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Dump information about file onto standard error</span>
av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、サイズ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_streamsの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタの配列にすぎませ</font><b><font style="vertical-align: inherit;">ん</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ビデオストリームが見つかるまで説明します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i;<font></font>
AVCodecContext *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
AVCodecContext *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
    videoStream=i;<font></font>
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
<font></font>
<span class="hljs-comment">// Get a pointer to the codec context for the video stream</span>
pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリーム内のコーデックに関する情報は、「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーデックコンテキスト</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」</font><font style="vertical-align: inherit;">と呼ばれる場所にあり</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これには、ストリームが使用するコーデックに関するすべての情報が含まれており、これへのポインターがあります。</font><font style="vertical-align: inherit;">しかし、実際のコーデックを見つけて開く必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">// Open codec</span>
<span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオストリームから</font><font style="vertical-align: inherit;">
直接</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用することはできません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vcodec_copy_context</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">てコンテキストを新しい場所にコピーする必要があります（もちろん、メモリが割り当てられた後）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データストレージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、フレームを格納する場所が必要です。</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Allocate video frame</span>
pFrame=av_frame_alloc();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
24ビットRGBに保存されているPPMファイルを出力する予定なので、フレームを独自の形式からRGBに変換する必要があります。</font><font style="vertical-align: inherit;">FFmpegが代わりにやってくれます。</font><font style="vertical-align: inherit;">ほとんどのプロジェクト（このプロジェクトを含む）では、開始フレームを特定の形式に変換する必要があります。</font><font style="vertical-align: inherit;">変換されたフレームのフレームを選択します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
pFrameRGB=av_frame_alloc();<font></font>
<span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームを選択したにもかかわらず、変換時に生データを収容できる場所が必要です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_get_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して適切なサイズを取得し、必要なスペースを手動で割り当てます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint8_t</span> *buffer = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> numBytes;
<span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
                            pCodecCtx-&gt;height);<font></font>
buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">FFmpegの</font><font style="vertical-align: inherit;">C関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mallocに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">類似</font><font style="vertical-align: inherit;">しています。これは、</font><font style="vertical-align: inherit;">メモリアドレスのアライメントなどを提供する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mallocの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なラッパーです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ちなみに、これは、メモリリーク、二重解放、または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で発生するその他の問題から保護しません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_fill</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して、フレームを新しく割り当てられたバッファに関連付けます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPictureの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造は</font><font style="vertical-align: inherit;">のサブセットである</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrameの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造</font><font style="vertical-align: inherit;">-の先頭</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrameの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造が</font><b><font style="vertical-align: inherit;">ある</font></b><font style="vertical-align: inherit;">と同一の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPictureの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
<span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
<span class="hljs-comment">// of AVPicture</span><font></font>
avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
                pCodecCtx-&gt;width, pCodecCtx-&gt;height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすでにゴールラインにいます！</font><font style="vertical-align: inherit;">これで、ストリームから読み取る準備ができました！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データの読み取り</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、ビデオストリーム全体を読み取るために、次のパッケージを読み取り、フレーム内で復号化します。復号化が完了したらすぐに、フレームを変換して保存します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span>
<span class="hljs-keyword">int</span> frameFinished;<font></font>
AVPacket packet;<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    pCodecCtx-&gt;pix_fmt,<font></font>
    pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    PIX_FMT_RGB24,<font></font>
    SWS_BILINEAR,<font></font>
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span><font></font>
    );<font></font>
<font></font>
i=<span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
	<span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
    <font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">// Convert the image from its native format to RGB</span>
        sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
        <span class="hljs-comment">// Save the frame to disk</span>
        <span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
          SaveFrame(pFrameRGB, pCodecCtx-&gt;width, <font></font>
                    pCodecCtx-&gt;height, i);<font></font>
    }<font></font>
  }<font></font>
    <font></font>
  <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
  av_free_packet(&amp;packet);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複雑なことは何もありません</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）はパッケージを読み取り、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体に保存し</font><font style="vertical-align: inherit;">ます。パッケージの構造のみを配布することに注意してください。FFmpegは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet.dataが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指す内部データを提供</font><b><font style="vertical-align: inherit;">し</font></b><font style="vertical-align: inherit;">ます。これにより</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">少し後で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free_packet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）が</font><font style="vertical-align: inherit;">解放され</font><font style="vertical-align: inherit;">ます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）はパケットをフレームに変換します。ただし、パケットをデコードした後、フレームに必要なすべての情報がない</font><font style="vertical-align: inherit;">場合があるため、次のフレームがある場合</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">設定します</font><font style="vertical-align: inherit;">。最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）を使用して独自の形式から変換します（</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pCodecCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）RGBで。あなたがキャストできることを覚えておいてください</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVFrameの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にポインタを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVPictureの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタ</font><font style="vertical-align: inherit;">。最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数のフレーム、高さ、幅に関する情報を渡します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッケージと言えば。技術的には、パケットにはフレームの一部と他のデータビットのみを含めることができます。ただし、FFmpegパーサーは、受信したパケットに完全なフレームまたは複数のフレームが含まれていることを保証します。</font><b><font style="vertical-align: inherit;">あと</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">てRGB情報をPPMファイルに書き込むだけです。表面的にはPPMフォーマット自体を扱っていますが、私を信じて、すべてがここで動作します：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準的なファイルオープン等を行い、RGBデータを記録します。ファイルは1行ずつ書き込まれます。 PPMファイルは、RGB情報が長い行として表示されるファイルです。 HTMLの色がわかっている場合</font><font style="vertical-align: inherit;">は、赤い画面のように</font><font style="vertical-align: inherit;">、最初から最後まで各ピクセルの色をマークするようなもの</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><nobr><font style="vertical-align: inherit;">たとえば</font></nobr><font style="vertical-align: inherit;">、</font><nobr><font style="vertical-align: inherit;">＃ff0000＃ff0000 ....の</font></nobr><font style="vertical-align: inherit;">ようになります。 （実際には、セパレーターなしでバイナリ形式で保存されますが、お気づきでしょうか。）タイトルは、画像の幅と高さ、およびRGB値の最大サイズを示しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数に戻ります</font><font style="vertical-align: inherit;">。ビデオストリームからの読み取りが完了したらすぐに、すべてをクリアする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Free the RGB image</span><font></font>
av_free(buffer);<font></font>
av_free(pFrameRGB);<font></font>
<font></font>
<span class="hljs-comment">// Free the YUV frame</span><font></font>
av_free(pFrame);<font></font>
<font></font>
<span class="hljs-comment">// Close the codecs</span><font></font>
avcodec_close(pCodecCtx);<font></font>
avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
<span class="hljs-comment">// Close the video file</span><font></font>
avformat_close_input(&amp;pFormatCtx);<font></font>
<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、</font><b><font style="vertical-align: inherit;">avcode_alloc_frame</font></b><font style="vertical-align: inherit;">と</font><b><font style="vertical-align: inherit;">av_malloc</font></b><font style="vertical-align: inherit;">を使用して割り当てられたメモリに</font><font style="vertical-align: inherit;">は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
それがすべてのコードです！</font><font style="vertical-align: inherit;">Linuxまたは同様のプラットフォームを使用している場合は、次を実行します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lavutil -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古いバージョンのFFmpegを使用している場合は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-lavutil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を削除する必要がある場合があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lz -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどのグラフィックプログラムでは、PPM形式を開く必要があります。</font><font style="vertical-align: inherit;">スクリーンキャップが私たちのプログラムを使用して作られたいくつかの映画ファイルでそれをチェックしてください。</font></font><a name="outputting"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン2：画面の表示</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン1：スクリーンキャプチャの作成"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン3：サウンドを再生する"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリスト：tutorial02.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial02.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial02 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-keyword">float</span>           aspect_ratio;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
      <font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codec</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDLとビデオ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面での描画にはSDLを使用します。 SDLは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple Direct Layerの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">略です</font><font style="vertical-align: inherit;">。多くのプロジェクトで使用されている優れたクロスプラットフォームマルチメディアライブラリです。ライブラリは、公式Webサイトで入手するか、ご使用のオペレーティングシステムの開発者パッケージをダウンロードできます。このレッスンのコードをコンパイルするには、ライブラリが必要になります（ちなみに、これは他のすべてのレッスンにも当てはまります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDLには、画面に描画するための多くのメソッドがあります。映画を表示する1つの方法は、いわゆる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUVオーバーレイ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正式には、YUVではなく、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YCbCr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ちなみに、「YCbCr」を「YUV」と呼ぶと、やけどする人もいます。一般的に、YUVはアナログ形式で、YCbCrはデジタル形式です。 FFmpegとSDLのコードとマクロでは、YCbCrをYUVとして指定していますが、それはそうです。</font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、RGBなどの生の画像データを保存する方法です。大まかに言えば、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るさの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントで</font><font style="vertical-align: inherit;">あり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">色の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンポーネントです</font><font style="vertical-align: inherit;">。 （これは、色情報の一部が破棄されるため、RGBよりも複雑で</font><font style="vertical-align: inherit;">あり、</font><b><font style="vertical-align: inherit;">Yの</font></b><font style="vertical-align: inherit;"> 2つの測定ごと</font><font style="vertical-align: inherit;">に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">測定は1つしかありません</font><font style="vertical-align: inherit;">）。</font><b><font style="vertical-align: inherit;">YUVオーバーレイ</font></b></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDLでは、未加工のYUVデータセットを受け入れて表示します。 4種類のYUVフォーマットを受け入れますが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が最も高速です。</font><font style="vertical-align: inherit;">YV12と一致する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">呼ばれる別のYUVフォーマットがあり</font><font style="vertical-align: inherit;">ますが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列</font><font style="vertical-align: inherit;">が入れ替わっています。 420は、4：2：0の比率でサンプリングされることを意味します。つまり、輝度の4つの測定ごとに1つの色測定があるため、色情報は4分の1に分散されます。人間の目はまだこれらの変化に気付かないため、これは帯域幅を節約するための良い方法です。名前のラテン文字「P」は、形式が「平面」であることを示します。これは、コンポーネントが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">あることを意味します</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は別々の配列にあります。</font><font style="vertical-align: inherit;">FFmpegは画像を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">変換でき</font><font style="vertical-align: inherit;">ます。これは、多くのビデオストリームが既にこの形式で保存されているか、簡単に変換できるため、非常に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、現在の計画では</font><font style="vertical-align: inherit;">、前のレッスンの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数を置き換え、</font><font style="vertical-align: inherit;">代わりにフレームを表示します。</font><font style="vertical-align: inherit;">ただし、最初にSDLライブラリの基本機能を理解する必要があります。</font><font style="vertical-align: inherit;">開始するには、ライブラリを接続し、SDLを初期化します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は基本的に、使用する関数をライブラリに</font><b><font style="vertical-align: inherit;">通知し</font></b><font style="vertical-align: inherit;">ます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_GetError</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）、もちろん、これはデバッグに便利な関数です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディスプレイ作成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、要素を配置するための画面上の場所が必要です。</font><font style="vertical-align: inherit;">SDLで画像を表示するための主な領域は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれ</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface *screen;<font></font>
<font></font>
screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span>(!screen) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、指定された幅と高さで画面を設定します。</font><font style="vertical-align: inherit;">次のオプションは画面のビット深度です-0-これは「現在のディスプレイと同じ」を意味する特別な値です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、この画面に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUVオーバーレイ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作成して</font><font style="vertical-align: inherit;">ビデオを出力できるようにし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWSContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">構成して</font><font style="vertical-align: inherit;">画像データを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に変換し</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay     *bmp = <span class="hljs-literal">NULL</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SWSContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,<font></font>
                           SDL_YV12_OVERLAY, screen);<font></font>
<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
                         pCodecCtx-&gt;height,<font></font>
			 pCodecCtx-&gt;pix_fmt,<font></font>
			 pCodecCtx-&gt;width,<font></font>
			 pCodecCtx-&gt;height,<font></font>
			 PIX_FMT_YUV420P,<font></font>
			 SWS_BILINEAR,<font></font>
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>
			 );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のように、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して画像を表示し、</font><font style="vertical-align: inherit;">FFmpegから</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データを取得します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像表示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、それは十分に簡単でした！次に、画像を表示するだけです。撮影が終わったところまで行きましょう。 RGBフレームのすべてを取り除くことができるので、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）を表示コード</font><font style="vertical-align: inherit;">に置き換え</font><font style="vertical-align: inherit;">ます。画像を表示するには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造を作成</font><font style="vertical-align: inherit;">し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUVオーバーレイ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のデータポインターとラインサイズを設定します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
    SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
    AVPicture pict;<font></font>
    pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
    pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーバーレイに書き込む予定なので、最初はオーバーレイをブロックします。これは良い習慣なので、後で問題はありません。上記の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体</font><font style="vertical-align: inherit;">には、4つのポインターの配列であるデータポインターがあります。ここでは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を扱っている</font><b><font style="vertical-align: inherit;">ため</font></b><font style="vertical-align: inherit;">、チャネルが3つしかないため、データセットは3つしかありません。他の形式では、アルファチャネルまたは他の何かへの4番目のポインタが含まれる場合があります。ラインサイズはこんな感じです。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUVオーバーレイの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同様の構造は、</font><font style="vertical-align: inherit;">ピクセルと高さの変数です。 （ピッチ、ピッチ-特定のデータラインの幅を示すためにSDLで表現した場合。）したがって、</font><font style="vertical-align: inherit;">オーバーレイ上に</font><font style="vertical-align: inherit;">3つの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pict.data配列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を示す</font><font style="vertical-align: inherit;">ので、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、私たちは実際にオーバーレイに記録しています。もちろん、オーバーレイには特別に必要なスペースがすでに割り当てられています。</font><font style="vertical-align: inherit;">同様に、オーバーレイから直接ラインサイズ情報を取得します。</font><font style="vertical-align: inherit;">私たちは、への変換形式を変更</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIX_FMT_YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前のように。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像描画</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、SDLに指定したデータが実際に表示されるように、SDLを指定する必要があります。</font><font style="vertical-align: inherit;">また、この関数に四角形を渡します。これは、ムービーの移動先、拡大縮小する幅と高さを示します。</font><font style="vertical-align: inherit;">したがって、SDLは私たちのためにスケーリングし、これはGPUがより速くスケーリングするのに役立ちます。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect rect;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">/* ... code ... */</span>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
              pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでビデオが表示されました！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDLのもう1つの機能で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるイベントシステムについて説明します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 SDLは、SDLアプリケーションでマウスを入力または移動したり、SDLアプリケーションに信号を送信したりすると、イベントが生成されるように構成されます。プログラムは、ユーザー入力を処理することを目的としている場合、これらのイベントをチェックします。プログラムは、SDLイベントをシステムに送信するイベントを作成することもできます。これは、レッスン4で確認するSDLを使用したマルチスレッドプログラミングに特に役立ちます。このプログラムでは、パッケージの処理直後にイベントをチェックします。現時点では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベントを処理して</font><font style="vertical-align: inherit;">終了できる</font><b><font style="vertical-align: inherit;">ように</font></b><font style="vertical-align: inherit;">します。</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event       event;<font></font>
<font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして私たちは生きています！古いゴミをすべて取り除き、コンパイルする準備が整いました。 LinuxまたはLinuxのようなものを使用する場合、SDLライブラリを使用してコンパイルする最良の方法は次のとおりです。</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdl-config</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がSDLライブラリを正しく有効にする</font><font style="vertical-align: inherit;">ために必要なフラグを表示するだけ</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これをシステムでコンパイルするには、他のことをする必要があるかもしれません。</font><font style="vertical-align: inherit;">消防士については、システムのSDLドキュメントを確認してください。</font><font style="vertical-align: inherit;">コンパイルしたら、続行して実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプログラムを実行するとどうなりますか？</font><font style="vertical-align: inherit;">ビデオはおかしくなりそうです！</font><font style="vertical-align: inherit;">実際、すべてのビデオフレームを、ムービーファイルから抽出するのと同じ速さで表示するだけです。</font><font style="vertical-align: inherit;">現在、ビデオを表示する必要があるかどうかを調べるコードはありません。</font><font style="vertical-align: inherit;">最後に（レッスン5で）、ビデオの同期を開始します。</font><font style="vertical-align: inherit;">しかし、現時点では、同じくらい重要なもの、つまりサウンドが欠けています。</font></font><a name="sound"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン3：サウンドを再生</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン2：ディスプレイ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン4：複数のスレッド"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリスト：tutorial03.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial03.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial03 tutorial03.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial03 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
PacketQueue audioq;<font></font>
<font></font>
<span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf, <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>; <span class="hljs-comment">// arbitrary?</span>
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream, audioStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
  <font></font>
  AVCodecContext  *aCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *aCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *aCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
  SDL_AudioSpec   wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
    <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;<font></font>
  audioStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
      videoStream=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
      audioStream=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
  <span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
   <font></font>
  aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;<font></font>
  aCodec = avcodec_find_decoder(aCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!aCodec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
  wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
  wanted_spec.format = AUDIO_S16SYS;<font></font>
  wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
  wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
  wanted_spec.callback = audio_callback;<font></font>
  wanted_spec.userdata = aCodecCtx;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  <span class="hljs-comment">// audio_st = pFormatCtx-&gt;streams[index]</span><font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses	</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
	<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
	av_free_packet(&amp;packet);<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
      packet_queue_put(&amp;audioq, &amp;packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(&amp;packet);<font></font>
    }<font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(aCodecCtxOrig);<font></font>
  avcodec_close(aCodecCtx);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、アプリケーションでサウンドを再生します。</font><font style="vertical-align: inherit;">SDLは、サウンドを再生する方法も提供します。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数は</font><font style="vertical-align: inherit;">、オーディオデバイス自体を開くために使用されます。</font><font style="vertical-align: inherit;">これは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体を引数として取ります</font><font style="vertical-align: inherit;">。これには、再生するオーディオに関するすべての情報が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを構成する方法を示す前に、コンピューターがオーディオを一般的に処理する方法を最初に説明します。</font><font style="vertical-align: inherit;">デジタルオーディオは、</font><b><font style="vertical-align: inherit;">サンプルの</font></b><font style="vertical-align: inherit;">長いストリームで構成されてい</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それぞれが音波の特定の意味を表します。サウンドは、特定のサンプリングレートで記録されます。これは、各サンプルの再生速度を示し、1秒あたりのサンプル数で測定されます。おおよそのサンプリング周波数は</font><font style="vertical-align: inherit;">、毎秒</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22,050</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44,100</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サンプルで、それぞれラジオとCDで使用される速度です。さらに、ほとんどのオーディオはステレオまたはサラウンドサウンド用に複数のチャネルを持つことができるため、たとえば、サンプルがステレオの場合、サンプルは一度に2つになります。ムービーファイルからデータを取得する場合、取得するサンプル数はわかりませんが、FFmpegは壊れたサンプルを生成しません。これは、ステレオサンプルも分離しないことも意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDLでオーディオを再生する方法は次のとおりです。</font><font style="vertical-align: inherit;">サウンドパラメータが設定されています：サンプリング周波数、チャネル数など。</font><font style="vertical-align: inherit;">また、コールバック関数とユーザーデータを設定します。</font><font style="vertical-align: inherit;">サウンドの再生を開始すると、SDLは常にこのコールバック関数を呼び出し、オーディオバッファーを特定のバイト数で埋めるように要求します。</font><font style="vertical-align: inherit;">この情報を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体に入れ</font><b><font style="vertical-align: inherit;">たら</font></b><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。これにより、オーディオデバイスが開き、別の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造体が返され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これらは私たちが実際に使用する特性です-私たちが要求したものを正確に得るという保証はありません！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音声設定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオストリームに関する情報はまだないので、今は覚えておきましょう。</font><font style="vertical-align: inherit;">コード内でビデオストリームを見つけた場所に戻り、どのストリームがオーディオストリームであるかを確認します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;<font></font>
audioStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) {
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO<font></font>
     &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
    videoStream=i;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
     audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
    audioStream=i;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
<span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは</font><font style="vertical-align: inherit;">、ビデオストリームの場合と同様に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">必要なすべての情報を</font><font style="vertical-align: inherit;">ストリーム</font><font style="vertical-align: inherit;">から取得でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodecContext *aCodecCtxOrig;<font></font>
AVCodecContext *aCodecCtx;<font></font>
<font></font>
aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えていれば、以前のレッスンでは、オーディオコーデック自体を開く必要があります。</font><font style="vertical-align: inherit;">それは簡単です：</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec         *aCodec;<font></font>
<font></font>
aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(!aCodec) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">/* set up SDL Audio here */</span><font></font>
<font></font>
avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コーデックのコンテキストでは、オーディオを構成するために必要なすべての情報が含まれています。</font></font><br>
<br>
<pre><code class="cpp hljs">wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
wanted_spec.format = AUDIO_S16SYS;<font></font>
wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
wanted_spec.callback = audio_callback;<font></font>
wanted_spec.userdata = aCodecCtx;<font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各項目について見ていきましょう。</font></font><br>
<ul>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前に説明したように、</font><b><font style="vertical-align: inherit;">freq</font></b><font style="vertical-align: inherit;">（周波数）：サンプリングレート。</font></font></li>
<li><b>format</b> ():  SDL ,      . «<b>S</b>»  «<b>S16SYS</b>»  «», <b>16</b> ,      16 ,  «<b>SYS</b>» ,       ,    .  ,   <b>avcodec_decode_audio2</b>   .</li>
<li><b>channels</b> ():  .</li>
<li><b>silence</b> ():  ,  .   0.</li>
<li><b>samples</b> ():    ,    ,  SDL  ,     .    -  512  8192; FFplay,  ,  1024.</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバック</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（callback）：ここでは、実際のコールバック関数を渡します。</font><font style="vertical-align: inherit;">コールバック関数については後で詳しく説明します。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：SDLは、コールバックに必要なユーザーデータへのnullポインターを提供します。</font><font style="vertical-align: inherit;">私たちはコーデックのコンテキストについて彼に知らせたいと思います。</font><font style="vertical-align: inherit;">少し低いのは理由がはっきりします。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudioで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオを</font><b><font style="vertical-align: inherit;">開き</font></b><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キュー</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それは必要です！これで、ストリームからオーディオ情報を抽出する準備ができました。しかし、この情報をどうするか？ムービーファイルから継続的にパケットを受信しますが、同時にSDLがコールバック関数を呼び出します！解決策は、オーディオパケットを挿入できるなんらかのグローバル構造を作成して、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にオーディオデータを受信できるようにすることです。だから、これがパケットキューを作成するために何をするかです。 FFmpegには、これを支援するための構造さえあります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。AVPacketListは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、パッケージのリンクリストにすぎません。キューの構造は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_packetsの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイズが異なる</font><font style="vertical-align: inherit;">ことを示す必要があります。</font><font style="vertical-align: inherit;">サイズ</font><font style="vertical-align: inherit;">は、</font><b><font style="vertical-align: inherit;">packet- </font></b></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; size</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取得するバイトのサイズを指し</font><nobr><font style="vertical-align: inherit;">ます</font></nobr><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">mutexと条件変数があることに注意してください。</font><font style="vertical-align: inherit;">これは、SDLがオーディオプロセスを別のストリームとして実行するためです。</font><font style="vertical-align: inherit;">キューを適切にブロックしないと、実際にデータが破壊される可能性があります。</font><font style="vertical-align: inherit;">キューの実装方法を見てみましょう。</font><font style="vertical-align: inherit;">すべての自尊心のあるプログラマーは、キューの作成方法を知っている必要がありますが、SDL関数をより簡単に学習できるように、これを行う方法も示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、キューを初期化する関数を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、オブジェクトをキューに配置する関数を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_LockMutex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）はキュー内のミューテックスをブロックして何かを追加できるようにし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">は条件付き変数を介して</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数にシグナルを送信し</font><font style="vertical-align: inherit;">（必要な場合）、データがあり、継続できることを通知します。ミューテックスのロックを解除します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは対応する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これを行うように指示した場合、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）が関数ブロックを作成する（つまり、データを取得するまで一時停止する）</font><b><font style="vertical-align: inherit;">ことに</font></b><font style="vertical-align: inherit;">注意</font><font style="vertical-align: inherit;">してください。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span> </span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、関数は永遠のサイクルでラップされているため、ブロックしたい場合は確実にデータを取得します。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数を使用して永久にループすることは避けます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">基本的には、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が行うこと</font><font style="vertical-align: inherit;">は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）（または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondBroadcast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（））</font><font style="vertical-align: inherit;">からの信号を待ってから</font><font style="vertical-align: inherit;">続行することだけです。</font><font style="vertical-align: inherit;">ただし、mutexでキャッチしたように見えます。ロックを保持している場合、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">は何もキューに</font><b><font style="vertical-align: inherit;">入れる</font></b><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">ができません。</font><font style="vertical-align: inherit;">ただし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）が実行するのは、指定したミューテックスのブロックを解除し、シグナルを受信したらすぐに再度ロックすることです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての消防士のために</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また</font><font style="vertical-align: inherit;">、プログラムで出力信号を設定しなかったことを確認するためにチェック</font><font style="vertical-align: inherit;">するグローバル</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数があることもわかります</font><font style="vertical-align: inherit;">（SDLは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TERM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号</font><font style="vertical-align: inherit;">などを</font><font style="vertical-align: inherit;">自動的に処理します</font><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">そうでない場合、スレッドは永久に継続し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kill -9で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムを</font><b><font style="vertical-align: inherit;">強制</font></b><font style="vertical-align: inherit;">終了する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">  SDL_PollEvent(&amp;event);
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
    quit = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
終了フラグを1に設定します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">荷物を送る</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューを構成するだけです。</font></font><br>
<br>
<pre><code class="cpp hljs">PacketQueue audioq;<font></font>
main() {<font></font>
...<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は最終的にオーディオユニットを開始します。</font><font style="vertical-align: inherit;">データを受信しない場合、沈黙を再現します。</font><font style="vertical-align: inherit;">しかし、これはすぐには起こりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、キューが構成されました。これで、パケットを彼女に送信する準備が整いました。</font><font style="vertical-align: inherit;">パッケージの読み取りサイクルに進みます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
    <span class="hljs-comment">// Decode video frame</span><font></font>
    ....<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
    packet_queue_put(&amp;audioq, &amp;packet);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    av_free_packet(&amp;packet);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キューに入れた後のパッケージのリリースは行いませんのでご注意ください。</font><font style="vertical-align: inherit;">後で復号化するときに解放します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージの取得</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、最終的に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成して</font><font style="vertical-align: inherit;">、キューからパケットをフェッチします。</font><font style="vertical-align: inherit;">コールバックは次のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span></span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はSDLに与えたポインタ、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はオーディオデータを書き込むバッファ、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はこのバッファのサイズです。</font><font style="vertical-align: inherit;">これがコードです：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span><font></font>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf,<font></font>
                                      <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、これは、書き込んだ別の関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">からデータを抽出し</font><font style="vertical-align: inherit;">、結果を中間バッファーに保存し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイトをストリーム</font><font style="vertical-align: inherit;">に書き込もうとして、</font><font style="vertical-align: inherit;">まだ十分にない場合や後で使用するために保存する場合に、より多くのデータを受信</font><font style="vertical-align: inherit;">する単純なループです</font><font style="vertical-align: inherit;">。何か残っている場合。</font><font style="vertical-align: inherit;">大きさ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_bufは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> FFmpegのは私たちに良いマージンを与える、私たちを与えることを最大のオーディオフレームの1.5倍の大きさです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的なオーディオ復号化</font></font></h3><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
デコーダーの内部を見てみましょう</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf,
                       <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセス全体は、実際には関数の終わり近くで始まります。ここで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。キューからパケットを取り出し、そこから情報を保存します。次に、パッケージを機能させるとき、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_audio4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。これは、姉妹関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">と非常によく似て</font><font style="vertical-align: inherit;">いますが、この場合、パッケージには複数のフレームを</font><b><font style="vertical-align: inherit;">含める</font></b><font style="vertical-align: inherit;">ことができます。したがって、パケットからすべてのデータを取得するために、数回呼び出す必要がある場合があります。フレームを受け取ったら、単純にそれをオーディオバッファーにコピーし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_sizeが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーディオバッファーよりも小さくなるようにします。また、</font><b><font style="vertical-align: inherit;">audio_bufの</font></b><font style="vertical-align: inherit;">キャストについても覚えておいて</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ください。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDLは8ビットのintバッファーを提供し、FFmpegは16ビットのintバッファーでデータを提供するため、正しいタイプに変換されます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_sizeの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いも考慮する必要があり</font><font style="vertical-align: inherit;">ます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は使用したパッケージのサイズで、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は返される生データの量です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがある場合は、すぐに戻って、キューからさらにデータを取得する必要があるか、それとも完了したかを確認します。それでもパッケージを処理する必要がある場合は、それに固執します。パッケージが完成したら、最後にリリースします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれはすべてです！メインの読み取りループからキューにオーディオが転送され、</font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;">関数によって読み取られます</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、このデータをSDLに転送し、SDLはサウンドカードに転送します。先に進んでコンパイルします。</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial03 tutorial03.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ギップギップフーレー！</font><font style="vertical-align: inherit;">ビデオは引き続き最高速度で伝送されますが、サウンドはすでに正常に再生されています。</font><font style="vertical-align: inherit;">何故ですか？</font><font style="vertical-align: inherit;">はい、音声情報にはサンプリング周波数があります。音声情報はすぐに抽出されますが、音声はそのサンプリング周波数に従ってこのストリームで単純に再生されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビデオとオーディオの同期はほぼ完了していますが、最初にプログラムを少し再編成する必要があります。</font><font style="vertical-align: inherit;">サウンドをキューに入れ、別のストリームを使用して再生する方法は非常にうまく機能しました。これにより、コードの管理が容易になり、モジュール化されました。</font><font style="vertical-align: inherit;">ビデオとオーディオの同期を開始する前に、コードを簡略化する必要があります。</font><font style="vertical-align: inherit;">次のシリーズでは、制御フローを作成します！</font></font><a name="threads"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン4：複数のスレッド</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン3：サウンドを再生する"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン5：ビデオ同期"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリストtutorial04.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial04.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can,</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial04 tutorial04.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Now, normally here goes a ton of code
	 about timing, etc. we're just going to
	 guess at a delay for now. You can
	 increase and decrease this value and hard code
	 the timing - but I don't suggest that ;)
	 We'll learn how to do it for real later.
      */</span>
      schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }      <font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概観</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回、SDLオーディオ機能を使用したオーディオサポートを追加しました。</font><font style="vertical-align: inherit;">SDLは、サウンドが必要になるたびに定義した関数のコールバックを行うスレッドを起動しました。</font><font style="vertical-align: inherit;">次に、ビデオディスプレイについても同じようにします。</font><font style="vertical-align: inherit;">これにより、コードがよりモジュール化され、扱いやすくなります。特に、同期を追加したい場合はそうです。</font><font style="vertical-align: inherit;">では、どこから始めましょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メイン関数は多くの処理を行うことに注意してください。イベントループを通過し、パケットを読み取り、ビデオをデコードします。私たちがやろうとしていることは、すべてを部分に分割することです。パケットのデコードを担当するストリームがあります。次に、これらのパケットがキューに追加され、対応するオーディオおよびビデオストリームによって読み取られます。オーディオストリームは既に必要に応じて調整されています。ビデオストリームでは、ビデオが自分で表示されることを確認する必要があるため、少し難しくなります。メインループに実際の表示コードを追加します。ただし、ループを実行するたびにビデオを表示する代わりに、ビデオ表示をイベントループに統合します。アイデアは、ビデオをデコードし、受信したフレームを別のキューに保存してから、独自のイベント（</font><b><font style="vertical-align: inherit;">FF_REFRESH_EVENTを</font></b><font style="vertical-align: inherit;">作成すること</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、これをイベントシステムに追加すると、イベントループがこのイベントを検出すると、キュー内の次のフレームが表示されます。ここでは、何が起こっているかを示す便利なASCIIイラストを示します。</font></font><br>
<br>
<div style="text-align:center;"><img width="335" height="221" src="https://habrastorage.org/webt/nf/ej/gq/nfejgqoqpypds3quordh_x2qgwa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントループを介してビデオ表示制御を移動する主な理由は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font><font style="vertical-align: inherit;">を使用すると、次のビデオフレームが画面に表示されるタイミングを正確に制御できるためです。</font><font style="vertical-align: inherit;">次のレッスンで最終的にビデオを同期するときに、正しい画像が適切なタイミングで画面に表示されるように、次のビデオ更新をスケジュールするコードを追加するだけです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを簡略化する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを少しクリアしましょう。オーディオコーデックとビデオコーデックに関するこのすべての情報があり、キューとバッファーを追加します。神は他に何を知っているのでしょうか。これらすべてのものは、特定の論理ユニット、つまり-映画のためのものです。したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるこのすべての情報を含む大きな構造を作成するつもり</font><b><font style="vertical-align: inherit;">です</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、最終的に何が得られるかについてのヒントが表示されます。最初に、基本的な情報、つまり、オーディオとビデオのストリームのフォーマットとインデックスのコンテキスト、および対応する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを</font><b><font style="vertical-align: inherit;">確認し</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。次に、これらのオーディオバッファーの一部がこの構造に移動されていることがわかります。それら（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）は、まだ存在していた（または存在しなかった）オーディオに関する情報を目的としています。ビデオ用の別のキューと、デコードされたフレーム（オーバーレイとして保存された）用のバッファー（キューとして使用されます。このため、贅沢なキューは必要ありません）を追加しました。</font><b><font style="vertical-align: inherit;">VideoPictureの</font></b><font style="vertical-align: inherit;">構造</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-これは私たち自身の創造物です（私たちがそれに来るとき、私たちはそれに何が入るかを見ていきます）。また、作成する2つの追加のストリームにポインターを割り当て、さらに終了フラグとムービーファイル名を割り当てていることにも気づくでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、プログラムがどのように変化するかを確認するために、メイン関数に戻ります。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造を設定しましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_mallocz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は、メモリを割り当ててゼロにする優れた関数です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font><font style="vertical-align: inherit;">、イベントループが表示関数を呼び出すので</font><font style="vertical-align: inherit;">、表示バッファー（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）の</font><font style="vertical-align: inherit;">ロックを初期化します。</font><font style="vertical-align: inherit;">表示関数は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">からプリデコードされたフレームを取得することに</font><b><font style="vertical-align: inherit;">注意してください</font></b><font style="vertical-align: inherit;">。同時に、ビデオデコーダーが情報を入力します。誰が最初にそこに到達するかはわかりません。これは古典的なレースコンディションであることをご理解いただければ幸いです。そのため、トピックを開始する前に配布しています。ムービーの名前も</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoStateに</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コピーし</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
is-&gt;pictq_cond = SDL_CreateCond();</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_strlcpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はFFmpegの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数であり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">strncpyの</font></b><font style="vertical-align: inherit;">ほかに追加の境界チェックを実行し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの最初のスレッド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドを実行して、実際に何かをしてみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
<span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
  av_free(is);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、後で定義する関数です。彼女が行うことは</font><font style="vertical-align: inherit;">、指定されたミリ秒数の後に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を生成するようにシステムに指示すること</font><b><font style="vertical-align: inherit;">です</font></b><font style="vertical-align: inherit;">。これにより、イベントキューに表示されたときにビデオ更新関数が呼び出されます。しかし、今度は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）を</font><font style="vertical-align: inherit;">見てみましょう</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）はまさにそれを行います-それは元のプロセスのすべてのメモリへのフルアクセスを持つ新しいスレッドを生成し、与えた関数によって実行されるスレッドを開始します。この関数は、ユーザー定義データも送信します。この場合、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出して</font><font style="vertical-align: inherit;">、</font><b><font style="vertical-align: inherit;">VideoState</font></b><font style="vertical-align: inherit;">構造をアタッチします</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。関数の前半には新しいものはありません。ファイルを開いてオーディオストリームとビデオストリームのインデックスを見つけるだけです。唯一異なるのは、フォーマットコンテキストを大きな構造に保つことです。ストリームインデックスを見つけ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たら</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、定義する別の関数</font><b><font style="vertical-align: inherit;">stream_component_open</font></b><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。これはかなり自然に分離する方法であり、ビデオコーデックとオーディオコーデックを設定するために多くの同様のことを行うため、一部のコードを再利用して機能にします。</font><b><font style="vertical-align: inherit;">Stream_component_open</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）コーデックデコーダーを発見し、サウンドパラメーターを構成し、重要な情報を大きな構造に保存し、オーディオおよびビデオストリームを起動する場所です。ここでは、自動検出の代わりにコーデックを強制的に使用するなど、他のパラメーターも挿入します。このような：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx;<font></font>
  AVCodec *codec;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    <span class="hljs-comment">/* ...etc... */</span><font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;pix_fmt, is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、以前のコードとほとんど同じですが、オーディオとビデオ用に一般化されています。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aCodecCtxの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代わりに</font><font style="vertical-align: inherit;">、大きな構造をオーディオコールバックのユーザーデータとして構成した</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。また、ストリーム自体を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として保存し</font><b><font style="vertical-align: inherit;">ました</font></b><font style="vertical-align: inherit;">。ビデオキューも追加し、オーディオキューと同じように設定しました。一番下の行は、ビデオとオーディオのストリームを実行することです。これらのビットはこれを行います：</font></font><br>
<br>
<pre><code class="cpp hljs">    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
<span class="hljs-comment">/* ...... */</span><font></font>
<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前のレッスンの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）を</font><font style="vertical-align: inherit;">
思い出してください</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）も同様に使用されます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数に</font><b><font style="vertical-align: inherit;">戻り</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その前に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数の後半に戻り</font><b><font style="vertical-align: inherit;">ましょう</font></b><font style="vertical-align: inherit;">。基本的には、パッケージを読み取り、適切なキューに入れるのは単なるforループです。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>((is-&gt;pFormatCtx-&gt;pb-&gt;error) == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオとビデオのキューの最大サイズがあり、読み取りエラーチェックが追加されていることを除いて、ここには本当に新しいものはありません。フォーマットコンテキストには、</font><b><font style="vertical-align: inherit;">pb</font></b><font style="vertical-align: inherit;">と呼ばれる</font><font style="vertical-align: inherit;">内部に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造があり</font><font style="vertical-align: inherit;">ます。</font><b><font style="vertical-align: inherit;">ByteIOContext</font></b><font style="vertical-align: inherit;">は、基本的に低レベルファイルに関するすべての情報を格納する構造です。</font><font style="vertical-align: inherit;">
forループの後、残りのプログラムが完了するか、それを通知するのを待つすべてのコードがあります。このコードは、イベントをプッシュする方法を示しているため、有益です。ビデオを表示するために後で必要になります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL定数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、カスタムイベントの値を取得します</font><font style="vertical-align: inherit;">。最初のユーザーイベントは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、次の</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などに</font><font style="vertical-align: inherit;">設定する必要があります</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_QUIT_EVENTは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プログラムで</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として定義されています</font><font style="vertical-align: inherit;">。必要に応じてユーザーデータを渡すこともできます。ここでは、ポインターを大きな構造体に渡します。最後に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PushEvent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">を呼び出します</font><font style="vertical-align: inherit;">。イベントループスイッチでは、これを</font><b><font style="vertical-align: inherit;">SDL_QUIT_EVENT</font></b><font style="vertical-align: inherit;">セクションに配置するだけです。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前あったこと。</font><font style="vertical-align: inherit;">イベントのサイクルをさらに詳しく見ていきます。</font><font style="vertical-align: inherit;">今のところ、ちょうど私たちは時にあることを確認してください</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_QUIT_EVENTを押して</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、我々は、後でそれをキャッチして終了フラグを切り替えます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受信フレーム：video_thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コーデックを準備したら、ビデオストリームを開始できます。</font><font style="vertical-align: inherit;">このストリームは、ビデオキューからパケットを読み取り、ビデオをフレームにデコードして</font><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出して</font><font style="vertical-align: inherit;">、処理されたフレームを画像キューに配置します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_free(pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能のほとんどは、今では理解されているはずです。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">avcodec_decode_video2関数をコピーしまし</font><b><font style="vertical-align: inherit;">たが</font></b><font style="vertical-align: inherit;">、いくつかの引数を単に置き換えています。</font><font style="vertical-align: inherit;">たとえば、</font><font style="vertical-align: inherit;">大きな構造に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStreamが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格納されているので、そこからコーデックを取得します。</font><font style="vertical-align: inherit;">誰かが終了するように指示するか、エラーが見つかるまで、ビデオキューからパケットを受信し続けます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キューフレーム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デコードした</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を画像キューに</font><font style="vertical-align: inherit;">保存する関数を見てみましょう</font><font style="vertical-align: inherit;">。私たちの画像キューはSDLのオーバーレイであるため（おそらく、ビデオ表示機能ができるだけ少ない計算を実行できるようにするため）、フレームをそれに変換する必要があります。画像キューに保存するデータは、作成した構造です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの大きな構造には、これらのファイルを格納できるバッファが含まれています。</font><font style="vertical-align: inherit;">ただし、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Overlayを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分で</font><font style="vertical-align: inherit;">配布する必要があります</font><font style="vertical-align: inherit;">（割り当て済みのフラグに注意してください。割り当てられたフラグは、行ったかどうかを示します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このキューを使用するには、書き込みインデックスと読み取りインデックスの2つのポインターがあります。</font><font style="vertical-align: inherit;">また、バッファ内にある実際の画像の数も追跡します。</font><font style="vertical-align: inherit;">キューに書き込むには、まずバッファがクリアされるまで待機します。これにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を保存する場所が</font><b><font style="vertical-align: inherit;">でき</font></b><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、レコードインデックスにオーバーレイを設定したかどうかを確認します。</font><font style="vertical-align: inherit;">そうでない場合は、メモリを割り当てる必要があります。</font><font style="vertical-align: inherit;">ウィンドウサイズが変更された場合も、バッファを再割り当てする必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">
関数を見てみましょう</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
  vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;  <font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メインループからこのセクションに移動し</font><font style="vertical-align: inherit;">
た関数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateYUVOverlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を認識する必要があります</font><font style="vertical-align: inherit;">。このコードは、今ではかなり明確になっているはずです。ただし、2つのスレッドが同時に画面に情報を書き込むことができないため、ミューテックスロックが設定されています。これにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">が画像を表示する別の関数</font><b><font style="vertical-align: inherit;">に</font></b><font style="vertical-align: inherit;">干渉</font><font style="vertical-align: inherit;">することはありません</font><font style="vertical-align: inherit;">。 （このロックをグローバル変数として作成し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）;コードを参照）</font><font style="vertical-align: inherit;">で初期化しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ビデオのサイズが何らかの理由で変更されないことを確認する必要があるため</font><font style="vertical-align: inherit;">、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造で幅と高さを保持していることを思い出してください</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK、解決しました。オーバーレイ</font><b><font style="vertical-align: inherit;">YUV</font></b><font style="vertical-align: inherit;">があります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、専用であり、イメージを受信する準備ができています。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に戻り</font><font style="vertical-align: inherit;">、フレームをオーバーレイにコピーするコードを見てみ</font><font style="vertical-align: inherit;">ましょう</font><font style="vertical-align: inherit;">。この部分はおなじみのはずです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* Allocate a frame if we need it... */</span>
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、そのほとんどが、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オーバーレイに</font><font style="vertical-align: inherit;">フレーム</font><font style="vertical-align: inherit;">を設定するために以前に使用したコードにすぎません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後のビットは単にキューに値を「追加」します。</font><font style="vertical-align: inherit;">キューは機能し、値がいっぱいになるまでキューに追加され、少なくとも何かが入っている間にキューからの読み取りが発生します。</font><font style="vertical-align: inherit;">したがって、それはすべての値に依存し</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ている</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq_size</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを阻止するために私たちを必要とし、。</font><font style="vertical-align: inherit;">したがって、ここで何をしているのか：レコードポインターを増やし（必要に応じて最初からやり直し）、キューをブロックしてサイズを増やします。</font><font style="vertical-align: inherit;">これで、私たちのリーダーは、キューについてのより多くの情報があることを知っています。これによりキューがいっぱいになると、レコーダーはそれを知っています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオディスプレイ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでビデオスレッドは終了です。これで、1つを除いてすべての空きスレッドが完成しました-ずっと前に</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数を呼び出した方法を覚えていますか</font><font style="vertical-align: inherit;">？実際に何が起こったかを見てみましょう：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AddTimer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）は、特定のミリ秒後にユーザー定義関数へのコールバックを実行する（そして必要に応じて、ユーザー定義データを転送する）SDL関数です。この関数を使用してビデオの更新をスケジュールします-呼び出すたびに、イベントをトリガーするタイマーを設定します。これにより、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）関数がキュー画像からフレームを抽出して表示する関数を呼び出します彼女！ふew！ 3つの「どっちがどっちがどっち？それでは、まず最初に、このイベントを起動します。これは私たちを以下に送ります：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このイベントは私たちの旧友によって開始されました。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENTは、</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として定義されています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">0を返すと、SDLはタイマーを停止するため、コールバックは再度実行されないことに注意してください。</font><b><font style="vertical-align: inherit;">FF_REFRESH_EVENTを</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
再度</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">ので、イベントループで処理する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
  SDL_WaitEvent(&amp;event);<font></font>
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
    video_refresh_timer(event.user.data1);<font></font>
    <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数に私たちを送るもの、これは実際に画像キューからデータを抽出します：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Timing code goes here */</span><font></font>
<font></font>
      schedule_refresh(is, <span class="hljs-number">80</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、この関数は非常に単純です：何かがある間にキューを処理し、タイマーを設定して次のビデオフレームを表示し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">てビデオを画面に実際に表示し、キューのカウンターを増やし、サイズを減らします。</font><font style="vertical-align: inherit;">この関数</font><font style="vertical-align: inherit;">で</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vpを使用</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">て実際に何も実行していないことに気付くかもしれませんが、その</font><font style="vertical-align: inherit;">理由は次のとおりです。しかし、少し後で。ビデオとオーディオの同期を開始するときに、これを使用して時間情報にアクセスします。ここでは、「タイミングコードがここにくる」というコメントが書かれているコードの場所を見てみましょう。このセクションでは、次のビデオフレームを表示するまでの時間を調べ、この値を</font><b><font style="vertical-align: inherit;">schedule_refresh</font></b><font style="vertical-align: inherit;">関数に入力します。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。現時点では、架空の値として80を入力しています。技術的には、この値を推測して確認し、映画ごとに再コンパイルできますが、1）しばらくすると速度が低下し始め、2）かなり愚かです。ただし、将来的にはこの時点に戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あと少しで完了です。あと1つ、ビデオを見せてください。これが</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">です：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
画面は任意のサイズ（640x480をインストールし、ユーザーがサイズを変更できるように構成する方法があります）であるため、フィルムの長方形の領域の大きさを動的に決定する必要があります。したがって、最初に、幅を高さで割ったフィルムのアスペクト比を調べる必要があります。一部のコーデックは、サンプルの奇数のアスペクト比を持ちます。これは、単に1ピクセルまたはサンプルの幅/高さです。コーデックコンテキストの高さと幅の値はピクセル単位で測定されるため、実際のアスペクト比は、アスペクト比にサンプルのアスペクト比を掛けたものに等しくなります。一部のコーデックでは、アスペクト比が0と表示されます。これは、各ピクセルのサイズが単に1x1であることを意味します。次に、このような方法でフィルムをスケーリングします画面にできるだけ収まるようにします。ビット反転</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＆-3</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、値を最も近い4の倍数に丸めるだけです。</font><font style="vertical-align: inherit;">次に、ムービーを中央に配置し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SDL_DisplayYUVOverlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">て、スクリーンミューテックスを使用してアクセスすることを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれはすべてですか？</font><font style="vertical-align: inherit;">できましたか？</font><font style="vertical-align: inherit;">新しい</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> VideoStruct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用するには、引き続きオーディオ</font><b><font style="vertical-align: inherit;">コード</font></b><font style="vertical-align: inherit;">を書き換える必要があります</font><font style="vertical-align: inherit;">が、これらはサンプルコードで確認できる簡単な変更です。</font><font style="vertical-align: inherit;">最後に行う必要があるのは、FFmpegの内部exitコールバック関数のコールバックを変更することです。</font></font><br>
<br>
<pre><code class="cpp hljs">VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_interrupt_cb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">return</span> (global_video_state &amp;&amp; global_video_state-&gt;quit);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">global_video_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）の</font><font style="vertical-align: inherit;">大きな構造に</font><font style="vertical-align: inherit;">
設定し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで終わりです！</font><font style="vertical-align: inherit;">コンパイルします：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial04 tutorial04.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期せずに映画をお楽しみください！</font><font style="vertical-align: inherit;">次のステップでは、最終的に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際に機能する</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオプレーヤーを</font><font style="vertical-align: inherit;">作成します</font><font style="vertical-align: inherit;">。</font></font><a name="video"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レッスン5：ビデオ同期</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン4：複数のスレッド"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="目次へ"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" title="レッスン5：オーディオ同期"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なリストtutorial05.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;  
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドを書いたばかりのとき、同期コードはすべて、当時のバージョンの</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ffplay.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から取得されました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">今日、それは完全に異なるプログラムであり、FFmpegライブラリー（およびffplay.c自体）の更新により、根本的な変更が行われました。</font><font style="vertical-align: inherit;">このコードは引き続き機能しますが、すでに古くなっており、このガイドで使用できる他の多くの改善点があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビデオの同期方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今まで、ほとんど役に立たない映画プレーヤーがありました。</font><font style="vertical-align: inherit;">はい、ビデオを再生し、オーディオを再生しますが、これは私たちが映画と呼んでいるものではありません。</font><font style="vertical-align: inherit;">それでは、私たちは何をしますか？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTSおよびDTS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸いなことに、オーディオストリームとビデオストリームには、再生する必要がある速度とタイミングに関する情報が含まれています。オーディオストリームにはサンプリングレートがあり、ビデオストリームには1秒あたりのフレーム数があります。ただし、フレーム数をカウントしてフレームレートを乗算するだけでビデオを同期すると、サウンドと同期しない可能性が高くなります。したがって、私たちは別の方法で行きます。ストリームからのパケットは、いわゆる有することができ、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">復号化タイム</font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">スタンプ</font></i><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -から</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ecoding </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IME </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タンプ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プレゼンテーションタイム</font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">スタンプ</font></i><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -から</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resentation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IME </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タンプ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。これら2つの意味を理解するには、映画がどのように保存されているかを知る必要があります。 MPEGなどの一部の形式は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるものを使用します</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベッドおよび</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">双方向</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、イングランド。</font><i><font style="vertical-align: inherit;">双方向</font></i><font style="vertical-align: inherit;">）。フレームの二つの他のタイプと呼ばれる</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iで</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、及び</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手段</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予測</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pは</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redicted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">には画像全体が含まれます。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以前のIフレームとPフレームに依存し、以前のフレームとは異なります。または、名前を付けることもできます-デルタ。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bフレーム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はP </font><b><font style="vertical-align: inherit;">フレーム</font></b><font style="vertical-align: inherit;">に似ていますが、前のフレームと後続のフレームの両方に含まれている情報に依存します。フレームには画像自体が含まれていない可能性がありますが、他のフレームとの違いがあります</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出した後に完成したフレームがない場合がある理由を説明し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のシーケンスで4フレームの映画があるとします：</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IBBP</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。次に、前の2つのBフレームを表示する前に、最後のPフレームから情報を見つける必要があります。このため、フレームは実際の表示順序と一致しない順序で格納される可能性があります：</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPBB</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これが、各フレームのデコードタイムスタンプとプレゼンテーションタイムスタンプの目的です。デコードタイムスタンプは、何かをデコードする必要があるときに通知し、プレゼンテーションタイムスタンプは、何かを表示する必要があるときに通知します。したがって、この場合、ストリームは次のようになります</font><font style="vertical-align: inherit;">。PTS </font></font><br>
<br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 4 2 3 </font></font><br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 2 3 4 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPBB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、再生中のストリームにBフレームが含まれている場合のみ、PTSとDTSが異なります。</font><b><font style="vertical-align: inherit;">av_read_frame</font></b><font style="vertical-align: inherit;">（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
からパッケージを受け取ると、パッケージ</font><font style="vertical-align: inherit;">内の情報のPTS値とDTS値が含まれています。しかし、本当に必要なのは、新しくデコードされた生フレームのPTSです。この場合、いつ表示する必要があるかがわかります。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、FFmpegは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_frame_get_best_effort_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">関数を使用して取得できる「可能な限り最高のタイムスタンプ」を提供します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームを順番に表示するには、特定のビデオフレームを表示するタイミングを知っておくと便利です。</font><font style="vertical-align: inherit;">しかし、それをどのように正確に行うのでしょうか。</font><font style="vertical-align: inherit;">アイデアは次のとおりです。フレームを表示した後、次のフレームをいつ表示するかを決定します。</font><font style="vertical-align: inherit;">次に、一時停止します。その後、この期間の後にビデオを更新します。</font><font style="vertical-align: inherit;">予想どおり、システムクロックの次のフレームのPTS値をチェックして、待機時間がどれくらいになるかを確認します。</font><font style="vertical-align: inherit;">このアプローチは機能しますが、対処する必要のある2つの問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、問題は、次のPTSがいつになるかです。あなたは単に現在のPTSにビデオ周波数を追加することができると言うでしょう-そして、あなたは原則として正しいでしょう。ただし、一部の種類のビデオでは、繰り返しフレームが必要になります。つまり、現在のフレームを特定の回数繰り返す必要があります。これにより、プログラムが次のフレームを表示するのが早すぎる場合があります。これを考慮に入れる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つ目の問題は、現時点で作成したプログラムでは、ビデオとオーディオが同期するまでわずらわしく駆け上がることです。</font><font style="vertical-align: inherit;">すべてがそれ自体で完全に機能していれば、心配する必要はありません。</font><font style="vertical-align: inherit;">しかし、コンピュータは完璧ではなく、多くのビデオファイルもそうです。</font><font style="vertical-align: inherit;">したがって、3つのオプションがあります。オーディオをビデオと同期する、ビデオをオーディオと同期する、またはオーディオとビデオの両方を外部クロック（コンピューターなど）と同期する、です。</font><font style="vertical-align: inherit;">次に、ビデオをオーディオと同期させます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディング：PTSフレームの受信</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直接何かを書いてみましょう。大きな構造にさらにいくつかのパーツを追加する必要があり、必要な方法でそれを行います。まず、ビデオスレッドを見てみましょう。ここで、デコードストリームによってキューに入れられたパケットを収集することを覚えていますか？コードのこの部分では、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が提供したフレームのPTSを取得する必要があり</font><font style="vertical-align: inherit;">ます。最初に説明した方法は、最後に処理されたパケットのDTSを取得することです。これは非常に簡単です。</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// Decode video frame</span><font></font>
    len1 = avcodec_decode_video2(is-&gt;video_st-&gt;codec,<font></font>
                                pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-keyword">if</span>(packet-&gt;dts != AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を決定できない場合は、PTSをゼロに設定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、それは簡単でした。テクニカルノート：ご覧の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とおり</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PTSに</font><font style="vertical-align: inherit;">は</font><b><font style="vertical-align: inherit;">int64</font></b><font style="vertical-align: inherit;">を使用しています</font><font style="vertical-align: inherit;">。これは、PTSが整数として格納されるためです。この値は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timebbの</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間ディメンションに対応するタイムスタンプです</font><font style="vertical-align: inherit;">。たとえば、ストリームの1秒あたりのフレーム数が24の場合、42からのPTSは、フレームを42番目のフレームの場所に使用する必要があることを示します。実際には）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フレームレートで除算することにより、この値を秒に変換できます。</font><b><font style="vertical-align: inherit;">Time_base</font></b><font style="vertical-align: inherit;">値</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームは1をフレームレートで割った値（固定フレームレートのコンテンツの場合）に等しいため、PTSを秒単位で取得するには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を掛け</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらにコーディング：PTSの同期と使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、既製のPTSがすべて揃いました。</font><font style="vertical-align: inherit;">ここで、少し前に説明した2つの同期の問題に対処します。</font><font style="vertical-align: inherit;">すべてと同期するようにPTSを更新</font><font style="vertical-align: inherit;">する</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を定義</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">最後に、この関数は、フレームのPTS値を取得できない場合にも対応します。</font><font style="vertical-align: inherit;">同時に、リフレッシュレートを正しく設定できるように、次のフレームが予想されるタイミングを追跡する必要があります。</font><font style="vertical-align: inherit;">これ</font><font style="vertical-align: inherit;">は、ビデオの経過時間を追跡する</font><font style="vertical-align: inherit;">内部の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値を使用して行うことができます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この値を大きな構造に追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span>
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">// pts of last decoded frame / predicted pts of next decoded frame</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">かなり明確な</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
関数を次に示します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、この関数では繰り返しフレームを考慮しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、正しいPTSを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、新しい</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引数を追加して、</font><b><font style="vertical-align: inherit;">queue_picture</font></b><font style="vertical-align: inherit;">を使用してフレームをキューに入れ</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
で変更さ</font><b><font style="vertical-align: inherit;">れるの</font></b><font style="vertical-align: inherit;">は、この</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">をキューに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入れるVideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構造に</font><font style="vertical-align: inherit;">格納</font><font style="vertical-align: inherit;">することだけです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変数</font><font style="vertical-align: inherit;">を構造体に追加し、次のコード行を追加する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  ...<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
  ... stuff ...<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
    ... convert picture ...<font></font>
    vp-&gt;pts = pts;<font></font>
    ... alert <span class="hljs-built_in">queue</span> ...<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、画像が正しいPTS値でキューに入れられたので、ビデオ更新機能を見てみましょう。前回のレッスンから、単にそれを偽装し、80ミリ秒のアップデートをインストールしたことを思い出してください。さて、今、私たちは本当にそこにあるべきものを見つけようとしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの戦略は、現在の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と前の</font><b><font style="vertical-align: inherit;">ポイントの</font></b><font style="vertical-align: inherit;">間の時間を測定するだけで、次のPTSの時間を予測すること</font><font style="vertical-align: inherit;">です。同時に、ビデオとオーディオを同期させる必要があります。</font><b><font style="vertical-align: inherit;">オーディオ時計</font></b><font style="vertical-align: inherit;">を作り</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：再生中のオーディオの位置を追跡する内部値。これは、任意のmp3プレーヤーのデジタル表示のようなものです。ビデオとサウンドを同期するので、ビデオストリームはこの値を使用して、ビデオが遠すぎたり遅すぎたりするかどうかを調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後で実装に戻ります。次に、</font><b><font style="vertical-align: inherit;">get_audio_clock</font></b><font style="vertical-align: inherit;">関数があるとします。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにより、オーディオクロックの時間が得られます。この値を取得したらすぐに、ビデオとオーディオが同期していない場合はどうする必要がありますか？検索などで適切なパッケージにジャンプしようとするのは愚かなことです。代わりに、次の更新のために計算した値を調整するだけです。PTSがオーディオ時間より遅れている場合は、推定遅延を2倍にします。 PTSが再生時間より前に進んでいる場合は、できるだけ早く更新します。更新または遅延時間の構成が</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完了</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">したので、それをコンピューターのクロックと比較して、</font><b><font style="vertical-align: inherit;">frame_timerを</font></b><font style="vertical-align: inherit;">実行し</font><font style="vertical-align: inherit;">た</font><font style="vertical-align: inherit;">ままにし</font><font style="vertical-align: inherit;">ます。このフレームタイマーは、ムービー再生中のすべての推定遅延を要約します。つまり、この</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-次のフレームをいつ表示するかを示す時間です。フレームタイマーに新しい遅延を追加し、コンピューターの時計の時刻と比較し、この値を使用して次の更新を計画します。これは少し混乱する可能性があるので、コードを注意深く読んでください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのチェックを行います。最初に、現在のPTSと前のPTSの間の遅延が適切であることを確認します。遅延の必要がない場合、オーディオとビデオはこの時点でちょうど一致し、最後の遅延を使用します。次に、完全な同期が行われないため、同期しきい値が満たされていることを確認します。 FFplayは、しきい値として0.01の値を使用します。また、同期のしきい値がPTS値の間隔よりも小さくなることはありません。最後に、最小更新値を10ミリ秒に設定します（実際、ここではフレームをスキップする必要があるようですが、それについては心配しないでください）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きな構造に一連の変数を追加したので、コードを確認することを忘れないでください。</font><font style="vertical-align: inherit;">また、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_openで</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームタイマーと前のフレームの初期遅延を初期化することを忘れないでください</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同期：オーディオクロック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オーディオ時計を実現する時が来ました。</font><font style="vertical-align: inherit;">オーディオをデコードする</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">時間を更新でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">ここで、この関数を呼び出すたびに常に新しいパッケージを処理するわけではないので、時計を更新する必要のある領域が2つあることに注意してください。</font><font style="vertical-align: inherit;">最初の場所は、新しいパッケージを取得する場所です。PTSパッケージにサウンドクロックをインストールするだけです。</font><font style="vertical-align: inherit;">次に、パケットに複数のフレームがある場合、サンプル数をカウントし、それらに1秒あたりの所定のサンプリング周波数を乗算することで、オーディオ再生時間を節約します。</font><font style="vertical-align: inherit;">したがって、パッケージがある場合：</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、パッケージを処理するとすぐに：</font></font><br>
<br>
<pre><code class="cpp hljs">      <span class="hljs-comment">/* Keep audio_clock up-to-date */</span><font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかのマイナーなニュアンス：関数テンプレートが変更され、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が含まれるようになったので、必ず変更してください。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">オーディオパケットの</font><b><font style="vertical-align: inherit;">ptsを</font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に通知するために使用するポインターです</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは次回、オーディオとビデオを同期するために使用されます。</font><font style="vertical-align: inherit;">
これで、ようやく</font><b><font style="vertical-align: inherit;">get_audio_clock</font></b><font style="vertical-align: inherit;">関数を実装できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">考えてみれば</font><font style="vertical-align: inherit;">、値を取得すること</font><nobr><b><font style="vertical-align: inherit;">は</font></b></nobr><nobr><font style="vertical-align: inherit;"> -&gt; </font></nobr><nobr><b><font style="vertical-align: inherit;">audio_clock</font></b></nobr><font style="vertical-align: inherit;">ほど単純ではありません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">処理するたびにPTSオーディオを設定しますが、</font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;">関数を</font><b><font style="vertical-align: inherit;">確認</font></b><font style="vertical-align: inherit;">すると</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><nobr><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b></nobr><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてのデータをオーディオパケットから出力バッファーに移動するには時間がかかります。</font><font style="vertical-align: inherit;">これは、オーディオクロックの値が大幅に進んでいる可能性があることを意味します。</font><font style="vertical-align: inherit;">したがって、どれだけ書く必要があるかを確認する必要があります。</font><font style="vertical-align: inherit;">完全なコードは次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_st-&gt;codec-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数が機能する理由を理解する必要があります;）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、それだけです！</font><font style="vertical-align: inherit;">コンパイルします：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial05 tutorial05.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは起こった！</font><font style="vertical-align: inherit;">自作のプレーヤーで映画を見ることができます。</font><font style="vertical-align: inherit;">次のレッスンでは、オーディオの同期について説明し、検索方法を学習します。</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpegおよびSDLガイド、または1000行未満でビデオプレーヤーを作成する方法-パート2</font></font></a></h3><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エジソンブログの翻訳：</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/fr/yz/q7/fryzq72v0ik0irt2q4orchflxvs.jpeg"></a></td>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/jv/3k/-f/jv3k-f5vi9drztohsh-e0t-puru.jpeg"></a></td>
</tr>
<tr>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10億以上の収益を</font><font style="vertical-align: inherit;">誇るトップ50のゲームフランチャイズ</font></font></a></th>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Airbnbはコロナウイルスに耐えますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[ネタバレ：はい]</font></font></a></th>
</tr>
</tbody></table></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja500386/index.html">既存のビジネスソリューションをSwiftUIに適合させます。パート2</a></li>
<li><a href="../ja500390/index.html">ITおよびデジタル通信の分野における言語ローカリゼーションの実際のモデル。パート1</a></li>
<li><a href="../ja500396/index.html">自律アクセス制御システムの問題-彼らが予期していなかった場所</a></li>
<li><a href="../ja500398/index.html">リモートマラソンウィーク3：無効なプロセス</a></li>
<li><a href="../ja500400/index.html">スレッドのトリミング：Puppet EnterpriseからAnsible Towerへの移行。パート1</a></li>
<li><a href="../ja500404/index.html">エレクトロンとウェビックスの友達を作る方法。パート2.ビューでアプリケーションを作成する</a></li>
<li><a href="../ja500406/index.html">インターネットの最初の麻痺の物語：忙しい信号の呪い</a></li>
<li><a href="../ja500408/index.html">貧困における幸福</a></li>
<li><a href="../ja500410/index.html">バックラッシュの作成*</a></li>
<li><a href="../ja500414/index.html">3D CNCマシンまたはすべてがすでに私たちの前で行われています</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>