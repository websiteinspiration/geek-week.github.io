<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜ üîì ü•ì Adaptive Backlight for Raspberry Pi TV - Ambilight Analog üë®üèº‚Äçüîß ‚§µÔ∏è ü§≠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is a 50 ‚ÄùTV with 37 RGB dots of adaptive backlighting on the top and sides of the screen. How to make a similar adaptive backlight for any screen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Adaptive Backlight for Raspberry Pi TV - Ambilight Analog</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486106/"><img src="https://habrastorage.org/webt/4j/nf/9b/4jnf9b-q6d5nf1a1pf-0-svy-ss.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a 50 ‚ÄùTV with 37 RGB dots of adaptive backlighting on the top and sides of the screen. How to make a similar adaptive backlight for any screen or TV is a hackneyed topic, but quite relevant for a number of reasons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First of all, everything is changing. A couple of years ago there was no project working without software or hardware crutches. In any case, I have not seen such publications. Those that are described on the Internet are either lost relevance due to the obsolescence of software or hardware platforms, or they implement this technology only with respect to monitors connected to a PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, there are no and will not be Samsung, Sony, Elge and other TVs supporting this technology in the market, as it was patented by Philips for many years to come. </font><font style="vertical-align: inherit;">And finally, all the solutions ‚Äúout of the box‚Äù available on Ali and others like him have a number of limitations in the flexibility of settings and adaptation to the frame size of video content, color gamut adjustments, etc., being just a hardware crutch analyzing an external signal and working only on the formation of the backlight.</font></font><br>
<a name="habracut"></a><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Hardware" frame capture option</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you don‚Äôt talk about theoretical options for refinement and modernization of the television receiver itself, you must agree with the fact that in any case you will have to process the HDMI signal - i.e. It will be used for frame analysis and backlighting. Here, only two implementation options suggest themselves: with signal processing from any source (like lightpacks with Ali) and with the implementation of the source itself as a TV set-top box with adaptive backlighting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first case, we get some kind of versatility - you can connect a game console or some kind of player to the device. In the second - we collect this same "some kind of player" with a built-in backlight function. While experimenting, I implemented both options, but here I will focus only on the second, and here's why:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ke/9o/pk/ke9opk8wfmxy-breiickrsaoqsa.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the given block diagram of the first variant, the HDMI signal from any source comes to the splitter, where it is divided into two outputs. From the first, content is played on any TV receiver or monitor. From the second, the signal simultaneously enters the hardware scaler, where it is converted into an analog signal with low resolution frames - 320x480. An analog signal is sent to a hardware USB grabber, which takes ‚Äúscreenshots‚Äù of each frame and transfers them via USB to the input of a single-board mini PC - Raspberry Pi 3 B +. The software on raspberries analyzes frames using the Hyperion program and, through one of the GPIO outputs, provides control sequences to the input of an address tape like WS2812B or APA102. All this worked fine, but it has a couple of drawbacks in the form of a heap of iron with connections and a slight delay in issuing a backlight signal.The delay was noticeable only on test videos with a sharp change of colors in most of the frame. Otherwise, no complaints, except for the cost of all the iron in this implementation:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raspberry Pi 3 B + - about $ 55. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Radiator Case - $ 14. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Active HDMI 1080P splitter for 2 outputs - $ 15. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HDMI 1080P To AV Scaler - $ 15. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EasyCap USB grabber - $ 18. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Power supply - about $ 10. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
32GB microSD card - $ 10. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connecting cables and other small things - about $ 10. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Total, not counting the address tape - almost $ 150.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It‚Äôs not that such an option immediately into the furnace - it may well come in handy for organizing backlighting on some large prefabricated screens in advertisements or presentations, and the price is not the worst for the result - but for home use I settled on the second option - in Mostly ‚Äúsoftware‚Äù. </font><font style="vertical-align: inherit;">It came out easier, cheaper, more compact and faster. </font><font style="vertical-align: inherit;">For commercial use, it can also be quite suitable - the Raspberry Pi with the player can be successfully used in projects where you need to automatically play cyclically and seamlessly play some content from the moment you turn it on, turning off the player, again automatically - according to the schedule at the end of the day. </font><font style="vertical-align: inherit;">Having written a small script, we get an advertising device with the function of adaptive backlighting of any screens, at least ten-meter high. </font><font style="vertical-align: inherit;">But back to home use ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Software" option capture frames</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The functions of the media center and backlight control will remain behind the same Raspberry Pi 3 B +, and all connections will now be reduced to connecting several connectors - power, Internet, backlight and HDMI to TV. No more than any other TV set-top box: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/kv/oi/fn/kvoifnkm8v3zyluhrtwicjwi2dy.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Looking ahead, I want to note that the Raspberry Pi 3 B + turned out to be a very universal TV set-top box-media center with all the necessary capabilities of such a device, plus a flexibly customizable adaptive backlight for any modern (and not so) TV having an HDMI input. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The basis of the software is the open Libreelec OS, specially sharpened for the Kodi player. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The project site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contains all the necessary information.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
About the capabilities of one of the most powerful and flexible platforms for playing video-audio content, IPTV, etc. can be read by scoring in any search engine "kodi description of opportunities." There is a lot of information in Russian on this topic. I use, perhaps, 1/10 of all the platform features and this is enough for me. The platform is actively supported, has a responsive community. Therefore, we read, we study - on the wiki of these projects and on the forums there is almost all the necessary information and answers to questions. We take the distribution kit and installation and configuration instructions on the Libreelec project website. Since the OS is cross-platform, do not forget that our project is built on Raspberry.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Violating the strange, but well-established tradition of starting such publications with a description of the types of address tapes and how to clumsy stick them on the back walls of home TVs, I will start by installing and configuring single-board software. Unfortunately, making step-by-step instructions for setting up is almost impossible - it would take half a hundred pages of text without screenshots. In addition, the player‚Äôs platform is actively developing, OS and Kodi versions are changing, current information - it soon ceases to be so. Therefore, here are only the main points plus links to sources of useful information.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To configure the software part of the backlight, control the IR remote control and the player itself, you need to have an initial idea of ‚Äã‚Äãhow the Libreelec directories are arranged, how the local network works, the console, what to do with the command line, etc., as we will do some things in the process manually. Through the installers on the microSD card, only the Libreelec OS and the add-in for highlighting - Hyperion, will be installed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the Raspberry Pi does not have a built-in real-time clock, BIOS and backup power, all that is needed to work is located on the microSD card. To install the OS on the card, you must download either the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NOOBS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> package </font><font style="vertical-align: inherit;">from the Raspberry project website (at the time of installation I used build version 3.2.1) or a special tool - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúLibreELEC USB-SD Creator‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The memory card should have good read and write speeds - that is, be at least grade 10. In terms of volume, Libreelec OS takes up little space, 16GB cards will be quite enough for work, if there is no desire to purchase more volume. It can be used to store any content.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case of NOOBS, the contents of the zip archive are unpacked to the root of a microSD card formatted in FAT32, the card is inserted into the slot of de-energized raspberries, the power is turned on, and then, choosing the necessary OS in the installer and following the instructions, we deploy Libreelec. However, the platform developers recommend installing using LibreELEC USB-SD Creator, which itself downloads and writes the distribution package to the card, then the card is also inserted into the raspberry slot, where the installer deploys the OS after turning on the power. In this case, the sections of the card are reformatted, after which from under Windows you will not see the entire real volume of the media. If for any reason you need to return the partitions to their original state, you will first have to clean the card with the standard Windows utility - DiskPart,then, in the "Disk Management" section, create a new partition on the free space of the medium and format it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To simplify the installation and configuration of the OS, I temporarily connected a separate monitor and keyboard with a mouse to raspberries. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, to configure and configure raspberry software, you will need its connection with a PC and Internet access, preferably wired. The software installed on the PC for connecting via SSH - PuTTY and WinSCP, as well as the Java virtual machine (jre-8u231-windows-x64) and the Hyperion daemon configurator - HyperCon (HyperCon.jar). You can use another convenient file manager with panels, for example - Total Commander. Where to download and configure - a lot of information on specialized sites, it is enough to search for information with the search query "work with PUttY and WinSCP". The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hyperion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> project </font><font style="vertical-align: inherit;">also has its own forum and wiki.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this screenshot, there are three ways to connect raspberries to a PC under win via SSH - through the Putty console, WinSCP file manager and Total Commander: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/zf/1z/tr/zf1ztr1lhtkmv2zk7puaho32j70.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libreelec admin account by default has a username and password root @ libreelec, which are best changed for security reasons. After a successful installation in the system settings, we perform simple actions - turning on SSH, SMB, assigning a static IP, disabling updates: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/20/t4/mb/20t4mbajewvx41ryqyhpr0qbur0.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is assumed that raspberries are connected to your home network, and you can find out the IP address of the devices connected to it on your home PC. I turned off updates so that the once configured adaptive backlight system does not crash if the developer changes any of the related components in Libreelec.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the system settings in the services you need to enable SSH and enable password authentication, also set the minimum version of the SMB2 protocol, the maximum - SMB3. SMB is needed in order to see the Raspberry Pi directories and the flash drives connected to it from the PC: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/i_/pw/uv/i_pwuvdqiel5pcmrd0ghzegbwj8.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Under Windows 10 on the PC, you will have to find and enable SMB support in the settings, since it is disabled by default in it: We </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1x/ag/ba/1xagbapzp3y9_sgc7pev46llrwi.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
also search and add in the settings Russian keyboard layout. Nothing will happen to the physical keyboard - there will only be input in English, but in the virtual on-screen keyboard it will be possible to enter text in Russian. For convenient access to directories on a microSD card and flash drives connected to raspberries, you can create and place a shortcut with the address of the remote directory on the toolbar in Total Commander:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hb/9d/gi/hb9dgixgtpsa8ojxy7yo4wmfzno.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Files on the local network will be transferred at a speed limited by the bandwidth of your home router, and much faster than in access via SSH. In any case, copying a movie or music in this way will be more convenient than carrying a USB flash drive from a set-top box to a PC. You will see the internal directory structure in / storage on the raspberry card and the drives connected to the USB ports. With a wired connection, I have 100 Mbps. through the router, the maximum download speed of files from a PC to a USB drive in raspberries was about 12 MB / s, which roughly corresponds to the bandwidth of my wired connection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If necessary, in the future you can deploy to your PC any home media server (UPnP, DLNA) for streaming content directly from your PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After installing and configuring access to raspberries from a PC via SSH using the PUttY and WinSCP programs, you can proceed to install and configure the Hyperion daemon. There must be a Java virtual machine on the PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Everything will work something like this - at the start of Raspberry, a special program, Hyperion, will be launched in the background with Kodi in the background. </font><font style="vertical-align: inherit;">She will analyze all the video frames, and depending on the settings recorded in the configuration file - manage the address tape through one of the raspberry's GPIO outputs. </font><font style="vertical-align: inherit;">That is, after the settings, everything will work autonomously, no communication or interaction with the PC is required. </font><font style="vertical-align: inherit;">But to quickly create a configuration file and install Hyperion on raspberries, there is a convenient configurator that runs on a PC. </font><font style="vertical-align: inherit;">This program will help you quickly create a configuration file for the daemon to work, download and install it in Raspberry and check the system‚Äôs functionality using a convenient graphical interface.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hypercon</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The configurator is called HyperCon, it does not require installation, we just run the executable file HyperCon.jar on the PC and we see this window: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/qi/zx/v0qizxsds5ngp1pbclq8tf8waeq.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the right side there is a virtual screen for which the backlight will be adjusted - color capture zones, their numbering (starts from 0), direction, location padding, overlap and depth. </font><font style="vertical-align: inherit;">In the left part there are five tabs with settings. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Briefly on the tabs of the configurator: </font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hardware (hardware)</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">device -&gt; Configuration Name - any convenient name for the current configuration</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">device -&gt; Type - chip type of the address tape, module, or something else</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">device -&gt; Amount LEDs - number of addressable pixels (how many LEDs in the tape)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">device -&gt; RGB Byte order - colors in the protocol used</font></font></li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construction (arrangement of light sources)</font></font></b><br>
<br>
<ul>
<li> ‚Äì&gt; (led top left ) ‚Äî      </li>
<li>LEDs horizontal -&gt;      </li>
<li>LEDs Left-&gt;      </li>
<li>LEDs Right -&gt;      </li>
<li>Bottom gap -&gt;        (       )</li>
<li>1-st LED offset -&gt;          .</li>
</ul><br>
<b>Image process ( )</b><br>
<br>
<ul>
<li>Image process -&gt; Horizontal depth ‚Äì    , %</li>
<li>Image process -&gt; Vertical depth ‚Äì    , %</li>
<li>Image process -&gt; Horizontal gap ‚Äì      , %</li>
<li>Image process -&gt; Vertical gap ‚Äì      , %</li>
<li>Image process -&gt; Overlap ‚Äì   , %</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blackborder detection - Sensitivity and processing mode. </font><font style="vertical-align: inherit;">It works in theory like this - the demon analyzes the edges of the screen at the specified level and calculates the width of the dark edges to exclude from the processed zones. </font><font style="vertical-align: inherit;">This is for cases when a widescreen picture is played. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process (frame processing)</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothing -&gt; Enabled (check box to enable anti-aliasing)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothing -&gt; Type</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothing -&gt; Time</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothing -&gt; Update freq (refresh rate)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Smoothing -&gt; Update delay (delay before updating the frame)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Color calibration - intuitive items that allow you to set the minimum and maximum glow level, saturation, temperature, background glow level without signal, separately for each of the 3 primary colors.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The marked checkbox Send Continuous allows you to see changes in the configuration process already on the assembled structure. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabber (Grabber - frame grabber, the most interesting tab)</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber (Software grabber)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber-&gt; Enabled (checkbox for enabling internal grabber)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber-&gt; Width</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber-&gt; Heigth (zone height)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber-&gt; Interval</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Internal Frame grabber-&gt; Priority Channel (priority of this channel)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some clarifications are needed here. </font><font style="vertical-align: inherit;">The trick is that we are making a media player based on the Raspberry Pi, which will itself play content from the local network, flash drive, or IP TV on the LibreElec platform. </font><font style="vertical-align: inherit;">Since the content is already spinning with the raspberry player, the capture will occur programmatically, without an external EasyCap grabber, and the demon will deal with the frames itself, since in this case the signal source will be the HDMI output of the Raspberry Pi itself. </font><font style="vertical-align: inherit;">It is possible to use the same external grabber for another source, without disconnecting the internal one - channel priorities are provided for this, this is the last item to configure the software grabber. </font><font style="vertical-align: inherit;">The higher the number, the lower the priority of the channel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exactly so, there is no mistake.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grabber V4L2 (Hardware Grabber Driver Settings))</font></font></li>
<li>Grabber V4L -&gt; Device ( USB ,     ‚Äî /dev/video0  )</li>
<li>Grabber V4L -&gt; Input (   ‚Äî 0  )</li>
<li>Grabber V4L -&gt; Width (  ‚Äî -1  )</li>
<li>Grabber V4L -&gt; Heigth (  ‚Äî -1  )</li>
<li>Grabber V4L -&gt; Frame decimation ( )</li>
<li>Grabber V4L -&gt; Size decimation ( )</li>
<li>Grabber V4L -&gt; Priority Channel (  )</li>
<li>Grabber V4L -&gt; 3D mode (  2D/3D)</li>
<li>Grabber V4L -&gt; Crop Left (  )</li>
<li>Grabber V4L -&gt; Crop Right (  )</li>
<li>Grabber V4L -&gt; Crop Top (  )</li>
<li>Grabber V4L -&gt; Crop Bottom (  )</li>
<li>Grabber V4L -&gt;    (    )</li>
</ul><br>
<b>External ( )</b><br>
<br>
<ul>
<li>External -&gt; Kodi Checker (   Kodi,       .           .   ,        ,      )</li>
<li>External -&gt; Json/Proto/Boblight Server (  ,    )</li>
<li>External -&gt; Booteffect / Static color ( -   )</li>
<li>External -&gt; Json/Proto Forvard (  ,    )</li>
</ul><br>
<b>SSH (    Raspberry Pi)</b><br>
<ul>
<li>SSH ‚Äì Connection -&gt; System ( ,   Raspberry Pi)</li>
<li>SSH ‚Äì Connection -&gt; Target IP (IP  Raspberry Pi)</li>
<li>SSH ‚Äì Connection -&gt; Port (   ‚Äî (22))</li>
<li>SSH ‚Äì Connection -&gt; Username/password ( ‚Äì ,   Raspberry Pi)</li>
<li>SSH ‚Äì Connection -&gt; Connect/Disconnect ( -  Raspberry Pi)</li>
<li>SSH ‚Äì Connection -&gt; Show Traffic (     )</li>
<li>SSH ‚Äì Manage Hyperion from HyperCon -&gt; Inst/Upd. Hyperion (    Raspberry Pi     .  sudo get-install,   Raspberry Pi,       HyperCon-)</li>
<li>SSH ‚Äì Manage Hyperion from HyperCon -&gt; Remove Hyperion (  )</li>
<li> SSH ‚Äì Manage Hyperion from HyperCon -&gt; Start/Stop ( - )</li>
<li>SSH ‚Äì Manage Hyperion from HyperCon -&gt; Get Log (    ,  </li>
<li>      )</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSH - Send Hyperion Configuration -&gt; Local Config Path (Send the configuration file to the specified local location on the PC)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSH - Send Hyperion Configuration -&gt; Send Config (Send configuration file via SSH to Raspberry Pi)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSH - Colorpicker (an intuitive palette tester - you can check the output of all colors.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The buttons under the tabs save-load the settings of HyperCon (not the daemon configuration file itself !!)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HELP is understandable, and Create Hyperion Configuration allows you to locally save the daemon config file for Raspberry Pi itself - hyperion.config.json</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see from the list above, there are a lot of customization options, and this makes the tool very flexible for any Wishlist and tasks. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an example, my tab configuration:</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/-z/qg/7g/-zqg7gpc15imlq10asidggqma9q.jpeg" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/9a/xv/i6/9axvi6bpicrucblyzxu8b-qhntm.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first tab, we arrange the zones so that the backlight pixels on the back of the TV will be physically located. You can fill in the entire perimeter or part of it, set the direction, beginning, etc. The type of tape I used is WS2812B, so in the screenshot the corresponding field is selected as WS281x. The number of pixels I determined the density of LEDs on the available tape and the diagonal of the screen. The remaining tabs are as described above, and in the most recent one, we select our OS on the Raspberry Pi, configure communication via SSH and install the Hyperion daemon on a single board. Then we save the HyperCon config, create a new Hyperion configuration file, send the created config to the Raspberry Pi, start and try using ColorPicker to check the color palette. If everything matches,any content played by the Kodi player will control the backlight. The GPIO signal output is 18 (physical pin of the comb is 12).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Details of all connections will be described below, after a description of all program settings. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I did not configure startup, the daemon starts at the same time as the player starts. However, it was so that the backlight still did not turn on. Then we try to check whether the autostart of the daemon is registered in "/storage/.config/ autostart.sh" and try to reinstall the daemon in order to send its config to Raspberry Pi again. The program itself sends the config to the </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Raspberry Pi </font><font style="vertical-align: inherit;">directory </font><font style="vertical-align: inherit;">- </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äú/storage/.config/ hyperion.config.json‚Äù. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can check the daemon‚Äôs operation by sending a color on the SSH HyperCon tab, checking the ‚ÄúAutoupdate‚Äù checkbox and clicking the stop-start button to restart it. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the daemon does not start after rebooting the Raspberry Pi, try changing the auto start in the file</font></font><br>
<br>
<pre><code class="plaintext hljs">/storage/.config/autostart.sh<font></font>
//---------------------------------------------------------------------------------------------------------------<font></font>
#!/bin/sh<font></font>
sleep 5<font></font>
/storage/hyperion/bin/hyperiond.sh /storage/.config/hyperion.config.json &gt; /storage/logfiles/hyperion.log 2&gt;&amp;1<font></font>
//---------------------------------------------------------------------------------------------------------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
thereby delaying the execution of the daemon.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remote control by any IR remote control</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since in addition to the backlight, the prefix will be a full-fledged media center - you need to fasten and configure the remote control to it. </font><font style="vertical-align: inherit;">If your TV supports CEC technology (Consumer Electronics Control, i.e. the control protocol via HDMI), you can configure and use Kodi‚Äôs existing remote control with the TV to control the set-top box. Since all manufacturers call this protocol differently in their TVs , (for example, LG - SimpLink, Samsung -Anynet, Sony - BRAVIA Sync), look in your TV settings for support for this function. I do not have a very good remote control for TV, so I went the other way - took the one that was with the old TV set-top box on android (while other ordered remotes for this project are coming from China):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ss/ey/-r/ssey-rwucyrk5mpufui4mhnq4uo.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the Raspberry comb, you will need + 5V pins, ground and signal on GPIO23 (physical pin - 16), since GPIO18 (physical pin - 12), which is configured for IR devices by default - is already busy outputting packets to the backlight. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process:</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
To connect the driver of the IR receiver, edit the file /flash/config.txt, at the very end of which we write the line (here and below without quotes): </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äúdtoverlay = gpio-ir, gpio_pin = 23‚Äù </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connecting the IR receiver to raspberries, you need get scan codes of the remote control buttons we need and attach commands to them. After determining the protocol type in the console with the ir-keytable command, we attach the scan codes to the commands received in the console using </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
irrecord -l | grep ^ KEY ", manually do the mappings and create a table of this kind: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
table ireltex, type: NEC</font></font><br>
<br>
<pre><code class="plaintext hljs">0x8f64d KEY_0<font></font>
0x8f642 KEY_1<font></font>
0x8f641 KEY_2<font></font>
0x8f640 KEY_3<font></font>
0x8f646 KEY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And so - all the buttons and commands we need. I got 34 lines of matches. The first line is the name of the table and the remote control protocol. The following lines are the button scan code on the left. On the right, separated by a space, is the Kodi control command. And so on, in order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The table must be kept. To do this, a file is created (I called it ireltex) from which these bindings will be read. The file must be placed in the folder ‚Äú/storage/.config/rc_keymaps/ireltex‚Äù, then we create the file </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äú/storage/.config/rc_maps.cfg‚Äù, in it we write the line: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äú* * ireltex‚Äù (ess, but without quotes) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the Putty console, load the resulting table into the driver: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äúir-keytable -c -w /storage/.config/rc_keymaps/ireltex‚Äù, reboot the Raspberry Pi and change the last line in the file </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äú/flash/config.txt‚Äù</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now it looks like this: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äúdtoverlay = gpio-ir, gpio_pin = 23, rc-map-name = ireltex‚Äù </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the file </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Äú/storage/.config/autostart.sh‚Äù you need to add the autoload of the remote control protocol so that the record looks like this (for of my remote control and its protocol):</font></font><br>
<br>
<pre><code class="plaintext hljs">#!/bin/sh<font></font>
(<font></font>
sleep 5<font></font>
ir-keytable -p nec<font></font>
)&amp;<font></font>
sleep 5<font></font>
/storage/hyperion/bin/hyperiond.sh /storage/.config/hyperion.config.json &gt; /storage/logfiles/hyperion.log 2&gt;&amp;1 &amp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I reboot the Raspberry Pi again and now Kodi responds to commands from the remote. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The entire setup process with examples in the original is described in more detail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also type in the search engine the query ‚ÄúLibreElec + IR Remote‚Äù and get several articles on this topic in Russian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you hang the output of the IR receiver except GPIO 23 as well on the GPIO3 input - the Raspberry Pi will turn on by command from the remote control. The disadvantage of this control method is that the turn-on signal will be received by anyone from any IR remote control, but I have not found other ways to remotely turn on raspberries. So you need to make an additional detector that takes one command and transmits only this signal to the GPIO3 Raspberry Pi input.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to avoid miracles with spontaneous random flickering of pixels, the ground of the tape, in addition to the GND GPIO pin, must be connected directly to the negative terminal of the external power supply with a wire corresponding to the current cross section, and the D-IN signal wire should be of a minimum length. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It must be remembered that different IR receivers may have different supply voltages (3.3 or 5V) and pin assignments. </font><font style="vertical-align: inherit;">In order not to damage the receiver or the Raspberry Pi ports, the connection must be done in accordance with the documentation for the receiver used! </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, so far all the connections on the GPIO Raspberry Pi pins look like this:</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/kp/za/pg/kpzapg9cddh4qk2uyl_eut2qiqe.jpeg" alt="image"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Correct inclusion of the Raspberry Pi with IR remote control</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you need to do exactly the ‚Äúcorrect‚Äù inclusion of the Raspberry Pi from the assigned button on the IR remote control. Now the device boots up when any signal arrives at the GPIO3 pin (fifth physical pin), and since the receiver does not care what to receive in this IR range, the download comes from a signal from any remote control, sometimes even when the lights are turned on in the room, which is not convenient . To solve this problem, between the GPIO3 and the signal pin of the IR receiver, you need an intermediary who will decode the signal, and only if the command matches the previously assigned one, turn on the Raspberry Pi. In addition, you need to be able to use different remotes or the buttons of one remote. Of course, you can write firmware for any ATiny worth half a dollar rubles and everything will work fine,but since we are talking about a repeatable and simple constructor, it‚Äôs much easier to use the relatively inexpensive and compact controller - Arduino Nano. The board will constantly work in standby mode, monitoring all incoming signals from any IR sources. And only when decoding one of the predefined signals - give a command to turn on the Raspberry Pi. The controller will also provide a simple flashing if you need to change the remote control for the Raspberry Pi.The controller will also provide a simple flashing if you need to change the remote control for the Raspberry Pi.The controller will also provide a simple flashing if you need to change the remote control for the Raspberry Pi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arduino Nano will be powered not quite standard - from pin + 5V GPIO RPi - to pin + 5V Arduino. There is nothing wrong with this inclusion - on the USB side, the Arduino board will have an input of the internal stabilizer, on the Vin pin side, the Schottky diode cathode. No load other than the IR receiver will not be connected to the Arduino nano pins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Arduino-Raspberry connection table will be as follows - Raspberri Pi 3 B + physical output / Arduino Nano </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4 (+ 5v) / + 5V </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6 </font><font style="vertical-align: inherit;">physical output </font><font style="vertical-align: inherit;">(GND) / GND </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5 (GPIO3) / D8</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the IR receiver will connect to the power pins on the Arduino board - (GND, + 5V or 3.3V), and the output signal through the 100R resistors to the D7 Arduino pin and through 510R to pin 16 (GPIO23) of the Raspberry Pi. Thus, the IR receiver will directly transmit all the commands to the GPIO23 input, and one or two short pulses will appear on the GPIO3 only upon receipt of the commands predefined in the sketch. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection diagram of IR receiver, Arduino nano and address tape to Raspberry Pi:</font></font></b><br>
<br>
<img src="https://habrastorage.org/webt/vp/5s/pw/vp5spwaetjtos-vxrzn3qjvxqhg.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The top jumper ‚Äú5V External‚Äù allows Arduino and Raspberry to be powered by an external power source, along with the backlight from the XS1 ‚ÄúPower‚Äù connector, if, for example, the number of pixels is small and does not create a large load. By the lower jumper according to the scheme, the voltage of the IR receiver can be selected - 3.3 or 5V. The device will be designed as an external shield connected to the GPIO connector, into which the Arduino nano board, IR receiver and all connectors are connected.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To check, it is enough to first read and enter into the sketch the codes of any buttons, for example ‚ÄúOK‚Äù or ‚ÄúENTER‚Äù, from any remote controls. You can also make an array of commands to launch the console by pressing any of a specific group of buttons or a sequence of keystrokes. The sketch uses the iarduino_IR-master library, the archive of which can be easily found on the Internet. There are sketch examples in the library archive, using one of them, for example receiver_GetProtokolAll, you can get command codes for any buttons on the remote control used. Subsequently, these codes need to be written into the sketch poured onto the Arduino Nano:</font></font><br>
<br>
<pre><code class="plaintext hljs">//*******************************************************************************<font></font>
#include &lt;iarduino_IR_RX.h&gt;  //      -<font></font>
iarduino_IR_RX IR(7);  //   IR,       -<font></font>
const int Out_GPOI_3 = 8;  //     GPIO RPi<font></font>
uint32_t Code_001 = 0xFF708F;  // RX code   <font></font>
uint32_t Code_002 = 0x106FA857;<font></font>
void setup()<font></font>
{<font></font>
  pinMode(Out_GPOI_3, OUTPUT);<font></font>
//        9600 /<font></font>
 Serial.begin(9600);<font></font>
  IR.begin(); //    -<font></font>
}<font></font>
void loop()<font></font>
{<font></font>
  if(IR.check()) //        <font></font>
   {      <font></font>
      //     ,  <font></font>
      if(IR.data == Code_001 or IR.data == Code_002)<font></font>
        {<font></font>
          digitalWrite(Out_GPOI_3, HIGH);       //    RPi<font></font>
          delay(5);<font></font>
          digitalWrite(Out_GPOI_3, LOW);        //     <font></font>
          delay(5);<font></font>
          digitalWrite(Out_GPOI_3, HIGH);       //    RPi<font></font>
          delay(5);<font></font>
          digitalWrite(Out_GPOI_3, LOW);        //     <font></font>
          delay(5);<font></font>
        }<font></font>
   }<font></font>
}<font></font>
//*******************************************************************************<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the iarduino_IR-master library uses the same timer as some standard ‚Äúwiring‚Äù functions of the Arduino environment, you cannot use micros (), millis (), tone (), and possibly some others in this sketch, otherwise an attempt to compile will lead to an indistinct error. Despite this approach of authors to writing code, the library regularly performs its functions and clearly defines the IR messages, their timings, structure and protocols used, and the ability to quickly read the codes of commands of any console reduces its configuration to a simple replacement of variables in the sketch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The whole superstructure was designed as a shield, for which the following factory boards were drawn and ordered in China:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/14/t2/no/14t2noezfi1ifwtddtytirdv4_q.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This shield connects an Arduino nano board, a connector for one 5V common power supply, a TV backlight connector, and the shield itself is included in the GPIO Raspberry Pi comb. After assembling all the components, it looks like this: I </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ei/g_/jg/eig_jgo2k6pfzip-9zqljflkh4y.jpeg" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/ot/xq/qm/otxqqmw_e6ldd9gfir1s-oua9go.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
planned to make a corner acrylic translucent cover on the holes provided for mounting the racks - but somehow my hands didn‚Äôt reach, and I still can‚Äôt see the set-top box ... A </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
lot has been written about the choice and sticking of the address tape, however, I also have a few comments on this topic and editing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First about myths. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"WS2812 is not suitable for adaptive backlighting, you need to use SK9822 or even APA102"</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
They justify this by the fact that the data transfer frequency of APA102 analogs is much higher due to the presence of a clock line, and the LEDs themselves have a wider color gamut and are more reliable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All this is true, but if we divide the working frequency of WS2812B by the number of pixels and 32 bits of information for each of them, we get an update frequency of almost 300 Hz for my 91 LEDs. This is several times higher than the required threshold. And all the ‚Äúflicker‚Äù and ‚Äúidle‚Äù cases - 146% are the result of the curve of the wiring of the earth and the signal wire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The color scheme is similar - Hyperion generates 8-bit packages for each color in each pixel. In any case, this is only 256 gradations of brightness of each of the three colors on any tape. The difference in colors will be noticeable only in the calculator on the screen of a good monitor, but the difference in the real glow by ¬± one or even several gradations our eyes will not see in any case - this is the anatomy of our vision and there is nothing we can do about it. In addition, the configurator has tools for adjusting the color gamut - if you wish, you can achieve almost perfect white color at close to maximum brightness. But even these gestures are unlikely to be needed - the backlight only creates the background on the wall behind the TV, and not the picture on the screen ... When analyzing the capture zones - both Hyperion and Philips take more than one specific point,and the average color of the entire specified area, so the shades will always be something different from those that are reproduced in dynamics at the edges of the screen. Given all this, there‚Äôs no point in shooting from a cannon at sparrows, which actually confirms the backlight design in the original Phillips TVs, where only 37 points are displayed on the 50 ‚Äùdiagonal and the width of the zones is 5-6 cm.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another myth - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"WS2812B is short-lived, a month later the pixels began to fail."</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturally, they will begin. Moreover, on any tape. Each color in each 2812B LED at full brightness consumes 18-20 mA. For example, I have 91 LEDs. 91X3X20 = ‚Äã‚Äã5.5A. Efficiency is about 30-40%, which means that more than three amperes go into heat. The only effective way to remove heat from the crystal substrates is through the copper tracks of the tape, which is glued to some surface. Connected to power, but the non-luminous tape is also noticeably warm - the chips themselves in static have some current consumption. The back plastic cover of the TV is not the best heat sink for long-term operation of the tape, so it is better and more correct to use a special metal profile. In addition, it comes with a diffuser of various depths, widths and shapes. You will not see reflections in the form of colored dots on the glossy surfaces of the room‚Äôs interior,which is also sometimes important.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qz/oi/yz/qzoiyz8dnluqtmxs1mluj3drfgs.jpeg" alt="image"><br>
<br>
<img src="https://habrastorage.org/webt/tj/yu/ah/tjyuahucfrbsijm6atc2v8nlroe.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When everything is mounted, connected and checked - it remains to configure the KODI player to your taste and color - install all the necessary add-ons, IPTV with program programs and share content from your home PC.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we compare the backlighting with the hardware version - the reaction to the processing of frames seemed more clear to me - there is no sensation of a slight delay in a split second. The implementation itself seems to me quite viable - it turned out to be a simple repeatable constructor assembled by the plug-in principle. If you take care of assembling the switching shield and saving the configured system as an image, it will take no more time to launch another such set-top box than for any ‚Äúboxed‚Äù TV box on android. If you make the IR receiver remote - the device can be hidden behind a TV with a wall mount option. If you have a configured OS or its image, the system will work in full mode the first time you turn it on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For those who watch TV channels, you will have to tinker with their paid and high-quality or free and non-working IPTV playlists, TV programs for channels, add-ons and player settings, which, by the way, has the ability to change skins, of which at the moment there are a great many for any taste. Everything is supported - displaying weather, time, screensavers, hundreds of different add-ons and applications. For example, I wanted to get rid of the OSD non-retractable menu, called for rewind or pause. For this, the add-on - Hide Video OSD perfectly. Download the zip archive, put it in a place convenient for raspberries, select the installation from the archive in the addon interface, set it, enable the addon in the settings, set the time in seconds, after which the OSD will automatically be removed from the screen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to other features, Kodi has a full-fledged web-interface through which you can configure settings, control the player and the media library from your home PC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Publications about all the features of the player, and how, for example, to raise a media server on a PC for Kodi, are easily found in RuNet. </font><font style="vertical-align: inherit;">For convenience, omnivorousness and other parameters, I would put this player on a par with such projects as WinAmp and MPC-HC. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small demo shot on slippers:</font></font></b><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/geosx4zqNRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en486084/index.html">Replacing smaller disks with larger disks in Linux</a></li>
<li><a href="../en486092/index.html">Marina Alex, CEO of University of Business Agility: ‚ÄúAgile is out of IT. Agile - More Than IT ‚Äù</a></li>
<li><a href="../en486094/index.html">House Democrat Fights Silicon Valley</a></li>
<li><a href="../en486098/index.html">How tech debt kills your projects</a></li>
<li><a href="../en486100/index.html">How to create a decentralized application that scales? Use less blockchain</a></li>
<li><a href="../en486108/index.html">SSD for gamers and data storage of the future: Seagate at CES 2020</a></li>
<li><a href="../en486112/index.html">Flask web applications: how to deal with cyclic imports</a></li>
<li><a href="../en486114/index.html">Leading scientists in the field of neuroscience will gather at the annual congress of the neuronet industry union</a></li>
<li><a href="../en486116/index.html">Fermat and Miller-Rabin simplicity tests</a></li>
<li><a href="../en486120/index.html">Normalization of deviance. How bad practices are becoming the norm in our industry</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>