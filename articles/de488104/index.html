<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📯 🦖 💃🏾 DBA: Finden Sie nutzlose Indizes 🎺 📻 👨🏽‍🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich stoße regelmäßig auf eine Situation, in der viele Entwickler aufrichtig glauben, dass der Index in PostgreSQL ein solches Schweizer Messer ist, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DBA: Finden Sie nutzlose Indizes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/488104/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich stoße regelmäßig auf eine Situation, in der viele Entwickler aufrichtig glauben, dass der Index in PostgreSQL ein solches Schweizer Messer ist, das allgemein bei Problemen mit der Abfrageleistung hilft. Es reicht aus, </font><font style="vertical-align: inherit;">der Tabelle </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen neuen Index</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzuzufügen </font><font style="vertical-align: inherit;">oder </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Feld irgendwo</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den vorhandenen aufzunehmen, und dann (Magie-Magie!) Werden alle Abfragen diesen Index effektiv verwenden. </font></font><br>
<img src="https://habrastorage.org/webt/7f/ay/qh/7fayqhfcbpano3cagjluq6cxary.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens werden sie entweder nicht oder nicht effizient oder nicht alle. Zweitens führen zusätzliche Indizes nur zu Leistungsproblemen beim Schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen treten solche Situationen während der "Langzeit" -Entwicklung auf, wenn kein benutzerdefiniertes Produkt nach dem Modell "einmal geschrieben, gegeben, vergessen" hergestellt wird, sondern wie in unserem Fall erstellt wird</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service mit einem langen Lebenszyklus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbesserungen erfolgen iterativ durch die Kräfte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vieler verteilter Teams</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die nicht nur räumlich, sondern auch zeitlich verteilt sind. </font><font style="vertical-align: inherit;">Und wenn Sie nicht die gesamte Geschichte der Projektentwicklung oder die Merkmale der angewandten Verteilung von Daten in der Datenbank kennen, können Sie die Indizes leicht "durcheinander bringen". </font><font style="vertical-align: inherit;">Überlegungen und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testanforderungen im Rahmen des Schnitts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ermöglichen es Ihnen jedoch, einen Teil der Probleme im Voraus vorherzusagen und zu erkennen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht verwendete Indizes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präfix "Klone"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel "in der Mitte"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexierbarer Boolescher Wert</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays im Index</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null Müll</font></font></li>
</ul><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, Indizes zu finden, für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es überhaupt keine Pässe gab</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie müssen nur sicherstellen, dass das Zurücksetzen von statistics ( </font></font><code>pg_stat_reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) vor langer Zeit erfolgt ist, und Sie möchten das verwendete "selten, aber passend" nicht löschen. </font><font style="vertical-align: inherit;">Wir verwenden die Systemansicht </font></font><code>pg_stat_user_indexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg_stat_user_indexes <span class="hljs-keyword">WHERE</span> idx_scan = <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn der Index verwendet wird und nicht in diese Auswahl fällt, bedeutet dies keineswegs, dass er für Ihre Abfragen gut geeignet ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Indizes sind [nicht] geeignet?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, warum einige Abfragen im Index "schlecht" werden, werden wir uns die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur eines regulären </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btree-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Index </font><b><font style="vertical-align: inherit;">überlegen</font></b></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der in der Natur am häufigsten vorkommenden Instanz. </font><font style="vertical-align: inherit;">Indizes aus einem einzelnen Feld verursachen normalerweise keine Probleme. Daher betrachten wir die Probleme, die bei einem Verbund aus zwei Feldern auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein extrem vereinfachter Weg, wie man sich vorstellen kann, ist ein „Schichtkuchen“, bei dem in jeder Schicht Bäume nach den Werten des entsprechenden Feldes in der richtigen Reihenfolge angeordnet sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/nq/tu/ucnqtujhwddszfy7aj5gitnqona.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ist es klar , </font><font style="vertical-align: inherit;">dass das Feld </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A global geordnet und B - nur innerhalb eines bestimmten Werts A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Schauen wir uns Beispiele für Bedingungen an, die in realen Abfragen auftreten, und wie sie den Index "durchlaufen".</font></font><br>
<br>
<h4><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gut: Präfixbedingung</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der Index </font></font><code>btree(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen „Subindex“ enthält </font></font><code>btree(A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass alle unten beschriebenen Regeln für jeden Präfixindex funktionieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, wenn Sie einen komplexeren Index als in unserem Beispiel erstellen, der vom Typ ist </font></font><code>btree(A, B, C)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können Sie davon ausgehen, dass Ihre Datenbank automatisch "angezeigt" wird:</font></font><br>
<br>
<ul>
<li><code>btree(A, B, C)</code></li>
<li><code>btree(A, B)</code></li>
<li><code>btree(A)</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass das „physische“ Vorhandensein des Präfixindex in der Datenbank in den meisten Fällen redundant ist. </font><font style="vertical-align: inherit;">Immerhin </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat die mehr Indizes eine Tabelle zu schreiben - desto schlechter ist es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für PostgreSQL, da es Write Amplification nennt - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uber darüber beschwert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (und hier können Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Analyse ihrer Ansprüche finden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn etwas die Basis daran hindert, gut zu leben, lohnt es sich, sie zu finden und zu beseitigen. </font><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel an:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(A <span class="hljs-built_in">integer</span>, B <span class="hljs-built_in">integer</span>, val <span class="hljs-built_in">integer</span>);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B)
  <span class="hljs-keyword">WHERE</span> val <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A) <span class="hljs-comment">--  #1</span>
  <span class="hljs-keyword">WHERE</span> val <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B, val);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A); <span class="hljs-comment">--  #2</span></code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Präfix-Index-Suchabfrage</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid <span class="hljs-keyword">AND</span>
      idx.indexprs <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  , <span class="hljs-keyword">CASE</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' WHERE '</span> <span class="hljs-keyword">THEN</span> regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* WHERE '</span>, <span class="hljs-string">''</span>)
    <span class="hljs-keyword">END</span> wh
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
, pre <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt<font></font>
  , wh<font></font>
  , nmf$<font></font>
  , tpf$<font></font>
  , nmi<font></font>
  , <span class="hljs-keyword">def</span>
  <span class="hljs-keyword">FROM</span><font></font>
    fld<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><font></font>
  Y.*<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  pre X<font></font>
<span class="hljs-keyword">JOIN</span><font></font>
  pre Y<font></font>
    <span class="hljs-keyword">ON</span> Y.nmi &lt;&gt; X.nmi <span class="hljs-keyword">AND</span>
    (Y.nmt, Y.wh) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> (X.nmt, X.wh) <span class="hljs-keyword">AND</span><font></font>
    (<font></font>
      Y.nmf$[<span class="hljs-number">1</span>:array_length(X.nmf$, <span class="hljs-number">1</span>)] = X.nmf$ <span class="hljs-keyword">OR</span>
      X.nmf$[<span class="hljs-number">1</span>:array_length(Y.nmf$, <span class="hljs-number">1</span>)] = Y.nmf$<font></font>
    )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idealerweise sollten Sie eine leere Auswahl erhalten, aber schauen Sie - dies sind unsere verdächtigen Indexgruppen:</font></font><br>
<br>
<pre><code class="plaintext hljs">nmt | wh            | nmf$      | tpf$             | nmi             | def<font></font>
---------------------------------------------------------------------------------------<font></font>
tbl | (val IS NULL) | {a}       | {int4}           | tbl_a_idx       | CREATE INDEX ...<font></font>
tbl | (val IS NULL) | {a,b}     | {int4,int4}      | tbl_a_b_idx     | CREATE INDEX ...<font></font>
tbl |               | {a}       | {int4}           | tbl_a_idx1      | CREATE INDEX ...<font></font>
tbl |               | {a,b,val} | {int4,int4,int4} | tbl_a_b_val_idx | CREATE INDEX ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann entscheiden Sie für jede Gruppe selbst, ob es sich gelohnt hat, den kürzeren oder den längeren Index zu entfernen, der überhaupt nicht benötigt wurde.</font></font><br>
<br>
<h4><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gut: alle Konstanten außer dem letzten Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte aller Felder des Index mit Ausnahme des letzten durch Konstanten festgelegt werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in unserem Beispiel ist dies Feld A), kann der Index normal verwendet werden. </font><font style="vertical-align: inherit;">In diesem Fall kann der Wert des letzten Feldes beliebig eingestellt werden: Konstante, Ungleichung, Intervall, Durchwahl </font></font><code>IN (...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>= ANY(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und es kann auch danach sortiert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/qt/2t/xyqt2tnwfc37wsztb96hzsp5ngu.png"><br>
<br>
<ul>
<li><code>WHERE A = constA AND B <b>[op]</b> constB / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code>WHERE A = constA AND B <b>BETWEEN</b> constB1 AND constB2</code></li>
<li><code>WHERE A = constA <b>ORDER BY</b> B</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den oben beschriebenen Präfixindizes funktioniert dies gut:</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>[op]</b> const / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code>WHERE A <b>BETWEEN</b> const1 AND const2</code></li>
<li><code><b>ORDER BY</b> A</code></li>
<li><code>WHERE (A, B) <b>[op]</b> (constA, constB) / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code><b>ORDER BY</b> A, B</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: vollständige Aufzählung der "Ebene"</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem Teil der Abfragen wird die einzige </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufzählung der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung im Index zu einer vollständigen </font><b><font style="vertical-align: inherit;">Aufzählung aller Werte</font></b><font style="vertical-align: inherit;"> in einer der „Ebenen“. </font><font style="vertical-align: inherit;">Es ist ein Glück, wenn es eine Einheit solcher Werte gibt - und wenn es Tausende gibt? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise tritt ein solches Problem auf, wenn </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungleichheit</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Abfrage verwendet wird </font><font style="vertical-align: inherit;">, die Bedingung </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Felder bestimmt </font><font style="vertical-align: inherit;">, </font><i><b><font style="vertical-align: inherit;">die</font></b></i><font style="vertical-align: inherit;"> in der Indexreihenfolge </font><i><b><font style="vertical-align: inherit;">vorher waren</font></b></i><font style="vertical-align: inherit;"> , oder diese </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihenfolge</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> während der Sortierung </font><i><b><font style="vertical-align: inherit;">verletzt wird</font></b></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>&lt;&gt;</b> const</code></li>
<li><code>WHERE B [op] const / = ANY(...) / IN (...)</code></li>
<li><code>ORDER BY B</code></li>
<li><code>ORDER BY B, A</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: Intervall oder Satz befindet sich nicht im letzten Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Konsequenz des vorherigen - Wenn Sie mehrere Werte oder deren Bereich auf einer Zwischenebene finden und dann nach den Feldern filtern oder sortieren müssen, die "tiefer" im Index liegen, treten Probleme auf, wenn die Anzahl der eindeutigen Werte "in der Mitte" des Index liegt groß.</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>BETWEEN</b> constA1 AND constA2 AND B <b>BETWEEN</b> constB1 AND constB2</code></li>
<li><code>WHERE A <b>= ANY(...)</b> AND B = const</code></li>
<li><code>WHERE A <b>= ANY(...)</b> ORDER BY B</code></li>
<li><code>WHERE A <b>= ANY(...)</b> AND B = ANY(...)</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: Ausdruck statt Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal verwandelt ein Entwickler eine Spalte in einer Abfrage unbewusst in etwas anderes - in einen Ausdruck, für den es keinen Index gibt. </font><font style="vertical-align: inherit;">Dies kann behoben werden, indem ein Index aus dem gewünschten Ausdruck erstellt oder die inverse Transformation durchgeführt wird:</font></font><br>
<br>
<ul>
<li><code>WHERE <b>A - const1</b> [op] const2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fix: </font></font><code>WHERE A [op] <b>const1 + const2</b></code></li>
<li><code>WHERE <b>A::typeOfConst</b> = const</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fix: </font></font><code>WHERE A = <b>const::typeOfA</b></code></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir berücksichtigen die Kardinalität der Felder</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie benötigen einen Index </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und möchten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur nach Gleichheit auswählen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>(A, B) = (constA, constB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Verwendung eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Index</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wäre ideal </font><font style="vertical-align: inherit;">, aber ... Zusätzlich zum Nicht-Journaling (Wal-Logging) solcher Indizes bis Version 10 können sie auch nicht in mehreren Feldern vorhanden sein:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl <span class="hljs-keyword">USING</span> <span class="hljs-keyword">hash</span>(A, B);
<span class="hljs-comment">-- ERROR:  access method "hash" does not support multicolumn indexes</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen haben Sie btree gewählt. </font><font style="vertical-align: inherit;">Was ist also der beste Weg, um Spalten darin anzuordnen - </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>(B, A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Um diese Frage zu beantworten, muss ein Parameter wie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kardinalität der Daten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der entsprechenden Spalte </font><font style="vertical-align: inherit;">berücksichtigt werden </font><font style="vertical-align: inherit;">, dh wie viele eindeutige Werte sie enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen wir uns das vor </font></font><code>A = {1,2}, B = {1,2,3,4}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zeichnen einen Umriss des Indexbaums für beide Optionen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/bv/xx/iubvxx2xilnlkhkihtjnjacaekk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tatsächlich ist jeder Knoten im Baum, den wir zeichnen, eine Seite im Index. </font><font style="vertical-align: inherit;">Und je mehr vorhanden sind, desto mehr Speicherplatz belegt der Index, desto länger dauert das Lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel hat die Option </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 Knoten und </font></font><code>(B, A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 12. Das heißt, es ist rentabler, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die "Felder" mit so wenig eindeutigen Werten wie möglich "zuerst" zu setzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: viel und fehl am Platz (Zeitstempel "in der Mitte")</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau aus diesem Grund sieht es immer verdächtig aus, wenn ein Feld mit offensichtlich großer Variabilität wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel [tz] nicht das letzte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Ihrem Index ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Regel steigen die Werte des Zeitstempelfelds monoton an, und die folgenden Indexfelder haben zu jedem Zeitpunkt nur einen Wert.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(A <span class="hljs-built_in">integer</span>, B <span class="hljs-built_in">timestamp</span>);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(B, A); <span class="hljs-comment">-- - </span></code></pre><br>
<img src="https://habrastorage.org/webt/m_/-e/qm/m_-eqmqod5kyvkako8evgt-a98s.png"><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchabfrage für nicht endgültige Zeitstempel [tz] -Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">replace</span>(opcname::<span class="hljs-built_in">text</span>, <span class="hljs-string">'_ops'</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indclass[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indclass, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_opclass T<font></font>
        <span class="hljs-keyword">ON</span> T.oid = f.ik<font></font>
  ) opc$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, <span class="hljs-keyword">def</span><font></font>
, nmf$<font></font>
, tpf$<font></font>
, opc$<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span>
  <span class="hljs-string">'timestamp'</span> = <span class="hljs-keyword">ANY</span>(tpf$[<span class="hljs-number">1</span>:array_length(tpf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamptz'</span> = <span class="hljs-keyword">ANY</span>(tpf$[<span class="hljs-number">1</span>:array_length(tpf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamp'</span> = <span class="hljs-keyword">ANY</span>(opc$[<span class="hljs-number">1</span>:array_length(opc$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamptz'</span> = <span class="hljs-keyword">ANY</span>(opc$[<span class="hljs-number">1</span>:array_length(opc$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>])
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier analysieren wir sofort sowohl die Typen der Eingabefelder selbst als auch die auf sie angewendeten Klassen von Operatoren - da sich einige timestamptz-Funktionen wie date_trunc als Indexfeld herausstellen können.</font></font><br>
<br>
<pre><code class="plaintext hljs">nmt | nmi         | def              | nmf$  | tpf$             | opc$<font></font>
----------------------------------------------------------------------------------<font></font>
tbl | tbl_b_a_idx | CREATE INDEX ... | {b,a} | {timestamp,int4} | {timestamp,int4}<font></font>
</code></pre><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: zu wenig (boolesch)</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kehrseite derselben Münze wird zu einer Situation, in der der Index ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolesches Feld ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das nur 3 Werte annehmen kann </font></font><code>NULL, FALSE, TRUE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Vorhandensein ist natürlich sinnvoll, wenn Sie es für die angewandte Sortierung verwenden möchten, indem Sie sie beispielsweise als Knotentyp in der Baumhierarchie festlegen, unabhängig davon, ob es sich um einen Ordner oder ein Blatt handelt („Ordner zuerst“).</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, leaf_pid<font></font>
    <span class="hljs-built_in">integer</span><font></font>
, leaf_type<font></font>
    <span class="hljs-built_in">boolean</span>
, <span class="hljs-keyword">public</span>
    <span class="hljs-built_in">boolean</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(leaf_pid, leaf_type); <span class="hljs-comment">--   </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">public</span>, <span class="hljs-keyword">id</span>); <span class="hljs-comment">-- - </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen ist dies jedoch nicht der Fall, und Anforderungen haben einen bestimmten Wert für das boolesche Feld. </font><font style="vertical-align: inherit;">Und dann wird es möglich, den Index durch dieses Feld durch seine bedingte Version zu ersetzen:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">public</span>;</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolesche Suchabfrage in Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">replace</span>(opcname::<span class="hljs-built_in">text</span>, <span class="hljs-string">'_ops'</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indclass[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indclass, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_opclass T<font></font>
        <span class="hljs-keyword">ON</span> T.oid = f.ik<font></font>
  ) opc$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, <span class="hljs-keyword">def</span><font></font>
, nmf$<font></font>
, tpf$<font></font>
, opc$<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span><font></font>
  (<font></font>
    <span class="hljs-string">'bool'</span> = <span class="hljs-keyword">ANY</span>(tpf$) <span class="hljs-keyword">OR</span>
    <span class="hljs-string">'bool'</span> = <span class="hljs-keyword">ANY</span>(opc$)<font></font>
  ) <span class="hljs-keyword">AND</span>
  <span class="hljs-keyword">NOT</span>(
    <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span>
        nmf$[i:i+<span class="hljs-number">1</span>]::<span class="hljs-built_in">text</span>
      <span class="hljs-keyword">FROM</span>
        generate_series(<span class="hljs-number">1</span>, array_length(nmf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) i<font></font>
    ) &amp;&amp;<font></font>
    <span class="hljs-built_in">ARRAY</span>[ <span class="hljs-comment">--  -  </span>
      <span class="hljs-string">'{leaf_pid,leaf_type}'</span><font></font>
    ]<font></font>
  )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">nmt | nmi               | def              | nmf$        | tpf$        | opc$<font></font>
------------------------------------------------------------------------------------<font></font>
tbl | tbl_public_id_idx | CREATE INDEX ... | {public,id} | {bool,int4} | {bool,int4}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays in btree</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein separater Punkt ist der Versuch, das Array mithilfe des btree-Index zu "indizieren". </font><font style="vertical-align: inherit;">Dies ist durchaus möglich, da für sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechenden Operatoren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelten </font><font style="vertical-align: inherit;">:</font></font><br>
<blockquote><b> </b>  (<code>&lt;, &gt;, =</code>  . .)     ,       B-,       ,      .        (      ).     ,   ,         .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist jedoch, dass er etwas verwendet, das er für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operatoren von Inklusion und Schnittmenge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwenden möchte </font><font style="vertical-align: inherit;">: </font></font><code>&lt;@, @&gt;, &amp;&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies funktioniert natürlich nicht - da sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Arten von Indizes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> benötigen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie ein solcher Baum für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion des Zugriffs auf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein bestimmtes Element </font><font style="vertical-align: inherit;">nicht </font><b><font style="vertical-align: inherit;">funktioniert</font></b></font><code>arr[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lernen solche zu finden:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, pid<font></font>
    <span class="hljs-built_in">integer</span>
, <span class="hljs-keyword">list</span>
    <span class="hljs-built_in">integer</span>[]<font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(pid);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">list</span>); <span class="hljs-comment">-- - </span>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array-Suchabfrage in btree</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span>
    idx.indisvalid <span class="hljs-keyword">AND</span><font></font>
    cli.relam = (<font></font>
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-keyword">oid</span>
      <span class="hljs-keyword">FROM</span><font></font>
        pg_am<font></font>
      <span class="hljs-keyword">WHERE</span>
        amname = <span class="hljs-string">'btree'</span>
      <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><font></font>
    )<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, nmf$<font></font>
, tpf$<font></font>
, <span class="hljs-keyword">def</span>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span>
  tpf$ &amp;&amp; <span class="hljs-built_in">ARRAY</span>(
    <span class="hljs-keyword">SELECT</span><font></font>
      typname<font></font>
    <span class="hljs-keyword">FROM</span><font></font>
      pg_type<font></font>
    <span class="hljs-keyword">WHERE</span>
      typname ~ <span class="hljs-string">'^_'</span><font></font>
  )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">nmt | nmi          | nmf$   | tpf$    | def<font></font>
--------------------------------------------------------<font></font>
tbl | tbl_list_idx | {list} | {_int4} | CREATE INDEX ...<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL-Indexeinträge</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte häufig auftretende Problem besteht darin, den Index mit vollständig NULL-Einträgen zu „verschmutzen“. </font><font style="vertical-align: inherit;">Das heißt, Datensätze, bei denen der indizierte Ausdruck </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jeder der Spalten NULL ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Solche Aufzeichnungen haben keinen praktischen Nutzen, aber sie fügen jedem Einsatz Schaden zu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise werden sie angezeigt, wenn Sie ein FK-Feld oder eine Wertebeziehung mit optionalem Auffüllen in der Tabelle erstellen. </font><font style="vertical-align: inherit;">Dann rollen Sie den Index, damit FK schnell funktioniert ... und hier sind sie. </font><font style="vertical-align: inherit;">Je seltener die Verbindung gefüllt wird, desto mehr „Müll“ fällt in den Index. </font><font style="vertical-align: inherit;">Wir werden simulieren:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, fk<font></font>
    <span class="hljs-built_in">integer</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(fk);<font></font>
<font></font>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tbl(fk)
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> i % <span class="hljs-number">10</span> = <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> i <span class="hljs-keyword">END</span>
<span class="hljs-keyword">FROM</span>
  generate_series(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>) i;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten Fällen kann ein solcher Index in einen bedingten Index konvertiert werden, der auch weniger benötigt:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(fk) <span class="hljs-keyword">WHERE</span> (fk) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;</code></pre><br>
<pre><code class="plaintext hljs">_tmp=# \di+ tbl*<font></font>
                               List of relations<font></font>
 Schema |      Name      | Type  |  Owner   |  Table   |  Size   | Description<font></font>
--------+----------------+-------+----------+----------+---------+-------------<font></font>
 public | tbl_fk_idx     | index | postgres | tbl      | 36 MB   |<font></font>
 public | tbl_fk_idx1    | index | postgres | tbl      | 2208 kB |<font></font>
 public | tbl_pkey       | index | postgres | tbl      | 21 MB   |<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um solche Indizes zu finden, müssen wir die tatsächliche Verteilung der Daten kennen - das heißt, wir müssen den gesamten Inhalt der Tabellen lesen und ihn gemäß den WHERE-Bedingungen des Auftretens überlagern (wir werden dies mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dblink</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tun </font><font style="vertical-align: inherit;">), was </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr lange dauern kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchabfrage nach NULL-Einträgen in Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisprimary <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span>
    idx.indisvalid <span class="hljs-keyword">AND</span>
    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-literal">NULL</span>
      <span class="hljs-keyword">FROM</span><font></font>
        pg_constraint<font></font>
      <span class="hljs-keyword">WHERE</span><font></font>
        conindid = cli.oid<font></font>
      <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>
    ) <span class="hljs-keyword">AND</span>
    pg_relation_size(cli.oid) &gt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">--  1MB   </span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , regexp_replace(<font></font>
      <span class="hljs-keyword">CASE</span>
        <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' USING btree '</span> <span class="hljs-keyword">THEN</span>
          regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* USING btree (.*?)($| WHERE .*)'</span>, E<span class="hljs-string">'\\1'</span>)
      <span class="hljs-keyword">END</span>
    , E<span class="hljs-string">' ([a-z]*_pattern_ops|(ASC|DESC)|NULLS\\s?(?:FIRST|LAST))'</span>
    , <span class="hljs-string">''</span>
    , <span class="hljs-string">'ig'</span><font></font>
    ) fld<font></font>
  , <span class="hljs-keyword">CASE</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' WHERE '</span> <span class="hljs-keyword">THEN</span> regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* WHERE '</span>, <span class="hljs-string">''</span>)
    <span class="hljs-keyword">END</span> wh
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
, q <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt<font></font>
  , $q$<span class="hljs-comment">-- $q$ || quote_ident(nmt) || $q$</span>
      <span class="hljs-keyword">SET</span> search_path = $q$ || quote_ident((<span class="hljs-keyword">TABLE</span> sch)) || $q$, <span class="hljs-keyword">public</span>;
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-built_in">ARRAY</span>[
          <span class="hljs-keyword">count</span>(*)<font></font>
        $q$ || string_agg(<font></font>
          <span class="hljs-string">', coalesce(sum(('</span> || <span class="hljs-keyword">coalesce</span>(wh, <span class="hljs-string">'TRUE'</span>) || <span class="hljs-string">')::integer), 0)'</span> || E<span class="hljs-string">'\n'</span> ||
          <span class="hljs-string">', coalesce(sum((('</span> || <span class="hljs-keyword">coalesce</span>(wh, <span class="hljs-string">'TRUE'</span>) || <span class="hljs-string">') AND ('</span> || fld || <span class="hljs-string">' IS NULL))::integer), 0)'</span> || E<span class="hljs-string">'\n'</span>
        , <span class="hljs-string">''</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) || $q$<font></font>
        ]<font></font>
      <span class="hljs-keyword">FROM</span>
        $q$ || quote_ident((<span class="hljs-keyword">TABLE</span> sch)) || $q$.$q$ || quote_ident(nmt) || $q$<font></font>
    $q$ q<font></font>
  , array_agg(clioid <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) <span class="hljs-keyword">oid</span>$<font></font>
  , array_agg(nmi <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) idx$<font></font>
  , array_agg(fld <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) fld$<font></font>
  , array_agg(wh <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) wh$
  <span class="hljs-keyword">FROM</span><font></font>
    fld<font></font>
  <span class="hljs-keyword">WHERE</span>
    fld <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span><font></font>
)<font></font>
, res <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , (<font></font>
      <span class="hljs-keyword">SELECT</span><font></font>
        qty<font></font>
      <span class="hljs-keyword">FROM</span><font></font>
        dblink(<font></font>
          <span class="hljs-string">'dbname='</span> || current_database() || <span class="hljs-string">' port='</span> || current_setting(<span class="hljs-string">'port'</span>)<font></font>
        , q<font></font>
        ) T(qty <span class="hljs-built_in">bigint</span>[])<font></font>
    ) qty<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    q<font></font>
)<font></font>
, iter <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , generate_subscripts(idx$, <span class="hljs-number">1</span>) i
  <span class="hljs-keyword">FROM</span><font></font>
    res<font></font>
)<font></font>
, stat <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt table_name<font></font>
  , idx$[i] index_name<font></font>
  , pg_relation_size(<span class="hljs-keyword">oid</span>$[i]) index_size<font></font>
  , pg_size_pretty(pg_relation_size(<span class="hljs-keyword">oid</span>$[i])) index_size_humanize<font></font>
  , regexp_replace(fld$[i], E<span class="hljs-string">'^\\((.*)\\)$'</span>, E<span class="hljs-string">'\\1'</span>) index_fields<font></font>
  , regexp_replace(wh$[i], E<span class="hljs-string">'^\\((.*)\\)$'</span>, E<span class="hljs-string">'\\1'</span>) index_cond<font></font>
  , qty[<span class="hljs-number">1</span>] table_rec_count<font></font>
  , qty[i * <span class="hljs-number">2</span>] index_rec_count<font></font>
  , qty[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] index_rec_count_null
  <span class="hljs-keyword">FROM</span><font></font>
    iter<font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  *<font></font>
, <span class="hljs-keyword">CASE</span>
    <span class="hljs-keyword">WHEN</span> table_rec_count &gt; <span class="hljs-number">0</span>
      <span class="hljs-keyword">THEN</span> index_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> / table_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> * <span class="hljs-number">100</span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">END</span>::<span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>) index_cover_prc<font></font>
, <span class="hljs-keyword">CASE</span>
    <span class="hljs-keyword">WHEN</span> index_rec_count &gt; <span class="hljs-number">0</span>
      <span class="hljs-keyword">THEN</span> index_rec_count_null::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> / index_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> * <span class="hljs-number">100</span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">END</span>::<span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>) index_null_prc
<span class="hljs-keyword">FROM</span><font></font>
  stat<font></font>
<span class="hljs-keyword">WHERE</span>
  index_rec_count_null * <span class="hljs-number">4</span> &gt; index_rec_count <span class="hljs-comment">--   NULL-</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">-[ RECORD 1 ]--------+--------------<font></font>
table_name           | tbl<font></font>
index_name           | tbl_fk_idx<font></font>
index_size           | 37838848<font></font>
index_size_humanize  | 36 MB<font></font>
index_fields         | fk<font></font>
index_cond           |<font></font>
table_rec_count      | 1000000<font></font>
index_rec_count      | 1000000<font></font>
index_rec_count_null | 900000<font></font>
index_cover_prc      | 100.00 -- 100%    <font></font>
index_null_prc       | 90.00  --   90% NULL-""<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, einige der Fragen in diesem Artikel werden Ihnen helfen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488088/index.html">Wie Habr mit staatlichen Stellen und anderen Antragstellern umgeht. Transparenzbericht für alle Jahre</a></li>
<li><a href="../de488092/index.html">Hackathons. Wie man das Beste herausholt und überlebt</a></li>
<li><a href="../de488096/index.html">400 g. Blick von der Seite des Getriebes. ZR / ZR +</a></li>
<li><a href="../de488098/index.html">So erstellen Sie ein Django-Projekt aus einer Vorlage</a></li>
<li><a href="../de488102/index.html">Die Beziehung zwischen C # und C #: REST, gRPC und alles dazwischen</a></li>
<li><a href="../de488108/index.html">SAP HANA Lab in Azure</a></li>
<li><a href="../de488112/index.html">Grundlegendes zu Iteratoren in Python</a></li>
<li><a href="../de488116/index.html">Fünf wichtige Lektionen zur Spielbalance</a></li>
<li><a href="../de488118/index.html">Haxe Winter Statusbericht</a></li>
<li><a href="../de488120/index.html">Warum lohnt es sich, ein 64-Bit-Betriebssystem auf dem Raspberry Pi4 zu installieren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>