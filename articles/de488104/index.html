<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìØ ü¶ñ üíÉüèæ DBA: Finden Sie nutzlose Indizes üé∫ üìª üë®üèΩ‚Äçüîß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich sto√üe regelm√§√üig auf eine Situation, in der viele Entwickler aufrichtig glauben, dass der Index in PostgreSQL ein solches Schweizer Messer ist, da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>DBA: Finden Sie nutzlose Indizes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/488104/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich sto√üe regelm√§√üig auf eine Situation, in der viele Entwickler aufrichtig glauben, dass der Index in PostgreSQL ein solches Schweizer Messer ist, das allgemein bei Problemen mit der Abfrageleistung hilft. Es reicht aus, </font><font style="vertical-align: inherit;">der Tabelle </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen neuen Index</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hinzuzuf√ºgen </font><font style="vertical-align: inherit;">oder </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Feld irgendwo</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den vorhandenen aufzunehmen, und dann (Magie-Magie!) Werden alle Abfragen diesen Index effektiv verwenden. </font></font><br>
<img src="https://habrastorage.org/webt/7f/ay/qh/7fayqhfcbpano3cagjluq6cxary.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstens werden sie entweder nicht oder nicht effizient oder nicht alle. Zweitens f√ºhren zus√§tzliche Indizes nur zu Leistungsproblemen beim Schreiben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen treten solche Situationen w√§hrend der "Langzeit" -Entwicklung auf, wenn kein benutzerdefiniertes Produkt nach dem Modell "einmal geschrieben, gegeben, vergessen" hergestellt wird, sondern wie in unserem Fall erstellt wird</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Service mit einem langen Lebenszyklus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verbesserungen erfolgen iterativ durch die Kr√§fte </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vieler verteilter Teams</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die nicht nur r√§umlich, sondern auch zeitlich verteilt sind. </font><font style="vertical-align: inherit;">Und wenn Sie nicht die gesamte Geschichte der Projektentwicklung oder die Merkmale der angewandten Verteilung von Daten in der Datenbank kennen, k√∂nnen Sie die Indizes leicht "durcheinander bringen". </font><font style="vertical-align: inherit;">√úberlegungen und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testanforderungen im Rahmen des Schnitts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erm√∂glichen es Ihnen jedoch, einen Teil der Probleme im Voraus vorherzusagen und zu erkennen:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht verwendete Indizes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§fix "Klone"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel "in der Mitte"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indexierbarer Boolescher Wert</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays im Index</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Null M√ºll</font></font></li>
</ul><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am einfachsten ist es, Indizes zu finden, f√ºr die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es √ºberhaupt keine P√§sse gab</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sie m√ºssen nur sicherstellen, dass das Zur√ºcksetzen von statistics ( </font></font><code>pg_stat_reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) vor langer Zeit erfolgt ist, und Sie m√∂chten das verwendete "selten, aber passend" nicht l√∂schen. </font><font style="vertical-align: inherit;">Wir verwenden die Systemansicht </font></font><code>pg_stat_user_indexes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> pg_stat_user_indexes <span class="hljs-keyword">WHERE</span> idx_scan = <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber selbst wenn der Index verwendet wird und nicht in diese Auswahl f√§llt, bedeutet dies keineswegs, dass er f√ºr Ihre Abfragen gut geeignet ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Welche Indizes sind [nicht] geeignet?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu verstehen, warum einige Abfragen im Index "schlecht" werden, werden wir uns die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur eines regul√§ren </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">btree-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Index </font><b><font style="vertical-align: inherit;">√ºberlegen</font></b></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der in der Natur am h√§ufigsten vorkommenden Instanz. </font><font style="vertical-align: inherit;">Indizes aus einem einzelnen Feld verursachen normalerweise keine Probleme. Daher betrachten wir die Probleme, die bei einem Verbund aus zwei Feldern auftreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein extrem vereinfachter Weg, wie man sich vorstellen kann, ist ein ‚ÄûSchichtkuchen‚Äú, bei dem in jeder Schicht B√§ume nach den Werten des entsprechenden Feldes in der richtigen Reihenfolge angeordnet sind. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/nq/tu/ucnqtujhwddszfy7aj5gitnqona.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun ist es klar , </font><font style="vertical-align: inherit;">dass das Feld </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A global geordnet und B - nur innerhalb eines bestimmten Werts A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Schauen wir uns Beispiele f√ºr Bedingungen an, die in realen Abfragen auftreten, und wie sie den Index "durchlaufen".</font></font><br>
<br>
<h4><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gut: Pr√§fixbedingung</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass der Index </font></font><code>btree(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen ‚ÄûSubindex‚Äú enth√§lt </font></font><code>btree(A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies bedeutet, dass alle unten beschriebenen Regeln f√ºr jeden Pr√§fixindex funktionieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, wenn Sie einen komplexeren Index als in unserem Beispiel erstellen, der vom Typ ist </font></font><code>btree(A, B, C)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, k√∂nnen Sie davon ausgehen, dass Ihre Datenbank automatisch "angezeigt" wird:</font></font><br>
<br>
<ul>
<li><code>btree(A, B, C)</code></li>
<li><code>btree(A, B)</code></li>
<li><code>btree(A)</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet, dass das ‚Äûphysische‚Äú Vorhandensein des Pr√§fixindex in der Datenbank in den meisten F√§llen redundant ist. </font><font style="vertical-align: inherit;">Immerhin </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hat die mehr Indizes eine Tabelle zu schreiben - desto schlechter ist es</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr PostgreSQL, da es Write Amplification nennt - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uber dar√ºber beschwert</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (und hier k√∂nnen Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Analyse ihrer Anspr√ºche finden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und wenn etwas die Basis daran hindert, gut zu leben, lohnt es sich, sie zu finden und zu beseitigen. </font><font style="vertical-align: inherit;">Schauen wir uns ein Beispiel an:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(A <span class="hljs-built_in">integer</span>, B <span class="hljs-built_in">integer</span>, val <span class="hljs-built_in">integer</span>);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B)
  <span class="hljs-keyword">WHERE</span> val <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A) <span class="hljs-comment">--  #1</span>
  <span class="hljs-keyword">WHERE</span> val <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B, val);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A); <span class="hljs-comment">--  #2</span></code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pr√§fix-Index-Suchabfrage</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid <span class="hljs-keyword">AND</span>
      idx.indexprs <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  , <span class="hljs-keyword">CASE</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' WHERE '</span> <span class="hljs-keyword">THEN</span> regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* WHERE '</span>, <span class="hljs-string">''</span>)
    <span class="hljs-keyword">END</span> wh
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
, pre <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt<font></font>
  , wh<font></font>
  , nmf$<font></font>
  , tpf$<font></font>
  , nmi<font></font>
  , <span class="hljs-keyword">def</span>
  <span class="hljs-keyword">FROM</span><font></font>
    fld<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><font></font>
  Y.*<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  pre X<font></font>
<span class="hljs-keyword">JOIN</span><font></font>
  pre Y<font></font>
    <span class="hljs-keyword">ON</span> Y.nmi &lt;&gt; X.nmi <span class="hljs-keyword">AND</span>
    (Y.nmt, Y.wh) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">FROM</span> (X.nmt, X.wh) <span class="hljs-keyword">AND</span><font></font>
    (<font></font>
      Y.nmf$[<span class="hljs-number">1</span>:array_length(X.nmf$, <span class="hljs-number">1</span>)] = X.nmf$ <span class="hljs-keyword">OR</span>
      X.nmf$[<span class="hljs-number">1</span>:array_length(Y.nmf$, <span class="hljs-number">1</span>)] = Y.nmf$<font></font>
    )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idealerweise sollten Sie eine leere Auswahl erhalten, aber schauen Sie - dies sind unsere verd√§chtigen Indexgruppen:</font></font><br>
<br>
<pre><code class="plaintext hljs">nmt | wh            | nmf$      | tpf$             | nmi             | def<font></font>
---------------------------------------------------------------------------------------<font></font>
tbl | (val IS NULL) | {a}       | {int4}           | tbl_a_idx       | CREATE INDEX ...<font></font>
tbl | (val IS NULL) | {a,b}     | {int4,int4}      | tbl_a_b_idx     | CREATE INDEX ...<font></font>
tbl |               | {a}       | {int4}           | tbl_a_idx1      | CREATE INDEX ...<font></font>
tbl |               | {a,b,val} | {int4,int4,int4} | tbl_a_b_val_idx | CREATE INDEX ...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann entscheiden Sie f√ºr jede Gruppe selbst, ob es sich gelohnt hat, den k√ºrzeren oder den l√§ngeren Index zu entfernen, der √ºberhaupt nicht ben√∂tigt wurde.</font></font><br>
<br>
<h4><font color="#008000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gut: alle Konstanten au√üer dem letzten Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Werte aller Felder des Index mit Ausnahme des letzten durch Konstanten festgelegt werden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (in unserem Beispiel ist dies Feld A), kann der Index normal verwendet werden. </font><font style="vertical-align: inherit;">In diesem Fall kann der Wert des letzten Feldes beliebig eingestellt werden: Konstante, Ungleichung, Intervall, Durchwahl </font></font><code>IN (...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>= ANY(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und es kann auch danach sortiert werden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/qt/2t/xyqt2tnwfc37wsztb96hzsp5ngu.png"><br>
<br>
<ul>
<li><code>WHERE A = constA AND B <b>[op]</b> constB / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code>WHERE A = constA AND B <b>BETWEEN</b> constB1 AND constB2</code></li>
<li><code>WHERE A = constA <b>ORDER BY</b> B</code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den oben beschriebenen Pr√§fixindizes funktioniert dies gut:</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>[op]</b> const / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code>WHERE A <b>BETWEEN</b> const1 AND const2</code></li>
<li><code><b>ORDER BY</b> A</code></li>
<li><code>WHERE (A, B) <b>[op]</b> (constA, constB) / <b>= ANY</b>(...) / <b>IN</b> (...)</code><br>
<code>op : { =, &gt;, &gt;=, &lt;, &lt;= }</code></li>
<li><code><b>ORDER BY</b> A, B</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: vollst√§ndige Aufz√§hlung der "Ebene"</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei einem Teil der Abfragen wird die einzige </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aufz√§hlung der</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bewegung im Index zu einer vollst√§ndigen </font><b><font style="vertical-align: inherit;">Aufz√§hlung aller Werte</font></b><font style="vertical-align: inherit;"> in einer der ‚ÄûEbenen‚Äú. </font><font style="vertical-align: inherit;">Es ist ein Gl√ºck, wenn es eine Einheit solcher Werte gibt - und wenn es Tausende gibt? .. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise tritt ein solches Problem auf, wenn </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ungleichheit</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Abfrage verwendet wird </font><font style="vertical-align: inherit;">, die Bedingung </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nicht</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Felder bestimmt </font><font style="vertical-align: inherit;">, </font><i><b><font style="vertical-align: inherit;">die</font></b></i><font style="vertical-align: inherit;"> in der Indexreihenfolge </font><i><b><font style="vertical-align: inherit;">vorher waren</font></b></i><font style="vertical-align: inherit;"> , oder diese </font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihenfolge</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§hrend der Sortierung </font><i><b><font style="vertical-align: inherit;">verletzt wird</font></b></i><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>&lt;&gt;</b> const</code></li>
<li><code>WHERE B [op] const / = ANY(...) / IN (...)</code></li>
<li><code>ORDER BY B</code></li>
<li><code>ORDER BY B, A</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: Intervall oder Satz befindet sich nicht im letzten Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Konsequenz des vorherigen - Wenn Sie mehrere Werte oder deren Bereich auf einer Zwischenebene finden und dann nach den Feldern filtern oder sortieren m√ºssen, die "tiefer" im Index liegen, treten Probleme auf, wenn die Anzahl der eindeutigen Werte "in der Mitte" des Index liegt gro√ü.</font></font><br>
<br>
<ul>
<li><code>WHERE A <b>BETWEEN</b> constA1 AND constA2 AND B <b>BETWEEN</b> constB1 AND constB2</code></li>
<li><code>WHERE A <b>= ANY(...)</b> AND B = const</code></li>
<li><code>WHERE A <b>= ANY(...)</b> ORDER BY B</code></li>
<li><code>WHERE A <b>= ANY(...)</b> AND B = ANY(...)</code></li>
</ul><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: Ausdruck statt Feld</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Manchmal verwandelt ein Entwickler eine Spalte in einer Abfrage unbewusst in etwas anderes - in einen Ausdruck, f√ºr den es keinen Index gibt. </font><font style="vertical-align: inherit;">Dies kann behoben werden, indem ein Index aus dem gew√ºnschten Ausdruck erstellt oder die inverse Transformation durchgef√ºhrt wird:</font></font><br>
<br>
<ul>
<li><code>WHERE <b>A - const1</b> [op] const2</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fix: </font></font><code>WHERE A [op] <b>const1 + const2</b></code></li>
<li><code>WHERE <b>A::typeOfConst</b> = const</code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fix: </font></font><code>WHERE A = <b>const::typeOfA</b></code></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir ber√ºcksichtigen die Kardinalit√§t der Felder</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angenommen, Sie ben√∂tigen einen Index </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und m√∂chten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur nach Gleichheit ausw√§hlen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><code>(A, B) = (constA, constB)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die Verwendung eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Index</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§re ideal </font><font style="vertical-align: inherit;">, aber ... Zus√§tzlich zum Nicht-Journaling (Wal-Logging) solcher Indizes bis Version 10 k√∂nnen sie auch nicht in mehreren Feldern vorhanden sein:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl <span class="hljs-keyword">USING</span> <span class="hljs-keyword">hash</span>(A, B);
<span class="hljs-comment">-- ERROR:  access method "hash" does not support multicolumn indexes</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen haben Sie btree gew√§hlt. </font><font style="vertical-align: inherit;">Was ist also der beste Weg, um Spalten darin anzuordnen - </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder </font></font><code>(B, A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Um diese Frage zu beantworten, muss ein Parameter wie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kardinalit√§t der Daten</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der entsprechenden Spalte </font><font style="vertical-align: inherit;">ber√ºcksichtigt werden </font><font style="vertical-align: inherit;">, dh wie viele eindeutige Werte sie enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen wir uns das vor </font></font><code>A = {1,2}, B = {1,2,3,4}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und zeichnen einen Umriss des Indexbaums f√ºr beide Optionen: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/bv/xx/iubvxx2xilnlkhkihtjnjacaekk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tats√§chlich ist jeder Knoten im Baum, den wir zeichnen, eine Seite im Index. </font><font style="vertical-align: inherit;">Und je mehr vorhanden sind, desto mehr Speicherplatz belegt der Index, desto l√§nger dauert das Lesen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Beispiel hat die Option </font></font><code>(A, B)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 Knoten und </font></font><code>(B, A)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 12. Das hei√üt, es ist rentabler, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die "Felder" mit so wenig eindeutigen Werten wie m√∂glich "zuerst" zu setzen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: viel und fehl am Platz (Zeitstempel "in der Mitte")</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau aus diesem Grund sieht es immer verd√§chtig aus, wenn ein Feld mit offensichtlich gro√üer Variabilit√§t wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeitstempel [tz] nicht das letzte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Ihrem Index ist </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In der Regel steigen die Werte des Zeitstempelfelds monoton an, und die folgenden Indexfelder haben zu jedem Zeitpunkt nur einen Wert.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(A <span class="hljs-built_in">integer</span>, B <span class="hljs-built_in">timestamp</span>);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(A, B);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(B, A); <span class="hljs-comment">-- - </span></code></pre><br>
<img src="https://habrastorage.org/webt/m_/-e/qm/m_-eqmqod5kyvkako8evgt-a98s.png"><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchabfrage f√ºr nicht endg√ºltige Zeitstempel [tz] -Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">replace</span>(opcname::<span class="hljs-built_in">text</span>, <span class="hljs-string">'_ops'</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indclass[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indclass, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_opclass T<font></font>
        <span class="hljs-keyword">ON</span> T.oid = f.ik<font></font>
  ) opc$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, <span class="hljs-keyword">def</span><font></font>
, nmf$<font></font>
, tpf$<font></font>
, opc$<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span>
  <span class="hljs-string">'timestamp'</span> = <span class="hljs-keyword">ANY</span>(tpf$[<span class="hljs-number">1</span>:array_length(tpf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamptz'</span> = <span class="hljs-keyword">ANY</span>(tpf$[<span class="hljs-number">1</span>:array_length(tpf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamp'</span> = <span class="hljs-keyword">ANY</span>(opc$[<span class="hljs-number">1</span>:array_length(opc$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>]) <span class="hljs-keyword">OR</span>
  <span class="hljs-string">'timestamptz'</span> = <span class="hljs-keyword">ANY</span>(opc$[<span class="hljs-number">1</span>:array_length(opc$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>])
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;
</code></pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier analysieren wir sofort sowohl die Typen der Eingabefelder selbst als auch die auf sie angewendeten Klassen von Operatoren - da sich einige timestamptz-Funktionen wie date_trunc als Indexfeld herausstellen k√∂nnen.</font></font><br>
<br>
<pre><code class="plaintext hljs">nmt | nmi         | def              | nmf$  | tpf$             | opc$<font></font>
----------------------------------------------------------------------------------<font></font>
tbl | tbl_b_a_idx | CREATE INDEX ... | {b,a} | {timestamp,int4} | {timestamp,int4}<font></font>
</code></pre><br>
<h4><font color="#c04000"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlecht: zu wenig (boolesch)</font></font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Kehrseite derselben M√ºnze wird zu einer Situation, in der der Index ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolesches Feld ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , das nur 3 Werte annehmen kann </font></font><code>NULL, FALSE, TRUE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Das Vorhandensein ist nat√ºrlich sinnvoll, wenn Sie es f√ºr die angewandte Sortierung verwenden m√∂chten, indem Sie sie beispielsweise als Knotentyp in der Baumhierarchie festlegen, unabh√§ngig davon, ob es sich um einen Ordner oder ein Blatt handelt (‚ÄûOrdner zuerst‚Äú).</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, leaf_pid<font></font>
    <span class="hljs-built_in">integer</span><font></font>
, leaf_type<font></font>
    <span class="hljs-built_in">boolean</span>
, <span class="hljs-keyword">public</span>
    <span class="hljs-built_in">boolean</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(leaf_pid, leaf_type); <span class="hljs-comment">--   </span>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">public</span>, <span class="hljs-keyword">id</span>); <span class="hljs-comment">-- - </span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen ist dies jedoch nicht der Fall, und Anforderungen haben einen bestimmten Wert f√ºr das boolesche Feld. </font><font style="vertical-align: inherit;">Und dann wird es m√∂glich, den Index durch dieses Feld durch seine bedingte Version zu ersetzen:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">public</span>;</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boolesche Suchabfrage in Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">replace</span>(opcname::<span class="hljs-built_in">text</span>, <span class="hljs-string">'_ops'</span>, <span class="hljs-string">''</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indclass[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indclass, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_opclass T<font></font>
        <span class="hljs-keyword">ON</span> T.oid = f.ik<font></font>
  ) opc$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span><font></font>
    idx.indisvalid<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, <span class="hljs-keyword">def</span><font></font>
, nmf$<font></font>
, tpf$<font></font>
, opc$<font></font>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span><font></font>
  (<font></font>
    <span class="hljs-string">'bool'</span> = <span class="hljs-keyword">ANY</span>(tpf$) <span class="hljs-keyword">OR</span>
    <span class="hljs-string">'bool'</span> = <span class="hljs-keyword">ANY</span>(opc$)<font></font>
  ) <span class="hljs-keyword">AND</span>
  <span class="hljs-keyword">NOT</span>(
    <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span>
        nmf$[i:i+<span class="hljs-number">1</span>]::<span class="hljs-built_in">text</span>
      <span class="hljs-keyword">FROM</span>
        generate_series(<span class="hljs-number">1</span>, array_length(nmf$, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>) i<font></font>
    ) &amp;&amp;<font></font>
    <span class="hljs-built_in">ARRAY</span>[ <span class="hljs-comment">--  -  </span>
      <span class="hljs-string">'{leaf_pid,leaf_type}'</span><font></font>
    ]<font></font>
  )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">nmt | nmi               | def              | nmf$        | tpf$        | opc$<font></font>
------------------------------------------------------------------------------------<font></font>
tbl | tbl_public_id_idx | CREATE INDEX ... | {public,id} | {bool,int4} | {bool,int4}<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arrays in btree</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein separater Punkt ist der Versuch, das Array mithilfe des btree-Index zu "indizieren". </font><font style="vertical-align: inherit;">Dies ist durchaus m√∂glich, da f√ºr sie die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entsprechenden Operatoren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelten </font><font style="vertical-align: inherit;">:</font></font><br>
<blockquote><b> </b>  (<code>&lt;, &gt;, =</code>  . .)     ,       B-,       ,      .        (      ).     ,   ,         .</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Problem ist jedoch, dass er etwas verwendet, das er f√ºr </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operatoren von Inklusion und Schnittmenge</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwenden m√∂chte </font><font style="vertical-align: inherit;">: </font></font><code>&lt;@, @&gt;, &amp;&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dies funktioniert nat√ºrlich nicht - da sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">andere Arten von Indizes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ben√∂tigen </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wie ein solcher Baum f√ºr die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Funktion des Zugriffs auf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein bestimmtes Element </font><font style="vertical-align: inherit;">nicht </font><b><font style="vertical-align: inherit;">funktioniert</font></b></font><code>arr[i]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir lernen solche zu finden:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, pid<font></font>
    <span class="hljs-built_in">integer</span>
, <span class="hljs-keyword">list</span>
    <span class="hljs-built_in">integer</span>[]<font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(pid);
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(<span class="hljs-keyword">list</span>); <span class="hljs-comment">-- - </span>
</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array-Suchabfrage in btree</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  , idx<font></font>
, (<font></font>
    <span class="hljs-keyword">SELECT</span>
      array_agg(T::<span class="hljs-built_in">text</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> f.i)
    <span class="hljs-keyword">FROM</span><font></font>
      (<font></font>
        <span class="hljs-keyword">SELECT</span><font></font>
          clr.oid rel<font></font>
        , i<font></font>
        , idx.indkey[i] ik<font></font>
        <span class="hljs-keyword">FROM</span>
          generate_subscripts(idx.indkey, <span class="hljs-number">1</span>) i<font></font>
      ) f<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      pg_attribute T<font></font>
        <span class="hljs-keyword">ON</span> (T.attrelid, T.attnum) = (f.rel, f.ik)<font></font>
  ) fld$<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisunique <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span>
    idx.indisvalid <span class="hljs-keyword">AND</span><font></font>
    cli.relam = (<font></font>
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-keyword">oid</span>
      <span class="hljs-keyword">FROM</span><font></font>
        pg_am<font></font>
      <span class="hljs-keyword">WHERE</span>
        amname = <span class="hljs-string">'btree'</span>
      <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><font></font>
    )<font></font>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (att::pg_attribute).attname<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) nmf$<font></font>
  , <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span><font></font>
        (<font></font>
          <span class="hljs-keyword">SELECT</span><font></font>
            typname<font></font>
          <span class="hljs-keyword">FROM</span><font></font>
            pg_type<font></font>
          <span class="hljs-keyword">WHERE</span>
            <span class="hljs-keyword">oid</span> = (att::pg_attribute).atttypid<font></font>
        )<font></font>
      <span class="hljs-keyword">FROM</span>
        <span class="hljs-keyword">unnest</span>(fld$) att<font></font>
    ) tpf$<font></font>
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  nmt<font></font>
, nmi<font></font>
, nmf$<font></font>
, tpf$<font></font>
, <span class="hljs-keyword">def</span>
<span class="hljs-keyword">FROM</span><font></font>
  fld<font></font>
<span class="hljs-keyword">WHERE</span>
  tpf$ &amp;&amp; <span class="hljs-built_in">ARRAY</span>(
    <span class="hljs-keyword">SELECT</span><font></font>
      typname<font></font>
    <span class="hljs-keyword">FROM</span><font></font>
      pg_type<font></font>
    <span class="hljs-keyword">WHERE</span>
      typname ~ <span class="hljs-string">'^_'</span><font></font>
  )<font></font>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">nmt | nmi          | nmf$   | tpf$    | def<font></font>
--------------------------------------------------------<font></font>
tbl | tbl_list_idx | {list} | {_int4} | CREATE INDEX ...<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NULL-Indexeintr√§ge</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte h√§ufig auftretende Problem besteht darin, den Index mit vollst√§ndig NULL-Eintr√§gen zu ‚Äûverschmutzen‚Äú. </font><font style="vertical-align: inherit;">Das hei√üt, Datens√§tze, bei denen der indizierte Ausdruck </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in jeder der Spalten NULL ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Solche Aufzeichnungen haben keinen praktischen Nutzen, aber sie f√ºgen jedem Einsatz Schaden zu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Normalerweise werden sie angezeigt, wenn Sie ein FK-Feld oder eine Wertebeziehung mit optionalem Auff√ºllen in der Tabelle erstellen. </font><font style="vertical-align: inherit;">Dann rollen Sie den Index, damit FK schnell funktioniert ... und hier sind sie. </font><font style="vertical-align: inherit;">Je seltener die Verbindung gef√ºllt wird, desto mehr ‚ÄûM√ºll‚Äú f√§llt in den Index. </font><font style="vertical-align: inherit;">Wir werden simulieren:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tbl(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">serial</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, fk<font></font>
    <span class="hljs-built_in">integer</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(fk);<font></font>
<font></font>
<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tbl(fk)
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">CASE</span> <span class="hljs-keyword">WHEN</span> i % <span class="hljs-number">10</span> = <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span> i <span class="hljs-keyword">END</span>
<span class="hljs-keyword">FROM</span>
  generate_series(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>) i;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den meisten F√§llen kann ein solcher Index in einen bedingten Index konvertiert werden, der auch weniger ben√∂tigt:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> tbl(fk) <span class="hljs-keyword">WHERE</span> (fk) <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>;</code></pre><br>
<pre><code class="plaintext hljs">_tmp=# \di+ tbl*<font></font>
                               List of relations<font></font>
 Schema |      Name      | Type  |  Owner   |  Table   |  Size   | Description<font></font>
--------+----------------+-------+----------+----------+---------+-------------<font></font>
 public | tbl_fk_idx     | index | postgres | tbl      | 36 MB   |<font></font>
 public | tbl_fk_idx1    | index | postgres | tbl      | 2208 kB |<font></font>
 public | tbl_pkey       | index | postgres | tbl      | 21 MB   |<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um solche Indizes zu finden, m√ºssen wir die tats√§chliche Verteilung der Daten kennen - das hei√üt, wir m√ºssen den gesamten Inhalt der Tabellen lesen und ihn gem√§√ü den WHERE-Bedingungen des Auftretens √ºberlagern (wir werden dies mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dblink</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tun </font><font style="vertical-align: inherit;">), was </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr lange dauern kann</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchabfrage nach NULL-Eintr√§gen in Indizes</font></font></b><div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> sch <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-string">'public'</span>::<span class="hljs-built_in">text</span> sch <span class="hljs-comment">-- schema</span><font></font>
)<font></font>
, <span class="hljs-keyword">def</span> <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    clr.relname nmt<font></font>
  , cli.relname nmi<font></font>
  , pg_get_indexdef(cli.oid) <span class="hljs-keyword">def</span><font></font>
  , cli.oid clioid<font></font>
  , clr<font></font>
  , cli<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    pg_class clr<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_index idx<font></font>
      <span class="hljs-keyword">ON</span> idx.indrelid = clr.oid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_class cli<font></font>
      <span class="hljs-keyword">ON</span> cli.oid = idx.indexrelid
  <span class="hljs-keyword">JOIN</span><font></font>
    pg_namespace nsp<font></font>
      <span class="hljs-keyword">ON</span> nsp.oid = cli.relnamespace <span class="hljs-keyword">AND</span>
      nsp.nspname = (<span class="hljs-keyword">TABLE</span> sch)
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">NOT</span> idx.indisprimary <span class="hljs-keyword">AND</span>
    idx.indisready <span class="hljs-keyword">AND</span>
    idx.indisvalid <span class="hljs-keyword">AND</span>
    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>(
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-literal">NULL</span>
      <span class="hljs-keyword">FROM</span><font></font>
        pg_constraint<font></font>
      <span class="hljs-keyword">WHERE</span><font></font>
        conindid = cli.oid<font></font>
      <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span>
    ) <span class="hljs-keyword">AND</span>
    pg_relation_size(cli.oid) &gt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">20</span> <span class="hljs-comment">--  1MB   </span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><font></font>
    clr.relname, cli.relname<font></font>
)<font></font>
, fld <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , regexp_replace(<font></font>
      <span class="hljs-keyword">CASE</span>
        <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' USING btree '</span> <span class="hljs-keyword">THEN</span>
          regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* USING btree (.*?)($| WHERE .*)'</span>, E<span class="hljs-string">'\\1'</span>)
      <span class="hljs-keyword">END</span>
    , E<span class="hljs-string">' ([a-z]*_pattern_ops|(ASC|DESC)|NULLS\\s?(?:FIRST|LAST))'</span>
    , <span class="hljs-string">''</span>
    , <span class="hljs-string">'ig'</span><font></font>
    ) fld<font></font>
  , <span class="hljs-keyword">CASE</span>
      <span class="hljs-keyword">WHEN</span> <span class="hljs-keyword">def</span> ~ <span class="hljs-string">' WHERE '</span> <span class="hljs-keyword">THEN</span> regexp_replace(<span class="hljs-keyword">def</span>, E<span class="hljs-string">'.* WHERE '</span>, <span class="hljs-string">''</span>)
    <span class="hljs-keyword">END</span> wh
  <span class="hljs-keyword">FROM</span>
    <span class="hljs-keyword">def</span><font></font>
)<font></font>
, q <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt<font></font>
  , $q$<span class="hljs-comment">-- $q$ || quote_ident(nmt) || $q$</span>
      <span class="hljs-keyword">SET</span> search_path = $q$ || quote_ident((<span class="hljs-keyword">TABLE</span> sch)) || $q$, <span class="hljs-keyword">public</span>;
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-built_in">ARRAY</span>[
          <span class="hljs-keyword">count</span>(*)<font></font>
        $q$ || string_agg(<font></font>
          <span class="hljs-string">', coalesce(sum(('</span> || <span class="hljs-keyword">coalesce</span>(wh, <span class="hljs-string">'TRUE'</span>) || <span class="hljs-string">')::integer), 0)'</span> || E<span class="hljs-string">'\n'</span> ||
          <span class="hljs-string">', coalesce(sum((('</span> || <span class="hljs-keyword">coalesce</span>(wh, <span class="hljs-string">'TRUE'</span>) || <span class="hljs-string">') AND ('</span> || fld || <span class="hljs-string">' IS NULL))::integer), 0)'</span> || E<span class="hljs-string">'\n'</span>
        , <span class="hljs-string">''</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) || $q$<font></font>
        ]<font></font>
      <span class="hljs-keyword">FROM</span>
        $q$ || quote_ident((<span class="hljs-keyword">TABLE</span> sch)) || $q$.$q$ || quote_ident(nmt) || $q$<font></font>
    $q$ q<font></font>
  , array_agg(clioid <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) <span class="hljs-keyword">oid</span>$<font></font>
  , array_agg(nmi <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) idx$<font></font>
  , array_agg(fld <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) fld$<font></font>
  , array_agg(wh <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> nmi) wh$
  <span class="hljs-keyword">FROM</span><font></font>
    fld<font></font>
  <span class="hljs-keyword">WHERE</span>
    fld <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
  <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span>
  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
    <span class="hljs-number">1</span><font></font>
)<font></font>
, res <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , (<font></font>
      <span class="hljs-keyword">SELECT</span><font></font>
        qty<font></font>
      <span class="hljs-keyword">FROM</span><font></font>
        dblink(<font></font>
          <span class="hljs-string">'dbname='</span> || current_database() || <span class="hljs-string">' port='</span> || current_setting(<span class="hljs-string">'port'</span>)<font></font>
        , q<font></font>
        ) T(qty <span class="hljs-built_in">bigint</span>[])<font></font>
    ) qty<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    q<font></font>
)<font></font>
, iter <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    *<font></font>
  , generate_subscripts(idx$, <span class="hljs-number">1</span>) i
  <span class="hljs-keyword">FROM</span><font></font>
    res<font></font>
)<font></font>
, stat <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    nmt table_name<font></font>
  , idx$[i] index_name<font></font>
  , pg_relation_size(<span class="hljs-keyword">oid</span>$[i]) index_size<font></font>
  , pg_size_pretty(pg_relation_size(<span class="hljs-keyword">oid</span>$[i])) index_size_humanize<font></font>
  , regexp_replace(fld$[i], E<span class="hljs-string">'^\\((.*)\\)$'</span>, E<span class="hljs-string">'\\1'</span>) index_fields<font></font>
  , regexp_replace(wh$[i], E<span class="hljs-string">'^\\((.*)\\)$'</span>, E<span class="hljs-string">'\\1'</span>) index_cond<font></font>
  , qty[<span class="hljs-number">1</span>] table_rec_count<font></font>
  , qty[i * <span class="hljs-number">2</span>] index_rec_count<font></font>
  , qty[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] index_rec_count_null
  <span class="hljs-keyword">FROM</span><font></font>
    iter<font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span><font></font>
  *<font></font>
, <span class="hljs-keyword">CASE</span>
    <span class="hljs-keyword">WHEN</span> table_rec_count &gt; <span class="hljs-number">0</span>
      <span class="hljs-keyword">THEN</span> index_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> / table_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> * <span class="hljs-number">100</span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">END</span>::<span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>) index_cover_prc<font></font>
, <span class="hljs-keyword">CASE</span>
    <span class="hljs-keyword">WHEN</span> index_rec_count &gt; <span class="hljs-number">0</span>
      <span class="hljs-keyword">THEN</span> index_rec_count_null::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> / index_rec_count::<span class="hljs-keyword">double</span> <span class="hljs-keyword">precision</span> * <span class="hljs-number">100</span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">END</span>::<span class="hljs-built_in">numeric</span>(<span class="hljs-number">32</span>,<span class="hljs-number">2</span>) index_null_prc
<span class="hljs-keyword">FROM</span><font></font>
  stat<font></font>
<span class="hljs-keyword">WHERE</span>
  index_rec_count_null * <span class="hljs-number">4</span> &gt; index_rec_count <span class="hljs-comment">--   NULL-</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>, <span class="hljs-number">2</span>;</code></pre></div></div><br>
<pre><code class="plaintext hljs">-[ RECORD 1 ]--------+--------------<font></font>
table_name           | tbl<font></font>
index_name           | tbl_fk_idx<font></font>
index_size           | 37838848<font></font>
index_size_humanize  | 36 MB<font></font>
index_fields         | fk<font></font>
index_cond           |<font></font>
table_rec_count      | 1000000<font></font>
index_rec_count      | 1000000<font></font>
index_rec_count_null | 900000<font></font>
index_cover_prc      | 100.00 -- 100%    <font></font>
index_null_prc       | 90.00  --   90% NULL-""<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich hoffe, einige der Fragen in diesem Artikel werden Ihnen helfen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de488088/index.html">Wie Habr mit staatlichen Stellen und anderen Antragstellern umgeht. Transparenzbericht f√ºr alle Jahre</a></li>
<li><a href="../de488092/index.html">Hackathons. Wie man das Beste herausholt und √ºberlebt</a></li>
<li><a href="../de488096/index.html">400 g. Blick von der Seite des Getriebes. ZR / ZR +</a></li>
<li><a href="../de488098/index.html">So erstellen Sie ein Django-Projekt aus einer Vorlage</a></li>
<li><a href="../de488102/index.html">Die Beziehung zwischen C # und C #: REST, gRPC und alles dazwischen</a></li>
<li><a href="../de488108/index.html">SAP HANA Lab in Azure</a></li>
<li><a href="../de488112/index.html">Grundlegendes zu Iteratoren in Python</a></li>
<li><a href="../de488116/index.html">F√ºnf wichtige Lektionen zur Spielbalance</a></li>
<li><a href="../de488118/index.html">Haxe Winter Statusbericht</a></li>
<li><a href="../de488120/index.html">Warum lohnt es sich, ein 64-Bit-Betriebssystem auf dem Raspberry Pi4 zu installieren?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>