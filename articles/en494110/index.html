<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôáüèø üõå üë®üèª‚Äçüöí Property-based testing for JavaScript and UI: an unusual approach to automated tests ü§ò ‚ò£Ô∏è üöô</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Falcon Heavy Demo Mission
 
 Writing tests is boring. And what is boring to do is constantly delayed. My name is Nazim Gafarov, I am an interface deve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Property-based testing for JavaScript and UI: an unusual approach to automated tests</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/494110/"><img src="https://habrastorage.org/webt/cv/a8/98/cva898pabv5cwmeqrewsi_27lry.jpeg" alt="Elon Musk's Tesla Roadster"><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Falcon Heavy Demo Mission</font></font></a></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Writing tests is boring. </font><font style="vertical-align: inherit;">And what is boring to do is constantly delayed. </font><font style="vertical-align: inherit;">My name is Nazim Gafarov, I am an interface developer at</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mail.ru Cloud Solutions</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in this article I will show you a different, slightly strange approach to automated testing.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is wrong with conventional testing and what to do</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, imagine that you have a summing function like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
   <span class="hljs-keyword">return</span> a + b<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We all understand the importance of unit tests. </font><font style="vertical-align: inherit;">Let's write a test for this function:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> {equal} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'assert'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> actual = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> expected = <span class="hljs-number">3</span><font></font>
<font></font>
equal(actual, expected)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We pass 1 and 2 to the input, we expect 3 at the output. Everything is simple - this is a classic unit-testing based on examples, the so-called example-based testing. </font><font style="vertical-align: inherit;">The test works, everyone is happy, you can roll to the prod. </font><font style="vertical-align: inherit;">But then your colleague, a fabulous enterprise programmer, comes into play. </font><font style="vertical-align: inherit;">Once he needed your summation function, but for some reason he decided to tweak it a bit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is some problem in this code, but on the other hand, all tests pass, and TDD teaches us that we need to write minimal code that will make your tests pass. </font><font style="vertical-align: inherit;">This is true. </font><font style="vertical-align: inherit;">Overcoming your teenage anger, you write another test - pass 4 and 8, expect 12:</font></font><br>
<br>
<pre><code class="javascript hljs">equal(<font></font>
 sum(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>),
 <span class="hljs-number">12</span><font></font>
)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the enterprise programmer does not calm down. </font><font style="vertical-align: inherit;">It once again corrects the summation function so that the tests do not fail:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">a, b</span>) </span>{
 <span class="hljs-keyword">if</span> (a == <span class="hljs-number">4</span> &amp;&amp; b == <span class="hljs-number">8</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">12</span>
 <span class="hljs-keyword">return</span> <span class="hljs-number">3</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You could add more examples to the test suite, and this would go on ad infinitum. </font><font style="vertical-align: inherit;">At this moment you think: ‚ÄúWhy did they only hire him?‚Äù, But nowhere to go. </font><font style="vertical-align: inherit;">You release your secret weapon - randomly:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">Math</span>.random()
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">Math</span>.random()
<span class="hljs-keyword">const</span> actual = sum(a, b)
<span class="hljs-keyword">const</span> expected = a + b<font></font>
<font></font>
equal(actual, expected)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now everything is fine, but the huge problem with such a test is that you duplicate the implementation of the function in the test code. </font><font style="vertical-align: inherit;">That is, use one implementation to test another:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now you have two implementations of the same function that you need to keep up to date;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">obviously, the summation function is pretty primitive, but imagine if your code does something more complicated than summation.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, when we test the code this way, we understand that this is some cunning, because we tested it on only two pairs of input data.</font></font><br>
<br>
<pre><code class="javascript hljs">equal( sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), <span class="hljs-number">3</span> )<font></font>
equal( sum(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>), <span class="hljs-number">12</span> )
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This test shows that the code only works correctly in these two cases. The best of us realize that it‚Äôs good to test boundary cases like negative numbers, floating point numbers, and others. But this still reflects the bias of the developer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Again, there is a problem with the damned Enterprise Programmer (The Enterprise Developer From Hell). This term was introduced by </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scott Vlashin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a well-known popularizer of F #. You might think that an enterprise programmer is unrealistic. It is clear that in a healthy company, not a single normal person will break functions, but in many cases we ourselves act in this way.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We write functions much more complicated than A + B, and in the process of implementation we can write code that works in particular particular cases, and not in general. </font><font style="vertical-align: inherit;">This is not due to malice, but unintentionally, due to unconsciousness and blindness. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So what can we do with this. </font><font style="vertical-align: inherit;">Let's think. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A + B</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
It makes no sense to tie tests for A or B, you need to test what is in the middle, the plus sign itself. </font><font style="vertical-align: inherit;">That is, you need to write a test that focuses not on input and output, but on properties. </font><font style="vertical-align: inherit;">These properties must be true for any proper implementation. </font><font style="vertical-align: inherit;">Therefore, let's think about what properties summation has.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commutativity</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to the school curriculum, we know this property: "the amount does not change from a change in the places of the terms." </font><font style="vertical-align: inherit;">That is, addition has the property of shifting - commutativity. </font><font style="vertical-align: inherit;">Let's write a test that will verify that our implementation matches this property:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> actual = sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
<span class="hljs-keyword">const</span> expected = sum(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<font></font>
<font></font>
equal(actual, expected)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The good thing about this test is that it works with any input, not just special magic numbers. </font><font style="vertical-align: inherit;">Nothing prevents us from doing something like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> rand = <span class="hljs-built_in">Math</span>.random
<span class="hljs-keyword">const</span> [n1, n2] = [ rand(), rand() ]<font></font>
<font></font>
<span class="hljs-keyword">const</span> actual = sum( n1, n2 )
<span class="hljs-keyword">const</span> expected = sum( n2, n1 )<font></font>
<font></font>
equal(actual, expected)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The addition of two numbers is not something we do every day, but a similar approach can be used not only for mathematical operations, but also for testing real web services, databases and even interfaces. </font><font style="vertical-align: inherit;">Therefore, the following example with the division of two numbers:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">div</span> (<span class="hljs-params">dividend, divisor</span>) </span>{
 <span class="hljs-keyword">return</span> dividend / divisor<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We go to Wikipedia, and it turns out that division has the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">distributive</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> property </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">on the right</font></a><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It means that dividing the sum of two numbers by some divisor is the same as dividing them separately. </font><font style="vertical-align: inherit;">Great, let's test this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [rand(), rand(), rand()]<font></font>
<font></font>
<span class="hljs-keyword">const</span> left = div(n1 + n2, n3)
<span class="hljs-keyword">const</span> right = div(n1, n3) + div(n2, n3)<font></font>
<font></font>
equal(left, right)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we run this test in a loop many, many times and with due patience we get the following combination of input data:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the test fails, because dividing zero by zero gives NaN:</font></font><br>
<br>
<pre><code class="javascript hljs">assert.js:<span class="hljs-number">85</span>
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(obj);<font></font>
 ^<font></font>
<font></font>
AssertionError [ERR_ASSERTION]: <span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And NaN, as you know, is not equal to NaN. </font><font style="vertical-align: inherit;">This is normal JavaScript behavior, but now we understand that in our division function, we need to check for zeros. </font><font style="vertical-align: inherit;">We spin our test in a cycle further, each time generating a new portion of random data. </font><font style="vertical-align: inherit;">At some point, we get the following combination:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> [n1, n2, n3] = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-347</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the test falls again:</font></font><br>
<br>
<pre><code class="javascript hljs">assert.js:<span class="hljs-number">85</span>
 <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError(obj);<font></font>
 ^<font></font>
<font></font>
AssertionError [ERR_ASSERTION]:<font></font>
<span class="hljs-number">-0.008645533141210375</span> == <span class="hljs-number">-0.008645533141210374</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inaccuracy of rounding</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> floating point numbers. </font><font style="vertical-align: inherit;">That is, again, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">normal limitations of the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> calculations, but when we generate the input data, these restrictions become explicit. </font><font style="vertical-align: inherit;">Now, in our function, we need to think about explicit rounding or an algorithm that will reduce the computational error, for example, the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kakhan Grandma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algorithm </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would seem that we wrote a regular test, but there are no magic values ‚Äã‚Äãtaken from our imagination. </font><font style="vertical-align: inherit;">We use arbitrary values ‚Äã‚Äãand get the opportunity to run the test many, many times on different input data, checking the specification itself, that is, what the function should do, and not its behavior with single examples.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is property-based testing. </font><font style="vertical-align: inherit;">That is a combination of the following things:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we describe the input data - we tell the system what random data needs to be generated.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we describe the expected properties - some conditions for passing the test.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And then just run this test many, many times.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to identify properties?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To identify a property for your specific function, you first need to formulate requirements. </font><font style="vertical-align: inherit;">With such testing, you don‚Äôt even need to generate random data. </font><font style="vertical-align: inherit;">You can check the properties on specific examples, for example, on very different values, some boundary cases. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But first of all, we want to make sure that our function is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identical on a given set</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">That is, it works correctly on all valid values.</font></font><br>
<br>
<math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo stretchy=&quot;false&quot;>(</mo><mi mathvariant=&quot;normal&quot;>&amp;#x2200;</mi><mi>x</mi><mo>&amp;#x2208;</mo><mi>X</mi><mo stretchy=&quot;false&quot;>)</mo><mi>P</mi><mo stretchy=&quot;false&quot;>(</mo><mi>x</mi><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="14.137ex" height="2.634ex" viewBox="0 -809.3 6086.6 1134.2" role="img" focusable="false" style="vertical-align: -0.755ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-28" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-2200" x="389" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMATHI-78" x="946" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-2208" x="1796" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMATHI-58" x="2741" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-29" x="3594" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMATHI-50" x="3983" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-28" x="4735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMATHI-78" x="5124" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://habr.com/ru/company/mailru/blog/494110/&amp;usg=ALkJrhgZl8RTgSYCTs02XwJ6MjiD0KaWrQ#MJMAIN-29" x="5697" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo stretchy="false">(</mo><mi mathvariant="normal">‚àÄ</mi><mi>x</mi><mo>‚àà</mo><mi>X</mi><mo stretchy="false">)</mo><mi>P</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1">(\forall x\in X) P(x)</script><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, no one forbids driving a test in a cycle by manually substituting these X's, but we definitely need a reliable way to reproduce fallen tests. </font><font style="vertical-align: inherit;">Fortunately, there are ready-made frameworks for this.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frameworks</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you know, all the best in programming was originally invented in the Haskell world. </font><font style="vertical-align: inherit;">20 years ago, the idea of ‚Äã‚Äãproperty testing was implemented in the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QuickCheck</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> framework </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now this form of testing in the Haskell ecosystem is actually dominant. </font><font style="vertical-align: inherit;">There are several libraries for JavaScript, but I will focus on two: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JSVerify</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast-check</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> jsc = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jsverify'</span>)<font></font>
<font></font>
jsc.assertForall(<font></font>
 jsc.integer, jsc.integer,<font></font>
 (a, b) =&gt; a + b === b + a<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a simple test for the translational property of addition, which we talked about at the beginning. Since we have an untyped language, we need to somehow tell the framework what arguments we expect. Here we say that we need two numbers and with the last argument we pass the predicate. By default, JSVerify will run the test a hundred times, each time generating a new pair of input values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's check the relocation property of subtraction. Of course, subtraction does not have such a property, so we get an object with an error and conclude it:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> subtractionIsCommutative = jsc.checkForall(<font></font>
 jsc.integer, jsc.integer,<font></font>
 (a, b) =&gt; a - b === b - a<font></font>
)<font></font>
<font></font>
<span class="hljs-built_in">console</span>.log(subtractionIsCommutative)<font></font>
<font></font>
{<font></font>
 <span class="hljs-attr">counterexample</span>: [ <span class="hljs-number">0</span>, <span class="hljs-number">1</span> ],
 <span class="hljs-attr">tests</span>: <span class="hljs-number">1</span>,
 <span class="hljs-attr">shrinks</span>: <span class="hljs-number">4</span>,
 <span class="hljs-attr">rngState</span>: <span class="hljs-string">'0e168f30eac572b94d'</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The system says that it fell after the very first test on counterexamples 0 and 1. RngState is the state of the random number generator. </font><font style="vertical-align: inherit;">In this case, the test data is randomly determined. </font><font style="vertical-align: inherit;">Random number generator displays a seed for us, which can be slipped into the test runner to reproduce the fallen case. </font><font style="vertical-align: inherit;">It is convenient for debugging, helps with reproducibility in CI / CD.</font></font><br>
<br>
<pre><code class="bash hljs">mocha test.js --jsverifyRngState 0e168f30eac572b94d</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSVerify has a small DSL for types, which allows you to slightly reduce the record. </font><font style="vertical-align: inherit;">Sometimes this is convenient, for example, when custom types are needed, it is easier to write like this:</font></font><br>
<br>
<pre><code class="javascript hljs">jsc.assert(jsc.forall(
 <span class="hljs-string">'{ name: asciinestring; age: nat }'</span>,<font></font>
 (obj) =&gt; {<font></font>
     <span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// { name: '9lfpy', age: 34 }</span>
     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
 }<font></font>
))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Than so:</font></font><br>
<br>
<pre><code class="javascript hljs">jsc.record({
 <span class="hljs-attr">name</span>: jsc.asciinestring,
 <span class="hljs-attr">age</span>: jsc.nat,<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Choose your preferred method. </font><font style="vertical-align: inherit;">So we can generate any of our own types, for example objects that come to us from the backend. </font><font style="vertical-align: inherit;">If there aren‚Äôt enough built-in generators, you can easily write your own. </font><font style="vertical-align: inherit;">Let's say you need not just a string, but a string with an email address. </font><font style="vertical-align: inherit;">You can generate it this way:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> emailGenerator = jsc<font></font>
 .asciinestring.generator<font></font>
 .map(<span class="hljs-function"><span class="hljs-params">str</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${str}</span>@example.com`</span>)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the real life</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's see how this can be applied in real life. </font><font style="vertical-align: inherit;">The </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">query-string</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library has </font><font style="vertical-align: inherit;">six million downloads per week. </font><font style="vertical-align: inherit;">This package is listed in the dependencies of more than four thousand other packages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Query-string does one simple thing - it parses a URL string into an object and, conversely, can generate a URL or part of it from an object:</font></font><br>
<br>
<pre><code class="javascript hljs">queryString.parseUrl(<span class="hljs-string">'https://foo.bar?foo=bar'</span>)
<span class="hljs-comment">//=&gt; {url: 'https://foo.bar', query: {foo: 'bar'}}</span><font></font>
<font></font>
queryString.stringify({<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">3</span>})
<span class="hljs-comment">//=&gt; 'b=1&amp;c=2&amp;a=3'</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Naturally, this library is covered in a bunch of classic example-based tests. A total of 400 lines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of test code</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But you cannot take into account all the options, no matter how many tests are written. Instead of inventing new examples, the author of the fast-check library wrote one single </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> focused on the properties of the library:</font></font><br>
<br>
<pre><code class="javascript hljs">fastCheck.property(<font></font>
 queryParamsArbitrary, optionsArbitrary,<font></font>
 (object, options) =&gt; deepEqual(<font></font>
   queryString.parse(queryString.stringify(object, options), options),<font></font>
   object<font></font>
 )<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Query-string is a classic inversion, that is, any object must be converted to a query-string, and if this string is parse, then the original object should be obtained. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you know, he immediately caught a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He used the same approach to test the infamous left-pad library and discovered a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bug</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with strings that contained characters outside </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Unicode</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> main </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">plane</font></a><font style="vertical-align: inherit;"> , for example emoji. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But how did he manage to easily deduce properties that find bugs? </font><font style="vertical-align: inherit;">All because he is familiar with popular properties. </font><font style="vertical-align: inherit;">Let's look at them too.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inversion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The approach is also known as Bilbo testing in honor of Tolkien‚Äôs story ‚ÄúThere and Back.‚Äù </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say we have an encryption function. </font><font style="vertical-align: inherit;">If decryption is applied to the result, we should get the initial message:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> string = <span class="hljs-string">'ANY_STRING'</span>
<span class="hljs-keyword">const</span> encrypted = encrypt(string)<font></font>
<font></font>
expect( decrypt(encrypted) ).toBe( string )</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It doesn‚Äôt matter which message we have encrypted ‚Äî it can be any line. </font><font style="vertical-align: inherit;">Accordingly, we can generate it. </font><font style="vertical-align: inherit;">The same can be used for serialization-deserialization, encoding-decoding, lossless compression, and so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the property we saw when testing query-string:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> obj = {<span class="hljs-attr">any</span>: <span class="hljs-string">'object'</span>}<font></font>
<font></font>
_.isEqual(<font></font>
   <span class="hljs-built_in">JSON</span>.parse( <span class="hljs-built_in">JSON</span>.stringify(obj) ),<font></font>
   obj,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Write / read, insert / search also match this pattern, even if they are not strict inversions.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reversibility</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also a special case of inversion is a round-trip. </font><font style="vertical-align: inherit;">This is when we take a reversible function and apply it twice:</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].reverse().reverse(),<font></font>
 array,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, if our function flips the array, we can generate an array with any data inside, flip it twice and the resulting result should match the original array.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Invariance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A search for invariants is a search for something that does not change when a function is applied. </font><font style="vertical-align: inherit;">Let's say we have a sort function. </font><font style="vertical-align: inherit;">If you apply sorting to any array, the length of this array should not change:</font></font><br>
<br>
<pre><code class="javascript hljs">equal(<font></font>
 [...array].sort().length,<font></font>
 array.length,<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, the elements of the array should not be changed either: they can change their order, but they themselves do not change - each element of the original array must be found in the sorted array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Size, length, content are excellent features to verify that your function does not change what it should not change. </font><font style="vertical-align: inherit;">Typically, such a check is not sufficient in itself, but often act as a counter-check to other properties.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idempotency</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, to the idempotency property. </font><font style="vertical-align: inherit;">When you reapply a function, this property will give the same result as when you first used it. </font><font style="vertical-align: inherit;">For example, if we sorted an array once, re-sorting will not change anything:</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].sort().sort(),<font></font>
 array.sort(),<font></font>
)</code></pre><br>
<pre><code class="javascript hljs">string.padStart(<span class="hljs-number">10</span>) === string.padStart(<span class="hljs-number">10</span>).padStart(<span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formatting, searching for unique values, normalizing, adding an existing element to a set - all these operations should not change anything when re-applied.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hard to prove, easy to check.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This property is usually illustrated by the example of a maze. </font><font style="vertical-align: inherit;">Finding a way out of the maze is difficult, but if your function knows how to find a way out, it is easy to test it - you just need to follow its instructions. </font><font style="vertical-align: inherit;">As a result, it should lead us to the exit. </font><font style="vertical-align: inherit;">We do not know the shortest path or not, but at least we are sure that this is the right path that leads to the exit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another example is again the sorting function. </font><font style="vertical-align: inherit;">Sorting an array correctly is quite difficult. </font><font style="vertical-align: inherit;">But we can easily check the result of sorting - we need to sequentially take the elements of the array and compare them with the subsequent ones. </font><font style="vertical-align: inherit;">If we sort in ascending order, then the current element should always be less than the next (or equal to it).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reference implementation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach is also called a test oracle. </font><font style="vertical-align: inherit;">Let's say we have two functions that do the same thing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, it occurred to us to implement our own sorting function. </font><font style="vertical-align: inherit;">At the same time, we have a sorting function built into JavaScript, which we take as a reference. </font><font style="vertical-align: inherit;">The idea of ‚Äã‚Äãthe test oracle is to compare the results of our sort with the results of the reference. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, we can generate random data, feed it into both functions and verify that the results match:</font></font><br>
<br>
<pre><code class="javascript hljs">_.isEqual(<font></font>
 [...array].sort(),<font></font>
 fastestSortingAlgorithm(array),<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a good template if you refactor old code. </font><font style="vertical-align: inherit;">You can make sure that the new implementation produces the same results as its old counterpart. </font><font style="vertical-align: inherit;">The test oracle in this case checks the correspondence property of the reference implementation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Just don't fall</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, the property is that the function at least does not fall. </font><font style="vertical-align: inherit;">This type of testing is called fuzzing, when we transfer incorrect or random data to the application input and see if the system crashes, whether there are freezes, violations of internal logic, or unexpected behavior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose we have an API - it doesn‚Äôt matter what pens we pull, what data we transfer, in any case, the server should not respond 500. This property itself makes little sense, but as a starting point it will do.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UI Testing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imagine that you have an online store with a basket of goods, you need to test it. </font><font style="vertical-align: inherit;">First you need to determine the available actions:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we can add goods to the basket;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remove goods;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Empty trash.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now let's reveal the properties. Offhand, you can say that the quantity of goods cannot be a negative quantity: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basket&gt; = 0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . At the same time, there can be no more goods in the basket than in the catalog: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basket &lt;= Catalog</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . And the sum of the entire basket cannot be less than the price of the most expensive product in it: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sum (Basket)&gt; = max (Goods)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then, in a cycle, you generate a valid sequence of actions many and many times and check all the properties after each step. Relatively speaking, in a random order you add something to the basket many, many times, delete something, empty it, and so on. And after each step, check the truth of all the properties.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With such testing, you can go through the user interface and click on buttons as in regular e2e tests. </font><font style="vertical-align: inherit;">But if you have a framework at the front where the presentation is a pure function of the model, then you can simply manipulate the model. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This approach was taken by Spotify developers to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test the playlist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pros and Cons of Property Based Testing</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pros</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Property-based tests replace many example-based tests, that is, you write less code, and you get a lot more tests.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such tests can themselves find extreme cases that you might not have thought about: division by zero, lines with emoji and the like.</font></font></li>
<li>  ,            ‚Äî -    ,   .     ,   .</li>
<li>    ,  ,     ,       .</li>
<li>      .     -,         ,   .</li>
</ol><br>
<h3></h3><br>
<ol>
<li>     .       .</li>
<li>     ,       . Property-based    ,  ,   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Each test needs to be run a hundred times, so the test execution time increases slightly.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such tests give a false sense of security. </font><font style="vertical-align: inherit;">Suppose you have identified several properties of a function and this gives you confidence that the implementation is correct. </font><font style="vertical-align: inherit;">However, a property may be necessary but not sufficient. </font><font style="vertical-align: inherit;">For example, a multiplication function has the property of being movable in the same way as summation, but these functions do slightly different things.</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findings</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We should not refuse classical tests, but we can combine them with testing on the basis of properties. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, you can cover the basic functionality with classic tests based on examples, and critical functions can be additionally covered with property tests.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a text version of the report from </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HolyJS Piter 2019</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda Meetup # 22</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What else to read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How technical debt kills your projects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My second year as an independent developer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our telegram channel with digital transformation news</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en494092/index.html">Degradation of the connected structure</a></li>
<li><a href="../en494094/index.html">3D do it yourself. Part 1: pixels and lines</a></li>
<li><a href="../en494096/index.html">Intranet deployment. Experience, mistakes, recommendations</a></li>
<li><a href="../en494098/index.html">Imperative approach to reactive data on the example of Jetbrains KTor and R2DBC</a></li>
<li><a href="../en494100/index.html">What you need to create the ideal model of an educational center for training IT-specialists</a></li>
<li><a href="../en494114/index.html">How to reduce the number and increase the readability of code in react-redux, redux-saga</a></li>
<li><a href="../en494118/index.html">COVID-19 Telegram-bot // We answer FAQ questions automatically</a></li>
<li><a href="../en494124/index.html">Assembling an 8-bit computer: how to reduce the number of chips to six</a></li>
<li><a href="../en494126/index.html">TOP SCIENCE. February Media Ten: Crab Zombie Feminists, Prehistoric Salamanders and Exaggerated Alcoholics</a></li>
<li><a href="../en494128/index.html">Hackspace Neuron - a meeting place for hackers in Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>