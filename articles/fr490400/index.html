<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üç± üßôüèΩ ü§∂üèæ Utilisation de la biblioth√®que OpenCV pour reconna√Ætre des arcs elliptiques dans des sections 2D de nuages ‚Äã‚Äãde points 3D üßëüèæ üóìÔ∏è üïê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En lien avec la plus large diffusion de scanners laser abordables (lidars) capables de recevoir des nuages ‚Äã‚Äãde points 3D ( 3dOT ) et l'application pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Utilisation de la biblioth√®que OpenCV pour reconna√Ætre des arcs elliptiques dans des sections 2D de nuages ‚Äã‚Äãde points 3D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lien avec la plus large diffusion de scanners laser abordables (lidars) capables de recevoir des nuages ‚Äã‚Äãde points 3D ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et l'application plus large de cette technologie dans divers domaines (de l'ing√©nierie m√©canique √† la s√©curit√©, de l'industrie p√©troli√®re √† l'architecture), l'int√©r√™t pour les algorithmes de traitement a repris. nuages ‚Äã‚Äãde points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'une des applications populaires de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans l'industrie est la cr√©ation de documentation de conception pour les √©quipements construits, anciens ou convertis, qui se composent g√©n√©ralement de pipelines et d'autres structures de g√©om√©trie cylindrique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour d√©tecter les primitives g√©om√©triques dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , des biblioth√®ques 3D sp√©cialis√©es, par exemple, </font><em><font style="vertical-align: inherit;">Microsoft PCL</font></em><font style="vertical-align: inherit;"> , sont g√©n√©ralement utilis√©es</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. L'approche avec l'utilisation de biblioth√®ques pr√™tes √† l'emploi, avec des avantages, pr√©sente des inconv√©nients. Par exemple, il est difficile de les int√©grer dans les sch√©mas de traitement Kadov existants, qui ont g√©n√©ralement une dimension 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment il serait possible de traiter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par exemple une station de pompage, en commen√ßant par des sections 2D et en utilisant tout l'arsenal de traitement 2D, qui est disponible dans des biblioth√®ques de traitement d'image fiables et optimis√©es, par exemple </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 1. Mod√®le OT 3D d'une station de pompage</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©l√©ment principal des sections obtenues en scannant diverses structures de tuyaux sont </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des arcs elliptiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2. Coupe horizontale d'un mod√®le 3D d'une station de pompage √† un niveau moyen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour cet article, nous limitons notre examen √† un algorithme cl√© qui nous permet de d√©tecter des arcs elliptiques arbitraires - il s'agit d'un algorithme it√©ratif pour la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">croissance de segments d'arc et la liaison de </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©gions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">croissance de r√©gions et liaison de bords</font></em><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les algorithmes de croissance sont les plus √©vidents et les plus facilement v√©rifiables, quoique longs en comparaison avec les algorithmes statistiques, qui conviennent mieux au cas o√π la sc√®ne contient des objets distants √† couplage l√¢che qui appartiennent √† une ellipse. </font><font style="vertical-align: inherit;">Ces algorithmes seront discut√©s dans de futurs articles.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'instant, pour des raisons de simplicit√©, nous omettons la proc√©dure d'obtention d'une section √† partir du fichier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source </font><font style="vertical-align: inherit;">, le pr√©traitement d'une section, son regroupement pour isoler les primitives g√©om√©triques, ainsi que la liaison, la rectification et les autres op√©rations photogramm√©triques n√©cessaires pour obtenir les param√®tres du mod√®le. Nous ne discuterons pas de la m√™me mani√®re le param√©trage des algorithmes de recherche heuristique. D√©crivons toutes les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√©rations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">base √†</font></i><font style="vertical-align: inherit;"> partir desquelles l'algorithme est construit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous supposons que nous devons d√©tecter (reconna√Ætre, classer) un arc elliptique (c'est-√†-dire calculer les param√®tres de l'ellipse, ainsi que l'angle initial et final de l'arc elliptique) dans cette image, d√©coup√©e dans la section horizontale du nuage de points. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3. L'un des arcs elliptiques de la section transversale du mod√®le 3D (apr√®s lissage)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de minimiser le travail avec le raster √† l'aveugle, nous effectuerons toutes les op√©rations avec le raster en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©crivant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proc√©dure </font><em><font style="vertical-align: inherit;">OpenCV </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recherche sur le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tapis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raster </font><font style="vertical-align: inherit;">tous les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> externes (sans formes internes) </font><font style="vertical-align: inherit;">sous la forme d'un vecteur de vecteurs de points entiers (en coordonn√©es raster):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit de notre op√©ration cl√©, qui dans certains cas simples </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©sout compl√®tement la t√¢che</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais comme les cas d√©g√©n√©r√©s ne sont pas toujours retrouv√©s, consid√©rons plus en d√©tail la technologie de traitement par contournage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'op√©ration inverse, g√©n√©rant un raster en fonction du circuit externe existant √† l'aide de la </font><font style="vertical-align: inherit;">fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , semble √©galement simple:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est √©galement tr√®s souvent utilis√© pour masquer les contours, dessiner ou calculer la surface. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, au stade initial, nous avons un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensemble de patchs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (morceaux d'une certaine courbe) qui doivent √™tre connect√©s en un arc elliptique, √©liminant les parties d'autres composants de la structure (par exemple, les attaches) ou le bruit optique provoqu√© par l'ombrage pendant la num√©risation et autres les raisons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cr√©ons une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction discriminante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui retournera le type de contour (ellipse, segment lin√©aire, hachures ou autre), ainsi que les points finaux du contour et son rectangle de contour pivot√©:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rapport entre la longueur et la largeur du rectangle permet de distinguer rapidement les contours proches </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des segments lin√©aires</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que les petits </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contours de bruit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rectangle pivot√© dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a un </font><font style="vertical-align: inherit;">syst√®me de coordonn√©es </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complexe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si ce n'est pas l'angle lui-m√™me qui est requis, mais ses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctions trigonom√©triques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est d'autant moins √©vident du contexte. Si la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur absolue de l'angle est utilis√©e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il faut tenir compte du fait que l' </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angle est compt√© de l'horizontale au premier bord du rectangle dans le sens antihoraire et a une valeur n√©gative</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les extr√©mit√©s des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contours elliptiques sont trouv√©es en utilisant notre proc√©dure, qui re√ßoit le </font><em><font style="vertical-align: inherit;">mat</font></em><font style="vertical-align: inherit;"> matriciel</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un contour discret extrait de l'image originale par masquage et renvoie le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©faut maximum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, ‚Ä¶ );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code principal de cette fonction est d'appeler deux proc√©dures </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re proc√©dure trouve un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polygone convexe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le contour √©tudi√©, la seconde - calcule tous les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©fauts de convexit√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne prenons que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le plus grand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©faut en termes de convexit√©, consid√©rant qu'il d√©termine les points terminaux du contour. Cela peut ne pas √™tre le cas si les limites externes ou internes du contour ont des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caract√©ristiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Afin de les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lisser</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous appliquons un lissage suppl√©mentaire au contour √©tudi√© (et non √† l'image enti√®re afin de ne pas ¬´brouiller¬ª les isthmes entre les contours et ne pas violer la topologie d'origine). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 4. Calcul du d√©faut de gonflement L' </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©finit par erreur le point final rouge. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finit correctement les points de terminaison. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'option (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> red√©finit les points d'extr√©mit√© sur la forme d'origine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque dans la technologie que nous avons adopt√©e, le circuit est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r√©g√©n√©r√© √†</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque fois </font><font style="vertical-align: inherit;">, nous devons rechercher √† nouveau les points de correspondance (ou plut√¥t leurs indices) par la proc√©dure de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recherche exhaustive</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les cas o√π il n'est pas possible de se d√©barrasser compl√®tement des fonctionnalit√©s, un mode suppl√©mentaire de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s√©paration d'arc</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a √©galement √©t√© impl√©ment√© </font><font style="vertical-align: inherit;">(travailler s√©par√©ment avec l'arc interne / externe). Ceci est important, par exemple, dans les cas o√π l'arc externe du contour est en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contact</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec d'autres objets ou est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bruyant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans ce cas, vous pouvez aller travailler avec l'arc interne. Dans ce cas, il n'est pas n√©cessaire de traiter s√©par√©ment les arcs externes et internes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, selon la formule bien connue du rapport de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexit√© de l'arc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rayon du</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cercle </font><font style="vertical-align: inherit;">est approximativement estim√© </font><font style="vertical-align: inherit;">et les ellipses trop grandes sont rejet√©es:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, pour tous les contours, leur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m√©trique de d√©faut de convexit√© a √©t√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trouv√©e </font><font style="vertical-align: inherit;">(ou ils sont class√©s comme lin√©aires ou petits et retir√©s de la proc√©dure). </font><font style="vertical-align: inherit;">√Ä la derni√®re √©tape, des param√®tres suppl√©mentaires sont ajout√©s √† la m√©trique d'origine, tels que le param√®tre de dimension pivot√©e, etc., et l'ensemble complet des m√©triques √† l'√©tude est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tri√© par taille</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme pour relier des segments d'arc aux points d'extr√©mit√©</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme de croissance est clair et √©vident: nous prenons le plus grand contour comme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et essayons de le cultiver, c'est-√†-dire de trouver et d'attacher les patchs les plus proches √† ses points finaux qui satisfont aux conditions de croissance. Dans la figure adulte, nous entrons dans l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc elliptique souhait√©</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Masquez et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soustrayez la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> figure de l'ensemble d'origine. Nous r√©p√©tons la proc√©dure de croissance </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'√† √©puisement de la s√©rie initiale</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La proc√©dure de base de l'algorithme de croissance ressemble √† ceci:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o√π </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contour</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le contour √† l'√©tude, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est son d√©faut de convexit√©, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le polygone convexe de toute la r√©gion, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la matrice tampon auxiliaire. √Ä la sortie, nous obtenons un contour d√©velopp√© par vecteur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La proc√©dure consiste en un cycle de tentatives de germination de la croissance, se terminant soit par l'√©puisement des patchs disponibles pour la croissance, soit limit√© par le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param√®tre du nombre maximal d'it√©rations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 5. Nombreux patchs pour la croissance sans graines La</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
principale difficult√© est de s√©lectionner les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patchs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les </font><i><font style="vertical-align: inherit;">plus proches</font></i><font style="vertical-align: inherit;"> des points d'extr√©mit√© du contour, de sorte que la figure ne pousse que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers l'avant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction tangentielle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous prenons la ligne moyenne appartenant √† l'arc au voisinage du point final. La </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 6</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affiche les candidats pour la connexion √† la graine √† une certaine it√©ration. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6. Graine entour√©e d'une pluralit√© de patchs candidats √† la croissance</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour chaque patch candidat, la m√©trique suivante est calcul√©e:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seuls les patchs qui tombent dans le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c√¥ne tangentiel sont</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pris en compte </font><font style="vertical-align: inherit;">. Ensuite, le patch avec la plus petite distance est s√©lectionn√© et, en imprimant la section de connexion dans le raster, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connecte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† l'extr√©mit√© correspondante de la graine. Pour l'autre extr√©mit√© de la graine, un patch correspondant aux param√®tres est recherch√© et, s'il est trouv√©, est √©galement connect√© √† la graine. Ensuite, la graine est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masqu√©e et soustraite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des nombreux patchs. La proc√©dure est r√©p√©t√©e depuis le tout d√©but. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä la fin de la proc√©dure de croissance, nous avons obtenu un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc elliptique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui reste √† v√©rifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, en utilisant le standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la proc√©dure que notre patch re√ßoit (sous la forme d'un chemin, nous nous souvenons que le chemin et le raster sont interchangeables avec nous) et renvoie la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimension pivot√©e</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-√†-dire une ellipse compl√®te.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous rejetons les ellipses trop grandes et trop petites, puis nous appliquons notre proc√©dure originale pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparer les zones de l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arc elliptique r√©sultant et le patch de croissance initial sous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forme raster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette proc√©dure comprend quelques astuces d√©guis√©es, nous allons donc omettre sa description pour l'instant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, nous trouvons les param√®tres restants de l'ellipse d√©tect√©e - les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angles de d√©but et de fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (nous connaissons d√©j√† les demi-axes de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour d√©terminer les angles de d√©but et de fin, nous proc√©dons comme suit: nous transformons notre ellipse compl√®te, de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retour au polygone,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et par d√©nombrement direct nous trouvons ses points les plus proches de nos extr√©mit√©s. Leurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordonn√©es angulaires</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en fait, les indices) et seront les angles de d√©but et de fin d'un arc elliptique. </font><font style="vertical-align: inherit;">En code, cela ressemble √† ceci (un peu simplifi√©):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre proc√©dure </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides prend</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en compte la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topologie de la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> travers√©e de l'arc elliptique. </font><font style="vertical-align: inherit;">Au total, huit cas possibles de contournement des indices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doivent √™tre consid√©r√©s </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Allons-nous le long du contour ext√©rieur ou int√©rieur, et lequel des indices est le plus grand, initial ou final? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code plus facile √† voir:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains r√©sultats de la d√©tection d'ellipses dans des cas complexes sont pr√©sent√©s √† la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les articles suivants, les m√©thodes de d√©tection statistique seront consid√©r√©es.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490386/index.html">Sinon, comment gagner de l'argent en bourse et r√©duire les risques: les actions des entreprises avec le paiement de dividendes</a></li>
<li><a href="../fr490390/index.html">Olga Makushenko, directrice g√©n√©rale de 101XP: ¬´5 erreurs cl√©s dans le d√©veloppement d'un jeu en tant qu'entreprise¬ª</a></li>
<li><a href="../fr490392/index.html">Catchain: algorithme de consensus TON Blockchain</a></li>
<li><a href="../fr490394/index.html">Commodore Amiga 500+: ne laissez personne s'en offusquer</a></li>
<li><a href="../fr490398/index.html">Poudlard rouge. Officiers, ou pourquoi un historien est comme un d√©tective</a></li>
<li><a href="../fr490404/index.html">Pourquoi et comment la 5G changera tout: technologie, mise en ≈ìuvre progressive et base d'√©l√©ments pour l'√©quipement d'abonn√©</a></li>
<li><a href="../fr490406/index.html">Inexprimablement attrayant: comment nous avons cr√©√© un haniot qui ne peut pas √™tre expos√©</a></li>
<li><a href="../fr490408/index.html">FreeBSD: –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ GNU/Linux</a></li>
<li><a href="../fr490410/index.html">Neurones vivants et artificiels connect√©s via Internet</a></li>
<li><a href="../fr490412/index.html">Peut-√™tre qu'on devrait se calmer un peu avec JavaScript?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>