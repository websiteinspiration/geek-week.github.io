<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍱 🧙🏽 🤶🏾 Utilisation de la bibliothèque OpenCV pour reconnaître des arcs elliptiques dans des sections 2D de nuages ​​de points 3D 🧑🏾 🗓️ 🕐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En lien avec la plus large diffusion de scanners laser abordables (lidars) capables de recevoir des nuages ​​de points 3D ( 3dOT ) et l'application pl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Utilisation de la bibliothèque OpenCV pour reconnaître des arcs elliptiques dans des sections 2D de nuages ​​de points 3D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En lien avec la plus large diffusion de scanners laser abordables (lidars) capables de recevoir des nuages ​​de points 3D ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et l'application plus large de cette technologie dans divers domaines (de l'ingénierie mécanique à la sécurité, de l'industrie pétrolière à l'architecture), l'intérêt pour les algorithmes de traitement a repris. nuages ​​de points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'une des applications populaires de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans l'industrie est la création de documentation de conception pour les équipements construits, anciens ou convertis, qui se composent généralement de pipelines et d'autres structures de géométrie cylindrique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour détecter les primitives géométriques dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , des bibliothèques 3D spécialisées, par exemple, </font><em><font style="vertical-align: inherit;">Microsoft PCL</font></em><font style="vertical-align: inherit;"> , sont généralement utilisées</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. L'approche avec l'utilisation de bibliothèques prêtes à l'emploi, avec des avantages, présente des inconvénients. Par exemple, il est difficile de les intégrer dans les schémas de traitement Kadov existants, qui ont généralement une dimension 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons comment il serait possible de traiter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , par exemple une station de pompage, en commençant par des sections 2D et en utilisant tout l'arsenal de traitement 2D, qui est disponible dans des bibliothèques de traitement d'image fiables et optimisées, par exemple </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 1. Modèle OT 3D d'une station de pompage</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'élément principal des sections obtenues en scannant diverses structures de tuyaux sont </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des arcs elliptiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 2. Coupe horizontale d'un modèle 3D d'une station de pompage à un niveau moyen.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour cet article, nous limitons notre examen à un algorithme clé qui nous permet de détecter des arcs elliptiques arbitraires - il s'agit d'un algorithme itératif pour la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">croissance de segments d'arc et la liaison de </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">régions</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">croissance de régions et liaison de bords</font></em><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les algorithmes de croissance sont les plus évidents et les plus facilement vérifiables, quoique longs en comparaison avec les algorithmes statistiques, qui conviennent mieux au cas où la scène contient des objets distants à couplage lâche qui appartiennent à une ellipse. </font><font style="vertical-align: inherit;">Ces algorithmes seront discutés dans de futurs articles.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'instant, pour des raisons de simplicité, nous omettons la procédure d'obtention d'une section à partir du fichier </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> source </font><font style="vertical-align: inherit;">, le prétraitement d'une section, son regroupement pour isoler les primitives géométriques, ainsi que la liaison, la rectification et les autres opérations photogrammétriques nécessaires pour obtenir les paramètres du modèle. Nous ne discuterons pas de la même manière le paramétrage des algorithmes de recherche heuristique. Décrivons toutes les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opérations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><i><font style="vertical-align: inherit;">base à</font></i><font style="vertical-align: inherit;"> partir desquelles l'algorithme est construit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous supposons que nous devons détecter (reconnaître, classer) un arc elliptique (c'est-à-dire calculer les paramètres de l'ellipse, ainsi que l'angle initial et final de l'arc elliptique) dans cette image, découpée dans la section horizontale du nuage de points. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 3. L'un des arcs elliptiques de la section transversale du modèle 3D (après lissage)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de minimiser le travail avec le raster à l'aveugle, nous effectuerons toutes les opérations avec le raster en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">décrivant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procédure </font><em><font style="vertical-align: inherit;">OpenCV </font></em></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> recherche sur le </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tapis</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raster </font><font style="vertical-align: inherit;">tous les </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> externes (sans formes internes) </font><font style="vertical-align: inherit;">sous la forme d'un vecteur de vecteurs de points entiers (en coordonnées raster):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit de notre opération clé, qui dans certains cas simples </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">résout complètement la tâche</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais comme les cas dégénérés ne sont pas toujours retrouvés, considérons plus en détail la technologie de traitement par contournage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'opération inverse, générant un raster en fonction du circuit externe existant à l'aide de la </font><font style="vertical-align: inherit;">fonction </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , semble également simple:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est également très souvent utilisé pour masquer les contours, dessiner ou calculer la surface. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, au stade initial, nous avons un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensemble de patchs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (morceaux d'une certaine courbe) qui doivent être connectés en un arc elliptique, éliminant les parties d'autres composants de la structure (par exemple, les attaches) ou le bruit optique provoqué par l'ombrage pendant la numérisation et autres les raisons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Créons une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonction discriminante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qui retournera le type de contour (ellipse, segment linéaire, hachures ou autre), ainsi que les points finaux du contour et son rectangle de contour pivoté:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rapport entre la longueur et la largeur du rectangle permet de distinguer rapidement les contours proches </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des segments linéaires</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que les petits </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contours de bruit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rectangle pivoté dans </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a un </font><font style="vertical-align: inherit;">système de coordonnées </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complexe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si ce n'est pas l'angle lui-même qui est requis, mais ses </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fonctions trigonométriques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est d'autant moins évident du contexte. Si la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur absolue de l'angle est utilisée</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , il faut tenir compte du fait que l' </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angle est compté de l'horizontale au premier bord du rectangle dans le sens antihoraire et a une valeur négative</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les extrémités des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contours elliptiques sont trouvées en utilisant notre procédure, qui reçoit le </font><em><font style="vertical-align: inherit;">mat</font></em><font style="vertical-align: inherit;"> matriciel</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avec un contour discret extrait de l'image originale par masquage et renvoie le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">défaut maximum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, … );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le code principal de cette fonction est d'appeler deux procédures </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La première procédure trouve un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">polygone convexe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour le contour étudié, la seconde - calcule tous les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">défauts de convexité</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne prenons que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le plus grand</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> défaut en termes de convexité, considérant qu'il détermine les points terminaux du contour. Cela peut ne pas être le cas si les limites externes ou internes du contour ont des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caractéristiques</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Afin de les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lisser</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous appliquons un lissage supplémentaire au contour étudié (et non à l'image entière afin de ne pas «brouiller» les isthmes entre les contours et ne pas violer la topologie d'origine). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 4. Calcul du défaut de gonflement L' </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">option (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> définit par erreur le point final rouge. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définit correctement les points de terminaison. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'option (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redéfinit les points d'extrémité sur la forme d'origine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisque dans la technologie que nous avons adoptée, le circuit est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">régénéré à</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaque fois </font><font style="vertical-align: inherit;">, nous devons rechercher à nouveau les points de correspondance (ou plutôt leurs indices) par la procédure de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recherche exhaustive</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les cas où il n'est pas possible de se débarrasser complètement des fonctionnalités, un mode supplémentaire de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">séparation d'arc</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a également été implémenté </font><font style="vertical-align: inherit;">(travailler séparément avec l'arc interne / externe). Ceci est important, par exemple, dans les cas où l'arc externe du contour est en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contact</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec d'autres objets ou est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bruyant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Dans ce cas, vous pouvez aller travailler avec l'arc interne. Dans ce cas, il n'est pas nécessaire de traiter séparément les arcs externes et internes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, selon la formule bien connue du rapport de la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexité de l'arc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rayon du</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cercle </font><font style="vertical-align: inherit;">est approximativement estimé </font><font style="vertical-align: inherit;">et les ellipses trop grandes sont rejetées:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, pour tous les contours, leur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métrique de défaut de convexité a été</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> trouvée </font><font style="vertical-align: inherit;">(ou ils sont classés comme linéaires ou petits et retirés de la procédure). </font><font style="vertical-align: inherit;">À la dernière étape, des paramètres supplémentaires sont ajoutés à la métrique d'origine, tels que le paramètre de dimension pivotée, etc., et l'ensemble complet des métriques à l'étude est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trié par taille</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithme pour relier des segments d'arc aux points d'extrémité</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'algorithme de croissance est clair et évident: nous prenons le plus grand contour comme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">graine</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et essayons de le cultiver, c'est-à-dire de trouver et d'attacher les patchs les plus proches à ses points finaux qui satisfont aux conditions de croissance. Dans la figure adulte, nous entrons dans l' </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc elliptique souhaité</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Masquez et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soustrayez la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> figure de l'ensemble d'origine. Nous répétons la procédure de croissance </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jusqu'à épuisement de la série initiale</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La procédure de base de l'algorithme de croissance ressemble à ceci:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
où </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contour</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le contour à l'étude, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est son défaut de convexité, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coque</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le polygone convexe de toute la région, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est la matrice tampon auxiliaire. À la sortie, nous obtenons un contour développé par vecteur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La procédure consiste en un cycle de tentatives de germination de la croissance, se terminant soit par l'épuisement des patchs disponibles pour la croissance, soit limité par le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètre du nombre maximal d'itérations</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 5. Nombreux patchs pour la croissance sans graines La</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
principale difficulté est de sélectionner les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">patchs</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> les </font><i><font style="vertical-align: inherit;">plus proches</font></i><font style="vertical-align: inherit;"> des points d'extrémité du contour, de sorte que la figure ne pousse que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vers l'avant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direction tangentielle</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous prenons la ligne moyenne appartenant à l'arc au voisinage du point final. La </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 6</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> affiche les candidats pour la connexion à la graine à une certaine itération. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 6. Graine entourée d'une pluralité de patchs candidats à la croissance</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pour chaque patch candidat, la métrique suivante est calculée:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seuls les patchs qui tombent dans le </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cône tangentiel sont</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pris en compte </font><font style="vertical-align: inherit;">. Ensuite, le patch avec la plus petite distance est sélectionné et, en imprimant la section de connexion dans le raster, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">connecte</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à l'extrémité correspondante de la graine. Pour l'autre extrémité de la graine, un patch correspondant aux paramètres est recherché et, s'il est trouvé, est également connecté à la graine. Ensuite, la graine est </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masquée et soustraite</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> des nombreux patchs. La procédure est répétée depuis le tout début. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la fin de la procédure de croissance, nous avons obtenu un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arc elliptique</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui reste à vérifier. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, en utilisant le standard </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la procédure que notre patch reçoit (sous la forme d'un chemin, nous nous souvenons que le chemin et le raster sont interchangeables avec nous) et renvoie la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimension pivotée</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire une ellipse complète.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous rejetons les ellipses trop grandes et trop petites, puis nous appliquons notre procédure originale pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparer les zones de l'</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arc elliptique résultant et le patch de croissance initial sous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forme raster</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cette procédure comprend quelques astuces déguisées, nous allons donc omettre sa description pour l'instant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, nous trouvons les paramètres restants de l'ellipse détectée - les </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">angles de début et de fin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (nous connaissons déjà les demi-axes de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour déterminer les angles de début et de fin, nous procédons comme suit: nous transformons notre ellipse complète, de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retour au polygone,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et par dénombrement direct nous trouvons ses points les plus proches de nos extrémités. Leurs </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordonnées angulaires</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(en fait, les indices) et seront les angles de début et de fin d'un arc elliptique. </font><font style="vertical-align: inherit;">En code, cela ressemble à ceci (un peu simplifié):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre procédure </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides prend</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en compte la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topologie de la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> traversée de l'arc elliptique. </font><font style="vertical-align: inherit;">Au total, huit cas possibles de contournement des indices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> doivent être considérés </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Allons-nous le long du contour extérieur ou intérieur, et lequel des indices est le plus grand, initial ou final? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code plus facile à voir:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains résultats de la détection d'ellipses dans des cas complexes sont présentés à la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">figure 7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les articles suivants, les méthodes de détection statistique seront considérées.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490386/index.html">Sinon, comment gagner de l'argent en bourse et réduire les risques: les actions des entreprises avec le paiement de dividendes</a></li>
<li><a href="../fr490390/index.html">Olga Makushenko, directrice générale de 101XP: «5 erreurs clés dans le développement d'un jeu en tant qu'entreprise»</a></li>
<li><a href="../fr490392/index.html">Catchain: algorithme de consensus TON Blockchain</a></li>
<li><a href="../fr490394/index.html">Commodore Amiga 500+: ne laissez personne s'en offusquer</a></li>
<li><a href="../fr490398/index.html">Poudlard rouge. Officiers, ou pourquoi un historien est comme un détective</a></li>
<li><a href="../fr490404/index.html">Pourquoi et comment la 5G changera tout: technologie, mise en œuvre progressive et base d'éléments pour l'équipement d'abonné</a></li>
<li><a href="../fr490406/index.html">Inexprimablement attrayant: comment nous avons créé un haniot qui ne peut pas être exposé</a></li>
<li><a href="../fr490408/index.html">FreeBSD: гораздо лучше GNU/Linux</a></li>
<li><a href="../fr490410/index.html">Neurones vivants et artificiels connectés via Internet</a></li>
<li><a href="../fr490412/index.html">Peut-être qu'on devrait se calmer un peu avec JavaScript?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>