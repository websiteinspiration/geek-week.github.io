<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🏫 🔌 🎞️ Unabhängiges Frontend 🎙️ 🎼 🔄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GoF, reine Architektur, perfekter Code - Die wahren Programmierhandbücher. In der Welt des Frontends sind jedoch viele Ideen aus diesen Büchern nicht ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unabhängiges Frontend</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491684/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GoF, reine Architektur, perfekter Code - Die wahren Programmierhandbücher. </font><font style="vertical-align: inherit;">In der Welt des Frontends sind jedoch viele Ideen aus diesen Büchern nicht verfügbar. </font><font style="vertical-align: inherit;">Zumindest ist eine Ähnlichkeit mit der realen Welt sehr schwer zu finden. </font><font style="vertical-align: inherit;">Vielleicht ist das moderne Frontend der Zeit voraus? </font><font style="vertical-align: inherit;">Vielleicht haben „funktionale“ Programmierung und React bereits ihre Überlegenheit gegenüber OOP bewiesen? </font><font style="vertical-align: inherit;">In diesem Artikel möchte ich ein Beispiel für eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToDo-List-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anwendung geben, die ich gemäß den in klassischen Büchern beschriebenen Prinzipien und Ansätzen zu implementieren versuchte.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Framework-Abhängigkeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rahmen ist der Eckpfeiler der modernen Front. Auf hh.ru-Stellen sind React vs Angular vs Vue-Entwickler. Ich habe mit jedem dieser Frameworks gearbeitet und konnte sehr lange nicht verstehen, warum ich ab 3 Jahren mit Vue arbeiten musste, um einen Knopf von rot nach lila neu zu streichen. Warum muss ich wissen, wie man Prototypen erbt oder wie die Ereignisschleife funktioniert, um dieselbe Schaltfläche von der linken Ecke nach rechts zu verschieben? Die Antwort ist einfach: Wir schreiben bibliotheksgebundene Anwendungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum arbeiten Unternehmen mit langjähriger Erfahrung mit React? </font><font style="vertical-align: inherit;">Ja, da die Anwendung stark von den Funktionen dieses React selbst abhängt und um beim Neulackieren einer Schaltfläche nichts zu beschädigen, sollten Sie sich überlegen, wie die Änderungserkennung, das Rendern des Komponentenbaums in React und die Beziehung zum Neulackieren der Schaltfläche funktionieren. </font><font style="vertical-align: inherit;">(Ich stimme zu, dies sind alles Sonderfälle ... Und sind Sie in Ihrem Unternehmen bereit, einen Spezialisten ohne Erfahrung mit dem Framework zu beauftragen?)</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmieren Sie mit einer Sprache, nicht mit einer Sprache. </font><font style="vertical-align: inherit;">(McConnell) Ein </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Framework ist ein Werkzeug, keine Lebensweise. </font><font style="vertical-align: inherit;">(Martin)</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Für die Welt der Front sind diese Thesen bestenfalls leere Sätze und im schlimmsten Fall eine Herausforderung, das Gegenteil zu beweisen. </font><font style="vertical-align: inherit;">Schauen wir uns die offizielle React-Dokumentation an und sehen uns ein Beispiel für eine einfache ToDo-List-Anwendung.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel-ToDo-Liste von der offiziellen React-Website</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">items</span>: [], <span class="hljs-attr">text</span>: <span class="hljs-string">''</span> };
    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.handleSubmit = <span class="hljs-keyword">this</span>.handleSubmit.bind(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{this.state.items}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{this.handleSubmit}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"new-todo"</span>&gt;</span>
              ?
          <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
            <span class="hljs-attr">id</span>=<span class="hljs-string">"new-todo"</span>
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleChange}</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.text}</span>
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>
             #{this.state.items.length + 1}
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  handleChange(e) {<font></font>
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">text</span>: e.target.value });<font></font>
  }<font></font>
<font></font>
  handleSubmit(e) {<font></font>
    e.preventDefault();<font></font>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.text.length) {
      <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">const</span> newItem = {
      <span class="hljs-attr">text</span>: <span class="hljs-keyword">this</span>.state.text,
      <span class="hljs-attr">id</span>: <span class="hljs-built_in">Date</span>.now()<font></font>
    };<font></font>
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
      <span class="hljs-attr">items</span>: state.items.concat(newItem),
      <span class="hljs-attr">text</span>: <span class="hljs-string">''</span><font></font>
    }));<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{<font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {this.props.items.map(item =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.text}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisiten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie eine kleine Aufgabenlistenanwendung erstellen. </font><font style="vertical-align: inherit;">In diesem Beispiel wird </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">, um die aktuelle Liste der Elemente zu verfolgen ... "</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Für einen unerfahrenen Programmierer (dh mich vor ein paar Jahren) generiert dieser Satz automatisch die Ausgabe:" Hier ist ein ideales Beispiel für eine Aufgabenlistenanwendung ". </font><font style="vertical-align: inherit;">Aber wer speichert den Zustand in der Komponente ?! </font><font style="vertical-align: inherit;">Dafür gibt es eine Zustandsverwaltungsbibliothek. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel für eine Aufgabenliste aus der Redux-Dokumentation</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ja, so ist die Anwendung viel klarer und einfacher geworden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nein)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Können wir versuchen, die Abhängigkeiten in die richtige Richtung zu ziehen?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabhängige Entscheidung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir das Problem der Aufgabenliste nicht als Front-End, dh vergessen Sie, dass wir HTML zeichnen müssen („Web ist ein Detail“). </font><font style="vertical-align: inherit;">Wir können das Ergebnis nicht mit unseren Augen überprüfen, daher müssen wir Tests schreiben (wie Onkel Bob sagt, "TDD kann dann angewendet werden"). </font><font style="vertical-align: inherit;">Und was ist die Aufgabe? </font><font style="vertical-align: inherit;">Was ist eine Aufgabenliste? </font><font style="vertical-align: inherit;">Wir versuchen zu schreiben.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Todo'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'Todo'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todo: Todo;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-string">'description'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getItems() should returns Todo[]'</span>, () =&gt; {<font></font>
    expect(todo.getTitle()).toBe(<span class="hljs-string">'description'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+isCompleted() should returns completion flag'</span>, () =&gt; {<font></font>
    expect(todo.isCompleted()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+toggleCompletion() should invert completion flag'</span>, () =&gt; {<font></font>
    todo.toggleCompletion();<font></font>
    expect(todo.isCompleted()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'TodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: TodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getItems() should returns Todo[]'</span>, () =&gt; {<font></font>
    expect(todoList.getItems()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should create item and add to collection'</span>, () =&gt; {<font></font>
    todoList.add(<span class="hljs-string">'Write tests'</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should create item with the description'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    expect(item.getTitle()).toBe(description);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getCompletedItems() should not returns uncompleted Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    expect(todoList.getCompletedItems()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getCompletedItems() should returns completed Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    item.toggleCompletion();<font></font>
    expect(todoList.getCompletedItems()).toEqual([item]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getUncompletedItems() should returns uncompleted Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    expect(todoList.getUncompletedItems()).toEqual([item]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getUncompletedItems() should not returns completed Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    item.toggleCompletion();<font></font>
    expect(todoList.getUncompletedItems()).toEqual([]);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  private completed: boolean = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private description: string) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.description;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Todo'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private items: Todo[] = [];<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items;<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  add(description: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.items.push(<span class="hljs-keyword">new</span> Todo(description));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erhalten zwei einfache Klassen mit informativen Schnittstellen. </font><font style="vertical-align: inherit;">Ist das alles? </font><font style="vertical-align: inherit;">Tests bestehen. </font><font style="vertical-align: inherit;">Nehmen Sie nun die Reaktion auf.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<font></font>
<font></font>
<span class="hljs-keyword">import</span> { TodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./core/TodoList'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-attr">todoList</span>: TodoList = <span class="hljs-keyword">this</span>.createTodoList();<font></font>
<font></font>
  render(): any {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Todo List App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoListCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoListCmp</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">AddTodoCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AddTodoCmp</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  private createTodoList(): TodoList {<font></font>
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
    todoList.add(<span class="hljs-string">'Initial created Todo'</span>);
    <span class="hljs-keyword">return</span> todoList;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoListCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>What to do?<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {todoList.getItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.getTitle()}</span>&gt;</span>{todo.getTitle()}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
  );<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AddTodoCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todoList.add(`Todo ${todoList.getItems().length}`)}&gt;Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und stellen Sie sicher, dass ... das Hinzufügen eines Elements nicht funktioniert. </font><font style="vertical-align: inherit;">Hmm ... Jetzt ist klar, warum alles im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status geschrieben werden muss</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - damit die React-Komponente nach dem Erlernen der Änderungen neu gezeichnet wird. </font><font style="vertical-align: inherit;">Aber ist dies ein Grund, alle möglichen Prinzipien zu verletzen und Logik in die Ansichtskomponente zu setzen? </font><font style="vertical-align: inherit;">Ein bisschen Geduld und Mut. </font><font style="vertical-align: inherit;">Um das Problem zu lösen, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ist es</font></a><font style="vertical-align: inherit;"> perfekt </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, forceUpdate () in einer Endlosschleife oder im </font></font></s> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observer-Muster </font></font></a><font style="vertical-align: inherit;"><s><font style="vertical-align: inherit;">aufzurufen</font></s><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag die RxJs-Bibliothek, aber ich werde sie nicht verbinden, sondern nur die für unsere Aufgabe erforderliche API kopieren.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Observable'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'Observable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> subject: Subject&lt;any&gt;;
  <span class="hljs-keyword">let</span> observable: Observable&lt;any&gt;;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    subject = <span class="hljs-keyword">new</span> Subject();<font></font>
    observable = subject.asObservable();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should call callback on next value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    observable.subscribe(spy);<font></font>
    subject.next({});<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should not call callback on next value if unsubscribed'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();
    <span class="hljs-keyword">const</span> subscription = observable.subscribe(spy);<font></font>
    subscription.unsubscribe();<font></font>
    subject.next({});<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).not.toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should send to callback subject.next value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    observable.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> sendingValue = {};<font></font>
    subject.next(sendingValue);<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy.calls.first().args[<span class="hljs-number">0</span>]).toBe(sendingValue);<font></font>
  });<font></font>
});<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">timeoutInMs?: number</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, timeoutInMs));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">export</span> interface Observable&lt;T = unknown&gt; {<font></font>
  subscribe(onNext: <span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>): Subscription;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> interface Subscription {<font></font>
  unsubscribe(): <span class="hljs-keyword">void</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>&lt;<span class="hljs-title">T</span> </span>= unknown&gt; implements Observable&lt;T&gt; {<font></font>
  protected callbackSet: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<font></font>
<font></font>
  asObservable(): Observable&lt;T&gt; {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  subscribe(onNext: <span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>): Subscription {
    <span class="hljs-keyword">this</span>.callbackSet.add(onNext);
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.callbackSet.delete(onNext) };<font></font>
  }<font></font>
<font></font>
  next(value: T): <span class="hljs-keyword">void</span> {
    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.callbackSet.forEach(<span class="hljs-function">(<span class="hljs-params">onNext</span>) =&gt;</span> onNext(value)));<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach nichts zu kompliziert. </font><font style="vertical-align: inherit;">Fügen Sie einen Test hinzu (Benachrichtigung über Änderungen - das ist die Logik).</font></font><br>
<br>
<pre><code class="javascript hljs">  it(<span class="hljs-string">'+TodoList.prototype.add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add(<span class="hljs-string">'description'</span>);
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Moment nachdenken, aber wirkt sich eine Änderung eines Todo-Elements auf den Status einer TodoList aus? Auswirkungen - Die Methoden getCompletedItems / getUncompletedItems müssen einen anderen Satz von Elementen zurückgeben. Vielleicht lohnt es sich, die toggleCompletion in die TodoList-Klasse zu verschieben? Es ist eine schlechte Idee - bei diesem Ansatz müssen wir TodoList für jede Funktion in Bezug auf ein neues Todo-Element aufblasen (wir werden später darauf zurückkommen). Aber wie erfährt man von den Veränderungen, wieder der Beobachter? Lassen Sie das Todo-Element selbst Änderungen über einen Rückruf kommunizieren, um die Sache zu vereinfachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vollversion des Programms sieht so aus.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { generateId } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/generateId'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  private completed: boolean = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  id: string = generateId();<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private description: string, private onCompletionToggle?: (todo: Todo) =&gt; void) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.description;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;
    <span class="hljs-keyword">this</span>.onCompletionToggle?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private items: Todo[] = [];<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items;<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  add(description: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.items.push(<span class="hljs-keyword">new</span> Todo(description, () =&gt; <span class="hljs-keyword">this</span>.changesSubject.next({})));
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-attr">todoList</span>: TodoList = <span class="hljs-keyword">this</span>.createTodoList();<font></font>
<font></font>
  render(): any {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Todo List App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoListCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoListCmp</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">AddTodoCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AddTodoCmp</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  componentDidMount(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.todoList.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.forceUpdate());<font></font>
  }<font></font>
<font></font>
  private createTodoList(): TodoList {<font></font>
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
    todoList.add(<span class="hljs-string">'Initial created Todo'</span>);
    <span class="hljs-keyword">return</span> todoList;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoListCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>What to do?<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {todoList.getUncompletedItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoCmp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoCmp</span>&gt;</span>
        ))}
        {todoList.getCompletedItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoCmp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoCmp</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
  );<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoCmp: React.FC&lt;{ <span class="hljs-attr">todo</span>: Todo }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todo }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">textDecoration:</span> <span class="hljs-attr">todo.isCompleted</span>() ? '<span class="hljs-attr">line-through</span>' <span class="hljs-attr">:</span> '' }}
    <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todo.toggleCompletion()}
  &gt;
    {todo.getTitle()}
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AddTodoCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todoList.add(`Todo ${todoList.getItems().length}`)}&gt;Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sollte die vom Framework unabhängige ToDo-List-Anwendung aussehen. </font><font style="vertical-align: inherit;">Die einzige Einschränkung ist PL. </font><font style="vertical-align: inherit;">Sie können die Anzeige für die Konsole implementieren oder Angular verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Möglicherweise ist die aktuelle Version der Anwendung nicht komplex genug, um sicherzustellen, dass ein unabhängiger Ansatz funktioniert, und um seine Stärken zu demonstrieren. </font><font style="vertical-align: inherit;">Daher werden wir unsere Vorstellungskraft verbinden, um ein mehr oder weniger plausibles ToDo-List-Entwicklungsszenario zu simulieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen vom Kunden</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptalptraum der meisten Projekte sind sich ändernde Anforderungen. </font><font style="vertical-align: inherit;">Sie wissen, dass Änderungen nicht vermieden werden können, und Sie wissen, dass dies normal ist. </font><font style="vertical-align: inherit;">Aber wie bereiten Sie sich auf zukünftige Veränderungen vor?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Todo-Elemente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der Hauptmerkmale von OOP ist die Fähigkeit, das Problem durch die Einführung neuer Typen zu lösen. Vielleicht ist dies die leistungsstärkste OOP-Technik, mit der ein komplexes und umständliches Programm im Alleingang erstellt werden kann. Zum Beispiel weiß ich nicht, was vom Todo-Element verlangt wird. Es kann notwendig sein, seinen Namen ändern zu können, es kann notwendig sein, zusätzliche Attribute hinzuzufügen, es kann möglich sein, dieses Element durch direkten Zugriff auf den SpaceX-Server zu ändern ... Aber ich bin sicher, dass sich die Anforderungen ändern werden und ich verschiedene Arten von Todo benötigen werde.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableTodo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  changeTitle(title: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass wir zur Anzeige eines speziellen Typs auch die Ansichtskomponenten ändern müssen. In der Praxis habe ich Komponenten getroffen (und geschrieben), bei denen eine Million verschiedener Bedingungen einen Div-Block von einer Giraffe in ein Maschinengewehr verwandeln. Um dieses Problem zu vermeiden, können Sie eine Hoc-Komponente mit einer riesigen Switch-Case-Liste erstellen. Oder wenden Sie das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besuchermuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den doppelten Versand an und lassen Sie das Todo-Element selbst entscheiden, welche Art von Komponente gezeichnet werden soll.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
  <span class="hljs-attr">id</span>: string = <span class="hljs-string">''</span>;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    protected title: string,<font></font>
    private completed: boolean = false,<font></font>
    protected onChange?: (todo: Todo) =&gt; void,<font></font>
  ) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.title;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render(renderer: TodoRenderer): any {<font></font>
    <span class="hljs-keyword">return</span> renderer.renderSimpleTodo(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableTodo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  changeTitle(title: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render(renderer: TodoRenderer): any {<font></font>
    <span class="hljs-keyword">return</span> renderer.renderEditableTodo(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoRenderer</span> </span>{<font></font>
  renderSimpleTodo(todo: Todo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SimpleTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
<font></font>
  renderFixedTodo(todo: Todo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FixedTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
<font></font>
  renderEditableTodo(todo: EditableTodo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EditableTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">EditableTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Option für den doppelten Versand ist besonders nützlich, wenn ein Artikeltyp unterschiedliche Ansichten hat. </font><font style="vertical-align: inherit;">Sie können sie ändern, indem Sie verschiedene TodoRenderer in die Rendermethode einsetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir bereit. </font><font style="vertical-align: inherit;">Die Angst vor neuen Anforderungen an „spezielle“ Todo-Elemente ist verschwunden. </font><font style="vertical-align: inherit;">Ich denke, die Entwickler selbst könnten die Initiative ergreifen und einige Funktionen anbieten, die die Einführung neuer Typen erfordern, die jetzt durch Schreiben von neuem Code und minimale Änderungen am vorhandenen hinzugefügt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern von Daten auf dem Server</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was für eine Anwendung ist ohne Interaktion mit dem Server? </font><font style="vertical-align: inherit;">Natürlich müssen Sie in der Lage sein, unsere Liste über HTTP zu speichern - eine weitere neue Anforderung. </font><font style="vertical-align: inherit;">Wir versuchen das Problem zu lösen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppTodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoType } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { AppTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./AppTodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'AppTodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: AppTodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({
      <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">type</span>: TodoType.Simple, <span class="hljs-attr">title</span>: <span class="hljs-string">'Loaded todo'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> }],
      <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(),<font></font>
    });<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should load saved todo items'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    expect(todoList.getItems().length).toBeGreaterThan(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should save todoList state on success and rollback to it on error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> api = { <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve() };<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList(api);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'1'</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> savedData = <span class="hljs-built_in">JSON</span>.stringify(todoList.getItems());<font></font>
    api.save = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Mock saving failed'</span>);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'2'</span> });<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(<span class="hljs-built_in">JSON</span>.stringify(todoList.getItems())).toBe(savedData);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> interface TodoListApi {<font></font>
  getItems(): <span class="hljs-built_in">Promise</span>&lt;TodoParams[]&gt;;<font></font>
  save(todoParamsList: TodoParams[]): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
<font></font>
  changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private subscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());<font></font>
  private synchronizedTodoParamsList: TodoParams[] = [];<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {}<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.updateState(todoParamsList);<font></font>
  }<font></font>
<font></font>
  private updateState(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.state = todoList;
    <span class="hljs-keyword">this</span>.subscription.unsubscribe();
    <span class="hljs-keyword">this</span>.subscription = todoList.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());
    <span class="hljs-keyword">this</span>.synchronizedTodoParamsList = todoParamsList;
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private <span class="hljs-keyword">async</span> onStateChanges(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">this</span>.changesSubject.next({});
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.save(params);
      <span class="hljs-keyword">this</span>.synchronizedTodoParamsList = params;<font></font>
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">this</span>.updateState(<span class="hljs-keyword">this</span>.synchronizedTodoParamsList);<font></font>
    }<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.subscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen nicht, wie sich die Anwendung verhalten soll. </font><font style="vertical-align: inherit;">Warten Sie, bis der Speichervorgang erfolgreich war, und zeigen Sie die Änderungen an. </font><font style="vertical-align: inherit;">Änderungen anzeigen lassen und im Fehlerfall in den synchronisierten Zustand zurücksetzen? </font><font style="vertical-align: inherit;">Oder Speicherfehler ganz ignorieren? </font><font style="vertical-align: inherit;">Höchstwahrscheinlich weiß der Kunde dies auch nicht. </font><font style="vertical-align: inherit;">Änderungen der Anforderungen sind daher unvermeidlich, sollten jedoch nur eine Klasse betreffen, die für die Erhaltung verantwortlich ist. </font><font style="vertical-align: inherit;">Und unterwegs die nächste Bearbeitung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschichte verändern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Wir brauchen die Fähigkeit, Aktionen abzubrechen / zu wiederholen" ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass uns eine Welle neuer Änderungen überrascht. </font><font style="vertical-align: inherit;">Aber in keinem Fall können Sie Tests opfern. </font><font style="vertical-align: inherit;">Nun ist völlig unklar, welche Vererbungshierarchie besser geeignet ist und ob die Vererbung allgemein geeignet ist. </font><font style="vertical-align: inherit;">Daher wird nichts Schlimmes passieren, wenn wir einfach unsere schmutzige Klasse ergänzen (wir werden dies als Implementierungsdetails betrachten) und das Prinzip der alleinigen Verantwortung opfern.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoListHistory.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoListHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListHistory'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'TodoListHistory'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> history: TodoListHistory;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    history = <span class="hljs-keyword">new</span> TodoListHistory();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getState() should returns TodoParams[]'</span>, () =&gt; {<font></font>
    expect(history.getState()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+setState() should rewrite current state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> newState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(newState);<font></font>
    expect(history.getState()).toBe(newState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns false on init'</span>, () =&gt; {<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns true after setState()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should switch on prev state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(prevState);<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns false after switch to first'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false on init'</span>, () =&gt; {<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns true after switchToPrev()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToNext() should switch on next state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState([]);<font></font>
    history.setState(prevState);<font></font>
    history.switchToPrev();<font></font>
    history.switchToNext();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false after switchToNext()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.switchToNext();<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false after setState()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.setState([]);<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should switch on prev state after setState()'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(prevState);<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+setState() should not emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.setState([]);<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).not.toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.switchToNext();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+reset() should reset history and apply initial state'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">const</span> initState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.reset(initState);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
    expect(history.getState()).toBe(initState);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppTodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoType } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { AppTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./AppTodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'AppTodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: AppTodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({
      <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">type</span>: TodoType.Simple, <span class="hljs-attr">title</span>: <span class="hljs-string">'Loaded todo'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> }],
      <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(),<font></font>
    });<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should load saved todo items'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    expect(todoList.getItems().length).toBeGreaterThan(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should ignore error on save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> api = { <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve() };<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList(api);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'1'</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    api.save = jasmine.createSpy().and.returnValue(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Mock saving failed'</span>));<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'2'</span> });<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(api.save).toHaveBeenCalled();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should provide current todoList state to history'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should provide current todoList state to history'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+history.switchToPrev() should change todoList state on prev'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+history.switchToPrev() should change todoList state on prev after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after history.switchToPrev()'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoListHistory</span> </span>{<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
  private history: TodoParams[][] = [<span class="hljs-keyword">this</span>.state];<font></font>
<font></font>
  changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private state: TodoParams[] = []) {}<font></font>
<font></font>
  reset(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.history = [<span class="hljs-keyword">this</span>.state];<font></font>
  }<font></font>
<font></font>
  getState(): TodoParams[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<font></font>
  }<font></font>
<font></font>
  setState(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.deleteHistoryAfterCurrentState();
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.history.push(state);<font></font>
  }<font></font>
<font></font>
  private nextState(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private deleteHistoryAfterCurrentState(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history = <span class="hljs-keyword">this</span>.history.slice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.getCurrentStateIndex() + <span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  hasPrev(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getCurrentStateIndex() &gt; <span class="hljs-number">0</span>;<font></font>
  }<font></font>
<font></font>
  hasNext(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getCurrentStateIndex() &lt; <span class="hljs-keyword">this</span>.history.length - <span class="hljs-number">1</span>;<font></font>
  }<font></font>
<font></font>
  switchToPrev(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> prevStateIndex = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.getCurrentStateIndex() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">this</span>.nextState(<span class="hljs-keyword">this</span>.history[prevStateIndex]);<font></font>
  }<font></font>
<font></font>
  switchToNext(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> nextStateIndex = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.getCurrentStateIndex() + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.history.length - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.nextState(<span class="hljs-keyword">this</span>.history[nextStateIndex]);<font></font>
  }<font></font>
<font></font>
  private getCurrentStateIndex(): number {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.indexOf(<span class="hljs-keyword">this</span>.state);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">import</span> { Observable, Subject, Subscription } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/Todo'</span>;
<span class="hljs-keyword">import</span> { TodoFactory, TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { TodoList, TodoListImp } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoList'</span>;
<span class="hljs-keyword">import</span> { TodoListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListApi'</span>;
<span class="hljs-keyword">import</span> { HistoryControl, TodoListHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListHistory'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private readonly todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  private readonly history: TodoListHistory = <span class="hljs-keyword">new</span> TodoListHistory();<font></font>
<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private stateSubscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
    <span class="hljs-keyword">this</span>.onStateChanges(),<font></font>
  );<font></font>
  private historySubscription = <span class="hljs-keyword">this</span>.history.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onHistoryChanges());<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {}<font></font>
<font></font>
  private onStateChanges(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));
    <span class="hljs-keyword">this</span>.history.setState(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private onHistoryChanges(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.history.getState();
    <span class="hljs-keyword">this</span>.updateStateTodoList(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});<font></font>
  }<font></font>
<font></font>
  private updateStateTodoList(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.state = todoList;
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.stateSubscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.history.reset(todoParamsList);
    <span class="hljs-keyword">this</span>.updateStateTodoList(todoParamsList);<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.historySubscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getHistory(): HistoryControl&lt;TodoParams[]&gt; {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history;<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der Änderungsverlauf ziemlich identisch ist, trennen wir die Verwaltung des Aufgabenlistenverlaufs in die Basisklasse.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/Todo'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject, Subscription } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { TodoFactory, TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { TodoList, TodoListImp } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoList'</span>;
<span class="hljs-keyword">import</span> { HistoryControl, HistoryState } <span class="hljs-keyword">from</span> <span class="hljs-string">'./HistoryState'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoricalTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span>, <span class="hljs-title">HistoryControl</span> </span>{<font></font>
  protected readonly todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  protected readonly history = <span class="hljs-keyword">new</span> HistoryState&lt;TodoParams[]&gt;([]);<font></font>
<font></font>
  private changesSubject: Subject = <span class="hljs-keyword">new</span> Subject();<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private stateSubscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
    <span class="hljs-keyword">this</span>.onStateChanged(<span class="hljs-keyword">this</span>.getSerializedState()),<font></font>
  );<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>() {}<font></font>
<font></font>
  protected onStateChanged(params: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.addState(params);
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  protected onHistorySwitched(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.updateState(<span class="hljs-keyword">this</span>.history.getState());<font></font>
  }<font></font>
<font></font>
  protected updateState(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.updateStateSubscription();
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private updateStateSubscription(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.stateSubscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
      <span class="hljs-keyword">this</span>.onStateChanged(<span class="hljs-keyword">this</span>.getSerializedState()),<font></font>
    );<font></font>
  }<font></font>
<font></font>
  private getSerializedState(): TodoParams[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
<font></font>
  canUndo(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.hasPrev();<font></font>
  }<font></font>
<font></font>
  canRedo(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.hasNext();<font></font>
  }<font></font>
<font></font>
  undo(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.switchToPrev();
    <span class="hljs-keyword">this</span>.onHistorySwitched();<font></font>
  }<font></font>
<font></font>
  redo(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.switchToNext();
    <span class="hljs-keyword">this</span>.onHistorySwitched();<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { HistoricalTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./HistoricalTodoList'</span>;
<span class="hljs-keyword">import</span> { TodoListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListApi'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResolvableTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HistoricalTodoList</span> </span>{
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {
    <span class="hljs-keyword">super</span>();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.history.reset(todoParamsList);
    <span class="hljs-keyword">this</span>.updateState(todoParamsList);<font></font>
  }<font></font>
<font></font>
  protected onStateChanged(params: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">super</span>.onStateChanged(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.undo());<font></font>
  }<font></font>
<font></font>
  protected onHistorySwitched(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">super</span>.onHistorySwitched();
    <span class="hljs-keyword">this</span>.api.save(<span class="hljs-keyword">this</span>.history.getState()).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung des Naturschutzproblems kam von selbst. </font><font style="vertical-align: inherit;">Jetzt können wir uns keine Gedanken darüber machen, welche Erhaltungsstrategie der Kunde langfristig wählen wird. </font><font style="vertical-align: inherit;">Sie können ihm alle drei Optionen zur Auswahl stellen und die Basisklasse erweitern.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass wir von unserer Aufgabenliste einen kleinen Prototyp von Google Keep haben. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verknüpfen Sie das Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Anwendung zu starten, oder gehen Sie den Verlauf der Commits durch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was unterscheidet dieses Beispiel grundlegend von den meisten Front-End-Anwendungen? Wir waren nicht auf Bibliotheken angewiesen, daher kann eine Person, die noch nie mit React gearbeitet hat, diese Anwendung verstehen. Unsere Entscheidungen zielten nur darauf ab, das Ergebnis zu erzielen, ohne die Details des Frameworks abzulenken, sodass der Code mehr oder weniger das zu lösende Problem widerspiegelt. Wir haben es geschafft, das Hinzufügen neuer Arten von Todo-Elementen zu vereinfachen, und sind bereit, die Erhaltungsstrategie zu ändern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf welche Schwierigkeiten sind wir gestoßen? Wir haben das Problem der Aktualisierung der Ansicht mithilfe des Observer-Musters ohne Bezugnahme auf das Framework gelöst. Wie sich herausstellte, war die Anwendung dieses Musters immer noch erforderlich, um das Hauptproblem zu lösen (auch wenn wir kein HTML zeichnen mussten). Daher sind uns keine Kosten entstanden, indem wir die „Dienste“ des in das Framework integrierten Änderungserkennungssystems aufgegeben haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich möchte betonen, dass das Schreiben von Tests keine Schwierigkeit war. Das Testen einfacher unabhängiger Objekte mit einer informativen Oberfläche ist ein Vergnügen. Die Komplexität des Codes hing nur von der Aufgabe selbst und meinen Fähigkeiten (oder meiner Krümmung) ab.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist mit der Ebene der Entwickler, die damit umgehen würden? </font><font style="vertical-align: inherit;">Könnte Junior React Developer eine solche Lösung schreiben? </font><font style="vertical-align: inherit;">„Programmieren ist eher ein Handwerk“. Ohne die Verwendung von OOP und Mustern wäre dies meiner Meinung nach schwierig. </font><font style="vertical-align: inherit;">Aber Sie und Ihr Unternehmen entscheiden, in was Sie investieren. </font><font style="vertical-align: inherit;">Üben Sie OOP oder verstehen Sie die Feinheiten des nächsten Frameworks? </font><font style="vertical-align: inherit;">Ich wurde erst wieder von der Relevanz der literarischen Werke erfahrener Programmierer überzeugt und zeigte, wie man den Rat der Klassiker an der Front mit voller Kapazität einsetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danke fürs Lesen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491672/index.html">Plötzlich: Anführungszeichen gegen Obskurantismus. Was auch immer das heißt</a></li>
<li><a href="../de491674/index.html">32 Unterschiede im Design einer mobilen Anwendung für iOS und Android</a></li>
<li><a href="../de491678/index.html">Amazon Go: No Cash Desk - Eine persönliche Erfahrung</a></li>
<li><a href="../de491680/index.html">Intel Atom P5900: Das zweite Atom</a></li>
<li><a href="../de491682/index.html">Sicherheitswoche 11: Suchmaschinen-Malware</a></li>
<li><a href="../de491686/index.html">Java Digest 10. März</a></li>
<li><a href="../de491690/index.html">Datenschutz schützen - die Herausforderung des Jahrhunderts</a></li>
<li><a href="../de491692/index.html">Debuggen von Winkelschemata mit Visual Studio-Code</a></li>
<li><a href="../de491694/index.html">90er Computer-Marken</a></li>
<li><a href="../de491696/index.html">Fang mich, wenn du kannst: Radiowellen, eine Kaskade von Partikeln und Eis, um Neutrinos einzufangen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>