<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüè´ üîå üéûÔ∏è Unabh√§ngiges Frontend üéôÔ∏è üéº üîÑ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GoF, reine Architektur, perfekter Code - Die wahren Programmierhandb√ºcher. In der Welt des Frontends sind jedoch viele Ideen aus diesen B√ºchern nicht ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unabh√§ngiges Frontend</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491684/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GoF, reine Architektur, perfekter Code - Die wahren Programmierhandb√ºcher. </font><font style="vertical-align: inherit;">In der Welt des Frontends sind jedoch viele Ideen aus diesen B√ºchern nicht verf√ºgbar. </font><font style="vertical-align: inherit;">Zumindest ist eine √Ñhnlichkeit mit der realen Welt sehr schwer zu finden. </font><font style="vertical-align: inherit;">Vielleicht ist das moderne Frontend der Zeit voraus? </font><font style="vertical-align: inherit;">Vielleicht haben ‚Äûfunktionale‚Äú Programmierung und React bereits ihre √úberlegenheit gegen√ºber OOP bewiesen? </font><font style="vertical-align: inherit;">In diesem Artikel m√∂chte ich ein Beispiel f√ºr eine </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ToDo-List-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anwendung geben, die ich gem√§√ü den in klassischen B√ºchern beschriebenen Prinzipien und Ans√§tzen zu implementieren versuchte.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Framework-Abh√§ngigkeit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rahmen ist der Eckpfeiler der modernen Front. Auf hh.ru-Stellen sind React vs Angular vs Vue-Entwickler. Ich habe mit jedem dieser Frameworks gearbeitet und konnte sehr lange nicht verstehen, warum ich ab 3 Jahren mit Vue arbeiten musste, um einen Knopf von rot nach lila neu zu streichen. Warum muss ich wissen, wie man Prototypen erbt oder wie die Ereignisschleife funktioniert, um dieselbe Schaltfl√§che von der linken Ecke nach rechts zu verschieben? Die Antwort ist einfach: Wir schreiben bibliotheksgebundene Anwendungen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum arbeiten Unternehmen mit langj√§hriger Erfahrung mit React? </font><font style="vertical-align: inherit;">Ja, da die Anwendung stark von den Funktionen dieses React selbst abh√§ngt und um beim Neulackieren einer Schaltfl√§che nichts zu besch√§digen, sollten Sie sich √ºberlegen, wie die √Ñnderungserkennung, das Rendern des Komponentenbaums in React und die Beziehung zum Neulackieren der Schaltfl√§che funktionieren. </font><font style="vertical-align: inherit;">(Ich stimme zu, dies sind alles Sonderf√§lle ... Und sind Sie in Ihrem Unternehmen bereit, einen Spezialisten ohne Erfahrung mit dem Framework zu beauftragen?)</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmieren Sie mit einer Sprache, nicht mit einer Sprache. </font><font style="vertical-align: inherit;">(McConnell) Ein </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Framework ist ein Werkzeug, keine Lebensweise. </font><font style="vertical-align: inherit;">(Martin)</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºr die Welt der Front sind diese Thesen bestenfalls leere S√§tze und im schlimmsten Fall eine Herausforderung, das Gegenteil zu beweisen. </font><font style="vertical-align: inherit;">Schauen wir uns die offizielle React-Dokumentation an und sehen uns ein Beispiel f√ºr eine einfache ToDo-List-Anwendung.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beispiel-ToDo-Liste von der offiziellen React-Website</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props) {
    <span class="hljs-keyword">super</span>(props);
    <span class="hljs-keyword">this</span>.state = { <span class="hljs-attr">items</span>: [], <span class="hljs-attr">text</span>: <span class="hljs-string">''</span> };
    <span class="hljs-keyword">this</span>.handleChange = <span class="hljs-keyword">this</span>.handleChange.bind(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.handleSubmit = <span class="hljs-keyword">this</span>.handleSubmit.bind(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TodoList</span> <span class="hljs-attr">items</span>=<span class="hljs-string">{this.state.items}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">{this.handleSubmit}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">htmlFor</span>=<span class="hljs-string">"new-todo"</span>&gt;</span>
              ?
          <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span>
            <span class="hljs-attr">id</span>=<span class="hljs-string">"new-todo"</span>
            <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleChange}</span>
            <span class="hljs-attr">value</span>=<span class="hljs-string">{this.state.text}</span>
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>
             #{this.state.items.length + 1}
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  handleChange(e) {<font></font>
    <span class="hljs-keyword">this</span>.setState({ <span class="hljs-attr">text</span>: e.target.value });<font></font>
  }<font></font>
<font></font>
  handleSubmit(e) {<font></font>
    e.preventDefault();<font></font>
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.state.text.length) {
      <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">const</span> newItem = {
      <span class="hljs-attr">text</span>: <span class="hljs-keyword">this</span>.state.text,
      <span class="hljs-attr">id</span>: <span class="hljs-built_in">Date</span>.now()<font></font>
    };<font></font>
    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> ({
      <span class="hljs-attr">items</span>: state.items.concat(newItem),
      <span class="hljs-attr">text</span>: <span class="hljs-string">''</span><font></font>
    }));<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{<font></font>
  render() {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {this.props.items.map(item =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{item.id}</span>&gt;</span>{item.text}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄûMit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requisiten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> k√∂nnen Sie eine kleine Aufgabenlistenanwendung erstellen. </font><font style="vertical-align: inherit;">In diesem Beispiel wird </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">, um die aktuelle Liste der Elemente zu verfolgen ... "</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
F√ºr einen unerfahrenen Programmierer (dh mich vor ein paar Jahren) generiert dieser Satz automatisch die Ausgabe:" Hier ist ein ideales Beispiel f√ºr eine Aufgabenlistenanwendung ". </font><font style="vertical-align: inherit;">Aber wer speichert den Zustand in der Komponente ?! </font><font style="vertical-align: inherit;">Daf√ºr gibt es eine Zustandsverwaltungsbibliothek. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Beispiel f√ºr eine Aufgabenliste aus der Redux-Dokumentation</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ja, so ist die Anwendung viel klarer und einfacher geworden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nein)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">K√∂nnen wir versuchen, die Abh√§ngigkeiten in die richtige Richtung zu ziehen?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unabh√§ngige Entscheidung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir das Problem der Aufgabenliste nicht als Front-End, dh vergessen Sie, dass wir HTML zeichnen m√ºssen (‚ÄûWeb ist ein Detail‚Äú). </font><font style="vertical-align: inherit;">Wir k√∂nnen das Ergebnis nicht mit unseren Augen √ºberpr√ºfen, daher m√ºssen wir Tests schreiben (wie Onkel Bob sagt, "TDD kann dann angewendet werden"). </font><font style="vertical-align: inherit;">Und was ist die Aufgabe? </font><font style="vertical-align: inherit;">Was ist eine Aufgabenliste? </font><font style="vertical-align: inherit;">Wir versuchen zu schreiben.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Todo.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Todo'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'Todo'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todo: Todo;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todo = <span class="hljs-keyword">new</span> Todo(<span class="hljs-string">'description'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getItems() should returns Todo[]'</span>, () =&gt; {<font></font>
    expect(todo.getTitle()).toBe(<span class="hljs-string">'description'</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+isCompleted() should returns completion flag'</span>, () =&gt; {<font></font>
    expect(todo.isCompleted()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+toggleCompletion() should invert completion flag'</span>, () =&gt; {<font></font>
    todo.toggleCompletion();<font></font>
    expect(todo.isCompleted()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'TodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: TodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getItems() should returns Todo[]'</span>, () =&gt; {<font></font>
    expect(todoList.getItems()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should create item and add to collection'</span>, () =&gt; {<font></font>
    todoList.add(<span class="hljs-string">'Write tests'</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should create item with the description'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    expect(item.getTitle()).toBe(description);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getCompletedItems() should not returns uncompleted Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    expect(todoList.getCompletedItems()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getCompletedItems() should returns completed Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    item.toggleCompletion();<font></font>
    expect(todoList.getCompletedItems()).toEqual([item]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getUncompletedItems() should returns uncompleted Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    expect(todoList.getUncompletedItems()).toEqual([item]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getUncompletedItems() should not returns completed Todo[]'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> description = <span class="hljs-string">'Write tests'</span>;<font></font>
    todoList.add(description);<font></font>
    <span class="hljs-keyword">const</span> [item] = todoList.getItems();<font></font>
    item.toggleCompletion();<font></font>
    expect(todoList.getUncompletedItems()).toEqual([]);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  private completed: boolean = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private description: string) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.description;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Todo'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private items: Todo[] = [];<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items;<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  add(description: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.items.push(<span class="hljs-keyword">new</span> Todo(description));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir erhalten zwei einfache Klassen mit informativen Schnittstellen. </font><font style="vertical-align: inherit;">Ist das alles? </font><font style="vertical-align: inherit;">Tests bestehen. </font><font style="vertical-align: inherit;">Nehmen Sie nun die Reaktion auf.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<font></font>
<font></font>
<span class="hljs-keyword">import</span> { TodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./core/TodoList'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-attr">todoList</span>: TodoList = <span class="hljs-keyword">this</span>.createTodoList();<font></font>
<font></font>
  render(): any {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Todo List App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoListCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoListCmp</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">AddTodoCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AddTodoCmp</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  private createTodoList(): TodoList {<font></font>
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
    todoList.add(<span class="hljs-string">'Initial created Todo'</span>);
    <span class="hljs-keyword">return</span> todoList;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoListCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>What to do?<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {todoList.getItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.getTitle()}</span>&gt;</span>{todo.getTitle()}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
  );<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AddTodoCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todoList.add(`Todo ${todoList.getItems().length}`)}&gt;Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und stellen Sie sicher, dass ... das Hinzuf√ºgen eines Elements nicht funktioniert. </font><font style="vertical-align: inherit;">Hmm ... Jetzt ist klar, warum alles im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Status geschrieben werden muss</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - damit die React-Komponente nach dem Erlernen der √Ñnderungen neu gezeichnet wird. </font><font style="vertical-align: inherit;">Aber ist dies ein Grund, alle m√∂glichen Prinzipien zu verletzen und Logik in die Ansichtskomponente zu setzen? </font><font style="vertical-align: inherit;">Ein bisschen Geduld und Mut. </font><font style="vertical-align: inherit;">Um das Problem zu l√∂sen, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ist es</font></a><font style="vertical-align: inherit;"> perfekt </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, forceUpdate () in einer Endlosschleife oder im </font></font></s> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observer-Muster </font></font></a><font style="vertical-align: inherit;"><s><font style="vertical-align: inherit;">aufzurufen</font></s><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich mag die RxJs-Bibliothek, aber ich werde sie nicht verbinden, sondern nur die f√ºr unsere Aufgabe erforderliche API kopieren.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Observable'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'Observable'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> subject: Subject&lt;any&gt;;
  <span class="hljs-keyword">let</span> observable: Observable&lt;any&gt;;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    subject = <span class="hljs-keyword">new</span> Subject();<font></font>
    observable = subject.asObservable();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should call callback on next value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    observable.subscribe(spy);<font></font>
    subject.next({});<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should not call callback on next value if unsubscribed'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();
    <span class="hljs-keyword">const</span> subscription = observable.subscribe(spy);<font></font>
    subscription.unsubscribe();<font></font>
    subject.next({});<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).not.toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'should send to callback subject.next value'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    observable.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> sendingValue = {};<font></font>
    subject.next(sendingValue);<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy.calls.first().args[<span class="hljs-number">0</span>]).toBe(sendingValue);<font></font>
  });<font></font>
});<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delay</span>(<span class="hljs-params">timeoutInMs?: number</span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">void</span>&gt; </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> setTimeout(resolve, timeoutInMs));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Observable.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">export</span> interface Observable&lt;T = unknown&gt; {<font></font>
  subscribe(onNext: <span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>): Subscription;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> interface Subscription {<font></font>
  unsubscribe(): <span class="hljs-keyword">void</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>&lt;<span class="hljs-title">T</span> </span>= unknown&gt; implements Observable&lt;T&gt; {<font></font>
  protected callbackSet: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<font></font>
<font></font>
  asObservable(): Observable&lt;T&gt; {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<font></font>
  }<font></font>
<font></font>
  subscribe(onNext: <span class="hljs-function">(<span class="hljs-params">value: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>): Subscription {
    <span class="hljs-keyword">this</span>.callbackSet.add(onNext);
    <span class="hljs-keyword">return</span> { <span class="hljs-attr">unsubscribe</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.callbackSet.delete(onNext) };<font></font>
  }<font></font>
<font></font>
  next(value: T): <span class="hljs-keyword">void</span> {
    <span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.callbackSet.forEach(<span class="hljs-function">(<span class="hljs-params">onNext</span>) =&gt;</span> onNext(value)));<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meiner Meinung nach nichts zu kompliziert. </font><font style="vertical-align: inherit;">F√ºgen Sie einen Test hinzu (Benachrichtigung √ºber √Ñnderungen - das ist die Logik).</font></font><br>
<br>
<pre><code class="javascript hljs">  it(<span class="hljs-string">'+TodoList.prototype.add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add(<span class="hljs-string">'description'</span>);
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns einen Moment nachdenken, aber wirkt sich eine √Ñnderung eines Todo-Elements auf den Status einer TodoList aus? Auswirkungen - Die Methoden getCompletedItems / getUncompletedItems m√ºssen einen anderen Satz von Elementen zur√ºckgeben. Vielleicht lohnt es sich, die toggleCompletion in die TodoList-Klasse zu verschieben? Es ist eine schlechte Idee - bei diesem Ansatz m√ºssen wir TodoList f√ºr jede Funktion in Bezug auf ein neues Todo-Element aufblasen (wir werden sp√§ter darauf zur√ºckkommen). Aber wie erf√§hrt man von den Ver√§nderungen, wieder der Beobachter? Lassen Sie das Todo-Element selbst √Ñnderungen √ºber einen R√ºckruf kommunizieren, um die Sache zu vereinfachen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Vollversion des Programms sieht so aus.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { generateId } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/generateId'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  private completed: boolean = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  id: string = generateId();<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private description: string, private onCompletionToggle?: (todo: Todo) =&gt; void) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.description;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;
    <span class="hljs-keyword">this</span>.onCompletionToggle?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private items: Todo[] = [];<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items;<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.filter(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> !todo.isCompleted());<font></font>
  }<font></font>
<font></font>
  add(description: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.items.push(<span class="hljs-keyword">new</span> Todo(description, () =&gt; <span class="hljs-keyword">this</span>.changesSubject.next({})));
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-attr">todoList</span>: TodoList = <span class="hljs-keyword">this</span>.createTodoList();<font></font>
<font></font>
  render(): any {<font></font>
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.Fragment</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Todo List App<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">main</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoListCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoListCmp</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">AddTodoCmp</span> <span class="hljs-attr">todoList</span>=<span class="hljs-string">{this.todoList}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">AddTodoCmp</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">main</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">React.Fragment</span>&gt;</span></span><font></font>
    );<font></font>
  }<font></font>
<font></font>
  componentDidMount(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.todoList.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.forceUpdate());<font></font>
  }<font></font>
<font></font>
  private createTodoList(): TodoList {<font></font>
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoList();<font></font>
    todoList.add(<span class="hljs-string">'Initial created Todo'</span>);
    <span class="hljs-keyword">return</span> todoList;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoListCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>What to do?<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
        {todoList.getUncompletedItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoCmp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoCmp</span>&gt;</span>
        ))}
        {todoList.getCompletedItems().map((todo) =&gt; (
          <span class="hljs-tag">&lt;<span class="hljs-name">TodoCmp</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{todo.id}</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TodoCmp</span>&gt;</span>
        ))}
      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
  );<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> TodoCmp: React.FC&lt;{ <span class="hljs-attr">todo</span>: Todo }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todo }</span>) =&gt;</span> (
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>
    <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">textDecoration:</span> <span class="hljs-attr">todo.isCompleted</span>() ? '<span class="hljs-attr">line-through</span>' <span class="hljs-attr">:</span> '' }}
    <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todo.toggleCompletion()}
  &gt;
    {todo.getTitle()}
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> AddTodoCmp: React.FC&lt;{ <span class="hljs-attr">todoList</span>: TodoList }&gt; = <span class="hljs-function">(<span class="hljs-params">{ todoList }</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> todoList.add(`Todo ${todoList.getItems().length}`)}&gt;Add<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So sollte die vom Framework unabh√§ngige ToDo-List-Anwendung aussehen. </font><font style="vertical-align: inherit;">Die einzige Einschr√§nkung ist PL. </font><font style="vertical-align: inherit;">Sie k√∂nnen die Anzeige f√ºr die Konsole implementieren oder Angular verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√∂glicherweise ist die aktuelle Version der Anwendung nicht komplex genug, um sicherzustellen, dass ein unabh√§ngiger Ansatz funktioniert, und um seine St√§rken zu demonstrieren. </font><font style="vertical-align: inherit;">Daher werden wir unsere Vorstellungskraft verbinden, um ein mehr oder weniger plausibles ToDo-List-Entwicklungsszenario zu simulieren.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñnderungen vom Kunden</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptalptraum der meisten Projekte sind sich √§ndernde Anforderungen. </font><font style="vertical-align: inherit;">Sie wissen, dass √Ñnderungen nicht vermieden werden k√∂nnen, und Sie wissen, dass dies normal ist. </font><font style="vertical-align: inherit;">Aber wie bereiten Sie sich auf zuk√ºnftige Ver√§nderungen vor?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spezielle Todo-Elemente</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der Hauptmerkmale von OOP ist die F√§higkeit, das Problem durch die Einf√ºhrung neuer Typen zu l√∂sen. Vielleicht ist dies die leistungsst√§rkste OOP-Technik, mit der ein komplexes und umst√§ndliches Programm im Alleingang erstellt werden kann. Zum Beispiel wei√ü ich nicht, was vom Todo-Element verlangt wird. Es kann notwendig sein, seinen Namen √§ndern zu k√∂nnen, es kann notwendig sein, zus√§tzliche Attribute hinzuzuf√ºgen, es kann m√∂glich sein, dieses Element durch direkten Zugriff auf den SpaceX-Server zu √§ndern ... Aber ich bin sicher, dass sich die Anforderungen √§ndern werden und ich verschiedene Arten von Todo ben√∂tigen werde.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableTodo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  changeTitle(title: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass wir zur Anzeige eines speziellen Typs auch die Ansichtskomponenten √§ndern m√ºssen. In der Praxis habe ich Komponenten getroffen (und geschrieben), bei denen eine Million verschiedener Bedingungen einen Div-Block von einer Giraffe in ein Maschinengewehr verwandeln. Um dieses Problem zu vermeiden, k√∂nnen Sie eine Hoc-Komponente mit einer riesigen Switch-Case-Liste erstellen. Oder wenden Sie das </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besuchermuster</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den doppelten Versand an und lassen Sie das Todo-Element selbst entscheiden, welche Art von Komponente gezeichnet werden soll.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Todo</span> </span>{
  <span class="hljs-attr">id</span>: string = <span class="hljs-string">''</span>;<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(<font></font>
    protected title: string,<font></font>
    private completed: boolean = false,<font></font>
    protected onChange?: (todo: Todo) =&gt; void,<font></font>
  ) {}<font></font>
<font></font>
  getTitle(): string {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.title;<font></font>
  }<font></font>
<font></font>
  isCompleted(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.completed;<font></font>
  }<font></font>
<font></font>
  toggleCompletion(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.completed = !<span class="hljs-keyword">this</span>.completed;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render(renderer: TodoRenderer): any {<font></font>
    <span class="hljs-keyword">return</span> renderer.renderSimpleTodo(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EditableTodo</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Todo</span> </span>{<font></font>
  changeTitle(title: string): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.title = title;
    <span class="hljs-keyword">this</span>.onChange?.(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
<font></font>
  render(renderer: TodoRenderer): any {<font></font>
    <span class="hljs-keyword">return</span> renderer.renderEditableTodo(<span class="hljs-keyword">this</span>);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoRenderer</span> </span>{<font></font>
  renderSimpleTodo(todo: Todo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SimpleTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SimpleTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
<font></font>
  renderFixedTodo(todo: Todo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FixedTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">FixedTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
<font></font>
  renderEditableTodo(todo: EditableTodo): any {<font></font>
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">EditableTodoCmp</span> <span class="hljs-attr">todo</span>=<span class="hljs-string">{todo}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">EditableTodoCmp</span>&gt;</span></span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Option f√ºr den doppelten Versand ist besonders n√ºtzlich, wenn ein Artikeltyp unterschiedliche Ansichten hat. </font><font style="vertical-align: inherit;">Sie k√∂nnen sie √§ndern, indem Sie verschiedene TodoRenderer in die Rendermethode einsetzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jetzt sind wir bereit. </font><font style="vertical-align: inherit;">Die Angst vor neuen Anforderungen an ‚Äûspezielle‚Äú Todo-Elemente ist verschwunden. </font><font style="vertical-align: inherit;">Ich denke, die Entwickler selbst k√∂nnten die Initiative ergreifen und einige Funktionen anbieten, die die Einf√ºhrung neuer Typen erfordern, die jetzt durch Schreiben von neuem Code und minimale √Ñnderungen am vorhandenen hinzugef√ºgt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichern von Daten auf dem Server</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was f√ºr eine Anwendung ist ohne Interaktion mit dem Server? </font><font style="vertical-align: inherit;">Nat√ºrlich m√ºssen Sie in der Lage sein, unsere Liste √ºber HTTP zu speichern - eine weitere neue Anforderung. </font><font style="vertical-align: inherit;">Wir versuchen das Problem zu l√∂sen.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppTodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoType } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { AppTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./AppTodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'AppTodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: AppTodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({
      <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">type</span>: TodoType.Simple, <span class="hljs-attr">title</span>: <span class="hljs-string">'Loaded todo'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> }],
      <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(),<font></font>
    });<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should load saved todo items'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    expect(todoList.getItems().length).toBeGreaterThan(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should save todoList state on success and rollback to it on error'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> api = { <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve() };<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList(api);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'1'</span> });
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">const</span> savedData = <span class="hljs-built_in">JSON</span>.stringify(todoList.getItems());<font></font>
    api.save = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Mock saving failed'</span>);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'2'</span> });<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">await</span> delay(<span class="hljs-number">1</span>);<font></font>
    expect(<span class="hljs-built_in">JSON</span>.stringify(todoList.getItems())).toBe(savedData);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> interface TodoListApi {<font></font>
  getItems(): <span class="hljs-built_in">Promise</span>&lt;TodoParams[]&gt;;<font></font>
  save(todoParamsList: TodoParams[]): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt;;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
<font></font>
  changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private subscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());<font></font>
  private synchronizedTodoParamsList: TodoParams[] = [];<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {}<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.updateState(todoParamsList);<font></font>
  }<font></font>
<font></font>
  private updateState(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.state = todoList;
    <span class="hljs-keyword">this</span>.subscription.unsubscribe();
    <span class="hljs-keyword">this</span>.subscription = todoList.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());
    <span class="hljs-keyword">this</span>.synchronizedTodoParamsList = todoParamsList;
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private <span class="hljs-keyword">async</span> onStateChanges(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">this</span>.changesSubject.next({});
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));
      <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.save(params);
      <span class="hljs-keyword">this</span>.synchronizedTodoParamsList = params;<font></font>
    } <span class="hljs-keyword">catch</span> {
      <span class="hljs-keyword">this</span>.updateState(<span class="hljs-keyword">this</span>.synchronizedTodoParamsList);<font></font>
    }<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.subscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir wissen nicht, wie sich die Anwendung verhalten soll. </font><font style="vertical-align: inherit;">Warten Sie, bis der Speichervorgang erfolgreich war, und zeigen Sie die √Ñnderungen an. </font><font style="vertical-align: inherit;">√Ñnderungen anzeigen lassen und im Fehlerfall in den synchronisierten Zustand zur√ºcksetzen? </font><font style="vertical-align: inherit;">Oder Speicherfehler ganz ignorieren? </font><font style="vertical-align: inherit;">H√∂chstwahrscheinlich wei√ü der Kunde dies auch nicht. </font><font style="vertical-align: inherit;">√Ñnderungen der Anforderungen sind daher unvermeidlich, sollten jedoch nur eine Klasse betreffen, die f√ºr die Erhaltung verantwortlich ist. </font><font style="vertical-align: inherit;">Und unterwegs die n√§chste Bearbeitung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschichte ver√§ndern</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"Wir brauchen die F√§higkeit, Aktionen abzubrechen / zu wiederholen" ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass uns eine Welle neuer √Ñnderungen √ºberrascht. </font><font style="vertical-align: inherit;">Aber in keinem Fall k√∂nnen Sie Tests opfern. </font><font style="vertical-align: inherit;">Nun ist v√∂llig unklar, welche Vererbungshierarchie besser geeignet ist und ob die Vererbung allgemein geeignet ist. </font><font style="vertical-align: inherit;">Daher wird nichts Schlimmes passieren, wenn wir einfach unsere schmutzige Klasse erg√§nzen (wir werden dies als Implementierungsdetails betrachten) und das Prinzip der alleinigen Verantwortung opfern.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TodoListHistory.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoListHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListHistory'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'TodoListHistory'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> history: TodoListHistory;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    history = <span class="hljs-keyword">new</span> TodoListHistory();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+getState() should returns TodoParams[]'</span>, () =&gt; {<font></font>
    expect(history.getState()).toEqual([]);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+setState() should rewrite current state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> newState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(newState);<font></font>
    expect(history.getState()).toBe(newState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns false on init'</span>, () =&gt; {<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns true after setState()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should switch on prev state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(prevState);<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasPrev() should returns false after switch to first'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false on init'</span>, () =&gt; {<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns true after switchToPrev()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">true</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToNext() should switch on next state'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState([]);<font></font>
    history.setState(prevState);<font></font>
    history.switchToPrev();<font></font>
    history.switchToNext();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false after switchToNext()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.switchToNext();<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+hasNext() should returns false after setState()'</span>, () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.setState([]);<font></font>
    expect(history.hasNext()).toBe(<span class="hljs-literal">false</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should switch on prev state after setState()'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> prevState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.setState(prevState);<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    expect(history.getState()).toBe(prevState);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+setState() should not emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.setState([]);<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).not.toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+switchToPrev() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    history.switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    history.changes.subscribe(spy);<font></font>
    history.switchToNext();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+reset() should reset history and apply initial state'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    history.setState([]);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">true</span>);
    <span class="hljs-keyword">const</span> initState = [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }] <span class="hljs-keyword">as</span> TodoParams[];<font></font>
    history.reset(initState);<font></font>
    expect(history.hasPrev()).toBe(<span class="hljs-literal">false</span>);<font></font>
    expect(history.getState()).toBe(initState);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AppTodoList.spec.ts</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { delay } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/delay'</span>;
<span class="hljs-keyword">import</span> { TodoType } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { AppTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./AppTodoList'</span>;<font></font>
<font></font>
describe(<span class="hljs-string">'AppTodoList'</span>, () =&gt; {
  <span class="hljs-keyword">let</span> todoList: AppTodoList;<font></font>
<font></font>
  beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({
      <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">type</span>: TodoType.Simple, <span class="hljs-attr">title</span>: <span class="hljs-string">'Loaded todo'</span>, <span class="hljs-attr">completed</span>: <span class="hljs-literal">false</span> }],
      <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> delay(),<font></font>
    });<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should load saved todo items'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    expect(todoList.getItems().length).toBeGreaterThan(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should emit changes'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+todo.onChange() should call TodoListApi.save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList({ <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [{ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> }], <span class="hljs-attr">save</span>: <span class="hljs-keyword">async</span> () =&gt; spy() });
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">const</span> [todo] = todoList.getItems();<font></font>
    todo.toggleCompletion();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should ignore error on save'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">const</span> api = { <span class="hljs-attr">getItems</span>: <span class="hljs-keyword">async</span> () =&gt; [], <span class="hljs-attr">save</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">Promise</span>.resolve() };<font></font>
    todoList = <span class="hljs-keyword">new</span> AppTodoList(api);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'1'</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    api.save = jasmine.createSpy().and.returnValue(<span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'Mock saving failed'</span>));<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">'2'</span> });<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(api.save).toHaveBeenCalled();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+resolve() should provide current todoList state to history'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">await</span> todoList.resolve();
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should provide current todoList state to history'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+history.switchToPrev() should change todoList state on prev'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">0</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+history.switchToPrev() should change todoList state on prev after resolve()'</span>, <span class="hljs-keyword">async</span> () =&gt; {
    <span class="hljs-keyword">await</span> todoList.resolve();<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">2</span>);<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(todoList.getHistory().getState()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
    expect(todoList.getItems()).toHaveLength(<span class="hljs-number">1</span>);<font></font>
  });<font></font>
<font></font>
  it(<span class="hljs-string">'+add() should emit changes after history.switchToPrev()'</span>, <span class="hljs-keyword">async</span> () =&gt; {<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });<font></font>
    todoList.getHistory().switchToPrev();<font></font>
    <span class="hljs-keyword">await</span> delay();
    <span class="hljs-keyword">const</span> spy = jasmine.createSpy();<font></font>
    todoList.changes.subscribe(spy);<font></font>
    todoList.add({ <span class="hljs-attr">title</span>: <span class="hljs-string">''</span> });
    <span class="hljs-keyword">await</span> delay();<font></font>
    expect(spy).toHaveBeenCalled();<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
</div></div><br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoListHistory</span> </span>{<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
  private history: TodoParams[][] = [<span class="hljs-keyword">this</span>.state];<font></font>
<font></font>
  changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private state: TodoParams[] = []) {}<font></font>
<font></font>
  reset(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.history = [<span class="hljs-keyword">this</span>.state];<font></font>
  }<font></font>
<font></font>
  getState(): TodoParams[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state;<font></font>
  }<font></font>
<font></font>
  setState(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.deleteHistoryAfterCurrentState();
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.history.push(state);<font></font>
  }<font></font>
<font></font>
  private nextState(state: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = state;
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private deleteHistoryAfterCurrentState(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history = <span class="hljs-keyword">this</span>.history.slice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.getCurrentStateIndex() + <span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  hasPrev(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getCurrentStateIndex() &gt; <span class="hljs-number">0</span>;<font></font>
  }<font></font>
<font></font>
  hasNext(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getCurrentStateIndex() &lt; <span class="hljs-keyword">this</span>.history.length - <span class="hljs-number">1</span>;<font></font>
  }<font></font>
<font></font>
  switchToPrev(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> prevStateIndex = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.getCurrentStateIndex() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">this</span>.nextState(<span class="hljs-keyword">this</span>.history[prevStateIndex]);<font></font>
  }<font></font>
<font></font>
  switchToNext(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> nextStateIndex = <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.getCurrentStateIndex() + <span class="hljs-number">1</span>, <span class="hljs-keyword">this</span>.history.length - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">this</span>.nextState(<span class="hljs-keyword">this</span>.history[nextStateIndex]);<font></font>
  }<font></font>
<font></font>
  private getCurrentStateIndex(): number {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.indexOf(<span class="hljs-keyword">this</span>.state);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">import</span> { Observable, Subject, Subscription } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/Todo'</span>;
<span class="hljs-keyword">import</span> { TodoFactory, TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { TodoList, TodoListImp } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoList'</span>;
<span class="hljs-keyword">import</span> { TodoListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListApi'</span>;
<span class="hljs-keyword">import</span> { HistoryControl, TodoListHistory } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListHistory'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span> </span>{<font></font>
  private readonly todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  private readonly history: TodoListHistory = <span class="hljs-keyword">new</span> TodoListHistory();<font></font>
<font></font>
  private changesSubject = <span class="hljs-keyword">new</span> Subject();<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private stateSubscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
    <span class="hljs-keyword">this</span>.onStateChanges(),<font></font>
  );<font></font>
  private historySubscription = <span class="hljs-keyword">this</span>.history.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onHistoryChanges());<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {}<font></font>
<font></font>
  private onStateChanges(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));
    <span class="hljs-keyword">this</span>.history.setState(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private onHistoryChanges(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> params = <span class="hljs-keyword">this</span>.history.getState();
    <span class="hljs-keyword">this</span>.updateStateTodoList(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});<font></font>
  }<font></font>
<font></font>
  private updateStateTodoList(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">const</span> todoList = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.state = todoList;
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.stateSubscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.onStateChanges());
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.history.reset(todoParamsList);
    <span class="hljs-keyword">this</span>.updateStateTodoList(todoParamsList);<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.historySubscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getHistory(): HistoryControl&lt;TodoParams[]&gt; {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history;<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da der √Ñnderungsverlauf ziemlich identisch ist, trennen wir die Verwaltung des Aufgabenlistenverlaufs in die Basisklasse.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">import</span> { Todo } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/Todo'</span>;
<span class="hljs-keyword">import</span> { Observable, Subject, Subscription } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/utils/Observable'</span>;
<span class="hljs-keyword">import</span> { TodoFactory, TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { TodoList, TodoListImp } <span class="hljs-keyword">from</span> <span class="hljs-string">'../core/TodoList'</span>;
<span class="hljs-keyword">import</span> { HistoryControl, HistoryState } <span class="hljs-keyword">from</span> <span class="hljs-string">'./HistoryState'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HistoricalTodoList</span> <span class="hljs-title">implements</span> <span class="hljs-title">TodoList</span>, <span class="hljs-title">HistoryControl</span> </span>{<font></font>
  protected readonly todoFactory = <span class="hljs-keyword">new</span> TodoFactory();<font></font>
  protected readonly history = <span class="hljs-keyword">new</span> HistoryState&lt;TodoParams[]&gt;([]);<font></font>
<font></font>
  private changesSubject: Subject = <span class="hljs-keyword">new</span> Subject();<font></font>
  readonly changes: Observable = <span class="hljs-keyword">this</span>.changesSubject.asObservable();<font></font>
<font></font>
  private state: TodoList = <span class="hljs-keyword">new</span> TodoListImp();<font></font>
  private stateSubscription: Subscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
    <span class="hljs-keyword">this</span>.onStateChanged(<span class="hljs-keyword">this</span>.getSerializedState()),<font></font>
  );<font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>() {}<font></font>
<font></font>
  protected onStateChanged(params: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.addState(params);
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  protected onHistorySwitched(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.updateState(<span class="hljs-keyword">this</span>.history.getState());<font></font>
  }<font></font>
<font></font>
  protected updateState(todoParamsList: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state = <span class="hljs-keyword">new</span> TodoListImp(todoParamsList);
    <span class="hljs-keyword">this</span>.updateStateSubscription();
    <span class="hljs-keyword">this</span>.changesSubject.next({});<font></font>
  }<font></font>
<font></font>
  private updateStateSubscription(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();
    <span class="hljs-keyword">this</span>.stateSubscription = <span class="hljs-keyword">this</span>.state.changes.subscribe(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
      <span class="hljs-keyword">this</span>.onStateChanged(<span class="hljs-keyword">this</span>.getSerializedState()),<font></font>
    );<font></font>
  }<font></font>
<font></font>
  private getSerializedState(): TodoParams[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems().map(<span class="hljs-function">(<span class="hljs-params">todo</span>) =&gt;</span> <span class="hljs-keyword">this</span>.todoFactory.serializeTodo(todo));<font></font>
  }<font></font>
<font></font>
  destroy(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.stateSubscription.unsubscribe();<font></font>
  }<font></font>
<font></font>
  getItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getItems();<font></font>
  }<font></font>
<font></font>
  getCompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getCompletedItems();<font></font>
  }<font></font>
<font></font>
  getUncompletedItems(): Todo[] {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.state.getUncompletedItems();<font></font>
  }<font></font>
<font></font>
  add(todoParams: TodoParams): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.state.add(todoParams);<font></font>
  }<font></font>
<font></font>
  canUndo(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.hasPrev();<font></font>
  }<font></font>
<font></font>
  canRedo(): boolean {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.history.hasNext();<font></font>
  }<font></font>
<font></font>
  undo(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.switchToPrev();
    <span class="hljs-keyword">this</span>.onHistorySwitched();<font></font>
  }<font></font>
<font></font>
  redo(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">this</span>.history.switchToNext();
    <span class="hljs-keyword">this</span>.onHistorySwitched();<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">import</span> { TodoParams } <span class="hljs-keyword">from</span> <span class="hljs-string">'src/core/TodoFactory'</span>;
<span class="hljs-keyword">import</span> { HistoricalTodoList } <span class="hljs-keyword">from</span> <span class="hljs-string">'./HistoricalTodoList'</span>;
<span class="hljs-keyword">import</span> { TodoListApi } <span class="hljs-keyword">from</span> <span class="hljs-string">'./TodoListApi'</span>;<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResolvableTodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HistoricalTodoList</span> </span>{
  <span class="hljs-keyword">constructor</span>(private api: TodoListApi) {
    <span class="hljs-keyword">super</span>();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">async</span> resolve(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; {
    <span class="hljs-keyword">const</span> todoParamsList = <span class="hljs-keyword">await</span> <span class="hljs-keyword">this</span>.api.getItems();
    <span class="hljs-keyword">this</span>.history.reset(todoParamsList);
    <span class="hljs-keyword">this</span>.updateState(todoParamsList);<font></font>
  }<font></font>
<font></font>
  protected onStateChanged(params: TodoParams[]): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">super</span>.onStateChanged(params);
    <span class="hljs-keyword">this</span>.api.save(params).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.undo());<font></font>
  }<font></font>
<font></font>
  protected onHistorySwitched(): <span class="hljs-keyword">void</span> {
    <span class="hljs-keyword">super</span>.onHistorySwitched();
    <span class="hljs-keyword">this</span>.api.save(<span class="hljs-keyword">this</span>.history.getState()).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {});<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die L√∂sung des Naturschutzproblems kam von selbst. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir uns keine Gedanken dar√ºber machen, welche Erhaltungsstrategie der Kunde langfristig w√§hlen wird. </font><font style="vertical-align: inherit;">Sie k√∂nnen ihm alle drei Optionen zur Auswahl stellen und die Basisklasse erweitern.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusammenfassung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass wir von unserer Aufgabenliste einen kleinen Prototyp von Google Keep haben. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verkn√ºpfen Sie das Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die Anwendung zu starten, oder gehen Sie den Verlauf der Commits durch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was unterscheidet dieses Beispiel grundlegend von den meisten Front-End-Anwendungen? Wir waren nicht auf Bibliotheken angewiesen, daher kann eine Person, die noch nie mit React gearbeitet hat, diese Anwendung verstehen. Unsere Entscheidungen zielten nur darauf ab, das Ergebnis zu erzielen, ohne die Details des Frameworks abzulenken, sodass der Code mehr oder weniger das zu l√∂sende Problem widerspiegelt. Wir haben es geschafft, das Hinzuf√ºgen neuer Arten von Todo-Elementen zu vereinfachen, und sind bereit, die Erhaltungsstrategie zu √§ndern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf welche Schwierigkeiten sind wir gesto√üen? Wir haben das Problem der Aktualisierung der Ansicht mithilfe des Observer-Musters ohne Bezugnahme auf das Framework gel√∂st. Wie sich herausstellte, war die Anwendung dieses Musters immer noch erforderlich, um das Hauptproblem zu l√∂sen (auch wenn wir kein HTML zeichnen mussten). Daher sind uns keine Kosten entstanden, indem wir die ‚ÄûDienste‚Äú des in das Framework integrierten √Ñnderungserkennungssystems aufgegeben haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich m√∂chte betonen, dass das Schreiben von Tests keine Schwierigkeit war. Das Testen einfacher unabh√§ngiger Objekte mit einer informativen Oberfl√§che ist ein Vergn√ºgen. Die Komplexit√§t des Codes hing nur von der Aufgabe selbst und meinen F√§higkeiten (oder meiner Kr√ºmmung) ab.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist mit der Ebene der Entwickler, die damit umgehen w√ºrden? </font><font style="vertical-align: inherit;">K√∂nnte Junior React Developer eine solche L√∂sung schreiben? </font><font style="vertical-align: inherit;">‚ÄûProgrammieren ist eher ein Handwerk‚Äú. Ohne die Verwendung von OOP und Mustern w√§re dies meiner Meinung nach schwierig. </font><font style="vertical-align: inherit;">Aber Sie und Ihr Unternehmen entscheiden, in was Sie investieren. </font><font style="vertical-align: inherit;">√úben Sie OOP oder verstehen Sie die Feinheiten des n√§chsten Frameworks? </font><font style="vertical-align: inherit;">Ich wurde erst wieder von der Relevanz der literarischen Werke erfahrener Programmierer √ºberzeugt und zeigte, wie man den Rat der Klassiker an der Front mit voller Kapazit√§t einsetzt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danke f√ºrs Lesen!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de491672/index.html">Pl√∂tzlich: Anf√ºhrungszeichen gegen Obskurantismus. Was auch immer das hei√üt</a></li>
<li><a href="../de491674/index.html">32 Unterschiede im Design einer mobilen Anwendung f√ºr iOS und Android</a></li>
<li><a href="../de491678/index.html">Amazon Go: No Cash Desk - Eine pers√∂nliche Erfahrung</a></li>
<li><a href="../de491680/index.html">Intel Atom P5900: Das zweite Atom</a></li>
<li><a href="../de491682/index.html">Sicherheitswoche 11: Suchmaschinen-Malware</a></li>
<li><a href="../de491686/index.html">Java Digest 10. M√§rz</a></li>
<li><a href="../de491690/index.html">Datenschutz sch√ºtzen - die Herausforderung des Jahrhunderts</a></li>
<li><a href="../de491692/index.html">Debuggen von Winkelschemata mit Visual Studio-Code</a></li>
<li><a href="../de491694/index.html">90er Computer-Marken</a></li>
<li><a href="../de491696/index.html">Fang mich, wenn du kannst: Radiowellen, eine Kaskade von Partikeln und Eis, um Neutrinos einzufangen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>