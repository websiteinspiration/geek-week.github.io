<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐺 🤳🏽 🐝 列挙型パートIIの値の最大数 🛐 😑 🧜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="パート1、理論  | パート2、実用的
 
 
 列挙内の値の最大数を引き続き検索します。
 今回は、問題の実際的な側面に焦点を当て、IDE、コンパイラ、JVMが私たちの成果にどのように反応するかを確認します。
 
 コンテンツ
   
   Javac ツール
   Extractメソッド
   ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>列挙型パートIIの値の最大数</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501870/"><nobr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート1、理論</font></font></b></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &nbsp;|&nbsp;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パート2、実用的</font></font></b></nobr><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列挙内の値の最大数を引き続き検索します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回は、問題の実際的な側面に焦点を当て、IDE、コンパイラ、JVMが私たちの成果にどのように反応するかを確認します。</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテンツ</font></font></h1><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ツール</font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extractメソッド</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的なクラスファイル定数</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突然の問題</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るい未来</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全でない</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></a><br>
    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javacとスイッチの</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パフォーマンス</font></a></font><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></a><br>
  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のリソース</font></font></a><br>
<br>
<a name="Tools"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツール</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javacが私たちの面倒を見てくれます。それ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、識別子から好きではない文字を切り取り、それからの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">継承を禁止する</font></font><code>java.lang.Enum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、実験のために他のツールが必要です。</font><font style="vertical-align: inherit;">JVMのアセンブラーおよび逆アセンブラーとして</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">asmtools</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用して仮説を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ASM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライブラリーを使用して産業規模でクラスファイルを生成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理解を簡単にするために、起こっていることの本質はjavaのような疑似コードに複製されます。</font></font><br>
<br>
<a name="Javac"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javac</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開始点として、トリックを1つだけ使用して、トリックなしで達成可能な最良の結果を得ることが論理的</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ここではすべてが簡単です。列挙でソースファイルを作成し、javacが</font><font style="vertical-align: inherit;">「コードが大きすぎる」悪態で</font><font style="vertical-align: inherit;">コンパイル</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">拒否するまで要素を追加します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java 1.7以降、かなり長い間、この数は2_746要素のレベルに保たれています。</font><font style="vertical-align: inherit;">しかし、Java 11以降のどこかで、定数プールに値を格納するアルゴリズムに変更があり、最大数は2_743に減少しました。</font><font style="vertical-align: inherit;">はい、はい。定数のプール内の要素の順序を変更しただけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最高の価値に焦点を当てます。</font></font><br>
<br>
<a name="ExtractMethod"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽出方法</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
制限要因の1つは静的初期化ブロックのバイトコードのサイズに関連しているので、静的初期化ブロックをできるだけ簡単にするようにします。</font><font style="vertical-align: inherit;">最初のパートの</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列挙の例でどのように見えるかを思い出してください</font></font><code>FizzBuzz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">コメントは適切な組み立て手順を提供します。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的{}</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//  0: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: ldc           #22                 // String Fizz</span>
    <span class="hljs-comment">//  6: iconst_0</span>
    <span class="hljs-comment">//  7: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 10: putstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    Buzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 13: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 16: dup</span>
    <span class="hljs-comment">// 17: ldc           #28                 // String Buzz</span>
    <span class="hljs-comment">// 19: iconst_1</span>
    <span class="hljs-comment">// 20: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 23: putstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    FizzBuzz = <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);
    <span class="hljs-comment">// 26: new           #2                  // class FizzBuzz</span>
    <span class="hljs-comment">// 29: dup</span>
    <span class="hljs-comment">// 30: ldc           #32                 // String FizzBuzz</span>
    <span class="hljs-comment">// 32: iconst_2</span>
    <span class="hljs-comment">// 33: invokespecial #24                 // Method "&lt;init&gt;":(Ljava/lang/String;I)V</span>
    <span class="hljs-comment">// 36: putstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span><font></font>
<font></font>
    $VALUES = <span class="hljs-keyword">new</span> FizzBuzz[] {
    <span class="hljs-comment">// 39: iconst_3</span>
    <span class="hljs-comment">// 40: anewarray     #2                  // class FizzBuzz</span><font></font>
        Fizz, <font></font>
    <span class="hljs-comment">// 43: dup</span>
    <span class="hljs-comment">// 44: iconst_0</span>
    <span class="hljs-comment">// 45: getstatic     #25                 // Field Fizz:LFizzBuzz;</span>
    <span class="hljs-comment">// 48: aastore</span><font></font>
        Buzz, <font></font>
    <span class="hljs-comment">// 49: dup</span>
    <span class="hljs-comment">// 50: iconst_1</span>
    <span class="hljs-comment">// 51: getstatic     #30                 // Field Buzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 54: aastore</span><font></font>
        FizzBuzz<font></font>
    <span class="hljs-comment">// 55: dup</span>
    <span class="hljs-comment">// 56: iconst_2</span>
    <span class="hljs-comment">// 57: getstatic     #33                 // Field FizzBuzz:LFizzBuzz;</span>
    <span class="hljs-comment">// 60: aastore</span><font></font>
    };<font></font>
    <span class="hljs-comment">// 61: putstatic     #1                  // Field $VALUES:[LFizzBuzz;</span>
    <span class="hljs-comment">// 64: return</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に頭に浮かぶのは、配列の作成と入力を</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">別のメソッド</font><font style="vertical-align: inherit;">に入れる</font><font style="vertical-align: inherit;">ことです。</font></font><br>
<br>
<pre><code class="java hljs">$VALUES = createValues();
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアイデアを発展させると、列挙要素のインスタンスの作成を同じメソッドに転送できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    FizzBuzz[] localValues = createValues();<font></font>
<font></font>
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
    Fizz = localValues[index++];<font></font>
    Buzz = localValues[index++];<font></font>
    FizzBuzz = localValues[index++];<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>), 
        <span class="hljs-keyword">new</span> FizzBuzz(<span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>)<font></font>
    };<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに優れていますが、配列要素のキャプチャとそれに続くインデックスの増分には6バイトのコストがかかります。</font><font style="vertical-align: inherit;">別の方法でそれらを出す。</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> valueIndex;<font></font>
<font></font>
<span class="hljs-keyword">static</span>  {<font></font>
    $VALUES = createValues();<font></font>
<font></font>
    valueIndex = <span class="hljs-number">0</span>;<font></font>
    Fizz = nextValue();<font></font>
    Buzz = nextValue();<font></font>
    FizzBuzz = nextValue();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">nextValue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> $VALUES[valueIndex++];<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが</font><font style="vertical-align: inherit;">ために11のバイトを要する</font><font style="vertical-align: inherit;">初期化</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および静的初期化ブロックからの復帰</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">及び65_524よりバイトのフィールドを初期化するために残っています。</font><font style="vertical-align: inherit;">各フィールドの初期化には6バイトが必要です。これにより、10_920要素の列挙を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
javacに比べて4倍近くの成長は、コード生成によって必ず祝われるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターのソースコード：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnumGenerator.java生成された</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
クラスの例：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExtractMethodHugeEnum.class</font></font></a><br>
<a name="ConDy"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的クラスファイル定数</font></font></h1><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 309</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とその神秘的な</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的定数</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
について覚えておくべき時</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一言で言えばイノベーションの本質：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数のプールによってサポートされている既存の型に、もう1つ追加されました</font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。クラスをロードするとき、そのような定数の型はわかっていますが、その値は不明です。定数を最初にロードすると、宣言で指定されたブートストラップメソッドが呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このメソッドの結果は定数値になります。すでに初期化されている定数に関連付けられている値を変更する方法はありません。これは定数にとって非常に論理的です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルトンについても考えていたら、すぐに忘れてください。</font><font style="vertical-align: inherit;">この場合、仕様ではスレッドの安全性は保証されないことを強調しており、マルチスレッドコードの初期化メソッドは複数回呼び出すことができます。</font><font style="vertical-align: inherit;">同じ定数に対してブートストラップメソッドを複数回呼び出す場合、JVMはコインを投げ、定数値の役割として計算された値の1つを選択し、その他はガベージコレクターに犠牲になることが保証されています。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動作上、CONSTANT_Dynamic定数は、次のパラメーターでブートストラップメソッドを実行することによって解決されます。 </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカルLookupオブジェクト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数の名前コンポーネントを表すString</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予想される定数型を表すクラス、および</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">残りのブートストラップ引数。</font></font></li>
</ol><br>
As with invokedynamic, multiple threads can race to resolve, but a unique winner will be chosen and any other contending answers discarded.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バイトコード内の定数プールから値をロードするために、コマンドが提供され</font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>ldc_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>ldc2_w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私たちにとって興味深いのは、それらの最初のもの</font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他とは異なり、定数プールの最初の255スロットからのみ値をロードできますが、バイトコードが1バイト少なくなります。これにより、最大255バイトの節約と</font></font><code>255 + ((65_524 - (255 * 5)) / 6) = 10_963</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙内の要素が提供されます。今回の成長はそれほど印象的ではありませんが、それでもまだあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この知識を武器に、始めましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的初期化ブロックでは、メソッド呼び出しの代わり</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、動的定数の値をロードします。</font></font><code>ordinal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列挙要素の序数インデックス</font><font style="vertical-align: inherit;">の値は</font><font style="vertical-align: inherit;">明示的に渡されるため</font></font><code>valueIndex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ファクトリメソッド</font><font style="vertical-align: inherit;">であるフィールドが削除されます</font></font><code>nextValue()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、実装のスレッドセーフティについての疑問。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートストラップメソッドとして、</font><font style="vertical-align: inherit;">Javaの</font><font style="vertical-align: inherit;">演算子の動作を模倣する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandleの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特別なサブタイプを使用</font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">標準ライブラリには、そのようなメソッドハンドルを取得するための</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MethodHandles.Lookup :: findConstructor（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドが用意さ</font><font style="vertical-align: inherit;">れていますが、この場合、JVMが必要なメソッドハンドルの構築を処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列挙型のコンストラクタをブートストラップメソッドとして使用するには、シグネチャを変更することにより、コンストラクタを少し変更する必要があります。</font><font style="vertical-align: inherit;">ブートストラップメソッドに必要なパラメーターは、名前列挙要素とシリアル番号の従来のコンストラクターに追加されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; enumClass, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
    <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
擬似コードの形式では、初期化は次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Fizz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Fizz"</span>, <span class="hljs-number">0</span>);<font></font>
    Buzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"Buzz"</span>, <span class="hljs-number">1</span>);<font></font>
    FizzBuzz = JVM_ldc(FizzBuzz::<span class="hljs-keyword">new</span>, <span class="hljs-string">"FizzBuzz"</span>, <span class="hljs-number">2</span>);<font></font>
<font></font>
    $VALUES = createValues();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の例では、命令は</font></font><code>ldc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド呼び出しとして指定されて</font></font><code>JVM_ldc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おり、代わりにバイトコードが対応するJVM命令になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、列挙の各要素に個別の定数があるため、配列の作成と入力は</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的定数を介して実装することもできます。</font><font style="vertical-align: inherit;">ブートストラップメソッドは非常に簡単です。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues(MethodHandles.Lookup lookup, String name, Class&lt;?&gt; clazz, FizzBuzz... elements) {
    <span class="hljs-keyword">return</span> elements;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この動的定数の静的パラメーターのリストのすべてのトリックでは、そこに入れたいすべての要素をリストします</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BootstrapMethods：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  ...</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  1：＃54 REF_invokeStatic FizzBu​​zz.createValues：（Ljava / lang / invoke / MethodHandles $ Lookup; Ljava / lang / String; Ljava / lang / Class; [LFizzBu​​zz;）[LFizzBu​​zz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
    メソッドの引数：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃1＃0：Fizz：LFizzBu​​zz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃2＃0：バズ：LFizzBu​​zz;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
      ＃3＃0：FizzBu​​zz：LFizzBu​​zz;</font></font><font></font>
</pre><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMはこれらの静的パラメータから配列を破棄し、それをvarargパラメータとしてブートストラップメソッドに渡します</font></font><code>elements</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">静的パラメータの最大数は従来の65_535であるため、いくつあっても、列挙のすべての要素に対して十分であることが保証されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素数が多い転送の場合、この変更により、結果のクラスファイルのサイズが小さくなります。要素数が多いためにメソッド</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をいくつかの部分に分割する必要がある場合、定数プールのスロットも保存されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして結局、それはただ美しいです。</font></font><br>
<br>
<a name="Surprise"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突然の困難</font></font></h1><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、手動でクラスを生成することによって、英雄的に克服しました。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高レベルのライブラリは、行動の自由の制限と引き換えに便利なインターフェースを提供します。</font><font style="vertical-align: inherit;">クラスファイルの生成に使用するASMライブラリも例外ではありません。</font><font style="vertical-align: inherit;">定数のプールの内容を直接制御するメカニズムは提供していません。</font><font style="vertical-align: inherit;">これは通常あまり重要ではありませんが、私たちの場合はそうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
覚えているように、静的初期化ブロックに貴重なバイトを保存するには、定数プールの最初の255要素が必要です。</font><font style="vertical-align: inherit;">動的定数が標準的な方法で追加されると、それらはランダムなインデックスに配置され、それほど重要ではない他の要素と混合されます。</font><font style="vertical-align: inherit;">これにより、最大数に達することができなくなります。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従来の方法で形成された定数のプールのフラグメント</font></font></b>
                        <div class="spoiler_text"><blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数プール：</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   ＃1 = Utf8 FizzBu​​zz</font></font><font></font>
   #2 = Class              #1             // FizzBuzz<font></font>
   #3 = Utf8               java/lang/Enum<font></font>
   #4 = Class              #3             // java/lang/Enum<font></font>
   #5 = Utf8               $VALUES<font></font>
   #6 = Utf8               [LFizzBuzz;<font></font>
   #7 = Utf8               valueIndex<font></font>
   #8 = Utf8               I<font></font>
   #9 = Utf8               Fizz<font></font>
  #10 = Utf8               LFizzBuzz;<font></font>
  #11 = Utf8               Buzz<font></font>
  #12 = Utf8               FizzBuzz<font></font>
  #13 = Utf8               values<font></font>
  #14 = Utf8               ()[LFizzBuzz;<font></font>
  #15 = NameAndType        #5:#6          // $VALUES:[LFizzBuzz;<font></font>
  #16 = Fieldref           #2.#15         // FizzBuzz.$VALUES:[LFizzBuzz;<font></font>
  #17 = Class              #6             // "[LFizzBuzz;"<font></font>
  #18 = Utf8               clone<font></font>
  #19 = Utf8               ()Ljava/lang/Object;<font></font>
  #20 = NameAndType        #18:#19        // clone:()Ljava/lang/Object;<font></font>
  #21 = Methodref          #17.#20        // "[LFizzBuzz;".clone:()Ljava/lang/Object;<font></font>
  ...<font></font>
  #40 = NameAndType        #9:#10         // Fizz:LFizzBuzz;<font></font>
  #41 = Dynamic            #0:#40         // #0:Fizz:LFizzBuzz;<font></font>
  #42 = Fieldref           #2.#40         // FizzBuzz.Fizz:LFizzBuzz;<font></font>
  #43 = NameAndType        #11:#10        // Buzz:LFizzBuzz;<font></font>
  #44 = Dynamic            #0:#43         // #0:Buzz:LFizzBuzz;<font></font>
  #45 = Fieldref           #2.#43         // FizzBuzz.Buzz:LFizzBuzz;<font></font>
  #46 = NameAndType        #12:#10        // FizzBuzz:LFizzBuzz;<font></font>
  #47 = Dynamic            #0:#46         // #0:FizzBuzz:LFizzBuzz;<font></font>
  #48 = Fieldref           #2.#46         // FizzBuzz.FizzBuzz:LFizzBuzz;<font></font>
</pre><br>
</blockquote><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸い、回避策があります。クラスを作成するときに、定数のプールと、ブートストラップメソッドの説明を含む属性をコピーするサンプルクラスを指定できます。</font><font style="vertical-align: inherit;">今だけ手動で生成する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、一見するとそれほど難しくはありません。</font><font style="vertical-align: inherit;">クラスファイルのフォーマットは非常に単純で、手動で生成するのはやや退屈なプロセスですが、まったく複雑ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで最も重要なことは明確な計画です。</font></font><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要な要素</font><font style="vertical-align: inherit;">から列挙する</font><font style="vertical-align: inherit;">には：</font></font><br>
<br>
<ul>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプレコード</font></font><code>CONSTANT_Dynamic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-動的定数</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプレコード</font></font><code>CONSTANT_NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-列挙要素の名前とそのタイプへのリンクのペア。</font><font style="vertical-align: inherit;">タイプはすべての人で同じになります。これは、列挙型のクラスタイプです。</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプレコード</font></font><code>CONSTANT_Utf8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-列挙要素の名前を直接</font></font></li>
<li><code>COUNT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプのレコード</font></font><code>CONSTANT_Integer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-パラメータ値としてコンストラクタに渡される列挙要素のシリアル番号</font></font><code>ordinal</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のクラスと基本クラスの名前、属性、メソッドシグネチャ、その他の退屈な実装の詳細。</font><font style="vertical-align: inherit;">興味のある人はジェネレータのソースコードを見ることができます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
定数のプールには、インデックスによってプールの他の要素を参照する多くの構成要素があるため、必要なすべてのインデックスは事前に計算する必要があり</font></font><code>elementNames</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これは、列挙型の要素の名前のリストです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> elementCount = elementNames.size();<font></font>
<font></font>
<span class="hljs-keyword">int</span> baseConDy = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> baseNameAndType = baseConDy + elementCount;
<span class="hljs-keyword">int</span> baseUtf8 = baseNameAndType + elementCount;
<span class="hljs-keyword">int</span> baseInteger = baseUtf8 + elementCount;
<span class="hljs-keyword">int</span> indexThisClass = baseInteger + elementCount;
<span class="hljs-keyword">int</span> indexThisClassUtf8 = indexThisClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClass = indexThisClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexSuperClassUtf8 = indexSuperClass + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodsUtf8 = indexSuperClassUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexConDyDescriptorUtf8 = indexBootstrapMethodsUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodHandle = indexConDyDescriptorUtf8 + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodRef = indexBootstrapMethodHandle + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodNameAndType = indexBootstrapMethodRef + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodName = indexBootstrapMethodNameAndType + <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> indexBootstrapMethodDescriptor = indexBootstrapMethodName + <span class="hljs-number">1</span>;<font></font>
<font></font>
<span class="hljs-keyword">int</span> constantPoolSize = indexBootstrapMethodDescriptor + <span class="hljs-number">1</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、書き始めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、クラスファイルの署名、誰もが知っている4バイト</font></font><nobr><code>0xCA 0xFE 0xBA 0xBE</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、およびファイル形式のバージョン：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Class file header</span><font></font>
u4(CLASS_FILE_SIGNATURE);<font></font>
u4(version);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に-定数のプール：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定数のプール</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">// Constant pool</span><font></font>
u2(constantPoolSize);<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Dynamic</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_Dynamic, i, baseNameAndType + i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_NameAndType</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1u2u2(CONSTANT_NameAndType, baseUtf8 + i, indexConDyDescriptorUtf8);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Utf8</span>
<span class="hljs-comment">//noinspection ForLoopReplaceableByForEach</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Utf8);<font></font>
    utf8(elementNames.get(i));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// N * CONSTANT_Integer</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {<font></font>
    u1(CONSTANT_Integer);<font></font>
    u4(i);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ThisClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexThisClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// ThisClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(enumClassName);<font></font>
<font></font>
<span class="hljs-comment">// SuperClass</span><font></font>
u1(CONSTANT_Class);<font></font>
u2(indexSuperClassUtf8);<font></font>
<font></font>
<span class="hljs-comment">// SuperClassUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(JAVA_LANG_ENUM);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodsUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(ATTRIBUTE_NAME_BOOTSTRAP_METHODS);<font></font>
<font></font>
<span class="hljs-comment">// ConDyDescriptorUtf8</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(binaryEnumClassName);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodHandle</span><font></font>
u1(CONSTANT_MethodHandle);<font></font>
u1(REF_newInvokeSpecial);<font></font>
u2(indexBootstrapMethodRef);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodRef</span><font></font>
u1u2u2(CONSTANT_Methodref, indexThisClass, indexBootstrapMethodNameAndType);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodNameAndType</span><font></font>
u1u2u2(CONSTANT_NameAndType, indexBootstrapMethodName, indexBootstrapMethodDescriptor);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodName</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_NAME);<font></font>
<font></font>
<span class="hljs-comment">// BootstrapMethodDescriptor</span><font></font>
u1(CONSTANT_Utf8);<font></font>
utf8(BOOTSTRAP_METHOD_DESCRIPTOR);<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プールの定数は、アクセス修飾子とフラグについて話した後（</font></font><code>public</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>enun</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">など）、クラス名とその祖先：</font></font><br>
<br>
<pre><code class="java hljs">u2(access);<font></font>
u2(indexThisClass);<font></font>
u2(indexSuperClass);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
生成したダミークラスにはインターフェイス、フィールド、メソッドはありませんが、ブートストラップメソッドの説明を持つ属性が1つあります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Interfaces count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Fields count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Methods count</span>
u2(<span class="hljs-number">0</span>);
<span class="hljs-comment">// Attributes count</span>
u2(<span class="hljs-number">1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これが属性自体の本体です：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// BootstrapMethods attribute</span><font></font>
u2(indexBootstrapMethodsUtf8);<font></font>
<span class="hljs-comment">// BootstrapMethods attribute size</span>
u4(<span class="hljs-number">2</span> <span class="hljs-comment">/* num_bootstrap_methods */</span> + <span class="hljs-number">6</span> * elementCount);
<span class="hljs-comment">// Bootstrap method count</span><font></font>
u2(elementCount);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; elementCount; i++) {
    <span class="hljs-comment">// bootstrap_method_ref</span><font></font>
    u2(indexBootstrapMethodHandle);<font></font>
    <span class="hljs-comment">// num_bootstrap_arguments</span>
    u2(<span class="hljs-number">1</span>);
    <span class="hljs-comment">// bootstrap_arguments[1]</span><font></font>
    u2(baseInteger + i);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでクラスが形成されました。</font><font style="vertical-align: inherit;">これらのバイトを受け取り、それらから作成します</font></font><code>ClassReader</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> ClassReader <span class="hljs-title">getBootstrapClassReader</span><span class="hljs-params">(<span class="hljs-keyword">int</span> version, <span class="hljs-keyword">int</span> access, String enumClassName, List&lt;String&gt; elementNames)</span> </span>{
    <span class="hljs-keyword">byte</span>[] bootstrapClassBytes = <span class="hljs-keyword">new</span> ConDyBootstrapClassGenerator(<font></font>
        version,<font></font>
        access,<font></font>
        enumClassName,<font></font>
        elementNames<font></font>
    )<font></font>
    .generate();<font></font>
<font></font>
    <span class="hljs-keyword">if</span> (bootstrapClassBytes == <span class="hljs-keyword">null</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClassReader(bootstrapClassBytes);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それほど難しくはありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェネレーターのソースコード：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConDyBootstrapClassGenerator.java</font></font></a><br>
<a name="Future"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">明るい未来</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストから少し離れます。</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscoverConstantValueAttribute</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING = <span class="hljs-string">"Habrahabr, world!"</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object OBJECT = <span class="hljs-keyword">new</span> Object();<font></font>
<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスの静的初期化ブロックでは、フィールドに突然1つの書き込み操作しかありません</font></font><code>OBJECT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">static</span> {<font></font>
    OBJECT = <span class="hljs-keyword">new</span> Object();
    <span class="hljs-comment">//  0: new           #2                  // class java/lang/Object</span>
    <span class="hljs-comment">//  3: dup</span>
    <span class="hljs-comment">//  4: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span>
    <span class="hljs-comment">//  7: putstatic     #7                  // Field OBJECT:Ljava/lang/Object;</span>
    <span class="hljs-comment">// 10: return</span><font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、どう</font></font><code>STRING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
チームはこのなぞなぞ</font></font><nobr><code>javap -c -s -p -v DiscoverConstantValueAttribute.class</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">光を当てるのを手伝います</font><font style="vertical-align: inherit;">、ここに私たちに興味のある断片があります：</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.String STRING;<font></font>
  descriptor: Ljava/lang/String;<font></font>
  flags: (<span class="hljs-number">0x0019</span>) ACC_PUBLIC, ACC_STATIC, ACC_FINAL<font></font>
  ConstantValue: String Habrahabr, world!<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
static finalフィールドの値は、初期化ブロックから別の属性に移動しました</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11§4.7.2で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この属性について彼らが書いたものは</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">次のとおり</font></a><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConstantValue属性は定数式（JLS§15.28）の値を表し、次のように使用されます。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">field_info構造体のaccess_flagsアイテムのACC_STATICフラグが設定されている場合、field_info構造体で表されるフィールドには、フィールドを宣言するクラスまたはインターフェースの初期化の一部として、ConstantValue属性で表される値が割り当てられます（§5.5）。</font><font style="vertical-align: inherit;">これは、そのクラスまたはインターフェースのクラスまたはインターフェース初期化メソッド（2.9.2）を呼び出す前に発生します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ以外の場合、Java仮想マシンは黙って属性を無視する必要があります。</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような属性は、同時に発生した場合</font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><code>final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドに（後者はここで明示的に綴られていないが）、そのようなフィールドは、この属性の値で初期化されます。</font><font style="vertical-align: inherit;">そして、これは静的初期化メソッドが呼び出される前でも起こります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この属性を使用して列挙型の要素を初期化するのは魅力的です。前の章では、動的な定数ではありますが、定数しかありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、この方向で最初に考えるのは私たちではありません。JEP309で言及されてい</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">残念ながら、この言及は未来の仕事の章にあります：</font></font><br>
<br>
<blockquote><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将来の作業</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
考えられる将来の拡張には次が含まれます：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的フィールドのConstantValue属性への動的定数の付加</font></font></li>
</ul><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その間、この機能が「実行できる」状態から「準備ができている」状態に移行する時期についてのみ夢を見ることができます。</font><font style="vertical-align: inherit;">次に、初期化ブロック内のコードのサイズに対する制限は影響を失い、列挙内の要素の最大数によって定数プールの制限が決まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おおまかな見積もりによると、この場合、</font></font><code>65&nbsp;489 / 4 = 16_372</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素を</font><font style="vertical-align: inherit;">期待でき</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これ</font></font><code>65_489</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、定数プールの空いているスロットの数です。理論的に可能な65_535の46がオーバーヘッドになりました。</font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1つのフィールドと対応する動的定数の宣言に必要なスロットの数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、正確な数は、この機能をサポートするJDKバージョンのリリース後にのみ確認できます。</font></font><br>
<br>
<a name="Unsafe"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全でない</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの敵は、列挙要素の数の増加に伴う初期化ブロックの線形成長です。</font><font style="vertical-align: inherit;">ループ内の初期化を削減する方法を見つけ、それによって列挙内の要素の数と初期化ブロックのサイズの間の関係を削除した場合、別のブレークスルーを作成することになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、標準のパブリックAPIでは</font></font><code>static final</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、静的な初期化ブロック内でもフィールド</font><font style="vertical-align: inherit;">への書き込みが許可されていません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ReflectionもVarHandlesもここでは役に立ちません。</font><font style="vertical-align: inherit;">私たちの唯一の希望は、偉大で恐ろしいもの</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
安全でないFizzBu​​zzの実行は次のようになります。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全でないFizzBu​​zz</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-keyword">import</span> java.lang.reflect.Field;
<span class="hljs-keyword">import</span> sun.misc.Unsafe;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> FizzBuzz {<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz[] $VALUES;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Fizz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz Buzz;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FizzBuzz FizzBuzz;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz[] values() {
        <span class="hljs-keyword">return</span> (FizzBuzz[]) $VALUES.clone();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FizzBuzz <span class="hljs-title">valueOf</span><span class="hljs-params">(String name)</span> </span>{
        <span class="hljs-keyword">return</span> (FizzBuzz) Enum.valueOf(FizzBuzz.class, name);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">FizzBuzz</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> ordinal)</span> </span>{
        <span class="hljs-keyword">super</span>(name, ordinal);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FizzBuzz[] createValues() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FizzBuzz[] {<font></font>
            Fizz,<font></font>
            Buzz,<font></font>
            FizzBuzz<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">static</span>  {<font></font>
        Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
        unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
        String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
            String fieldName = fieldNames[i];<font></font>
            Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
            <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
            unsafe.putObject(FizzBuzz.class, fieldOffset, <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i));<font></font>
        }<font></font>
<font></font>
        $VALUES = createValues();<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、約21千要素の列挙を作成できます;さらに、定数のプールの容量は十分ではありません。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Enum :: ordinal（）</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のドキュメントで</font><font style="vertical-align: inherit;">は、その値が列挙宣言の対応する要素のシリアル番号と一致する必要があるため、フィールド名のリストを正しい順序で明示的に格納する必要があり、それによってクラスファイルのサイズがほぼ2倍になります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">public final int ordinal（）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この列挙定数の序数を返します（列挙型宣言での位置。初期定数にはゼロの序数が割り当てられています）。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、定数のプールのコンテンツへのパブリックAPIが役立つ可能性があります。必要な順序でそれを埋める方法はすでにわかっていますが、そのようなAPIはなく、ありそうもありません。 OpenJDKで利用可能な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getConstantPool（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">は、package-privateとして宣言されており、ユーザーコードで</font><font style="vertical-align: inherit;">このメソッドを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">信頼するのは簡単</font></a><font style="vertical-align: inherit;">ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化ブロックは非常にコンパクトになり、列挙内の要素数にほとんど依存しないため</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ループに本体を埋め込むことで拒否できます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    FizzBuzz[] localValues = <span class="hljs-keyword">new</span> FizzBuzz[fieldNames.length];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = FizzBuzz.class.getDeclaredField(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }<font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、雪崩のようなプロセスが発生します。メソッドとともに</font></font><code>createValues()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、列挙型要素のフィールドを読み取るための指示が消え、</font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのフィールドの</font><font style="vertical-align: inherit;">タイプレコードが不要</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">なるため</font><font style="vertical-align: inherit;">、タイプ</font></font><code>NameAndType</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコードのタイプレコードになり</font></font><code>Fieldref</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。定数プールでは、</font></font><code>2 * &lt;   &gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加の列挙要素を宣言するために使用できるスロットが</font><font style="vertical-align: inherit;">解放さ</font><font style="vertical-align: inherit;">れます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべてがそれほどバラバラなわけではありませんが、テストは大幅なパフォーマンスの低下を示しています。65,000の要素を持つ列挙型クラスを初期化するには、思いがけない1分30分かかります。結局のところ、「反射が遅くなる」ことがわかりました。</font><font style="vertical-align: inherit;">OpenJDK </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Class :: getDeclaredField（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の実装には、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">クラス</font></a><font style="vertical-align: inherit;">のフィールド数の線形漸近的な振る舞いがあり、このため、初期化ブロックは2次です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
キャッシングを追加すると、状況は多少改善されますが、完全に解決するわけではありません。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">static</span>  {<font></font>
    Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");<font></font>
    unsafeField.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
    Unsafe unsafe = (Unsafe) unsafeField.get(<span class="hljs-keyword">null</span>);<font></font>
<font></font>
    String[] fieldNames = "Fizz,Buzz,FizzBuzz".split(",");<font></font>
    Field[] fields = FizzBuzz.class.getDeclaredFields();<font></font>
    HashMap&lt;String, Field&gt; cache = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(fields.length);<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(Field field : fields) {<font></font>
        cache.put(field.getName(), field);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fieldNames.length; i++) {<font></font>
        String fieldName = fieldNames[i];<font></font>
        Field field = cache.get(fieldName);<font></font>
        <span class="hljs-keyword">long</span> fieldOffset = unsafe.staticFieldOffset(field);<font></font>
        unsafe.putObject(<font></font>
            FizzBuzz.class,<font></font>
            fieldOffset,<font></font>
            (localValues[i] = <span class="hljs-keyword">new</span> FizzBuzz(fieldName, i))<font></font>
        );<font></font>
    }    <font></font>
<font></font>
    $VALUES = localValues;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この章で説明する安全でないアプローチでは、最大65_410の要素数で転送を作成できます。これは、javacで達成可能な結果のほぼ24倍であり、サイクルの前回の公開で計算された65_505要素の理論上の制限に非常に近いものです。</font></font><br>
<br>
<a name="Testing"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスを確認する</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストでは、最大の列挙を使用して、コマンドを使用して生成し</font></font><nobr><code>java -jar HugeEnumGen.jar -a Unsafe UnsafeHugeEnum</code></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。その結果、2メガバイトのサイズと65_410要素のクラスファイルが取得されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDEAで新しいJavaプロジェクトを作成し、生成されたクラスを外部ライブラリとして追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに、IDEAがそのようなストレステストの準備ができていないことが顕著になり</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m4/su/-6/m4su-6bvdkkqmf3pypqrmpzntnw.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。列挙要素のオートコンプリートは、古代のモバイルi5とより新しいi7 8700Kの両方で数十秒かかります。また、クイックフィックスを使用して不足している要素をスイッチに追加しようとすると、IDEAはウィンドウの再描画を停止します。一時的にそうなのかと思われますが、完了するのを待ちませんでした。デバッグ中の応答性にも多くのことが望まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の少数の要素から始めましょう</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFew</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String... args)</span> </span>{
        <span class="hljs-keyword">for</span>(String arg : args) {<font></font>
            System.out.print(arg + <span class="hljs-string">" : "</span>);<font></font>
<font></font>
            <span class="hljs-keyword">try</span> {<font></font>
                UnsafeHugeEnum value = UnsafeHugeEnum.valueOf(arg);<font></font>
<font></font>
                doSwitch(value);<font></font>
            } <span class="hljs-keyword">catch</span>(Throwable e) {<font></font>
                e.printStackTrace(System.out);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSwitch</span><span class="hljs-params">(UnsafeHugeEnum value)</span> </span>{
        <span class="hljs-keyword">switch</span>(value) {
            <span class="hljs-keyword">case</span> VALUE_00001:<font></font>
                System.out.println(<span class="hljs-string">"First"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_31415:<font></font>
                System.out.println(<span class="hljs-string">"(int) (10_000 * Math.PI)"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
                System.out.println(<span class="hljs-string">"Last"</span>);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:<font></font>
                System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
                <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
    }<font></font>
<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの驚きはありません。コンパイルと起動は定期的に行われます。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ java TestFew VALUE_00001 VALUE_00400 VALUE_31415 VALUE_65410<font></font>
VALUE_00001 : First<font></font>
VALUE_00400 : Unexpected value: VALUE_00400<font></font>
VALUE_31415 : (int) (10_000 * Math.PI)<font></font>
VALUE_65410 : Last<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の他のアイテムは</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どうですか？</font><font style="vertical-align: inherit;">たとえば、</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">65,000の要素すべてを一度</font><font style="vertical-align: inherit;">に処理できます</font><font style="vertical-align: inherit;">か？</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">switch</span>(value) {
    <span class="hljs-keyword">case</span> VALUE_00001:
    <span class="hljs-keyword">case</span> VALUE_00002:<font></font>
        ...<font></font>
    <span class="hljs-keyword">case</span> VALUE_65410:<font></font>
        System.out.println(<span class="hljs-string">"One of known values: "</span> + value);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:<font></font>
        System.out.println(<span class="hljs-string">"Unexpected value: "</span> + value);
        <span class="hljs-keyword">break</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ああ、違う。</font><font style="vertical-align: inherit;">コンパイルしようとすると、大量のエラーメッセージが表示されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">$ javac -fullversion<font></font>
javac full version "14.0.1+7"<font></font>
<font></font>
$ javac TestAll.java<font></font>
TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
TestAll.java:65433: error: too many constants<font></font>
                break;<font></font>
                ^<font></font>
TestAll.java:17: error: code too large<font></font>
    private static void doSwitch(UnsafeHugeEnum value) {<font></font>
                        ^<font></font>
TestAll.java:1: error: too many constants<font></font>
public class TestAll {<font></font>
       ^<font></font>
4 errors<font></font>
</code></pre><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testfew.java</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TestAll.java</font></font></a></li>
</ul><br>
<a name="JavacSwitchTranslation"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javacとスイッチ</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何が起こっているのかを理解するには</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、列挙型の要素の</font><font style="vertical-align: inherit;">変換</font><font style="vertical-align: inherit;">が</font><font style="vertical-align: inherit;">どのように行われるかを理解する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JVM仕様には、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JVMS11§3.10Compiling Switches</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">個別の章があり</font><font style="vertical-align: inherit;">、その推奨</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、2つのバイトコード命令の</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いずれか</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">するように</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">要約</font></a><font style="vertical-align: inherit;">され</font><font style="vertical-align: inherit;">てい</font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この章では、文字列または列挙要素への</font><font style="vertical-align: inherit;">参照</font><font style="vertical-align: inherit;">はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最良のドキュメントはコードなので、ソースに飛び込む時が来ました</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
選択は間</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>lookupswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で発生</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲン:: visitSwitch（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とのオプションの数によって異なります</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどの場合、勝ち</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">// Determine whether to issue a tableswitch or a lookupswitch</span>
<span class="hljs-comment">// instruction.</span>
<span class="hljs-keyword">long</span> table_space_cost = <span class="hljs-number">4</span> + ((<span class="hljs-keyword">long</span>) hi - lo + <span class="hljs-number">1</span>); <span class="hljs-comment">// words</span>
<span class="hljs-keyword">long</span> table_time_cost = <span class="hljs-number">3</span>; <span class="hljs-comment">// comparisons</span>
<span class="hljs-keyword">long</span> lookup_space_cost = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (<span class="hljs-keyword">long</span>) nlabels;
<span class="hljs-keyword">long</span> lookup_time_cost = nlabels;
<span class="hljs-keyword">int</span> opcode =<font></font>
    nlabels &gt; <span class="hljs-number">0</span> &amp;&amp;<font></font>
    table_space_cost + <span class="hljs-number">3</span> * table_time_cost &lt;=<font></font>
    lookup_space_cost + <span class="hljs-number">3</span> * lookup_time_cost<font></font>
    ?<font></font>
    tableswitch : lookupswitch;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘッダー</font></font><code>tableswitch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は約16バイト+値あたり4バイトです。</font><font style="vertical-align: inherit;">したがって、</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのような状況でも</font></font><code>( 65_535 - 16 ) / 4 = 16_379</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要素</font><font style="vertical-align: inherit;">が増えることはありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、</font></font><code>case</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボディ</font><font style="vertical-align: inherit;">のブランチ数</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を16千</font><font style="vertical-align: inherit;">に減らした後、</font><font style="vertical-align: inherit;">コンパイルエラーは1つしか残っていません。これは最も神秘的です。</font></font><br>
<br>
<pre><code class="plaintext hljs">TestAll.java:18: error: code too large for try statement<font></font>
        switch(value) {<font></font>
        ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーの原因を探すために、少し前に、構文糖質を取り除く段階に戻ります。</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドは、</font><font style="vertical-align: inherit;">翻訳</font></font><code>visitEnumSwitch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>mapForEnum()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Lower.java</font></a><font style="vertical-align: inherit;">のクラス</font></font><code>EnumMapping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">担当し</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこにも小さなドキュメンタリーコメントがあります：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EnumMapping JavaDoc</font></font></b>
                        <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment">/** This map gives a translation table to be used for enum
 *  switches.
 *
 *  &lt;p&gt;For each enum that appears as the type of a switch
 *  expression, we maintain an EnumMapping to assist in the
 *  translation, as exemplified by the following example:
 *
 *  &lt;p&gt;we translate
 *  &lt;pre&gt;
 *          switch(colorExpression) {
 *          case red: stmt1;
 *          case green: stmt2;
 *          }
 *  &lt;/pre&gt;
 *  into
 *  &lt;pre&gt;
 *          switch(Outer$0.$EnumMap$Color[colorExpression.ordinal()]) {
 *          case 1: stmt1;
 *          case 2: stmt2
 *          }
 *  &lt;/pre&gt;
 *  with the auxiliary table initialized as follows:
 *  &lt;pre&gt;
 *          class Outer$0 {
 *              synthetic final int[] $EnumMap$Color = new int[Color.values().length];
 *              static {
 *                  try { $EnumMap$Color[red.ordinal()] = 1; } catch (NoSuchFieldError ex) {}
 *                  try { $EnumMap$Color[green.ordinal()] = 2; } catch (NoSuchFieldError ex) {}
 *              }
 *          }
 *  &lt;/pre&gt;
 *  class EnumMapping provides mapping data and support methods for this translation.
 */</span>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不思議な</font></font><code>try</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことに、自動生成されたヘルパークラスの一部であることが判明しました</font></font><code>TestAll$0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。内部-静的配列の宣言とそれを初期化するコード。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
配列は、コンパイル中に列挙要素の名前とそれらに割り当てられた</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数値の</font><font style="vertical-align: inherit;">間の対応を修正し</font><font style="vertical-align: inherit;">、それによってコンパイルされたコードをリファクタリングの有害な影響から保護します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並べ替え、新しい要素の追加、または既存の列挙要素の削除を行うと、一部の要素が値</font></font><code>ordinal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">変更する可能性があり</font><font style="vertical-align: inherit;">、これが追加の間接レベルから保護されます。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">try</span> {<font></font>
    $SwitchMap$UnsafeHugeEnum[UnsafeHugeEnum.VALUE_00001.ordinal()] = <span class="hljs-number">1</span>;
    <span class="hljs-comment">//  9: getstatic     #2                  // Field $SwitchMap$UnsafeHugeEnum:[I</span>
    <span class="hljs-comment">// 12: getstatic     #3                  // Field UnsafeHugeEnum.VALUE_00001:LUnsafeHugeEnum;</span>
    <span class="hljs-comment">// 15: invokevirtual #4                  // Method UnsafeHugeEnum.ordinal:()I</span>
    <span class="hljs-comment">// 18: iconst_1</span>
    <span class="hljs-comment">// 19: iastore</span><font></font>
}<font></font>
<span class="hljs-comment">// 20: goto          24</span>
<span class="hljs-keyword">catch</span>(NoSuchFieldError e) { }
<span class="hljs-comment">// 23: astore_0</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初期化コードは単純で、要素あたり15〜17バイトを消費します。</font><font style="vertical-align: inherit;">その結果、静的初期化ブロックは3_862要素以下の初期化に対応します。</font><font style="vertical-align: inherit;">この数は</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、現在の実装</font><font style="vertical-align: inherit;">で1つに使用できる列挙要素の最大数になります</font></font><code>javac</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="Conclusion"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
列挙型要素の作成を割り当て、配列</font></font><code>$VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を別のメソッドに</font><font style="vertical-align: inherit;">初期化するなどの単純な手法を使用しても、列挙型の要素</font><font style="vertical-align: inherit;">の最大数を2_746から10_920に増やすことができることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前の実績の背景に対する一定の動的な結果はそれほど印象的ではなく、43要素しか取得できませんが、このアプローチでは、列挙体に新しいプロパティを追加する方がはるかに洗練されています。コンストラクターを変更し、動的定数の静的パラメーターを介して必要な値を渡すだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来のある</font></font><code>ConstantValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時点で動的定数を理解するように</font><font style="vertical-align: inherit;">属性</font><font style="vertical-align: inherit;">を教える場合、この数は1万から16に増える可能性があり</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。</font></font><code>sun.misc.Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">飛躍して要素の最大数を65_410に増やすことができます。ただし</font></font><code>Unsafe</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、javacが直接警告するように、これは時間の経過とともに消える可能性がある独自のAPIであり、その使用はかなりのリスクであることを</font><font style="vertical-align: inherit;">忘れないでください</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">Test.java:3: warning: Unsafe is internal proprietary API and may be removed in a future release<font></font>
import sun.misc.Unsafe;<font></font>
               ^<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、結局のところ、巨大な列挙を生成するだけでは十分ではなく、それを使用できる必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、IDEとJavaコンパイラレベルの両方で、このような列挙のサポートに問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス内の多数のフィールドは、編集中とデバッグ中の両方でIDEの応答性を低下させる可能性があります。</font><font style="vertical-align: inherit;">完全にハングすることがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスファイルの形式とjavacの実装の詳細によって課せられる制限により、コード内</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で3_862を超える要素</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">同時に</font><font style="vertical-align: inherit;">使用することができなくなります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">肯定的な側面のうち、これらは任意の3_862要素である可能性があることに言及する価値があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果のさらなる改善は、Javaコンパイラーの改良によってのみ可能ですが、これはまったく別の話です。</font></font><br>
<br>
<a name="Appendix"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加資料</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHubソースコード：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">//github.com/Maccimo/HugeEnumGeneratorArticle</font></a></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
収集されたJARファイル：</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">https</font></a><font style="vertical-align: inherit;"> : </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">//github.com/Maccimo/HugeEnumGeneratorArticle/releases/tag/v1.0</font></font></a><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サポートされているスタートアップヘルプ</font></font></b>
                        <div class="spoiler_text"><pre><font></font>
Huge enumeration generator<font></font>
<font></font>
    https://github.com/Maccimo/HugeEnumGeneratorArticle<font></font>
<font></font>
Additional information (in Russian):<font></font>
<font></font>
    https://habr.com/ru/post/483392/<font></font>
    https://habr.com/ru/post/501870/<font></font>
<font></font>
Usage:<font></font>
    java -jar HugeEnumGen.jar [ &lt;options&gt; ] &lt;enum name&gt;<font></font>
<font></font>
    &lt;enum name&gt;<font></font>
        An enumeration class name.<font></font>
        Should be a valid Java identifier. May contain package name.<font></font>
<font></font>
Options:<font></font>
<font></font>
    -d &lt;directory&gt;<font></font>
        Output directory path.<font></font>
        Current working directory by default.<font></font>
<font></font>
    -e &lt;item list file&gt;<font></font>
        Path to UTF8-encoded text file with list of enumeration item names.<font></font>
        Item names will be autogenerated if absent.<font></font>
        Mutually exclusive with the -c option.<font></font>
<font></font>
    -c &lt;count&gt;<font></font>
        Count of autogenerated enumeration item names.<font></font>
        Mutually exclusive with the -e option.<font></font>
        Default value: Algorithm-depended<font></font>
<font></font>
    -a &lt;algorithm&gt;<font></font>
        Enumeration generation algorithm.<font></font>
        Supported algorithms:<font></font>
          ConDy          - Employ Constant Dynamic (JEP 309) for enum elements initialization<font></font>
          ExtractMethod  - Extract enum elements initialization code to separate method<font></font>
          Unsafe         - Employ sun.misc.Unsafe for enum elements initialization<font></font>
<font></font>
        Default algorithm: ExtractMethod<font></font>
<font></font>
    -h / -?<font></font>
        Show this help page.<font></font>
<font></font>
Example:<font></font>
<font></font>
    java -jar HugeEnumGen.jar -d ./bin -c 2020 com.habr.maccimo.HugeEnum2020<font></font>
<font></font>
</pre><br>
</div>
                    </div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja501860/index.html">5月15日RU-Centerは、お客様の参加なしに有料サービスを追加する場合があります</a></li>
<li><a href="../ja501862/index.html">フードの下でフラッター</a></li>
<li><a href="../ja501864/index.html">アシスタントまたはインスペクター：ロボットは誰を呼び出していますか？</a></li>
<li><a href="../ja501866/index.html">ロボットが破壊するジョブの数</a></li>
<li><a href="../ja501868/index.html">会計士に自分を投げ込ませない方法、または1Cをクラウドに転送する方法。ステップバイステップの説明</a></li>
<li><a href="../ja501872/index.html">サイバネティックシステムの研究場所</a></li>
<li><a href="../ja501874/index.html">最新のフロントエンドアーキテクチャ（パート2）</a></li>
<li><a href="../ja501880/index.html">「はじまり」「はじまり」の翻訳について、始まり、始まり、最初なし</a></li>
<li><a href="../ja501882/index.html">コンピュータービジョンアルゴリズムの使用方法：OpenCV.jsを使用したモバイルブラウザーでのビデオ処理</a></li>
<li><a href="../ja501884/index.html">電子医療情報アーカイブが病気の診断をより効果的にする方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>