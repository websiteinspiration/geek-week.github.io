<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✏️ 💇🏿 😄 Mesurer la bande passante mémoire sur le genou 🛌🏾 📋 👨🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelques semaines lors d'une conversation au cours du dîner, un collègue s'est plaint d'une sorte de lenteur. Il a calculé le nombre d'octets g...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mesurer la bande passante mémoire sur le genou</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il y a quelques semaines lors d'une conversation au cours du dîner, un collègue s'est plaint d'une sorte de lenteur. Il a calculé le nombre d'octets générés, le nombre de cycles de traitement et, finalement, la quantité de RAM. Un collègue a déclaré qu'un GPU moderne avec une bande passante mémoire de plus de 500 Go / s mangerait sa tâche et ne s'étoufferait pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il me semble que c'est une approche intéressante. Personnellement, je n'ai pas évalué auparavant les objectifs de performance dans cette perspective. Oui, je connais la différence de performances du processeur et de la mémoire. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2de/d86/182/2ded861823d832e2e382d1e97e0ec147.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je sais écrire du code qui fait un usage intensif du cache. Je connais les chiffres approximatifs des retards. Mais cela ne suffit pas pour évaluer immédiatement la bande passante mémoire.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une expérience de pensée. </font><font style="vertical-align: inherit;">Imaginez en mémoire un tableau continu d'un milliard d'entiers 32 bits. </font><font style="vertical-align: inherit;">C'est 4 gigaoctets. </font><font style="vertical-align: inherit;">Combien de temps faut-il pour parcourir ce tableau et additionner les valeurs? </font><font style="vertical-align: inherit;">Combien d'octets par seconde le CPU peut-il lire à partir de la RAM? </font><font style="vertical-align: inherit;">Des données continues? </font><font style="vertical-align: inherit;">Accès aléatoire? </font><font style="vertical-align: inherit;">Dans quelle mesure ce processus peut-il être parallélisé? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous direz que ce sont des questions inutiles. </font><font style="vertical-align: inherit;">Les vrais programmes sont trop complexes pour faire un point de repère aussi naïf. </font><font style="vertical-align: inherit;">Et voici! </font><font style="vertical-align: inherit;">La vraie réponse est «en fonction de la situation». </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, je pense que cette question mérite d'être explorée. </font><font style="vertical-align: inherit;">Je n'essaie pas de trouver la </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">réponse</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mais je pense que nous pouvons définir des limites supérieures et inférieures, des points intéressants au milieu et apprendre quelque chose dans le processus.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chiffres que chaque programmeur doit connaître</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous lisez des blogs de programmation, vous êtes probablement tombé sur des «chiffres que chaque programmeur devrait connaître». </font><font style="vertical-align: inherit;">Ils ressemblent à ceci:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lien vers le cache L1 0,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prédiction 5 ns incorrecte</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers le cache L2 7 ns 14x vers le cache L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mutex Capture / Release 25 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lien vers la mémoire principale 100 ns 20x vers le cache L2, 200x vers le cache L1</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compressez 1000 octets avec Zippy 3000 ns 3 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envoi de 1000 octets sur un réseau à 1 Gbit / s 10000 ns 10 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lecture aléatoire 4000 avec SSD 150 000 ns 150 μs ~ 1 Go / s SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lecture séquentielle de 1 Mo à partir de 250 000 ns 250 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paquet aller-retour à l'intérieur du centre de données 500 000 ns 500 μs</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1 Mo de lecture séquentielle dans le SSD 1.000.000 ns 1.000 μs 1 ms ~ 1 Go / s SSD, 4x mémoire</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Recherche de disque 10000000 ns 10000 μs 10 ms 20x vers le centre de données</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lecture séquentielle de 1 Mo à partir du disque 20 000 000 ns 20 000 μs 20 ms 80x vers la mémoire, 20x vers SSD</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envoi de colis CA-&gt; Pays-Bas-&gt; CA 150,000,000 ns 150,000 μs 150 ms</font></font></pre> <br>
<i><font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jonas Boner</font></font></a></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Grande liste. </font><font style="vertical-align: inherit;">Il apparaît sur HackerNews au moins une fois par an. </font><font style="vertical-align: inherit;">Chaque programmeur devrait connaître ces chiffres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ces chiffres concernent autre chose. </font><font style="vertical-align: inherit;">La latence et la bande passante ne sont pas la même chose.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retard en 2020</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette liste a été compilée en 2012, et cet article de 2020, les temps ont changé. </font><font style="vertical-align: inherit;">Voici les chiffres pour Intel i7 avec </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StackOverflow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frappé dans le cache L1, ~ 4 cycles (2.1 - 1.2 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frappé dans le cache L2, ~ 10 cycles (5,3 - 3,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frappez dans le cache L3, pour un seul cœur ~ 40 cycles (21,4 - 12,0 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frappez dans le cache L3, ensemble pour un autre noyau ~ 65 cycles (34,8 - 19,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Frappez le cache L3, avec un changement pour un autre noyau ~ 75 cycles (40,2 - 22,5 ns)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RAM locale ~ 60 ns</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Intéressant! </font><font style="vertical-align: inherit;">Qu'est ce qui a changé?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L1 est devenu plus lent; </font></font><code>0,5 → 1,5 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L2 plus rapide; </font></font><code>7 → 4,2 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le rapport de L1 et L2 est très réduit; </font></font><code>2,5x  14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(sensationnel!)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le cache L3 est désormais devenu la norme; </font></font><code> 12  40 </code><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La RAM est devenue plus rapide; </font></font><code>100 → 60 </code></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous ne tirerons pas de conclusions de grande portée. </font><font style="vertical-align: inherit;">On ne sait pas comment les nombres originaux ont été calculés. </font><font style="vertical-align: inherit;">Nous ne comparerons pas les pommes avec les oranges. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici quelques chiffres de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wikichip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sur la bande passante et la taille du cache de mon processeur.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bande passante mémoire: 39,74 gigaoctets par seconde</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L1: 192 kilo-octets (32 Ko par cœur)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L2: 1,5 mégaoctets (256 Ko par cœur)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cache L3: 12 mégaoctets (partagé; 2 Mo par cœur)</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce que je veux savoir:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limite supérieure des performances de la RAM</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limite inférieure</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites du cache L1 / L2 / L3</font></font></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse comparative naïve</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons quelques tests. </font><font style="vertical-align: inherit;">Pour mesurer la bande passante, j'ai écrit un simple programme C ++. </font><font style="vertical-align: inherit;">Très approximativement, elle ressemble à ceci.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Generate random elements</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>; ++i) <span class="hljs-comment">// one billion ints</span>
    nums.push_back(rng() % <span class="hljs-number">1024</span>); <span class="hljs-comment">// small nums to prevent overflow</span><font></font>
<font></font>
<span class="hljs-comment">// Run test with 1 to 12 threads</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> thread_count = <span class="hljs-number">1</span>; thread_count &lt;= MAX_THREADS; ++thread_count) {
    <span class="hljs-keyword">auto</span> slice_len = nums.size() / thread_count;<font></font>
    <font></font>
    <span class="hljs-comment">// for-each thread</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> thread = <span class="hljs-number">0</span>; thread &lt; thread_count; ++thread) {<font></font>
        <font></font>
        <span class="hljs-comment">// partition data</span>
        <span class="hljs-keyword">auto</span> begin = nums.begin() + thread * slice_len;
        <span class="hljs-keyword">auto</span> end = (thread == thread_count - <span class="hljs-number">1</span>)<font></font>
            ? nums.end() : begin + slice_len;<font></font>
<font></font>
        <span class="hljs-comment">// spawn threads</span>
        futures.push_back(<span class="hljs-built_in">std</span>::async([begin, end] { <font></font>
            <font></font>
            <span class="hljs-comment">// sum ints sequentially</span>
            <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = begin; ptr &lt; end; ++ptr)<font></font>
                sum += *ptr;<font></font>
            <span class="hljs-keyword">return</span> sum;<font></font>
        }));<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// combine results</span>
    <span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; <span class="hljs-built_in">future</span> : futures)<font></font>
        sum += <span class="hljs-built_in">future</span>.get();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Certains détails sont omis. Mais vous avez compris l'idée. Créez un large éventail continu d'éléments. Divisez le tableau en fragments séparés. Traitez chaque fragment dans un thread séparé. Accumulez les résultats. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez également mesurer l'accès aléatoire. C'est très difficile. J'ai essayé plusieurs façons, j'ai finalement décidé de mélanger des index pré-calculés. Chaque index existe exactement une fois. Ensuite, la boucle interne parcourt les indices et calcule </font></font><code>sum += nums[index]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; nums = <span class="hljs-comment">/* ... */</span>;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">uint32_t</span>&gt; indices = <span class="hljs-comment">/* shuffled */</span>;<font></font>
<font></font>
<span class="hljs-comment">// random access</span>
<span class="hljs-keyword">int64_t</span> sum = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ptr = indices.begin(); ptr &lt; indices.end(); ++ptr) {
    <span class="hljs-keyword">auto</span> idx = *ptr;<font></font>
    sum += nums[idx];<font></font>
}<font></font>
<span class="hljs-keyword">return</span> sum;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le calcul du débit, je </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> considère </font><b><font style="vertical-align: inherit;">pas</font></b><font style="vertical-align: inherit;"> la mémoire du tableau d'index. </font><font style="vertical-align: inherit;">Seuls les octets qui contribuent au total sont comptés </font></font><code>sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Je ne compare pas mon matériel, mais j'évalue la capacité de travailler avec des ensembles de données de différentes tailles et avec différents schémas d'accès. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous effectuerons des tests avec trois types de données: </font></font><br>
<br>
<code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- l'entier principal 32 bits </font></font><br>
<code>matri4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- contient </font></font><code>int[16]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">tient dans une ligne de cache de 64 octets </font></font><br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- utilise des outils intégrés</font></font><code>__m256i</code><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gros bloc</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon premier test fonctionne avec un gros bloc de mémoire. Un bloc d' </font></font><code>N</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">éléments </font><font style="vertical-align: inherit;">de 1 Go </font><font style="vertical-align: inherit;">est mis en surbrillance et rempli de petites valeurs aléatoires. Une boucle simple itère sur un tableau N fois, donc elle accède à la mémoire avec un volume </font></font><code>N </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour calculer la somme </font></font><code>int64_t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Plusieurs threads divisent le tableau et chacun accède au même nombre d'éléments. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d36/45d/2d1/d3645d2d119e28f1306945258d1b422b.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voilà! Dans ce graphique, nous prenons le temps d'exécution moyen de l'opération de sommation et le convertissons de </font></font><code>runtime_in_nanoseconds</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">à </font></font><code>gigabytes_per_second</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Très bon résultat. </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut lire séquentiellement 11 Go / s en un seul flux. Il évolue linéairement jusqu'à atteindre 38 Go / s. Des tests </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">plus rapides, mais reposent contre le même plafond.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un plafond clair et évident sur la quantité de données que nous pouvons lire à partir de la RAM par seconde. </font><font style="vertical-align: inherit;">Sur mon système, cela représente environ 40 Go / s. </font><font style="vertical-align: inherit;">Ceci est conforme aux spécifications actuelles énumérées ci-dessus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À en juger par les trois derniers graphiques, l'accès aléatoire est lent. </font><font style="vertical-align: inherit;">Très, très lent. </font><font style="vertical-align: inherit;">Les performances sur </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un </font><font style="vertical-align: inherit;">seul thread </font><font style="vertical-align: inherit;">sont négligeables de 0,46 Go / s. </font><font style="vertical-align: inherit;">C'est 24 fois plus lent que l'empilement séquentiel à 11,03 Go / s! </font><font style="vertical-align: inherit;">Le test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montre le meilleur résultat, car il s'exécute sur des lignes de cache complètes. </font><font style="vertical-align: inherit;">Mais il est toujours quatre à sept fois plus lent que l'accès séquentiel et culmine à seulement 8 Go / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Petit bloc: lecture séquentielle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur mon système, la taille du cache L1 / L2 / L3 pour chaque flux est de 32 Ko, 256 Ko et 2 Mo. Que se passe-t-il si vous prenez un bloc d'éléments de 32 kilo-octets et que vous le répétez 125 000 fois? Il s'agit de 4 Go de mémoire, mais nous irons toujours dans le cache. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2bd/662/3dd/2bd6623dd63d0eae81548f4b5e6d4599.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Impressionnant! Les performances monothread sont similaires à la lecture d'un gros bloc, environ 12 Go / s. Sauf que cette fois, le multithreading franchit le plafond de 40 Go / s. Ca a du sens. Les données restent dans le cache, donc le goulot d'étranglement RAM n'apparaît pas. Pour les données qui ne tenaient pas dans le cache L3, le même plafond d'environ 38 Go / s s'applique. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montre des résultats similaires au circuit, mais encore plus rapides; 31 Go / s en mode monothread, 171 Go / s en mode multithread. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/929/9ab/ceb/9299abceb2e779406f598b76c00beba5.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons maintenant </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Faites attention à l'axe y.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/f96/7b2/9c6/f967b29c6f839f0536667b9918fabd70.png"><br>
<br>
<code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effectué exceptionnellement rapide. </font><font style="vertical-align: inherit;">C'est 10 fois plus rapide que </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sur un bloc de 16 Ko, il franchit même les 1000 Go / s! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Évidemment, il s'agit d'un test synthétique de surface. </font><font style="vertical-align: inherit;">La plupart des applications n'effectuent pas la même opération avec les mêmes données un million de fois de suite. </font><font style="vertical-align: inherit;">Le test ne montre pas les performances dans le monde réel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais la leçon est claire. </font><font style="vertical-align: inherit;">À l'intérieur du cache, les données sont traitées </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rapidement</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Avec un plafond très élevé lors de l'utilisation de SIMD: plus de 100 Go / s en mode mono-thread, plus de 1000 Go / s en multi-thread. </font><font style="vertical-align: inherit;">L'écriture de données dans le cache est lente et avec une limite stricte d'environ 40 Go / s.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Petit bloc: lecture aléatoire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons de même, mais maintenant avec un accès aléatoire. </font><font style="vertical-align: inherit;">Ceci est ma partie préférée de l'article. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/983/854/ef8/983854ef856e17e37493e9c8b928d318.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lecture de valeurs aléatoires à partir de la RAM est lente, seulement 0,46 Go / s. </font><font style="vertical-align: inherit;">La lecture de valeurs aléatoires à partir du cache L1 est très rapide: 13 Go / s. </font><font style="vertical-align: inherit;">C'est plus rapide que de lire des données série </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depuis la RAM (11 Go / s). </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/59a/7bf/b72/59a7bfb728445b69a7947523ab9b0900.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le test </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">montre un résultat similaire pour le même modèle, mais environ deux fois plus rapide que </font></font><code>int</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d99/bc2/f70/d99bc2f70c2f7bda177f70ec166bd74a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'accès aléatoire est </font></font><code>matrix4x4_simd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incroyablement rapide.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résultats d'accès aléatoire</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lecture libre de la mémoire est lente. </font><font style="vertical-align: inherit;">Catastrophiquement lent. </font><font style="vertical-align: inherit;">Moins de 1 Go / s pour les deux cas de test </font></font><code>int32</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans le même temps, les lectures aléatoires à partir du cache sont étonnamment rapides. </font><font style="vertical-align: inherit;">Elle est comparable à la </font><font style="vertical-align: inherit;">lecture </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">séquentielle à</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir de la RAM. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dde/0a4/52b/dde0a452b8f293758c2efe1760115306.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il doit être digéré. </font><font style="vertical-align: inherit;">L'accès aléatoire au cache est comparable en vitesse à l'accès séquentiel à la RAM. </font><font style="vertical-align: inherit;">La baisse de L1 16 Ko à L2 256 Ko n'est que de moitié ou moins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pense que cela aura des conséquences profondes.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les listes liées sont considérées comme nuisibles</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chasser un pointeur (sauter sur des pointeurs) est mauvais. </font><font style="vertical-align: inherit;">Très très mauvais. </font><font style="vertical-align: inherit;">Combien les performances diminuent-elles? </font><font style="vertical-align: inherit;">Voir par vous-même. </font><font style="vertical-align: inherit;">Je l' </font><font style="vertical-align: inherit;">ai fait un test supplémentaire qui enveloppe </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en </font></font><code>std::unique_ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Chaque accès passe par un pointeur. </font><font style="vertical-align: inherit;">Voici un résultat terrible, juste catastrophique.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">     1 fil | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grand bloc - Seq | </font><font style="vertical-align: inherit;">14,8 Go / s | </font><font style="vertical-align: inherit;">0,8 Go / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 Ko - Séq | </font><font style="vertical-align: inherit;">31,6 Go / s | </font><font style="vertical-align: inherit;">2,2 Go / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 Ko - Séq | </font><font style="vertical-align: inherit;">22,2 Go / s | </font><font style="vertical-align: inherit;">1,9 Go / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grand bloc - Rand | </font><font style="vertical-align: inherit;">2,2 Go / s | </font><font style="vertical-align: inherit;">0,1 Go / s | </font><font style="vertical-align: inherit;">22x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 Ko - Rand | </font><font style="vertical-align: inherit;">23,2 Go / s | </font><font style="vertical-align: inherit;">1,7 Go / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 Ko - Rand | </font><font style="vertical-align: inherit;">15,2 Go / s | </font><font style="vertical-align: inherit;">0,8 Go / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font>
<font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     6 fils | </font><font style="vertical-align: inherit;">matrix4x4 | </font><font style="vertical-align: inherit;">unique_ptr | </font><font style="vertical-align: inherit;">diff |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------------------- | --------------- | ------------ | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grand bloc - Seq | </font><font style="vertical-align: inherit;">34,4 Go / s | </font><font style="vertical-align: inherit;">2,5 Go / s | </font><font style="vertical-align: inherit;">14x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 Ko - Séq | </font><font style="vertical-align: inherit;">154,8 Go / s | </font><font style="vertical-align: inherit;">8,0 Go / s | </font><font style="vertical-align: inherit;">19x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 Ko - Séq | </font><font style="vertical-align: inherit;">111,6 Go / s | </font><font style="vertical-align: inherit;">5,7 Go / s | </font><font style="vertical-align: inherit;">20x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Grand bloc - Rand | </font><font style="vertical-align: inherit;">7,1 Go / s | </font><font style="vertical-align: inherit;">0,4 Go / s | </font><font style="vertical-align: inherit;">18x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
16 Ko - Rand | </font><font style="vertical-align: inherit;">95,0 Go / s | </font><font style="vertical-align: inherit;">7,8 Go / s | </font><font style="vertical-align: inherit;">12x |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
256 Ko - Rand | </font><font style="vertical-align: inherit;">58,3 Go / s | </font><font style="vertical-align: inherit;">1,6 Go / s | </font><font style="vertical-align: inherit;">36x |</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sommation séquentielle des valeurs derrière le pointeur est effectuée à une vitesse inférieure à 1 Go / s. </font><font style="vertical-align: inherit;">La vitesse d'accès aléatoire à double saut du cache n'est que de 0,1 Go / s. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La poursuite d'un pointeur ralentit l'exécution du code 10 à 20 fois. </font><font style="vertical-align: inherit;">Ne laissez pas vos amis utiliser des listes chaînées. </font><font style="vertical-align: inherit;">Veuillez penser au cache.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Estimation budgétaire pour les cadres</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est courant pour les développeurs de jeux de définir une limite (budget) pour la charge sur le CPU et la mémoire. Mais je n'ai jamais vu de budget de bande passante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans les jeux modernes, FPS continue de croître. Il est maintenant à 60 FPS. VR fonctionne à une fréquence de 90 Hz. J'ai un moniteur de jeu 144 Hz. C'est génial, donc le 60 FPS ressemble à de la merde. Je ne reviendrai jamais sur l'ancien moniteur. Esports et streamers Twitch surveille 240 Hz. Cette année, Asus a présenté un monstre à 360 Hz au CES. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mon processeur a une limite supérieure d'environ 40 Go / s. Cela semble être un grand nombre! Cependant, à une fréquence de 240 Hz, seulement 167 Mo par trame sont obtenus. Une application réaliste peut générer un trafic de 5 Go / s à 144 Hz, soit seulement 69 Mo par trame. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un tableau avec quelques chiffres.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">        | </font><font style="vertical-align: inherit;">1 | </font><font style="vertical-align: inherit;">10 | </font><font style="vertical-align: inherit;">30 | </font><font style="vertical-align: inherit;">60 | </font><font style="vertical-align: inherit;">90 | </font><font style="vertical-align: inherit;">144 | </font><font style="vertical-align: inherit;">240 | </font><font style="vertical-align: inherit;">360 |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-------- | ------- | -------- | -------- | -------- | ------ - | -------- | -------- | -------- |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
40 Go / s | </font><font style="vertical-align: inherit;">40 Go | </font><font style="vertical-align: inherit;">4 Go | </font><font style="vertical-align: inherit;">1,3 Go | </font><font style="vertical-align: inherit;">667 Mo | </font><font style="vertical-align: inherit;">444 Mo | </font><font style="vertical-align: inherit;">278 Mo | </font><font style="vertical-align: inherit;">167 Mo | </font><font style="vertical-align: inherit;">111 Mo |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
10 Go / s | </font><font style="vertical-align: inherit;">10 Go | </font><font style="vertical-align: inherit;">1 Go | </font><font style="vertical-align: inherit;">333 Mo | </font><font style="vertical-align: inherit;">166 Mo | </font><font style="vertical-align: inherit;">111 Mo | </font><font style="vertical-align: inherit;">69 Mo | </font><font style="vertical-align: inherit;">42 Mo | </font><font style="vertical-align: inherit;">28 Mo |</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 1 Go / s | </font><font style="vertical-align: inherit;">1 Go | </font><font style="vertical-align: inherit;">100 Mo | </font><font style="vertical-align: inherit;">33 Mo | </font><font style="vertical-align: inherit;">17 Mo | </font><font style="vertical-align: inherit;">11 Mo | </font><font style="vertical-align: inherit;">7 Mo | </font><font style="vertical-align: inherit;">4 Mo | </font><font style="vertical-align: inherit;">3 Mo |</font></font><font></font>
</pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il me semble qu'il est utile d'évaluer les problèmes sous cet angle. </font><font style="vertical-align: inherit;">Cela montre clairement que certaines idées ne sont pas réalisables. </font><font style="vertical-align: inherit;">Atteindre 240 Hz n'est pas facile. </font><font style="vertical-align: inherit;">Cela ne se fera pas tout seul.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chiffres que chaque programmeur devrait connaître (2020)</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La liste précédente est obsolète. </font><font style="vertical-align: inherit;">Il doit maintenant être mis à jour et mis en conformité d'ici 2020. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici quelques chiffres pour mon ordinateur personnel. </font><font style="vertical-align: inherit;">Ceci est un mélange d'AIDA64, Sandra et mes références. </font><font style="vertical-align: inherit;">Les chiffres ne donnent pas une image complète et ne sont qu'un point de départ.</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latence L1: 1 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Délai L2: 2,5 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retard L3: 10 ns</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Latence RAM: 50 ns</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(par fil)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bande L1: 210 Go / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bande L2: 80 Go / s</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bande L3: 60 Go / s</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(le système au complet)</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bande RAM: 45 Go / s</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce serait bien de créer un petit benchmark open source simple. </font><font style="vertical-align: inherit;">Certains fichiers C qui peuvent être exécutés sur des ordinateurs de bureau, des serveurs, des appareils mobiles, des consoles, etc. Mais je ne suis pas du genre à écrire un tel outil.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Déni de responsabilité</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La mesure de la bande passante mémoire est difficile. </font><font style="vertical-align: inherit;">Très difficile. </font><font style="vertical-align: inherit;">Il y a probablement des erreurs dans mon code. </font><font style="vertical-align: inherit;">De nombreux facteurs non comptabilisés. </font><font style="vertical-align: inherit;">Si vous critiquez ma technique, vous avez probablement raison. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, je pense que c'est normal. </font><font style="vertical-align: inherit;">Cet article ne concerne pas les performances exactes de mon bureau. </font><font style="vertical-align: inherit;">Il s'agit d'une déclaration de problème d'un certain point de vue. </font><font style="vertical-align: inherit;">Et comment apprendre à faire des calculs mathématiques approximatifs.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un collègue m'a fait part d'une opinion intéressante sur la bande passante mémoire du GPU et les performances des applications. </font><font style="vertical-align: inherit;">Cela m'a incité à étudier les performances de la mémoire sur les ordinateurs modernes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour des calculs approximatifs, voici quelques chiffres pour un bureau moderne:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances RAM</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum: </font></font><code>45 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En moyenne, environ: </font></font><code>5 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le minimum: </font></font><code>1 /</code></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances du cache L1 / L2 / L3 (par cœur)</font></font><br>
 <ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maximum (c simd): </font></font><code>210 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>80 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>60 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En moyenne, environ: </font></font><code>25 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>15 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>9 /</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Minimum: </font></font><code>13 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>8 /</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font><code>3,5 /</code></li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les notes d'échantillon sont liées aux performances </font></font><code>matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Le vrai code ne sera jamais aussi simple. </font><font style="vertical-align: inherit;">Mais pour les calculs sur une serviette, c'est un point de départ raisonnable. </font><font style="vertical-align: inherit;">Vous devez ajuster ce chiffre en fonction des modèles d'accès à la mémoire dans votre programme, des caractéristiques de votre équipement et du code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, la chose la plus importante est une nouvelle façon de penser aux problèmes. </font><font style="vertical-align: inherit;">La présentation du problème en octets par seconde ou en octets par trame est une autre lentille à regarder. </font><font style="vertical-align: inherit;">C'est un outil utile au cas où. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci d'avoir lu.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></h1><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benchmark C ++ </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python Graph </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data.json</font></font></a><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">De plus amples recherches</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article n'a que légèrement abordé le sujet. </font><font style="vertical-align: inherit;">Je n’y entrerai probablement pas. </font><font style="vertical-align: inherit;">Mais s'il le faisait, alors il pourrait couvrir certains des aspects suivants:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrement des performances</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faux partage</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance </font></font><code>std::atomic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ou son absence)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compteurs de performance</font></font><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances TLB</font></font></a><br>
</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protocoles de cache</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spécifications du système</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Des tests ont été effectués sur mon ordinateur personnel. </font><font style="vertical-align: inherit;">Seuls les paramètres de stock, pas d'overclocking.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Système d'exploitation: Windows 10 v1903 build 18362</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processeur: Intel i7-8700k à 3,70 GHz</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAM: 2x16 GSkill Ripjaw DDR4-3200 (16-18-18-38 @ 1600 MHz)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carte mère: Asus TUF Z370-Plus Gaming</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr487884/index.html">5 choses que j'aimerais savoir avant de développer l'échange</a></li>
<li><a href="../fr487888/index.html">CSRF chez Umbraco CMS</a></li>
<li><a href="../fr487890/index.html">Traduire la parole en texte sur iOS à l'aide du framework Speech</a></li>
<li><a href="../fr487894/index.html">BarsUP.AM: comment nous avons développé un outil de protection des informations des applications web</a></li>
<li><a href="../fr487896/index.html">Quand la mort se transforme en art: épitaphes de personnages célèbres avec un sens profond en anglais</a></li>
<li><a href="../fr487900/index.html">pyqtdeploy, ou nous emballons le programme Python dans exe'shnik ... à la dure</a></li>
<li><a href="../fr487902/index.html">D'incendie en incendie: électrolyte à l'état solide réfractaire pour batteries lithium-ion</a></li>
<li><a href="../fr487906/index.html">Le livre "Réseaux informatiques. Principes, technologies, protocoles: édition anniversaire »</a></li>
<li><a href="../fr487908/index.html">Le début de la guerre des processus technologiques: 5 nm et 3 nm</a></li>
<li><a href="../fr487910/index.html">Lois naturelles et mathématiques élégantes: problèmes et solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>