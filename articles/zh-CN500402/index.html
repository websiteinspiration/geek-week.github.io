<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔩 🎅🏿 ⤵️ [Part 1/2] FFmpeg和SDL指南或如何编写少于1000行的视频播放器 👨🏼‍🚒 🌔 👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="尽管此信息已经过时，但原始材料仍然是FFmpeg主题上各种有用内容的流行灵感来源。但是，仍然没有将原件完全翻译成俄文。我们更正了烦人的遗漏，因为迟到总比没有好。
 
 尽管我们尝试了，但是在如此庞大的文本中翻译的困难是不可避免的。报告错误（最好是在私人消息中）-我们在一起将做得更好。
 
 目录  ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Part 1/2] FFmpeg和SDL指南或如何编写少于1000行的视频播放器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/500402/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/8g/lm/9b/8glm9bxivqkvscmah31ojdjmzci.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管此信息已经过时，但原始材料仍然是FFmpeg主题上各种有用内容的流行灵感来源。</font><font style="vertical-align: inherit;">但是，仍然没有将原件完全翻译成俄文。</font><font style="vertical-align: inherit;">我们更正了烦人的遗漏，因为迟到总比没有好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管我们尝试了，但是在如此庞大的文本</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中翻译的困难是</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可避免的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">报告错误（最好是在私人消息中）-我们在一起将做得更好。</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1部分</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2部分</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前言</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1课：创建屏幕截图</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2课：显示</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3课：播放声音</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4课：多线程</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5课：同步视频</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 6:  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 7: </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 1.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> 2.  </a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><a name="preamble"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="EDISON软件-网络开发"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON软件-网络开发"></a><br clear="right">
     EDISON.<br>
<br>
        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     </a>,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">      C  C++</a>.<br>
<br>
     ! ;-)</blockquote><br>
<h2> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录">⇑</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第1课：创建屏幕截图">→</a></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD：本指南已于2015年2月更新。</font></font></b><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是用于创建视频应用程序和通用实用程序的出色库。 FFmpeg负责整个视频处理例程，执行所有解码，编码，复用和解复用。这极大地简化了媒体应用程序的创建。一切都非常简单，快捷，用C编写，您可以解码当今几乎所有可用的编解码器，以及编码为其他格式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一的不足是该文档几乎丢失了。有一个教程（</font><i><font style="vertical-align: inherit;">在原始</font></i><font style="vertical-align: inherit;">教程</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中，这是到一个不存在的网页的链接-注释翻译器</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），涵盖了FFmpeg的基础知识和doxygen扩展坞的自动生成。仅此而已。因此，我决定独立研究如何使用FFmpeg创建有效的数字视频和音频应用程序，同时记录该过程并以教科书的形式进行介绍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FFmpeg附带有一个FFplay程序。它很简单，用C编写，使用FFmpeg实现了完整的视频播放器。我的第一课是Martin Boehme的原始课程的更新版本（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">原始语言是指向已经失效的网页的链接-译者注</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-我从那里拖了一些片段。在我的系列课程中，我还将展示基于</font><b><font style="vertical-align: inherit;">ffplay.c</font></b><font style="vertical-align: inherit;">创建有效的视频播放器的过程</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法布里斯·贝勒（Fabrice Bellard）。每节课将介绍一个新的想法（甚至两个），并说明其实施方式。每章都有一个C清单，您可以编译并自行运行。源文件将显示该程序的工作方式，各个部分的工作方式，并演示本指南未涵盖的次要技术细节。完成后，我们将使用不到1000行代码编写一个可正常工作的视频播放器！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建播放器时，我们将使用SDL输出音频和视频媒体文件。 SDL是一个出色的跨平台多媒体库，可用于MPEG播放程序，仿真器和许多视频游戏。您需要在系统上下载并安装SDL库，才能从本指南中编译程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本教程适用于具有良好编程经验的人。至少，您需要了解C，并且还需要了解队列，互斥对象等概念。应该对多媒体有所了解；例如，诸如波形之类的东西。但是，不必在这些问题上担任专家，因为在上课过程中将解释许多概念。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请随时通过Dranger Doggy Gmail dot Com向我发送错误消息，问题，评论，想法，功能等。</font></font><a name="screencaps"></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另请参阅</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EDISON公司</font><font style="vertical-align: inherit;">的博客</font><font style="vertical-align: inherit;">：</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg libav手册</font></font></b></a><br>
<hr><hr><hr><hr><hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第1课：创建屏幕截图</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="前言"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第2课：显示"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整清单：tutorial01.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial01.c</span>
<span class="hljs-comment">// Code based on a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101 </span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span><font></font>
<font></font>
<span class="hljs-comment">// A small sample program that shows how to use libavformat and libavcodec to</span>
<span class="hljs-comment">// read video from a file.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lswscale -lz</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed</span>
<span class="hljs-comment">// your system).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// tutorial01 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to write the first five frames from "myvideofile.mpg" to disk in PPM</span>
<span class="hljs-comment">// format.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{
  <span class="hljs-comment">// Initalizing these to NULL prevents segfaults!</span>
  AVFormatContext   *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>               i, videoStream;<font></font>
  AVCodecContext    *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext    *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec           *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame           *pFrameRGB = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket          packet;<font></font>
  <span class="hljs-keyword">int</span>               frameFinished;
  <span class="hljs-keyword">int</span>               numBytes;
  <span class="hljs-keyword">uint8_t</span>           *buffer = <span class="hljs-literal">NULL</span>;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please provide a movie file\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
  pFrameRGB=av_frame_alloc();<font></font>
  <span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
  numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
			      pCodecCtx-&gt;height);<font></font>
  buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));<font></font>
  <font></font>
  <span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
  <span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
  <span class="hljs-comment">// of AVPicture</span><font></font>
  avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
		 pCodecCtx-&gt;width, pCodecCtx-&gt;height);<font></font>
  <font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_RGB24,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {
	<span class="hljs-comment">// Convert the image from its native format to RGB</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
	<span class="hljs-comment">// Save the frame to disk</span>
	<span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
	  SaveFrame(pFrameRGB, pCodecCtx-&gt;width, pCodecCtx-&gt;height, <font></font>
		    i);<font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the RGB image</span><font></font>
  av_free(buffer);<font></font>
  av_frame_free(&amp;pFrameRGB);<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总览</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
电影文件具有几个主要组成部分。首先，文件本身称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">容器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><b><font style="vertical-align: inherit;">容器</font></b><font style="vertical-align: inherit;">的类型决定了文件中数据的表示方式。容器的示例是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quicktime</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此外，文件中有多个线程。特别地，通常存在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频流</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频流</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 （“流”是一个有趣的词，意为“根据时间轴可用的一系列数据项。”）流中的数据项称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。每个流由一种或另一种类型的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编解码器编码</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。编解码器确定如何将实际数据发送</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diruyutsya和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">December</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">已审核-编解码器的名称。</font><font style="vertical-align: inherit;">DivX和MP3是编解码器的示例。</font><font style="vertical-align: inherit;">然后从流中读取数据包。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据包</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是数据片段，可以包含</font><font style="vertical-align: inherit;">解码为原始帧</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的数据位</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们最终可以在应用程序中对其进行操作。</font><font style="vertical-align: inherit;">为了我们的目的，每个数据包都包含完整帧（如果是音频，则包含几个帧）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
即使在最基本的级别上，使用视频和音频流也非常简单：</font></font><br>
<br>
<pre><code class="vbscript hljs"><span class="hljs-number">10</span> OPEN video_stream FROM video.avi
<span class="hljs-number">20</span> READ packet FROM video_stream INTO frame
<span class="hljs-number">30</span> <span class="hljs-keyword">IF</span> frame <span class="hljs-keyword">NOT</span> COMPLETE <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span>
<span class="hljs-number">40</span> <span class="hljs-keyword">DO</span> SOMETHING <span class="hljs-keyword">WITH</span> frame
<span class="hljs-number">50</span> <span class="hljs-keyword">GOTO</span> <span class="hljs-number">20</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用FFmpeg使用多媒体几乎与该程序一样简单，尽管在某些程序中“ MAKE”步骤可能非常困难。</font><font style="vertical-align: inherit;">在本教程中，我们将打开文件，计算其中的视频流，然后我们的“ MAKE”将帧写入PPM文件。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开文件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，让我们看看打开文件时首先发生的情况。</font><font style="vertical-align: inherit;">首先使用FFmpeg初始化所需的库：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ffmpeg/swscale.h&gt;</span></span><font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, charg *argv[])</span> </span>{<font></font>
av_register_all();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这会在库中注册所有可用的文件格式和编解码器，因此在打开具有适当格式/编解码器的文件时将自动使用它们。</font><font style="vertical-align: inherit;">请注意，您只需要调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_register_all</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）一次，因此我们在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）中进行此操作。</font><font style="vertical-align: inherit;">如果愿意，可以仅注册选择性文件格式和编解码器，但通常没有特殊原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在打开文件：</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Open video file</span>
<span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从第一个参数获取文件名。</font><font style="vertical-align: inherit;">此函数读取文件头并将文件格式信息存储在</font><font style="vertical-align: inherit;">我们传递</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">中。</font><font style="vertical-align: inherit;">最后三个参数用于指定文件格式，缓冲区大小和格式参数。</font><font style="vertical-align: inherit;">通过将它们设置为NULL或0，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libavformat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将自动检测所有内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数仅查看标头，因此现在我们需要检查文件中的流信息：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Retrieve stream information</span>
<span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该函数将</font><font style="vertical-align: inherit;">有效数据</font><font style="vertical-align: inherit;">传递给</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们熟悉了方便的调试功能，向我们展示了其中的内容：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Dump information about file onto standard error</span>
av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是一个大小为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFormatCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的指针数组</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将仔细研究直到找到视频流：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> i;<font></font>
AVCodecContext *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
AVCodecContext *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
    videoStream=i;<font></font>
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
<font></font>
<span class="hljs-comment">// Get a pointer to the codec context for the video stream</span>
pCodecCtx=pFormatCtx-&gt;streams[videoStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关流中编解码器的信息位于称为“ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编解码器上下文</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”的位置。</font><font style="vertical-align: inherit;">它包含有关流使用的编解码器的所有信息，现在我们有一个指向它的指针。</font><font style="vertical-align: inherit;">但是我们仍然必须找到真正的编解码器并打开它：</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">// Open codec</span>
<span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec)&lt;<span class="hljs-number">0</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，您不能直接</font><font style="vertical-align: inherit;">从视频流中</font><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">因此，您必须使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vcodec_copy_context</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）将上下文复制到新位置（当然，在为它分配内存之后）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据存储</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要一个存放框架的地方：</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
<span class="hljs-comment">// Allocate video frame</span>
pFrame=av_frame_alloc();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们计划输出以24位RGB存储的PPM文件，因此我们需要将帧从其自身的格式转换为RGB。</font><font style="vertical-align: inherit;">FFmpeg将为我们做到这一点。</font><font style="vertical-align: inherit;">对于大多数项目（包括此项目），您需要将起始帧转换为特定格式。</font><font style="vertical-align: inherit;">为转换后的帧选择一个帧：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Allocate an AVFrame structure</span><font></font>
pFrameRGB=av_frame_alloc();<font></font>
<span class="hljs-keyword">if</span>(pFrameRGB==<span class="hljs-literal">NULL</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管我们选择了框架，但在转换原始数据时仍需要一个地方来容纳原始数据。</font><font style="vertical-align: inherit;">我们使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_get_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来获取正确的大小并手动分配必要的空间：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint8_t</span> *buffer = <span class="hljs-literal">NULL</span>;
<span class="hljs-keyword">int</span> numBytes;
<span class="hljs-comment">// Determine required buffer size and allocate buffer</span><font></font>
numBytes=avpicture_get_size(PIX_FMT_RGB24, pCodecCtx-&gt;width,<font></font>
                            pCodecCtx-&gt;height);<font></font>
buffer=(<span class="hljs-keyword">uint8_t</span> *)av_malloc(numBytes*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint8_t</span>));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font><font style="vertical-align: inherit;">FFmpeg </font><font style="vertical-align: inherit;">的C函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的类似物</font><font style="vertical-align: inherit;">，它是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的简单包装</font><font style="vertical-align: inherit;">，提供内存地址等的对齐方式。</font><font style="vertical-align: inherit;">顺便说一句，这不能防止内存泄漏，双重释放或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生的其他问题</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpicture_fill</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将帧与新分配的缓冲区关联。</font><font style="vertical-align: inherit;">关于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：所述</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">是的一个子集</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">-的开头</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><b><font style="vertical-align: inherit;">是</font></b><font style="vertical-align: inherit;">相同于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Assign appropriate parts of buffer to image planes in pFrameRGB</span>
<span class="hljs-comment">// Note that pFrameRGB is an AVFrame, but AVFrame is a superset</span>
<span class="hljs-comment">// of AVPicture</span><font></font>
avpicture_fill((AVPicture *)pFrameRGB, buffer, PIX_FMT_RGB24,<font></font>
                pCodecCtx-&gt;width, pCodecCtx-&gt;height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已经到了终点线！</font><font style="vertical-align: inherit;">现在我们准备从流中读取信息！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取数据</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，要读取整个视频流，我们将读取下一个包，并在帧中对其进行解密，解密完成后，立即转换帧并保存：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span>
<span class="hljs-keyword">int</span> frameFinished;<font></font>
AVPacket packet;<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    pCodecCtx-&gt;pix_fmt,<font></font>
    pCodecCtx-&gt;width,<font></font>
    pCodecCtx-&gt;height,<font></font>
    PIX_FMT_RGB24,<font></font>
    SWS_BILINEAR,<font></font>
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span>,
    <span class="hljs-literal">NULL</span><font></font>
    );<font></font>
<font></font>
i=<span class="hljs-number">0</span>;
<span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
	<span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
    <font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">// Convert the image from its native format to RGB</span>
        sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);<font></font>
	<font></font>
        <span class="hljs-comment">// Save the frame to disk</span>
        <span class="hljs-keyword">if</span>(++i&lt;=<span class="hljs-number">5</span>)<font></font>
          SaveFrame(pFrameRGB, pCodecCtx-&gt;width, <font></font>
                    pCodecCtx-&gt;height, i);<font></font>
    }<font></font>
  }<font></font>
    <font></font>
  <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
  av_free_packet(&amp;packet);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
没什么复杂的：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）读取包并将其保存在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构中</font><font style="vertical-align: inherit;">。请注意，我们仅分发包的结构</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-FFmpeg</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向我们提供了</font><b><font style="vertical-align: inherit;">packet.data</font></b><font style="vertical-align: inherit;">指向的内部数据</font><font style="vertical-align: inherit;">。稍后释放</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free_packet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）将数据包转换为帧。然而，我们可能没有，我们需要对分组进行解码后的帧的所有信息，因此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）组</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我们有下一帧。最后，我们使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）从我们自己的格式进行转换（</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pCodecCtx-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt;</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）在RGB中。请记住，可以将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font><b><font style="vertical-align: inherit;">强制</font></b><font style="vertical-align: inherit;">转换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font><font style="vertical-align: inherit;">。最后，我们传递有关</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的框架，高度和宽度的</font><b><font style="vertical-align: inherit;">信息</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
说起包裹。从技术上讲，数据包只能包含一部分帧以及其他数据位。但是，FFmpeg解析器保证我们收到的数据包包含完整帧或什至几个帧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在剩下要做的就是使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将RGB信息写入PPM文件。尽管我们只是在表面上处理PPM格式；相信我，一切都在这里工作：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SaveFrame</span><span class="hljs-params">(AVFrame *pFrame, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> iFrame)</span> </span>{<font></font>
  FILE *pFile;<font></font>
  <span class="hljs-keyword">char</span> szFilename[<span class="hljs-number">32</span>];
  <span class="hljs-keyword">int</span>  y;<font></font>
  <font></font>
  <span class="hljs-comment">// Open file</span>
  <span class="hljs-built_in">sprintf</span>(szFilename, <span class="hljs-string">"frame%d.ppm"</span>, iFrame);<font></font>
  pFile=fopen(szFilename, <span class="hljs-string">"wb"</span>);
  <span class="hljs-keyword">if</span>(pFile==<span class="hljs-literal">NULL</span>)
    <span class="hljs-keyword">return</span>;<font></font>
  <font></font>
  <span class="hljs-comment">// Write header</span>
  <span class="hljs-built_in">fprintf</span>(pFile, <span class="hljs-string">"P6\n%d %d\n255\n"</span>, width, height);<font></font>
  <font></font>
  <span class="hljs-comment">// Write pixel data</span>
  <span class="hljs-keyword">for</span>(y=<span class="hljs-number">0</span>; y&lt;height; y++)<font></font>
    fwrite(pFrame-&gt;data[<span class="hljs-number">0</span>]+y*pFrame-&gt;linesize[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, width*<span class="hljs-number">3</span>, pFile);<font></font>
  <font></font>
  <span class="hljs-comment">// Close file</span><font></font>
  fclose(pFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们执行标准文件打开等操作，然后记录RGB数据。该文件逐行写入。 PPM文件只是其中RGB信息以长行显示的文件。如果您知道HTML的颜色，则就像标记每个像素从头到尾的颜色一样，例如</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃ff0000＃ff0000 ....</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，就像红色屏幕一样。 （实际上，它以二进制格式存储，没有分隔符，但我希望您能理解。）标题指示图像的宽度和高度，以及RGB值的最大大小。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在回到我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。一旦我们完成了从视频流中读取的内容，我们只需清除所有内容：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Free the RGB image</span><font></font>
av_free(buffer);<font></font>
av_free(pFrameRGB);<font></font>
<font></font>
<span class="hljs-comment">// Free the YUV frame</span><font></font>
av_free(pFrame);<font></font>
<font></font>
<span class="hljs-comment">// Close the codecs</span><font></font>
avcodec_close(pCodecCtx);<font></font>
avcodec_close(pCodecCtxOrig);<font></font>
<font></font>
<span class="hljs-comment">// Close the video file</span><font></font>
avformat_close_input(&amp;pFormatCtx);<font></font>
<font></font>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_free</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcode_alloc_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_malloc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分配的内存</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是全部代码！</font><font style="vertical-align: inherit;">现在，如果您使用的是Linux或类似平台，请运行：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavutil -lavformat -lavcodec -lz -lavutil -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您使用的是较旧版本的FFmpeg，则可能需要删除</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-lavutil</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial01 tutorial01.c -lavformat -lavcodec -lz -lm</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大多数图形程序必须打开PPM格式。</font><font style="vertical-align: inherit;">在使用我们的程序制作了屏幕截图的一些电影文件上进行检查。</font></font><a name="outputting"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第2课：显示屏幕</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第1课：创建屏幕截图"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第三课：播放声音"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整清单：tutorial02.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial02.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">// </span>
<span class="hljs-comment">// gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial02 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-keyword">float</span>           aspect_ratio;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++)
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO) {<font></font>
      videoStream=i;<font></font>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span><font></font>
  <font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
      <font></font>
      }<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codec</span><font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL和视频</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了在屏幕上绘图，我们将使用SDL。 SDL代表</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单直接层</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。它是许多项目中使用的出色的跨平台多媒体库。您可以在官方网站上获得该库，或者下载适用于您的操作系统的开发人员软件包。您将需要库来编译本课程中的代码（顺便说一下，所有其他课程也都适用）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL有许多在屏幕上绘制的方法。显示电影的一种方法是所谓的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV覆盖</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正式上，甚至不是YUV，而是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YCbCr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。顺便说一句，当“ YCbCr”被称为“ YUV”时，某些人会非常燃烧。一般来说，YUV是模拟格式，而YCbCr是数字格式。 FFmpeg和SDL在其代码和宏中将YCbCr指定为YUV，但这是。</font></font></i><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种存储原始图像数据（例如RGB）的方法。大致来说，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">亮度</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的组成部分</font><font style="vertical-align: inherit;">，而</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">颜色的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">组成部分</font><font style="vertical-align: inherit;">。 （这比RGB更复杂，因为部分颜色信息被丢弃，并且</font><font style="vertical-align: inherit;">每2个</font><b><font style="vertical-align: inherit;">Y</font></b><font style="vertical-align: inherit;">值只能有1个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值。</font><font style="vertical-align: inherit;">）</font><b><font style="vertical-align: inherit;">YUV叠加</font></b></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL中的接受原始YUV数据集并显示它。它接受4种不同的YUV格式，但是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是其中最快的一种。</font><font style="vertical-align: inherit;">除了</font><font style="vertical-align: inherit;">交换</font><b><font style="vertical-align: inherit;">U</font></b><font style="vertical-align: inherit;">和</font><b><font style="vertical-align: inherit;">V</font></b><font style="vertical-align: inherit;">的数组之外，</font><font style="vertical-align: inherit;">还有另一种YUV格式称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它与YV12匹配</font><font style="vertical-align: inherit;">。 420表示以4：2：0的比率对其进行采样，也就是说，每4次亮度测量都进行1次颜色测量，因此颜色信息按四分之一分布。这是节省带宽的好方法，因为人眼仍然没有注意到这些变化。在名称拉丁字母“P”表示该格式是“平面”，它简单地意味着该组件是</font><b><font style="vertical-align: inherit;">ÿ</font></b><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">U</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在单独的数组中。</font><font style="vertical-align: inherit;">FFmpeg可以将图像转换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这非常有帮助，因为许多视频流已经以这种格式存储或易于转换为它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们当前的计划是替换</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一课中的SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，并显示我们的框架。</font><font style="vertical-align: inherit;">但是首先，您需要熟悉SDL库的基本功能。</font><font style="vertical-align: inherit;">首先，连接库并初始化SDL：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Init</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）本质上告诉库我们将使用哪些函数。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_GetError</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（），当然，这是我们方便的调试功能。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示制作</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要在屏幕上放置一个位置来排列元素。</font><font style="vertical-align: inherit;">使用SDL显示图像的主要区域称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表面</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface *screen;<font></font>
<font></font>
screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">if</span>(!screen) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们设置了具有给定宽度和高度的屏幕。</font><font style="vertical-align: inherit;">下一个选项是屏幕的位深度-0-这是一个特殊值，表示“与当前显示相同”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们</font><font style="vertical-align: inherit;">在此屏幕上</font><font style="vertical-align: inherit;">创建一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV叠加层</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以便我们可以向其输出视频，并配置</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWSContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将图像数据转换为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay     *bmp = <span class="hljs-literal">NULL</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SWSContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
<font></font>
bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,<font></font>
                           SDL_YV12_OVERLAY, screen);<font></font>
<font></font>
<span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
                         pCodecCtx-&gt;height,<font></font>
			 pCodecCtx-&gt;pix_fmt,<font></font>
			 pCodecCtx-&gt;width,<font></font>
			 pCodecCtx-&gt;height,<font></font>
			 PIX_FMT_YUV420P,<font></font>
			 SWS_BILINEAR,<font></font>
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>,
			 <span class="hljs-literal">NULL</span>
			 );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如前所述，我们使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YV12</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来显示图像并</font><font style="vertical-align: inherit;">从FFmpeg </font><font style="vertical-align: inherit;">获取</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图像显示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，这很容易！现在我们只需要显示图像。让我们一直走到完成拍摄的地方。我们可以摆脱RGB帧的所有内容，并</font><font style="vertical-align: inherit;">用显示代码</font><font style="vertical-align: inherit;">替换</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SaveFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。为了显示图像，我们将创建一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">，并为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV叠加层</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置其数据指针和行大小</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
    SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
    AVPicture pict;<font></font>
    pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
    pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们计划覆盖该覆盖层，因为我们计划对其进行写入。这是一个好习惯，这样以后就没有问题了。</font><font style="vertical-align: inherit;">如上所示，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">具有一个数据指针，该数据指针是4个指针的数组。由于在这里我们要处理</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，所以我们只有3个通道，因此只有3个数据集。其他格式可能具有用于alpha通道或其他内容的第四个指针。行大小就是它的样子。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV叠加层</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的</font><font style="vertical-align: inherit;">类似结构</font><font style="vertical-align: inherit;">是像素和高度的变量。 （间距，间距-如果用SDL表示以表示给定数据字符串的宽度。）因此，我们</font><font style="vertical-align: inherit;">在叠加层上</font><font style="vertical-align: inherit;">表示了三个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pict.data数组</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此当我们写入时</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，实际上是我们在叠加层中进行记录，当然，叠加层已经为它专门分配了必要的空间。</font><font style="vertical-align: inherit;">以同样的方式，我们直接从叠加层中获得线径信息。</font><font style="vertical-align: inherit;">我们将转换格式更改为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PIX_FMT_YUV420P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font><font style="vertical-align: inherit;">像以前一样</font><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sws_scale</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图像绘图</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们仍然需要指定SDL，以便它真正显示我们提供给它的数据。</font><font style="vertical-align: inherit;">我们还向该函数传递了一个矩形，该矩形指示影片应该放哪里，应缩放影片的宽度和高度。</font><font style="vertical-align: inherit;">因此，SDL可为我们扩展，这可以帮助您的GPU更快地扩展：</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect rect;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(frameFinished) {
    <span class="hljs-comment">/* ... code ... */</span>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
              pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(bmp);<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们的视频已显示！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们展示SDL的另一个功能：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件系统</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 SDL的配置方式使得当您在SDL应用程序中输入或移动鼠标或向其发送信号时，会生成一个事件。然后，如果程序打算处理用户输入，则检查这些事件。您的程序还可以创建事件以将SDL事件发送到系统。这对于使用SDL进行多线程编程特别有用，我们将在第4课中看到这一点。在我们的程序中，我们将在处理程序包后立即检查事件。目前，我们将处理</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_QUIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事件，</font><b><font style="vertical-align: inherit;">以便</font></b><font style="vertical-align: inherit;">我们可以退出：</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event       event;<font></font>
<font></font>
    av_free_packet(&amp;packet);<font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样我们就活着！我们摆脱了所有旧的垃圾，并准备好进行编译。如果您使用Linux或类似Linux的软件，则使用SDL库进行编译的最佳方法是：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial02 tutorial02.c -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdl-config</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅显示</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gcc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的必要标志，</font><font style="vertical-align: inherit;">以正确启用SDL库。</font><font style="vertical-align: inherit;">您可能需要做其他事情才能在您的系统上进行编译。</font><font style="vertical-align: inherit;">请为任何消防员检查系统的SDL文档。</font><font style="vertical-align: inherit;">编译后，继续运行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
运行此程序会怎样？</font><font style="vertical-align: inherit;">该视频似乎快要疯了！</font><font style="vertical-align: inherit;">实际上，我们只需显示所有视频帧，就可以从电影文件中提取它们一样快。</font><font style="vertical-align: inherit;">我们现在没有代码来确定何时需要显示视频。</font><font style="vertical-align: inherit;">最后（第5课），我们将开始同步视频。</font><font style="vertical-align: inherit;">但是此刻，我们缺少了同样重要的东西：声音！</font></font><a name="sound"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第3课：播放声音</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第2课：显示"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第4课：多线程"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整清单：tutorial03.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial03.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial03 tutorial03.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial03 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
PacketQueue audioq;<font></font>
<font></font>
<span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf, <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>; <span class="hljs-comment">// arbitrary?</span>
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
  AVFormatContext *pFormatCtx = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">int</span>             i, videoStream, audioStream;<font></font>
  AVCodecContext  *pCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *pCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *pCodec = <span class="hljs-literal">NULL</span>;<font></font>
  AVFrame         *pFrame = <span class="hljs-literal">NULL</span>;<font></font>
  AVPacket        packet;<font></font>
  <span class="hljs-keyword">int</span>             frameFinished;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span> = <span class="hljs-title">NULL</span>;</span><font></font>
  <font></font>
  AVCodecContext  *aCodecCtxOrig = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodecContext  *aCodecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec         *aCodec = <span class="hljs-literal">NULL</span>;<font></font>
<font></font>
  SDL_Overlay     *bmp;<font></font>
  SDL_Surface     *screen;<font></font>
  SDL_Rect        rect;<font></font>
  SDL_Event       event;<font></font>
  SDL_AudioSpec   wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, argv[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>);<font></font>
    <font></font>
  <span class="hljs-comment">// Find the first video stream</span>
  videoStream=<span class="hljs-number">-1</span>;<font></font>
  audioStream=<span class="hljs-number">-1</span>;
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
      videoStream=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
      audioStream=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
  <span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
   <font></font>
  aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;<font></font>
  aCodec = avcodec_find_decoder(aCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!aCodec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
  wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
  wanted_spec.format = AUDIO_S16SYS;<font></font>
  wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
  wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
  wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
  wanted_spec.callback = audio_callback;<font></font>
  wanted_spec.userdata = aCodecCtx;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  <span class="hljs-comment">// audio_st = pFormatCtx-&gt;streams[index]</span><font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);<font></font>
<font></font>
  <span class="hljs-comment">// Get a pointer to the codec context for the video stream</span><font></font>
  pCodecCtxOrig=pFormatCtx-&gt;streams[videoStream]-&gt;codec;<font></font>
  <font></font>
  <span class="hljs-comment">// Find the decoder for the video stream</span><font></font>
  pCodec=avcodec_find_decoder(pCodecCtxOrig-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(pCodec==<span class="hljs-literal">NULL</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Codec not found</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Copy context</span><font></font>
  pCodecCtx = avcodec_alloc_context3(pCodec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Open codec</span>
  <span class="hljs-keyword">if</span>(avcodec_open2(pCodecCtx, pCodec, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Could not open codec</span><font></font>
  <font></font>
  <span class="hljs-comment">// Allocate video frame</span><font></font>
  pFrame=av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width,<font></font>
				 pCodecCtx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
<font></font>
  <span class="hljs-comment">// initialize SWS context for software scaling</span><font></font>
  sws_ctx = sws_getContext(pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   pCodecCtx-&gt;pix_fmt,<font></font>
			   pCodecCtx-&gt;width,<font></font>
			   pCodecCtx-&gt;height,<font></font>
			   PIX_FMT_YUV420P,<font></font>
			   SWS_BILINEAR,<font></font>
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span>,
			   <span class="hljs-literal">NULL</span><font></font>
			   );<font></font>
<font></font>
  <span class="hljs-comment">// Read frames and save first five frames to disk</span>
  i=<span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
      <span class="hljs-comment">// Decode video frame</span><font></font>
      avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet);<font></font>
      <font></font>
      <span class="hljs-comment">// Did we get a video frame?</span>
      <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
	SDL_LockYUVOverlay(bmp);<font></font>
<font></font>
	AVPicture pict;<font></font>
	pict.data[<span class="hljs-number">0</span>] = bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
	pict.data[<span class="hljs-number">1</span>] = bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
	pict.data[<span class="hljs-number">2</span>] = bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
<font></font>
	pict.linesize[<span class="hljs-number">0</span>] = bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
	pict.linesize[<span class="hljs-number">1</span>] = bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
	pict.linesize[<span class="hljs-number">2</span>] = bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
<font></font>
	<span class="hljs-comment">// Convert the image into YUV format that SDL uses	</span>
	sws_scale(sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
		  pFrame-&gt;linesize, <span class="hljs-number">0</span>, pCodecCtx-&gt;height,<font></font>
		  pict.data, pict.linesize);<font></font>
	<font></font>
	SDL_UnlockYUVOverlay(bmp);<font></font>
	<font></font>
	rect.x = <span class="hljs-number">0</span>;<font></font>
	rect.y = <span class="hljs-number">0</span>;<font></font>
	rect.w = pCodecCtx-&gt;width;<font></font>
	rect.h = pCodecCtx-&gt;height;<font></font>
	SDL_DisplayYUVOverlay(bmp, &amp;rect);<font></font>
	av_free_packet(&amp;packet);<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
      packet_queue_put(&amp;audioq, &amp;packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(&amp;packet);<font></font>
    }<font></font>
    <span class="hljs-comment">// Free the packet that was allocated by av_read_frame</span><font></font>
    SDL_PollEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Free the YUV frame</span><font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the codecs</span><font></font>
  avcodec_close(pCodecCtxOrig);<font></font>
  avcodec_close(pCodecCtx);<font></font>
  avcodec_close(aCodecCtxOrig);<font></font>
  avcodec_close(aCodecCtx);<font></font>
  <font></font>
  <span class="hljs-comment">// Close the video file</span><font></font>
  avformat_close_input(&amp;pFormatCtx);<font></font>
  <font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音讯</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们希望声音在应用程序中播放。</font><font style="vertical-align: inherit;">SDL还为我们提供了播放声音的方法。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">用于打开音频设备本身。</font><font style="vertical-align: inherit;">它以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构作为参数，该结构</font><font style="vertical-align: inherit;">包含有关我们将要播放的音频的所有信息。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在展示如何配置它之前，我们首先说明计算机通常如何处理音频。</font><font style="vertical-align: inherit;">数字音频包含大量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">样本</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每个代表声波的特定含义。声音以特定的采样率记录，该采样率仅指示每个样本的播放速度，并通过每秒的样本数进行测量。大概的采样频率是</font><font style="vertical-align: inherit;">每秒</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">22,050</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">44,100个</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样，分别是用于无线电和CD的速度。此外，大多数音频可以有多个声道用于立体声或环绕声，因此，例如，如果样本为立体声，则样本一次将为两个。当我们从电影文件中获取数据时，我们不知道将获得多少样本，但是FFmpeg不会产生残缺的样本-这也意味着它也不会分离立体声样本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在SDL中播放音频的方法如下。</font><font style="vertical-align: inherit;">声音参数已配置：采样频率，通道数等。</font><font style="vertical-align: inherit;">并同时设置回调函数和用户数据。</font><font style="vertical-align: inherit;">当我们开始播放声音时，SDL将不断调用此回调函数，并要求它用一定数量的字节填充音频缓冲区。</font><font style="vertical-align: inherit;">将这些信息放入</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AudioSpec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构之后</font><font style="vertical-align: inherit;">，我们调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（），它将打开音频设备并向</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回另一个</font><b><font style="vertical-align: inherit;">AudioSpec</font></b><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这些是我们将实际使用的特征-无法保证我们会完全得到我们所要求的！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音讯设定</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
暂时请记住，因为我们还没有有关音频流的任何信息！</font><font style="vertical-align: inherit;">让我们回到代码中找到视频流并找出音频流是哪个位置的地方：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Find the first video stream</span>
videoStream=<span class="hljs-number">-1</span>;<font></font>
audioStream=<span class="hljs-number">-1</span>;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) {
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO<font></font>
     &amp;&amp;<font></font>
       videoStream &lt; <span class="hljs-number">0</span>) {<font></font>
    videoStream=i;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
     audioStream &lt; <span class="hljs-number">0</span>) {<font></font>
    audioStream=i;<font></font>
  }<font></font>
}<font></font>
<span class="hljs-keyword">if</span>(videoStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Didn't find a video stream</span>
<span class="hljs-keyword">if</span>(audioStream==<span class="hljs-number">-1</span>)
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们可以</font><font style="vertical-align: inherit;">从流中</font><font style="vertical-align: inherit;">从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得所需的所有信息</font><font style="vertical-align: inherit;">，就像我们对视频流所做的那样：</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodecContext *aCodecCtxOrig;<font></font>
AVCodecContext *aCodecCtx;<font></font>
<font></font>
aCodecCtxOrig=pFormatCtx-&gt;streams[audioStream]-&gt;codec;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您还记得的话，在上一课中，我们仍然必须打开音频编解码器本身。</font><font style="vertical-align: inherit;">这很简单：</font></font><br>
<br>
<pre><code class="cpp hljs">AVCodec         *aCodec;<font></font>
<font></font>
aCodec = avcodec_find_decoder(aCodecCtx-&gt;codec_id);<font></font>
<span class="hljs-keyword">if</span>(!aCodec) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}<font></font>
<span class="hljs-comment">// Copy context</span><font></font>
aCodecCtx = avcodec_alloc_context3(aCodec);<font></font>
<span class="hljs-keyword">if</span>(avcodec_copy_context(aCodecCtx, aCodecCtxOrig) != <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
}<font></font>
<span class="hljs-comment">/* set up SDL Audio here */</span><font></font>
<font></font>
avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在编解码器的上下文中包含配置音频所需的所有信息：</font></font><br>
<br>
<pre><code class="cpp hljs">wanted_spec.freq = aCodecCtx-&gt;sample_rate;<font></font>
wanted_spec.format = AUDIO_S16SYS;<font></font>
wanted_spec.channels = aCodecCtx-&gt;channels;<font></font>
wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
wanted_spec.callback = audio_callback;<font></font>
wanted_spec.userdata = aCodecCtx;<font></font>
<font></font>
<span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
  <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们来看一下每个项目：</font></font><br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（频率）：采样率，如前所述。</font></font></li>
<li><b>format</b> ():  SDL ,      . «<b>S</b>»  «<b>S16SYS</b>»  «», <b>16</b> ,      16 ,  «<b>SYS</b>» ,       ,    .  ,   <b>avcodec_decode_audio2</b>   .</li>
<li><b>channels</b> ():  .</li>
<li><b>silence</b> ():  ,  .   0.</li>
<li><b>samples</b> ():    ,    ,  SDL  ,     .    -  512  8192; FFplay,  ,  1024.</li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（callback）：这里我们传递真实的回调函数。</font><font style="vertical-align: inherit;">稍后我们将详细讨论回调函数。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：SDL将为我们的回调提供一个空指针，指向我们想要的任何用户数据。</font><font style="vertical-align: inherit;">我们想让他知道我们的编解码器环境；</font><font style="vertical-align: inherit;">稍微降低一点就清楚了。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_OpenAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">打开音频</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queue列</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是必要的！现在，我们准备从流中提取音频信息。但是如何处理此信息？我们将不断从电影文件中接收数据包，但是与此同时，SDL将调用回调函数！解决方案将是创建某种全局结构，我们可以在其中插入音频数据包，以便我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以接收音频数据！因此，这是我们将创建数据包队列的工作。 FFmpeg甚至有一个结构可以帮助解决这个问题：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它只是软件包的链表。这是我们的队列结构：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们必须指出</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_packets</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的大小不同-大小是指我们从</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet-&gt; size</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得的字节的</font><nobr><font style="vertical-align: inherit;">大小</font></nobr><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">注意，我们有一个互斥锁和一个条件变量。</font><font style="vertical-align: inherit;">这是因为SDL将音频处理作为单独的流执行。</font><font style="vertical-align: inherit;">如果我们没有适当地阻塞队列，那么我们确实会破坏我们的数据。</font><font style="vertical-align: inherit;">让我们看看如何实现队列。</font><font style="vertical-align: inherit;">每个自重的程序员都应该知道如何创建队列，但是我们还将展示如何执行队列，以便您更轻松地学习SDL函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们创建一个函数来初始化队列：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后创建一个函数以将对象放入我们的队列中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_LockMutex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）阻止队列中的互斥锁，以便我们可以添加一些东西，然后</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><font style="vertical-align: inherit;">）通过条件变量</font><font style="vertical-align: inherit;">将信号发送到我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">（如果期望），以告诉它有数据并且可以继续进行进一步操作解锁互斥锁。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是相应的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。请注意，</font><font style="vertical-align: inherit;">如果我们告诉</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">如何执行此操作，</font><b><font style="vertical-align: inherit;">它将</font></b><font style="vertical-align: inherit;">创建该功能块（即暂停直到获取数据）：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> quit = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span> </span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们将函数包装在一个永恒的周期中，因此，如果我们要阻塞它，肯定会得到一些数据。</font><font style="vertical-align: inherit;">我们避免使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数永远循环</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">本质上，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所做的</font><font style="vertical-align: inherit;">只是等待来自</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondSignal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）（或</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondBroadcast</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（））的信号，然后继续。</font><font style="vertical-align: inherit;">但是，好像我们将其捕获在互斥锁中一样-如果我们持有锁，则</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将无法排队任何东西！</font><font style="vertical-align: inherit;">但是，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CondWait</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）对我们的作用还在于取消阻止提供给它的互斥锁，然后在收到信号后立即再次尝试将其锁定。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于每个消防员</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您还将看到</font><font style="vertical-align: inherit;">我们检查</font><font style="vertical-align: inherit;">了一个全局</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">退出</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量</font><font style="vertical-align: inherit;">，以确保未在程序中设置输出信号（SDL自动处理</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TERM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信号</font><font style="vertical-align: inherit;">等）。</font><font style="vertical-align: inherit;">否则，线程将永远继续，并且我们将不得不使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kill -9终止</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">程序</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">  SDL_PollEvent(&amp;event);
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
    quit = <span class="hljs-number">1</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将退出标志设置为1。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们提供包裹</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它仅用于配置队列：</font></font><br>
<br>
<pre><code class="cpp hljs">PacketQueue audioq;<font></font>
main() {<font></font>
...<font></font>
  avcodec_open2(aCodecCtx, aCodec, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
  packet_queue_init(&amp;audioq);<font></font>
  SDL_PauseAudio(<span class="hljs-number">0</span>);</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）最终启动音频单元。</font><font style="vertical-align: inherit;">如果不接收数据，它将重现静默状态。</font><font style="vertical-align: inherit;">但这不会立即发生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们已经配置了一个队列，现在我们可以将数据包发送给她了。</font><font style="vertical-align: inherit;">我们进入包装阅读周期：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">while</span>(av_read_frame(pFormatCtx, &amp;packet)&gt;=<span class="hljs-number">0</span>) {
  <span class="hljs-comment">// Is this a packet from the video stream?</span>
  <span class="hljs-keyword">if</span>(packet.stream_index==videoStream) {
    <span class="hljs-comment">// Decode video frame</span><font></font>
    ....<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet.stream_index==audioStream) {<font></font>
    packet_queue_put(&amp;audioq, &amp;packet);<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    av_free_packet(&amp;packet);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，排队后我们不会释放包裹。</font><font style="vertical-align: inherit;">我们稍后将在解密时将其释放。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取包</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们最后使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">从队列中获取数据包。</font><font style="vertical-align: inherit;">回调应如下所示：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span></span></code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们提供SDL的指针，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们将音频数据写入其中的缓冲区，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是此缓冲区的大小。</font><font style="vertical-align: inherit;">这是代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  AVCodecContext *aCodecCtx = (AVCodecContext *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> audio_buf_index = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(audio_buf_index &gt;= audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span><font></font>
      audio_size = audio_decode_frame(aCodecCtx, audio_buf,<font></font>
                                      <span class="hljs-keyword">sizeof</span>(audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(audio_buf, <span class="hljs-number">0</span>, audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_buf_size = audio_size;<font></font>
      }<font></font>
      audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = audio_buf_size - audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)audio_buf + audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    audio_buf_index += len1;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，这是一个简单的循环，它从我们编写的另一个函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">中提取数据</font><font style="vertical-align: inherit;">，将结果保存在中间缓冲区中，尝试将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字节</font><font style="vertical-align: inherit;">写入</font><font style="vertical-align: inherit;">流中，如果我们仍然没有足够的字节</font><font style="vertical-align: inherit;">，则尝试</font><font style="vertical-align: inherit;">接收更多数据，或者将其保存以备后用，如果我们还有东西。</font><font style="vertical-align: inherit;">大小</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最大的音频帧大小的1.5倍的FFmpeg会给我们，这给了我们一个很好的利润率。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最终音频解密</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解码器的内部</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(AVCodecContext *aCodecCtx, <span class="hljs-keyword">uint8_t</span> *audio_buf,
                       <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">static</span> AVPacket pkt;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">uint8_t</span> *audio_pkt_data = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> audio_pkt_size = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">static</span> AVFrame frame;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(aCodecCtx, &amp;frame, &amp;got_frame, &amp;pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      audio_pkt_data += len1;<font></font>
      audio_pkt_size -= len1;<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       aCodecCtx-&gt;channels,<font></font>
					       frame.nb_samples,<font></font>
					       aCodecCtx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt.data)<font></font>
      av_free_packet(&amp;pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;audioq, &amp;pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    audio_pkt_data = pkt.data;<font></font>
    audio_pkt_size = pkt.size;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
整个过程实际上是在函数结尾处开始的，我们在此调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。我们从队列中取出数据包并保存其中的信息。然后，当我们可以使用该程序包时，我们调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_audio4</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（），与它的姐妹函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">非常相似</font><font style="vertical-align: inherit;">，不同的是，在这种情况下，该程序包可以具有多个帧。因此，您可能需要多次调用它才能从数据包中获取所有数据。收到帧后，我们只需将其复制到我们的音频缓冲区中，确保</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小于我们的音频缓冲区。另外，请记住有关投射</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf的信息</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确的类型，因为SDL提供了一个8位的int缓冲区，而FFmpeg提供了一个16位的int缓冲区中的数据。您还应该考虑</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间的区别</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len1</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们使用的包的大小，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是返回的原始数据量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们有一些数据时，我们立即返回以找出是否需要从队列中获取更多数据或已经完成。如果我们仍然需要处理包裹，请坚持下去。如果您已完成软件包，请最终将其释放。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是全部！我们已将音频从主读取循环传输到队列，然后由</font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;">函数读取</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它将这些数据传输到SDL，然后SDL传输到您的声卡。继续编译：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial03 tutorial03.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gip-gip-hooray！</font><font style="vertical-align: inherit;">视频仍以最大速度传输，但是声音已经按预期播放。</font><font style="vertical-align: inherit;">这是为什么？</font><font style="vertical-align: inherit;">是的，因为音频信息具有采样频率-我们以最快的速度输出音频信息，但是音频只是根据其采样频率在此流中播放。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于视频和音频同步，我们几乎已经成熟，但是首先我们需要对该程序进行小的重组。</font><font style="vertical-align: inherit;">使用单独的流对声音进行排队和播放的方法效果很好：它使代码更易于管理和模块化。</font><font style="vertical-align: inherit;">在开始将视频与音频同步之前，我们需要简化代码。</font><font style="vertical-align: inherit;">在下一个系列中，我们将产生控制流！</font></font><a name="threads"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4课：多线程</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第三课：播放声音"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第5课：视频同步"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整列表tutorial04.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial04.c</span>
<span class="hljs-comment">// A pedagogical video player that will stream through every video frame as fast as it can,</span>
<span class="hljs-comment">// and play audio (out of sync).</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial04 tutorial04.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf));
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Now, normally here goes a ton of code
	 about timing, etc. we're just going to
	 guess at a delay for now. You can
	 increase and decrease this value and hard code
	 the timing - but I don't suggest that ;)
	 We'll learn how to do it for real later.
      */</span>
      schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }      <font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总览</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上一次，我们使用SDL音频功能添加了音频支持。</font><font style="vertical-align: inherit;">SDL启动了一个线程，用于在每次需要声音时为我们定义的函数进行回调。</font><font style="vertical-align: inherit;">现在，我们将对视频显示执行相同的操作。</font><font style="vertical-align: inherit;">这使代码更具模块化，并且更易于使用-特别是在您要添加同步的情况下。</font><font style="vertical-align: inherit;">那么我们从哪里开始呢？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我们的主要功能处理很多事情：它通过事件循环，读取数据包并对视频进行解码。我们要做的是将一切都分成几部分：我们将有一个流负责对数据包进行解码；然后将这些数据包添加到队列中，并由相应的音频和视频流读取。我们已经根据需要调整了音频流。使用视频流会有些困难，因为我们必须确保视频是自己显示的。我们将实际的显示代码添加到主循环中。但是，我们不会在每次执行循环时都显示视频，而是将视频显示集成到事件循环中。想法是解码视频，将接收到的帧保存在另一个队列中，然后创建自己的事件（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），然后将其添加到事件系统中，然后在事件循环中看到该事件时，它将显示队列中的下一帧。以下是发生的情况的便捷ASCII插图：</font></font><br>
<br>
<div style="text-align:center;"><img width="335" height="221" src="https://habrastorage.org/webt/nf/ej/gq/nfejgqoqpypds3quordh_x2qgwa.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过事件循环移动视频显示控件的主要原因是，通过</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流，</font><font style="vertical-align: inherit;">我们可以精确控制下一个视频帧何时出现在屏幕上。</font><font style="vertical-align: inherit;">当我们最终在下一课中同步视频时，只需添加代码即可安排下一次视频更新，以便正确的图像在正确的时间显示在屏幕上。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简化代码</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们清除一下代码。我们拥有有关音频和视频编解码器的所有信息，并且我们将添加队列，缓冲区，上帝知道还有什么。所有这些都是针对某个逻辑单元的，即针对电影。因此，我们打算创建一个包含所有这些信息的大型结构，称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;<font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们看到了最终的提示。首先，我们了解基本信息-音频和视频流的格式上下文以及索引，以及相应的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象</font><font style="vertical-align: inherit;">。然后，我们看到其中一些音频缓冲区已移至此结构。它们（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等）旨在获取有关仍然存在（或丢失）的音频的信息。我们为视频添加了另一个队列和一个缓冲区（将用作队列；为此，我们不需要任何多余的队列）用于已解码的帧（保存为叠加层）。</font><b><font style="vertical-align: inherit;">VideoPicture</font></b><font style="vertical-align: inherit;">结构</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是我们自己的创作（来到时将看到其中的内容）。您还可以注意到，我们已经为要创建的两个附加流分配了指针，并为退出标志和影片文件名分配了指针。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，现在我们返回主函数，以了解它如何改变程序。让我们设置我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_mallocz</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）是一个很好的函数，它将为我们分配内存并将其清零。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们初始化显示缓冲区（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font><font style="vertical-align: inherit;">锁</font><font style="vertical-align: inherit;">，因为由于事件循环调用了我们的显示功能-请记住，显示功能将从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检索预解码的帧</font><font style="vertical-align: inherit;">。同时，我们的视频解码器会将信息放入其中-我们不知道谁先到达那里。希望您了解这是经典的比赛条件。因此，我们现在在开始任何主题之前先分发它。让我们还将电影的名称复制到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoState中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
is-&gt;pictq_cond = SDL_CreateCond();</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_strlcpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是FFmpeg的函数，除了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strncpy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之外还执行其他一些边界检查</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的第一个线程</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们运行线程并做一些实际的事情：</font></font><br>
<br>
<pre><code class="cpp hljs">schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
<span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
  av_free(is);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们稍后将定义的函数。她所做的是告诉系统</font><font style="vertical-align: inherit;">在指定的毫秒数后</font><font style="vertical-align: inherit;">产生</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。反过来，当我们在事件队列中看到视频更新功能时，它将调用视频更新功能。但是现在让我们看一下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）就是这样做的-它产生一个具有对原始进程所有内存的完全访问权限的新线程，并启动我们提供的函数执行的线程。此功能还将传输用户定义的数据。在这种情况下，我们调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）并附加我们的</font><b><font style="vertical-align: inherit;">VideoState</font></b><font style="vertical-align: inherit;">结构</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该功能的前半部分没有新内容；它只是打开文件并查找音频和视频流的索引。我们唯一不同的方法是将格式上下文保留在我们的大型结构中。找到流索引后，我们调用定义的另一个函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。这是一种很自然的分离方式，并且由于我们做了很多类似的事情来设置视频和音频编解码器，因此我们重用了一些代码，使其成为一个函数。</font><b><font style="vertical-align: inherit;">Stream_component_open</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
函数</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）是我们发现编解码器，配置声音参数，在重要结构中保存重要信息并启动音频和视频流的地方。在这里，我们还插入其他参数，例如强制使用编解码器而不是自动检测编解码器等。像这样：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx;<font></font>
  AVCodec *codec;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    <span class="hljs-comment">/* ...etc... */</span><font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;pix_fmt, is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这与我们以前的代码几乎相同，只是现在它已被广泛用于音频和视频。请注意</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们已将大型结构配置为音频回调的用户数据</font><font style="vertical-align: inherit;">，而不是</font><b><font style="vertical-align: inherit;">aCodecCtx</font></b><font style="vertical-align: inherit;">。我们还将流本身保存为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_st</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。我们还添加了视频队列并像设置音频队列一样对其进行设置。最重要的是运行视频和音频流。这些位执行此操作：</font></font><br>
<br>
<pre><code class="cpp hljs">    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
<span class="hljs-comment">/* ...... */</span><font></font>
<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
记住</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一课的SDL_PauseAudio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateThread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）的使用方式相同。回到我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此之前，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回到</font><b><font style="vertical-align: inherit;">解码</font></b><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">的第二部分</font><font style="vertical-align: inherit;">。本质上，这只是一个for循环，它读取一个包并将其放入正确的队列中：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>((is-&gt;pFormatCtx-&gt;pb-&gt;error) == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这里没有什么真正的新东西，除了我们现在有一个最大的音频和视频队列大小，并且我们添加了读取错误检查。格式上下文在内部具有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构，</font><font style="vertical-align: inherit;">称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一种基本上存储有关低级文件的所有信息的结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们的for循环之后，我们拥有所有代码来等待程序的其余部分完成或通知它。这段代码具有指导意义，因为它显示了我们如何推送事件-稍后我们需要一些东西来显示视频：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们使用SDL常量</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">获得自定义事件的值</font><font style="vertical-align: inherit;">。必须将第一个用户事件设置为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，下一个</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等等。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_QUIT_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在我们的程序中定义为</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。如果需要，我们还可以传递用户数据，这里我们将指针传递给大型结构。最后，我们调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_PushEvent</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。在事件循环开关中，我们将其放在</font><b><font style="vertical-align: inherit;">SDL_QUIT_EVENT</font></b><font style="vertical-align: inherit;">部分中</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们以前有过的。</font><font style="vertical-align: inherit;">我们将更详细地了解事件的周期；</font><font style="vertical-align: inherit;">现在，请确保在我们</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按FF_QUIT_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时</font><b><font style="vertical-align: inherit;">稍后</font></b><font style="vertical-align: inherit;">再捕获它并切换退出标志。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接收帧：video_thread</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
准备好编解码器后，就可以开始视频流了。</font><font style="vertical-align: inherit;">此流从视频队列读取数据包，将视频解码为帧，然后调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将处理后的帧放入图像队列：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_free(pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到现在为止，大多数功能都应该被理解。</font><font style="vertical-align: inherit;">我们只是在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复制了avcodec_decode_video2函数</font><font style="vertical-align: inherit;">，只需替换一些参数即可。</font><font style="vertical-align: inherit;">例如，我们有一个</font><font style="vertical-align: inherit;">存储在大型结构中</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此可以从那里获取编解码器。</font><font style="vertical-align: inherit;">我们只是继续从视频队列中接收数据包，直到有人告诉我们退出或我们发现错误为止。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">队列框架</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下将已解码的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pFrame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储</font><font style="vertical-align: inherit;">在图像队列</font><font style="vertical-align: inherit;">中的函数</font><font style="vertical-align: inherit;">。由于我们的图像队列是SDL的叠加层（大概是为了使视频显示功能能够执行尽可能少的计算），因此我们需要将帧转换成它。我们存储在图像队列中的数据是我们创建的结构：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;<font></font>
} VideoPicture;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的大型结构包含这些文件的缓冲区，我们可以在其中存储它们。</font><font style="vertical-align: inherit;">但是，我们需要自己分发</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（请注意分配的标志，该标志表明我们是否进行了设置）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用此队列，我们​​有两个指针-写索引和读索引。</font><font style="vertical-align: inherit;">我们还跟踪缓冲区中有多少实际图像。</font><font style="vertical-align: inherit;">要写入队列，我们​​首先等待直到清除缓冲区，以便我们有一个位置来存储</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">然后检查是否在记录索引中设置了覆盖图？</font><font style="vertical-align: inherit;">如果不是，则需要分配内存。</font><font style="vertical-align: inherit;">如果窗口大小已更改，我们还必须重新分配缓冲区！</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_st-&gt;codec-&gt;width,<font></font>
				 is-&gt;video_st-&gt;codec-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
  vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;  <font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您应该认识到函数</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_CreateYUVOverlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们已经将其从主循环移到了本节。该代码现在应该已经相当清楚了。但是，现在有了互斥锁，因为两个线程无法同时将信息写入屏幕！这将不允许我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alloc_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">干扰另一个将显示图片的函数。 （我们将此锁创建为全局变量，并在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）中</font><font style="vertical-align: inherit;">对其进行了初始化</font><font style="vertical-align: inherit;">；请参见代码。）请记住，我们将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构的宽度和高度保持不变</font><font style="vertical-align: inherit;">，因为我们需要确保视频的大小不会由于某些原因而改变。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，我们已经解决了，我们有叠加的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，专用并准备接收图像。让我们回到</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，看看将帧复制到叠加层的代码。这部分您应该熟悉：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* Allocate a frame if we need it... */</span>
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，大多数只是我们之前用来用</font><font style="vertical-align: inherit;">框架</font><font style="vertical-align: inherit;">填充</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">YUV</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">叠加层的代码</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最后一位只是将我们的值“添加”到队列中。</font><font style="vertical-align: inherit;">队列正常工作，将值添加到队列中直到队列满为止，并在队列中至少有内容的情况下进行读取。</font><font style="vertical-align: inherit;">因此，这一切都取决于价值</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - &gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pictq_size</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这就要求我们要阻止它。</font><font style="vertical-align: inherit;">因此，我们在这里做什么：增加记录指针（如有必要，重新开始），然后阻塞队列并增加其大小。</font><font style="vertical-align: inherit;">现在，我们的读者将知道有更多有关该队列的信息，如果这使我们的队列已满，则记录器将对此有所了解。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频展示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是我们的视频主题！现在，我们已经完成了所有的免费线程，除了一个线程之外-还记得我们很久以前如何调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">schedule_refresh</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">吗？看看实际发生了什么：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_AddTimer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）是一个SDL函数，仅在一定的毫秒数后简单地执行对用户定义函数的回调（并在必要时传输一些用户定义的数据）。我们将使用此函数安排视频更新-每次调用它时，它都会设置一个计时器来触发事件，这将导致我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）函数调用一个函数，该函数从队列图片中提取帧并显示她！ ！一句话三个“哪个/哪个/哪个”！因此，我们要做的第一件事-触发此事件。这将我们发送至：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该活动由我们的老朋友发起。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT在此</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定义为</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_USEREVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">应该注意的是，当我们返回0时，SDL将停止计时器，因此回调不会再次执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们再次调用了</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FF_REFRESH_EVENT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们需要在事件循环中对其进行处理：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
  SDL_WaitEvent(&amp;event);<font></font>
  <span class="hljs-keyword">switch</span>(event.type) {
  <span class="hljs-comment">/* ... */</span>
  <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
    video_refresh_timer(event.user.data1);<font></font>
    <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
是什么将我们带到此功能，该功能实际上是从图像队列中提取数据：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <span class="hljs-comment">/* Timing code goes here */</span><font></font>
<font></font>
      schedule_refresh(is, <span class="hljs-number">80</span>);<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目前，此功能非常简单：它在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有空</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时处理队列，设置计时器以显示下一个视频帧，调用</font><b><font style="vertical-align: inherit;">video_display</font></b><font style="vertical-align: inherit;">以在屏幕上实际显示视频，然后增加队列中的计数器，同时减小其大小。您可能会注意到，</font><font style="vertical-align: inherit;">在此功能中，</font><font style="vertical-align: inherit;">我们实际上并没有对</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">做任何事情，</font><font style="vertical-align: inherit;">这就是原因：这是未来。但是过了一会儿。当我们开始将视频与音频同步时，我们将使用它来访问时间信息。在这里，请看一下代码中写有“ Timing code go here”的注释的位置。在本节中，我们将找出应该显示下一帧视频的时间，然后在</font><b><font style="vertical-align: inherit;">schedule_refresh</font></b><font style="vertical-align: inherit;">函数中输入该值。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）。目前，我们只输入一个虚拟值80。从技术上讲，您可以猜测并检查该值并为每部电影重新编译，但是：1）一段时间后它将开始变慢，2）相当愚蠢。虽然，将来我们会回到这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们快完成了。剩下要做的只有一件事：显示视频！这是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_st-&gt;codec-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于屏幕可以是任何大小（我们安装了640x480，并且可以通过多种方式对其进行配置，以便用户调整大小），因此您需要动态确定影片的矩形区域应多大。因此，首先您需要找出我们胶片的长宽比，只是宽度除以高度。一些编解码器的样本长宽比是奇数，即一个像素或样本的宽度/高度。由于我们编解码器上下文中的高度和宽度值是以像素为单位进行测量的，因此实际的宽高比等于宽高比乘以样本的宽高比。某些编解码器的长宽比为0，这意味着每个像素的大小仅为1x1。然后我们以这种方式缩放电影使其尽可能地适合屏幕。位反转</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＆-3</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">简单地将值四舍五入到最接近的四倍数。</font><font style="vertical-align: inherit;">然后将影片居中，并调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SDL_DisplayYUVOverlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）以确保使用屏幕互斥锁来访问它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是全部吗？</font><font style="vertical-align: inherit;">我们完了吗？</font><font style="vertical-align: inherit;">您仍然需要重写音频</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代码</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">才能使用新的</font><b><font style="vertical-align: inherit;"> VideoStruct</font></b><font style="vertical-align: inherit;">，但是这些都是微不足道的更改，可以在示例代码中看到。</font><font style="vertical-align: inherit;">我们需要做的最后一件事是更改FFmpeg中内部退出回调函数的回调：</font></font><br>
<br>
<pre><code class="cpp hljs">VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_interrupt_cb</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
  <span class="hljs-keyword">return</span> (global_video_state &amp;&amp; global_video_state-&gt;quit);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在</font><b><font style="vertical-align: inherit;">main</font></b><font style="vertical-align: inherit;">（）</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中将global_video_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
设置</font><font style="vertical-align: inherit;">为较大的结构</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
就是这样了！</font><font style="vertical-align: inherit;">我们编译：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial04 tutorial04.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并欣赏电影而无需同步！</font><font style="vertical-align: inherit;">下一步，我们将最终创建一个</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真正有效的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频播放器！</font></font><a name="video"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5课：视频同步</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第4课：多线程"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">← </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="到目录"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⇑ </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="第5课：音频同步"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">→</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完整列表tutorial05.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;  
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    <font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我刚刚编写本指南时，我所有的同步代码都来自当时的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ffplay.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">版本</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">今天，它是一个完全不同的程序，FFmpeg库（和ffplay.c本身）中的更新已导致根本性的变化。</font><font style="vertical-align: inherit;">尽管此代码仍然有效，但它已经过时，并且本指南中可以使用许多其他改进。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频如何同步</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到现在为止，我们几乎没有用过的电影播放器​​。</font><font style="vertical-align: inherit;">是的，它播放视频，是的，它播放音频，但这并不是我们所说的电影。</font><font style="vertical-align: inherit;">那我们该怎么办呢？</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS和DTS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，音频和视频流包含有关播放速度和时间的信息。音频流具有采样率，视频流具有每秒的帧数。但是，如果仅通过计数帧数并乘以帧速率来同步视频，则很有可能它与声音不同步。因此，我们将走另一条路。从流分组可以具有所谓的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解码时间</font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">戳记</font></i><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -从</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ecoding </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IME </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夯实</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">显示时间</font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">戳记</font></i><font style="vertical-align: inherit;">（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -从</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resentation </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吨</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IME </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">小号</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">夯实</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。要了解这两种含义，您需要了解电影的存储方式。某些格式（例如MPEG）使用它们称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B帧的</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格式</font><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bed，并且</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是双向的，</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">England。Bidirectional</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。其他两种类型的帧被称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nner</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，和</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手段</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预测的</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redicted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">包含完整图像。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P框</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取决于先前的I帧和P帧，并且与先前的帧不同，或者您也可以命名-增量。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B帧</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与P </font><b><font style="vertical-align: inherit;">帧</font></b><font style="vertical-align: inherit;">相似，但是取决于先前和后续帧中包含的信息！一个帧可能不包含图像本身，而是与其他帧不同的事实-解释了为什么在调用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之后我们可能没有完整的帧</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设我们有一部电影，其中按以下顺序播放4帧：</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IBBP</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。然后，我们需要从最后一个P帧中找出信息，然后才能显示之前两个B帧中的任何一个。因此，可以按照与实际显示顺序不匹配的顺序存储帧：</font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IPBB</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这就是每个帧的解码时间戳和演示时间戳。解码时间戳告诉我们何时需要解码某些内容，演示时间戳告诉我们何时需要显示某些内容。因此，在这种情况下，我们的流可能如下所示：</font></font><br>
<br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 4 2 3 </font></font><br>
&nbsp;&nbsp;&nbsp;<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DTS：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 2 3 4 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">流：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IPBB </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，仅当正在播放的流包含B帧时，PTS和DTS才不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们从</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_read_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">接收到一个包时</font><font style="vertical-align: inherit;">，它包含该包内部信息的PTS和DTS值。但是我们真正需要的是我们新解码的原始帧的PTS，在这种情况下，我们知道何时需要显示它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幸运的是，FFmpeg使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_frame_get_best_effort_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（）</font><font style="vertical-align: inherit;">函数为我们提供了“最佳时间戳” </font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了依次显示帧，最好知道何时显示特定的视频帧。</font><font style="vertical-align: inherit;">但是我们到底是怎么做到的呢？</font><font style="vertical-align: inherit;">这个想法是这样的：在显示框架之后，我们确定何时应该显示下一个框架。</font><font style="vertical-align: inherit;">然后暂停一下，然后我们将在这段时间后更新视频。</font><font style="vertical-align: inherit;">如预期的那样，我们检查系统时钟上下一帧的PTS值，以了解我们的等待时间应该多长时间。</font><font style="vertical-align: inherit;">这种方法有效，但是有两个问题需要解决。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，问题是，下一个PTS何时生效？您会说，您可以简单地将视频添加到当前的PTS中-原则上您是正确的。但是，某些类型的视频将需要重复帧。这意味着您必须重复当前帧一定次数。这可能会导致程序过早显示下一帧。必须考虑到这一点。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个问题是，在我们目前编写的程序中，视频和音频正在欣喜地向前冲，直到他们根本不希望同步。</font><font style="vertical-align: inherit;">如果一切本身都能完美运行，我们就不必担心。</font><font style="vertical-align: inherit;">但是您的计算机和许多视频文件都不是完美的。</font><font style="vertical-align: inherit;">因此，我们有三个选项：将音频与视频同步，将视频与音频同步或将音频和视频与外部时钟（例如与您的计算机）同步。</font><font style="vertical-align: inherit;">现在，我们将视频与音频同步。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编码：接收PTS帧</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们直接写点东西。我们需要在大型结构中添加更多的零件，我们将按照需要的方式进行操作。首先，让我们看一下视频线程。还记得我们在这里收集解码流排队的数据包吗？在这部分代码中，我们需要获取</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_decode_video2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给</font><b><font style="vertical-align: inherit;">我们</font></b><font style="vertical-align: inherit;">的帧的PTS </font><font style="vertical-align: inherit;">。我们谈论的第一种方法是获取最后处理的数据包的DTS，这很简单：</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// Decode video frame</span><font></font>
    len1 = avcodec_decode_video2(is-&gt;video_st-&gt;codec,<font></font>
                                pFrame, &amp;frameFinished, packet);<font></font>
    <span class="hljs-keyword">if</span>(packet-&gt;dts != AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果无法确定其值，则将PTS设置为零。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好吧，那很容易。技术说明：如您所见，我们将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于PTS。这是因为PTS被存储为整数。该值是一个时间戳，与</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timebb中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的时间维度相对应</font><font style="vertical-align: inherit;">。例如，如果流具有每秒24帧，则42中的PTS将指示应在第42帧应使用的位置使用该帧，但前提是我们每1/24秒钟更换一次帧（当然，不一定如此。事实上）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过除以帧频，我们可以将该值转换为秒。</font><b><font style="vertical-align: inherit;">时基</font></b><font style="vertical-align: inherit;">值</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该流将等于1除以帧速率（对于具有固定帧速率的内容），因此，要获得以秒为单位的PTS，请乘以</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进一步编码：PTS的同步和使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，现在我们拥有所有现成的PTS。</font><font style="vertical-align: inherit;">现在，我们将处理这两个同步问题，这些问题将在后面进行讨论。</font><font style="vertical-align: inherit;">我们将定义一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sync_ize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">将更新PTS以与所有内容进行同步。</font><font style="vertical-align: inherit;">最后，此功能还将处理无法获得帧的PTS值的情况。</font><font style="vertical-align: inherit;">同时，我们需要跟踪何时预期下一帧，以便我们可以正确设置刷新率。</font><font style="vertical-align: inherit;">我们可以使用内部</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值来执行此操作，该值</font><font style="vertical-align: inherit;">跟踪视频经过了多少时间。</font><font style="vertical-align: inherit;">我们将此值添加到大型结构中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span>
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">// pts of last decoded frame / predicted pts of next decoded frame</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syncnize_video</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，非常清楚：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如您所见，我们在此功能中考虑了重复的帧。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们获得正确的PTS，并</font><font style="vertical-align: inherit;">通过添加一个新的</font><b><font style="vertical-align: inherit;">pts</font></b><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">使用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将帧排队</font><font style="vertical-align: inherit;">：</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queue_picture中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
唯一发生变化的</font><font style="vertical-align: inherit;">是，我们将此</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值存储</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">我们排队</font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VideoPicture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构</font><font style="vertical-align: inherit;">中。</font><font style="vertical-align: inherit;">因此，我们必须将</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变量添加</font><font style="vertical-align: inherit;">到结构中并添加以下代码行：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  ...<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
  ... stuff ...<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
    ... convert picture ...<font></font>
    vp-&gt;pts = pts;<font></font>
    ... alert <span class="hljs-built_in">queue</span> ...<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将图像与正确的PTS值一起排队，让我们看一下视频更新功能。您可以从上一课中回想起我们只是伪造了它，并安装了80毫秒的更新。好吧，现在我们将要找出应该真正存在的内容。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的策略是通过简单地测量当前</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">点</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和上一个</font><b><font style="vertical-align: inherit;">点</font></b><font style="vertical-align: inherit;">之间的时间来预测下一个PTS的时间</font><font style="vertical-align: inherit;">。同时，我们需要将视频与音频同步。我们要制造一个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频时钟。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：一个内部值，用于跟踪我们正在播放的音频的位置。就像任何mp3播放器上的数字读数一样。由于我们将视频与声音同步，因此视频流使用此值来确定它是太远还是太远。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
稍后我们将返回实施；现在，假设我们具有</font><b><font style="vertical-align: inherit;">get_audio_clock</font></b><font style="vertical-align: inherit;">函数</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这将使我们有时间使用音频时钟。一旦获得此值，如果视频和音频不同步，该怎么办？仅尝试通过搜索或其他方法跳转到正确的软件包是愚蠢的。取而代之的是，我们只需调整为下一次更新计算的值：如果PTS与音频时间相差太远，我们会将估计的延迟加倍。如果PTS比播放时间提前太多，我们将尽快更新。现在，我们已经配置了更新或延迟时间，我们将其与计算机时钟进行比较，而</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer仍在</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">运行</font><font style="vertical-align: inherit;">。此帧计时器总结了我们在电影播放期间的所有估计延迟。换句话说，这个</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frame_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是指示何时显示下一帧的时间。我们只需向帧计时器添加一个新的延迟，将其与计算机时钟上的时间进行比较，然后使用该值来计划下一次更新。这可能会有些混乱，因此请仔细阅读代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio */</span><font></font>
      ref_clock = get_audio_clock(is);<font></font>
      diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
      <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	 FFPlay still doesn't "know if this is the best guess." */</span><font></font>
      sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
      <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	<span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	  delay = <span class="hljs-number">0</span>;<font></font>
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	  delay = <span class="hljs-number">2</span> * delay;<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们进行一些检查：首先，我们确保当前PTS和先前PTS之间的延迟是合理的。如果不需要延迟，则音频和视频此时恰好重合，仅使用最后一个延迟。然后我们确保满足同步阈值，因为永远不会发生完美的同步。 FFplay的阈值使用0.01。我们还确保同步阈值不小于PTS值之间的间隔。最后，将最小更新值设置为10毫秒（实际上，似乎他们应该在此处跳过该帧，但是我们不必为此担心）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们在大型结构中添加了一堆变量，所以不要忘记检查代码。</font><font style="vertical-align: inherit;">同样，不要忘记在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化帧计时器和上一帧的初始延迟</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同步：音频时钟</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在是实现音频时钟的时候了。</font><font style="vertical-align: inherit;">我们可以在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_decode_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数中更新时间</font><font style="vertical-align: inherit;">，在其中解码音频。</font><font style="vertical-align: inherit;">现在请记住，并非每次调用此函数时都总是处理新的包，因此需要在两个区域中更新时钟。</font><font style="vertical-align: inherit;">首先是获得新软件包的位置：只需将声音时钟安装在PTS软件包上即可。</font><font style="vertical-align: inherit;">然后，如果数据包有几个帧，我们可以通过计算采样数并将它们乘以每秒给定的采样频率来节省音频播放时间。</font><font style="vertical-align: inherit;">所以，当我们有包时：</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并且，一旦我们处理了包裹，</font></font><br>
<br>
<pre><code class="cpp hljs">      <span class="hljs-comment">/* Keep audio_clock up-to-date */</span><font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一些细微的差别：功能模板已更改，现在包括</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此请确保对其进行更改。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是我们用来告诉</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_callback</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频数据包</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的指针</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">下次将使用它来同步音频和视频。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们终于可以实现我们的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">考虑一下，</font><font style="vertical-align: inherit;">这并不像获取值</font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_clock</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">那样简单</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">请注意，每次处理时我们都会设置PTS音频，但是如果您查看</font><b><font style="vertical-align: inherit;">audio_callback</font></b><font style="vertical-align: inherit;">函数，</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将所有数据从音频数据包移到输出缓冲区将需要一些时间。</font><font style="vertical-align: inherit;">这意味着我们音频时钟中的值可能会过高。</font><font style="vertical-align: inherit;">因此，我们需要检查必须写多少。</font><font style="vertical-align: inherit;">这是完整的代码：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_st-&gt;codec-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您现在应该了解为什么此功能有效；）就</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这样！</font><font style="vertical-align: inherit;">我们编译：</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial05 tutorial05.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它发生了！</font><font style="vertical-align: inherit;">您可以在自制播放器上观看电影。</font><font style="vertical-align: inherit;">在下一课中，我们将研究音频同步，然后学习如何搜索。</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg和SDL指南或如何编写少于1000行的视频播放器-第2部分</font></font></a></h3><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">爱迪生博客上的翻译：</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/fr/yz/q7/fryzq72v0ik0irt2q4orchflxvs.jpeg"></a></td>
<td align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img width="360" height="180" src="https://habrastorage.org/webt/jv/3k/-f/jv3k-f5vi9drztohsh-e0t-puru.jpeg"></a></td>
</tr>
<tr>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
收入超过十亿美元的</font><font style="vertical-align: inherit;">前50大游戏特许经营权</font></font></a></th>
<th align="center"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Airbnb能否在冠状病毒中存活？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[剧透：是的]</font></font></a></th>
</tr>
</tbody></table></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN500386/index.html">使您现有的业务解决方案适应SwiftUI。第2部分</a></li>
<li><a href="../zh-CN500390/index.html">IT和数字通信领域中语言本地化的实际模型。第1部分</a></li>
<li><a href="../zh-CN500396/index.html">自主访问控制系统的问题-他们没有想到的地方</a></li>
<li><a href="../zh-CN500398/index.html">远程马拉松周3：无效的过程</a></li>
<li><a href="../zh-CN500400/index.html">修剪线程：从Puppet Enterprise迁移到Ansible Tower。第1部分</a></li>
<li><a href="../zh-CN500404/index.html">如何结交Electron和Webix的朋友。第2部分。使用您的视图创建应用程序</a></li>
<li><a href="../zh-CN500406/index.html">互联网第一次瘫痪的故事：繁忙信号的诅咒</a></li>
<li><a href="../zh-CN500408/index.html">贫穷幸福</a></li>
<li><a href="../zh-CN500410/index.html">产生反冲</a></li>
<li><a href="../zh-CN500414/index.html">3D CNC机床或我们之前已经完成的一切</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>