<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👆🏽 😗 🕉️ Mail.ruクラウドソリューションプラットフォームでのフォールトトレラントWebアーキテクチャの実装方法 🍙 🔦 💂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="こんにちは、ハブル！Mail.Ru Cloud Solutions（MCS）のシステム管理チームの責任者であるArtem Karamyshevです。昨年、私たちは新製品を数多く発表してきました。私たちは、APIサービスを簡単にスケーリングし、フォールトトレラントにして、ユーザー負荷の急速な増加に対応...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Mail.ruクラウドソリューションプラットフォームでのフォールトトレラントWebアーキテクチャの実装方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/474180/"><img src="https://habrastorage.org/webt/gd/wp/de/gdwpdevye3ploqkbmd4rwjqkvva.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
こんにちは、ハブル！</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.Ru Cloud Solutions（MCS）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のシステム管理チームの責任者であるArtem Karamyshevです</font><font style="vertical-align: inherit;">。昨年、私たちは新製品を数多く発表してきました。私たちは、APIサービスを簡単にスケーリングし、フォールトトレラントにして、ユーザー負荷の急速な増加に対応できるようにしたいと考えました。私たちのプラットフォームはOpenStackに実装されています。フォールトトレラントシステムを実現するためにクローズしなければならなかったコンポーネントのフォールトトレランスの問題を教えてください。これは、OpenStackで製品を開発する人にとっても興味深いと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プラットフォームの全体的な耐障害性は、そのコンポーネントの安定性で構成されています。したがって、リスクを発見し、それらをクローズしたすべてのレベルを段階的に通過します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このストーリーのビデオバージョンは、元のソースが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ITSummaが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主催するUptime Day 4カンファレンスでのレポートでした</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、Uptime Community YouTubeチャンネル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見ることができます</font><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理アーキテクチャのフォールトトレランス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、MCSクラウドのパブリック部分は2つのTier IIIデータセンターに基づいており、それらの間に独自のダークファイバーがあり、200 Gb /秒のスループットで、異なるルートによって物理層に予約されています。</font><font style="vertical-align: inherit;">Tier IIIレベルは、物理インフラストラクチャの必要なレベルの復元力を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダークファイバーは、物理レベルと論理レベルの両方で予約されています。</font><font style="vertical-align: inherit;">チャネル予約プロセスは繰り返し行われ、問題が発生しました。データセンター間の通信は常に改善されています。</font></font><br>
<br>
<blockquote>,            -   ,      ,     .      -     ,  . ,    .   ,   ,         .</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセンターには、BGPを介してプレフィックスをブロードキャストする通信プロバイダーの拠点があります。</font><font style="vertical-align: inherit;">ネットワークの方向ごとに最適なメトリックが選択されるため、さまざまな顧客が最高の接続品質を提供できます。</font><font style="vertical-align: inherit;">1つのプロバイダーを介した通信が切断された場合、使用可能なプロバイダーを介してルーティングを再構築します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロバイダーに障害が発生した場合、自動的に次のプロバイダーに切り替えます。</font><font style="vertical-align: inherit;">データセンターの1つに障害が発生した場合は、2番目のデータセンターにサービスのミラーコピーがあり、すべての負担がかかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d0/m8/ly/d0m8lykvifmc-gum-h9mbppyn3g.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理インフラストラクチャの復元力</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションレベルのフォールトトレランスに使用するもの</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのサービスは、多くのオープンソースコンポーネントに基づいて構築されています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExaBGP</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、BGPに基づく動的ルーティングプロトコルを使用して多くの機能を実装するサービスです。私たちは積極的にそれを使用して、ユーザーがAPIにアクセスするためのホワイトIPアドレスを発表します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は負荷の高いバランサーであり、OSIモデルのさまざまなレベルでトラフィックを分散するための非常に柔軟なルールを構成できます。データベース、メッセージブローカー、APIサービス、Webサービス、社内プロジェクトなど、すべてのサービスのバランスを取るために使用します。すべてはHAProxyの背後にあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIアプリケーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -Pythonで記述されたWebアプリケーションで、ユーザーがインフラストラクチャ、サービスを制御します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワーカーアプリケーション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（以下、単にワーカー）-OpenStackサービスでは、これはインフラストラクチャデーモンであり、APIコマンドをインフラストラクチャに変換できます。</font><font style="vertical-align: inherit;">たとえば、ディスクの作成はワーカーで行われ、作成リクエストはAPIアプリケーションで行われます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準のOpenStackアプリケーションアーキテクチャ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStack用に開発されたほとんどのサービスは、単一のパラダイムに従っています。サービスは通常、APIとワーカー（バックエンドエグゼキューター）の2つの部分で構成されます。通常、APIは、スタンドアロンプ​​ロセス（デーモン）として、または既製のNginx WebサーバーであるApacheを使用して実行されるPython WSGIアプリケーションです。 APIはユーザー要求を処理し、ワーカーアプリケーションにさらに指示を渡します。送信はメッセージブローカー（通常はRabbitMQ）を使用して行われますが、残りはサポートが不十分です。メッセージがブローカーに到達すると、メッセージはワーカーによって処理され、必要に応じて応答が返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパラダイムは、RabbitMQとデータベースという、孤立した共通の障害ポイントを意味します。ただし、RabbitMQは1つのサービスのフレームワーク内で分離されており、理論的にはサービスごとに個別にすることができます。したがって、MCSではこれらのサービスを可能な限り共有し、プロジェクトごとに個別のデータベース、個別のRabbitMQを作成します。一部の脆弱な箇所で事故が発生した場合、すべてのサービスが中断するのではなく、一部のみであるため、このアプローチは適切です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワーカーアプリケーションの数は無制限なので、APIはパフォーマンスとフォールトトレランスを向上させるために、バランサーの後ろで簡単に水平方向にスケーリングできます。</font></font><br>
<br>
<blockquote>       —       API  worker'.       ,    Redis, Memcache, etcd,    worker'  ,       («, ,   »).   etcd.        ,     .       mariadb,      -.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような古典的なシングルユーザーサービスは、OpenStackで一般に受け入れられている方法で編成されています。</font><font style="vertical-align: inherit;">これはクローズドシステムと見なすことができ、スケーリングとフォールトトレランスの方法は非常に明白です。</font><font style="vertical-align: inherit;">たとえば、APIのフォールトトレランスについては、それらの前にバランサーを配置するだけで十分です。</font><font style="vertical-align: inherit;">労働者のスケーリングは、彼らの数を増やすことによって達成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スキーム全体の弱点は、RabbitMQとMariaDBです。</font><font style="vertical-align: inherit;">それらのアーキテクチャーは別の記事に値しますこの記事では、APIのフォールトトレランスに焦点を当てたいと思います。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/ab/i1/1aabi1ew0ctxnlrcm2j78nbhefk.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Openstackアプリケーションアーキテクチャ </font><font style="vertical-align: inherit;">クラウドプラットフォームのバランスと復元力</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExaBGPによるHAProxyバランサーの復元力の向上</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIをスケーラブル、高速、フォールトトレラントにするために、それらの前にバランサーを設定します。私たちはHAProxyを選びました。私の意見では、それは私たちのタスクに必要なすべての特性を持っています：複数のOSIレベルでのバランス、管理インターフェース、柔軟性とスケーラビリティ、多数のバランス方法、セッションテーブルのサポート。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決する必要がある最初の問題は、バランサー自体のフォールトトレランスでした。バランサーをインストールするだけでも障害点が発生します。バランサーが壊れ、サービスが停止します。これを防ぐために、ExaBGPとともにHAProxyを使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ExaBGPを使用すると、サービスのステータスをチェックするメカニズムを実装できます。このメカニズムを使用してHAProxyの機能をチェックし、問題が発生した場合はBGPからHAProxyサービスを無効にしました。</font></font><br>
<br>
<b> ExaBGP+HAProxy</b><br>
<br>
<ol>
<li>     , ExaBGP  HAProxy. </li>
<li>     loopback-.</li>
<li>             IP-.</li>
<li> IP-     ExaBGP. </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランスは、3つのサーバーすべてから同じIPアドレスをアナウンスすることによって実現されます。ネットワークの観点からは、3つの異なる次の希望から同じアドレスにアクセスできます。ルーターは3つの同一のルートを確認し、独自のメトリック（通常は同じオプションです）に基づいて最も優先度の高いルートを選択し、トラフィックはいずれかのサーバーにのみ送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HAProxyの動作に問題がある場合やサーバーに障害が発生した場合、ExaBGPはルートのアナウンスを停止し、トラフィックはスムーズに別のサーバーに切り替わります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これにより、バランサーのフォールトトレランスを実現しました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ij/c_/cz/ijc_cz1jvhlug0axiwiiqjqpcww.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyバランサー</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
の</font><i><font style="vertical-align: inherit;">フォールトトレランス</font></i><font style="vertical-align: inherit;">スキームは不完全であることが判明しました。HAProxyを予約する方法は学びましたが、サービス内の負荷を分散する方法は学びませんでした。</font><font style="vertical-align: inherit;">したがって、このスキームを少し拡張しました。いくつかの白いIPアドレス間のバランスを取ることに移りました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNSベースの分散とBGP</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HAProxyが未解決のままになる前の負荷分散の問題。それにもかかわらず、私たちが家でしたように、それは非常に簡単に解決することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのサーバーのバランスを取るには、3つのホワイトIPアドレスと古き良きDNSが必要です。これらの各アドレスは、各HAProxyのループバックインターフェイスで定義され、インターネットでアナウンスされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStackはサービスカタログを使用してリソースを管理し、サービスのエンドポイントAPIを設定します。このディレクトリには、ドメイン名-public.infra.mail.ruが規定されています。これは、DNSを介して3つの異なるIPアドレスで解決されます。その結果、DNSを介して3つのアドレス間で負荷分散が行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ホワイトIPアドレスをアナウンスするときは、サーバー選択の優先順位を制御しないため、これまでのところバランスが取れていません。原則として、BGPではメトリックが指定されていないため、IPアドレスの優先順位によって1つのサーバーのみが選択され、他の2つはアイドル状態になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるメトリックを使用してExaBGP経由のルートを提供し始めました。各バランサーは3つすべてのホワイトIPアドレスをアナウンスしますが、そのうちの1つ、このバランサーのメインアドレスは、最小のメトリックでアナウンスされます。そのため、3つのバランサーがすべて動作している間、最初のIPアドレスへの呼び出しは最初のバランサー、2番目から2番目、3番目から3番目の呼び出しに分類されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バランサーの1つが落ちるとどうなりますか？</font><font style="vertical-align: inherit;">基本的にバランサーに障害が発生した場合でも、アドレスは他の2つから引き続き通知され、それらの間のトラフィックが再分配されます。</font><font style="vertical-align: inherit;">したがって、DNSを介して一度に複数のIPアドレスをユーザーに提供します。</font><font style="vertical-align: inherit;">DNSとさまざまなメトリックに従って分散することにより、3つすべてのバランサーで均一な負荷分散が得られます。</font><font style="vertical-align: inherit;">同時に、耐障害性も失われません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ek/xc/3z/ekxc3zsz5oazwdiqziwp_idfk7a.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DNS + BGPに基づくHAProxyバランシング</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExaBGPとHAProxy間の相互作用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、ルートのアナウンスの終了に基づいて、サーバーが残った場合のフォールトトレランスを実装しました。ただし、HAProxyは、サーバー障害以外の理由（管理エラー、サービス障害など）で切断されることもあります。壊れたバランサーを負荷の下から削除する必要があります。これらの場合、別のメカニズムが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、前のスキームを拡張して、ExaBGPとHAProxyの間にハートビートを実装しました。これは、ExaBGPがカスタムスクリプトを使用してアプリケーションのステータスをチェックするときの、ExaBGPとHAProxy間の相互作用のソフトウェア実装です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、ExaBGP構成で、HAProxyのステータスを確認できるヘルスチェッカーを構成する必要があります。</font><font style="vertical-align: inherit;">この例では、HAProxyでヘルスバックエンドを構成し、ExaBGP側から単純なGETリクエストで確認します。</font><font style="vertical-align: inherit;">アナウンスが発生しなくなった場合、HAProxyは機能しない可能性が高く、アナウンスする必要はありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/w0/ac/5c/w0ac5cvqsvjtki2cqzcgtgyk4x4.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyヘルスチェック</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyピア：セッション同期 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に行うことは、セッションを同期することでした。分散バランサーを使用する場合、クライアントセッションに関する情報のストレージを整理することは困難です。しかし、HAProxyは、ピア機能（異なるHAProxyプロセス間でセッションテーブルを転送する機能）により、これを実行できる数少ないバランサーの1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散方法にはさまざまなものがあります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラウンドロビン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの単純な方法</font><font style="vertical-align: inherit;">と、クライアントセッションが記憶されているときの詳細な方法と、以前と同じサーバーに到達するたびです。 2番目のオプションを実装したかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HAProxyはスティックテーブルを使用して、このメカニズムのクライアントセッションを保存します。クライアントのソースIPアドレス、選択したターゲットアドレス（バックエンド）、およびいくつかのサービス情報を保存します。通常、スティックテーブルは、送信元IPと宛先IPのペアを保存するために使用されます。これは、たとえば、RoundRobinバランスモードなど、別のバランサーに切り替えるときにユーザーのセッションコンテキストを送信できないアプリケーションに特に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スティックテーブルが異なるHAProxyプロセス間で移動するように教えられている場合（どのバランシングが実行されるか）、バランサーはスティックテーブルの1つのプールで作業できます。これにより、バランサーの1つが落ちたときにクライアントネットワークをシームレスに切り替えることが可能になり、クライアントセッションでの作業は以前に選択されたのと同じバックエンドで続行されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
適切に動作させるには、セッションの確立元であるバランサーのソースIPアドレスを解決する必要があります。私たちの場合、これはループバックインターフェイスの動的アドレスです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ピアの正しい操作は、特定の条件でのみ達成されます。つまり、TCPタイムアウトが十分に大きいか、スイッチが十分に高速であるため、TCPセッションが中断する時間がありません。ただし、これによりシームレスな切り替えが可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IaaSには、同じテクノロジーに基づいて構築されたサービスがあります。これは、</font><font style="vertical-align: inherit;">Octaviaと呼ばれる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenStackのサービスとしてのロードバランサー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。これは2つのHAProxyプロセスに基づいており、元々はピアサポートが含まれていました。彼らはこのサービスで彼ら自身を証明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図は、3つのHAProxyインスタンス間でのピアテーブルの移動を概略的に示しています。構成が提案されており、これをどのように構成できるかを示しています。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ov/ol/wr/ovolwrmp-gzrvyybotjjagtb-re.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyピア（セッション同期）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
同じスキームを実装する場合、その作業は慎重にテストする必要があります。</font><font style="vertical-align: inherit;">これが100％のケースで同じように機能するという事実ではありません。</font><font style="vertical-align: inherit;">ただし、クライアントのソースIPを覚えておく必要がある場合でも、少なくともスティックテーブルは失われません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じクライアントからの同時リクエスト数を制限する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIを含むパブリックドメインのサービスは、雪崩のリクエストにさらされる可能性があります。それらの理由は、ユーザーエラーから標的型攻撃まで、まったく異なる場合があります。私たちは定期的にIPアドレスでDDoSを行っています。クライアントはスクリプトを間違えることが多く、ミニDDoSになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの方法で、追加の保護を提供する必要があります。明白な解決策は、APIリクエストの数を制限し、悪意のあるリクエストの処理にCPU時間を浪費しないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような制限を実装するために、同じスティックテーブルを使用して、HAProxyに基づいて編成されたレート制限を使用します。制限は非常に簡単に設定され、APIへのリクエスト数によってユーザーを制限できます。このアルゴリズムは、リクエスト元のソースIPを記憶し、1人のユーザーからの同時リクエスト数を制限します。もちろん、各サービスのAPIの負荷の平均プロファイルを計算し、この値の≈10倍の制限を設定しました。私たちはまだ状況を注意深く監視し続けており、私たちは常に脈をとっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際にはどのように見えますか？</font><font style="vertical-align: inherit;">自動スケールAPIを常に使用しているクライアントがいます。</font><font style="vertical-align: inherit;">彼らは、朝の近くに約200〜300の仮想マシンを作成し、夜の近くにそれらを削除します。</font><font style="vertical-align: inherit;">OpenStackの場合、サービス間の相互作用もAPIを介して行われるため、PaaSサービスを備えた仮想マシンを作成し、少なくとも1000のAPIリクエストを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなタスクのスローは、かなり大きな負荷を引き起こします。</font><font style="vertical-align: inherit;">この負荷を見積もり、毎日のピークを収集し、10倍に増やし、これがレート制限となりました。</font><font style="vertical-align: inherit;">私たちは指を脈に合わせています。</font><font style="vertical-align: inherit;">ボット、スキャナーが私たちを見ようとしているのをよく目にします。実行できるCGAスクリプトがあれば、積極的にカットします。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー向けにコードベースを慎重に更新する方法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、コード展開プロセスのレベルでフォールトトレランスを実装します。ロールアウト中にクラッシュが発生しますが、サービスの可用性への影響を最小限に抑えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは常にサービスを更新しており、ユーザーに影響を与えることなくコードベースを更新するプロセスを保証する必要があります。私たちはHAProxy管理の機能とサービスでのグレースフルシャットダウンの実装を使用してこの問題を解決することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、バランサー制御とサービスの「正しい」シャットダウンを提供する必要がありました。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HAProxyの場合、制御は、本質的にはソケットであり、HAProxy構成で定義されているstatsファイルを介して実行されます。</font><font style="vertical-align: inherit;">stdioを介してコマンドを送信できます。</font><font style="vertical-align: inherit;">しかし、私たちの主な構成制御ツールはansibleであるため、HAProxyを管理するための組み込みモジュールがあります。</font><font style="vertical-align: inherit;">積極的に利用しています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどのAPIサービスとエンジンサービスは、優雅なシャットダウンテクノロジーをサポートしています。シャットダウン時に、HTTPリクエストや何らかのユーティリティタスクなど、現在のタスクが完了するまで待機します。</font><font style="vertical-align: inherit;">同じことが労働者にも起こります。</font><font style="vertical-align: inherit;">彼は自分が行うすべてのタスクを知っており、すべてを正常に完了すると終了します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの2つの点のおかげで、私たちの展開の安全なアルゴリズムは次のようになります。</font></font><br>
<br>
<ol>
<li>     (   RPM),   dev-,   stage,    stage-.</li>
<li>         «»:   ,           .</li>
<li>   .   Ansible,      : <br>
 <ul>
<li>   stage-,        .</li>
<li>    .</li>
<li>     HAProxy      .  graceful shutdown  ,       .</li>
<li>   API, worker',  HAProxy,   .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansibleがサービスを開始します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービスごとに、いくつかの事前定義された主要なテストの単体テストを実行する特定の「ペン」を引き出します。</font><font style="vertical-align: inherit;">新しいコードの基本的なチェックが行われます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前のステップでエラーが見つからなかった場合、バックエンドがアクティブ化されます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次のバックエンドに移動します。</font></font></li>
</ul> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのバックエンドを更新した後、機能テストが開始されます。</font><font style="vertical-align: inherit;">それらが十分でない場合、開発者は自分が行った新しい機能を確認します。</font></font></li>
</ol> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この展開では完了です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-b/km/dt/-bkmdt98ituj53jetxiaay4uf4c.jpeg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス更新サイクル</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
このスキームは、1つのルールがなければ機能しません。</font><font style="vertical-align: inherit;">バトルでは新旧両方のバージョンをサポートしています。</font><font style="vertical-align: inherit;">事前に、ソフトウェア開発の段階で、サービスデータベースに変更があったとしても、以前のコードを壊さないことが定められています。</font><font style="vertical-align: inherit;">その結果、コードベースは徐々に更新されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレラントなWEBアーキテクチャについて自分の考えを共有しますが、その重要な点をもう一度指摘しておきます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">物理的なフォールトトレランス。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークのフォールトトレランス（バランサー、BGP）;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用および開発されたソフトウェアのフォールトトレランス。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての安定した稼働時間！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474164/index.html">ジンブラは私たちのすべてです</a></li>
<li><a href="../ja474166/index.html">GiSTのカバーインデックス</a></li>
<li><a href="../ja474170/index.html">デザイン告白-11月15日、モスクワ、DIテレグラフ</a></li>
<li><a href="../ja474172/index.html">クッキーの違法な使用には3万ユーロの罰金</a></li>
<li><a href="../ja474176/index.html">カリーニングラードでのDevFest 2019の初日からの11本のビデオ</a></li>
<li><a href="../ja474184/index.html">Callum Macraeからの挑戦に100％合格</a></li>
<li><a href="../ja474186/index.html">神話の反駁：アルメニアでの実際のIT実践</a></li>
<li><a href="../ja474192/index.html">なぜUXからPMに、次にLead PMに切り替えたのですか、また何が変わったのですか？</a></li>
<li><a href="../ja474194/index.html">コンパスチーム</a></li>
<li><a href="../ja474196/index.html">今日のAI開発における最も重要な10のマイルストーン</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>