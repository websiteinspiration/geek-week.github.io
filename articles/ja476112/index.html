<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😶 🧚🏼 👩‍⚕️ python asyncの開発目標としてのElixir ❣️ 🤟🏽 🐦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本「Python。卓越性の高さへ。」ルチアーノ・ラマーロはある物語を説明しています。 2000年にルチアーノはコースを受講し、ギドファンロッサムは聴衆をのぞきました。このようなイベントが発生すると、誰もが彼に質問をし始めました。 Pythonが他の言語から借用した関数を尋ねると、Guidoは次のよう...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>python asyncの開発目標としてのElixir</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/476112/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本「Python。卓越性の高さへ。」ルチアーノ・ラマーロはある物語を説明しています。 2000年にルチアーノはコースを受講し、ギドファンロッサムは聴衆をのぞきました。このようなイベントが発生すると、誰もが彼に質問をし始めました。 Pythonが他の言語から借用した関数を尋ねると、Guidoは次のように答えました。「Pythonで優れているものはすべて他の言語から盗まれています。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本当にそうです。 Pythonは他のプログラミング言語のコンテキストで長い間使用されており、その環境の概念を吸収しています。asyncioは、Lispラムダ式が登場したおかげで借りられ、Tornadoはlibeventからコピーされました。しかし、もし誰かがアイデアを借りるべきなら、それはアーランのものです。これは30年前に作成され、現在実装されている、または単に概要が説明されているすべてのPythonの概念は、Erlangで長い間動作しています。マルチコア、通信の基礎としてのメッセージ、メソッド呼び出し、ライブプロダクションシステム内のイントロスペクション。これらのアイデアは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何らかの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">形で、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Seastar.ioの</font></a><font style="vertical-align: inherit;">ようなシステムで表現されています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fb/0x/mf/fb0xmfg8afpsrhs7js423v4bvjy.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonが現在競争力を失っているData Scienceを考慮しない場合、ネットワークでの作業、HTTPソケットとWebソケットの処理、データベースでの作業など、他のすべてはすでにErlangで実装されています。</font><font style="vertical-align: inherit;">したがって、Python開発者は、言語がどこに移動するかを理解することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の言語の開発履歴を理解し、進歩がどこに進んでいるかを理解するために、</font><strong><font style="vertical-align: inherit;">Maxim Lapshin</font></strong><font style="vertical-align: inherit;">を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モスクワPython会議++</font></font></a> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erlyvideo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-Erlyvideo.ruプロジェクトの作成者。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カットの下には、このレポートのテキストバージョンがあります。つまり、システムの開発が強制される方向です。これは、単純な線形コードからlibevent以降に移行し続けます。これは一般的であり、ElixirとPythonの違いは何ですか。ソケット、スレッド、データをさまざまなプログラミング言語とプラットフォームで管理する方法に特に注意を払います。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/RAZ0sHpPrZE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erlyvideo.ruには、カメラのアクセス制御がPythonで記述されたビデオ監視システムがあります。これは、この言語の古典的なタスクです。ユーザーとカメラ、彼らが見ることができるビデオがあります。誰かがいくつかのカメラを見ている間、他の人は通常のサイトを見ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonが選ばれた理由は、そのようなサービスを記述するのが便利だからです。フレームワーク、ORM、プログラマーが結局います。開発したソフトウェアをパッケージ化してユーザーに販売します。 Erlyvideo.ruはソフトウェアを販売する会社であり、サービスを提供するだけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonのどのような問題を解決したいですか。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアにこのような問題があるのはなぜですか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Intelが登場する前から、FlussonicをStadiaコンピュータで実行していました。しかし、Pythonにはこれに関する問題があります。なぜサーバーの80コアすべてを使用しないのですか？</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンソケットに悩まされないようにするにはどうすればよいですか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開いているソケットの数を監視することは大きな問題です。</font><font style="vertical-align: inherit;">限界に達したら、閉じて漏れも防いでください。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忘れられたグローバル変数には解決策がありますか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル変数のリークは、JavaやC＃などのガベージコレクション言語にとっては地獄です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">資源を無駄にせずに鉄を使用するには？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーを効率的に使用し、不要なハードウェアに月額数十万ドルを投じないようにするには、40人のJungワーカーと64 GBのRAMを実行せずに済む方法を教えてください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアが必要な理由</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのコアを完全に利用するに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コアよりもはるかに多くのワーカーが必要です。</font><font style="vertical-align: inherit;">たとえば、40個のプロセッサコアの場合、100人のワーカーが必要です。1人のワーカーがデータベースにアクセスし、もう1人は他の何かでビジーです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1人のワーカーが300〜400 MBを消費する可能性があり</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これは、Ruby on Railsではなく、Pythonでまだ書いています。数倍消費する可能性があり、40 GBのRAMは簡単かつ簡単に無駄になります。</font><font style="vertical-align: inherit;">それはそれほど高価ではありませんが、なぜあなたが買うことができないところでメモリを買うのですか？</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアは、共有データをいじり、メモリ消費を減らし</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、多くの独立したプロセスを便利かつ安全に実行</font><strong><font style="vertical-align: inherit;">するのに役立ち</font></strong><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">プログラミングははるかに簡単ですが、メモリの方が高価です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケット管理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webソケットで、バックエンドからカメラのランタイムデータをポーリングします。</font><font style="vertical-align: inherit;">PythonソフトウェアはFlussonicに接続し、カメラのステータスデータをポーリングします。カメラが機能しているかどうか、新しいイベントがあるかどうかを調べます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、クライアントが接続し、Webソケットを介してこのデータをブラウザーに送信します。</font><font style="vertical-align: inherit;">クライアントのデータをリアルタイムで送信したいのです。カメラのオン/オフ、猫が食べて、寝て、ソファーを引き裂き、ボタンを押して猫を追い払ったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、たとえば、ある種の問題が発生しました。データベースが要求に応答せず、すべてのコードが落ち、2つのソケットが開いていました。</font><font style="vertical-align: inherit;">私たちはリロードを開始し、何かをしました、再びこの問題-2つのソケットがありました。</font><font style="vertical-align: inherit;">DBエラーが正しく処理されず、2つのオープン接続がハングしました。</font><font style="vertical-align: inherit;">時間の経過とともに、これによりソケットリークが発生します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">忘れられたグローバル変数</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Webソケット経由で接続されているブラウザーのリストに対してグローバルなdictを作成しました。</font><font style="vertical-align: inherit;">人がサイトにログインし、Webソケットを開きます。</font><font style="vertical-align: inherit;">次に、その識別子を持つWebソケットをある種のグローバル辞書に配置すると、ある種のエラーが発生することがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、彼らはデータを送信するためにdictに接続リンクを記録しました。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外が機能し、リンクの削除を忘れたため、データがハングしました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そのため、しばらくすると、64 GBが不足し始めており、サーバーのメモリを2倍にしたいと考えています。</font><font style="vertical-align: inherit;">とにかくデータが漏洩するため、これは解決策ではありません。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは常に間違いを犯します。私たちは人間であり、すべてを追跡することはできません。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は、予期しないエラーであっても、いくつかのエラーが発生することです。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歴史的な遠足</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メイントピックに近づくために、ストーリーを掘り下げてみましょう。</font><font style="vertical-align: inherit;">今私たちがPython、Go、Erlangについて話していることすべて、他の人々は約30年前にこの道を行きました。</font><font style="vertical-align: inherit;">Pythonの私たちは長い道のりを歩み、何十年も前に旅されてきた困難を埋めます。</font><font style="vertical-align: inherit;">パスは驚くべき方法で繰り返されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、DOSに移りましょう。これが最も近い場所です。</font><font style="vertical-align: inherit;">彼の前にはまったく異なるものがあり、DOSの前にコンピューターを覚えているすべての人が生きているわけではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOSプログラムが（ほとんど）コンピュータを占有していました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえばゲームの実行中は、他に何も実行されていません。</font><font style="vertical-align: inherit;">あなたはインターネットに行きません-それはまだそこにありません、そしてあなたはどこにも行きません。</font><font style="vertical-align: inherit;">悲しかったですが、青春との関わりがあり、記憶は温かいです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">協調マルチタスク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DOSでは本当に苦痛だったので、新しい課題が現れ、コンピュータはより強力になりました。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数十年前、彼らは</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Windows 3.11の前でさえ</font><strong><font style="vertical-align: inherit;">、協調マルチタスクの概念を開発しました</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データはプロセスごとに分割され、各プロセスは個別に実行されます。データは互いに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保護されています。 1つのプロセスの不良コードは、ブラウザーのコードを損なうことはできません（最初のブラウザーは既に表示されています）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の質問は次のとおりです。計算時間は異なるプロセス間でどのように分散されるのですか </font><font style="vertical-align: inherit;">コアが1つしかないということではなく、デュアルプロセッサシステムは珍しいものでした。</font><font style="vertical-align: inherit;">スキームは次のとおりです。たとえば、1つのプロセスがデータをディスクに送信している間に、2番目のプロセスがOSから制御を受け取ります。</font><font style="vertical-align: inherit;">1人目は2人目が自発的に与えるときにコントロールを取得できます。</font><font style="vertical-align: inherit;">私は状況を大幅に簡略化しましたが、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスは何らかの形で自発的にプロセッサから削除することを許可しました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリエンプティブマルチタスク</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
協調型マルチタスクにより、次の問題が発生しました。書き込みが不十分なため、プロセスがハングする可能性があります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサの処理に長い時間がかかる場合、残りはブロックされます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。この場合、コンピューターがクラッシュし、ウィンドウの切り替えなど、コンピューターでは何もできませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題に対応して、プリエンプティブマルチタスクが発明されました。現在、OS自体が厳密に駆動します。プロセスを実行から削除し、データを完全に分離し、プロセスメモリを互いに保護し、すべてのユーザーにある程度の計算時間を与えます。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OSは各プロセスに同じ時間間隔を割り当てます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間制限の問題はまだ解決されていません。</font><font style="vertical-align: inherit;">今日でも、OS開発者は、何が適切で、どの順序で、誰に、どのくらいの時間を管理に費やすかを考え出し続けています。</font><font style="vertical-align: inherit;">今日、私たちはこれらのアイデアの発展を見ています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリーム</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これでは不十分でした。</font><font style="vertical-align: inherit;">プロセスはデータを交換する必要があります。ネットワーク経由ではコストがかかり、どういうわけかまだ複雑です。</font><font style="vertical-align: inherit;">したがって、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フロー</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><strong><font style="vertical-align: inherit;">概念</font></strong><font style="vertical-align: inherit;">が発明されました</font><font style="vertical-align: inherit;">。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドは、共通のメモリを共有する軽量プロセスです。</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームは、すべてが簡単でシンプルで楽しいものになることを期待して作成されました。現在、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチスレッドプログラミングはアンチパターンと見なされてい</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ビジネスロジックがスレッドで記述されている場合、エラーが発生している可能性があるため、このコードはおそらく破棄されます。エラーがないと思われる場合は、まだエラーを発見していないだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッドプログラミングは非常に複雑なものです。スレッドに書き込む機能に本当に専念し、実際に機能している人はほとんどいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアコンピュータ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が登場しました</font><font style="vertical-align: inherit;">。彼らは恐ろしいものを持ってきました。データへのまったく異なるアプローチが取られ、データの局所性に関する疑問が生じました。次に、どのカーネルからどのデータにアクセスするかを理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスタは実際にはコンピュータの内部にあるため、1つのコアでデータをここに配置し、もう1つのコアでデータを配置する必要があります。</font><font style="vertical-align: inherit;">最近のコンピューターの内部では、メモリの一部が1つのコアにはんだ付けされ、他のコアが別のコアにはんだ付けされている場合、クラスターがあります。</font><font style="vertical-align: inherit;">これらのデータ間の通過時間は、桁違いに変化する可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonの例</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「バイヤーを支援するサービス」の簡単な例を考えてみましょう。</font><font style="vertical-align: inherit;">彼はいくつかのプラットフォームで商品の最高の価格を選択します。商品の名前を入力し、最低価格の取引フロアを探します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは古いDjango、Python 2のコードです。今日はあまり人気がなく、プロジェクトを開始する人はほとんどいません。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-meta">@api_view(['GET'])</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">best_price</span>(<span class="hljs-params">request</span>):</span>  
    name = request.GET[<span class="hljs-string">'name'</span>]  <font></font>
    price1 = http_fetch_price(<span class="hljs-string">'market.yandex.ru'</span>, name)  <font></font>
    price2 = http_fetch_price(<span class="hljs-string">'ebay.com'</span>, name)  <font></font>
    price3 = http_fetch_price(<span class="hljs-string">'taobao.com'</span>, name)  
    <span class="hljs-keyword">return</span> Response(min([price1,price2,price3]))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストが到着し、1つのバックエンドに移動してから、別のバックエンドに移動します。と呼ばれる場所では</font></font><code>http_fetch_price</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スレッドがブロックされます。この時点で、労働者全員がYandex.Market、次にeBay、そして淘宝網のタイムアウトの前に、そして最後に回答を出します。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この間ずっと、労働者全員が立ってい</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のバックエンドを同時にポーリングすることは非常に困難です。これは悪い状況です。メモリが消費され、多数のワーカーを起動してサービス全体を監視する必要があります。そのようなリクエストの頻度を確認する必要があります。それでもワーカーを実行する必要があるのですか、それとも余分なリクエストがあるのですか。これらは私が話した問題そのものです。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のバックエンドに順番に問い合わせる必要があります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pythonでは何が見えますか？</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクごとに1つのプロセス、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonではまだマルチコアはありません。状況は明らかです。このクラスの言語で</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、パフォーマンスが低下</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するため、安全でシンプルなマルチコアを作成することは困難</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
異なるストリームからdictにアクセスする場合、データへのアクセスは次のように記述できます。メモリ内の2つのPythonインスタンスを接着して、データを破壊する-単に破壊するだけです。たとえば、dictに移動して何も壊さないようにするには、mutexをその前に置く必要があります。各dictの前にミューテックスがある場合、システムは約1000倍遅くなります-それは単に不便です。マルチコアにドラッグするのは難しいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々は持っている</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行のスレッドを1つだけ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロセスだけで拡張することが可能です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">実際、私たちはプロセス内でDOSを再発明しました-2010年のスクリプト言語です。</font><font style="vertical-align: inherit;">プロセスの内部にはDOSに似たものがあります。何かを実行している間、他のすべてのプロセスは機能しません。</font><font style="vertical-align: inherit;">誰もが巨額のコスト超過と遅い応答を好んでいませんでした。</font><b><font style="vertical-align: inherit;">ソケットリアクタ</font></b></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
は、少し前にPythonに登場しました</font><font style="vertical-align: inherit;">が、コンセプト自体はずっと前に生まれました。</font><font style="vertical-align: inherit;">これで、一度に複数のソケットの準備ができることが期待できます。</font><font style="vertical-align: inherit;">
最初、reactorはnginxのようなサーバーで需要がありました。</font><font style="vertical-align: inherit;">この技術の正しい使い方も含めて人気を博しています。</font><font style="vertical-align: inherit;">次に、その概念はPythonやRubyなどのスクリプト言語にクロールされました。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reactorの考え方は、イベント指向プログラミングに移行したということです。</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント指向プログラミング</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの実行コンテキストが要求を生成します。</font><font style="vertical-align: inherit;">回答を待っている間、別のコンテキストが実行されています。</font><font style="vertical-align: inherit;">注目に値するのは、DOSからWindows 3.11への移行とほぼ同じ進化の段階をたどったことです。</font><font style="vertical-align: inherit;">これを20年前に行ったのは人だけで、PythonとRubyでは10年前に登場しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ツイスト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、イベント駆動型ネットワークフレームワークです。</font><font style="vertical-align: inherit;">2002年に登場し、Pythonで書かれています。</font><font style="vertical-align: inherit;">上記の例を取り、Twistedで書き直しました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_GET</span>(<span class="hljs-params">self, request</span>):</span>  
    price1 = deferred_fetch_price(<span class="hljs-string">'market.yandex.ru'</span>, name)  <font></font>
    price2 = deferred_fetch_price(<span class="hljs-string">'ebay.com'</span>, name)  <font></font>
    price3 = deferred_fetch_price(<span class="hljs-string">'taobao.com'</span>, name)  <font></font>
    dl = defer.DeferredList([price1,price2,price3])    <font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reply</span>(<span class="hljs-params">prices</span>):</span>    
        request.write(<span class="hljs-string">'%d'</span>.format(min(prices)))    <font></font>
        request.finish()  <font></font>
    dl.addCallback(reply)  <font></font>
    <span class="hljs-keyword">return</span> server.NOT_DONE_YET</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーや不正確な点がある可能性があり、悪名高いエラー処理では不十分です。</font><font style="vertical-align: inherit;">しかし、おおよその方式は次のとおりです。私たちは要求を出しませんが、時間があるときに、後でこの要求に行くように頼みます。</font><font style="vertical-align: inherit;">それに</font></font><code>defer.DeferredList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合わせて、いくつかのクエリからの応答をまとめます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、コードは2つの部分で構成されています。</font><font style="vertical-align: inherit;">最初の部分では、要求の前に何が起こったのか、2番目の部分では、その後に何が起こったのか。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント指向プログラミングの全歴史は、「要求前」と「要求後」の線形コードを壊すという苦痛に満ちています。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの断片が混在しているため、これは苦痛です。最後の行は元のリクエストでまだ実行され、関数は</font></font><code>reply</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">後で呼び出されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形コードを壊したからといって、簡単に覚えておくのは簡単ではありませんが、それを行わなければなりませんでした。</font><font style="vertical-align: inherit;">詳細には触れません</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、DjangoからTwistedに書き直されたコードは、</font><strong><font style="vertical-align: inherit;">完全に信じられないほどの疑似アクセラレーションを生成し</font></strong><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ねじれたアイデア</font></font></h3><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケットの準備ができると、オブジェクトをアクティブ化できます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストから必要なデータを収集するオブジェクトを取得し、それらのアクティブ化をソケットにバインドします。ソケットの可用性は現在、システム全体の最も重要な制御の1つです。オブジェクトがコンテキストになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし同時に、言語は、例外が存在する実行のコンテキストの概念そのものを依然として分離しています。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行コンテキストはオブジェクトとは別に存在し、オブジェクトと疎結合しています</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで問題は、オブジェクト内のデータを収集しようとしているという事実で発生します。それらなしでは方法はありませんが、言語はそれをサポートしていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはすべて、古典的なコールバック地獄につながります。たとえば、彼らはNode.jsを気に入っています。最近まで、他に方法はまったくありませんでしたが、それでもPythonに登場しました。問題は</font><strong><font style="vertical-align: inherit;">、外部IOのポイントでコードブレーク</font></strong><font style="vertical-align: inherit;">があることです。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックにつながります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの質問があります。</font><font style="vertical-align: inherit;">コードのギャップの端を「接着」することは可能ですか？</font><font style="vertical-align: inherit;">通常の人間のコードに戻ることは可能ですか？</font><font style="vertical-align: inherit;">論理オブジェクトが2つのソケットで動作し、そのうちの1つが閉じている場合はどうしますか？</font><font style="vertical-align: inherit;">秒を閉じることを忘れないようにするには？</font><font style="vertical-align: inherit;">どういうわけかすべてのコアを使用することは可能ですか？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期io</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの質問に対する良い答えは、非同期IOです。</font><font style="vertical-align: inherit;">これは一歩前進ですが、簡単ではありません。</font><font style="vertical-align: inherit;">非同期IOは複雑なものであり、その内部には多くの苦痛なニュアンスがあります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">best_price</span>(<span class="hljs-params">request</span>):</span>  
    name = request.GET[<span class="hljs-string">'name'</span>]  <font></font>
    price1 = async_http_fetch_price(<span class="hljs-string">'market.yandex.ru'</span>, name)  <font></font>
    price2 = async_http_fetch_price(<span class="hljs-string">'ebay.com'</span>, name)  <font></font>
    price3 = async_http_fetch_price(<span class="hljs-string">'taobao.com'</span>, name)<font></font>
<font></font>
    prices = <span class="hljs-keyword">await</span> asyncio.wait([price1,price2,price3])  
    <span class="hljs-keyword">return</span> min(prices)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードブレークは構文糖に隠されてい</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。以前のものはすべて取りましたが、このコードではネットワークに行きませんでした。</font></font><code>Callback(reply)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の例で</font><font style="vertical-align: inherit;">削除</font><font style="vertical-align: inherit;">し</font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たコードをハサミで切る場所</font><font style="vertical-align: inherit;">を隠しました</font><font style="vertical-align: inherit;">。これは、結果を処理する呼び出しとコールバックの2つの部分に分かれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">素晴らしい構文上の砂糖</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。複数の期待を1つに結び付ける方法があります。これはクールですが、ニュアンスがあり</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><strong><font style="vertical-align: inherit;">「クラシック」ソケットによってすべてが壊れる可能性があります</font></strong><font style="vertical-align: inherit;">。 Pythonには、同期的にソケットにアクセスし、それ</font></font><code>timer library</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実行して</font><font style="vertical-align: inherit;">すべてを台無しに</font><font style="vertical-align: inherit;">する膨大な数のライブラリがまだあり</font><font style="vertical-align: inherit;">ます。これをデバッグする方法はわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">asyncioはリークとマルチコアを助けません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、良くなったものの、根本的な変更はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に話し合った問題はすべて残っています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソケットで漏れやすい;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グローバル変数にリンクを残しやすい;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常に骨の折れるエラー処理。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアを行うのはまだ難しいです。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何をすべきか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがすべて発展するかどうかはわかりませんが、他の言語とプラットフォームでの実装を示します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分離された実行コンテキスト。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行コンテキストでは、結果が蓄積され、ソケットが保持されます。通常、コールバックとソケットに関するすべてのデータを格納する論理オブジェクトです。 1つの概念：実行のコンテキストを取得し、実行のスレッドでそれらを結合し、それらを互いに完全に分離します。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトのパラダイムシフト。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストを実行のスレッドに接続しましょう。アナログはありますが、これは新鮮なものではありません。誰かがApacheのソースコードを編集してモジュールを書き込もうとした場合、Apacheプールがあることがわかります。 Apacheプール間の</font><strong><font style="vertical-align: inherit;">リンクは許可さ</font></strong><font style="vertical-align: inherit;">れてい</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 1つのApacheプールからのデータ-リクエストに関連付けられたプールはその内部にあり、そこから何も取得できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理論的には可能ですが、そうすると、誰かが叱られたり、パッチを受け入れなかったり、本番環境でのデバッグが長くてつらいものになったりします。その後は、誰もこれを行わず、他の人にそのようなことをさせることはできません。コンテキスト間のデータは、そのように参照することはできません。完全な分離が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクティビティを交換するには？</font><font style="vertical-align: inherit;">必要なのは小さなモナドではありません。小さなモナドは内部で閉じられており、互いに通信しません。</font><font style="vertical-align: inherit;">コミュニケーションをとる必要があります。</font><font style="vertical-align: inherit;">1つのアプローチはメッセージングです。</font><font style="vertical-align: inherit;">これは、Windowsがプロセス間でメッセージを交換するときに使用したパスとほぼ同じです。</font><font style="vertical-align: inherit;">通常のOSでは、別のプロセスのメモリへの参照を与えることはできませんが、UNIXのようにネットワークを介して、またはWindowsのようにメッセージを介して信号を送ることができます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスとコンテキスト内のすべてのリソースは、実行のスレッドになります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちは一緒に接着しました：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外が発生した仮想マシンのランタイムデータ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサ上で実行されているもののような実行のスレッド。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのデータが論理的に収集されるオブジェクト。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おめでとうございます-プログラミング言語の内部でUNIXを発明しました！</font><font style="vertical-align: inherit;">このアイデアは1969年頃に発明されました。</font><font style="vertical-align: inherit;">これまでのところ、まだPythonには含まれていませんが、Pythonはこれに到達する可能性があります。</font><font style="vertical-align: inherit;">そして、おそらく、彼女は来ないでしょう-私は知りません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは何を与えるのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースの自動制御</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。モスクワPython Conf ++ 2019で</font><font style="vertical-align: inherit;">、Goでプログラムを作成してすべてのエラーを処理できる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と述べまし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た。プログラムは手袋のように立ち、数ヶ月働きます。これは事実ですが、すべてのエラーを処理するわけではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは生きている人々であり、常に期限があり、何か有用なことをしたいという欲求があり、今日の535番目のエラーを処理しません。エラー処理が散りばめられたコードは、誰にも温かい気持ちを引き起こすことはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、全員が「ハッピーパス」を書いて、それを本番環境で理解します。正直に言いましょう：何かを処理する必要がある場合のみ、処理を開始します。防御プログラミングは少し異なり、商業的な開発ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーの自動制御がある場合-それは問題ありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。しかし、オペレーティングシステムは50年前にそれを思い付きました。プロセスが停止すると、開いているすべてのものが自動的に閉じます。今日、殺されたプロセスの背後にあるファイルをクリーンアップするコードを書く必要はありません。これは、どのOSでも50年ほど前から存在していませんが、Pythonでは、手で慎重にこれを実行する必要があります。これは奇妙です。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重いコンピューティングを別のコンテキスト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に移すことができ</font><strong><font style="vertical-align: inherit;">ますが</font></strong><font style="vertical-align: inherit;">、すでに別のコアに移行している可能性があります。データを共有したので、ミューテックスは必要なくなりました。別のコンテキストでデータを送信することもできます。たとえば、「どこかで行い、完了して何かを行ったことを知らせます。」</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「async / await」という言葉なしでasyncioを実装する</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、ランタイムからの仮想マシンからの少しの助け。</font><font style="vertical-align: inherit;">これが私たちが話したこと</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です：メッセージに変換して削除</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、仮想マシンレベルで取得</font><font style="vertical-align: inherit;">すること</font><font style="vertical-align: inherit;">もできます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlangプロセス</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erlangは30年前に発明されました。</font><font style="vertical-align: inherit;">あごひげを生やしていないあごひげを生やした男たちはUNIXを見て、すべての概念をプログラミング言語に移しました。</font><font style="vertical-align: inherit;">彼らは今や自分たちで夜に寝て、コンピューターなしで静かに釣りに行くことになると決めました。</font><font style="vertical-align: inherit;">その後、まだラップトップはありませんでしたが、あごひげを生やした人たちはこれを事前に検討する必要があることをすでに知っていました。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erlang（Elixir）-彼ら自身を実行するアクティブなコンテキストを得ました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらにErlangでの私の例。</font><font style="vertical-align: inherit;">エリクサーでは、いくつかのバリエーションはありますが、ほぼ同じように見えます。</font></font><br>
<br>
<pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title">best_price</span><span class="hljs-params">(Name)</span> -&gt;</span>  <font></font>
    Price1 = spawn_price_fetcher('market.yandex.ru', Name),  <font></font>
    Price2 = spawn_price_fetcher('ebay.com', Name),  <font></font>
    Price3 = spawn_price_fetcher('taobao.com', Name),  <font></font>
    lists:min(wait4([Price1,Price2,Price3])).</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはいくつかのフェッチャーを起動します-これらは私たちが待っているいくつかの別々の新しいコンテキストです。</font><font style="vertical-align: inherit;">彼らは待って、データを収集し、結果を最低価格として返しました。</font><font style="vertical-align: inherit;">これらはすべて似</font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ていますが、「非同期/待機」という言葉はありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エリクサーの特徴</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ElixirはErlangのベースにあり、すべての言語概念はElixirに静かに移植されています。その機能は何ですか？</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサ間リンクの禁止。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスとは、仮想マシン内のすでに軽量なプロセスを意味します-コンテキスト。簡素化され、Pythonに移植された場合、Erlangは別のオブジェクト内のデータ参照を許可しません。閉じたボックスとしてオブジェクト全体へのリンクを設定できますが、オブジェクト内のデータを参照することはできません。別のオブジェクト内にあるデータへのポインタを構文的に取得することもできません。オブジェクト自体についてのみ知ることができます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス（オブジェクト）内にミューテックスはありません。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは重要です-個人的には、私が人生でマルチスレッドフライトをデバッグしてプロダクションに移行する歴史と交差することは決してありません。これは誰にも望まない。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスはコアの周りを動き回ることができ、安全です。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javaのように、ある</font></font><code>pointer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場所から別の場所にデータを移動するとき</font><font style="vertical-align: inherit;">に他の人の束をバイパス</font><font style="vertical-align: inherit;">して書き直す</font><font style="vertical-align: inherit;">必要がなくなりました</font><font style="vertical-align: inherit;">。共通のデータや内部リンクはありません。たとえば、ヒップスパースネスの問題はどこから来たのですか？誰かがこのデータを参照しているため。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
圧縮のためにヒープ内のデータを別の場所に転送する場合は、システム全体を調べる必要があります。それは数十ギガバイトを占有し、すべてのポインタを更新することができます-これはクレイジーです。</font><font style="vertical-align: inherit;">すべての通信がメッセージを介して行われるため、</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全なスレッドセーフ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このすべての降伏で、私たちは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混雑したプロセスを取り除きました</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼はそれを簡単で安くした。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コミュニケーションの基礎となるメッセージ。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトの内部、通常の関数呼び出し、メッセージオブジェクト間。ネットワークからのデータの到着はメッセージであり、別のオブジェクトの応答はメッセージであり、他の何かは1つの着信キュー内のメッセージでもあります。 rootになっていないため、UNIXにはありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド呼び出し。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスと呼ぶオブジェクトがあります。プロセスのメソッドはメッセージを通じて呼び出されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドの呼び出しもメッセージを送信しています。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイムアウトで実行できるようになったのは素晴らしいことです。何かの応答が遅い場合は、別のオブジェクトのメソッドを呼び出します。しかし同時に、タイムアウトが70秒のクライアントがあるため、60秒以内に待機する準備ができていると言います。私は彼に「503」と言って行く必要があります-明日来てください、彼らはあなたを待っていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、</font><strong><font style="vertical-align: inherit;">電話へ</font></strong><font style="vertical-align: inherit;">の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返答が遅れることがあります</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オブジェクト内で、メソッドを呼び出す要求を受け入れて、「はい、はい、今すぐあなたを置きます。30分後に戻ってきます。私が答えます。」と言うことができます。</font><font style="vertical-align: inherit;">あなたは話すことはできませんが、静かに脇に置いておきます。</font><font style="vertical-align: inherit;">時々使用します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークを使用するには</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
線形コード、コールバック、またはスタイルで記述できます</font></font><code>asyncio.gather</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">それがどのように見えるかの例。</font></font><br>
<br>
<pre><code class="erlang hljs"><span class="hljs-function"><span class="hljs-title">wait4</span><span class="hljs-params">([ ])</span> -&gt;</span>  <font></font>
    [ ]; <font></font>
<span class="hljs-function"><span class="hljs-title">wait4</span><span class="hljs-params">(List)</span> -&gt;</span>  
    <span class="hljs-keyword">receive</span>   <font></font>
        {reply, Pid, Price} -&gt; [Price] ++ wait4(List -- [Pid])  <font></font>
    <span class="hljs-keyword">after</span>    
        <span class="hljs-number">60000</span> -&gt;     <font></font>
            []  <font></font>
    <span class="hljs-keyword">end</span>.</code></pre><br><font style="vertical-align: inherit;"></font><code>wait4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前の例の</font><font style="vertical-align: inherit;">
関数で</font><font style="vertical-align: inherit;">は、まだ回答を待っている人のリストを繰り返し処理します。</font><font style="vertical-align: inherit;">メソッド</font></font><code>receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">そのプロセスからメッセージを取得した</font><font style="vertical-align: inherit;">場合、</font><font style="vertical-align: inherit;">それをリストに書き込みます。</font><font style="vertical-align: inherit;">リストが終わった場合は、それまでのすべてを返し、リストを蓄積します。</font><font style="vertical-align: inherit;">同時に3つのオブジェクトにデータを駆動するように依頼しました。</font><font style="vertical-align: inherit;">60秒以内にすべてを一緒に管理せず、少なくとも1人がOKを返さなかった場合、空のリストが作成されます。</font><font style="vertical-align: inherit;">ただし、一連のオブジェクト全体に対してすぐにリクエストの一般的なタイムアウトを作成することが重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かが言うかもしれない、「考えてください、libcurlも同じものを持っています。」</font><font style="vertical-align: inherit;">ただし、ここで重要なのは、一方でHTTPトリップだけでなく、DBトリップもあり、クライアントに対する最適な数の計算など、いくつかの計算があることです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラー処理</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エラーがストリームからオブジェクトに渡されましたが、現在は同じ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これで、エラー自体はスレッドではなく、エラーが実行されたオブジェクトにアタッチされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これははるかに論理的です。</font><font style="vertical-align: inherit;">通常、ボードにあらゆる種類の小さな正方形や円を描いて、それらが生き返って結果やお金がもたらされることを期待して、通常はオブジェクトを描画します。これらのオブジェクトが実行されるフローではありません。</font><font style="vertical-align: inherit;">たとえば、配達</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時に別のオブジェクトの死についての</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自動</font><strong><font style="vertical-align: inherit;">メッセージを</font></strong><font style="vertical-align: inherit;">受け取ることができ</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本番環境でのイントロスペクションまたはデバッグ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にエラーがラッシュアワー中に負荷がかかった場合にのみ発生する場合は、本番に移行して借方記入するよりも優れている可能性があります。</font><font style="vertical-align: inherit;">ラッシュアワーでは、次のように言います</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。-さあ、今すぐ再起動します！</font></font></em><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ドアを出て、誰かが再起動します！</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、現在実行されていて、特別に準備されていない生きているシステムの内部に入ることができます。</font><font style="vertical-align: inherit;">これを行うには、プロファイラーで再起動する必要はなく、デバッガーで再構築する必要があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稼働中の本番システムでパフォーマンスを損なうことなく</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、プロセスのリストを確認できます。プロセスの内部、プロセス、廃棄、プロセスのチェックなどです。</font><font style="vertical-align: inherit;">これはすべて箱から出して無料です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボーナス</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードは非常に信頼できます。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、Pythonにはとの脆弱性があり</font></font><code>old vs async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、それでも5年間はそのままです。</font><font style="vertical-align: inherit;">Python 3が実装された速度を考えると、それが速くなることを期待してはいけません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージの読み取りとトレースは、コールバックのデバッグよりも簡単です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">大事です。</font><font style="vertical-align: inherit;">表示できるメッセージを処理するためのコールバックがまだある場合は、どうすればよいでしょうか。</font><font style="vertical-align: inherit;">メッセージがメモリ内のデータの一部であるという事実。</font><font style="vertical-align: inherit;">あなたはそれをあなたの目で見て、何がここに来たかを理解することができます。</font><font style="vertical-align: inherit;">トレーサに追加して、メッセージのリストをテキストファイルで取得できます。</font><font style="vertical-align: inherit;">これはコールバックより便利です。</font><strong><font style="vertical-align: inherit;">ライブ</font></strong><font style="vertical-align: inherit;">プロダクション</font><strong><font style="vertical-align: inherit;">システム内での</font></strong></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴージャスなマルチコア</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メモリ管理、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イントロスペクション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、Erlangにも問題があります。</font><font style="vertical-align: inherit;">別のプロセスまたはオブジェクトのデータを参照できなくなったため</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、最大パフォーマンスが失わ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます。それらを移動する必要がありますが、これは無料ではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス間でデータをコピーするオーバーヘッド。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 80個すべてのコアで実行され、1つのデータ配列を処理するCプログラムを作成できます。これは正しく行われると想定しています。 Erlangではこれを行うことはできません。データを慎重に切り取り、プロセスのパックに分散させ、すべてを追跡する必要があります。この通信には、リソース（プロセッササイクル）がかかります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どれくらい速いですか、遅いですか？</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは10年間Erlangコードを書いています。この10年間生き残った唯一の競争相手はJavaで書かれています。彼の場合、パフォーマンスはほぼ完全に同等です。誰かが私たちが悪い、誰かが悪いと言っています。しかし、JITから始めて、すべての問題を抱えたJavaを持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは数万のソケットにサービスを提供し、それ自体で数十GBのデータを送り出すプログラムを作成しています。突然、この場合、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルゴリズム</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><strong><font style="vertical-align: inherit;">正確性と、本番環境でこれをすべてデバッグする機能が、潜在的なJavaバンよりも重要であることがわかりました</font></strong><font style="vertical-align: inherit;">。何十億ドルも投資されていますが、これはJava JITに魔法のような利点を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、「フィボナッチ数を計算する」など、愚かで無意味なベンチマークを測定したい場合、ここでErlangはおそらくPythonまたは同等のものよりもさらに悪いでしょう。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージ割り当てのオーバーヘッド。</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時には痛いです。</font><font style="vertical-align: inherit;">たとえば、Cにはコードの一部が含まれており、これらの場所ではErlangではまったく機能しませんでした。</font><font style="vertical-align: inherit;">しかし、そのような場所はほとんどなく、不必要であることが判明したものからほとんどすべてを飲みました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
内部的に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Erlangに</font><strong><font style="vertical-align: inherit;">は変数を変更するための構文さえありません</font></strong><font style="vertical-align: inherit;">。自己再帰関数に渡されるデータのみがあります。</font><font style="vertical-align: inherit;">これは、円を描いて回転し、メソッド</font></font><code>receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とを</font><font style="vertical-align: inherit;">作成する関数です</font></font><code>send receive</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これはプロセスです-外部から検査されるオブジェクトの状態のエミュレーション。</font><font style="vertical-align: inherit;">そこにも</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトはありません</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは</font><strong><font style="vertical-align: inherit;">、データを処理する関数にすぎません</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれがPythonプログラマにとってすべてなのか</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発パスを理解することが重要</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">私は単に歴史的な文脈から始めたのではありません。</font><font style="vertical-align: inherit;">私はシステムプログラマーの開発段階を示したかったのですが、あなたとPythonがその開発パスの途中にいることを示しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">により、さらなる発展を理解することができ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">突然、あなたの1人がPythonを変更して、最終的に40年ではなく20年以上前の機能を取得することを決定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視野と代替案の知識</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も役に立ちます。</font><font style="vertical-align: inherit;">例を見て、エリクサーに書き直すことに決めたかもしれませんが、これは追加のボーナスです。</font></font><br>
<br>
<blockquote>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Moscow Python Conf++</a>. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>  ,         6      4   .  ,   ,  )     ) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>  . Call for Papers   13 ,     27 .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja476102/index.html">PHP配列を使用したタイプセーフ</a></li>
<li><a href="../ja476104/index.html">無料のMTProxyやその他の種類の無料のプロキシを使用しないでください...</a></li>
<li><a href="../ja476106/index.html">暗号システムプロトコル：Diffie — Hellman、El-Gamal、MTI / A（0）、STS</a></li>
<li><a href="../ja476108/index.html">可変脳</a></li>
<li><a href="../ja476110/index.html">ITにパーソナルブランドが必要な理由</a></li>
<li><a href="../ja476114/index.html">Pythonがないとどうなりますか？機械学習向けのJuliaと一般</a></li>
<li><a href="../ja476118/index.html">ゲームのインターフェイスデザイン、Dark Souls 3からHavelリングを描く</a></li>
<li><a href="../ja476122/index.html">宇宙を「聞く」：暗黒物質から彗星チュリュモフまで-Gerasimenko</a></li>
<li><a href="../ja476126/index.html">サーバーのパフォーマンスをテストする方法：いくつかのオープンソースベンチマークの選択</a></li>
<li><a href="../ja476128/index.html">jug.msk.ruミーティングでのKotlinとIntelliJ IDEAのプラグインについてIvan OsipovとYuri Artamonov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>