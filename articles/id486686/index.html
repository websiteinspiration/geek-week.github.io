<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💠 ↗️ 😀 Tentang menerapkan perpustakaan pembelajaran yang mendalam di Python 🎛️ ☢️ 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Teknologi pembelajaran yang dalam telah berjalan jauh dalam waktu singkat - mulai dari jaringan saraf sederhana hingga arsitektur yang cukup kompleks....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Tentang menerapkan perpustakaan pembelajaran yang mendalam di Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/486686/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknologi pembelajaran yang dalam telah berjalan jauh dalam waktu singkat - mulai dari jaringan saraf sederhana hingga arsitektur yang cukup kompleks. Untuk mendukung penyebaran cepat teknologi ini, berbagai perpustakaan dan platform pembelajaran yang mendalam telah dikembangkan. Salah satu tujuan utama dari perpustakaan tersebut adalah untuk menyediakan pengembang dengan antarmuka sederhana untuk membuat dan melatih model jaringan saraf. Perpustakaan semacam itu memungkinkan penggunanya untuk lebih memperhatikan tugas-tugas yang diselesaikan, dan bukan pada seluk-beluk implementasi model. Untuk melakukan ini, Anda mungkin perlu menyembunyikan implementasi mekanisme dasar di balik beberapa level abstraksi. Dan ini, pada gilirannya, memperumit pemahaman prinsip-prinsip dasar yang menjadi dasar perpustakaan pembelajaran mendalam.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/bp/yi/sl/bpyislfb1o7e-qh7exvklh1oxuw.jpeg"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel, terjemahan yang kami terbitkan, bertujuan menganalisis fitur perangkat blok bangunan tingkat rendah dari perpustakaan pembelajaran yang mendalam. </font><font style="vertical-align: inherit;">Pertama, kita secara singkat berbicara tentang esensi pembelajaran yang mendalam. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kami untuk memahami persyaratan fungsional untuk masing-masing perangkat lunak. </font><font style="vertical-align: inherit;">Kemudian kita melihat mengembangkan perpustakaan pembelajaran yang dalam tapi sederhana dengan Python menggunakan NumPy. </font><font style="vertical-align: inherit;">Perpustakaan ini mampu memberikan pelatihan ujung ke ujung untuk model jaringan saraf sederhana. </font><font style="vertical-align: inherit;">Sepanjang jalan, kita akan berbicara tentang berbagai komponen kerangka pembelajaran yang mendalam. </font><font style="vertical-align: inherit;">Perpustakaan yang akan kami pertimbangkan cukup kecil, kurang dari 100 baris kode. </font><font style="vertical-align: inherit;">Dan ini berarti cukup mudah untuk mengetahuinya. </font><font style="vertical-align: inherit;">Kode proyek lengkap, yang akan kami tangani, dapat ditemukan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Informasi Umum</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya, perpustakaan pembelajaran yang mendalam (seperti TensorFlow dan PyTorch) terdiri dari komponen yang ditunjukkan pada gambar berikut.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c49/b9f/396/c49b9f39652c0260a9e30ee4e5dea146.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Komponen kerangka kerja pembelajaran dalam</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mari kita menganalisis komponen ini.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Operator</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konsep "operator" dan "lapisan" (layer) biasanya digunakan secara bergantian. </font><font style="vertical-align: inherit;">Ini adalah blok bangunan dasar dari setiap jaringan saraf. </font><font style="vertical-align: inherit;">Operator adalah fungsi vektor yang mengubah data. </font><font style="vertical-align: inherit;">Di antara operator yang sering digunakan, seseorang dapat membedakan seperti lapisan linier dan konvolusi, lapisan sub-sampling (penyatuan), semi-linear (ReLU) dan fungsi aktivasi sigmoid (sigmoid).</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍Produk (pengoptimal)</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengoptimal adalah dasar dari perpustakaan pembelajaran yang mendalam. </font><font style="vertical-align: inherit;">Mereka menggambarkan metode untuk menyesuaikan parameter model menggunakan kriteria tertentu dan mempertimbangkan tujuan optimasi. </font><font style="vertical-align: inherit;">Di antara pengoptimal terkenal, SGD, RMSProp dan Adam dapat dicatat.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Fungsi kerugian</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehilangan fungsi adalah ekspresi matematika analitik dan terdiferensiasi yang digunakan sebagai pengganti untuk tujuan optimasi ketika memecahkan masalah. </font><font style="vertical-align: inherit;">Sebagai contoh, fungsi cross-entropy dan fungsi linear piecewise biasanya digunakan dalam masalah klasifikasi.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Inisialisasi</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inisialisasi menyediakan nilai awal untuk parameter model. </font><font style="vertical-align: inherit;">Nilai-nilai inilah yang dimiliki parameter pada awal pelatihan. </font><font style="vertical-align: inherit;">Inisialisasi memainkan peran penting dalam pelatihan jaringan saraf, karena parameter awal yang tidak berhasil dapat berarti bahwa jaringan akan belajar secara lambat atau mungkin tidak belajar sama sekali. </font><font style="vertical-align: inherit;">Ada banyak cara untuk menginisialisasi bobot jaringan saraf. </font><font style="vertical-align: inherit;">Misalnya - Anda dapat menetapkan nilai acak kecil dari distribusi normal. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikut adalah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> halaman di mana Anda dapat mempelajari tentang berbagai jenis inisialisasi.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">▍ Pembuat peraturan</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Regulator adalah alat yang menghindari pelatihan ulang jaringan dan membantu jaringan mendapatkan kemampuan generalisasi. Anda dapat menangani pelatihan ulang jaringan secara eksplisit atau implisit. Metode eksplisit melibatkan batasan struktural pada bobot. Misalnya, meminimalkan L1-Norm dan L2-Norm, yang, masing-masing, membuat nilai bobot lebih tersebar dan lebih merata. Metode implisit diwakili oleh operator khusus yang melakukan transformasi representasi menengah. Ini dilakukan baik dengan normalisasi eksplisit, misalnya, menggunakan teknik BatchNorm, atau dengan mengubah konektivitas jaringan menggunakan algoritma DropOut dan DropConnect.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Komponen di atas biasanya milik bagian antarmuka perpustakaan. </font><font style="vertical-align: inherit;">Di sini, dengan "bagian antarmuka" yang saya maksud entitas yang berinteraksi dengan pengguna. </font><font style="vertical-align: inherit;">Mereka memberinya alat yang nyaman untuk merancang arsitektur jaringan saraf secara efisien. </font><font style="vertical-align: inherit;">Jika kita berbicara tentang mekanisme internal perpustakaan, mereka dapat memberikan dukungan untuk perhitungan gradien fungsi kerugian secara otomatis, dengan mempertimbangkan berbagai parameter model. </font><font style="vertical-align: inherit;">Teknik ini biasa disebut Automatic Differentiation (AD).</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diferensiasi otomatis</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap pustaka pembelajaran yang dalam memberikan pengguna dengan beberapa kemampuan diferensiasi otomatis. Ini memberinya kesempatan untuk fokus pada deskripsi struktur model (grafik perhitungan) dan mentransfer tugas menghitung gradien ke modul AD. Mari kita ambil contoh yang akan memberi tahu kami cara kerjanya. Misalkan kita ingin menghitung turunan parsial dari fungsi berikut sehubungan dengan variabel input X₁ dan X₂: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y = sin (x₁) + X₁ * X₂ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar berikut, yang saya pinjam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menunjukkan grafik perhitungan dan perhitungan turunan menggunakan aturan rantai.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/605/635/189/605635189c56a2f87927ec1a0c5b6318.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafik komputasi dan perhitungan turunan oleh aturan rantai</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Apa yang Anda lihat di sini adalah sesuatu seperti "mode terbalik" diferensiasi otomatis. </font><font style="vertical-align: inherit;">Algoritme propagasi kesalahan kembali terkenal adalah kasus khusus dari algoritma di atas untuk kasus di mana fungsi yang terletak di atas adalah fungsi kerugian. </font><font style="vertical-align: inherit;">AD mengeksploitasi fakta bahwa setiap fungsi kompleks terdiri dari operasi aritmatika elementer dan fungsi elementer. </font><font style="vertical-align: inherit;">Akibatnya, turunan dapat dihitung dengan menerapkan aturan rantai pada operasi ini.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada bagian sebelumnya, kami memeriksa komponen yang diperlukan untuk membuat perpustakaan pembelajaran yang mendalam yang dirancang untuk membuat dan pelatihan ujung-ke-ujung dari jaringan saraf. Agar tidak menyulitkan contoh, saya meniru pola desain perpustakaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caffe di</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sini </font><font style="vertical-align: inherit;">. Di sini kita mendeklarasikan dua kelas abstrak - </font></font><code>Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Optimizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selain itu, ada kelas </font></font><code>Tensor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang merupakan struktur sederhana yang berisi dua array NumPy multidimensi. Salah satunya dirancang untuk menyimpan nilai parameter, yang lain - untuk menyimpan gradien mereka. Semua parameter di lapisan yang berbeda (operator) akan bertipe </font></font><code>Tensor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sebelum kita melangkah lebih jauh, lihat garis besar umum perpustakaan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d05/98c/068/d0598c068139ecda1f2aacbd9ea5f068.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagram UML Perpustakaan</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pada saat penulisan materi ini, perpustakaan ini berisi implementasi dari lapisan linier, fungsi aktivasi ReLU, lapisan SoftMaxLoss dan pengoptimal SGD. Akibatnya, ternyata perpustakaan dapat digunakan untuk melatih model klasifikasi yang terdiri dari lapisan yang terhubung penuh dan menggunakan fungsi aktivasi nonlinier. Sekarang mari kita lihat beberapa detail tentang kelas abstrak yang kita miliki.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas abstrak</font></font><code>Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan antarmuka untuk operator. Ini kodenya:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span>&nbsp; <span class="hljs-title">Function</span>(<span class="hljs-params">object</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self</span>):</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">raise</span> NotImplementedError<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">self</span>):</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">raise</span> NotImplementedError<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getParams</span>(<span class="hljs-params">self</span>):</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> []</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua operator diimplementasikan melalui pewarisan kelas abstrak </font></font><code>Function</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Setiap operator harus menyediakan implementasi metode </font></font><code>forward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>backward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Operator dapat berisi implementasi metode opsional </font></font><code>getParams()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan parameternya (jika ada). Metode </font></font><code>forward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima data input dan mengembalikan hasil transformasi mereka oleh operator. Selain itu, ia memecahkan masalah internal yang diperlukan untuk menghitung gradien. Metode ini </font></font><code>backward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima turunan parsial dari fungsi kehilangan sehubungan dengan output operator dan mengimplementasikan perhitungan derivatif parsial dari fungsi kehilangan sehubungan dengan data input operator dan parameter (jika ada). Perhatikan metode itu</font></font><code>backward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pada dasarnya, menyediakan perpustakaan kami dengan kemampuan untuk melakukan diferensiasi otomatis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menangani semua ini dengan contoh spesifik, mari kita lihat implementasi fungsi </font></font><code>Linear</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Linear</span>(<span class="hljs-params">Function</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,in_nodes,out_nodes</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.weights = Tensor((in_nodes,out_nodes))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.bias&nbsp; &nbsp; = Tensor((<span class="hljs-number">1</span>,out_nodes))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.type = <span class="hljs-string">'linear'</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self,x</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output = np.dot(x,self.weights.data)+self.bias.data<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.input = x&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> output<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backward</span>(<span class="hljs-params">self,d_y</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.weights.grad += np.dot(self.input.T,d_y)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.bias.grad&nbsp; &nbsp; += np.sum(d_y,axis=<span class="hljs-number">0</span>,keepdims=<span class="hljs-literal">True</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grad_input &nbsp; &nbsp; &nbsp; &nbsp; = np.dot(d_y,self.weights.data.T)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> grad_input<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getParams</span>(<span class="hljs-params">self</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> [self.weights,self.bias]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode </font></font><code>forward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengimplementasikan transformasi tampilan </font></font><code>Y = X*W+b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengembalikan hasilnya. Selain itu, menghemat nilai input </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena diperlukan untuk menghitung turunan parsial dari </font></font><code>dY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi kerugian sehubungan dengan nilai output </font></font><code>Y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam metode ini </font></font><code>backward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Metode </font></font><code>backward()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menerima turunan parsial, dihitung sehubungan dengan nilai input </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan parameter </font></font><code>W</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selain itu, ia mengembalikan turunan parsial yang dihitung sehubungan dengan nilai input </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang akan ditransfer ke lapisan sebelumnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas abstrak </font></font><code>Optimizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyediakan antarmuka untuk pengoptimal:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optimizer</span>(<span class="hljs-params">object</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,parameters</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.parameters = parameters<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self</span>):</span>&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">raise</span> NotImplementedError<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">zeroGrad</span>(<span class="hljs-params">self</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> self.parameters:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.grad = <span class="hljs-number">0.</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua pengoptimal diterapkan dengan mewarisi dari kelas dasar </font></font><code>Optimizer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kelas yang menjelaskan optimasi tertentu harus menyediakan implementasi metode </font></font><code>step()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Metode ini memperbarui parameter model menggunakan turunan parsial yang dihitung dalam kaitannya dengan nilai optimal dari fungsi kerugian. </font><font style="vertical-align: inherit;">Tautan ke berbagai parameter model disediakan dalam fungsi </font></font><code>__init__()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Harap dicatat bahwa fungsi universal untuk mengatur ulang nilai gradien diimplementasikan di kelas dasar itu sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang, untuk lebih memahami semua ini, pertimbangkan contoh khusus - implementasi algoritma stochastic gradient descent (SGD) dengan dukungan untuk menyesuaikan momentum dan mengurangi bobot:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SGD</span>(<span class="hljs-params">Optimizer</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,parameters,lr=<span class="hljs-number">.001</span>,weight_decay=<span class="hljs-number">0.0</span>,momentum = <span class="hljs-number">.9</span></span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super().__init__(parameters)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.lr &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = lr<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.weight_decay = weight_decay<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.momentum &nbsp; &nbsp; = momentum<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.velocity &nbsp; &nbsp; = []<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> parameters:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.velocity.append(np.zeros_like(p.grad))<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">step</span>(<span class="hljs-params">self</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> p,v <span class="hljs-keyword">in</span> zip(self.parameters,self.velocity):<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v = self.momentum*v+p.grad+self.weight_decay*p.data<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.data=p.data-self.lr*v</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi untuk masalah nyata</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami memiliki semua yang kami butuhkan untuk melatih model jaringan saraf (dalam) menggunakan perpustakaan kami. </font><font style="vertical-align: inherit;">Untuk ini kita membutuhkan entitas berikut:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model: grafik perhitungan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data dan nilai target: data untuk pelatihan jaringan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi kerugian: pengganti tujuan pengoptimalan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengoptimal: mekanisme untuk memperbarui parameter model.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode pseudo berikut menjelaskan siklus pengujian yang khas:</font></font><br>
<br>
<pre><code class="python hljs">model <span class="hljs-comment"># </span>
data,target <span class="hljs-comment"># </span>
loss_fn <span class="hljs-comment"># </span>
optim <span class="hljs-comment">#,         </span>
Repeat:<span class="hljs-comment">#   ,    ,     </span>
&nbsp;&nbsp;&nbsp;optim.zeroGrad() <span class="hljs-comment">#    </span>
&nbsp;&nbsp;&nbsp;output = model.forward(data) <span class="hljs-comment">#   </span>
&nbsp;&nbsp;&nbsp;loss &nbsp; = loss_fn(output,target) <span class="hljs-comment"># </span>
&nbsp;&nbsp;&nbsp;grad &nbsp; = loss.backward() <span class="hljs-comment">#      </span>
&nbsp;&nbsp;&nbsp;model.backward(grad) <span class="hljs-comment">#    </span>
&nbsp;&nbsp;&nbsp;optim.step() <span class="hljs-comment">#  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun ini tidak diperlukan dalam perpustakaan pembelajaran yang mendalam, mungkin berguna untuk memasukkan fungsi di atas dalam kelas yang terpisah. </font><font style="vertical-align: inherit;">Ini akan memungkinkan kita untuk tidak mengulangi tindakan yang sama ketika mempelajari model baru (ide ini sesuai dengan filosofi abstraksi kerangka kerja tingkat tinggi seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Untuk mencapai ini, deklarasikan kelas </font></font><code>Model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span>():</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.computation_graph = []<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.parameters&nbsp; &nbsp; &nbsp; &nbsp; = []<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">self,layer</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.computation_graph.append(layer)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.parameters+=layer.getParams()<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__innitializeNetwork</span>(<span class="hljs-params">self</span>):</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> self.computation_graph:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">if</span> f.type==<span class="hljs-string">'linear'</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weights,bias = f.getParams()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weights.data = <span class="hljs-number">.01</span>*np.random.randn(weights.data.shape[<span class="hljs-number">0</span>],weights.data.shape[<span class="hljs-number">1</span>])<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bias.data&nbsp; &nbsp; = <span class="hljs-number">0.</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span>(<span class="hljs-params">self,data,target,batch_size,num_epochs,optimizer,loss_fn</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loss_history = []<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.__innitializeNetwork()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data_gen = DataGenerator(data,target,batch_size)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itr = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(num_epochs):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> X,Y <span class="hljs-keyword">in</span> data_gen:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optimizer.zeroGrad()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> self.computation_graph: X=f.forward(X)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loss = loss_fn.forward(X,Y)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grad = loss_fn.backward()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> self.computation_graph[::<span class="hljs-number">-1</span>]: grad = f.backward(grad)&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loss_history+=[loss]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<span class="hljs-string">"Loss at epoch = {} and iteration = {}: {}"</span>.format(epoch,itr,loss_history[<span class="hljs-number">-1</span>]))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;itr+=<span class="hljs-number">1</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;optimizer.step()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> loss_history<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">predict</span>(<span class="hljs-params">self,data</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;X = data<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> self.computation_graph: X = f.forward(X)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> X</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kelas ini mencakup fungsionalitas berikut:</font></font><br>
<br>
<ul>
<li>  :  <code>add()</code>   ,    .        <code>computation_graph</code>.</li>
<li> : ,   ,       ,    .</li>
<li> :    <code>fit()</code>       .       ,    .</li>
<li>  :  <code>predict()</code>   ,       ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena kelas ini bukan blok bangunan dasar dari sistem pembelajaran yang mendalam, saya mengimplementasikannya dalam modul terpisah </font></font><code>utilities.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Perhatikan bahwa metode ini </font></font><code>fit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan kelas </font></font><code>DataGenerator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang implementasinya dalam modul yang sama. </font><font style="vertical-align: inherit;">Kelas ini hanya pembungkus untuk data pelatihan dan menghasilkan paket mini untuk setiap iterasi pelatihan.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelatihan model</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang perhatikan potongan kode terakhir di mana model jaringan saraf dilatih menggunakan perpustakaan yang dijelaskan di atas. </font><font style="vertical-align: inherit;">Saya akan melatih jaringan multilayer pada data yang disusun secara spiral. </font><font style="vertical-align: inherit;">Saya diminta oleh </font><font style="vertical-align: inherit;">publikasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kode untuk menghasilkan data ini dan untuk memvisualisasikannya dapat ditemukan dalam file </font></font><code>utilities.py</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/895/eb0/856/895eb085662368f9c1d171153a301fb0.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data dengan tiga kelas disusun dalam bentuk spiral.Gambar&nbsp;</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
sebelumnya menunjukkan visualisasi data yang akan kita latih modelnya. </font><font style="vertical-align: inherit;">Data ini dapat dipisahkan secara nonlinier. </font><font style="vertical-align: inherit;">Kita dapat berharap bahwa jaringan dengan lapisan tersembunyi dapat dengan benar menemukan batas keputusan nonlinier. </font><font style="vertical-align: inherit;">Jika Anda mengumpulkan semua yang kami bicarakan, Anda mendapatkan fragmen kode berikut yang memungkinkan Anda untuk melatih model:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> dl_numpy <span class="hljs-keyword">as</span> DL
<span class="hljs-keyword">import</span> utilities<font></font>
<font></font>
batch_size&nbsp; &nbsp; &nbsp; &nbsp; = <span class="hljs-number">20</span>
num_epochs&nbsp; &nbsp; &nbsp; &nbsp; = <span class="hljs-number">200</span>
samples_per_class = <span class="hljs-number">100</span>
num_classes &nbsp; &nbsp; &nbsp; = <span class="hljs-number">3</span>
hidden_units&nbsp; &nbsp; &nbsp; = <span class="hljs-number">100</span><font></font>
data,target &nbsp; &nbsp; &nbsp; = utilities.genSpiralData(samples_per_class,num_classes)<font></font>
model &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = utilities.Model()<font></font>
model.add(DL.Linear(<span class="hljs-number">2</span>,hidden_units))<font></font>
model.add(DL.ReLU())<font></font>
model.add(DL.Linear(hidden_units,num_classes))<font></font>
optim &nbsp; = DL.SGD(model.parameters,lr=<span class="hljs-number">1.0</span>,weight_decay=<span class="hljs-number">0.001</span>,momentum=<span class="hljs-number">.9</span>)<font></font>
loss_fn = DL.SoftmaxWithLoss()<font></font>
model.fit(data,target,batch_size,num_epochs,optim,loss_fn)<font></font>
predicted_labels = np.argmax(model.predict(data),axis=<span class="hljs-number">1</span>)<font></font>
accuracy &nbsp; &nbsp; &nbsp; &nbsp; = np.sum(predicted_labels==target)/len(target)<font></font>
print(<span class="hljs-string">"Model Accuracy = {}"</span>.format(accuracy))<font></font>
utilities.plot2DDataWithDecisionBoundary(data,target,model)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar di bawah ini menunjukkan data yang sama dan batas-batas yang menentukan dari model yang dilatih.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/502/b0b/84f/502b0b84fee2c960c918494e8d63e33a.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data dan batas keputusan model yang dilatih</font></font></font></i><br>
 <br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengingat semakin kompleksnya model pembelajaran yang mendalam, ada kecenderungan untuk meningkatkan kemampuan perpustakaan masing-masing dan untuk meningkatkan jumlah kode yang diperlukan untuk mengimplementasikan kemampuan ini. Tetapi fungsi paling dasar dari perpustakaan tersebut masih dapat diimplementasikan dalam bentuk yang relatif kompak. Meskipun perpustakaan yang kami buat dapat digunakan untuk pelatihan jaringan sederhana end-to-end, masih, dalam banyak hal, masih terbatas. Kami berbicara tentang keterbatasan di bidang kemampuan yang memungkinkan kerangka kerja pembelajaran yang mendalam untuk digunakan di berbagai bidang seperti visi mesin, ucapan dan pengenalan teks. Ini, tentu saja, kemungkinan kerangka kerja seperti itu tidak terbatas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya percaya bahwa setiap orang dapat membayar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyek</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kode yang kami periksa di sini, dan, sebagai latihan, perkenalkan ke dalamnya apa yang ingin mereka lihat di dalamnya. </font><font style="vertical-align: inherit;">Berikut adalah beberapa mekanisme yang dapat Anda coba terapkan sendiri:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operator: konvolusi, subsampling.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pengoptimal: Adam, RMSProp.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regulator: BatchNorm, DropOut.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya berharap materi ini memungkinkan Anda untuk setidaknya melihat dari sudut mata Anda apa yang terjadi di perut perpustakaan untuk pembelajaran yang mendalam. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembaca yang budiman! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perpustakaan pembelajaran mendalam apa yang Anda gunakan?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id486686/">https://habr.com/ru/post/id486686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id486676/index.html">Keniscayaan penetrasi FPGA ke dalam pusat data</a></li>
<li><a href="../id486678/index.html">Kuarsa dalam ASP.NET Core</a></li>
<li><a href="../id486680/index.html">ML, VR & Robot (dan sedikit cloud)</a></li>
<li><a href="../id486682/index.html">Susunan Docker: Sederhanakan Menggunakan Makefile</a></li>
<li><a href="../id486684/index.html">Jawaban saya kepada mereka yang percaya bahwa nilai TDD berlebihan</a></li>
<li><a href="../id486688/index.html">Node.js, Tor, Dalang dan Cheerio: pengikisan web anonim</a></li>
<li><a href="../id486690/index.html">5 tips untuk menulis fungsi panah berkualitas</a></li>
<li><a href="../id486692/index.html">Fitur konsol Chrome yang mungkin belum pernah Anda gunakan</a></li>
<li><a href="../id486694/index.html">Berita dari dunia OpenStreetMap No. 496 (01/14/2020/20/01/2020)</a></li>
<li><a href="../id486702/index.html">Acara digital di Moskow dari 3 hingga 9 Februari</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>