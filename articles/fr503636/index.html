<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßùüèª ‚ôäÔ∏è ü§Ωüèº Quel type de charge sur les serveurs cr√©e des m√©canismes de r√©seau? üåä üò† ‚ò∫Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de l'analyse du fonctionnement du sous-syst√®me r√©seau de serveurs, l'attention est g√©n√©ralement port√©e sur des indicateurs tels que la latence, l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Quel type de charge sur les serveurs cr√©e des m√©canismes de r√©seau?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503636/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lors de l'analyse du fonctionnement du sous-syst√®me r√©seau de serveurs, l'attention est g√©n√©ralement port√©e sur des indicateurs tels que la latence, le d√©bit du syst√®me et le nombre de paquets pouvant √™tre trait√©s par seconde (PPS, Packets Per Second). Ces indicateurs sont utilis√©s pour comprendre sous quelle charge maximale l'ordinateur √† l'√©tude peut fonctionner. Et bien que ces mesures soient importantes et puissent souvent en dire long sur le syst√®me, elles ne fournissent pas d'informations sur l'impact du traitement des paquets r√©seau sur les programmes ex√©cut√©s sur le serveur. </font><font style="vertical-align: inherit;">
Ce mat√©riel vise √† √©tudier la charge cr√©√©e par les m√©canismes de r√©seau sur les serveurs. En particulier, nous parlerons du temps processeur que la solution aux probl√®mes de r√©seau peut ¬´voler¬ª √† divers processus ex√©cut√©s sur les syst√®mes Linux.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/q_/0y/ya/q_0yyareydlakrio4dbunpbt8fu.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traitement des paquets r√©seau sous Linux</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linux traite un nombre important de paquets dans le contexte de tout processus ex√©cut√© par le processeur au moment du traitement de l'IRQ correspondant. </font><font style="vertical-align: inherit;">Le moteur de comptabilit√© syst√®me attribuera les cycles de processeur utilis√©s √† cet effet √† tout processus en cours d'ex√©cution. </font><font style="vertical-align: inherit;">Cela sera fait m√™me si ce processus n'a rien √† voir avec le traitement des paquets r√©seau. </font><font style="vertical-align: inherit;">Par exemple, une √©quipe </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut indiquer qu'un processus semble utiliser plus de 99% des ressources du processeur, mais en fait 60% du temps du processeur sera consacr√© au traitement des paquets. </font><font style="vertical-align: inherit;">Et cela signifie que le processus lui-m√™me, r√©solvant ses propres probl√®mes, n'utilise que 40% des ressources du processeur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gestionnaire entrant</font></font><code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√©n√©ralement effectu√© tr√®s, tr√®s rapidement. Par exemple, en moins de 25 Œºs. (Ces donn√©es ont √©t√© obtenues √† partir de mesures utilisant eBPF. Si vous √™tes int√©ress√© par les d√©tails, regardez </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a> <code>net_rx_action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Le processeur peut traiter jusqu'√† 64 paquets par instance NAPI (NIC ou RPS) avant de reporter la t√¢che √† un autre cycle SoftIRQ. L'un apr√®s l'autre, sans interruption, jusqu'√† 10 cycles SoftIRQ peuvent suivre, ce qui prend environ 2 ms (vous pouvez en savoir plus √† ce sujet en lisant √† propos de </font></font><code>__do_softirq</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Si le vecteur SoftIRQ, apr√®s le nombre maximal de cycles ou le temps √©coul√©, a toujours des probl√®mes non r√©solus, la solution de ces probl√®mes est retard√©e pour l'ex√©cution dans le thread</font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU sp√©cifique. </font><font style="vertical-align: inherit;">Lorsque cela se produit, le syst√®me se r√©v√®le un peu plus transparent dans le sens d'obtenir des informations sur la charge du processeur cr√©√©e par les op√©rations r√©seau (bien qu'une telle analyse soit effectu√©e en supposant que c'est SoftIRQ qui est √©tudi√©, qui est li√© au traitement des paquets, et non √† autre chose) . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fa√ßon d'obtenir les indicateurs ci-dessus consiste √† utiliser </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">sudo perf record -a \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:irq_handler_entry,irq:irq_handler_exit<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_entry --filter="vec == 3" \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e irq:softirq_exit --filter="vec == 3"&nbsp; \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-e napi:napi_poll \<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- sleep 1<font></font>
<font></font>
sudo perf script<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici le r√©sultat:</font></font><br>
<br>
<pre><code class="plaintext hljs">swapper &nbsp; &nbsp; 0 [005] 176146.491879: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880:&nbsp; irq:irq_handler_exit: irq=152 ret=handled<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491880: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491942:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 64 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491943: &nbsp; &nbsp; irq:softirq_entry: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; &nbsp; napi:napi_poll: napi poll on napi struct 0xffff9d3d53863e88 for device eth0 work 27 budget 64<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.491971:&nbsp; &nbsp; &nbsp; irq:softirq_exit: vec=3 [action=NET_RX]<font></font>
swapper &nbsp; &nbsp; 0 [005] 176146.492200: irq:irq_handler_entry: irq=152 name=mlx5_comp2@pci:0000:d8:00.0<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, le processeur est inactif (d'o√π l'apparition d'entr√©es </font></font><code>swapper</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour le processus), l'IRQ est appel√© pour la file d'attente Rx sur le CPU 5, le traitement SoftIRQ est appel√© deux fois, 64 paquets sont trait√©s en premier, puis 27. L'IRQ suivante est appel√©e apr√®s 229 Œºs et recommence le cycle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ces donn√©es ont √©t√© obtenues sur un syst√®me inactif. Mais sur le processeur, n'importe quelle t√¢che peut √™tre effectu√©e. Dans ce cas, la s√©quence d'√©v√©nements ci-dessus se produit, interrompant cette t√¢che et effectuant des t√¢ches IRQ / SoftIRQ. Dans le m√™me temps, la comptabilit√© syst√®me attribue au processus interrompu la charge cr√©√©e par le processeur. Par cons√©quent, les t√¢ches de traitement des paquets r√©seau sont g√©n√©ralement masqu√©es des outils classiques de surveillance de la charge du processeur. Ils sont ex√©cut√©s dans le cadre d'un processus choisi au hasard, dans le contexte du ¬´processus victime¬ª. Cela nous am√®ne √† quelques questions. Comment estimer le temps pendant lequel le processus est interrompu pour le traitement des paquets Comment comparer 2 solutions r√©seau diff√©rentes afin de comprendre laquelle a le moins d'effet sur les diff√©rentes t√¢ches r√©solues sur un ordinateur?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'utilisation des m√©canismes RSS, RPS, RFS, le traitement des paquets est g√©n√©ralement r√©parti entre les c≈ìurs du processeur. </font><font style="vertical-align: inherit;">Par cons√©quent, la s√©quence de traitement de paquets ci-dessus est li√©e √† chaque CPU sp√©cifique. </font><font style="vertical-align: inherit;">√Ä mesure que le taux d'arriv√©e des paquets augmente (je pense que nous pouvons parler de vitesses de 100 000 paquets par seconde et plus), chaque CPU doit traiter des milliers ou des dizaines de milliers de paquets par seconde. </font><font style="vertical-align: inherit;">Le traitement d'un si grand nombre de paquets affectera in√©vitablement d'autres t√¢ches effectu√©es sur le serveur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envisagez une fa√ßon d'√©valuer cet effet.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D√©sactivation du traitement distribu√© des paquets</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, arr√™tons le traitement distribu√© des paquets en d√©sactivant RPS et en configurant des r√®gles de contr√¥le de flux visant √† organiser le traitement de tous les paquets li√©s √† une adresse MAC sp√©cifique sur le seul CPU que nous connaissons. </font><font style="vertical-align: inherit;">Mon syst√®me poss√®de 2 cartes r√©seau agr√©g√©es dans une configuration 802.3ad. </font><font style="vertical-align: inherit;">Les t√¢ches r√©seau sont attribu√©es √† une seule machine virtuelle ex√©cut√©e sur un ordinateur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPS sur les cartes r√©seau est d√©sactiv√© comme suit:</font></font><br>
<br>
<pre><code class="plaintext hljs">for d in eth0 eth1; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;find /sys/class/net/${d}/queues -name rps_cpus |<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;while read f; do<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 0 | sudo tee ${f}<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;done<font></font>
done<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, nous avons configur√© les r√®gles de contr√¥le de flux pour garantir que les paquets entrent dans la machine virtuelle de test √† l'aide d'un seul processeur:</font></font><br>
<br>
<pre><code class="plaintext hljs">DMAC=12:34:de:ad:ca:fe<font></font>
sudo ethtool -N eth0 flow-type ether dst ${DMAC} action 2<font></font>
sudo ethtool -N eth1 flow-type ether dst ${DMAC} action 2<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La d√©sactivation de RPS et l'utilisation de r√®gles de contr√¥le de flux nous permettent de garantir que tous les paquets destin√©s √† notre machine virtuelle sont trait√©s sur le m√™me CPU. </font><font style="vertical-align: inherit;">Afin de vous assurer que les paquets sont envoy√©s dans la file d'attente vers laquelle ils doivent √™tre envoy√©s, vous pouvez utiliser une commande comme </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ethq</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ensuite, vous pouvez savoir √† quel processeur cette file d'attente appartient </font></font><code>/proc/interrupts</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dans mon cas, le virage 2 est trait√© au moyen de la CPU 5.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Commande de vitesse openssl</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je pourrais utiliser des utilitaires </font></font><code>perf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou </font><font style="vertical-align: inherit;">analyser les runtimes SoftIRQ responsables du traitement du trafic entrant </font></font><code>bpf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais cette approche est assez compliqu√©e. De plus, le processus d'observation lui-m√™me affecte d√©finitivement les r√©sultats. Une solution beaucoup plus simple et plus compr√©hensible consiste √† identifier la charge cr√©√©e par les op√©rations r√©seau sur le syst√®me √† l'aide d'une t√¢che, celle qui cr√©e une charge connue sur le syst√®me. Par exemple, il s'agit d'une commande </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilis√©e pour tester les performances d'OpenSSL. Cela vous permettra de savoir combien de ressources processeur le programme obtient en r√©alit√© et de le comparer avec la quantit√© de ressources qu'il est cens√© recevoir (cela vous aidera √† savoir combien de ressources sont d√©pens√©es pour les t√¢ches r√©seau).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'√©quipe est </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presque 100% une √©quipe de l'espace utilisateur. Si vous le liez √† un certain processeur, alors, lors de l'ex√©cution des tests, il utilise toutes ses ressources disponibles. L'√©quipe travaille en r√©glant la minuterie √† l'intervalle sp√©cifi√© (ici, par exemple, pour faciliter les calculs, cela prend 10 secondes), en ex√©cutant le test, puis, lorsque la minuterie est d√©clench√©e, en l'utilisant </font></font><code>times</code><code>()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour savoir combien de temps processeur le programme a r√©ellement obtenu. Du point de vue, </font></font><code>syscall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cela ressemble √† ceci:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726601344<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 2782545353<font></font>
times({tms_utime=1000, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726602344<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, il s'av√®re que </font></font><code>alarm()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tr√®s peu d'appels syst√®me ont √©t√© effectu√©s </font><font style="vertical-align: inherit;">entre l'appel </font><font style="vertical-align: inherit;">et la v√©rification des r√©sultats. Si le programme n'a pas √©t√© interrompu, ou tr√®s rarement interrompu, le temps </font></font><code>tms_utime</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">co√Øncidera avec le temps de test (dans ce cas, 10 secondes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puisqu'il s'agit d'un test effectu√© exclusivement dans l'espace utilisateur, toute heure syst√®me qui appara√Æt </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifie une charge suppl√©mentaire sur le syst√®me. Il s'av√®re que bien que </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ce processus s'ex√©cute sur le CPU, le CPU lui-m√™me peut √™tre occup√© par autre chose. Par exemple, le traitement des paquets r√©seau:</font></font><br>
<br>
<pre><code class="plaintext hljs">alarm(10) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; = 0<font></font>
times({tms_utime=0, tms_stime=0, tms_cutime=0, tms_cstime=0}) = 1726617896<font></font>
--- SIGALRM {si_signo=SIGALRM, si_code=SI_KERNEL} ---<font></font>
rt_sigaction(SIGALRM, ...) = 0<font></font>
rt_sigreturn({mask=[]}) = 4079301579<font></font>
times({tms_utime=178, tms_stime=571, tms_cutime=0, tms_cstime=0}) = 1726618896<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, vous pouvez voir qu'il a √©t√© </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">possible de travailler sur le processeur pendant 7,49 secondes (178 + 571 en unit√©s de mesure correspondant √† 0,01 s.). </font><font style="vertical-align: inherit;">Mais en m√™me temps 5,71 s. </font><font style="vertical-align: inherit;">cet intervalle est repr√©sent√© par l'heure syst√®me. </font><font style="vertical-align: inherit;">Comme il n'est </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">occup√© par aucune activit√© dans l'espace du noyau, cela signifie que 5,71 s. </font><font style="vertical-align: inherit;">- Ceci est le r√©sultat d'une charge suppl√©mentaire sur le syst√®me. </font><font style="vertical-align: inherit;">C'est-√†-dire que c'est le moment o√π le processus a √©t√© "vol√©" afin de r√©pondre aux besoins du syst√®me.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utilisation de la commande openssl speed pour d√©tecter la charge du syst√®me caus√©e par les m√©canismes du r√©seau</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons compris comment fonctionne l'√©quipe </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons examiner les r√©sultats qu'elle produit sur un serveur pratiquement inactif:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 66675623 aes-256 cbc's in 9.99s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 18096647 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 4607752 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 1162429 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 145251 aes-256 cbc's in 10.00s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 72831 aes-256 cbc's in 10.00s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, nous sommes inform√©s que le programme passe de 9,99 √† 10 secondes pour traiter des blocs de diff√©rentes tailles. Cela confirme que les m√©canismes du syst√®me ne prennent pas de temps processeur du programme. Maintenant, en utilisant </font></font><code>netperf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, nous allons charger le serveur en traitant les paquets provenant de deux sources. Relancez le test:</font></font><br>
<br>
<pre><code class="plaintext hljs">$ taskset -c 5 openssl speed -seconds 10 aes-256-cbc &gt;/dev/null<font></font>
Doing aes-256 cbc for 10s on 16 size blocks: 12061658 aes-256 cbc's in 1.96s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 3457491 aes-256 cbc's in 2.10s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 893939 aes-256 cbc's in 2.01s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 201756 aes-256 cbc's in 1.86s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 25117 aes-256 cbc's in 1.78s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 13859 aes-256 cbc's in 1.89s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les r√©sultats sont tr√®s diff√©rents de ceux obtenus sur un serveur inactif. Il est pr√©vu que chacun des tests soit ex√©cut√© dans les 10 secondes, mais </font></font><code>times()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">indique que le temps d'ex√©cution r√©el est de 1,78 √† 2,1 secondes. Cela signifie que le temps restant, variant de 7,9 √† 8,22 secondes, a √©t√© consacr√© au traitement des paquets, soit dans le contexte du processus, </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soit dans </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voyons ce que l'√©quipe donnera </font></font><code>top</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lors de l'analyse du lancement qui vient de se terminer </font></font><code>openssl speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P&nbsp;<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.649g 1.565g S 279.9&nbsp; 0.9&nbsp; 18:57.81 qemu-system-x86 &nbsp; &nbsp; 75<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 99.4&nbsp; 0.0 &nbsp; 2:57.97 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 89<font></font>
&nbsp;1684 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4400 &nbsp; 3892 R&nbsp; 73.6&nbsp; 0.0 &nbsp; 0:09.91 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 26.2&nbsp; 0.0 &nbsp; 0:31.86 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, vous pourriez penser qu'il </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utilise environ 73% des ressources du processeur 5, et les </font></font><code>ksoftirqd</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ressources restantes sont obtenues. </font><font style="vertical-align: inherit;">Mais en r√©alit√©, dans le contexte </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, le traitement d'un si grand nombre de packages est effectu√© que le programme lui-m√™me ne prend que 18 √† 21% du temps du processeur pour r√©soudre ses probl√®mes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous r√©duisez la charge r√©seau √† 1 flux, vous </font></font><code>openssl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avez l' </font><font style="vertical-align: inherit;">impression que </font><font style="vertical-align: inherit;">99% des ressources syst√®me sont consomm√©es.</font></font><br>
<br>
<pre><code class="plaintext hljs">&nbsp;&nbsp;PID USER&nbsp; &nbsp; &nbsp; PR&nbsp; NI&nbsp; &nbsp; VIRT&nbsp; &nbsp; RES&nbsp; &nbsp; SHR S&nbsp; %CPU %MEM &nbsp; &nbsp; TIME+ COMMAND&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; P<font></font>
&nbsp;8180 libvirt+&nbsp; 20 &nbsp; 0 33.269g 1.722g 1.637g S 325.1&nbsp; 0.9 166:38.12 qemu-system-x86 &nbsp; &nbsp; 29<font></font>
44218 dahern&nbsp; &nbsp; 20 &nbsp; 0 &nbsp; 17112 &nbsp; 4488 &nbsp; 3996 R&nbsp; 99.2&nbsp; 0.0 &nbsp; 0:28.55 openssl&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
&nbsp;8374 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 R&nbsp; 64.7&nbsp; 0.0&nbsp; 60:40.50 vhost-8180&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 55<font></font>
&nbsp;&nbsp;&nbsp;38 root&nbsp; &nbsp; &nbsp; 20 &nbsp; 0 &nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0&nbsp; &nbsp; &nbsp; 0 S &nbsp; 1.0&nbsp; 0.0 &nbsp; 4:51.98 ksoftirqd/5&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais en r√©alit√©, il s'av√®re que le programme en cours d'ex√©cution dans l'espace utilisateur obtient, sur les 10 secondes attendues, seulement environ 4 secondes:</font></font><br>
<br>
<pre><code class="plaintext hljs">Doing aes-256 cbc for 10s on 16 size blocks: 26596388 aes-256 cbc's in 4.01s<font></font>
Doing aes-256 cbc for 10s on 64 size blocks: 7137481 aes-256 cbc's in 4.14s<font></font>
Doing aes-256 cbc for 10s on 256 size blocks: 1844565 aes-256 cbc's in 4.31s<font></font>
Doing aes-256 cbc for 10s on 1024 size blocks: 472687 aes-256 cbc's in 4.28s<font></font>
Doing aes-256 cbc for 10s on 8192 size blocks: 59001 aes-256 cbc's in 4.46s<font></font>
Doing aes-256 cbc for 10s on 16384 size blocks: 28569 aes-256 cbc's in 4.16s<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les outils de surveillance de processus conventionnels indiquent que le programme utilise presque toutes les ressources du processeur, mais en r√©alit√©, il s'av√®re que 55 √† 80% des ressources du processeur sont consacr√©es au traitement des paquets r√©seau. </font><font style="vertical-align: inherit;">Le d√©bit du syst√®me en m√™me temps semble excellent (plus de 22 Gb / s par ligne de 25 Gb / s), mais cela a un impact √©norme sur les processus en cours d'ex√©cution dans ce syst√®me.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sommaire</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous avons examin√© un exemple de la fa√ßon dont les m√©canismes de traitement des paquets ¬´volent¬ª les horloges des processeurs √† partir d'une r√©f√©rence simple et peu importante. </font><font style="vertical-align: inherit;">Mais sur un vrai serveur, les processus qui sont affect√©s de la m√™me mani√®re peuvent √™tre n'importe quoi. </font><font style="vertical-align: inherit;">Il peut s'agir de processeurs virtuels, de threads d'√©mulation, de threads vhost de machines virtuelles. </font><font style="vertical-align: inherit;">Il peut s'agir de processus syst√®me diff√©rents, dont l'impact peut avoir un impact diff√©rent sur les performances de ces processus et sur l'ensemble du syst√®me. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consid√©rez-vous, en analysant vos serveurs, l'impact sur leurs performances r√©elles de la charge associ√©e aux op√©rations r√©seau?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503624/index.html">Le condens√© de mati√®res fra√Æches du monde du front-end de la derni√®re semaine n ¬∞ 416 (18-24 mai 2020)</a></li>
<li><a href="../fr503626/index.html">Essai. Erreurs de certification ISTQB ou r√©solvez un million d'exemples</a></li>
<li><a href="../fr503630/index.html">Lunettes de r√©alit√© augment√©e: o√π en sommes-nous maintenant?</a></li>
<li><a href="../fr503632/index.html">1000 et 1 poste: joyeux anniversaire, Habr ‚ù§</a></li>
<li><a href="../fr503634/index.html">5 trouvailles JavaScript int√©ressantes faites dans le code source de Vue</a></li>
<li><a href="../fr503638/index.html">6 habitudes utiles que, √©tonnamment, seuls quelques programmeurs ont</a></li>
<li><a href="../fr503642/index.html">Comment acc√©der √† LinkedIn, Facebook, Google dans la Silicon Valley</a></li>
<li><a href="../fr503650/index.html">VKCup 2020 Stage I. Un long chemin</a></li>
<li><a href="../fr503652/index.html">√âv√©nements num√©riques √† Moscou du 25 au 31 mai</a></li>
<li><a href="../fr503654/index.html">Service Web qui permet aux utilisateurs de maintenir ind√©pendamment une culture de communication en ligne</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>