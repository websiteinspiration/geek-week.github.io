<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💡 👎 😣 Theoretische Datenstrukturen und ihre Anwendung in JavaScript. P1. Paare 👉🏻 👕 👶🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="„Schlechte Programmierer denken über Code nach. Gute Programmierer denken über Datenstrukturen und ihre Beziehungen nach “, erklärt Linus Torvalds, En...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Theoretische Datenstrukturen und ihre Anwendung in JavaScript. P1. Paare</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/493692/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Schlechte Programmierer denken über Code nach. </font><font style="vertical-align: inherit;">Gute Programmierer denken über Datenstrukturen und ihre Beziehungen nach “, erklärt Linus Torvalds, Entwickler von Linux.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir gehen davon aus, dass die Lösung eines Programmierproblems sehr oft in der Auswahl der richtigen Datenstruktur besteht. </font><font style="vertical-align: inherit;">Dieses Axiom kann bewiesen werden, aber es ist eine lange Zeit und der Artikel handelt ein wenig von einem anderen. </font><font style="vertical-align: inherit;">Heute werden wir über eine der einfachsten theoretischen Strukturen sprechen, über das Paar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Paar ist eine Datenstruktur, die zwei beliebige Datenelemente in sich speichert, was bedeutet, dass wir sie irgendwie logisch zu einem kombinieren möchten. </font><font style="vertical-align: inherit;">Es löst genau dieses Problem, d.h. </font><font style="vertical-align: inherit;">Wenn es einige Datenelemente gibt </font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir sie im Formular präsentieren müssen </font></font><code>b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, können wir dieses Design paarweise implementieren.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie denken, dass Sie so etwas noch nie erlebt haben oder nicht begegnen werden, ist dies nicht der Fall. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist das einfachste Beispiel einer berechneten Eigenschaft aus der VUE-Dokumentation:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue({
  <span class="hljs-attr">el</span>: <span class="hljs-string">'#demo'</span>,
  <span class="hljs-attr">data</span>: {
    <span class="hljs-attr">firstName</span>: <span class="hljs-string">'Foo'</span>,
    <span class="hljs-attr">lastName</span>: <span class="hljs-string">'Bar'</span><font></font>
  },<font></font>
  <span class="hljs-attr">computed</span>: {
    <span class="hljs-attr">fullName</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">' '</span> + <span class="hljs-keyword">this</span>.lastName<font></font>
    }<font></font>
  }<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus theoretischer Sicht ist </font></font><code>fullName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dies ein Paar. Und es gibt unzählige solcher Beispiele in der Technologie und in der realen Welt, die wir oft mit Programmcode modellieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können zu Recht feststellen, dass wir eine beliebige Anzahl von Elementen logisch kombinieren können, und Sie haben Recht. Dies bringt uns zu einem komplexeren Strukturkonzept </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zusammengesetzter Daten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , von denen eines ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paar ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Wir werden uns etwas später mit den zusammengesetzten Daten befassen, jetzt konzentrieren wir uns auf das Paar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Theorie sagt uns, dass Paare die folgenden Eigenschaften haben:</font></font><br>
<br>
<ul>
<li><b></b>, ..    -    ,        ,     .      ,    (     -  .           ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>)</li>
<li><b>          </b>.     .          .      ,   ,     ,     ,    ,     .<br>
<br>
    :<br>
<br>
<pre><code class="plaintext hljs">pair = { a, b }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir im aufrufenden Code direkt mit dem Paar in diesem Stil arbeiten: Wenn wir </font></font><code>pair.a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dann die Implementierung des Paares ändern, müssen wir den aufrufenden Code überall dort neu schreiben, wo der Aufruf des Paares erscheint. </font><font style="vertical-align: inherit;">Das ist nicht toll! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Paar ist eine Abstraktion (sogar eine niedrige Ebene), daher wäre es falsch, direkt mit ihren Komponenten zu arbeiten. </font><font style="vertical-align: inherit;">Wenn wir mit den Komponenten einer Abstraktion arbeiten, müssen wir die Abstraktionsschnittstelle verwenden, sonst wird der Code zu Chaos (es wird schwieriger zu lesen, leichter Fehler zu machen, aber vor allem schwieriger zu ändern, da eine Änderung in verschiedenen Teilen des Codes vorgenommen werden muss).</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paare können auf sehr unterschiedliche Weise implementiert werden. </font><font style="vertical-align: inherit;">In jeder Programmiersprache gibt es mehr als eine Möglichkeit, diese Datenstruktur zu implementieren. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können beispielsweise ein Paar für beliebige Datentypen implementieren:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//       </span>
<span class="hljs-comment">//      </span>
<span class="hljs-keyword">const</span> pair = <span class="hljs-function">(<span class="hljs-params">first, second</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">elementType</span>) =&gt;</span> {
  <span class="hljs-keyword">switch</span>(elementType) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'first'</span>:
     <span class="hljs-keyword">return</span> first;
   <span class="hljs-keyword">case</span> <span class="hljs-string">'second'</span>:
     <span class="hljs-keyword">return</span> second;<font></font>
  }<font></font>
};<font></font>
<span class="hljs-comment">//    ,      ,</span>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> getFirstElement = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair(<span class="hljs-string">'first'</span>));
<span class="hljs-keyword">const</span> getSecondElement = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair(<span class="hljs-string">'second'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Arbeitsweise wird als Senden von Nachrichten bezeichnet. Seltsamerweise, aber es war diese Art der Interaktion zwischen Entitäten, die vor C / C ++ einmal OOP genannt wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Müssen wir das Design verwenden </font></font><code>switch </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Natürlich nicht unbedingt. Dies sind die Details der technischen Implementierung, und es kann sehr viele Implementierungen geben! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste ist, das Paar veränderlich zu machen! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beispielsweise können Sie dieselbe Funktionalität mit </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Map</font></a><font style="vertical-align: inherit;"> implementieren</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     </span>
<span class="hljs-comment">//  ,       </span>
<span class="hljs-keyword">const</span> pair = <span class="hljs-function">(<span class="hljs-params">first, second</span>) =&gt;</span> (
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<font></font>
    [<span class="hljs-string">'first'</span>, first],<font></font>
    [<span class="hljs-string">'second'</span>, second],<font></font>
  ])<font></font>
);<font></font>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> getFirst = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair.get(<span class="hljs-string">'first'</span>));
<span class="hljs-keyword">const</span> getSecond = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair.get(<span class="hljs-string">'second'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beachten Sie, dass die erste Implementierung leicht durch die zweite ersetzt werden kann. und der zweite zum ersten! Der aufrufende Code wird nicht geändert. Dies ist ein wichtiger Vorteil von Abstraktionen. Wir können die Implementierung der Abstraktion im Programm leicht ändern, aber der Code, der mit dieser Abstraktion arbeitet, kennt diese Änderungen nicht. Wir müssen den Code, der mit diesen Abstraktionen funktioniert, nicht bearbeiten, wenn wir die Implementierung der Abstraktionen selbst ändern möchten. Das ist sehr wichtig, weil spart Kundengeld und erhöht Entwicklerboni. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir übrigens an, wir wissen nichts über die Existenz von Mapov in js, aber wir können mit Objekten arbeiten.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//       </span>
<span class="hljs-comment">//   </span>
<span class="hljs-keyword">const</span> pair = <span class="hljs-function">(<span class="hljs-params">first, second</span>) =&gt;</span> (
  <span class="hljs-built_in">Object</span>.freeze({
    <span class="hljs-string">'first'</span>: first,
    <span class="hljs-string">'second'</span>: second,<font></font>
  })<font></font>
);<font></font>
<span class="hljs-comment">//    ,       </span>
<span class="hljs-keyword">const</span> getFirst = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair.first);
<span class="hljs-keyword">const</span> getSecond = <span class="hljs-function">(<span class="hljs-params">pair</span>) =&gt;</span> (pair.second);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie leicht erraten können, können beide vorherigen Implementierungen auch durch eine dritte ersetzt werden, und daran ändert sich nichts ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tatsächlich gibt es einen Unterschied. Karten lösen keine Ausnahmen aus, wenn sie versuchen, Eigenschaften direkt zu ändern, aber sie werfen "eingefrorene Objekte" aus </font></font><code>TypeError: Cannot assign to read only property</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Im Kontext dieses Artikels wichtig.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum brauchen wir Kenntnisse über theoretische Datenstrukturen?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die Arbeit eines Programmierers aus der Vogelperspektive betrachten, werden wir sehen, dass er sich im Wesentlichen damit beschäftigt. Dadurch werden Tools erstellt, mit denen bestimmte Datensätze bearbeitet werden können. Daher müssen wir ständig eine Art Speicherstruktur für die Daten auswählen und Wege finden, um mit ihnen zu arbeiten oder dem chaotischen Datensatz eine bestimmte Struktur zu geben. Das Verständnis der typischen Datenstrukturen ermöglicht es uns, eine Reihe vorgefertigter Lösungen für verschiedene typische Aufgaben zu besitzen und einfach den bequemsten Weg für eine bestimmte Aufgabe zu wählen. </font><font style="vertical-align: inherit;">
Analysieren </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wir ein Beispiel: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Implementieren Sie einen Mechanismus für die Arbeit mit Brüchen. Brüche sollten im üblichen Format gespeichert werden. jene. in Form von 1/2. Es ist auch notwendig, grundlegende Operationen (Addition, Subtraktion, Multiplikation, Division) zu implementieren. Normalisierung muss bereitgestellt werden. “</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns den Zustand des Problems verstehen! Wir müssen eine Abstraktion für eine mathematische Entität implementieren, daher ist es sinnvoll, auf die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ursprüngliche Quelle</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verweisen </font><font style="vertical-align: inherit;">. Wenn erfahrene Programmierer diesen Text lesen, müssen sie sich die Lösung im Code sofort vorgestellt haben, ohne den Artikel über Brüche in der Mathematik zu lesen, aber wir gehen davon aus. dass wir uns schwach vorstellen, wie Brüche funktionieren, und den gesamten Verlauf des Denkens veranschaulichen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wikipedia-Material sagt uns, dass Brüche gewöhnlich (1/4) und dezimal (0,1) sind. Aufgrund des Problemzustands müssen wir natürlich mit Brüchen im üblichen Präsentationsformat arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen auch, dass der gewöhnliche Bruch eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logische Vereinigung von zwei ist</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zahlen (Zähler und Nenner), dies ist das sicherste Signal für die Notwendigkeit, ein Paar als Datenstruktur für diese Aufgabe zu verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Code könnten wir diese Struktur wie folgt beschreiben:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//        ,</span>
<span class="hljs-comment">//  ,    </span>
<span class="hljs-comment">//          ,</span>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">const</span> makeRational = <span class="hljs-function">(<span class="hljs-params">num, denom</span>) =&gt;</span> (
  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<font></font>
    [<span class="hljs-string">'num'</span>, num],<font></font>
    [<span class="hljs-string">'denom'</span>, denom],<font></font>
  ])<font></font>
);<font></font>
<font></font>
<span class="hljs-comment">//  ,    </span>
<span class="hljs-comment">//   ,      ,    </span>
<span class="hljs-comment">//    </span>
<span class="hljs-keyword">const</span> getNumer = <span class="hljs-function">(<span class="hljs-params">rat</span>) =&gt;</span> (rat.get(<span class="hljs-string">'num'</span>));
<span class="hljs-keyword">const</span> getDenom = <span class="hljs-function">(<span class="hljs-params">rat</span>) =&gt;</span> (rat.get(<span class="hljs-string">'denom'</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes sollten wir die Situation mit Bruchteilen eines solchen Plans 8/4, 6/9 analysieren. </font><font style="vertical-align: inherit;">Der Zustand der Aufgabe sagt über die Notwendigkeit aus, für eine Normalisierung zu sorgen. </font><font style="vertical-align: inherit;">Die Normalisierung einer Fraktion ist die Entfernung des größten gemeinsamen Teilers (GCD). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir implementieren eine Funktion zur Suche nach zwei GCD-Zahlen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//Gcd     </span>
<span class="hljs-keyword">const</span> getGcd = <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> ((a % b) ? getGcd(b, a % b) : <span class="hljs-built_in">Math</span>.abs(b));
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihnen der Text der Funktion nicht klar ist, empfehle ich Ihnen, über die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekursion</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu lesen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Bruch zu normalisieren, müssen wir seinen Zähler und Nenner durch GCD teilen. </font><font style="vertical-align: inherit;">Wir schreiben die Normalisierungsfunktion:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> normalize = <span class="hljs-function">(<span class="hljs-params">n1, n2</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> commonDivisor = getGcd(n1, n2);
  <span class="hljs-keyword">return</span> [n1 / commonDivisor, n2 / commonDivisor];<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wäre logisch, die Normalisierung in den makeRational-Konstruktor einzufügen, um die Daten beim Erstellen des Bruchs immer zu normalisieren. </font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> makeRational = <span class="hljs-function">(<span class="hljs-params">num, denom</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [normalizeNum, normalizeDenom] = normalize(num, denom);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<font></font>
    [<span class="hljs-string">'num'</span>, normalizeNum],<font></font>
    [<span class="hljs-string">'denom'</span>, normalizeDenom],<font></font>
  ]);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Nächstes arbeiten wir an der Betriebsoberfläche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) Addition </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zwei gewöhnliche Brüche zu addieren, sollten Sie sie auf einen gemeinsamen Nenner bringen. </font><font style="vertical-align: inherit;">Fügen Sie dann die Zähler hinzu und lassen Sie den Nenner unverändert.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//..       ,</span>
<span class="hljs-comment">//       ,</span>
<span class="hljs-comment">//         </span>
<span class="hljs-keyword">const</span> add = <span class="hljs-function">(<span class="hljs-params">rat1, rat2</span>) =&gt;</span> (<font></font>
  makeRational(<font></font>
    getNumer(rat1) * getDenom(rat2) + getNumer(rat2) * getDenom(rat1),<font></font>
    getDenom(rat1) * getDenom(rat2),<font></font>
  ));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) Subtraktion </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Differenz der Brüche zu erhalten, müssen sie auch auf einen gemeinsamen Nenner reduziert werden, und dann sollten die Zähler subtrahiert werden, der Nenner sollte unverändert bleiben.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//    </span>
<span class="hljs-comment">//     </span>
<span class="hljs-keyword">const</span> sub = <span class="hljs-function">(<span class="hljs-params">rat1, rat2</span>) =&gt;</span> (<font></font>
  makeRational(<font></font>
    getNumer(rat1) * getDenom(rat2) - getNumer(rat2) * getDenom(rat1),<font></font>
    getDenom(rat1) * getDenom(rat2),<font></font>
  ));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3) Multiplikation </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zwei gewöhnliche Brüche zu multiplizieren, müssen Sie ihre Zähler und Nenner multiplizieren.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> multi = <span class="hljs-function">(<span class="hljs-params">rat1, rat2</span>) =&gt;</span> (<font></font>
  makeRational(<font></font>
    getNumer(rat1) * getNumer(rat2),<font></font>
    getDenom(rat1) * getDenom(rat2),<font></font>
  ));<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4) Division </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen gewöhnlichen Bruch in einen anderen zu teilen, müssen Sie den ersten Bruch mit dem Bruchteil des zweiten multiplizieren. </font><font style="vertical-align: inherit;">Die Umkehrung ist ein Bruch, dessen Zähler gleich dem Nenner des Originals ist, und der Nenner ist der Zähler des Originals.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> div = <span class="hljs-function">(<span class="hljs-params">rat1, rat2</span>) =&gt;</span> (<font></font>
  makeRational(<font></font>
    getNumer(rat1) * getDenom(rat2),<font></font>
    getDenom(rat1) * getNumer(rat2),<font></font>
  ));<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, erstellen wir in jeder Operation eine neue Entität. </font><font style="vertical-align: inherit;">Dies ist eine Folge der Unveränderlichkeitsregel. </font><font style="vertical-align: inherit;">Beachten Sie, dass Sie in mathematischen Operationen die ursprüngliche Anzahl von Zahlen nicht ändern und neue erstellen : </font></font><code>1 + 2 = 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sollte aufpassen. </font><font style="vertical-align: inherit;">dass wir die Implementierung </font></font><code>makeRational</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in eine andere </font><font style="vertical-align: inherit;">ändern </font><font style="vertical-align: inherit;">können, der aufrufende Code jedoch nichts davon weiß und weiterhin funktioniert. </font><font style="vertical-align: inherit;">Dies ist eine Folge der Tatsache, dass wir die Abstraktion korrekt implementiert haben und mit ihren Komponenten über die Schnittstelle und nicht direkt arbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch wichtig, dass der Benutzer seine Daten auf die übliche Weise abrufen kann, daher führen wir eine zusätzliche Funktion ein.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> ratToString = <span class="hljs-function">(<span class="hljs-params">rat</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${getNumer(rat)}</span>/<span class="hljs-subst">${getDenom(rat)}</span>`</span>;
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde eine Liste der Tests beifügen:</font></font><br>
<br>
<pre><code class="javascript hljs">describe(<span class="hljs-string">'normalize'</span>, () =&gt; {<font></font>
  test(<span class="hljs-string">'should work'</span>, () =&gt; {<font></font>
    expect(normalize(<span class="hljs-number">21</span>, <span class="hljs-number">6</span>)).toEqual([<span class="hljs-number">7</span>, <span class="hljs-number">2</span>]);<font></font>
    expect(normalize(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).toEqual([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<font></font>
  });<font></font>
});<font></font>
<font></font>
<font></font>
describe(<span class="hljs-string">'rational'</span>, () =&gt; {<font></font>
  test(<span class="hljs-string">'getters'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> rat1 = makeRational(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);<font></font>
    expect(getNumer(rat1)).toBe(<span class="hljs-number">1</span>);<font></font>
    expect(getDenom(rat1)).toBe(<span class="hljs-number">3</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> rat3 = makeRational(<span class="hljs-number">-4</span>, <span class="hljs-number">16</span>);<font></font>
    expect(getNumer(rat3)).toBe(<span class="hljs-number">-1</span>);<font></font>
    expect(getDenom(rat3)).toBe(<span class="hljs-number">4</span>);<font></font>
  });<font></font>
<font></font>
  test(<span class="hljs-string">'add&amp;sub'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> rat1 = makeRational(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
    <span class="hljs-keyword">const</span> rat2 = makeRational(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);<font></font>
    expect(add(rat1, rat2)).toEqual(makeRational(<span class="hljs-number">11</span>, <span class="hljs-number">3</span>));<font></font>
    expect(sub(rat1, rat2)).toEqual(makeRational(<span class="hljs-number">-3</span>, <span class="hljs-number">1</span>));<font></font>
<font></font>
    <span class="hljs-keyword">const</span> rat4 = makeRational(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>);
    <span class="hljs-keyword">const</span> rat3 = makeRational(<span class="hljs-number">-4</span>, <span class="hljs-number">16</span>);<font></font>
    expect(add(rat3, rat4)).toEqual(makeRational(<span class="hljs-number">43</span>, <span class="hljs-number">20</span>));<font></font>
    expect(sub(rat3, rat4)).toEqual(makeRational(<span class="hljs-number">-53</span>, <span class="hljs-number">20</span>));<font></font>
<font></font>
    <span class="hljs-keyword">const</span> rat5 = makeRational(<span class="hljs-number">1</span>, <span class="hljs-number">15</span>);
    <span class="hljs-keyword">const</span> rat6 = makeRational(<span class="hljs-number">4</span>, <span class="hljs-number">25</span>);<font></font>
    expect(add(rat5, rat6)).toEqual(makeRational(<span class="hljs-number">17</span>, <span class="hljs-number">75</span>));<font></font>
    expect(sub(rat5, rat6)).toEqual(makeRational(<span class="hljs-number">-7</span>, <span class="hljs-number">75</span>));<font></font>
  });<font></font>
<font></font>
  test(<span class="hljs-string">'multi&amp;div'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> rat1 = makeRational(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    <span class="hljs-keyword">const</span> rat2 = makeRational(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<font></font>
    expect(multi(rat1, rat2)).toEqual(makeRational(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>));<font></font>
<font></font>
    <span class="hljs-keyword">const</span> rat3 = makeRational(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
    <span class="hljs-keyword">const</span> rat4 = makeRational(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<font></font>
    expect(div(rat3, rat4)).toEqual(makeRational(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));<font></font>
  });<font></font>
<font></font>
  test(<span class="hljs-string">'ratToString'</span>, () =&gt; {
    <span class="hljs-keyword">const</span> rat1 = makeRational(<span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
    <span class="hljs-keyword">const</span> rat3 = makeRational(<span class="hljs-number">-4</span>, <span class="hljs-number">16</span>);<font></font>
    expect(ratToString(rat1)).toBe(<span class="hljs-string">'1/3'</span>);<font></font>
    expect(ratToString(rat3)).toBe(<span class="hljs-string">'-1/4'</span>);<font></font>
  });<font></font>
});<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Text erwies sich als ziemlich umfangreich, aber ich hoffe, es ist klar. </font><font style="vertical-align: inherit;">Zusammenfassen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir können die Dampfdatenstruktur immer dann verwenden, wenn wir zwei nicht miteinander verbundene Werte logisch kombinieren müssen </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Paar muss immun sein</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Das Paar muss eine Schnittstelle für die Arbeit mit seinen Komponenten bereitstellen</font></font></li>
</ol> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich entschuldige mich im Voraus, wenn der Artikel jemandem überladen erschien. </font><font style="vertical-align: inherit;">Ich konzentriere mich hauptsächlich auf nicht sehr erfahrene Entwickler, deshalb versuche ich, so zu schreiben, dass die Logik meiner Argumentation und die Wahl dieser oder jener Lösung äußerst klar sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn der Artikel für die Community von Interesse ist. </font><font style="vertical-align: inherit;">dann wird die Richtung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">typischer Datenstrukturen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fortgesetzt. </font><font style="vertical-align: inherit;">Das nächste Thema sind Themenlisten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de493674/index.html">Video Player Übersicht für das Web</a></li>
<li><a href="../de493680/index.html">10 Tricks, wie man Online-Konfu nicht zusammenführt</a></li>
<li><a href="../de493686/index.html">Der mysteriöse Ursprung des Brettspiels über das Hacken von Codes Mastermind</a></li>
<li><a href="../de493688/index.html">Wir machen Microsoft Teams kostenlos - bleiben Sie in dieser schwierigen Zeit mit Kollegen in Kontakt</a></li>
<li><a href="../de493690/index.html">20 Tipps für den Piloten DJI Mavic Mini zum Schutz Ihrer Drohne vor Absturz und Verlust</a></li>
<li><a href="../de493696/index.html">Beschleunigung des Qemu KVM-Festplattensubsystems unter Linux</a></li>
<li><a href="../de493700/index.html">Verwenden von Malware in Azure, um Zugriff auf Microsoft 365-Mandanten zu erhalten</a></li>
<li><a href="../de493702/index.html">Massiver Übergang zur Fernarbeit: technische Probleme und Sicherheitsbedrohungen</a></li>
<li><a href="../de493704/index.html">Verwenden von TypeScript in JavaScript ohne Schreiben von TypeScript</a></li>
<li><a href="../de493706/index.html">Kennen Sie Ihren Feind: Erstellen Sie eine Node.js-Hintertür</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>