<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçä üê∫ üì∏ Kelebihan dalam C ++. Bagian III. Overloading pernyataan baru / hapus üòú üíú üêõ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami melanjutkan seri "C ++, menggali lebih dalam." Tujuan dari seri ini adalah untuk memberi tahu sebanyak mungkin tentang berbagai fitur bahasa, mun...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kelebihan dalam C ++. Bagian III. Overloading pernyataan baru / hapus</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melanjutkan seri "C ++, menggali lebih dalam." </font><font style="vertical-align: inherit;">Tujuan dari seri ini adalah untuk memberi tahu sebanyak mungkin tentang berbagai fitur bahasa, mungkin cukup istimewa. </font><font style="vertical-align: inherit;">Artikel ini membahas tentang kelebihan operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah artikel ketiga dalam seri ini, yang pertama didedikasikan untuk fungsi dan templat yang berlebihan, terletak di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang kedua didedikasikan untuk operator yang kelebihan beban, yang terletak di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Artikel ini menyimpulkan seri tiga artikel tentang kelebihan muatan di C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Isi</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar Isi</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Bentuk standar dari operator baru / hapus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ mendukung beberapa opsi operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Mereka dapat dibagi menjadi standar dasar, standar tambahan dan kebiasaan. </font><font style="vertical-align: inherit;">Bagian ini dan bagian 2 membahas formulir standar, formulir kustom akan dibahas di bagian 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Bentuk standar dasar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bentuk standar utama dari operator yang </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan saat membuat dan menghapus objek dan array jenis adalah </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebagai berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pekerjaan mereka dapat digambarkan sebagai berikut. Ketika operator dipanggil </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memori pertama dialokasikan ke objek. Jika seleksi berhasil, konstruktor dipanggil. Jika konstruktor melempar pengecualian, maka memori yang dialokasikan dibebaskan. Ketika operator dipanggil, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semuanya terjadi dalam urutan terbalik: pertama, destructor dipanggil, kemudian memori dibebaskan. Destruktor seharusnya tidak melempar pengecualian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika operator</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan untuk membuat berbagai objek, memori pertama dialokasikan untuk seluruh array. Jika seleksi berhasil, maka konstruktor default (atau konstruktor lain, jika ada penginisialisasi) dipanggil untuk setiap elemen array mulai dari nol. Jika ada konstruktor yang melempar pengecualian, maka untuk semua elemen array yang dibuat, destruktor dipanggil dalam urutan terbalik dari panggilan konstruktor, maka memori yang dialokasikan akan dibebaskan. Untuk menghapus array, Anda harus memanggil operator </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan untuk semua elemen array, destructor dipanggil dengan urutan terbalik dari konstruktor, kemudian memori yang dialokasikan dibebaskan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatian! Penting untuk memanggil bentuk operator yang benar</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tergantung pada apakah satu objek atau array dihapus. Aturan ini harus dipatuhi dengan ketat, jika tidak Anda bisa mendapatkan perilaku tidak terdefinisi, yaitu, apa pun bisa terjadi: kebocoran memori, kerusakan, dll. Lihat [Meyers1] untuk detailnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam uraian di atas, satu klarifikasi diperlukan. Untuk apa yang disebut tipe sepele (tipe bawaan, struktur gaya C), konstruktor default mungkin tidak dipanggil, dan destruktor tidak melakukan apa pun dalam hal apa pun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi alokasi memori standar, ketika tidak mungkin untuk memenuhi permintaan, melempar pengecualian tipe </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tetapi pengecualian ini dapat ditangkap, untuk ini Anda perlu menginstal pencegat global menggunakan panggilan fungsi </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, untuk lebih jelasnya lihat [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua bentuk operator</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terapkan dengan aman ke null pointer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat membuat array dengan operator, </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukurannya dapat diatur ke nol. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kedua bentuk operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan penggunaan inisialisasi dalam kawat gigi.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Formulir standar tambahan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menghubungkan file header </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, 4 formulir operator standar tersedia </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua yang pertama disebut </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penempatan non-alokasi </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Argumen </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah penunjuk ke wilayah memori yang cukup besar untuk menampung instance atau array. Selain itu, area memori harus memiliki perataan yang sesuai. Versi operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini tidak mengalokasikan memori, melainkan hanya memberikan panggilan ke konstruktor. Dengan demikian, opsi ini memungkinkan Anda untuk memisahkan fase alokasi memori dan inisialisasi objek. Fitur ini secara aktif digunakan dalam wadah standar. Operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk objek yang dibuat dengan cara ini tentu saja tidak dapat dipanggil. Untuk menghapus objek, Anda harus langsung memanggil destruktor, dan kemudian membebaskan memori dengan cara yang tergantung pada metode alokasi memori.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua opsi kedua disebut operator tidak melempar pengecualian </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan berbeda dalam hal jika tidak mungkin memenuhi permintaan, mereka kembali </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi tidak melempar pengecualian tipe </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menghapus objek terjadi menggunakan operator utama </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Opsi ini dianggap usang dan tidak disarankan untuk digunakan.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Alokasi Memori dan Fungsi Gratis</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bentuk standar operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan fungsi alokasi dan deallokasi berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi-fungsi ini didefinisikan dalam namespace global. </font><font style="vertical-align: inherit;">Fungsi alokasi memori untuk pernyataan host </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak melakukan apa pun dan mengembalikannya </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 mendukung bentuk alokasi memori dan fungsi deallokasi tambahan, yang menunjukkan penyelarasan. </font><font style="vertical-align: inherit;">Inilah beberapa di antaranya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formulir ini tidak secara langsung dapat diakses oleh pengguna, mereka digunakan oleh kompiler untuk objek yang persyaratan penyelarasannya lebih unggul </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga masalah utama adalah bahwa pengguna tidak sengaja menyembunyikannya (lihat bagian 2.2.1). </font><font style="vertical-align: inherit;">Ingatlah bahwa dalam C ++ 11 menjadi mungkin untuk secara eksplisit mengatur penyelarasan tipe pengguna.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Kelebihan bentuk standar operator baru / hapus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overloading bentuk standar operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terdiri dari mendefinisikan fungsi yang ditentukan pengguna untuk mengalokasikan dan membebaskan memori yang tandatangannya sesuai dengan yang standar. </font><font style="vertical-align: inherit;">Fungsi-fungsi ini dapat didefinisikan dalam namespace global atau dalam kelas, tetapi tidak dalam namespace selain global. </font><font style="vertical-align: inherit;">Fungsi alokasi memori untuk pernyataan host standar </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat didefinisikan dalam namespace global. </font><font style="vertical-align: inherit;">Setelah definisi seperti itu, operator yang sesuai </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menggunakannya, bukan yang standar.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Kelebihan dalam namespace global</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan, misalnya, dalam sebuah modul dalam ruang nama global yang fungsi-fungsi yang ditentukan pengguna didefinisikan:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, sebenarnya akan ada penggantian (penggantian) fungsi standar untuk mengalokasikan dan membebaskan memori untuk semua panggilan operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk setiap kelas (termasuk yang standar) di seluruh modul. Ini dapat menyebabkan kekacauan total. Perhatikan bahwa mekanisme substitusi yang dijelaskan adalah mekanisme khusus yang diterapkan hanya untuk kasus ini, dan bukan mekanisme C ++ umum. Dalam hal ini, ketika mengimplementasikan fungsi pengguna untuk mengalokasikan dan membebaskan memori, menjadi tidak mungkin untuk memanggil fungsi standar yang sesuai, mereka sepenuhnya tersembunyi (operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak membantu), dan ketika Anda mencoba memanggilnya, panggilan rekursif ke fungsi pengguna terjadi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi Ditentukan Namespace Global</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini juga akan menggantikan yang standar, tetapi akan ada lebih sedikit potensi masalah, karena operator yang tidak melempar pengecualian </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jarang digunakan. </font><font style="vertical-align: inherit;">Tetapi formulir standar juga tidak tersedia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Situasi yang sama dengan fungsi untuk array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pernyataan berlebihan </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di namespace global sangat tidak disarankan.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Kelas terlalu banyak</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator kelebihan muatan </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di kelas tidak memiliki kelemahan yang dijelaskan di atas. </font><font style="vertical-align: inherit;">Overloading hanya efektif ketika membuat dan menghapus instance dari kelas yang sesuai, terlepas dari konteks memohon operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saat menerapkan fungsi yang ditentukan pengguna untuk mengalokasikan dan membebaskan memori menggunakan operator, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda dapat mengakses fungsi standar yang sesuai. </font><font style="vertical-align: inherit;">Pertimbangkan sebuah contoh.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, pelacakan hanya ditambahkan ke operasi standar. </font><font style="vertical-align: inherit;">Sekarang, dalam hal </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menggunakan fungsi-fungsi ini untuk mengalokasikan dan membebaskan memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi-fungsi ini secara formal statis dan dapat dinyatakan sebagai </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Tetapi pada dasarnya mereka adalah instance, dengan pemanggilan fungsi </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, penciptaan instance dimulai, dan pemanggilan fungsi </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyelesaikan penghapusannya. </font><font style="vertical-align: inherit;">Fungsi-fungsi ini tidak pernah dipanggil untuk tugas lain. </font><font style="vertical-align: inherit;">Selain itu, seperti yang akan ditunjukkan di bawah, fungsi </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini pada dasarnya virtual. </font><font style="vertical-align: inherit;">Jadi lebih tepat untuk mendeklarasikannya tanpa </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Akses ke bentuk standar dari operator baru / hapus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat digunakan dengan operator resolusi ruang lingkup tambahan, misalnya </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam hal ini, fungsi yang </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">didefinisikan di kelas akan diabaikan, dan standar yang sesuai akan digunakan. </font><font style="vertical-align: inherit;">Dengan cara yang sama, Anda dapat menggunakan operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Menyembunyikan bentuk lain dari operator baru / hapus</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika sekarang untuk kelas </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami mencoba menggunakan melempar atau tidak melempar pengecualian </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kami mendapatkan kesalahan. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa fungsi </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menyembunyikan bentuk lain </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Masalahnya bisa diselesaikan dengan dua cara. </font><font style="vertical-align: inherit;">Pada yang pertama, Anda perlu menambahkan opsi yang sesuai ke kelas (opsi ini seharusnya hanya mendelegasikan operasi fungsi standar). </font><font style="vertical-align: inherit;">Dalam yang kedua, Anda perlu menggunakan operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan operator resolusi lingkup, misalnya </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Kontainer standar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika kita mencoba menempatkan instance </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam beberapa wadah standar, misalnya </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, kita akan melihat bahwa fungsi kita tidak digunakan untuk mengalokasikan dan mengosongkan memori. </font><font style="vertical-align: inherit;">Faktanya adalah bahwa semua kontainer standar memiliki mekanisme sendiri untuk mengalokasikan dan membebaskan memori (kelas pengalokasi khusus, yang merupakan parameter templat dari wadah), dan mereka menggunakan operator penempatan untuk menginisialisasi elemen </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Warisan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi untuk mengalokasikan dan membebaskan memori diwarisi. Jika fungsi-fungsi ini didefinisikan di kelas dasar, tetapi tidak di yang diturunkan, maka operator akan kelebihan beban untuk kelas turunan </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan fungsi-fungsi yang didefinisikan dan dialokasikan di kelas dasar akan digunakan untuk mengalokasikan dan membebaskan memori. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang pertimbangkan hirarki kelas polimorfik, di mana setiap kelas membebani operator </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sekarang, biarkan instance dari kelas turunan dihapus menggunakan operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">melalui pointer ke kelas dasar. Jika destruktor dari kelas dasar adalah virtual, maka standar menjamin bahwa destruktor dari kelas turunan ini dipanggil. Dalam hal ini </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">pemanggilan fungsi yang </font><font style="vertical-align: inherit;">ditentukan untuk kelas turunan </font><font style="vertical-align: inherit;">ini juga dijamin </font><font style="vertical-align: inherit;">. Jadi, fungsinya </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebenarnya virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Bentuk alternatif fungsi delete () operator</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di kelas (terutama ketika warisan digunakan), kadang-kadang nyaman untuk menggunakan bentuk alternatif fungsi untuk membebaskan memori:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menentukan ukuran elemen (bahkan dalam versi untuk array). </font><font style="vertical-align: inherit;">Formulir ini memungkinkan Anda untuk menggunakan berbagai fungsi untuk mengalokasikan dan mengosongkan memori, tergantung pada kelas turunan tertentu.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Operator pengguna baru / hapus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ dapat mendukung bentuk operator kustom dari </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formulir berikut:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar bentuk-bentuk ini didukung, perlu untuk menentukan fungsi yang sesuai untuk mengalokasikan dan membebaskan memori:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daftar parameter tambahan fungsi alokasi memori tidak boleh kosong dan tidak boleh terdiri dari satu </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, tanda tangannya tidak boleh bertepatan dengan salah satu yang standar. Daftar parameter tambahan di </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus cocok. Argumen yang diteruskan ke operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus sesuai dengan parameter tambahan fungsi alokasi memori. Fungsi kustom </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga bisa dalam bentuk dengan parameter ukuran opsional.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi-fungsi ini dapat didefinisikan di namespace global atau di kelas, tetapi tidak di namespace selain global. Jika mereka didefinisikan dalam namespace global, mereka tidak menggantikan, tetapi overload, fungsi standar mengalokasikan dan membebaskan memori, sehingga penggunaannya dapat diprediksi dan aman, dan fungsi standar selalu tersedia. Jika mereka didefinisikan di kelas, mereka menyembunyikan formulir standar, tetapi akses ke formulir standar dapat diperoleh dengan menggunakan operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ini dijelaskan secara rinci dalam bagian 2.2. </font><font style="vertical-align: inherit;">Formulir </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ditentukan pengguna </font><font style="vertical-align: inherit;">disebut </font><font style="vertical-align: inherit;">penempatan yang ditentukan pengguna </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Mereka tidak boleh bingung dengan operator penempatan standar (tidak mengalokasikan) yang </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dijelaskan dalam bagian 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bentuk operator yang sesuai </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak ada. </font><font style="vertical-align: inherit;">Ada </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dua cara untuk </font><font style="vertical-align: inherit;">menghapus objek yang dibuat menggunakan operator yang ditentukan pengguna </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika fungsi yang ditentukan pengguna </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendelegasikan operasi alokasi memori ke fungsi alokasi memori standar, maka operator standar dapat digunakan </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Jika tidak, Anda harus memanggil destruktor secara eksplisit, dan kemudian fungsi yang ditentukan pengguna </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kompilator memanggil fungsi yang ditentukan pengguna </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya </font><font style="vertical-align: inherit;">dalam </font><font style="vertical-align: inherit;">satu kasus: ketika </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konstruktor melempar pengecualian </font><font style="vertical-align: inherit;">selama operasi operator yang ditentukan pengguna </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini sebuah contoh (dalam lingkup global).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definisi fungsi alokasi memori</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, fungsi pengguna </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi yang didelegasikan sesuai dengan fungsi standar. Terkadang opsi ini berguna, tetapi tujuan utama overloading </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah menciptakan mekanisme baru untuk mengalokasikan / membebaskan memori. Tugas ini tidak sederhana, dan sebelum melakukannya, seseorang harus dengan cermat memikirkan semuanya. Scott Meyers [Meyers1] membahas kemungkinan motif untuk membuat keputusan semacam itu (tentu saja, yang utama adalah efisiensi). Dia juga membahas masalah teknis utama yang terkait dengan implementasi yang benar dari fungsi yang ditentukan pengguna untuk mengalokasikan dan membebaskan memori (menggunakan fungsi</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sinkronisasi multi-utas, penyelarasan). </font><font style="vertical-align: inherit;">Guntheroth memberikan contoh implementasi fungsi alokasi dan deallokasi memori yang didefinisikan pengguna yang relatif sederhana. </font><font style="vertical-align: inherit;">Sebelum membuat versi Anda sendiri, Anda harus mencari solusi yang sudah jadi, sebagai contoh, Anda bisa membawa perpustakaan Pool dari proyek Boost.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Kelas allocator dari kontainer standar</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti disebutkan di atas, kontainer standar menggunakan kelas pengalokasi khusus untuk mengalokasikan dan membebaskan memori. </font><font style="vertical-align: inherit;">Kelas-kelas ini adalah templat parameter wadah dan pengguna dapat menentukan versinya untuk kelas tersebut. </font><font style="vertical-align: inherit;">Motif untuk solusi semacam itu kira-kira sama dengan untuk operator kelebihan muatan </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] menjelaskan cara membuat kelas seperti itu.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliografi</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimalisasi program dalam C ++. </font><font style="vertical-align: inherit;">Metode yang terbukti untuk meningkatkan produktivitas: Per. </font><font style="vertical-align: inherit;">dari bahasa Inggris </font><font style="vertical-align: inherit;">- SPb.: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Penggunaan C ++ secara efektif. </font><font style="vertical-align: inherit;">55 cara pasti untuk meningkatkan struktur dan kode program Anda:: Per. </font><font style="vertical-align: inherit;">dari bahasa Inggris </font><font style="vertical-align: inherit;">- M .: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id490626/index.html">Panduan lengkap untuk data- * atribut HTML</a></li>
<li><a href="../id490628/index.html">Apa yang harus dilakukan ketika CSS memblokir parsing halaman?</a></li>
<li><a href="../id490630/index.html">Memuat NumPy Array dari Disk: Perbandingan memmap () dan Zarr / HDF5</a></li>
<li><a href="../id490634/index.html">Acara digital di Moskow dari 2 hingga 8 Maret</a></li>
<li><a href="../id490636/index.html">Acara digital di St. Petersburg dari 2 hingga 8 Maret</a></li>
<li><a href="../id490642/index.html">Plugin untuk memantau aplikasi K8 DevOpsProdigy KubeGraf v1.3.0: rilis baru dan fitur baru</a></li>
<li><a href="../id490644/index.html">Repositori rpm sederhana menggunakan Inotify dan webdav</a></li>
<li><a href="../id490648/index.html">Menggunakan Kata Containers di Kubernetes</a></li>
<li><a href="../id490650/index.html">Kesalahan utama dalam menyusun CV oleh spesialis IT pemula</a></li>
<li><a href="../id490652/index.html">Logistik. pengantar Hampir rumit</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>