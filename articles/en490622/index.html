<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèø üôÖüèæ üàöÔ∏è Fighting memory leaks in web applications ü§æ üë©üèΩ‚Äçüíª üëçüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When we moved from the development of websites whose pages are formed on the server to the creation of single-page web applications that are rendered ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fighting memory leaks in web applications</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/490622/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When we moved from the development of websites whose pages are formed on the server to the creation of single-page web applications that are rendered on the client, we adopted certain rules of the game. One of them is the accurate handling of resources on the user's device. This means - do not block the main stream, do not ‚Äúspin‚Äù the laptop fan, do not put the phone‚Äôs battery. We exchanged an improvement in the interactivity of web projects, and the fact that their behavior became more like the behavior of ordinary applications, a new class of problems that did not exist in the world of server rendering.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/wv/_c/nl/wv_cnlo46dgs8op0yzhybzgkpw8.jpeg"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One such problem is memory leaks. </font><font style="vertical-align: inherit;">A poorly designed one-page application can easily gobble up megabytes or even gigabytes of memory. </font><font style="vertical-align: inherit;">It is able to take up more and more resources even when it sits quietly on the background tab. </font><font style="vertical-align: inherit;">The page of such an application, after capturing an exorbitant amount of resources, may begin to ‚Äúslow down‚Äù greatly. </font><font style="vertical-align: inherit;">In addition, the browser can simply shut down the tab and tell the user: ‚ÄúSomething went wrong.‚Äù</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34b/e9d/da8/34be9dda87ca7f35d70a1a934816ce78.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Something went wrong</font></font></font></i><br>
<cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, sites that are rendered on the server can also suffer from a memory leak problem. But here we are talking about server memory. At the same time, it is highly unlikely that such applications will cause a memory leak on the client, since the browser clears the memory after each user transition between pages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The topic of memory leaks is not well covered in web development publications. And despite this, I am almost sure that most non-trivial single-page applications suffer from memory leaks - unless the teams that deal with them have reliable tools to detect and fix this problem. The point here is that in JavaScript it is extremely easy to randomly allocate a certain amount of memory, and then just forget to free this memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The author of the article, the translation of which we are publishing today, is going to share with readers his experience in combating memory leaks in web applications, and also wants to give examples of their effective detection.</font></font><br>
<cut></cut><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why is so little written about this?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, I want to talk about why so little is written about memory leaks. </font><font style="vertical-align: inherit;">I suppose here you can find several reasons:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lack of user complaints: most users are not busy closely monitoring the task manager while browsing the web. </font><font style="vertical-align: inherit;">Typically, the developer does not encounter user complaints until the memory leak is so serious that it causes the inability to work or slow down the application.</font></font></li>
<li>  :   Chrome   -   ,     .          .</li>
<li> :            .</li>
<li>      :       ¬´¬ª     .   ,     ,   , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>,   -.</li>
</ul><br>
<h2><font color="#3AC1EF">  </font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modern libraries and frameworks for developing web applications, such as React, Vue and Svelte, use the component model of the application. Within this model, the most common way to cause a memory leak is something like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That's all. </font><font style="vertical-align: inherit;">This is all that is needed to ‚Äúequip‚Äù a project with a memory leak. </font><font style="vertical-align: inherit;">To do this, just call the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">addEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method of </font><font style="vertical-align: inherit;">some global object (like </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or </font></font><code>&lt;body&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, or something similar), and then, when unmounting the component, forget to remove the event listener using the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">removeEventListener</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But the consequences of this are even worse, since the leak of the whole component occurs. </font><font style="vertical-align: inherit;">This is due to the fact that the method is </font></font><code>this.onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">attached to </font></font><code>this</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Along with this component, leakage of its child components occurs. </font><font style="vertical-align: inherit;">It is very likely that all the DOM nodes associated with this component will leak. </font><font style="vertical-align: inherit;">The situation, as a result, can get out of control very quickly, leading to very bad consequences.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's how to solve this problem:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//   </span>
<span class="hljs-keyword">this</span>.onMessage = <span class="hljs-keyword">this</span>.onMessage.bind(<span class="hljs-keyword">this</span>);
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);<font></font>
&nbsp;<font></font>
<span class="hljs-comment">//   </span>
<span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">'message'</span>, <span class="hljs-keyword">this</span>.onMessage);</code></pre><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situations in which memory leaks occur most often</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Experience tells me that memory leaks most often occur when using the following APIs:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Method </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is where memory leaks occur most often. </font><font style="vertical-align: inherit;">To solve the problem, it is enough to call at the right time </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">setTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">setInterval</a>.   ,        (,  30 ),  ,   ,      ,   ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">clearTimeout</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">clearInterval</a>. ,    <code>setTimeout</code>,  ¬´¬ª   ,    ,     <code>setInterval</code>-.  ,    <code>setTimeout</code>       .</li>
<li>API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">IntersectionObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">ResizeObserver</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">MutationObserver</a>   .  ,  ,  .         .     -         ,  ,   ,     ,   ,   <code>disconnect</code>  .    ,     DOM    ,           ,  -.        -,     .  ‚Äî  <code>&lt;body&gt;</code>,  <code>document</code>,   <code>header</code>  <code>footer</code>,     .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">Promise-</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> </a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> </a>      .   ,    ,     ‚Äî   ,      . , ,  ¬´¬ª   ,        .    ¬´¬ª     <code>.then()</code>-.</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositories represented by global objects. </font><font style="vertical-align: inherit;">When you use something like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redux</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to control the state of an application </font><font style="vertical-align: inherit;">, the state store is represented by a global object. </font><font style="vertical-align: inherit;">As a result, if you deal with such storage carelessly, unnecessary data will not be deleted from it, as a result of which its size will constantly increase.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Infinite DOM growth. </font><font style="vertical-align: inherit;">If the page implements endless scrolling without the use of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">virtualization</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this means that the number of DOM nodes on this page can grow unlimitedly.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Above, we examined situations in which memory leaks occur most often, but, of course, there are many other cases that cause the problem of interest to us.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory leak identification</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we have moved on to the challenge of identifying memory leaks. To begin with, I don‚Äôt think that any of the existing tools is very suitable for this. I tried the Firefox memory analysis tools, tried the tools from Edge and IE. Tested even Windows Performance Analyzer. But the best of these tools are still Chrome Developer Tools. True, in these tools there are many "sharp corners", which are worth knowing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Among the tools that the Chrome developer gives, we are most interested in the profiler </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the tab </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, which allows you to create heap snapshots. There are other tools for analyzing memory in Chrome, but I have not been able to extract special benefits from them in detecting memory leaks.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7d/e42/63a/e7de4263abd59eecce420c4bcbfc55ea.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Heap snapshot tool allows you to take snapshots of the memory of the main stream, web workers or iframe elements.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
If the Chrome tool window looks like the one shown in the previous figure, when you click the button</font></font><code>Take snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, information about all objects in the memory of the selected virtual machine is captured JavaScript of the investigated page. This includes objects referenced in</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, objects referenced by the callbacks used in the call</font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and so on. A snapshot of memory can be perceived as a ‚Äúfrozen moment‚Äù of the work of the investigated entity, representing information about all the memory used by this entity.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the picture is taken, we come to the next step of finding leaks. It consists in reproducing a scenario in which, according to the developer, a memory leak may occur. For example, it is opening and closing a certain modal window. After the similar window is closed, it is expected that the amount of allocated memory will return to the level that existed before the window was opened. Therefore, they take another picture, and then compare it with the picture taken earlier. As a matter of fact, comparison of images is the most important feature of interest to us </font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/92d/776/4c7/92d7764c7fbe5d561032c3bc092e1541.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take the first snapshot, then we take actions that can cause a memory leak, and then we take another snapshot. </font><font style="vertical-align: inherit;">If there is no leak, the size of the allocated memory will be equal.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
True, this</font></font><code>Heap snapshot</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is far from an ideal tool. </font><font style="vertical-align: inherit;">It has some limitations worth knowing about:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if you click on the small button on the panel </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that starts garbage collection ( </font></font><code>Collect garbage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), then in order to be sure that the memory is really cleared, you may need to take several consecutive pictures. </font><font style="vertical-align: inherit;">I usually have three shots. </font><font style="vertical-align: inherit;">Here it is worth focusing on the total size of each image - it, in the end, should stabilize.</font></font></li>
<li>    -, -,  <code>iframe</code>,      ,   ,          .   ,        JavaScript.   ‚Äî      ,       ,    .</li>
<li>           ¬´¬ª.             .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this point, if your application is quite complex, you may notice a lot of ‚Äúleaking‚Äù objects when comparing snapshots. </font><font style="vertical-align: inherit;">Here the situation is somewhat complicated, since what can be mistaken for a memory leak is not always the case. </font><font style="vertical-align: inherit;">Much of what is suspicious is just normal processes for working with objects. </font><font style="vertical-align: inherit;">The memory occupied by some objects is cleared to place other objects in this memory, something is flushed to the cache, and so that the corresponding memory is not cleared immediately, and so on.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We make our way through the information noise</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I found that the best way to break through the noise of information is to repeat the actions that are supposed to cause a memory leak. For example, instead of opening and closing the modal window only once after capturing the first shot, this can be done 7 times. Why 7? Yes, if only because 7 is a noticeable prime. Then you need to take a second shot and, comparing it with the first, find out if a certain object ‚Äúleaked‚Äù 7 times (or 14 times, or 21 times).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2a7/ac2/243/2a7ac2243dc82f0e7887b23098e7c893.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare heap snapshots. Please note that we are comparing image No. 3 with image No. 6. The fact is that I took three shots in a row so that Chrome would have more garbage collection sessions. In addition, note that some objects ‚Äúleaked‚Äù 7 times.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Another useful trick is that, at the very beginning of the study, before creating the first picture, perform the procedure once, during which, as expected, memory leak. This is especially recommended if code splitting is used in the project. In such a case, it is very likely that upon the first execution of the suspicious action, the necessary JavaScript modules will be loaded, which will affect the amount of allocated memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now you may have a question about why you should pay special attention to the number of objects, and not to the total amount of memory. Here we can say that we intuitively strive to reduce the amount of "leaking" memory. In this regard, you might think that you should monitor the total amount of memory used. But this approach, for one important reason, does not suit us particularly well. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If something ‚Äúleaks‚Äù, it happens because (retelling </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Joe Armstrong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) you need a banana, but you end up with a banana, the gorilla that holds it, and also, in addition, all the jungle. If we focus on the total amount of memory, it will be the same as ‚Äúmeasuring‚Äù the jungle, and not the banana that interests us.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e8/af8/847/7e8af8847ab7e8689e1638ac218582d6.jpg"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gorilla eating a banana.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Now back to the above example with</font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A leak source is an event listener that references a function. And this function, in turn, refers to a component that, possibly, stores links to a bunch of good stuff like arrays, strings, and objects.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you analyze the difference between the images, sorting the entities by the amount of memory they occupy, this will allow you to see many arrays, lines, objects, most of which are most likely not related to the leak. And after all, we need to find the very event listener from which it all began. He, in comparison with what he refers to, takes up very little memory. In order to fix the leak, you need to find a banana, not the jungle.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, if you sort the records by the number of ‚Äúleaked‚Äù objects, you will notice 7 event listeners. </font><font style="vertical-align: inherit;">And maybe 7 components, and 14 subcomponents, and maybe something else like that. </font><font style="vertical-align: inherit;">This number 7 should stand out from the big picture, since it is, nevertheless, a rather noticeable and unusual number. </font><font style="vertical-align: inherit;">In this case, it does not matter how many times the suspicious action is repeated. </font><font style="vertical-align: inherit;">When examining images, if the suspicions are justified, it will be recorded just as many ‚Äúleaked‚Äù objects. </font><font style="vertical-align: inherit;">This is how you can quickly identify the source of a memory leak.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link Tree Analysis</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The tool for creating snapshots provides the ability to view ‚Äúlink chains‚Äù that help you find out which objects are referenced by other objects. </font><font style="vertical-align: inherit;">This is what allows the application to function. </font><font style="vertical-align: inherit;">By analyzing such ‚Äúchains‚Äù or ‚Äútrees‚Äù of links, you can find out exactly where the memory was allocated for the ‚Äúleaking‚Äù object.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bf/77a/07d/7bf77a07dd2d15e479f77c2279b9942d.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The chain of links allows you to find out which object refers to the "leaky" object. </font><font style="vertical-align: inherit;">When reading these chains, it is necessary to take into account that the objects located in them below refer to the objects located above.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In the above example, there is a variable called</font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">referenced in the closure (</font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) referenced by the event listener. </font><font style="vertical-align: inherit;">If you click on the link leading to the source code, a fairly understandable text of the program will be displayed:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SomeObject</span> () </span>{ <span class="hljs-comment">/* ... */</span> }<font></font>
&nbsp;<font></font>
<span class="hljs-keyword">const</span> someObject = <span class="hljs-keyword">new</span> SomeObject();
<span class="hljs-keyword">const</span> onMessage = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> { <span class="hljs-comment">/* ... */</span> };
<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'message'</span>, onMessage);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we compare this code with the previous figure, it turns out that </font></font><code>context</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the figure is a closure </font></font><code>onMessage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that refers to </font></font><code>someObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artificial example</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Real memory leaks can be much less obvious. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is worth noting that the heap snapshot tool has some limitations:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you save a snapshot file and then upload it again, links to files with code are lost. </font><font style="vertical-align: inherit;">That is, for example, having downloaded a snapshot, it will not be possible to find out that the event listener closure code is on line 22 of the file </font></font><code>foo.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Since this information is extremely important, saving heap snapshot files, or, for example, transferring them to someone, is almost useless.</font></font></li>
<li>     <code>WeakMap</code>,  Chrome       ,      . ,   ,     ,    ,   .    <code>WeakMap</code> ‚Äî     .</li>
<li>Chrome  ,    .  ,        ,     ,     ,     .      ,       <code>object</code>,    <code>EventListener</code>.   <code>object</code> ‚Äî     ,  ,   ,  ¬´¬ª   7  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a description of my basic strategy for identifying memory leaks. </font><font style="vertical-align: inherit;">I have successfully used this technique to detect dozens of leaks. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
True, I must say that this guide to finding memory leaks covers only a small part of what is happening in reality. </font><font style="vertical-align: inherit;">This is just the beginning of the work. </font><font style="vertical-align: inherit;">In addition, you need to be able to handle the installation of breakpoints, logging, testing corrections to determine if they solve the problem. </font><font style="vertical-align: inherit;">And, unfortunately, all this, in essence, translates into a serious investment of time.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automated memory leak analysis</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to start this section with the fact that I could not find a good approach to automating the detection of memory leaks. Chrome has its own </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">performance.memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> API </font><font style="vertical-align: inherit;">, but for privacy reasons, it </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not allow you to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collect sufficiently detailed data. As a result, this API cannot be used in production to detect leaks. The W3C Web Performance Working Group previously discussed </font><font style="vertical-align: inherit;">memory </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tools</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , but its members have yet to agree on a new standard designed to replace this API. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In test environments, you can increase the granularity of data output </font></font><code>performance.memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">using the Chrome flag </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">--enable-precise-memory-info</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Heap snapshots can still be created using the Chromedriver's own team </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: takeHeapSnapshot</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . This team has the same limitations that we have already discussed. It is likely that if you use this command, then, for the reasons described above, it makes sense to call it three times, and then take only what was received as a result of its last call. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since event listeners are the most common source of memory leaks, I‚Äôll talk about another leak detection technique I use. It consists in creating monkey patches for the API </font></font><code>addEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>removeEventListener</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in counting the links to check that their number is returning to zero. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an example of how this is done.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the Chrome Developer Tools, you can also use the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getEventListeners</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> native API </font><font style="vertical-align: inherit;">to find out which event listeners are attached to a particular element. </font><font style="vertical-align: inherit;">This command, however, is available only from the developer toolbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I want to add that Matthias Binens told me about another useful Chrome tools API. </font><font style="vertical-align: inherit;">These are </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">queryObjects</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">With it, you can get information about all objects created using a certain constructor. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> some good material on this topic about automating memory leak detection in Puppeteer.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Searching and fixing memory leaks in web applications is still in its infancy. Here I talked about some techniques that, in my case, performed well. But it should be recognized that the application of these techniques is still fraught with certain difficulties and time-consuming.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As with any performance issues, as they say, a pinch ahead of time is worth a pound. Perhaps someone will find it useful to prepare the appropriate synthetic tests rather than analyze the leak after it has already occurred. And if it‚Äôs not one leak, but several, then the analysis of the problem can turn into something like peeling onions: after one problem is fixed, another is discovered, and then this process repeats (and all this time, like from onions , tears on eyes). Code reviews can also help identify common leak patterns. But this - if you know - where to look.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript is a language that provides secure working with memory. </font><font style="vertical-align: inherit;">Therefore, there is some irony in how easily memory leaks happen in web applications. </font><font style="vertical-align: inherit;">True, this is partly because of the features of the device user interfaces. </font><font style="vertical-align: inherit;">You need to listen to a lot of events: mouse events, scroll events, keyboard events. </font><font style="vertical-align: inherit;">Applying all of these patterns can easily lead to memory leaks. </font><font style="vertical-align: inherit;">But, striving to ensure that our web applications use the memory sparingly, we can increase their performance and protect them from ‚Äúcrashes‚Äù. </font><font style="vertical-align: inherit;">In addition, we thereby demonstrate respect for the resource limits of user devices. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dear readers! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you encountered memory leaks in your web projects?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490610/index.html">Baidu Beats Waymo in California Robomobile Autonomy Rating</a></li>
<li><a href="../en490612/index.html">Functional approach to transactions on Scala or write your own useful monad</a></li>
<li><a href="../en490616/index.html">The digest of fresh materials from the world of the front-end for the last week No. 404 (February 24 - March 1, 2020)</a></li>
<li><a href="../en490618/index.html">Goroutine Stack Buffers</a></li>
<li><a href="../en490620/index.html">When I hear the words "restored the neural network", I climb to check backups</a></li>
<li><a href="../en490624/index.html">Feature-Policy HTTP Header and Web Browser Control</a></li>
<li><a href="../en490626/index.html">A complete guide to data- * HTML attributes</a></li>
<li><a href="../en490628/index.html">What to do when CSS blocks page parsing?</a></li>
<li><a href="../en490630/index.html">Loading NumPy Arrays from Disk: Comparison of memmap () and Zarr / HDF5</a></li>
<li><a href="../en490634/index.html">Digital events in Moscow from March 2 to 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>