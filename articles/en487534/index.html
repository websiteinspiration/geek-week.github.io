<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîâ ‚ûø üëÜüèæ etcd 3.4.3: storage reliability and security research üë∂ üëÉüèæ ü•ñ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Note perev. : The content of this article is not entirely typical of our blog. However, as many people know, etcd is located in the heart of Kubernete...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>etcd 3.4.3: storage reliability and security research</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/487534/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note perev.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The content of this article is not entirely typical of our blog. However, as many people know, etcd is located in the heart of Kubernetes, which is why this study, conducted by an independent consultant in the field of reliability, turned out to be interesting among engineers operating this system. In addition, it is interesting in the context of how Open Source-projects that have already proven themselves in production are being improved even at such a very "low" level.</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/xd/av/d3/xdavd35rjqklgnrnd-0wulkpayo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The key-value (KV)</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etc vault</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is a distributed database based on the Raft consensus algorithm. In an analysis</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conducted in 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we found that etcd 0.4.1 was affected by the so-called stale reads by default</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(read operations that return an old, irrelevant value due to a delay in synchronization - approx. transl.)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We decided to return to etcd (this time - to version 3.4.3) in order to again evaluate in detail its potential in the field of reliability and security.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We have found that operation with pairs of "key-value" strictly serializable and that the processes of the observer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(watches)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> delivered to every change in the order key. </font><font style="vertical-align: inherit;">However, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in etcd are fundamentally unsafe, and the risks associated with them are exacerbated by a bug, as a result of which the relevance of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lease</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is not checked </font><font style="vertical-align: inherit;">after waiting for the lock. </font><font style="vertical-align: inherit;">You can read the comment of the etcd developers on our report </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on the project blog</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The study was sponsored by the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Native Computing Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (CNCF), part of The Linux Foundation. </font><font style="vertical-align: inherit;">It was carried out in full compliance with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen ethical policies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Background</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Etc KV repository is a distributed system designed to be used as a basis for coordination. Like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zookeeper</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consul</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etcd stores small amounts of rarely updated states ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by default up to 8 GB</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) in the form of a key-value map and provides </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strictly serializable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> read, write and microtransactions throughout the data warehouse, as well as coordination primitives like </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">locks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tracking </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(watches)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and leader selection. Many distributed systems, such as </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenStack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , use etcd to store cluster metadata, coordinate coordinated views of data, choose a leader, etc.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In 2014, we already conducted an evaluation of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etcd 0.4.1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Then we found that by default it is prone to stale reads due to optimization. While the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">work on Raft principles</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> discusses the need to split read operations into threads and pass them through a consensus system to ensure viability, etcd reads on any leader locally without checking for a more current state on the newer leader. The etcd development team implemented the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">optional quorum flag</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and in the etcd version 3.0 API </font><font style="vertical-align: inherit;">, </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">linearizability</font></a><font style="vertical-align: inherit;"> for all operations except tracking operations </font><font style="vertical-align: inherit;">appeared </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">by default</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">
The etcd 3.0 API concentrates on a KV flat map where the keys and values ‚Äã‚Äãare opaque</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opaque</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> byte arrays. Using range queries, you can simulate hierarchical keys. Users can read, write and delete keys, as well as monitor the flow of updates for a single key or range of keys. The etcd toolkit is complemented by leases (variable objects with a limited lifetime, which are maintained in the active state by heartbeat-requests of the client), locks (dedicated named objects bound to leases) and the choice of leaders. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In version 3.0, etcd offers a limited </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transactional API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for atomic operations with many keys. </font><font style="vertical-align: inherit;">In this model, a transaction is a conditional expression with a predicate, a true branch, and a false branch. </font><font style="vertical-align: inherit;">A predicate can be a conjunction of several key comparisons: equality or various inequalities, according to versions of one key, global revision etcd, or the current key value. </font><font style="vertical-align: inherit;">True and false branches may include multiple read and write operations; </font><font style="vertical-align: inherit;">all of them are applied atomically depending on the result of predicate estimation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1 Guarantees of consistency in documentation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As of October 2019, the </font><font style="vertical-align: inherit;">etcd </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">documentation for the API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> states that ‚Äúall API calls demonstrate consistent consistency ‚Äî the strongest form of consistency guarantee available on distributed systems.‚Äù This is not so: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consistent consistency is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> strictly weaker than </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearizability</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and linearizability is definitely achievable in distributed systems. Further, the documentation states that ‚Äúduring the read operation, etcd does not guarantee the transfer of [the most recent (measured by the external clock following the completion of the query)] value available on any member of the cluster‚Äù. This is also a too conservative statement: if etcd provides linearizability, read operations are always associated with the most recent committed state in linearization order. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The documentation also claims that etcd guarantees </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">serializable isolation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: all operations (even those that affect several keys) are performed in some general order. The authors describe serializable isolation as ‚Äúthe strongest isolation level available in distributed systems.‚Äù This (depending on what you mean by the ‚Äúisolation level‚Äù) is also not true; strict serializability is stronger than simple serializability, while the former is also achievable in distributed systems. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The documentation says that all operations (except tracking) in etcd are linearizable by default. In this case, linearizability is defined as consistency with weakly synchronized global clocks. It should be noted that such a definition is not only incompatible with the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">definition of linearizability</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Herlihy &amp; Wing, but also implies a violation of causality: nodes with leading hours will try to read the results of operations that have not even begun. We assume that etcd is still not a time machine, and since it is based on the Raft algorithm, the generally accepted definition of linearizability should be applied. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since KV operations in etcd are serializable and linearizable, we think that in fact etcd provides </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strict serialization</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by default </font><font style="vertical-align: inherit;">. This makes sense, since all keys etcd are in a single state machine, and Raft provides complete ordering of all operations on this state machine. In fact, the entire etcd dataset is a single linearizable object. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optional flag </font></font><code>serializable</code> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lowers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The level of read operations from strict to regular serializable consistency, allowing reading of an outdated committed state. </font><font style="vertical-align: inherit;">Note that the flag </font></font><code>serializable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not affect the serializability of the story; </font><font style="vertical-align: inherit;">KV operations etcd are serializable in all cases.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Test development</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To create </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a test suite,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we used the appropriate </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen library</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The version etcd 3.4.3 (the latest as of October'19) was analyzed, working on Debian Stretch clusters consisting of 5 nodes. We have implemented a number of faults in these clusters, including network partitions, isolating individual nodes, partitioning the cluster into a majority and a minority, as well as non-transitive partitions with an overlapping majority. They ‚Äúdropped‚Äù and suspended random subsets of nodes, and also deliberately disabled leaders. Temporal distortions of up to several hundred seconds were introduced, both at multisecond intervals and at millisecond ones (fast ‚Äúflicker‚Äù). Since etcd supports dynamically changing the number of components, we randomly added and removed nodes during testing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Test loads included registers, sets, and transactional tests for checking operations on KV, as well as specialized loads for locks and watches.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1 Registers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To evaluate the reliability of etcd during KV operations, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">register test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was developed </font><font style="vertical-align: inherit;">during which random read, write, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compare-and-set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operations were performed </font><font style="vertical-align: inherit;">on unit keys. </font><font style="vertical-align: inherit;">The results were </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">evaluated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">Knossos</font></a><font style="vertical-align: inherit;"> linearizability tool </font><font style="vertical-align: inherit;">using the comparison / installation register model and version information.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2 Sets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To quantify stale reads, a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was developed </font><font style="vertical-align: inherit;">that used a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">compare-and-set</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transaction </font><font style="vertical-align: inherit;">to read a set of integers from a single key and then add a value to this set. </font><font style="vertical-align: inherit;">During the test, we also carried out a parallel reading of the entire set. </font><font style="vertical-align: inherit;">After completion of the test, the results were analyzed for the occurrence of cases when the element, which was known to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">be</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> present in the set, was absent in the reading results. </font><font style="vertical-align: inherit;">These cases were used to quantify stale reads and lost updates.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.3 Append Test</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To verify strict serializability, an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">append test</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was developed </font><font style="vertical-align: inherit;">during which transactions were read in parallel and added values ‚Äã‚Äãto lists consisting of unique sets of integers. Each list was stored in one etcd key, and additions were made within each transaction, reading </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">each key that needed to be changed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in one transaction, and then </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">these keys were written and reads were performed</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the second transaction, which </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was protected</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to ensure that no recorded key has changed since the first read. </font><font style="vertical-align: inherit;">At the end of the test, we plotted the relationship between transactions based on real-time priority and the relationship of read and add operations. </font><font style="vertical-align: inherit;">Checking this graph for loops made it possible to determine whether the operations were strictly serializable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
While etcd prevents transactions from writing the same key multiple times, you can create transactions with up to one record per key. </font><font style="vertical-align: inherit;">We also made sure that read operations within the same transaction reflected previous write operations from the same transaction.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.4 Locks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a coordination service, etcd promises built-in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">support for distributed locking</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We investigated these locks in two ways. At first, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">randomized lock and unlock requests were</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generated </font><font style="vertical-align: inherit;">, receiving a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lease for each lock and leaving it open</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> using the built-in </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">etc</font></a><font style="vertical-align: inherit;"> client in the Java client </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><code> keepalive</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">until </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">released</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We tested the results with Knossos to see if they form a linearized implementation of the lock service. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For a more practical test (and to quantify the frequency of lock failures), we used locks and etcd to organize </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mutual exclusion when making updates to the set in in-memory</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and searched for lost updates in this set. </font><font style="vertical-align: inherit;">This test allowed us to directly confirm whether systems using etcd as a mutex can safely update the internal state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The third version of the lock test involved </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">guards on the lease key</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to modify the set stored in etcd.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5 Tracking</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to verify that the watchs provide information about each key update, one key was created as part of the test and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">blindly assigned</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> unique integer values. </font><font style="vertical-align: inherit;">Meanwhile, customers shared </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this key</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for several seconds at a time. </font><font style="vertical-align: inherit;">Each time after the initiation of the watch, the client began with the revision on which it had stopped the last time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of this process, we </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">made sure</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that each client observed the same sequence of key changes.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. Results</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1 Tracking from the 0th revision</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When tracking a key, clients can specify an </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">initial revision</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which is ‚Äúan optional revision with which tracking starts (inclusively)‚Äù. If the user wants to see each operation with a certain key, he can specify the first revision of etcd. What is this audit? </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The data model</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glossary</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do not provide an answer to this question; revisions are described as monotonically increasing 64-bit counters, but it is unclear whether etcd starts from 0 or 1. It is reasonable to assume that the countdown is from scratch (just in case). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alas, this is wrong. Requesting the 0th revision causes etcd to start broadcasting updates, starting with the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current revision on the server plus one</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but not with the very first. </font><font style="vertical-align: inherit;">The request for the 1st revision gives all the changes. </font><font style="vertical-align: inherit;">This behavior is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">not documented anywhere</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We believe that in practice this subtlety is unlikely to lead to problems in production, since most clusters do not linger on the first revision. </font><font style="vertical-align: inherit;">In addition, etcd compresses the story anyway over time, so in real-world applications, most likely, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in any case, it</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not require reading all versions, starting with the 1st revision. </font><font style="vertical-align: inherit;">Such behavior is justified, but it would not hurt the corresponding description in the documentation.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2 Mythical locks</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The API documentation for locks</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> states that a locked key "can be used in conjunction with transactions to ensure that updates in etcd occur only when the lock is owned." Strange, but it does not provide any guarantees for the locks themselves and their purpose is not explained. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, in other materials, maintainers etcd still share information about the use of locks. For example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the etcd 3.2 release announcement</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> describes an application </font></font><code>etcdctl</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for blocking file sharing changes on a disk. In addition, in an issue on GitHub with a question about the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specific purpose of the locks,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> one of the etcd developers answered the following:</font></font><br>
<br>
<blockquote>     etcd  ,   (  )        ,     (        etcd), - :<br>
<br>
<ol>
<li>    etcd;</li>
<li>  - ( ,     etcd);</li>
<li>    .</li>
</ol></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just such an example is given in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><code>  etcdctl</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: a lock was used to protect the team </font></font><code>put</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but did not bind the lock key to the update. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alas, this is not safe because it allows multiple clients to simultaneously hold the same lock. The problem is aggravated by the suspension of processes, network crashes or partitions, however, it can also occur in completely healthy clusters without any external failures. For example, in this </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">test run,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> process number 3 successfully sets the lock, and process 1 gets the same lock in parallel even before process 3 has the opportunity to remove it:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ko/hy/lz/kohylznbfb8bh5a2m1l88kysrg4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The mutex violation was most noticeable on leases with short TTLs: TTLs of 1, 2, and 3 seconds were not able to provide mutual exclusion after only a few minutes of testing (even in healthy clusters). Process suspensions and network partitions led to problems even faster. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In one of our lock-test variants, etcd mutexes were used to protect joint updates of a set of integers (as the documentation etcd suggests). Each update reads the current in-memory sample value, and, after about one second, writes this collection back with the addition of a unique element. With leases with a two-second TTL, five parallel processes, and a process pause every five seconds, we were able to cause a steady loss of about 18% of confirmed updates.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This problem was exacerbated by the internal locking mechanism in etcd. If a client waited for another client to unlock it, lost its lease, and after that the lock was released, the server </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">did not double-check lease</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to make sure it is still valid before informing the client that the lock is now behind it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The inclusion of an additional lease check, as well as the selection of longer TTLs and careful setting of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">election</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> timeouts, will reduce the frequency of this problem. However, mutex violations cannot be completely eliminated, since distributed locks are fundamentally unsafe in asynchronous systems. Dr. Martin Kleppmann convincingly describes this in </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">his article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About distributed locks. According to him, blocking services must sacrifice correctness in order to maintain viability in asynchronous systems: if the process crashes while controlling the blocking, the blocking service needs some way to force the blocking to be unlocked. However, if the process actually did not fall, but simply runs slowly or is temporarily unavailable, unlocking it can lead to it being held in several places at the same time.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But even if the distributed blocking service uses, say, some kind of magic failure detector and can actually guarantee mutual exclusion, in the case of some non-local resource, its use will still be unsafe. Suppose process A sends a message to database D while holding a lock. After that, process A crashes, and process B receives a lock and also sends a message to base D. The problem is that a message from process A (due to asynchrony) can come after a message from process B, violating the mutual exception that the lock was supposed to provide. . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To prevent this problem, it is necessary to rely on the fact that </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the storage system itself</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will support the correctness of transactions or, if the locking service provides such a mechanism, use</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fencing‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> token</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that will be included in all operations performed by the lock holder. It will ensure that no operations of the previous lock holder occur suddenly between operations of the current lock owner. For example, in </font><font style="vertical-align: inherit;">Google‚Äôs </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chubby blocking service,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> these tokens are called </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequencers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In etcd, you can use the lock key revision as a globally ordered blocking token. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, lock keys in etcd can be used to protect transactional updates in etcd itself. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Checking the lock key version as part of the transaction</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, users can prevent a transaction if the lock is no longer held (i.e. the lock key version is greater than zero). </font><font style="vertical-align: inherit;">In our tests, this approach allowed us to successfully isolate read-modify-write operations in which the write was the only transaction protected by locking. </font><font style="vertical-align: inherit;">This approach provides isolation similar to barrage tokens, but (like barrage tokens) does not guarantee atomicity: a process may crash or lose a mutex during an update consisting of many operations, leaving etcd in a logically inconsistent state. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The results of work in the issues of the project:</font></font><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Watches beginning at revision 0 start later</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - not decided;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Locks return after blocking without checking ownership</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - in master;</font></font></li>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Locks are not documented as unsafe</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - not solved.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Discussion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our tests, etcd 3.4.3 lived up to expectations regarding KV operations: we observed strictly serializable consistency of read, write, and even multi-key transactions, despite the suspension of processes, crashes, manipulation of the clock and network, as well as a change in the number of cluster members . </font><font style="vertical-align: inherit;">Strictly serializable behavior was implemented by default in KV operations; </font><font style="vertical-align: inherit;">performance of readings with the flag </font></font><code>serializable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set led to the appearance of stale reads (as described in the documentation). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Monitor </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(watches)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to work correctly - at least on the individual keys. </font><font style="vertical-align: inherit;">Until the compression of the history destroyed the old data, the watch successfully issued each key update.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, it turned out that locks in etcd (like all distributed locks) do not provide mutual exclusion. Different processes can hold the lock at the same time - even in healthy clusters with perfectly synchronized clocks. The documentation with the locking API did not say anything about this, and the examples of locks presented were unsafe. However, some of the problems with the locks had to go after the release of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this patch</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result of our collaboration, the etcd team made a number of amendments to the documentation (they have already appeared on GitHub and will be published in future versions of the project website). The GitHub Warranties API page now states that by default etcd is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strictly serializable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the claim that serial and serializable are the strongest levels of consistency available in distributed systems has been removed. With regard to revisions, it is now indicated that the start should be </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from unit (1)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , although the API documentation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">still does not say</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that an attempt to start from the 0th revision will result in ‚Äúoutputting events that occurred after the current revision plus 1‚Äù instead of the expected "dispatch of all events." Documentation of lock security issues is </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">under development</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Some documentation changes, such as describing the special behavior of etcd when trying to read, starting with a zero revision, still require attention.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As usual, we emphasize that Jepsen prefers an experimental approach to security verification: we can confirm the presence of bugs, but not their absence. </font><font style="vertical-align: inherit;">Considerable efforts are being made to find problems, but we cannot prove the general correctness of etcd.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.1 Recommendations</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you use locks in etcd, think about whether you need them for security or to simply increase performance by probabilisticly limiting concurrency. Etcd locks can be used to increase performance, but using them for security purposes can be risky. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In particular, if you use the etcd lock to protect a shared resource such as a file, database or service, this resource should guarantee security </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">without</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> blocking. One way to achieve this is to use a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">monotonous barrage token</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It may be, for example, an etcd revision associated with the current held lock key. The shared resource must ensure that once the client has used the token</font></font><code>y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to perform some operation, any operation with a token </font></font><code>x &lt; y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be rejected. This approach does not ensure atomicity, but it does guarantee that operations within the framework of locking are performed in order, and not intermittently. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We suspect that ordinary users are unlikely to encounter this problem. But if you still </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rely</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on reading all the changes from etcd, starting with the first revision, remember that you need to pass 1, not 0 as a parameter. Our experiments show that a zero revision in this case means "current revision", not "Earliest."</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, locks and etcd (like all distributed locks) mislead users: they may want to use them as regular locks, but they will be very surprised when they realize that these locks do not provide mutual exclusion. </font><font style="vertical-align: inherit;">The API documentation, blog posts, issues on GitHub don't say anything about this risk. </font><font style="vertical-align: inherit;">We recommend that you include information in the etcd documentation that locks do not provide mutual exclusion and provide examples of using barrage tokens to update the status of shared resources instead of examples that could lead to loss of updates.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.2 Further plans</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The etcd project has been considered stable for several years: the Raft algorithm based on it has worked well, the API for KV operations is simple and straightforward. Although some additional features have recently received a new API, its semantics are relatively simple. We believe that we have already studied enough basic commands like </font></font><code>get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>put</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, transactions, blocking and tracking. However, there are other tests that should be performed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the moment, we have not conducted a sufficiently detailed assessment of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deletions.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: There may be boundary cases associated with versions and revisions, when objects are constantly created and deleted. In future tests, we intend to subject the removal operations to more careful study. We also did not test range queries or tracking operations with multiple keys, although we suspect that their semantics are similar to operations with single keys. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the tests, we used the suspension of processes, crashes, manipulations with the clock, the network was divided and the composition of the cluster changed; behind the scenes there were problems like disk damage and other </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byzantine failures</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> at the level of one node. These opportunities may be explored in future research. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The work was supported by the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cloud Native Computing Foundation.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, part of </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Linux Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and complies with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jepsen's ethical policies</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">We would like to thank the etcd team for their help, and the following representatives in particular: Chris Aniszczyk, Gyuho Lee, Xiang Li, Hitoshi Mitake, Jingyi Hu and Brandon Philips.</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS from the translator</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Read also in our blog:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TiKV - distributed key-value database for cloud native</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zetcd from CoreOS: Replacing ZooKeeper with ... storage etcd</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ";</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äú </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KeyDB as a [potential] replacement for Redis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Databases and Kubernetes (review and video report)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ."</font></font></li>
</ul></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487516/index.html">Hunting techniques and tactics of attackers using Prefetch files</a></li>
<li><a href="../en487518/index.html">Radioactive products. Gamma spectrometer. Part 2</a></li>
<li><a href="../en487522/index.html">We make the terminal fly (part 1)</a></li>
<li><a href="../en487524/index.html">Why does a hardware startup hackathon need</a></li>
<li><a href="../en487528/index.html">–ò–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–º —Å–æ–≥–ª–∞—à–µ–Ω–∏–∏ –∏ –ø–æ–ª–∏—Ç–∏–∫–µ –∫–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ—Å—Ç–∏ –Ω–∞ —Å–µ—Ä–≤–∏—Å–∞—Ö –•–∞–±—Ä–∞</a></li>
<li><a href="../en487538/index.html">.NET Interactive is here! | .NET Notebooks Preview 2</a></li>
<li><a href="../en487540/index.html">HighLoad ++, Anastasia Tsymbalyuk, Stanislav Tselovalnikov (Sberbank): how we became MDA</a></li>
<li><a href="../en487542/index.html">PRESENT - Ultra-Lightweight Block Encryption (translation of the original PRESENT: An Ultra-Lightweight Block Cipher)</a></li>
<li><a href="../en487544/index.html">.NET Documentation: What's New for January</a></li>
<li><a href="../en487548/index.html">New Experiment: Calling .NET gRPC Services from a Browser with gRPC-Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>