<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 👩🏾‍🔬 🌏 Hash + caché: optimización de procesamiento de flujo 👨🏽‍💻 🌽 👨🏿‍🤝‍👨🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="¿Qué debo hacer si quiero escribir muchos "hechos" en la base de datos de un volumen mucho mayor de lo que puede soportar? Primero, por supuesto, llev...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Hash + caché: optimización de procesamiento de flujo</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/498830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¿Qué debo hacer si quiero escribir muchos "hechos" en la base de datos de un volumen mucho mayor de lo que puede soportar? Primero, por supuesto, llevamos los datos a una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forma normal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> más económica </font><font style="vertical-align: inherit;">y obtenemos "diccionarios", que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">escribiremos una vez</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero, ¿cómo hacerlo de manera más efectiva? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es exactamente la pregunta que enfrentamos al desarrollar la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supervisión y el análisis de los registros del servidor PostgreSQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , cuando </font><font style="vertical-align: inherit;">se agotaron </font><font style="vertical-align: inherit;">otros </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">métodos para optimizar el registro en la base de datos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/0y/34/cp/0y34cps5t4nqozitxa0xb7urypm.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Haremos </font><font style="vertical-align: inherit;">
una reserva de inmediato para que nuestros recolectores estén ejecutando </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Node.js</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que no interactuamos con registros de procesador y cachés de ninguna manera. </font><font style="vertical-align: inherit;">Y la opción de utilizar "cientos" o servicios / bases de datos de almacenamiento en caché externo da demasiado retraso para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las transmisiones entrantes de varios cientos de Mbps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, tratamos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">almacenar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en </font><b><font style="vertical-align: inherit;">caché todo en RAM</font></b><font style="vertical-align: inherit;"> , específicamente en la memoria del proceso de JavaScript. </font><font style="vertical-align: inherit;">Sobre cómo organizar esto de manera más eficiente, e iremos más allá.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caché de disponibilidad</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nuestra tarea principal es asegurarnos de que la única instancia de cualquier objeto ingrese a la base de datos. Estos son los textos originales repetidamente repetidos de consultas SQL, plantillas de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planes para su implementación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nodos de estos planes, en resumen, algunos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bloques de texto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Históricamente, como identificador, utilizamos un </font></font><code>UUID</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor -valor, que se obtuvo como resultado del cálculo directo del </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hash MD5 a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir del texto del objeto. Después de eso, verificamos la disponibilidad de dicho hash en el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"diccionario"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> local </font><b><font style="vertical-align: inherit;">en la memoria del proceso</font></b><font style="vertical-align: inherit;"> , y si no está allí, solo entonces escribimos en la base de datos en la tabla "diccionario".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, no necesitamos almacenar el valor del texto original en sí (y a veces toma decenas de kilobytes), solo el </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hecho de la presencia del hash correspondiente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en el diccionario </font><font style="vertical-align: inherit;">es suficiente </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diccionario clave</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dicho diccionario se puede guardar </font></font><code>Array</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y usar </font></font><code>Array.includes()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para verificar la disponibilidad, pero esto es bastante redundante: la búsqueda se degrada (al menos en versiones anteriores de V8) linealmente desde el tamaño de la matriz, O (N). </font><font style="vertical-align: inherit;">Y en las implementaciones modernas, a pesar de todas las optimizaciones, pierde a una velocidad del 2-3%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, en la era anterior a ES6, el almacenamiento era la solución tradicional </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, con valores almacenados como claves. </font><font style="vertical-align: inherit;">Pero todos asignaron los valores de las teclas a lo que él quería, por ejemplo </font></font><code>Boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> dict = {};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">has</span>(<span class="hljs-params">key</span>) </span>{
  <span class="hljs-keyword">return</span> dict[key] !== <span class="hljs-literal">undefined</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">key</span>) </span>{<font></font>
  dict[key] = <span class="hljs-literal">true</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero es bastante obvio que claramente estamos almacenando el exceso aquí: el valor de la clave que nadie necesita. Pero, ¿y si no se almacena en absoluto? Entonces apareció el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objeto Set</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las pruebas muestran que la búsqueda con ayuda es </font></font><code>Set.has()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aproximadamente un 20-25% más rápida que la verificación clave c </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Pero esta no es su única ventaja. Dado que almacenamos menos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deberíamos necesitar menos memoria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y esto afecta directamente el rendimiento cuando se trata de cientos de miles de tales claves. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, </font></font><code>Object</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el que hay 100 claves UUID en una representación de texto, ocupa </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.216 bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> en memoria </font><font style="vertical-align: inherit;">: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/1e/n6/ge/1en6gefozucw86wki6odp-j3ria.png"><br>
<br>
<code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">con el mismo contenido - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.632 bytes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ri/59/cb/ri59cbgqbmmbqhivlopro2gspuu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
es decir, </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona más rápido y al mismo tiempo toma</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.5 veces menos memoria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : el ganador es obvio.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimizamos el almacenamiento de claves UUID</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, en la naturaleza de los sistemas distribuidos, las claves UUID son bastante comunes: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en nuestro VLSI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , como mínimo, se utilizan para identificar documentos y regulaciones en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la gestión de documentos electrónicos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , personas en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mensajería</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora echemos un vistazo más de cerca a la imagen de arriba: cada UUID es la clave almacenada en la representación hexadecimal "nos cuesta" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">56 bytes de memoria</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pero tenemos cientos de miles de ellos, por lo que es razonable preguntar: "¿Es posible tener menos?" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero, recuerde que el UUID es un identificador de 16 bytes. Esencialmente una pieza de datos binarios. Y para la transmisión por correo electrónico, por ejemplo, los datos binarios están codificados en </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base64</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; intente aplicarlos:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'base64'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/pd/jc/ks/pdjckslsoycw92xnx4moahgmweg.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya 48 bytes cada uno es mejor, pero imperfecto. </font><font style="vertical-align: inherit;">Intentemos traducir la representación hexadecimal directamente en una cadena:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> str = Buffer.from(uuidstr, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);</code></pre><br>
<img src="https://habrastorage.org/webt/6i/nn/_5/6inn_5k8y3pnogatsv-r5ntrdzo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En lugar de 56 bytes por clave, ¡40 bytes, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ahorrando casi un 30%</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> !</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maestro, trabajador: ¿dónde almacenar los diccionarios?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teniendo en cuenta que los datos de vocabulario de los trabajadores se cruzan con bastante fuerza, hicimos el almacenamiento de diccionarios y los escribimos en la base de datos en el proceso maestro, y la transmisión de datos de los trabajadores a través </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">del mecanismo de mensajes IPC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, una parte importante del tiempo del maestro se gastó en </font></font><code>channel.onread</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, es decir, procesar la recepción de paquetes con información de "diccionario" de procesos secundarios:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/kr/nr/sdkrnrm1c_amswktwm57kl3qsfo.png"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conjunto doble barrera de escritura</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora pensemos por un segundo: los trabajadores envían y envían al maestro los mismos datos de vocabulario (básicamente estas son las plantillas de plan y los cuerpos de solicitud repetitivos), los analiza con sudor y ... no hace nada, porque ya se han enviado a la base de datos antes ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, si </font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"protegimos" la base de datos de la grabación del maestro con un diccionario, ¿por qué no usar el mismo enfoque para "proteger" al maestro de ser transferido del trabajador? ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, eso se hizo y </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redujo los costos directos de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> servicio del canal de intercambio </font><b><font style="vertical-align: inherit;">tres veces</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y1/h4/aj/y1h4ajs-o3hdg1xfoyf9j_kflpc.png"><br>
<br>
<img src="https://habrastorage.org/webt/vl/be/na/vlbenalj_sd_2jk36xdkhaouhp8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero ahora los trabajadores parecen hacer más trabajo: ¿almacenar diccionarios y filtrar por ellos? </font><font style="vertical-align: inherit;">¿O no? De hecho, comenzaron a funcionar significativamente menos, ya que la transferencia de grandes volúmenes (¡incluso a través de IPC!) No es barata.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/dz/7k/mb/dz7kmbdj5jnirhajahmwrpcwzfw.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonito bono</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dado que el asistente ahora comenzó a recibir una cantidad mucho menor de información, comenzó a asignar mucha menos memoria para estos contenedores, lo que significa que el tiempo dedicado al trabajo del recolector de basura disminuyó significativamente, lo que afectó positivamente la latencia del sistema en su conjunto.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fg/af/el/fgafel26_6der0h-knhglqckt8k.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tal esquema proporciona protección contra entradas repetidas a nivel de coleccionista, pero ¿qué pasa si tenemos varios coleccionistas? </font><font style="vertical-align: inherit;">Solo el gatillo con ayudará aquí </font></font><code>INSERT ... ON CONFLICT DO NOTHING</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acelerar el cálculo de hash</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestra arquitectura, todo el flujo de registro de un servidor PostgreSQL es procesado por un trabajador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es decir, un servidor es una tarea para el trabajador. Al mismo tiempo, la carga de trabajadores se equilibra con el propósito de las tareas del servidor, de modo que el consumo de CPU por parte de los trabajadores de todos los recolectores es aproximadamente el mismo. Este es un despachador de servicios por separado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
"En promedio", cada trabajador maneja docenas de tareas que producen aproximadamente la misma carga total. Sin embargo, hay servidores que superan significativamente el resto en la cantidad de entradas de registro. E incluso si el despachador deja esta tarea como la única en el trabajador, su descarga es mucho mayor que las demás:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ol/p1/9a/olp19ahpqzn4e5aaek0oyg1tjt0.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eliminamos el perfil de CPU de este trabajador: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2q/zk/fs/2qzkfsaqceti_tietxizjhfmioi.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
en las líneas superiores, el cálculo de los hash MD5. </font><font style="vertical-align: inherit;">Y realmente se calculan una gran cantidad, para todo el flujo de objetos entrantes.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¿Cómo optimizar esta parte, a excepción de estos hash, no podemos? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decidimos probar otra función hash: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxHash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que implementa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un algoritmo hash no criptográfico extremadamente rápido</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y el módulo para Node.js es </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">xxhash-addon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que utiliza la última versión de la biblioteca xxHash 0.7.3 con el nuevo algoritmo XXH3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verifique ejecutando cada opción en un conjunto de filas de diferentes longitudes:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">'crypto'</span>);
<span class="hljs-keyword">const</span> { XXHash3, XXHash64 } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'xxhash-addon'</span>);
<span class="hljs-keyword">const</span> hasher3 = <span class="hljs-keyword">new</span> XXHash3(<span class="hljs-number">0xDEADBEAF</span>);
<span class="hljs-keyword">const</span> hasher64 = <span class="hljs-keyword">new</span> XXHash64(<span class="hljs-number">0xDEADBEAF</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> buf = Buffer.allocUnsafe(<span class="hljs-number">16</span>);
<span class="hljs-keyword">const</span> getBinFromHash = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> buf.fill(hash, <span class="hljs-string">'hex'</span>).toString(<span class="hljs-string">'binary'</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> funcs = {
  <span class="hljs-attr">xxhash64</span> : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher64.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">xxhash3</span>  : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> hasher3.hash(Buffer.from(str)).toString(<span class="hljs-string">'binary'</span>)<font></font>
, <span class="hljs-attr">md5</span>      : <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> getBinFromHash(crypto.createHash(<span class="hljs-string">'md5'</span>).update(str).digest(<span class="hljs-string">'hex'</span>))<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">const</span> check = <span class="hljs-function">(<span class="hljs-params">hash</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> log = [];
  <span class="hljs-keyword">let</span> cnt = <span class="hljs-number">10000</span>;
  <span class="hljs-keyword">while</span> (cnt--) log.push(crypto.randomBytes(cnt).toString(<span class="hljs-string">'hex'</span>));<font></font>
<font></font>
  <span class="hljs-built_in">console</span>.time(hash);<font></font>
  log.forEach(funcs[hash]);<font></font>
  <span class="hljs-built_in">console</span>.timeEnd(hash);<font></font>
};<font></font>
<font></font>
<span class="hljs-built_in">Object</span>.keys(funcs).forEach(check);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultados:</font></font><br>
<pre><code class="plaintext hljs">xxhash64 : 148.268ms<font></font>
xxhash3  : 108.337ms<font></font>
md5      : 317.584ms<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como se </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperaba</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ¡xxhash3 fue </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho más rápido que MD5</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Queda por comprobar la resistencia a las colisiones. </font><font style="vertical-align: inherit;">Se crean secciones de tablas de diccionarios para nosotros todos los días, por lo que fuera de los límites del día podemos permitir la intersección de hashes de forma segura. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero por si acaso, lo verificamos con un margen en el intervalo de tres días, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ni un solo conflicto</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que nos convenga más que suficiente.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reemplazo de hash</font></font></h4><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/3d/rz/ga/3drzgasyjhevujtp-etsjcwlnz8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pero simplemente no podemos tomar y cambiar los antiguos campos de UUID en el nuevo hash en las tablas del diccionario, porque tanto la base de datos como la interfaz existente esperan que los objetos continúen siendo identificados por UUID. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, agregaremos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">una caché más</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al recopilador </font><font style="vertical-align: inherit;">, para MD5 ya calculado. Ahora será un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mapa</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , en el que las claves son xxhash3, los valores son MD5. Para líneas idénticas, no volvemos a contar el MD5 "caro", sino que lo tomamos del caché:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> getHashFromBin = <span class="hljs-function">(<span class="hljs-params">bin</span>) =&gt;</span> Buffer.from(bin, <span class="hljs-string">'binary'</span>).toString(<span class="hljs-string">'hex'</span>);
<span class="hljs-keyword">const</span> dictmd5 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
<span class="hljs-keyword">const</span> getmd5 = <span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> hash = xxhash(data);
  <span class="hljs-keyword">let</span> md5hash = dictmd5.get(hash);
  <span class="hljs-keyword">if</span> (!md5hash) {<font></font>
    md5hash = md5(data);<font></font>
    dictmd5.set(hash, getBinFromHash(md5hash));<font></font>
    <span class="hljs-keyword">return</span> md5hash;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> getHashFromBin(md5hash);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eliminamos el perfil: la fracción del tiempo para calcular hashes ha disminuido notablemente, ¡salud! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/el/5q/ce/el5qcei3ahbakyyerswutw2rulk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces ahora contamos xxhash3, luego verificamos el caché MD5 y obtenemos el MD5 deseado, y luego verificamos el caché del diccionario; si este md5 no está allí, envíelo a la base de datos para su escritura. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algo que demasiadas comprobaciones ... ¿Por qué comprobar la memoria caché del diccionario si ya ha verificado la memoria caché MD5? </font><font style="vertical-align: inherit;">Resulta que todos los cachés de diccionario ya no son necesarios y es suficiente tener solo un caché, para MD5, con el que se realizarán todas las operaciones básicas: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wl/e_/uc/wle_ucs0o22wpxmrjlg_2sokzvm.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, reemplazamos la verificación en varios diccionarios de "objetos" con un caché MD5, y la operación de cálculo intensivo de recursos MD5 es intensiva El hash se realiza solo para nuevas entradas, utilizando el xxhash mucho más eficiente para la transmisión entrante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
gracias</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kilor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> por ayuda en la preparación del artículo.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es498816/index.html">La verdad en primer lugar, o por qué el sistema debe diseñarse en función del dispositivo de la base de datos</a></li>
<li><a href="../es498820/index.html">Algunas preguntas más difíciles sobre .NET y C #</a></li>
<li><a href="../es498822/index.html">Desarrollo y creación desde cero de una máquina arcade para cuatro jugadores.</a></li>
<li><a href="../es498826/index.html">SIL y Salesforce</a></li>
<li><a href="../es498828/index.html">Cómo la sal de mesa y las proteínas aumentarán la supervivencia del implante</a></li>
<li><a href="../es498832/index.html">Descripción general de las posibilidades de Qt Creator 4.12 y QBS 1.16 para programar microcontroladores</a></li>
<li><a href="../es498834/index.html">33 mitaps en línea de la semana. ¿Elegir uno o tener tiempo para todo?</a></li>
<li><a href="../es498836/index.html">[Infografía] Top 50 franquicias de juegos con ingresos de más de mil millones</a></li>
<li><a href="../es498840/index.html">El bot monitorea y controla la computadora a través de telegramas</a></li>
<li><a href="../es498842/index.html">Moderación de comentarios: Y, sin embargo, ¿podemos confiar en los usuarios?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>