<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìô üçù üë©‚Äç‚ù§Ô∏è‚Äçüíã‚Äçüë® How to cause a memory leak in an Angular application? ü§ôüèª üôãüèΩ üßôüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Performance is the key to the success of a web application. Therefore, developers need to know how memory leaks occur and how to deal with them. 
 
 T...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>How to cause a memory leak in an Angular application?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/503312/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance is the key to the success of a web application. Therefore, developers need to know how memory leaks occur and how to deal with them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This knowledge is especially important when the application the developer is dealing with reaches a certain size. If you do not pay enough attention to memory leaks, then everything may end up with the developer getting into the ‚Äúteam for eliminating memory leaks‚Äù (I had to be part of such a team). </font><font style="vertical-align: inherit;">
Memory leaks can occur for various reasons. However, I believe that when using Angular, you may encounter a pattern that matches the most common cause of memory leaks. There is a way to deal with such memory leaks. And the best thing, of course, is not to fight problems, but to avoid them.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/bg/op/jz/bgopjzk2msaiedpikpoa1qcv2cm.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is memory management?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript uses an automatic memory management system. </font><font style="vertical-align: inherit;">The memory life cycle usually consists of three steps:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allocation of necessary memory.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Work with allocated memory, performing read and write operations.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Releasing memory after it is no longer needed.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> says that automatic memory management - it is a potential source of confusion. </font><font style="vertical-align: inherit;">This can give developers a false sense that they do not need to worry about memory management. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you do not care about memory management at all, this means that after your application grows to a certain size, you may well encounter a memory leak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, memory leaks can be thought of as the memory allocated to the application, which it no longer needs, but is not released. </font><font style="vertical-align: inherit;">In other words, these are objects that failed to undergo garbage collection operations.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How does garbage collection work?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
During the garbage collection procedure, which is quite logical, all that can be considered ‚Äúgarbage‚Äù is cleaned. </font><font style="vertical-align: inherit;">The garbage collector cleans up memory that the application no longer needs. </font><font style="vertical-align: inherit;">In order to find out what areas of memory the application still needs, the garbage collector uses the ‚Äúmark and sweep‚Äù algorithm (tagging algorithm). </font><font style="vertical-align: inherit;">As the name implies, this algorithm consists of two phases - the marking phase and the sweep phase.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Flag phase</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objects and links to them are presented in the form of a tree. </font><font style="vertical-align: inherit;">The root of the tree is, in the following figure, a node </font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In JavaScript, this is an object </font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Each object has a special flag. </font><font style="vertical-align: inherit;">Let's name this flag </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In the flagging phase, first of all, all flags </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are set to a value </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/433/436/b8a/433436b8a72bc7a207bd66c5b76788f5.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the beginning, the flags of marked objects are set to false.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Then the object tree is traversed. </font><font style="vertical-align: inherit;">All flags of</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">objects reachable from the node</font></font><code>root</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are set to</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">And the flags of those objects that cannot be reached, remain in the value</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An object is considered unreachable if it cannot be reached from the root object.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1cf/d14/a50/1cfd14a50f9be4e7aa402052982eb253.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reachable objects are marked as marked = true, unreachable objects as marked = false</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As a result, all flags of</font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unreachable objects remain in the value</font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The memory has not yet been freed, but, after the completion of the tagging phase, everything is ready for the cleaning phase.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Cleaning phase</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The memory is cleared precisely at this phase of the algorithm. Here, all unreachable objects (those whose flag </font></font><code>marked</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">remains in the value </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) are destroyed by the garbage collector.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a0/75f/f16/8a075ff162428195665afe583a85151f.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Object tree after garbage collection. </font><font style="vertical-align: inherit;">All objects whose marked flag is set to false are destroyed by the garbage collector.</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Garbage collection is periodically performed while the JavaScript program is running. </font><font style="vertical-align: inherit;">During this procedure, memory is released that can be freed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps the following question arises here: ‚ÄúIf the garbage collector removes all objects marked as unreachable - how to create a memory leak?‚Äù. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The point here is that the object will not be processed by the garbage collector if the application does not need it, but you can still reach it from the root node of the object tree.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The algorithm cannot know whether the application will use some piece of memory that it can access or not. </font><font style="vertical-align: inherit;">Only a programmer has such knowledge.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Angular memory leaks</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most often, memory leaks occur over time when a component is repeatedly re-rendered. </font><font style="vertical-align: inherit;">For example - through routing, or as a result of using the directive </font></font><code>*ngIf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Say, in a situation where some advanced user works with the application all day without updating the application page in the browser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to reproduce this scenario, we will create a construction of two components. </font><font style="vertical-align: inherit;">These will be the components </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>: <span class="hljs-string">'app-root'</span>,
&nbsp;&nbsp;<span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;app-sub *ngIf="hide"&gt;&lt;/app-sub&gt;`</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppComponent</span> </span>{<font></font>
&nbsp;&nbsp;hide = <span class="hljs-literal">false</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.hide = !<span class="hljs-keyword">this</span>.hide, <span class="hljs-number">50</span>);<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The component template </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uses the component </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. The most interesting thing here is that our component uses a function </font></font><code>setInterval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that switches the flag </font></font><code>hide</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">every 50 ms. This results in a component being re-rendered every 50 ms </font></font><code>app-sub</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. That is, the creation of new instances of the class is performed </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. This code mimics the behavior of a user who works all day with a web application without refreshing a page in a browser. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We, in </font></font><code>SubComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, have implemented different scenarios, in the use of which, over time, changes in the amount of memory used by the application begin to appear. Note that the component</font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">always remains the same. </font><font style="vertical-align: inherit;">In each scenario, we will find out if what we are dealing with is a memory leak by analyzing the memory consumption of the browser process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If the memory consumption of the process increases over time, this means that we are faced with a memory leak. </font><font style="vertical-align: inherit;">If a process uses a more or less constant amount of memory, it means either that there is no memory leak, or that the leak, although present, does not manifest itself in a fairly obvious way.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Scenario # 1: huge for loop</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Our first scenario is represented by a loop that runs 100,000 times. </font><font style="vertical-align: inherit;">In the loop, random values ‚Äã‚Äãare added to the array. </font><font style="vertical-align: inherit;">Let's not forget that the component is re-rendered every 50 ms. </font><font style="vertical-align: inherit;">Take a look at the code and think about whether we created a memory leak or not.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;arr = [];<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.arr.push(<span class="hljs-built_in">Math</span>.random());<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although such code should not be sent to production, it does not create a memory leak. </font><font style="vertical-align: inherit;">Namely, the memory consumption does not go beyond the range limited to a value of 15 MB. </font><font style="vertical-align: inherit;">As a result, there is no memory leak. </font><font style="vertical-align: inherit;">Below we will talk about why this is so.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Scenario 2: BehaviorSubject Subscription</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this scenario, we subscribe to </font></font><code>BehaviorSubject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and assign a value to a constant. </font><font style="vertical-align: inherit;">Is there a memory leak in this code? </font><font style="vertical-align: inherit;">As before, do not forget that the component is rendered every 50 ms.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, as in the previous example, there is no memory leak.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Scenario 3: assigning a value to a class field inside a subscription</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, almost the same code is presented as in the previous example. </font><font style="vertical-align: inherit;">The main difference is that the value is assigned not to a constant, but to a class field. </font><font style="vertical-align: inherit;">And now, do you think there is a leak in the code?</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;subject = <span class="hljs-keyword">new</span> BehaviorSubject(<span class="hljs-number">42</span>);<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.subject.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you believe that there is no leak here - you are absolutely right. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In scenario # 1 there is no subscription. </font><font style="vertical-align: inherit;">In scenarios No. 2 and 3, we subscribed to the stream of the observed object initialized in our component. </font><font style="vertical-align: inherit;">It feels like we're safe by subscribing to component flows. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But what if we add service to our scheme?</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scenarios that use the service</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the following scenarios, we are going to revise the above examples, but this time we will subscribe to the stream provided by the service </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Here is the service code.</font></font><br>
<br>
<pre><code class="javascript hljs">@Injectable({
&nbsp;&nbsp;<span class="hljs-attr">providedIn</span>: <span class="hljs-string">'root'</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DummyService</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;some$ = <span class="hljs-keyword">new</span> BehaviorSubject&lt;number&gt;(<span class="hljs-number">42</span>);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before us is a simple service. </font><font style="vertical-align: inherit;">This is just a service that provides stream ( </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) in the form of a public class field.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Scenario 4: Subscribing to a stream and assigning a value to a local constant</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will recreate here the same scheme that was already described earlier. </font><font style="vertical-align: inherit;">But this time, we subscribe to the stream </font></font><code>some$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from </font></font><code>DummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and not to the component‚Äôs field. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Is there a memory leak? </font><font style="vertical-align: inherit;">Again, when answering this question, remember that the component is used in </font></font><code>AppComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and rendered many times.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> foo = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now we finally created a memory leak. </font><font style="vertical-align: inherit;">But this is a small leak. </font><font style="vertical-align: inherit;">By "small leak" I mean one that, over time, leads to a slow increase in the amount of memory consumed. </font><font style="vertical-align: inherit;">This increase is barely noticeable, but a cursory inspection of the heap snapshot showed the presence of many undeleted instances </font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Scenario 5: subscribing to a service and assigning a value to a class field</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we subscribe again to </font></font><code>dummyService</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But this time we assign the resulting value to the class field, and not a local constant.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> </span>{<font></font>
&nbsp;&nbsp;randomValue = <span class="hljs-number">0</span>;<font></font>
&nbsp;&nbsp;<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.dummyService.some$.subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.randomValue = value;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;});<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And here we finally created a significant memory leak. </font><font style="vertical-align: inherit;">Memory consumption quickly, within a minute, exceeded 1 GB. </font><font style="vertical-align: inherit;">Let's talk about why this is so.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçWhen did a memory leak occur?</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may have noticed that in the first three scenarios we were not able to create a memory leak. </font><font style="vertical-align: inherit;">These three scenarios have something in common: all links are local to the component. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When we subscribe to an observable object, it stores a list of subscribers. </font><font style="vertical-align: inherit;">Our callback is also on this list, and the callback can refer to our component.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bda/49f/92e/bda49f92eb184ad1eb78231a4144b71c.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">No memory leak</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
When a component is destroyed, that is, when Angular no longer has a link to it, which means that the component cannot be reached from the root node, the observed object and its list of subscribers cannot be reached from the root node either. As a result, the entire component object is garbage collected.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As long as we are subscribed to an observable object, links to which are only within the component, no problems arise. But when the service comes into play, the situation changes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/454/6f7/b5b/4546f7b5b2ab2d2858f550740243189e.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory Leak</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
As soon as we subscribed to an observable object provided by a service or another class, we created a memory leak. </font><font style="vertical-align: inherit;">This is due to the observed object, because of its list of subscribers. </font><font style="vertical-align: inherit;">Because of this, the callback, and therefore the component, are accessible from the root node, although Angular does not have a direct reference to the component. </font><font style="vertical-align: inherit;">As a result, the garbage collector does not touch the corresponding object. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I‚Äôll clarify: you can use such constructions, but you need to work with them correctly, and not like we do.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proper Subscription Work</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to avoid memory leak, it is important to unsubscribe correctly from the observed object, by doing this when the subscription is no longer needed. For example, when a component is destroyed. There are many ways to unsubscribe from an observed object. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The experience of advising owners of large corporate projects indicates that in this situation it is best to use the entity </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">created by the team </font></font><code>new Subject&lt;void&gt;()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in combination with the operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="javascript hljs">@Component({
&nbsp;&nbsp;<span class="hljs-attr">selector</span>:<span class="hljs-string">'app-sub'</span>,
&nbsp;&nbsp;<span class="hljs-comment">// ...</span><font></font>
})<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnDestroy</span> </span>{<font></font>
<font></font>
&nbsp;&nbsp;private destroy$: Subject&lt;<span class="hljs-keyword">void</span>&gt; = <span class="hljs-keyword">new</span> Subject&lt;<span class="hljs-keyword">void</span>&gt;();<font></font>
&nbsp;&nbsp;randomNumber = <span class="hljs-number">0</span>;<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(private dummyService: DummyService) {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dummyService.some$.pipe(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;takeUntil(<span class="hljs-keyword">this</span>.destroy$)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).subscribe(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-keyword">this</span>.randomNumber = value);<font></font>
&nbsp;&nbsp;}<font></font>
<font></font>
&nbsp;&nbsp;ngOnDestroy(): <span class="hljs-keyword">void</span> {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.next();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.destroy$.complete();<font></font>
&nbsp;&nbsp;}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we unsubscribe from the subscription using the </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after the destruction of the component. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We implemented a lifecycle hook in the component </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Every time a component is destroyed, we call </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">methods </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The call is </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very important because this call clears the subscription from </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then we use the operator </font></font><code>takeUntil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and pass it our stream </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This ensures that the subscription is cleared (that is, that we have unsubscribed from the subscription) after the component is destroyed.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How to remember to clear subscriptions?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It's easy to forget to add in the component </font></font><code>destroy$</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and forget to call </font></font><code>next</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and </font></font><code>complete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Hook lifecycle </font></font><code>ngOnDestroy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Even despite the fact that I taught this to teams working on projects, I often forgot about it myself. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, there is a wonderful rule of linter, which is part of a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">set of rules</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that allows you to ensure proper unsubscription from subscriptions. </font><font style="vertical-align: inherit;">You can set a rule set like this:</font></font><br>
<br>
<pre><code class="javascript hljs">npm install @angular-extensions/lint-rules --save-dev
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then it must be connected to </font></font><code>tslint.json</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs">{
&nbsp;&nbsp;<span class="hljs-string">"extends"</span>: [
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"tslint:recommended"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-string">"@angular-extensions/lint-rules"</span><font></font>
&nbsp;&nbsp;]<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I highly recommend that you use this set of rules in your projects. </font><font style="vertical-align: inherit;">This will save you many hours of debugging in finding sources of memory leaks.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Angular, it is very easy to create a situation leading to memory leaks. </font><font style="vertical-align: inherit;">Even small code changes in places that, apparently, should not be related to memory leaks, can lead to serious adverse consequences. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The best way to avoid memory leaks is to manage your subscriptions correctly. </font><font style="vertical-align: inherit;">Unfortunately, the operation of cleaning subscriptions requires great accuracy from the developer. </font><font style="vertical-align: inherit;">This is easy to forget. </font><font style="vertical-align: inherit;">Therefore, it is recommended that you apply rules </font></font><code>@angular-extensions/lint-rules</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that help you organize the right work with your subscriptions. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repository with the code underlying this material. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you encountered memory leaks in Angular applications?</font></font></b><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/a_/bs/aa/a_bsaactpbr8fltzymtkhqbw1d4.png"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en503288/index.html">How we searched for candidates using machine learning</a></li>
<li><a href="../en503290/index.html">DJI Matrice 300 RTK industrial quadrocopter review</a></li>
<li><a href="../en503300/index.html">The book ‚ÄúRick and Morty. Guide to the most brilliant cartoon of all galaxies ¬ª</a></li>
<li><a href="../en503302/index.html">Speeding up a project build on CMake + GCC: precompilation of header files</a></li>
<li><a href="../en503310/index.html">What do senior programmers think?</a></li>
<li><a href="../en503318/index.html">Profession: Programmer. Not everything is clear</a></li>
<li><a href="../en503322/index.html">Firmware Development: Introduction</a></li>
<li><a href="../en503324/index.html">‚ÄúAt the peak‚Äù of Brad Stalberg and Steve Magness: prevention of spontaneous combustion (part one)</a></li>
<li><a href="../en503328/index.html">We compile the Spring Boot application into native using GraalVM</a></li>
<li><a href="../en503330/index.html">How to Learn from a Data Scientist: The Most Wanted Technical Skills</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>