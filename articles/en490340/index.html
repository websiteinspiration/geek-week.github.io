<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚Ñ¢Ô∏è ‚ÅâÔ∏è üòø Zen go ü§ôüèΩ üë©‚Äçüëß‚Äçüë¶ üèØ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Evaluating my work, I recently thought a lot about how to write good code. Given that no one is interested in how to write bad code, the question aris...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zen go</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/490340/"><img src="https://habrastorage.org/webt/kr/ic/9k/kric9kwqdonbm71t_zw5b35ui4o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Evaluating my work, I recently thought a lot about how to write good code. </font><font style="vertical-align: inherit;">Given that no one is interested in how to write </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bad</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> code, the question arises: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">how do you know if you wrote good code on Go</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? </font><font style="vertical-align: inherit;">If there is some kind of scale between good and bad, then how to understand which parts of the scale belong to the good? </font><font style="vertical-align: inherit;">What are its properties, attributes, distinguishing features, patterns and idioms?</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiomatic go</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These considerations led me to the idiomatic Go. </font><font style="vertical-align: inherit;">If we call something ‚Äúidiomatic‚Äù, then this something corresponds to a certain style of some time. </font><font style="vertical-align: inherit;">If something is not idiomatic, then it does not correspond to the dominant style. </font><font style="vertical-align: inherit;">That is not fashionable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
More importantly, when we say that someone‚Äôs code is not idiomatic, this doesn‚Äôt explain the reason. </font><font style="vertical-align: inherit;">Why not idiomatic? </font><font style="vertical-align: inherit;">The answer is given by the dictionary.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idiom (n.): A speech revolution, used as a whole, not subject to further decomposition and usually not allowing permutations within itself.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idioms are hallmarks of common meanings. </font><font style="vertical-align: inherit;">Books will not teach you the idiomatic Go; it is only known when you become part of a community. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I am concerned about the idiomatic Go mantra because it is often restrictive. </font><font style="vertical-align: inherit;">She says: "you cannot sit with us." </font><font style="vertical-align: inherit;">Isn't that what we mean when we criticize someone else's work as ‚Äúnot idiomatic‚Äù? </font><font style="vertical-align: inherit;">They did it wrong. </font><font style="vertical-align: inherit;">This does not look right. </font><font style="vertical-align: inherit;">This is not in keeping with the style of the times. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I believe that the idiomatic Go is not suitable for teaching how to write good code, because, in essence, it means telling people that they did something wrong. </font><font style="vertical-align: inherit;">It is better to give such advice that will not push a person away at the moment when he most wants to receive this advice.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayings</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's distract from idiomatic problems. </font><font style="vertical-align: inherit;">What other cultural artifacts are inherent in Go programmers? </font><font style="vertical-align: inherit;">Turn to the beautiful </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go Proverbs</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> page </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Are these sayings a suitable learning tool? </font><font style="vertical-align: inherit;">Do they tell beginners how to write good Go code? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I don‚Äôt think so. </font><font style="vertical-align: inherit;">I do not want to belittle the work of the author. </font><font style="vertical-align: inherit;">The sayings he composed are merely observations, not definitions of meanings. </font><font style="vertical-align: inherit;">The dictionary comes to the rescue again:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proverb (n.): A short statement that has literal or figurative meaning.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go Proverbs' mission is to show the deep essence of the language architecture. </font><font style="vertical-align: inherit;">But will it be useful to advice like "The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">empty interface does not say anything</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " to a beginner who came from a language without structural typing? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a growing community, it is important to recognize that the number of Go students is far greater than the number of those who are fluent in this language. </font><font style="vertical-align: inherit;">That is, sayings are probably not the best way to learn in such a situation.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Values</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan Liu found </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an old presentation by</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mark Lukowski on the design culture in the Windows NT-Windows 2000 Windows development team. I mentioned this because Lukowski describes culture as a common way of evaluating architectures and making compromises.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cb/a0d/487/0cba0d4873afc7945a74500669efd389.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main idea is to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make value-based decisions within an unknown architecture</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">The NT team had these values: portability, reliability, security and extensibility. </font><font style="vertical-align: inherit;">Simply put, design values ‚Äã‚Äãare a way to solve problems.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go Values</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What are Go's explicit values? </font><font style="vertical-align: inherit;">What are the key concepts or philosophies that determine how Go programmers interpret the world? </font><font style="vertical-align: inherit;">How are they proclaimed? </font><font style="vertical-align: inherit;">How are they taught? </font><font style="vertical-align: inherit;">How are they followed? </font><font style="vertical-align: inherit;">How do they change over time? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do you convert a Go programmer get the values ‚Äã‚Äãof Go design? </font><font style="vertical-align: inherit;">Or how do you, an experienced Go-pro, proclaim your values ‚Äã‚Äãto future generations? </font><font style="vertical-align: inherit;">And so that you understand, this process of knowledge transfer is not optional? </font><font style="vertical-align: inherit;">Without the influx of new participants and new ideas, our community becomes myopic and withers.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Values ‚Äã‚Äãof other languages</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To prepare the way for what I want to say, we can pay attention to other languages, to their design values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, in C ++ and Rust it is believed that a programmer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">should not pay for a feature that he does not use</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . If the program does not use some resource-intensive feature of the language, then the program cannot be forced to bear the cost of maintaining this feature. This value is projected from the language into the standard library and is used as a criterion for evaluating the architecture of all programs written in C ++. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Main value in Java, Ruby and Smalltalk - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">everything is an object</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This principle underlies program design in terms of message transfer, information hiding, and polymorphism. </font><font style="vertical-align: inherit;">Architectures that conform to a procedural or functional paradigm are considered erroneous in these languages. </font><font style="vertical-align: inherit;">Or, as a Go programmer would say, not idiomatic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's get back to our community. </font><font style="vertical-align: inherit;">What design values ‚Äã‚Äãdo Go programmers profess? </font><font style="vertical-align: inherit;">Discussions on this topic are often fragmented, so it is not easy to formulate a set of meanings. </font><font style="vertical-align: inherit;">It is imperative to reach agreement, but the difficulty of reaching it grows exponentially with the growing number of participants in the discussion. </font><font style="vertical-align: inherit;">But what if someone did this difficult job for us?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zen </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Go</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A few decades ago, Tim Peters sat down and wrote </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PEP-20</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Zen of Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">He attempted to document the design values ‚Äã‚Äãthat Guido Van Rossum adhered to as the Generous Lifetime Dictator of Python. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's look at </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Zen of Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and see if we can learn anything about Go designer's design values.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A good package starts with a good name</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start with the sharp one:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namespaces are a great idea, let's make them bigger! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, record 19.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unambiguously enough: Python programmers should use namespaces. Lots of spaces. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go terminology, a namespace is a package. There is no doubt that bundling favors design and reuse. But there may be confusion about how to do this, especially if you have many years of programming experience in another language. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Go, every package must be designed for something. And the name is the best way to understand this destination. Reformulating Peteres‚Äôs thoughts, every package in Go should be designed for one thing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The idea is not new, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have already talked about this</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But why should this approach be used, and not another, in which packages are used for the needs of a detailed classification? It's all about the changes.</font></font><br>
<br>
<blockquote> ‚Äî    ,         .<br>
<br>
 </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Change is the name of the game we are participating in. We, as programmers, manage change. If we do it well, we call it architecture. And if it‚Äôs bad, then we call it technical debt or legacy code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you write a program that works great once with one fixed set of input data, then nobody will be interested in whether it has good code, because only the result of its work is important for business. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not happen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . There are bugs in programs, requirements and input data change, and very few programs are written with a single execution expectation. That is, your program </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> change over time. Perhaps this task will be given to you, but most likely someone else will do it. Someone needs to accompany this code.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How do we make it easier to change programs? </font><font style="vertical-align: inherit;">Add interfaces everywhere? </font><font style="vertical-align: inherit;">Do everything suitable for creating stubs? </font><font style="vertical-align: inherit;">Deploy dependencies tightly? </font><font style="vertical-align: inherit;">Perhaps, for some types of programs, these techniques are suitable, but not for many. </font><font style="vertical-align: inherit;">However, for most programs, creating a flexible architecture is more than design. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And if instead of expanding the components we will replace them? </font><font style="vertical-align: inherit;">If the component does not do what is specified in the instructions, then it is time to change it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A good package starts with choosing a good name. </font><font style="vertical-align: inherit;">Consider it a short presentation that describes the function of a package with just one word. </font><font style="vertical-align: inherit;">And when the name no longer meets the requirement, find a replacement.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicity matters</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simple is better than complex. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, entry 3.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PEP-20 claims that the simple is better than the complex, and I completely agree. </font><font style="vertical-align: inherit;">A few years ago I wrote:</font></font><br>
<br>
<div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="539576755254611968"></twitter-widget>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
</div><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most programming languages ‚Äã‚Äãtry to be simple at first, but later decide to be powerful.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
According to my observations, at least at that time, I could not remember a language I knew that would not be thought of as simple. As justification and temptation, the authors of each new language declared simplicity. But I found that simplicity was not the core value of many languages ‚Äã‚Äãof the same age as Go (Ruby, Swift, Elm, Go, NodeJS, Python, Rust). Perhaps this will hit a sore spot, but maybe the reason is that none of these languages ‚Äã‚Äãis simple. Or their authors did not </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> them simple. Simplicity was not included in the list of core values. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can consider me old-fashioned, but when did this simplicity go out of fashion? Why is the commercial software industry constantly and joyfully forgetting this fundamental truth?</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are two ways to create a software architecture: to make it so simple that the lack of flaws is obvious, and to make it so complex that it does not have obvious flaws. </font><font style="vertical-align: inherit;">The first method is much more difficult. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Charles Hoar, The Emperor's Old Clothes, Turing Award Lecture, 1980</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Simple does not mean easy, we know that. </font><font style="vertical-align: inherit;">Often it takes more effort to ensure ease of use, rather than ease of creation.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicity is the key to reliability. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Edsger Dijkstra, EWD498, June 18, 1975</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why strive for simplicity? </font><font style="vertical-align: inherit;">Why is it important for Go programs to be simple? </font><font style="vertical-align: inherit;">Simple means raw, it means readable and easy to follow. </font><font style="vertical-align: inherit;">Simple does not mean artless, it means reliable, intelligible and understandable.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The core of programming is complexity management. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Brian Kernigan, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Software Tools</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (1976)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Whether Python follows its mantra of simplicity is a debatable question. </font><font style="vertical-align: inherit;">At Go, however, simplicity is a core value. </font><font style="vertical-align: inherit;">I think we will all agree that in Go simple code is preferable to smart code.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Avoid package-level states</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicit is better than implicit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, entry 2</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here, Peters, in my opinion, rather dreams than adheres to the facts. In Python, much is not explicit: decorators, dunder methods, etc. Undoubtedly, these are powerful tools, and they exist for a reason. On the implementation of each feature, especially complex, someone worked. But the active use of such features makes it difficult to evaluate the cost of the operation when reading the code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fortunately, we Go programmers can optionally make the code explicit. Perhaps, for you, manifestation may be synonymous with bureaucracy and verbosity, but this is a superficial interpretation. It will be a mistake to focus only on the syntax, to take care of the length of the lines and the application of DRY principles to expressions. It seems to me more important to provide explicitness in terms of connectedness and states.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connectivity is a measure of the dependence of one on the other. If one is closely related to the other, then both move together. An action affecting one is directly reflected in the other. Imagine a train in which all the cars are connected ‚Äî or rather, connected ‚Äî together. Where the steam train goes, there are the cars. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connectivity can also be described by the term cohesion - cohesion. This is a measure of how much one belongs to the other. In a soldered team, all the participants are so suited to each other, as if they were specially created that way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Why is coherence important? As in the case of the train, when you need to change a piece of code, you have to change the rest of the closely related code. For example, someone has released a new version of their API, and now your code does not compile.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An API is an unavoidable source of binding. But it can be presented in more insidious forms. Everyone knows that if the signature of the API has changed, then the data transferred to and from the API will also change. It's all about the function signature: I take the values ‚Äã‚Äãof one type and return the values ‚Äã‚Äãof other types. And if the API begins to transfer data in a different way? What if the result of each API call depends on the previous call, even if you did not change your settings? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is called state, and state management is a problem in computer science.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> counter<font></font>
<font></font>
<span class="hljs-keyword">var</span> count <span class="hljs-keyword">int</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Increment</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {<font></font>
        count += n<font></font>
        <span class="hljs-keyword">return</span> count<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we have a simple package </font></font><code>counter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. To change the counter, you can call </font></font><code>Increment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can even get the value back if you increment with a zero value. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say you need to test this code. How to reset the counter after each test? And if you want to run tests in parallel, how can this be done? And suppose you want to use several counters in the program, will you succeed? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course not. Obviously, the solution is to encapsulate the variable </font></font><code>variable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the type.</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">package</span> counter<font></font>
<font></font>
<span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> {<font></font>
        count <span class="hljs-keyword">int</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Increment</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {<font></font>
        c.count += n<font></font>
        <span class="hljs-keyword">return</span> c.count<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now imagine that the described problem is not limited to counters; it also affects the main business logic of your applications. </font><font style="vertical-align: inherit;">Can you test it in isolation? </font><font style="vertical-align: inherit;">Can you test in parallel? </font><font style="vertical-align: inherit;">Can you use multiple instances at the same time? </font><font style="vertical-align: inherit;">If the answer is no for all questions, then the reason is the state at the packet level. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avoid these conditions. </font><font style="vertical-align: inherit;">Reduce connectivity and the number of nightmare remote actions by providing types with the dependencies they need as fields, rather than using package variables.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make plans for failure, not success</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Never pass bugs silently. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, entry 10</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is said about languages ‚Äã‚Äãthat encourage samurai-style exception handling: come back with a victory or don't come back at all. In languages ‚Äã‚Äãbased on exceptions, functions return only valid results. If the function cannot do this, then the control flow goes in a completely different way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, unchecked exceptions are an unsafe programming model. How can you write reliable code in the presence of errors if you do not know which expressions can throw an exception? Java tries to reduce risks with the concept of checked exceptions. And as far as I know, in other popular languages ‚Äã‚Äãthere are no analogues of this solution. There are exceptions in many languages, and everywhere except Java, they are not checked.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviously, Go took a different path. </font><font style="vertical-align: inherit;">Go programmers believe that reliable programs are made up of parts that handle failures </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">before</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> processing successful paths. </font><font style="vertical-align: inherit;">Given that the language was created for server development, the creation of multi-threaded programs, as well as programs that process data entering over the network, programmers should focus on working with unexpected and damaged data, timeouts, and connection failures. </font><font style="vertical-align: inherit;">Of course, if they want to make reliable products.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I believe that errors should be handled explicitly, this should be the main value of the language. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peter Burgon, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GoTime # 91</font></font></a></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I join the words of Peter, they served as an impetus to the writing of this article. </font><font style="vertical-align: inherit;">I believe that Go owes its success to explicit error handling. </font><font style="vertical-align: inherit;">Programmers primarily think about possible crashes. </font><font style="vertical-align: inherit;">First, we solve problems like ‚Äúwhat if‚Äù. </font><font style="vertical-align: inherit;">The result is programs in which failures are handled at the stage of writing code, and not as they happen during operation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The verbosity of this code</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
    <span class="hljs-keyword">return</span> err<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outweighs the importance of deliberately handling each failed state at the time it occurs. </font><font style="vertical-align: inherit;">The key to this is the value of explicitly handling each error.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Better to return early than to invest deeply</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sibling is better than nesting </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, entry 5</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This wise advice comes from a language in which indentation is the main form of control flow. How do we interpret this tip in Go terminology? gofmt manages the entire amount of empty space in Go programs, so we have nothing to do here. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I wrote above about package names. Perhaps it is advisable to avoid a complex hierarchy of packages. In my experience, the more a programmer tries to separate and classify a code base on Go, the higher the risk of cyclical import of packages. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I believe that the best use of the fifth entry from </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Zen of Python</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is to create a control flow </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">inside a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function. In other words, avoid a control flow that requires multi-level indentation.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct visibility is a straight line along which the view is not obscured by anything. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
May Ryer, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code: Align the happy path to the left edge</font></font></a></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
May Ryer describes this idea as programming in direct line of sight:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use control statements to return early if the precondition is not met.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Placing the statement of successful return at the end of the function, and not inside the conditional block.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduce the overall nesting level by extracting functions and methods.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Try to ensure that important functions never move out of line of sight to the right edge of the screen. </font><font style="vertical-align: inherit;">This principle has a side effect: you will avoid meaningless disputes with the team about the length of the lines. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Each time you indent, you add one more precondition to the heads of programmers, occupying one of their 7 ¬± 2 short-term memory slots. </font><font style="vertical-align: inherit;">Instead of deepening the nesting, try to keep the successful path of the function as close to the left side of the screen as possible.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you think something is running slowly, then prove it with a benchmark</font></font></h2><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Give up the temptation to guess in the face of ambiguity. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python 12</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Programming is based on mathematics and logic. </font><font style="vertical-align: inherit;">These two concepts rarely use the element of luck. </font><font style="vertical-align: inherit;">But we, as programmers, make numerous assumptions every day. </font><font style="vertical-align: inherit;">What does this variable do? </font><font style="vertical-align: inherit;">What does this option do? </font><font style="vertical-align: inherit;">What happens if I pass nil here? </font><font style="vertical-align: inherit;">What happens if I call the register twice? </font><font style="vertical-align: inherit;">In modern programming, you have to assume a lot, especially when using other people's libraries.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The API should be easy to use and hard to misuse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Josh Bloch</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the best ways I've known to help a programmer avoid guessing when creating an API is to </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">focus on standard usage methods</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The caller should be able to perform normal operations as easily as possible. However, before I wrote a lot and talked about designing the API, so here is my interpretation of record 12: </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do not guess about the topic of performance</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite your attitude to Knut‚Äôs advice, one of the reasons for Go‚Äôs success is the effectiveness of its execution. Effective programs can be written in this language, and thanks to this, people </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">choose go. </font><font style="vertical-align: inherit;">There are many misconceptions related to performance. </font><font style="vertical-align: inherit;">Therefore, when you are looking for ways to improve code performance, or follow dogmatic tips such as ‚Äúshelving slows down,‚Äù ‚ÄúCGO is expensive,‚Äù or ‚Äúalways use atomic operations instead of mutexes,‚Äù don‚Äôt guess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do not complicate your code due to outdated dogmas. </font><font style="vertical-align: inherit;">And if you think that something is working slowly, first make sure of it with the help of a benchmark. </font><font style="vertical-align: inherit;">Go has great free benchmarking and profiling tools. </font><font style="vertical-align: inherit;">Use them to find bottlenecks in the performance of your code.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Before starting gorutin, find out when it will stop</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think I have listed the valuable items from PEP-20 and perhaps expanded their interpretation beyond good taste. </font><font style="vertical-align: inherit;">This is good, because although this is a useful rhetorical device, we are still talking about two different languages.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write g, o, a space, and then a function call. </font><font style="vertical-align: inherit;">Three button presses, it cannot be shorter. </font><font style="vertical-align: inherit;">Three button clicks, and you launched the subprocess. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Rob Pike, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplicity is Complicated</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dotGo 2015</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The next two tips I devote to the goroutines. Gorutins are a characteristic feature of the language, our response to high-level competitiveness. They are very easy to use: put a word </font></font><code>go</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in front of the operator and you run the function asynchronously. No execution threads, no pool executors, no IDs, no completion status tracking. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gorutins are cheap. Due to the ability of the runtime environment to multiplex goroutines in a small number of execution threads (which you do not need to manage), you can easily create hundreds of thousands or millions of goroutines. This allows you to create architectures that would be impractical when using other competitive models, in the form of execution threads or event callbacks.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But no matter how cheap the goroutines were, they are not free. Their stack takes at least a few kilobytes. And when you have millions of goroutines, it becomes noticeable. I do not mean to say that you do not need to use millions of goroutines, if architecture pushes you to this. But if you use it, then it is extremely important to monitor them, since in such quantities goroutines can consume a lot of resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Goroutines are the main source of ownership in Go. To be useful, goroutine must do something. That is, almost always it contains a link to a resource, that is, ownership information: lock, network connection, data buffer sending the end of the channel. While goroutine lives, the lock is held, the connection remains open, the buffer is saved, and channel recipients will wait for new data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest way to free resources is to link them to the goroutine life cycle. </font><font style="vertical-align: inherit;">When it completes, resources are freed. </font><font style="vertical-align: inherit;">And since it‚Äôs very easy to run goroutine, before you write ‚Äúgo and space‚Äù make sure that you have answers to these questions:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Under what condition does goroutine stop? </font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go cannot tell goroutine to end. </font><font style="vertical-align: inherit;">For a specific reason, there is no function to stop or interrupt. </font><font style="vertical-align: inherit;">We cannot order the goroutines to stop, but we can politely ask. </font><font style="vertical-align: inherit;">This is almost always related to the operation of the channel. </font><font style="vertical-align: inherit;">When it is closed, the range is looped to exit the channel. </font><font style="vertical-align: inherit;">When closing the channel, you can select it. </font><font style="vertical-align: inherit;">The signal from one goroutine to another is best expressed as a closed channel.</font></font></li>
<li><strong>    ?</strong>          ,        ,   :        ?</li>
<li><strong>     ,   ?</strong>     ,    -       .        ,       .           .          ,        .</li>
</ul><br>
<h2>  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probably in any of your serious Go programs, concurrency is used. This often leads to the problem of a worker pattern ‚Äî one goroutine per connection. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A prime example is net / http. It is quite simple to stop the server that owns the listening socket, but what about the goroutines that are generated by this socket? net / http provides a context object inside the request object that can be used to tell the listening code that the request needs to be canceled, and therefore interrupt the goroutine. But it is not clear how to find out when all this needs to be done. It is one thing to call </font></font><code>context.Cancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, another to know that the cancellation is completed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I often find fault with net / http, but not because it is bad. On the contrary, it is the most successful, oldest and most popular API in the Go codebase. Therefore, its architecture, evolution, and flaws are carefully analyzed. Consider this flattery, not criticism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, I want to bring net / http as a counterexample of good practice. Since each connection is processed by the goroutin created inside the type </font></font><code>net/http.Server</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the program outside the net / http package cannot control the goroutins that are created by the receiving socket. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This area of ‚Äã‚Äãarchitecture is still developing. You can recall </font></font><code>run.Group</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the go-kit, or </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ErrGroup,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> of the Go development team, which provides a framework for executing, canceling, and waiting for asynchronously executed functions.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For everyone who writes code that can be executed asynchronously, the main principle of creating architectures is that the responsibility for running goroutines should be shifted to the caller. </font><font style="vertical-align: inherit;">Let him choose how he wants to run, track and wait for your functions to complete.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Write tests to block the behavior of your package API</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may have hoped that in this article I will not mention testing. Sorry, some other time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Your tests are an agreement on what your program does and what does not. Unit tests should block the behavior of their APIs at the package level. Tests describe in code form what the package promises to do. If there is a unit test for each input conversion, then you, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the form of code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and not documentation, have defined an agreement on what the code will do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Approving this agreement is as simple as writing a test. At any stage, you can </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">state</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> with a high degree of confidence </font><font style="vertical-align: inherit;">that the behavior that people relied on before the changes you made will continue to function after the changes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tests block API behavior. </font><font style="vertical-align: inherit;">Any changes that add, change or remove the public API should include changes in the tests.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moderation is a virtue</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go is a simple language with only 25 keywords. </font><font style="vertical-align: inherit;">In a way, this highlights the features built into the language. </font><font style="vertical-align: inherit;">These are the features that allow the language to promote itself: simple competition, structural typing, etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I think all of us are confused by trying to use all the features of Go at once. </font><font style="vertical-align: inherit;">How many of you were so inspired by the use of channels that you used them wherever you can? </font><font style="vertical-align: inherit;">I found out that the resulting programs are difficult to test, they are fragile and too complex. </font><font style="vertical-align: inherit;">And you?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I had the same experience with goroutines. Trying to divide the work into tiny fragments, I created the darkness of goroutin, which was difficult to control, and completely lost sight of the fact that most of them were always blocked due to the expectation of their predecessors to complete the work. The code was completely consistent, and I had to greatly increase the complexity in order to get a small advantage. How many of you have encountered this? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I had the same with embedding. At first I confused it with inheritance. Then he ran into the problem of a fragile base class, combining several complex types that already had several tasks into even more complex huge types.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This may be the least effective advice, but I consider it important to mention it. </font><font style="vertical-align: inherit;">The advice is the same: keep moderation, and Go's capabilities are no exception. </font><font style="vertical-align: inherit;">Whenever possible, do not use goroutines, channels, embedding structures, anonymous functions, an abundance of packages and interfaces. </font><font style="vertical-align: inherit;">Use simpler solutions than smart ones.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ease of maintenance matters</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, I‚Äôll give you another entry from PEP-20:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Readability matters. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The Zen of Python, record 7</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A lot has been said about the importance of code readability in all programming languages. Those who promote Go use words such as simplicity, readability, clarity, productivity. But all these are synonyms of one concept - convenience of maintenance. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The real goal is to create code that is easy to maintain. The code that outlives the author. A code that can exist not only as an investment of time, but as a basis for obtaining future value. This does not mean that readability is not important, just the convenience of maintenance is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">more important</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Go is not one of those languages ‚Äã‚Äãthat are optimized for single-line programs. And not one of those languages ‚Äã‚Äãthat are optimized for programs with a minimum number of lines. We do not optimize for the size of the source code on the disk, or for the speed of writing programs in the editor. We want to optimize our code so that it becomes more understandable for readers. Because it is they who will have to accompany him.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you write a program for yourself, then perhaps it will be launched only once, or you are the only one who sees its code. </font><font style="vertical-align: inherit;">In this case, do anything. </font><font style="vertical-align: inherit;">But if more than one person works on the code, or if it will be used for a long time and the requirements, capabilities or runtime may change, then the program should be convenient to maintain. </font><font style="vertical-align: inherit;">If the software cannot be maintained, then it cannot be rewritten. </font><font style="vertical-align: inherit;">And this may be the last time your company invests in Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What you work hard on will be convenient to accompany after your departure? </font><font style="vertical-align: inherit;">How can you facilitate the maintenance of your code for those who come after you today?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490324/index.html">How do we find unobvious errors in the online assignment interfaces for children</a></li>
<li><a href="../en490328/index.html">Profession: Tester</a></li>
<li><a href="../en490332/index.html">We make a clone of the food delivery service using Nuxt.js, GraphQL, Strapi and Stripe. Part 2/7</a></li>
<li><a href="../en490336/index.html">Channel Anatomy in Go</a></li>
<li><a href="../en490338/index.html">In an innovative experiment, physicists learned to capture individual atoms.</a></li>
<li><a href="../en490342/index.html">What we learned from testing the state information system</a></li>
<li><a href="../en490344/index.html">Who is techlide and why is the team needed it</a></li>
<li><a href="../en490346/index.html">The role of the MQTT protocol in the development of the industrial Internet of things</a></li>
<li><a href="../en490348/index.html">How to give feedback and not start the Third World War</a></li>
<li><a href="../en490354/index.html">Enhancing the culture of information security in fintech companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>