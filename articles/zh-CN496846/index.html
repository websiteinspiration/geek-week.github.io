<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✋🏼 🚞 👩🏿‍🤝‍👨🏻 堆栈和指针的语言机制 👩‍👧‍👧 👰 👇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="序幕
 这是该系列文章中的四篇文章的第一篇，将深入了解指针，堆栈，堆，转义分析和Go /指针语义的机制和设计。这篇文章是关于堆栈和指针的。
 
 目录：
 
 

1. 堆栈和指针上的语言力学
2. 逃生分析的语言力学（翻译）
3. 记忆剖析的语言机制
4. 数据与语义设计哲学
 介绍
 我不会反汇...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>堆栈和指针的语言机制</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">序幕</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是该系列文章中的四篇文章的第一篇，将深入了解指针，堆栈，堆，转义分析和Go /指针语义的机制和设计。</font><font style="vertical-align: inherit;">这篇文章是关于堆栈和指针的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目录：</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈和指针上的语言力学</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">逃生分析的语言力学</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻译</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆剖析的语言机制</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据与语义设计哲学</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">介绍</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不会反汇编-指针很难理解。</font><font style="vertical-align: inherit;">如果使用不当，指针可能会导致令人不愉快的错误，甚至导致性能问题。</font><font style="vertical-align: inherit;">在编写竞争性或多线程程序时尤其如此。</font><font style="vertical-align: inherit;">毫不奇怪，许多语言都试图隐藏程序员的指针。</font><font style="vertical-align: inherit;">但是，如果使用Go编写，则无法转义指针。</font><font style="vertical-align: inherit;">如果没有对指针的清楚理解，您将很难编写干净，简单而有效的代码。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">边框</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在帧的边界内执行功能，这些帧为每个相应功能提供了单独的存储空间。每个框架都允许该功能在其自己的上下文中工作，并提供流控制。函数可以通过指针直接访问其框架内的内存，但是访问框架外部的内存则需要间接访问。为了使功能在其框架之外访问存储器，必须将该存储器与该功能结合使用。必须首先了解和研究由这些边界设置的机制和限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用函数时，会在两个帧之间发生过渡。代码从调用函数的框架到被调用函数的框架。如果需要数据来调用该函数，则必须将该数据从一帧传输到另一帧。 Go中两个帧之间的数据传输是“按值”完成的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“按值”数据传输的优点是可读性。您在函数调用中看到的值是在另一端复制并接受的值。这就是为什么我将“按价值传递”与所见即所得相关联的原因，因为您所看到的就是所得到的。所有这一切都使您可以编写不隐藏两个功能之间切换成本的代码。这有助于保持良好的心理模型，以了解过渡期间每个函数调用将如何影响程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看一下这个小程序，该程序通过“按值”传递整数数据来调用函数：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单1：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当您的Go程序启动时，运行时将创建主goroutine以开始执行所有代码，包括main函数中的代码。 Gorutin是适合操作系统线程的执行路径，该线程最终运行在某些内核上。从版本1.8开始，每个goroutine都提供了一个初始的连续内存块，大小为2048字节，这形成了堆栈空间。多年来，此初始堆栈大小已更改，并且将来可能会更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
堆栈很重要，因为它为分配给每个单独功能的帧边界提供了物理存储空间。到主goroutine执行清单1中的main函数时，程序堆栈（非常高级）将如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图1：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图1中，您可以看到堆栈的一部分已针对主要功能进行了“框架化”。</font><font style="vertical-align: inherit;">此部分称为“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈框架</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”，正是该框架表示堆栈上主要功能的边界。</font><font style="vertical-align: inherit;">框架被设置为在调用函数时执行的代码的一部分。</font><font style="vertical-align: inherit;">您还可以看到，count变量的内存已分配给main框架内的0x10429fa4。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还有一个有趣的地方，如图1所示。活动帧下的所有堆栈内存均无效，但活动帧及其后的堆栈内存均有效。</font><font style="vertical-align: inherit;">您需要清楚地了解堆栈的有效部分和无效部分之间的边界。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地址</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
变量用于为特定存储单元分配名称，以提高代码的可读性并帮助您了解所使用的数据。</font><font style="vertical-align: inherit;">如果您有一个变量，那么您在内存中就有一个值，如果您有一个值在内存中，那么它必须有一个地址。</font><font style="vertical-align: inherit;">在第09行，主函数调用内置的println函数以显示count变量的“值”和“地址”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单2：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用＆号获取变量位置的地址并不是什么新鲜事，其他语言也使用此运算符。</font><font style="vertical-align: inherit;">如果在32位体系结构（例如Go Playground）上运行代码，则第09行的输出应类似于以下输出：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单3：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数调用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，在第12行，主要功能调用了增量功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单4：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进行函数调用意味着程序必须在堆栈上创建新的内存部分。但是，一切都有些复杂。为了成功完成一个函数调用，期望在过渡期间跨帧边界传输数据并将其放置在新帧中。特别地，期望在呼叫期间复制并发送整数值。您可以通过查看第18行上的递增函数的声明来了解此需求。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单5：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果再次查看对第12行的增量函数的调用，您将看到代码传递了变量计数的“值”。该值将被复制，传输并放置在用于增量功能的新帧中。请记住，增量函数只能在其自己的帧中读写存储器，因此它需要inc变量来获取，存储和访问其自己的已传输计数器值的副本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在增量函数中的代码开始执行之前，程序堆栈（非常高的层次）将如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图2：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您会看到堆栈上现在有两帧-一帧为主帧，一帧为增量帧。</font><font style="vertical-align: inherit;">在增量框架内，您可以看到包含值10的inc变量，该变量在函数调用期间被复制并传递。</font><font style="vertical-align: inherit;">inc变量地址为0x10429f98，它在内存中较小，因为帧被压入堆栈，这只是实现细节，没有任何意义。</font><font style="vertical-align: inherit;">重要的是该程序从main框架中检索计数值，并将该值的副本放置在框架中以使用inc变量增加。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其余代码在增量内递增，并显示inc变量的“值”和“地址”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单6：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操场上第22行的输出应如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单7：</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行相同的代码行后，堆栈显示如下：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图3：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
执行第21和22行之后，递增函数结束，并将控制权返回给主函数。</font><font style="vertical-align: inherit;">然后，main函数再次在第14行显示局部变量计数的“值”和“地址”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单8：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
操场上程序的完整输出应如下所示：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单9：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
main帧中的计数值在调用增量之前和之后是相同的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从函数返回</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当函数退出并且控制权返回到调用函数时，堆栈上的内存实际上发生了什么？简短的答案是什么。返回增量函数后的堆栈如下</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所示</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">图4：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
堆栈看上去与图3完全相同，只是现在将与增量函数关联的帧视为无效内存。这是因为main的框架现在处于活动状态。为增量功能创建的内存保持不变。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清除返回函数的内存框架将浪费时间，因为尚不清楚是否会再次需要此内存。</font><font style="vertical-align: inherit;">因此记忆仍然保持原样。</font><font style="vertical-align: inherit;">在每个函数调用期间，当拍摄一个帧时，将清除该帧的堆栈存储器。</font><font style="vertical-align: inherit;">这是通过初始化适合框架的任何值来完成的。</font><font style="vertical-align: inherit;">由于所有值都初始化为它们的``零值''，因此每次函数调用都会正确清除堆栈。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">价值共享</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果对于增量函数直接使用main框架中存在的count变量很重要，该怎么办？</font><font style="vertical-align: inherit;">这是指针的时机到了。</font><font style="vertical-align: inherit;">指针有一个目的-与函数共享一个值，以便该函数可以读取和写入此值，即使该值不直接存在于其框架中也是如此。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您认为不需要“共享”值，则无需使用指针。</font><font style="vertical-align: inherit;">学习指针时，请务必使用简洁的字典，而不是运算符或语法。</font><font style="vertical-align: inherit;">请记住，指针旨在共享，并且在阅读代码时，将＆运算符替换为短语“ sharing”。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针类型</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于您声明的或由语言本身直接声明的每种类型，您将获得一个可用于共享的免费指针类型。已经有一个称为int的内置类型，因此有一个名为* int的指针类型。如果声明一个名为User的类型，则免费获得一个名为* User的指针类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有类型的指针都有两个相同的特征。首先，它们以*字符开头。其次，它们在内存中的大小都相同，并且占据4或8个字节的表示形式代表该地址。在32位体系结构（例如，在游乐场）上，指针需要4字节的内存，而在64位体系结构（例如，您的计算机）上，指针则需要8字节的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在规范中，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针类型</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">被认为是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型文字</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这意味着它们是由现有类型组成的无名类型。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">间接内存访问</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看一下这个小程序，它通过“按值”传递地址来进行函数调用。</font><font style="vertical-align: inherit;">这将使用增量函数从主堆栈的堆栈帧中拆分count变量：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单10：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对原始程序进行了三个有趣的更改。</font><font style="vertical-align: inherit;">第一个更改在第12行：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单11：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，在第12行，代码不复制“值”并将其传递给count变量，而是传递其“ address”而不是count变量。现在您可以说：“我正在共享”带有函数增量的变量计数。这就是＆运算符所说的“共享”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道这仍然是“按值传递”，唯一的区别是传递的值是地址，而不是整数。地址也是值；这就是复制并跨过框架边界传递的内容，以调用该函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于地址值已复制并传递，因此您需要在增量框架内添加一个变量来获取和保存该整数地址。第18行上有一个整数指针变量声明。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单12：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果传递了类型为User的值的地址，则必须将变量声明为* User。尽管所有指针变量都存储了地址值，但它们不能传递任何地址，只能传递与指针类型关联的地址。共享值的基本原理是接收函数必须读取或写入该值。您需要有关任何值类型的信息，以便对其进行读写。编译器将确保此函数仅使用与正确的指针类型关联的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
调用递增函数后，堆栈如下</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所示</font><font style="vertical-align: inherit;">：</font><font style="vertical-align: inherit;">图5：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图5显示了使用地址作为值执行“按值传递”时的堆栈外观。现在，增量功能框架内的指针变量指向位于main框架内的count变量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，使用指针变量，该函数可以对位于main框架内的count变量执行间接读取和更改操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单13：</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，*字符充当运算符，并应用于指针变量。使用*作为运算符意味着“指针指向的值”。指针变量提供对使用它的函数框架之外的内存的间接访问。有时，这种间接读取或写入称为指针取消引用。增量函数仍然需要在其框架中具有一个指针变量，可以直接读取该指针变量以执行间接访问。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图6显示了第21行之后的堆栈外观。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图6：</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是该程序的最终输出：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
清单14：</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可能会注意到inc指针变量的“值”与计数变量的“地址”匹配。</font><font style="vertical-align: inherit;">这建立了共享关系，允许间接访问框架外的内存。</font><font style="vertical-align: inherit;">增量函数通过指针写入后，一旦将控制返回给主函数，该更改便对主函数可见。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针变量并不特殊</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指针变量不是特殊的，因为它们是与任何其他变量相同的变量。</font><font style="vertical-align: inherit;">它们具有内存分配，并且包含含义。</font><font style="vertical-align: inherit;">碰巧的是，所有指针变量（无论它们可以指向的值的类型）始终具有相同的大小和表示形式。</font><font style="vertical-align: inherit;">令人困惑的是，*字符充当代码内的运算符，并用于声明指针类型。</font><font style="vertical-align: inherit;">如果可以将类型声明与指针操作区分开，则可以帮助消除一些混乱。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章描述了指针的用途，堆栈的操作以及Go中指针的机制。</font><font style="vertical-align: inherit;">这是理解编写连贯且可读的代码所需的机制，设计原理和使用技术的第一步。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，这是您学到的知识：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在帧边界内执行功能，这为每个相应功能提供了单独的存储空间。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">调用函数时，会在两个帧之间发生过渡。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“按值”数据传输的优点是可读性。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆栈很重要，因为它为分配给每个单独功能的帧边界提供了物理存储空间。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">活动框架下方的所有堆栈内存均无效，但活动框架及其上方的所有堆栈内存均有效。</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN496832/index.html">摄影之旅：ITMO新物理研究所的混合纳米光子学和光电子学实验室正在做什么</a></li>
<li><a href="../zh-CN496836/index.html">QSerializer：简单JSON / XML序列化的解决方案</a></li>
<li><a href="../zh-CN496838/index.html">Slack使用的项目部署方法</a></li>
<li><a href="../zh-CN496840/index.html">马斯克认为，1.2万颗卫星不会干扰天文学家。他的意见与模型不符</a></li>
<li><a href="../zh-CN496842/index.html">具有基本Python工具的简单流行模型</a></li>
<li><a href="../zh-CN496848/index.html">＃340移动开发人员的有趣材料摘要（4月6日至12日）</a></li>
<li><a href="../zh-CN496850/index.html">Java 14的JPackage Maven插件</a></li>
<li><a href="../zh-CN496852/index.html">顺利排序</a></li>
<li><a href="../zh-CN496856/index.html">没有遥控器，但带有立方体的智能家居</a></li>
<li><a href="../zh-CN496858/index.html">FOSS新闻第11号-2020年4月6日至12日免费和开源软件回顾</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>