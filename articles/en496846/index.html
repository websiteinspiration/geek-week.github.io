<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👐🏻 👩🏽‍🤝‍👩🏼 👴🏽 Language mechanics of stacks and pointers 🎀 🎅🏽 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prelude
 This is the first of four articles in the series that will provide insight into the mechanics and design of pointers, stacks, heaps, escape a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Language mechanics of stacks and pointers</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496846/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prelude</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is the first of four articles in the series that will provide insight into the mechanics and design of pointers, stacks, heaps, escape analysis, and Go / pointer semantics. </font><font style="vertical-align: inherit;">This post is about stacks and pointers. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Table of Contents:</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Language Mechanics On Stacks And Pointers</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Language Mechanics On Escape Analysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">translation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Language Mechanics On Memory Profiling</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Design Philosophy On Data And Semantics</font></font></a></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Introduction</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will not dissemble - pointers are difficult to understand. </font><font style="vertical-align: inherit;">If used improperly, pointers can cause unpleasant errors and even performance problems. </font><font style="vertical-align: inherit;">This is especially true when writing competitive or multithreaded programs. </font><font style="vertical-align: inherit;">Not surprisingly, many languages ​​try to hide pointers from programmers. </font><font style="vertical-align: inherit;">However, if you write in Go, you cannot escape pointers. </font><font style="vertical-align: inherit;">Without a clear understanding of pointers, it will be difficult for you to write clean, simple, and efficient code.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame borders</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functions are performed within the boundaries of frames that provide a separate memory space for each corresponding function. Each frame allows the function to work in its own context, and also provides flow control. A function has direct access to memory inside its frame via a pointer, but access to memory outside the frame requires indirect access. For a function to access memory outside its frame, this memory must be used in conjunction with this function. The mechanics and limitations set by these boundaries must be understood and studied first.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When a function is called, a transition between two frames occurs. The code goes from the frame of the calling function to the frame of the called function. If the data is needed to call the function, then this data must be transferred from one frame to another. The transfer of data between two frames in Go is done "by value." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The advantage of “by value” data transmission is readability. The value that you see in the function call is what is copied and accepted on the other side. That's why I associate “pass by value” with WYSIWYG, because what you see is what you get. All this allows you to write code that does not hide the cost of switching between two functions. This helps maintain a good mental model of how each function call will affect the program during the transition.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Look at this little program that calls a function by passing integer data "by value": </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 1:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "value of" the count.</span>
<span class="hljs-number">12</span>    increment(count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" inc.</span>
<span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When your Go program starts, the runtime creates the main goroutine to start executing all the code, including the code inside the main function. Gorutin is the execution path that fits into the thread of the operating system, which ultimately runs on some kernel. Starting with version 1.8, each goroutine is provided with an initial block of continuous memory of 2048 bytes in size, which forms the stack space. This initial stack size has changed over the years and may change in the future. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The stack is important because it provides physical memory space for the frame boundaries that are given to each individual function. By the time the main goroutine performs the main function in Listing 1, the program stack (at a very high level) will look like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 1:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z4/7w/l0/z47wl0tm16nh5u-gf8u9m0kemba.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Figure 1, you can see that part of the stack was “framed” for the main function. </font><font style="vertical-align: inherit;">This section is called the " </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stack frame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ", and it is this frame that denotes the boundary of the main function on the stack. </font><font style="vertical-align: inherit;">The frame is set as part of the code that executes when the function is called. </font><font style="vertical-align: inherit;">You can also see that the memory for the count variable was allocated at 0x10429fa4 inside the frame for main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is another interesting point, illustrated in Figure 1. All the stack memory under the active frame is not valid, but the memory from the active frame and above is valid. </font><font style="vertical-align: inherit;">You need to clearly understand the boundary between the valid and invalid part of the stack.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Addresses</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Variables are used to assign a name to a specific memory cell to improve the readability of the code and help you understand what data you are working with. </font><font style="vertical-align: inherit;">If you have a variable, then you have a value in memory, and if you have a value in memory, then it must have an address. </font><font style="vertical-align: inherit;">On line 09, the main function calls the built-in println function to display the "value" and "address" of the count variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using the ampersand “&amp;” to get the address of a variable’s location is not new, other languages ​​also use this operator. </font><font style="vertical-align: inherit;">The output of line 09 should look like the output below if you are running code on a 32-bit architecture such as Go Playground: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 3:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Function Call</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, on line 12, the main function calls the increment function. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 4:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Making a function call means that the program must create a new section of memory on the stack. However, everything is a little more complicated. To successfully complete a function call, it is expected that data will be transferred across the frame boundary and placed in a new frame during the transition. In particular, an integer value is expected to be copied and transmitted during the call. You can see this requirement by looking at the declaration of the increment function on line 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 5:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc <span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you look again at the call to the increment function on line 12, you will see that the code passes the “value” of the variable count. This value will be copied, transferred, and placed in a new frame for the increment function. Remember that the increment function can only read and write to memory in its own frame, so it needs the inc variable to get, store and access its own copy of the transmitted counter value. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Just before the code inside the increment function starts to execute, the program stack (at a very high level) will look like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 2:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2g/jw/n9/2gjwn96mbhikaxys6ftv3cf4s14.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can see that there are now two frames on the stack - one for main and one below for increment. </font><font style="vertical-align: inherit;">Inside the frame for increment, you can see the inc variable containing the value 10, which was copied and passed during the function call. </font><font style="vertical-align: inherit;">The inc variable address is 0x10429f98, and it is smaller in memory because the frames are pushed onto the stack, which are just implementation details that mean nothing. </font><font style="vertical-align: inherit;">The important thing is that the program retrieved the count value from the frame for main and placed a copy of this value in the frame to increase using the inc variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The rest of the code inside increment increments and displays the "value" and "address" of the inc variable. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 6:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The output of line 22 in the playground should look something like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 7:</font></font><br>
<br>
<pre><code class="go hljs">inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what the stack looks like after executing the same lines of code: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 3: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/59/1o/kv/591okvkseze5gjqum4k8hp-qv34.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After executing lines 21 and 22, the increment function ends and returns control to the main function. </font><font style="vertical-align: inherit;">Then the main function again displays the “value” and “address” of the local variable count on line 14. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 8:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>,count, <span class="hljs-string">"]\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The full output of the program in the playground should look something like this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 9:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">11</span> ]  Addr Of[ <span class="hljs-number">0x10429f98</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">10</span> ]  Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The count value in the frame for main is the same before and after the call to increment.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Return from functions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What actually happens to the memory on the stack when the function exits and control returns to the calling function? The short answer is nothing. Here's what the stack looks like after the increment function returns: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 4: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qq/ve/-n/qqve-nygmg0jnhsnwrubpchwfky.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The stack looks exactly the same as in Figure 3, except that the frame associated with the increment function is now considered invalid memory. This is because the frame for main is now active. The memory created for the increment function has remained untouched.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clearing the memory frame of the return function will be a waste of time, because it is not known whether this memory will ever be needed again. </font><font style="vertical-align: inherit;">So the memory remained the way it was. </font><font style="vertical-align: inherit;">During each function call, when a frame is taken, the stack memory for this frame is cleared. </font><font style="vertical-align: inherit;">This is done by initializing any values ​​that fit into the frame. </font><font style="vertical-align: inherit;">Since all values ​​are initialized as their "zero value", the stacks are correctly cleared with every function call.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Value Sharing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What if it was important for the increment function to work directly with the count variable that exists inside the frame for main? </font><font style="vertical-align: inherit;">This is where the time comes for pointers. </font><font style="vertical-align: inherit;">Pointers serve one purpose - to share a value with a function so that the function can read and write this value, even if the value does not exist directly within its frame. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you don’t think you need to “share” the value, then you don’t need to use a pointer. </font><font style="vertical-align: inherit;">When learning pointers, it’s important to think that using a clean dictionary, not operators or syntax. </font><font style="vertical-align: inherit;">Remember that pointers are intended to be shared and when reading code replace the &amp; operator with the phrase “sharing”.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Types of Pointers</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For each type that you declared, or that was declared directly by the language itself, you get a free pointer type that you can use for sharing. There is already a built-in type called int, so there is a pointer type named * int. If you declare a type named User, you get a pointer type named * User for free. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All types of pointers have two identical characteristics. First, they start with the * character. Secondly, they all have the same size in memory and a representation occupying 4 or 8 bytes that represent the address. On 32-bit architectures (for example, in the playground) pointers require 4 bytes of memory, and on 64-bit architectures (for example, your computer) they require 8 bytes of memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the specification, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pointer types</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are considered </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">type literals</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which means they are nameless types made up of an existing type.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Indirect memory access</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Look at this little program that makes a function call, passing the address "by value". </font><font style="vertical-align: inherit;">This will split the count variable from the stack frame of main with the increment function: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 10:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">01</span> <span class="hljs-keyword">package</span> main
<span class="hljs-number">02</span>
<span class="hljs-number">03</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-number">04</span>
<span class="hljs-number">05</span>    <span class="hljs-comment">// Declare variable of type int with a value of 10.</span>
<span class="hljs-number">06</span>    count := <span class="hljs-number">10</span>
<span class="hljs-number">07</span>
<span class="hljs-number">08</span>    <span class="hljs-comment">// Display the "value of" and "address of" count.</span>
<span class="hljs-number">09</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">10</span>
<span class="hljs-number">11</span>    <span class="hljs-comment">// Pass the "address of" count.</span>
<span class="hljs-number">12</span>    increment(&amp;count)
<span class="hljs-number">13</span>
<span class="hljs-number">14</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"count:\tValue Of["</span>, count, <span class="hljs-string">"]\t\tAddr Of["</span>, &amp;count, <span class="hljs-string">"]"</span>)
<span class="hljs-number">15</span> }
<span class="hljs-number">16</span>
<span class="hljs-number">17</span> <span class="hljs-comment">//go:noinline</span>
<span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {
<span class="hljs-number">19</span>
<span class="hljs-number">20</span>    <span class="hljs-comment">// Increment the "value of" count that the "pointer points to". (dereferencing)</span>
<span class="hljs-number">21</span>    *inc++
<span class="hljs-number">22</span>    <span class="hljs-built_in">println</span>(<span class="hljs-string">"inc:\tValue Of["</span>, inc, <span class="hljs-string">"]\tAddr Of["</span>, &amp;inc, <span class="hljs-string">"]\tValue Points To["</span>, *inc, <span class="hljs-string">"]"</span>)
<span class="hljs-number">23</span> }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Three interesting changes were made to the original program. </font><font style="vertical-align: inherit;">The first change is on line 12: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 11:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">12</span>    increment(&amp;count)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time, on line 12, the code does not copy and passes the "value" to the count variable, but passes its "address" instead of the count variable. Now you can say: “I am sharing” the variable count with the function increment. This is what the &amp; operator says - “share.” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Understand that this is still “passing by value,” and the only difference is that the value you pass is the address, not the integer. Addresses are also values; this is what is copied and passed across the border of the frame to call the function. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the address value is copied and passed, you need a variable inside the increment frame to get and save this integer address. An integer pointer variable declaration is on line 18. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 12:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">18</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">increment</span><span class="hljs-params">(inc *<span class="hljs-keyword">int</span>)</span></span> {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If you passed the address of the value of type User, then the variable would have to be declared as * User. Despite the fact that all pointer variables store address values, they cannot be passed any address, only addresses associated with the type of pointer. The basic principle of sharing a value is that the receiving function must read or write to that value. You need information about the type of any value to read and write to it. The compiler will ensure that only values ​​associated with the correct pointer type are used with this function. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what the stack looks like after calling the increment function: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 5:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uk/ak/zj/ukakzj1mpr_9m3thjmv2i04e_hw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 5 shows what the stack looks like when "pass by value" is performed using the address as the value. The pointer variable inside the frame for the increment function now points to the count variable, which is located inside the frame for main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, using the pointer variable, the function can perform an indirect read and change operation for the count variable located inside the frame for main. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 13:</font></font><br>
<br>
<pre><code class="go hljs"><span class="hljs-number">21</span>    *inc++</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This time, the * character acts as an operator and is applied to the pointer variable. Using * as an operator means "the value that the pointer points to." A pointer variable provides indirect access to memory outside the frame of the function that uses it. Sometimes this indirect reading or writing is called pointer dereferencing. The increment function still needs to have a pointer variable in its frame, which it can directly read to perform indirect access. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6 shows what the stack looks like after line 21. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Figure 6: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rn/ph/vi/rnphvi1x69rrhspljslmvxilauq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is the final output from this program: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 14:</font></font><br>
<br>
<pre><code class="go hljs">count:  Value Of[ <span class="hljs-number">10</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]<font></font>
inc:    Value Of[ <span class="hljs-number">0x10429fa4</span> ]      Addr Of[ <span class="hljs-number">0x10429f98</span> ]   Value Points To[ <span class="hljs-number">11</span> ]<font></font>
count:  Value Of[ <span class="hljs-number">11</span> ]              Addr Of[ <span class="hljs-number">0x10429fa4</span> ]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You may notice that the “value” of the inc pointer variable matches the “address” of the count variable. </font><font style="vertical-align: inherit;">This establishes a sharing relationship that allowed indirect access to memory outside the frame. </font><font style="vertical-align: inherit;">As soon as the increment function writes through the pointer, the change is visible to the main function when control is returned to it.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pointer variables are not special</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pointer variables are not special because they are the same variables as any other variable. </font><font style="vertical-align: inherit;">They have a memory allocation, and they contain meaning. </font><font style="vertical-align: inherit;">It just so happened that all pointer variables, regardless of the type of value they can point to, always have the same size and presentation. </font><font style="vertical-align: inherit;">What can be confusing is that the * character acts as an operator inside the code and is used to declare a pointer type. </font><font style="vertical-align: inherit;">If you can distinguish a type declaration from a pointer operation, this can help eliminate some confusion.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This post describes the purpose of pointers, the operation of the stack, and the mechanics of pointers in Go. </font><font style="vertical-align: inherit;">This is the first step in understanding the mechanics, design principles, and usage techniques needed to write coherent and readable code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, here is what you learned:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Functions are performed within the frame boundaries, which provide a separate memory space for each corresponding function.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When a function is called, a transition between two frames occurs.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantage of “by value” data transmission is readability.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The stack is important because it provides physical memory space for the frame boundaries that are given to each individual function.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All stack memory below the active frame is invalid, but memory from the active frame and above is valid.</font></font></li>
<li>   ,         .</li>
<li>    ,   ,      .</li>
<li>    —    ,        ,         .</li>
<li>   ,  ,   ,     ,      .</li>
<li>-          ,   .</li>
<li>-   - ,      ,     .     ,    .</li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496832/index.html">Photo tour: what are they doing in the laboratory of hybrid nanophotonics and optoelectronics of the New Physics Institute ITMO</a></li>
<li><a href="../en496836/index.html">QSerializer: solution for simple JSON / XML serialization</a></li>
<li><a href="../en496838/index.html">Project deployment methodology used by Slack</a></li>
<li><a href="../en496840/index.html">Musk believes that 12 thousand satellites will not interfere with astronomers. His opinion is not consistent with the model</a></li>
<li><a href="../en496842/index.html">A simple epidemic model with basic Python tools</a></li>
<li><a href="../en496848/index.html">The digest of interesting materials for the mobile # 340 developer (on April 6 - 12)</a></li>
<li><a href="../en496850/index.html">Maven plugin for JPackage from Java 14</a></li>
<li><a href="../en496852/index.html">Smooth sorting</a></li>
<li><a href="../en496856/index.html">Smart home without remotes, but with a cube</a></li>
<li><a href="../en496858/index.html">FOSS News No. 11 - a review of free and open source software for April 6-12, 2020</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>