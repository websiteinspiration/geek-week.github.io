<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥦 🐮 🤧 競争的コーティニズムについて（例としてリアクティブプログラミングを使用） 💨 🕦 🧙🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.はじめに
 プログラマーの心、気分、願望をめぐる競争は、私には思えるように、プログラミング開発における現代の傾向です。ほとんど何も提案されていないとき、それのための闘争のスローガンの下で。ソフトウェアのパラダイムの突破の中で何か新しいものを認識することは非常に非常に困難です。実際、それはしばしば...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>競争的コーティニズムについて（例としてリアクティブプログラミングを使用）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487720/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.はじめに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーの心、気分、願望をめぐる競争は、私には思えるように、プログラミング開発における現代の傾向です。ほとんど何も提案されていないとき、それのための闘争のスローガンの下で。ソフトウェアのパラダイムの突破の中で何か新しいものを認識することは非常に非常に困難です。実際、それはしばしば非常によく知られており、時には単に古くなっていることが判明しています。多くのプログラミング言語では、用語の楽しみ、詳細な分析、複数行の例によってすべてが洗い流されています。同時に、ソリューションの背景を開いたり検討したりする要求、イノベーションの本質は頑固に回避され、これがどれだけ必要か、最終的に何が得られるかを突き止める試みは、既知のアプローチやプログラミングツールと革新を質的に区別しているため、発芽を阻止できます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるフリーズの後、議論の1つできちんと気づかれたように、私はハブレに登場しました。私も気にしません。少なくとも、印象は明らかにそれだけです。したがって、私は同意します。自白しますが、それが私のせいである場合、それは部分的にのみです。確かに、私は前世紀の80年代に結成された並列プログラミングについてのアイデアに生きています。古代？多分。しかし、[並列]プログラミングの科学がまだ知られていない、何が新しいのか教えてください（詳細[1]を参照）。当時、並列プログラムは、並列-直列と非同期の2つのクラスに分類されていました。前者がすでに古風であると考えられていた場合、後者は-高度で真に平行しています。後者の中では、イベント制御（または単にイベントプログラミング）、ストリーム制御、および動的プログラミングを使用したプログラミングが選択されました。これですべてです。さらなる詳細はすでに。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、少なくとも40年前にすでに知られているものに加えて、現在のプログラミングは何を提供していますか？私の「凍傷に見える」-何も。結局のところ、コルーチンはコルーチンまたはゴルーチンと呼ばれるようになりました。同時実行性と競争という用語は、翻訳者だけでなく、混乱に陥るようです。そして、そのような例はありません。たとえば、リアクティブプログラミング（RP）とイベントプログラミングまたはストリーミングの違いは何ですか？既知のカテゴリおよび/または分類のどれに該当しますか？誰もこれに興味がないようで、誰もこれを明確にすることはできません。それとも名前で分類できますか？そして、実際には、コルーチンとコルーチンは異なるものであり、並列プログラミングは単に競合プログラミングとは異なるものにならざるを得ません。ステートマシンはどうですか？これはどんな奇跡のテクニックですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭の「スパゲッティ」は、新しいモデルが導入されたときに、それが既知のよく研究されているモデルと比較されるという理論の忘却から生じます。</font><font style="vertical-align: inherit;">これがうまくいくかどうか、しかし少なくともあなたはそれを理解することができます、なぜならプロセスは形式化されているからです。</font><font style="vertical-align: inherit;">しかし、コルーチンに新しいニックネームを付け、「フードコード」を5つの言語で同時に選択して、スレッドへの移行の可能性に加えて評価する場合の問題の根底にある方法。</font><font style="vertical-align: inherit;">そして、これらはコルーチンにすぎません。率直に言って、その基本的な性質とそれらの小さな使用のために、すでに忘れられているはずです（もちろん、私の経験についてです）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.リアクティブプログラミングとすべて、すべて、すべて</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「リアクティブプログラミング」の概念を完全に理解するという目標を設定するつもりはありませんが、「ディスカッションの例」をさらなる議論の基礎として取り上げます。</font><font style="vertical-align: inherit;">彼の正式なモデルは、有名な正式なモデルに基づいて作成されます。</font><font style="vertical-align: inherit;">これにより、元のプログラムの解釈と操作を明確、正確、詳細に理解できるようになることを願っています。</font><font style="vertical-align: inherit;">ただし、作成されたモデルとその実装がどの程度「反応」するかは、このタイプのプログラミングの謝罪担当者が決定します。</font><font style="vertical-align: inherit;">現時点では、新しいモデルが元の例のすべてのニュアンスを実装/モデル化する必要があるだけで十分です。</font><font style="vertical-align: inherit;">何かが考慮されていない場合は、私を修正する人がいることを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、[2]では、リアクティブプログラムの例を検討しました。そのコードをリスト1に示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト1.リアクティブプログラムコード</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">1. 1 = 2 <font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2 <font></font>
4.  1, 2, 3 <font></font>
5. 1 = 4 <font></font>
6.  1, 2, 3</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リアクティブプログラミングの世界では、その作業の結果は、同じ種類の通常のプログラムの結果とは異なります。醜さを言わないにしても、これだけでは悪いのです。プログラムの結果は明確で、実装に依存しないものでなければなりません。しかし、もっと混乱します。まず、外見上、通常の類似したコードと反応的なコードを区別することはほとんど不可能です。第二に、どうやら、作者自身はリアクティブプログラムの作業に完全に確信が持てず、結果を「最も可能性が高い」と語っています。そして第三に、どの結果が正しいと考えられますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの解釈におけるこのようなあいまいさにより、すぐにコードに「割り込む」ことができないという事実につながりました。</font><font style="vertical-align: inherit;">しかし、よくあることですが、すべてが予想よりもはるかに単純であることがわかりました。</font><font style="vertical-align: inherit;">図1は、できれば構造に対応し、例の動作を説明する2つの構造図を示しています。</font><font style="vertical-align: inherit;">上の図では、ブロックX1とX2がデータ入力を整理し、ブロックX3にそれらの変更を通知します。</font><font style="vertical-align: inherit;">後者は合計を実行し、Prブロックが変数の現在の値を出力できるようにします。</font><font style="vertical-align: inherit;">印刷が完了すると、PrブロックはX3ブロック、さらに彼に、そして彼にのみ新しい値を印刷する準備ができていることを通知します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">1.例の2つの構造モデル</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/tw/hs/rq/twhsrqxfdfuyxi4txtd9ciat6hs.jpeg" alt="image"><br>
</div></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のスキームと比較して、2番目のスキームは非常に初歩的です。単一ブロックの一部として、データを入力して順次実装します。1）入力データの合計を計算し、2）それらを印刷します。このレベルの表示でのブロックの内部充填は公開されていません。構造的には「4ブロック方式を含むブラックボックス」と言える。しかし、それでも、彼の[アルゴリズム]デバイスは異なるはずです。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コメント。ブラックボックスとしてのプログラムへのアプローチは、基本的にはプログラムに対するユーザーの態度を反映しています。後者は、その実装には関心がなく、作業の結果に関心があります。それが反応型プログラムであろうと、イベントプログラムであろうと、その他であっても、アルゴリズムの理論に従った結果は、明確で予測可能でなければなりません。</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図では </font><font style="vertical-align: inherit;">2は、回路ブロックの内部[アルゴリズム]構造を詳細に明らかにするアルゴリズムモデルを示しています。</font><font style="vertical-align: inherit;">上位モデルはオートマトンのネットワークで表され、各オートマトンは個別のブロックのアルゴリズムモデルです。</font><font style="vertical-align: inherit;">一点鎖線の弧で示されているオートマトン間の接続は、回路の接続に対応しています。</font><font style="vertical-align: inherit;">単一オートマトンモデルは、1つのブロックで構成されるブロック線図の操作アルゴリズムを記述します（図1の別のPrブロックを参照）。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">2.構造スキームのアルゴリズムモデル</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/rj/4f/ds/rj4fdsx8kekihnbqqebmpji1y9e.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンX1およびX2（オートマトンおよびブロックの名前はそれらの変数の名前と一致します）、変更を検出し、オートマトンX3が追加操作を実行する準備ができている場合（状態「s0」で）、状態「s1」に入り、変数の現在の値を記憶します。状態「s1」に入る許可を受け取ったX3マシンは、追加操作を実行し、必要に応じて、変数の印刷の完了を待ちます。 「印刷機」Prは、印刷が終了すると、初期状態「p0」に戻り、次のコマンドを待ちます。その状態「p1」が逆遷移のチェーンを開始することに注意してください。オートマトンX3は状態「s0」になり、X1とX2は状態「s0」になります。その後、入力データの分析、そしてそれらの合計とその後の印刷が繰り返されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オートマトンネットワークと比較して、個別のPrオートマトンのアルゴリズムは非常に単純ですが、同じ仕事をし、おそらくさらに高速です。</font><font style="vertical-align: inherit;">その述語は変数の変化を明らかにします。</font><font style="vertical-align: inherit;">これが発生した場合、状態「p1」への遷移は、変数yの現在の値を合計しながら、それらを記憶しながらアクションy1（図2を参照）の開始とともに実行されます。</font><font style="vertical-align: inherit;">次に、状態「p1」から状態「p0」への無条件遷移で、アクションy2は変数を出力します。</font><font style="vertical-align: inherit;">その後、プロセスは入力データの分析に戻ります。</font><font style="vertical-align: inherit;">最新のモデルの実装コードをリスト2に示します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト2. Prオートマトンの実装</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span>
<span class="hljs-keyword">extern</span> LArc TBL_PlusX3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPlusX3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPlusX3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPlusX3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_PlusX3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarX1;        		<span class="hljs-comment">// </span>
    CVar *pVarX2;        		<span class="hljs-comment">// </span>
    CVar *pVarX3;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//   X1</span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//   X2</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX1{<span class="hljs-number">0</span>};
    <span class="hljs-keyword">double</span> dSaveX2{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fplusx3.h"</span></span><font></font>
<font></font>
LArc TBL_PlusX3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPlusX3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"dX1"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX2 = CreateLocVar(<span class="hljs-string">"dX2"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"dX3"</span>, CLocVar::vtDouble, <span class="hljs-string">""</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    str = pVarStrNameX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX3 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1-&gt;GetDataSrc() != dSaveX1; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPlusX3::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX2-&gt;GetDataSrc() != dSaveX2; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPlusX3::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// X3 = X1 + X2</span>
    <span class="hljs-keyword">double</span> dX1 = pVarX1-&gt;GetDataSrc(); <span class="hljs-keyword">double</span> dX2 = pVarX2-&gt;GetDataSrc();
    <span class="hljs-keyword">double</span> dX3 = dX1 + dX2;<font></font>
    pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, dX3);<font></font>
    dSaveX1 = dX1; dSaveX2 = dX2;<font></font>
<span class="hljs-comment">//  1, 2, 3</span><font></font>
    QString strX1; strX1.setNum(dX1); QString strX2; strX2.setNum(dX2);<font></font>
    QString strX3; strX3.setNum(dX3);<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの量は、明らかに元の例とは比較にならないほど大きくなっています。ただし、単一のコードではないことに注意してください。新しいソリューションは、機能のすべての問題を取り除き、プログラムの解釈の空想に遭遇することを許可しません。見た目はコンパクトでエレガントですが、「可能性が高い」と言える作品は、ポジティブな感情やそれを使って仕事をしたいという気持ちを引き起こしません。また、オートマトンy1の動作と実際に比較する必要があることにも注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの残りの部分は「自動環境」の要件に関連していますが、これはソースコードでは話されていません。だから、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FCreationOfLinksForVariablesの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方法</font><font style="vertical-align: inherit;">基本オートマトンクラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マシンのローカル変数を作成し、VKPA環境のレベルでそれらに関連付けられている他の環境変数のシンボリック名が示されている場合にそれらにリンクします。最初にオートマトンを作成するときに開始し、次に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FInit</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドのフレームワーク内で</font><font style="vertical-align: inherit;">（ステップy12を参照）、オブジェクトの作成時にすべてのリンクが認識されるわけではありません。マシンは、x12述語チェックで必要なすべてのリンクが初期化されるまで、「st」状態になります。変数への参照は、その名前が指定されている場合、GetAddressVarメソッドを返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考えられる質問を削除するために、オートマトンネットワークのコードを示します。</font><font style="vertical-align: inherit;">リスト3に示すように、3つのオートマトンクラスのコードが含まれています。</font><font style="vertical-align: inherit;">図1に示すネットワークの構造図に対応する多くのオブジェクトが作成されるのは、それらに基づいています。</font><font style="vertical-align: inherit;">1.オブジェクトX1およびX2は、一般クラスFSynchから派生していることに注意してください。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リスト3.自動化されたネットワーククラス</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Synch[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSynch</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSynch(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FSynch(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Synch, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX;			<span class="hljs-comment">// </span>
    CVar *pVarStrNameX;		<span class="hljs-comment">//   </span>
    CVar *pVarStrNameObject;<span class="hljs-comment">//  -</span>
    LFsaAppl *pL {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX-&gt;GetDataSrc() != dSaveX; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pL != <span class="hljs-literal">nullptr</span>; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ dSaveX = pVarX-&gt;GetDataSrc(); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };
    <span class="hljs-keyword">double</span> dSaveX{<span class="hljs-number">0</span>};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
LArc TBL_Synch[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x2"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSynch::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameObject = CreateLocVar(<span class="hljs-string">"strNameObject"</span>, CLocVar::vtString, <span class="hljs-string">"name of function"</span>);                   <span class="hljs-comment">//  </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX) {<font></font>
        str = pVarStrNameX-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    str = pVarStrNameObject-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pL = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_X1X2X3[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dGetData</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX3-&gt;GetDataSrc(); };
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FX1X2X3(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FX1X2X3(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_X1X2X3, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarX1{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX2{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarX3{<span class="hljs-literal">nullptr</span>};			<span class="hljs-comment">//</span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//  X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//  X2</span>
    CVar *pVarStrNameFPr;		<span class="hljs-comment">//  Pr</span>
    CVar *pVarStrNameX3;		<span class="hljs-comment">//   </span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};<font></font>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};<font></font>
    LFsaAppl *pLPr {<span class="hljs-literal">nullptr</span>};
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX1-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX2-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x3</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr-&gt;FGetState() == <span class="hljs-string">"p1"</span>; }
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLPr != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pVarX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span> </span>{ pVarX3-&gt;SetDataSrc(<span class="hljs-keyword">this</span>, pLX1-&gt;dGetData() + pLX2-&gt;dGetData()); }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_X1X2X3[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x2"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x3"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FX1X2X3::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX3 = CreateLocVar(<span class="hljs-string">"x"</span>, CLocVar::vtDouble, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameFPr = CreateLocVar(<span class="hljs-string">"strNameFPr"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);<font></font>
    pVarStrNameX3 = CreateLocVar(<span class="hljs-string">"strNameX3"</span>, CLocVar::vtString, <span class="hljs-string">""</span>);
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str; str = pVarStrNameFX1-&gt;strGetDataSrc();
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFPr-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLPr = FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fsynch.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_Print[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FX1X2X3</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FPrint</span> :</span> <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FPrint(nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
    FPrint(<span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL): LFsaAppl(TBL_Print, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) { }<font></font>
<font></font>
    CVar *pVarY;        		<span class="hljs-comment">// </span>
    CVar *pVarStrNameFX1;		<span class="hljs-comment">//    X1</span>
    CVar *pVarStrNameFX2;		<span class="hljs-comment">//    X2</span>
    CVar *pVarStrNameFX3;		<span class="hljs-comment">//    X3</span>
    FSynch *pLX1 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X1</span>
    FSynch *pLX2 {<span class="hljs-literal">nullptr</span>};     <span class="hljs-comment">//    X2</span>
    FX1X2X3 *pLX3 {<span class="hljs-literal">nullptr</span>};    <span class="hljs-comment">//    X3</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3 != <span class="hljs-literal">nullptr</span> &amp;&amp; pLX1 &amp;&amp; pLX2 &amp;&amp; pLX3; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span> </span>{ FInit(); };<font></font>
};<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fprint.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"fx1x2x3.h"</span></span><font></font>
<font></font>
LArc TBL_Print[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"x12"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p0"</span>,		<span class="hljs-string">"p1"</span>,<span class="hljs-string">"x1"</span>,  <span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"p1"</span>,		<span class="hljs-string">"p0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FPrint::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"strY"</span>, CLocVar::vtString, <span class="hljs-string">"print of output string"</span>);			<span class="hljs-comment">//  </span>
    pVarStrNameFX1 = CreateLocVar(<span class="hljs-string">"strNameFX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX2 = CreateLocVar(<span class="hljs-string">"strNameFX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameFX3 = CreateLocVar(<span class="hljs-string">"strNameFX3"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input object(pr)"</span>);			<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;<font></font>
    str = pVarStrNameFX1-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX1 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX2-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX2 = (FSynch*)FGetPtrFsaAppl(str);	}<font></font>
    str = pVarStrNameFX3-&gt;strGetDataSrc();<font></font>
    <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pLX3 = (FX1X2X3*)FGetPtrFsaAppl(str);	}
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FPrint::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pLX3-&gt;FGetState() == <span class="hljs-string">"s1"</span>; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FPrint::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    QString strX1; strX1.setNum(pLX1-&gt;dGetData());<font></font>
    QString strX2; strX2.setNum(pLX2-&gt;dGetData());<font></font>
    QString strX3; strX3.setNum(pLX3-&gt;dGetData());<font></font>
    QString qstr = <span class="hljs-string">"X1="</span> + strX1 + <span class="hljs-string">", X2="</span> + strX2 + <span class="hljs-string">", X3="</span> + strX3;<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, qstr.toStdString(), <span class="hljs-literal">nullptr</span>);<font></font>
}<font></font>
</code></pre> <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは、設計ドキュメントの飛行機の写真のように、リスト1とは異なります。しかし、私たちは主にプログラマーであり、何人かのデザイナーには何の罪も言われないでしょう。最初のフライトで「飛行機」がクラッシュしないように、「デザインコード」はわかりやすく、明確に解釈できる必要があります。そして、そのような不幸が起こり、プログラムでこれが飛行機よりも頻繁に起こる場合、その理由は簡単かつ迅速に見つけることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、リスト3を考えると、クラスの数が並列プログラム内の対応するオブジェクトの数に直接関係していないことを想像する必要があります。コードはオブジェクト間の関係を反映していませんが、オブジェクトを作成するメカニズムを含んでいます。したがって、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスに</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">タイプのオブジェクトへの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタが含まれ</font><font style="vertical-align: inherit;">ています</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LFsaAppl</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このオブジェクトの名前はVKPa環境で名前付きオートマトン変数に対応するローカル変数によって決定される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strNameObject</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FGetState</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを使用して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FSynch</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプのオートマトンオブジェクトの現在の状態</font><i><font style="vertical-align: inherit;">を</font></i><font style="vertical-align: inherit;">監視</font><font style="vertical-align: inherit;">するには、ポインターが必要です</font><font style="vertical-align: inherit;">（述語コードx2を参照）。オブジェクトへの同様のポインター、オブジェクトの名前を指定するための変数、および関係を編成するために必要な述語には、他のクラスが含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、VKPA環境での並列プログラムの「構築」について少し説明します。プログラム構成のロード中に作成されます。この場合、最初のオブジェクトは、オートマトンタイプのテーマ別動的ライブラリからのクラスに基づいて作成されます（それらのセットは、アプリケーション/プログラムの構成によって決定されます）。作成されたオブジェクトは名前で識別されます（</font><i><font style="vertical-align: inherit;">自動変数</font></i><font style="vertical-align: inherit;">と呼びましょう</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">次に、オートマトンのローカル値に必要な値が割り当てられます。</font><font style="vertical-align: inherit;">この例では、文字列型の変数は、他のオブジェクトの変数名またはオブジェクトの名前、あるいはその両方に設定されます。</font><font style="vertical-align: inherit;">このようにして、並列オートマトンプログラムのオブジェクト間の接続が確立されます（図1を参照）。</font><font style="vertical-align: inherit;">さらに、入力変数の値を変更して（個々のオブジェクト制御ダイアログまたは標準ダイアログ/環境ダイアログを使用して環境変数の値を設定）、結果を修正します。</font><font style="vertical-align: inherit;">変数の値を表示する標準環境ダイアログを使用して表示できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.並列プログラムの分析へ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並列プログラムの機能については、逐次並列が非常に単純でない限り、具体的なことを言うのは非常に困難です。考えられるオートマトンのネットワークも例外ではありません。次に、これを見て、そこから何が期待できるかを理解します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果として得られるオートマトンとそれが構築されたネットワークを図4に示します。</font><font style="vertical-align: inherit;">3.図のネットワークから </font><font style="vertical-align: inherit;">2、その要素の名前を変更することに加えて-オートマトン、入力および出力信号、それは変数の「印刷機」がないことによって区別されます。</font><font style="vertical-align: inherit;">後者はネットワークの操作に必須ではありません。名前を変更すると、合成操作を使用して結果のオートマトンを構築できます。</font><font style="vertical-align: inherit;">また、より短い名前を作成するために、オートマトンAの状態「a0」を記号「0」で表し、「a1」を記号「1」で表すなどのコーディングが導入されました。</font><font style="vertical-align: inherit;">他のマシンについても同様です。</font><font style="vertical-align: inherit;">この場合、ネットワークのコンポーネント状態、たとえば「a1b0c1」には「101」という名前が割り当てられます。</font><font style="vertical-align: inherit;">同様に、名前はネットワークのすべてのコンポーネント状態に対して形成され、その数はコンポーネントオートマトンの状態の積によって決定されます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図。</font><font style="vertical-align: inherit;">3.結果のネットワークオートマトン</font></font></b><div class="spoiler_text"><img src="https://habrastorage.org/webt/a8/oc/9k/a8oc9kfwbbm3apemxhjzpbz5mxw.jpeg" alt="image"><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 もちろん、結果として得られるオートマトンは純粋に形式的な方法で計算できますが、そのためには適切な「計算機」が必要です。しかし、そうでない場合は、かなり単純で直感的なアルゴリズムを使用できます。そのフレームワーク内で、ネットワークの1つまたは別のコンポーネントの状態が記録され、考えられるすべての入力状況をソートして、ターゲットコンポーネントの状態が「ハンドル」によって決定されます。したがって、コンポーネントオートマトンの現在の状態に対応する状態「000」を固定すると、「a0」、「b0」、「c0」、入力変数の結合の遷移^ x1 ^ x2、^ x1x2、x1 ^ x2、x1x2が決定されます。遷移はそれぞれ結果のマシンで「000」、「010」、「100」、「110」とマークされた「a0b0c0」、「a0b1c0」、「a1b0c0」、「a1b1c0」の状態。到達可能なすべての状態に対してこの操作を順番に繰り返す必要があります。ループアクションがロードされていないものは、グラフから除外できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「乾燥残留物」にあるもの。私たちは主要なことを達成しました-ネットワークの操作を正確に説明する結果のオートマトンを受け取りました。 8つのネットワーク状態のうち、1つはアクセス不能（分離）であることがわかりました-状態「001」。つまり、現在の値を変更していない入力変数に対しては、合計操作がトリガーされることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストはエラーを明らかにしませんでしたが、これは厄介です。結果のオートマトンのグラフで、出力アクションで競合する遷移が見つかりました。それらはアクションy1y3とy2y3の組み合わせでマークされています。アクションy1とy2は入力データが変更されたときにトリガーされ、次に別のアクションy3がそれらと並行して変数の合計を計算します。それはどの値に作用しますか-古い値または新しい値によって変更されただけですか？あいまいさをなくすには、単にy3とy4のアクションを変更します。この場合、コードは次のようになります：X3 = X1Sav + X2Savと印刷（X1Sav、X2Sav、X3）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そう。</font><font style="vertical-align: inherit;">結果のオートマトンの構築により、作成された並列モデルに明らかな問題が明らかになりました。</font><font style="vertical-align: inherit;">それらが事後対応プログラムに現れるかどうかは問題です。</font><font style="vertical-align: inherit;">すべては明らかに、反応型パラダイムでの並列処理の実装へのアプローチに依存します。</font><font style="vertical-align: inherit;">いずれの場合でも、このような依存関係を考慮に入れて、何らかの形で排除する必要があります。</font><font style="vertical-align: inherit;">自動化されたネットワークの場合、ネットワークを変更するよりも、変更されたバージョンをそのままにしておく方が簡単です。</font><font style="vertical-align: inherit;">ネットワークの操作を開始した「古い」データが最初に印刷され、次に現在のデータが次に印刷されても問題ありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.結論 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検討されているソリューションにはそれぞれ長所と短所があります。最初のものは非常に単純で、ネットワークはより複雑で、単一のマシンに基づいて作成され、視覚化の後でのみ入力データの分析を開始します。並列処理のため、同じ自動ネットワークが印刷手順の終了前に入力データの分析を開始します。また、可視化時間が長い場合でも、これは総和演算に当てはまる場合、ネットワークは入力制御の観点からはより高速になります。それら。並列プログラムの場合のコード量の見積もりに基づく評価は、常に客観的であるとは限りません。簡単に言うと、ネットワークは並列であり、1つのコンポーネントによるソリューションは、ほとんどが順次的です（述語とアクションは並列です）。そして、まず第一に、並列プログラムについて話します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークモデルも柔軟なソリューションの例です。まず、コンポーネントを互いに独立して設計できます。次に、任意のコンポーネントを別のコンポーネントと交換できます。そして3番目に、どのネットワークコンポーネントも自動プロセスのライブラリの要素になり、別のネットワークソリューションで使用されます。そして、これらは並列ソリューションの最も明白な利点にすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、リアクティブプログラミングに戻ります。 RPはすべてのプログラムステートメントを最初は並列であると見なしますか？これがないと、「データフローと変更の伝播に向けられた」プログラミングパラダイムについて話すのは難しいとしか想定できません（[3]のリアクティブプログラミングの定義を参照）。しかし、ストリーミングコントロールを使用したプログラミングとの違いは何ですか（詳細については、[1]を参照してください）？それでは、元の場所に戻ります。よく知られている分類のフレームワークで反応型プログラミングを分類するにはどうすればよいでしょうか。また、RPが特別なプログラミングである場合、既知のプログラミングパラダイムと何が違うのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、理論について。それがなければ、並列アルゴリズムの分析は難しいだけではなく、不可能です。分析プロセスでは、偶然にも「設計ドキュメント」でプログラムを注意深く検討しても、推測が不可能であるという問題が明らかになる場合があります。いずれにせよ、私は飛行機が、比喩的でもその他の意味でも、墜落しないという事実に賛成です。これはもちろん、シンプルで優美なフォルムを追求する必要があるが、品質を損なうことはないという事実です。私たちプログラマーは、単にプログラムを「描く」だけでなく、飛行機など、そこに隠されているものを制御することがよくあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、ほとんど忘れました。私は自動プログラミング（AP）を動的制御のプログラミングとして分類します。非同期に関して-私は賭けます。 AP制御モデルの基礎が1回のネットワーク、つまりオートマトンの同期ネットワーク、それは同期です。しかし、VKPa環境は「オートマトンの世界」の概念を通じて多くのネットワークを実装しているため、完全に非同期です。一般的に、私は非常に厳格な分類フレームワークに反対していますが、無政府状態には反対です。この意味で、VKPaでは、シリアル-パラレルプログラミングの厳密さと特定の非同期アナキズムの間で、ある程度の妥協点に到達したことを願っています。自動プログラミングもイベントプログラムのクラスをカバーし（[4]を参照）、ストリームプログラムはその中で簡単にモデル化できるという事実を考えると、あなたはまだどんなプログラミングを夢見ることができますか？確かに-私には。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b><div class="spoiler_text">1.   /.. , .. , .. , .. ;  . .. . – .:   , 1983. – 240.<br>
2.      . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">habr.com/ru/post/486632</a> . . . (  07.02.2020).<br>
3.  . . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">ru.wikipedia.org/wiki/_</a> . . . (  07.02.2020).<br>
4.  —  ? [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">habr.com/ru/post/483610</a> . . . (  07.02.2020).<br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487698/index.html">2月10〜16日のサンクトペテルブルクでのデジタルイベント</a></li>
<li><a href="../ja487702/index.html">機械学習に関する記事の選択：2020年1月のケーススタディ、ガイド、および研究</a></li>
<li><a href="../ja487704/index.html">SSRS 2014で動的レポートを作成する方法</a></li>
<li><a href="../ja487706/index.html">Consulの例を使用した分散システムでのサービス検出。アレクサンドル・シガチェフ</a></li>
<li><a href="../ja487716/index.html">完璧なSAST。パーサー</a></li>
<li><a href="../ja487724/index.html">BlazingPizza：最初から最後までBlazorアプリ。パート2.コンポーネントを追加する</a></li>
<li><a href="../ja487728/index.html">@Pythonetcコンパイル、2020年1月</a></li>
<li><a href="../ja487730/index.html">自然言語処理。2019年の結果と2020年の傾向</a></li>
<li><a href="../ja487734/index.html">Entity Framework Coreの高速化</a></li>
<li><a href="../ja487738/index.html">SCADAのスキーマアニメーション</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>