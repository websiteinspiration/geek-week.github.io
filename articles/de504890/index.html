<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè® üë©üèΩ‚Äçüöí üëª R√ºckgabewert vom Powershell-Aufrufbefehl an den SQL Server-Agenten ü§ûüèª üëç üç∂</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bei der Erstellung meiner eigenen Backup-Verwaltungsmethode auf vielen MS-SQL-Servern habe ich viel Zeit damit verbracht, den Mechanismus der √úbertrag...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>R√ºckgabewert vom Powershell-Aufrufbefehl an den SQL Server-Agenten</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504890/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bei der Erstellung meiner eigenen Backup-Verwaltungsmethode auf vielen MS-SQL-Servern habe ich viel Zeit damit verbracht, den Mechanismus der √úbertragung von Werten an Powershell f√ºr Remoteaufrufe zu untersuchen. Daher schreibe ich mir selbst ein Memo, das pl√∂tzlich f√ºr andere n√ºtzlich sein wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir also zun√§chst ein einfaches Skript und f√ºhren es lokal aus:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$exitcode</span> = <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]
<span class="hljs-built_in">Write-Host</span> <span class="hljs-string">'Out to host.'</span>
<span class="hljs-built_in">Write-Output</span> <span class="hljs-string">'Out to output.'</span>
<span class="hljs-built_in">Write-Host</span> (<span class="hljs-string">'ExitCode: '</span> + <span class="hljs-variable">$exitcode</span>)
<span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$exitcode</span>
<span class="hljs-variable">$host</span>.SetShouldExit(<span class="hljs-variable">$exitcode</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum Ausf√ºhren der Skripte verwende ich die folgende CMD-Datei, die ich nicht jedes Mal gebe:</font></font><br>
<br>
<pre><code class="dos hljs">@<span class="hljs-built_in">Echo</span> OFF<font></font>
PowerShell .\TestOutput1.ps1 <span class="hljs-number">1</span>
<span class="hljs-built_in">ECHO</span> <span class="hljs-keyword">ERRORLEVEL</span>=<span class="hljs-variable">%ERRORLEVEL%</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf dem Bildschirm sehen wir Folgendes:</font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
Out to output.<font></font>
ExitCode: 1<font></font>
1<font></font>
ERRORLEVEL=1</code></pre><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie nun dasselbe Skript √ºber WSMAN (remote) aus:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-ComputerName</span> . <span class="hljs-literal">-ScriptBlock</span> { &amp;<span class="hljs-string">'D:\sqlagent\TestOutput1.ps1'</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>] } <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist das Ergebnis:</font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
Out to output.<font></font>
ExitCode: 2<font></font>
2<font></font>
ERRORLEVEL=0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie durch ein Wunder ist Errorlevel irgendwo verschwunden, aber wir m√ºssen den Wert aus dem Skript holen! </font><font style="vertical-align: inherit;">Wir versuchen folgende Konstruktion:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$res</span>=<span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-ComputerName</span> . <span class="hljs-literal">-ScriptBlock</span> { &amp;<span class="hljs-string">'D:\sqlagent\TestOutput1.ps1'</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>] } <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist noch interessanter. </font><font style="vertical-align: inherit;">Die Nachrichtenausgabe in Ausgabe ist irgendwo verschwunden:</font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
ExitCode: 2<font></font>
ERRORLEVEL=0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als lyrischen Exkurs stelle ich fest, dass, wenn Sie Write-Output oder nur einen Ausdruck schreiben, ohne ihn einer Variablen innerhalb der Powershell-Funktion zuzuweisen (und dies impliziert implizit eine Ausgabe an den Ausgabekanal), selbst wenn Sie ihn lokal ausf√ºhren, nichts angezeigt wird! </font><font style="vertical-align: inherit;">Dies ist eine Folge der Powershell-Pipeline-Architektur: Jede Funktion verf√ºgt √ºber eine eigene Output-Pipeline, ein Array wird f√ºr sie erstellt und alles, was in sie gelangt, wird als Ergebnis der Funktion betrachtet. Die Return-Anweisung f√ºgt den R√ºckgabewert derselben Pipeline wie das letzte Element hinzu und √ºbertr√§gt die Steuerung an die aufrufende Funktion. </font><font style="vertical-align: inherit;">F√ºhren Sie zur Veranschaulichung das folgende Skript lokal aus:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-function"><span class="hljs-keyword">Function</span> <span class="hljs-title">Write-Log</span></span> {
  <span class="hljs-keyword">Param</span>( [<span class="hljs-type">Parameter</span>(<span class="hljs-type">Mandatory</span>=<span class="hljs-variable">$false</span>, <span class="hljs-type">ValueFromPipeline</span>=<span class="hljs-variable">$true</span>)] [<span class="hljs-built_in">String</span>[]] <span class="hljs-variable">$OutString</span> = <span class="hljs-string">"`r`n"</span> )
  <span class="hljs-built_in">Write-Output</span> (<span class="hljs-string">"Function: "</span>+<span class="hljs-variable">$OutString</span>)
  <span class="hljs-keyword">Return</span> <span class="hljs-string">"ReturnValue"</span><font></font>
}<font></font>
<span class="hljs-built_in">Write-Output</span> (<span class="hljs-string">"Main: "</span>+<span class="hljs-string">"ParameterValue"</span>)
<span class="hljs-variable">$res</span> = <span class="hljs-built_in">Write-Log</span> <span class="hljs-string">"ParameterValue"</span>
<span class="hljs-variable">$res</span>.GetType()
<span class="hljs-variable">$res</span>.Length
<span class="hljs-variable">$res</span> | <span class="hljs-built_in">Foreach-Object</span> { <span class="hljs-built_in">Write-Host</span> (<span class="hljs-string">"Main: "</span>+<span class="hljs-variable">$_</span>) }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist sein Ergebnis:</font></font><br>
<br>
<pre><code class="plaintext hljs">Main: ParameterValue<font></font>
<font></font>
IsPublic IsSerial Name                                     BaseType<font></font>
-------- -------- ----                                     --------<font></font>
True     True     Object[]                                 System.Array<font></font>
2<font></font>
Main: Function: ParameterValue<font></font>
Main: ReturnValue</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hauptfunktion (der Skriptk√∂rper) hat auch eine eigene Ausgabepipeline. Wenn wir das erste Skript von CMD ausf√ºhren und die Ausgabe in eine Datei umleiten, </font></font><br>
<br>
<pre><code class="dos hljs">PowerShell .\TestOutput1.ps1 <span class="hljs-number">1</span> &gt; TestOutput1.txt
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dann werden wir auf dem Bildschirm sehen </font></font><br>
<br>
<pre><code class="plaintext hljs">ERRORLEVEL=1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und in der Datei </font></font><br>
<pre><code class="plaintext hljs">Out to host.<font></font>
Out to output.<font></font>
ExitCode: 1<font></font>
1<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wenn wir einen √§hnlichen Anruf von Powershell machen </font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-built_in">PS</span> D:\sqlagent&gt; .\TestOutput1.ps1 <span class="hljs-number">1</span> &gt; TestOutput1.txt</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dann wird der Bildschirm sein </font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
ExitCode: 1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und in der Datei </font></font><br>
<br>
<pre><code class="plaintext hljs">Out to output.<font></font>
1</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies liegt daran, dass CMD Powershell startet, das in Abwesenheit anderer Anweisungen die beiden Streams (Host und Output) mischt und an CMD weiterleitet, das alles, was es empfangen hat, an die Datei sendet. Wenn es von Powershell gestartet wird, existieren diese beiden Streams separat und das Symbol Weiterleitungen wirken sich nur auf die Ausgabe aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zur√ºck zum Hauptthema, wir erinnern uns, dass das .NET-Objektmodell in Powershell vollst√§ndig im Rahmen eines Computers (eines Betriebssystems) existiert. Wenn Remotecode √ºber WSMAN ausgef√ºhrt wird, werden Objekte durch XML-Serialisierung √ºbertragen, was ein gro√ües zus√§tzliches Interesse f√ºr unsere Forschung mit sich bringt. </font><font style="vertical-align: inherit;">Lassen Sie uns die Experimente fortsetzen, indem Sie den folgenden Code ausf√ºhren:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$res</span>=<span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-ComputerName</span> . <span class="hljs-literal">-ScriptBlock</span> { &amp;<span class="hljs-string">'D:\sqlagent\TestOutput1.ps1'</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>] } <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]
<span class="hljs-variable">$res</span>.GetType()
<span class="hljs-variable">$host</span>.SetShouldExit(<span class="hljs-variable">$res</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist, was wir auf dem Bildschirm haben:</font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
<font></font>
ExitCode: 3<font></font>
<font></font>
IsPublic IsSerial Name                                     BaseType<font></font>
-------- -------- ----                                     --------<font></font>
True     True     Object[]                                 System.Array<font></font>
    "exitCode",  : "System.Object[]",  "SetShouldExit"   "System.Int32": "    "System.Object[]"  "System.Object[]"   "System<font></font>
.Int32"."<font></font>
D:\sqlagent\TestOutput3.ps1:3 :1<font></font>
+ $host.SetShouldExit($res)<font></font>
+ ~~~~~~~~~~~~~~~~~~~~~~~~~<font></font>
    + CategoryInfo          : NotSpecified: (:) [], MethodException<font></font>
    + FullyQualifiedErrorId : MethodArgumentConversionInvalidCastArgument<font></font>
<font></font>
ERRORLEVEL=0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tolles Ergebnis! </font><font style="vertical-align: inherit;">Dies bedeutet, dass beim Aufruf von Invoke-Command die Pipeline in zwei Streams (Host und Output) unterteilt wird, was uns Hoffnung auf Erfolg gibt. </font><font style="vertical-align: inherit;">Versuchen wir, nur einen Wert im Ausgabestream zu belassen, f√ºr den wir das allererste Skript √§ndern, das wir remote ausf√ºhren:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$exitcode</span> = <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]
<span class="hljs-built_in">Write-Host</span> <span class="hljs-string">'Out to host.'</span>
<span class="hljs-comment">#Write-Output 'Out to output.'</span>
<span class="hljs-built_in">Write-Host</span> (<span class="hljs-string">'ExitCode: '</span> + <span class="hljs-variable">$exitcode</span>)
<span class="hljs-built_in">Write-Output</span> <span class="hljs-variable">$exitcode</span>
<span class="hljs-variable">$host</span>.SetShouldExit(<span class="hljs-variable">$exitcode</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºhren Sie es so aus:</font></font><br>
<br>
<pre><code class="powershell hljs"><span class="hljs-variable">$res</span>=<span class="hljs-built_in">Invoke-Command</span> <span class="hljs-literal">-ComputerName</span> . <span class="hljs-literal">-ScriptBlock</span> { &amp;<span class="hljs-string">'D:\sqlagent\TestOutput1.ps1'</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>] } <span class="hljs-literal">-ArgumentList</span> <span class="hljs-variable">$args</span>[<span class="hljs-number">0</span>]
<span class="hljs-variable">$host</span>.SetShouldExit(<span class="hljs-variable">$res</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
und ... JA, es scheint ein Sieg zu sein!</font></font><br>
<br>
<pre><code class="plaintext hljs">Out to host.<font></font>
ExitCode: 4<font></font>
<font></font>
IsPublic IsSerial Name                                     BaseType<font></font>
-------- -------- ----                                     --------<font></font>
True     True     Int32                                    System.ValueType<font></font>
<font></font>
<font></font>
ERRORLEVEL=4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir herauszufinden, was mit uns passiert ist. </font><font style="vertical-align: inherit;">Wir haben lokal Powershell aufgerufen, das wiederum Powershell auf dem Remotecomputer aufgerufen und dort unser Skript ausgef√ºhrt hat. </font><font style="vertical-align: inherit;">Zwei Streams (Host und Output) vom Remote-Computer wurden serialisiert und zur√ºckgesendet, w√§hrend der Output-Stream, wenn er einen digitalen Wert hatte, in den Int32-Typ konvertiert und in dieser Form an die Empfangsseite gesendet wurde, und die Empfangsseite ihn als anrufenden Exit-Code verwendete Power Shell. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und als letzte Pr√ºfung erstellen wir auf dem SQL Server eine einstufige Aufgabe vom Typ "Betriebssystem (cmdexec)" mit folgendem Text:</font></font><br>
<br>
<pre><code class="dos hljs">PowerShell -NonInteractive -NoProfile "$res=Invoke-Command -ComputerName BACKUPSERVER -ConfigurationName SQLAgent -ScriptBlock {&amp;'D:\sqlagent\TestOutput1.ps1' <span class="hljs-number">6</span>}; $host.SetShouldExit($res)"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HURRA! </font><font style="vertical-align: inherit;">Die Aufgabe ist fehlgeschlagen, der Text im Protokoll:</font></font><br>
<br>
<pre><code class="plaintext hljs">   : DOMAIN\agentuser. Out to host. ExitCode: 6.     6.     .
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse:</font></font></b><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vermeiden Sie die Verwendung von Write-Output und die Angabe von Ausdr√ºcken ohne Zuweisung. </font><font style="vertical-align: inherit;">Denken Sie daran, dass das Verschieben dieses Codes an eine andere Stelle im Skript zu unerwarteten Ergebnissen f√ºhren kann.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºhren Sie in Skripten, die nicht f√ºr den manuellen Start vorgesehen sind, sondern f√ºr die Verwendung in Ihren Automatisierungsmechanismen, insbesondere f√ºr Fernaufrufe √ºber WINRM, eine manuelle Fehlerbehandlung √ºber Try / Catch durch und stellen Sie sicher, dass dieses Skript f√ºr die Entwicklung von Ereignissen genau eine Sendung an den Ausgabestream sendet primitiver Typwert. </font><font style="vertical-align: inherit;">Wenn Sie die klassische Fehlerstufe erhalten m√∂chten, muss dieser Wert numerisch sein.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504878/index.html">109 kostenlose Kurse in Data Science</a></li>
<li><a href="../de504880/index.html">Entwicklung, Optimierung und Ver√∂ffentlichung von Synthety-Spielen auf Unity</a></li>
<li><a href="../de504884/index.html">Gef√§hrliche Peripherieger√§te: Thunderspy verstehen</a></li>
<li><a href="../de504886/index.html">Selenium WebDriver im Dienste des Entwicklers</a></li>
<li><a href="../de504888/index.html">"Ruhig, nur ruhig!" oder weniger Sorgen</a></li>
<li><a href="../de504894/index.html">GUI in Russisch oder VKS-Terminal selbst machen</a></li>
<li><a href="../de504902/index.html">Top 9 Trends im automatisierten Testen im Jahr 2020</a></li>
<li><a href="../de504906/index.html">PHP - Was ist die Nische der Sprache und wird PHP8 helfen, dr√§ngende Probleme zu l√∂sen (Spoiler: IMHO nicht)</a></li>
<li><a href="../de504908/index.html">PyTrace - Zeitreise-Debugger f√ºr Python</a></li>
<li><a href="../de504912/index.html">HackTheBox-Endspiel. Passage des Labors Professionelle Offensivoperationen. Pentest Active Directory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>