<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😑 ⛺️ ⚗️ JetBrainsでのインターンシップと、なんとかそれを乗り越える方法 😞 🍝 🕸️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="多くの若い開発者のように、仕事やインターンシップを見つけたいという欲求があるとき、私はクールなIT企業の方向を見ています。
 
 最近、私はJetBrainsの仲間入りを試み、カットの下で自分の経験を共有する準備ができています。
 
 なぜ「ほとんど」成功したのですか？
 きっとあなたはすぐにそのよ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>JetBrainsでのインターンシップと、なんとかそれを乗り越える方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/454354/"><img src="https://habrastorage.org/getpro/habr/post_images/d42/5b8/da4/d425b8da4aec5f7359e39503e9f1d700.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの若い開発者のように、仕事やインターンシップを見つけたいという欲求があるとき、私はクールなIT企業の方向を見ています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、私はJetBrainsの仲間入りを試み、カットの下で自分の経験を共有する準備ができています。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ「ほとんど」成功したのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
きっとあなたはすぐにそのような質問をするでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、私は過去8〜9年にわたって日々改善してきた、一連の成果と優れたスキルを備えた優れた履歴書を持っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はテストタスクを完了しました（そして私には良さそうです）、以前私の街にあるJBのオフィスを訪問し、HHと会社の開発者に話しかけた結果、コメントなしでインターンシップを拒否されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、その理由は、JetBrainsがインターンシップのためだけに学生を選択しているという事実にあります。現在、私は11日を卒業し、次々と試験に合格しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、これはもう1年間、自分を引き上げて翌年に応募する機会です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストタスクの分析</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インターンシップの申し込みの提出とテスト課題のテストの締め切りが終了しました。つまり、私を含め、それらを解決したすべての人がこれらの課題の分析を投稿できるため、来年はJBインターンシップを開始する前に、おおよその課題のレベルに慣れることができます。それは彼が直面しなければならないことであり、その場合彼の知識を引き出すためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KotlinのCorotinデバッガ開発チームにインターンシップを申請しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今年のインターンシップ中のこのチームのタスクは、デバッガのこの部分とIDEとの統合を完成させることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクは少し期待されていました-小さなPL用のデバッガーを作成することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それが複雑であるとは言わず、むしろ逆です。</font><font style="vertical-align: inherit;">翻訳者の構築理論に関する深い知識とクールなスキルは必要ありません。</font><font style="vertical-align: inherit;">しかし、それでも、この分野でインターンシップを申請する人は、少なくともこれらの基本を持ち、問題なくこのタスクに対処する必要があります。</font><font style="vertical-align: inherit;">私のgithubで「競合他社」のソリューションのキーワードを検索することに決めたとき、私は驚いた。約6〜7個の空のリポジトリに対して2〜3個の実用的なソリューションが見つかるか、いくつかのコードでそれを断念した。</font><font style="vertical-align: inherit;">多分私はひどく見ていました、それにもかかわらず、結果は私を満足させませんでした。</font><font style="vertical-align: inherit;">この投稿をこのタスクを放棄した人が読む場合-将来これを行う必要はありません。</font><font style="vertical-align: inherit;">極端なケースでは、数日間タスクに座るだけで十分で、きっとあなたはそれに対処するでしょう。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クエスト自体のテキスト</font></font></b><div class="spoiler_text">:         Guu. <br>
<br>
:        .  ,     .    ,   ( ,    ). <br>
<br>
  Guu    .      sub (subname)      (  ,     ).    sub main. <br>
<br>
  –  ,       .          .   .   Guu . <br>
<br>
 Guu    : — set (varname) (new value) –     . — call (subname) –  .    . — print (varname) –     . <br>
<br>
  Guu    .       a = 2. <br>
<br>
sub main <br>
set a 1 <br>
call foo <br>
print a <br>
<br>
sub foo <br>
set a 2 <br>
<br>
      : <br>
<br>
sub main <br>
call main <br>
<br>
     Guu.             sub main     .     : <br>
<br>
i – step into,    call (subname). <br>
o – step over,     call. <br>
trace –  stack trace    ,   main… <br>
var –     . <br>
<br>
        .      GDB-like ,      UI.       . <br>
<br>
           TIOBE TOP 50  open-source /. <br>
<br>
    : <br>
<br>
  ; <br>
     ; <br>
   (,       ). <br>
         Git- (,  GitHub  BitBucket).       .      GitHub-,      .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++、Java、Object Pascalで記述しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初はすべてを同じMPSに書き込むつもりでしたが、JBの従業員を確認するのはあまり便利ではないと思い、提出の締め切りの2日前に申請書を提出しました（すべて同じ...）。それはすでに窓の外で夕方になりました-私はより有名な言語ですべてをすぐに書くことにしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の意見では、Pascalは、少なくとも文字列の最も便利な実装のために、問題の解決に最も適しています... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
少なくとも私にとって。</font><font style="vertical-align: inherit;">さらに、TIOBE TOP 50に含まれているので、IDE、つまりLazarusを大胆に立ち上げました。</font><font style="vertical-align: inherit;">彼は商業的ではありません:)そして問題の解決に取り掛かります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らがJBに7日も与えるという事実にもかかわらず、プロジェクトを完了するのに約1時間かかり、プロジェクトは約500行のコードであることが判明しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どこから始めますか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず最初に、コードデバッグが最終的にどのように機能するかを想像する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステップバイステップのコード実行を実装する必要があります。つまり、各命令は構造/クラスの形式で提示する必要があり、一般に、命令はこれらのクラスのリストのように見えるか、または私の実装のように、シーケンスを形成する互いを参照する必要があります（後で行った理由を書き留めます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシーケンスを取得するには、デバッガーが提案された言語でコードを処理する必要があるため、コードの構文解析と意味解析だけでなく、小さなパーサーも実装する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パーサーの実装から始めましょう。</font><font style="vertical-align: inherit;">なぜなら </font><font style="vertical-align: inherit;">Guu言語は、スペースで区切られた一連のトークンで構成されているため、最初に小さくシンプルなトークナイザーを記述するのが論理的です。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetToken</span><span class="hljs-params">(s: <span class="hljs-keyword">string</span>; tokenNum: word)</span>:</span> <span class="hljs-keyword">string</span>;
<span class="hljs-keyword">var</span><font></font>
  p: word;<font></font>
<span class="hljs-keyword">begin</span><font></font>
  s := Trim(s);<font></font>
  s := StringReplace(s, <span class="hljs-string">'  '</span>, <span class="hljs-string">' '</span>, [rfReplaceAll]);<font></font>
<font></font>
  <span class="hljs-keyword">while</span> tokenNum &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
   <span class="hljs-keyword">begin</span>
     p := Pos(<span class="hljs-string">' '</span>, s);
     <span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
       Delete(s, <span class="hljs-number">1</span>, p)
     <span class="hljs-keyword">else</span>
       <span class="hljs-keyword">begin</span>
         s := <span class="hljs-string">''</span>;
         <span class="hljs-keyword">break</span>;
       <span class="hljs-keyword">end</span>;<font></font>
     dec(tokenNum);<font></font>
   <span class="hljs-keyword">end</span>;<font></font>
<font></font>
  p := Pos(<span class="hljs-string">' '</span>, s);
  <span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><font></font>
    Delete(s, p, Length(s));<font></font>
<font></font>
  Result := s;<font></font>
<span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、トークンから列挙型を宣言します。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">type</span><font></font>
  TGuuToken = (opSub, opSet, opCall, opPrint, opUnknown);<font></font>
<font></font>
<span class="hljs-keyword">const</span>
  GuuToken: <span class="hljs-keyword">array</span>[opSub..opPrint] <span class="hljs-keyword">of</span> <span class="hljs-keyword">string</span> = (
    <span class="hljs-string">'sub'</span>, <span class="hljs-string">'set'</span>, <span class="hljs-string">'call'</span>, <span class="hljs-string">'print'</span><font></font>
  );<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、コード行を解析する命令クラス自体：</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">type</span>
  TGuuOp = <span class="hljs-keyword">class</span>
    <span class="hljs-keyword">public</span><font></font>
      OpType         : TGuuToken;<font></font>
      OpArgs         : TStringList;<font></font>
      OpLine         : Cardinal;<font></font>
      OpUnChangedLine: <span class="hljs-keyword">string</span>;<font></font>
      NextOp         : TGuuOp;<font></font>
      OpReg          : Pointer;<font></font>
      <span class="hljs-function"><span class="hljs-keyword">function</span>    <span class="hljs-title">Step</span><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span>:</span> TGuuOp;
      <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Create</span><span class="hljs-params">(LineNum: Cardinal; Line:<span class="hljs-keyword">string</span>)</span>;</span>
      <span class="hljs-function"><span class="hljs-keyword">destructor</span>  <span class="hljs-title">Destroy</span>;</span> <span class="hljs-keyword">override</span>;
  <span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpTypeでは、命令はOpArgs（残りの構成）に格納されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpLine、OpUnChangedLine-デバッガーの情報。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NextOpは、次のステートメントへのポインターです。</font><font style="vertical-align: inherit;">nil（Pascalではnull）と等しい場合、それ以上の指示はなく、コードを完了するか、コールバックスタック経由で戻る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpRegは小さなポインターレジスターで、後でコード実行の小さな最適化に使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス宣言が書かれた後、私は最もコンパクトで美しい解決策はパーサーと少しの構文解析をコンストラクターに追加することだと判断しました。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">TGuuOp</span>.<span class="hljs-title">Create</span><span class="hljs-params">(LineNum: Cardinal; Line:<span class="hljs-keyword">string</span>)</span>;</span>
<span class="hljs-comment">(*
 * That method parse code line.
 *)</span>
<span class="hljs-keyword">var</span>
  s: <span class="hljs-keyword">string</span>;<font></font>
  w: word;<font></font>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">inherited</span> Create;<font></font>
  OpArgs := TStringList.Create;<font></font>
  OpLine := LineNum;<font></font>
  OpUnChangedLine := Line;<font></font>
<font></font>
  NextOp    := <span class="hljs-keyword">nil</span>;<font></font>
  OpReg     := <span class="hljs-keyword">nil</span>;<font></font>
<font></font>
  s := GetToken(Line, <span class="hljs-number">1</span>);<font></font>
  OpType := TGuuToken(AnsiIndexStr(s, GuuToken));<font></font>
  <span class="hljs-keyword">case</span> OpType <span class="hljs-keyword">of</span>
    opSub  : <span class="hljs-keyword">begin</span> <span class="hljs-comment">// sub &lt;name&gt;</span>
               s := GetToken(Line, <span class="hljs-number">2</span>);
               <span class="hljs-keyword">if</span> Length(s) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><font></font>
                OpArgs.Add(s)<font></font>
               <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "sub" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> Length(GetToken(Line, <span class="hljs-number">3</span>)) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "'</span>, Line, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;
             <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opSet  : <span class="hljs-keyword">begin</span> <span class="hljs-comment">// set &lt;var&gt; &lt;value&gt;</span>
               OpArgs.Add(GetToken(Line, <span class="hljs-number">2</span>));<font></font>
               OpArgs.Add(GetToken(Line, <span class="hljs-number">3</span>));<font></font>
               w := <span class="hljs-number">1</span>;
               <span class="hljs-keyword">while</span> w &lt; Length(OpArgs[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span> <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">begin</span>
                  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> (OpArgs[<span class="hljs-number">1</span>][w] <span class="hljs-keyword">in</span> [<span class="hljs-string">'0'</span>..<span class="hljs-string">'9'</span>]) <span class="hljs-keyword">then</span>
                   <span class="hljs-keyword">begin</span>
                     writeln(<span class="hljs-string">'[Syntax error]: Invalid variable assigment "'</span>, Line, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                     halt;<font></font>
                   <span class="hljs-keyword">end</span>;<font></font>
                  inc(w);<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> (Length(OpArgs[<span class="hljs-number">0</span>]) = <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span> (Length(OpArgs[<span class="hljs-number">1</span>]) = <span class="hljs-number">0</span>) <span class="hljs-keyword">or</span>
                  (Length(GetToken(Line, <span class="hljs-number">4</span>)) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "'</span>, Line, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>
             <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opCall : <span class="hljs-keyword">begin</span> <span class="hljs-comment">// call &lt;name&gt;</span>
               s := GetToken(Line, <span class="hljs-number">2</span>);
               <span class="hljs-keyword">if</span> Length(s) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><font></font>
                OpArgs.Add(s)<font></font>
               <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "call" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> Length(GetToken(Line, <span class="hljs-number">3</span>)) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "'</span>, Line, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;
             <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opPrint: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// print &lt;var&gt;</span>
               s := GetToken(Line, <span class="hljs-number">2</span>);
               <span class="hljs-keyword">if</span> Length(s) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><font></font>
                OpArgs.Add(s)<font></font>
               <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "print" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> Length(GetToken(Line, <span class="hljs-number">3</span>)) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Syntax error]: Invalid construction "'</span>, Line, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>;
             <span class="hljs-keyword">end</span>;
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">begin</span>
        writeln(<span class="hljs-string">'[Syntax error]: Invalid token "'</span>, s, <span class="hljs-string">'" at line '</span>, OpLine, <span class="hljs-string">'.'</span>);<font></font>
        halt;<font></font>
      <span class="hljs-keyword">end</span>;
  <span class="hljs-keyword">end</span>;
<span class="hljs-keyword">end</span>;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">destructor</span>  <span class="hljs-title">TGuuOp</span>.<span class="hljs-title">Destroy</span>;</span>
<span class="hljs-keyword">begin</span><font></font>
  FreeAndNil(OpArgs);<font></font>
  <span class="hljs-keyword">inherited</span>;
<span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、基本的に構築の始まり（つまり、最初の単語）をチェックしてから、残りのトークンとその数を調べます。</font><font style="vertical-align: inherit;">コードに明らかに問題がある場合は、エラーが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードの主要部分では、ファイルからTStringListのコードを読み取り、TGuuOpコンストラクターを1行ずつ呼び出し、クラスインスタンスへのポインターをGuuOps：TListに格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
広告：</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">var</span><font></font>
  LabelNames: TStringList;<font></font>
  GuuOps, GuuVars: TList;<font></font>
<font></font>
  SubMain: TGuuOp = <span class="hljs-keyword">nil</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コード解析と一緒に、さらにいくつかのアクションを実行すると便利です。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">ParseNext</span><span class="hljs-params">(LineNum: Cardinal; Line: <span class="hljs-keyword">string</span>)</span>;</span>
<span class="hljs-comment">(*
 * Parsing code lines and define variables and labels.
 *)</span>
<span class="hljs-keyword">var</span><font></font>
  Op: TGuuOp;<font></font>
  GV: TGuuVar;<font></font>
  c: cardinal;<font></font>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> Trim(Line) &lt;&gt; <span class="hljs-string">''</span> <span class="hljs-keyword">then</span>
   <span class="hljs-keyword">begin</span><font></font>
     Op := TGuuOp.Create(LineNum, Line);<font></font>
     GuuOps.Add(Op);<font></font>
<font></font>
     <span class="hljs-keyword">case</span> Op.OpType <span class="hljs-keyword">of</span>
      opSet: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// define variable and/or optimisation var calling</span>
               GV := <span class="hljs-keyword">nil</span>;<font></font>
               c := <span class="hljs-number">0</span>;
               <span class="hljs-keyword">while</span> c &lt; GuuVars.Count <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">begin</span>
                  <span class="hljs-keyword">if</span> TGuuVar(GuuVars[c]).gvName = Op.OpArgs[<span class="hljs-number">0</span>] <span class="hljs-keyword">then</span>
                   <span class="hljs-keyword">begin</span><font></font>
                     GV := TGuuVar(GuuVars[c]);<font></font>
                     <span class="hljs-keyword">break</span>;
                   <span class="hljs-keyword">end</span>;<font></font>
                  inc(c);<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> GV = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  GV := TGuuVar.Create(Op.OpArgs[<span class="hljs-number">0</span>]);<font></font>
                  GuuVars.Add(GV);<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
<font></font>
               Op.OpReg := GV;<font></font>
             <span class="hljs-keyword">end</span>;<font></font>
<font></font>
      opSub: <span class="hljs-keyword">begin</span> <span class="hljs-comment">// Check for label dublicade declaration</span>
               <span class="hljs-keyword">if</span> Op.OpArgs[<span class="hljs-number">0</span>] = <span class="hljs-string">'main'</span> <span class="hljs-keyword">then</span><font></font>
                SubMain := Op;<font></font>
<font></font>
               <span class="hljs-keyword">if</span> LabelNames.IndexOf(Op.OpArgs[<span class="hljs-number">0</span>]) &lt;&gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'[Error]: Dublicate sub "'</span>, Op.OpArgs[<span class="hljs-number">0</span>], <span class="hljs-string">'" declaration at line '</span>, Op.OpLine, <span class="hljs-string">'.'</span>);<font></font>
                  halt;<font></font>
                <span class="hljs-keyword">end</span>
               <span class="hljs-keyword">else</span>
                LabelNames.Add(Op.OpArgs[<span class="hljs-number">0</span>]);
             <span class="hljs-keyword">end</span>;
     <span class="hljs-keyword">end</span>;
   <span class="hljs-keyword">end</span>;
<span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階で、再定義時にエントリポイントを確認し、OpRegを考えることができます。Guu変数へのポインターを格納するために使用しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数と言えば、この小さなコードを別のユニットに入れました。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">unit</span> uVars;<font></font>
<font></font>
<span class="hljs-meta">{$mode objfpc}</span><span class="hljs-meta">{$H+}</span><font></font>
<font></font>
<span class="hljs-keyword">interface</span><font></font>
<font></font>
<span class="hljs-keyword">uses</span><font></font>
  Classes, SysUtils;<font></font>
<font></font>
<span class="hljs-keyword">type</span>
  TGuuVar = <span class="hljs-keyword">class</span>
    <span class="hljs-keyword">public</span>
      gvName: <span class="hljs-keyword">string</span>;<font></font>
      gvVal: variant;<font></font>
      <span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">Create</span><span class="hljs-params">(VarName: <span class="hljs-keyword">string</span>)</span>;</span>
  <span class="hljs-keyword">end</span>;<font></font>
<font></font>
<span class="hljs-keyword">implementation</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">constructor</span> <span class="hljs-title">TGuuVar</span>.<span class="hljs-title">Create</span><span class="hljs-params">(VarName: <span class="hljs-keyword">string</span>)</span>;</span>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">inherited</span> Create;<font></font>
  gvName := VarName;<font></font>
  gvVal := <span class="hljs-number">0</span>;
<span class="hljs-keyword">end</span>;<font></font>
<font></font>
<span class="hljs-keyword">end</span>.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで構文が正しいように見えるコードを解析しました。</font><font style="vertical-align: inherit;">それはそれを分析するために残り、あなたは最も重要なこと-デバッグを実行し始めることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、少しセマンティック分析を実装し、同時にコードの実行とデバッグのためにすべてを準備する必要があります。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">CheckSemantic</span>;</span>
<span class="hljs-comment">(*
 * Semantic analyse and calls optimisation.
 *)</span>
<span class="hljs-keyword">var</span><font></font>
  c, x: cardinal;<font></font>
  op: TGuuOp;<font></font>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> GuuOps.Count &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
   <span class="hljs-keyword">begin</span>
     <span class="hljs-keyword">if</span> TGuuOp(GuuOps[<span class="hljs-number">0</span>]).OpType &lt;&gt; opSub <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">begin</span>
        writeln(<span class="hljs-string">'[Error]: Operation outside sub at line '</span>, TGuuOp(GuuOps[<span class="hljs-number">0</span>]).OpLine, <span class="hljs-string">'.'</span>);<font></font>
        halt;<font></font>
      <span class="hljs-keyword">end</span>;<font></font>
<font></font>
     c := <span class="hljs-number">0</span>;
     <span class="hljs-keyword">while</span> c &lt; GuuOps.Count <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">begin</span>
        <span class="hljs-keyword">case</span> TGuuOp(GuuOps[c]).OpType <span class="hljs-keyword">of</span><font></font>
          opSub:;<font></font>
<font></font>
          opCall: <span class="hljs-keyword">begin</span>
                    TGuuOp(GuuOps[c - <span class="hljs-number">1</span>]).NextOp := TGuuOp(GuuOps[c]);<font></font>
                    x := <span class="hljs-number">0</span>;<font></font>
                    op := <span class="hljs-keyword">nil</span>;
                    <span class="hljs-keyword">while</span> x &lt; GuuOps.Count <span class="hljs-keyword">do</span>
                     <span class="hljs-keyword">begin</span>
                       <span class="hljs-keyword">if</span> TGuuOp(GuuOps[x]).OpType = opSub <span class="hljs-keyword">then</span>
                       <span class="hljs-keyword">if</span> TGuuOp(GuuOps[x]).OpArgs[<span class="hljs-number">0</span>] = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number">0</span>] <span class="hljs-keyword">then</span>
                        <span class="hljs-keyword">begin</span><font></font>
                          op := TGuuOp(GuuOps[x]);<font></font>
                          <span class="hljs-keyword">break</span>;
                        <span class="hljs-keyword">end</span>;<font></font>
                      inc(x);<font></font>
                    <span class="hljs-keyword">end</span>;<font></font>
<font></font>
                   <span class="hljs-keyword">if</span> op &lt;&gt; <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span><font></font>
                    TGuuOp(GuuOps[c]).OpReg := op<font></font>
                   <span class="hljs-keyword">else</span>
                    <span class="hljs-keyword">begin</span>
                      writeln(<span class="hljs-string">'[Error]: Calling to not exist sub "'</span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number">0</span>],
                              <span class="hljs-string">'" at line '</span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string">'.'</span>);<font></font>
                      halt;<font></font>
                    <span class="hljs-keyword">end</span>;
                 <span class="hljs-keyword">end</span>;<font></font>
<font></font>
          opPrint: <span class="hljs-keyword">begin</span>
                     TGuuOp(GuuOps[c - <span class="hljs-number">1</span>]).NextOp := TGuuOp(GuuOps[c]);<font></font>
                     x := <span class="hljs-number">0</span>;
                     <span class="hljs-keyword">while</span> x &lt; GuuVars.Count <span class="hljs-keyword">do</span>
                      <span class="hljs-keyword">begin</span>
                        <span class="hljs-keyword">if</span> TGuuVar(GuuVars[x]).gvName = TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number">0</span>] <span class="hljs-keyword">then</span>
                         <span class="hljs-keyword">begin</span><font></font>
                           TGuuOp(GuuOps[c]).OpReg := TGuuVar(GuuVars[x]);<font></font>
                           <span class="hljs-keyword">break</span>;
                         <span class="hljs-keyword">end</span>;<font></font>
                        inc(x);<font></font>
                      <span class="hljs-keyword">end</span>;<font></font>
<font></font>
                     <span class="hljs-keyword">if</span> TGuuOp(GuuOps[c]).OpReg = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
                      <span class="hljs-keyword">begin</span>
                        writeln(<span class="hljs-string">'[Error]: Variable "'</span>, TGuuOp(GuuOps[c]).OpArgs[<span class="hljs-number">0</span>],
                                <span class="hljs-string">'" for print doesn''t exist at line '</span>, TGuuOp(GuuOps[c]).OpLine, <span class="hljs-string">'.'</span>);
                      <span class="hljs-keyword">end</span>;
                   <span class="hljs-keyword">end</span>;
          <span class="hljs-keyword">else</span>
            TGuuOp(GuuOps[c - <span class="hljs-number">1</span>]).NextOp := TGuuOp(GuuOps[c]);
        <span class="hljs-keyword">end</span>;<font></font>
        inc(c);<font></font>
      <span class="hljs-keyword">end</span>;
   <span class="hljs-keyword">end</span>;
<span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各トークンのTGuuOp.NextOpに、次のトークンへのポインターを書き込みます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
呼び出しオペコードの場合は、トリッキーでシンプルです。NextOpでは、呼び出されたエントリポイントへのポインターを書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、printステートメントを使用して出力変数をチェックします... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力前に宣言されていない可能性がありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、コード実行を実装する必要があります。</font><font style="vertical-align: inherit;">TGuuOpクラスに戻り、Stepメソッドを実装します。</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TGuuOp</span>.<span class="hljs-title">Step</span><span class="hljs-params">(StepInto: boolean; CallBacks: TList; Trace: TStringList)</span>:</span> TGuuOp;
<span class="hljs-comment">(*
 * That method execute instruction.
 *)</span>
<span class="hljs-keyword">var</span><font></font>
  Op: TGuuOp;<font></font>
  CBSize: Cardinal;<font></font>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">case</span> OpType <span class="hljs-keyword">of</span>
    opSub: <span class="hljs-keyword">begin</span>
             Trace.Add(<span class="hljs-string">'-&gt; Sub "'</span> + OpArgs[<span class="hljs-number">0</span>] + <span class="hljs-string">'"'</span>);<font></font>
             Result := NextOp;<font></font>
           <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opCall: <span class="hljs-keyword">begin</span>
              <span class="hljs-keyword">if</span> StepInto <span class="hljs-keyword">then</span>
               <span class="hljs-keyword">begin</span>
                 <span class="hljs-keyword">if</span> NextOp &lt;&gt; <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span><font></font>
                  CallBacks.Add(NextOp);<font></font>
                 Result := TGuuOp(OpReg);<font></font>
               <span class="hljs-keyword">end</span>
              <span class="hljs-keyword">else</span>
               <span class="hljs-keyword">begin</span><font></font>
                 Op := TGuuOp(OpReg);<font></font>
                 CBSize := CallBacks.Count;<font></font>
<font></font>
                 <span class="hljs-keyword">while</span> ((Op &lt;&gt; <span class="hljs-keyword">nil</span>) <span class="hljs-keyword">or</span> (CallBacks.Count &gt; CBSize)) <span class="hljs-keyword">and</span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword">do</span>
                  <span class="hljs-keyword">begin</span>
                    <span class="hljs-keyword">if</span> Op = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
                     <span class="hljs-keyword">begin</span>
                       Op := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number">1</span>]);<font></font>
                       CallBacks.Delete(CallBacks.Count - <span class="hljs-number">1</span>);<font></font>
                       Trace.Delete(Trace.Count - <span class="hljs-number">1</span>);
                     <span class="hljs-keyword">end</span>;<font></font>
<font></font>
                    Op := Op.Step(StepInto, CallBacks, Trace);<font></font>
                  <span class="hljs-keyword">end</span>;<font></font>
<font></font>
                 Result := NextOp;<font></font>
               <span class="hljs-keyword">end</span>;
            <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opPrint: <span class="hljs-keyword">begin</span>
               writeln(TGuuVar(OpReg).gvName, <span class="hljs-string">' = '</span>, TGuuVar(OpReg).gvVal);<font></font>
               Result := NextOp;<font></font>
             <span class="hljs-keyword">end</span>;<font></font>
<font></font>
    opSet: <span class="hljs-keyword">begin</span>
             TGuuVar(OpReg).gvVal := OpArgs[<span class="hljs-number">1</span>];<font></font>
             Result := NextOp;<font></font>
           <span class="hljs-keyword">end</span>;
  <span class="hljs-keyword">end</span>;
<span class="hljs-keyword">end</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ループが発生した場合のアクセス違反を回避するには、スタックを制限することをお勧めします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記で宣言された定数STACK_SIZE = 2048は、これを担当します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いよいよデバッガのメインコードを書く時です：</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">var</span><font></font>
  code: TStringList;<font></font>
  c: Cardinal;<font></font>
  cmd: <span class="hljs-keyword">string</span>;<font></font>
  CallBacks: TList;<font></font>
  Trace: TStringList;<font></font>
  DebugMode: boolean = true;<font></font>
<span class="hljs-keyword">begin</span>
  <span class="hljs-keyword">if</span> ParamCount &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">begin</span>
      <span class="hljs-comment">// Initialisation</span><font></font>
<font></font>
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> FileExists(ParamStr(<span class="hljs-number">1</span>)) <span class="hljs-keyword">then</span>
       <span class="hljs-keyword">begin</span>
         writeln(<span class="hljs-string">'[Error]: Can''t open file "'</span>, ParamStr(<span class="hljs-number">1</span>), <span class="hljs-string">'".'</span>);<font></font>
         halt;<font></font>
       <span class="hljs-keyword">end</span>;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> ParamCount &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span>
       <span class="hljs-keyword">if</span> LowerCase(ParamStr(<span class="hljs-number">2</span>)) = <span class="hljs-string">'/run'</span> <span class="hljs-keyword">then</span><font></font>
        DebugMode := false;<font></font>
<font></font>
      code := TStringList.Create;<font></font>
      code.LoadFromFile(ParamStr(<span class="hljs-number">1</span>));<font></font>
<font></font>
      GuuOps  := TList.Create;<font></font>
      GuuVars := TList.Create;<font></font>
<font></font>
      <span class="hljs-comment">// Parsing and preparing</span><font></font>
<font></font>
      LabelNames := TStringList.Create;<font></font>
<font></font>
      c := <span class="hljs-number">0</span>;
      <span class="hljs-keyword">while</span> c &lt; code.Count <span class="hljs-keyword">do</span>
       <span class="hljs-keyword">begin</span>
         ParseNext(c + <span class="hljs-number">1</span>, Trim(code[c]));<font></font>
         inc(c);<font></font>
       <span class="hljs-keyword">end</span>;<font></font>
<font></font>
      FreeAndNil(LabelNames);<font></font>
<font></font>
      CheckSemantic;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> SubMain = <span class="hljs-keyword">nil</span> <span class="hljs-keyword">then</span>
       <span class="hljs-keyword">begin</span>
         writeln(<span class="hljs-string">'[Error]: Sub "main" doesn''t exist!'</span>);<font></font>
         halt;<font></font>
       <span class="hljs-keyword">end</span>;<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">// Start code execution</span><font></font>
<font></font>
      CurrentOp := SubMain;<font></font>
<font></font>
      CallBacks := TList.Create;<font></font>
      Trace := TStringList.Create;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> DebugMode <span class="hljs-keyword">then</span>
       <span class="hljs-keyword">begin</span>
         <span class="hljs-comment">//Out code and features</span><font></font>
<font></font>
         ClrScr;<font></font>
         writeln(<span class="hljs-string">'Code for debugging:'</span>);<font></font>
         writeln(<span class="hljs-string">'.....'</span>);<font></font>
         c := <span class="hljs-number">0</span>;
         <span class="hljs-keyword">while</span> c &lt; code.Count <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">begin</span>
            writeln(FillSpaces(IntToStr(c + <span class="hljs-number">1</span>), <span class="hljs-number">4</span>), <span class="hljs-string">'| '</span>, code[c]);<font></font>
            inc(c);<font></font>
          <span class="hljs-keyword">end</span>;<font></font>
         writeln(<span class="hljs-string">'"""""'</span>);<font></font>
<font></font>
         FreeAndNil(code);<font></font>
<font></font>
         writeln(sLineBreak,<font></font>
                 <span class="hljs-string">'Features:'</span>, sLineBreak,
                 <span class="hljs-string">'* i     - step into.'</span>, sLineBreak,
                 <span class="hljs-string">'* o     - step over.'</span>, sLineBreak,
                 <span class="hljs-string">'* trace - print stack trace.'</span>, sLineBreak,
                 <span class="hljs-string">'* var   - print variables list.'</span>, sLineBreak,
                 <span class="hljs-string">'* x     - exit.'</span>, sLineBreak);<font></font>
<font></font>
         <span class="hljs-comment">// Execution loop</span>
         <span class="hljs-keyword">while</span> ((CurrentOp &lt;&gt; <span class="hljs-keyword">nil</span>) <span class="hljs-keyword">or</span> (CallBacks.Count &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">and</span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">begin</span>
            <span class="hljs-keyword">write</span>(<span class="hljs-string">'Line '</span>, CurrentOp.OpLine, <span class="hljs-string">' ~&gt; '</span>);<font></font>
            readln(cmd);<font></font>
<font></font>
            <span class="hljs-comment">// Execute commands</span>
            <span class="hljs-keyword">if</span> cmd = <span class="hljs-string">'i'</span> <span class="hljs-keyword">then</span><font></font>
             CurrentOp := CurrentOp.Step(true, CallBacks, Trace)<font></font>
            <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> cmd = <span class="hljs-string">'o'</span> <span class="hljs-keyword">then</span><font></font>
             CurrentOp := CurrentOp.Step(false, CallBacks, Trace)<font></font>
            <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> cmd = <span class="hljs-string">'trace'</span> <span class="hljs-keyword">then</span>
             <span class="hljs-keyword">begin</span>
               writeln(<span class="hljs-string">'| Trace:'</span>);<font></font>
               c := <span class="hljs-number">0</span>;
               <span class="hljs-keyword">while</span> c &lt; Trace.Count <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'| '</span>, Trace[c]);<font></font>
                  inc(c);<font></font>
                <span class="hljs-keyword">end</span>;<font></font>
               writeln(<span class="hljs-string">'| -&gt; Line '</span>, CurrentOp.OpLine, <span class="hljs-string">': "'</span>, CurrentOp.OpUnChangedLine, <span class="hljs-string">'".'</span>)
             <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> cmd = <span class="hljs-string">'var'</span> <span class="hljs-keyword">then</span>
             <span class="hljs-keyword">begin</span>
               writeln(<span class="hljs-string">'| Variables list:'</span>);<font></font>
               c := <span class="hljs-number">0</span>;
               <span class="hljs-keyword">while</span> c &lt; GuuVars.Count <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">begin</span>
                  writeln(<span class="hljs-string">'| '</span>, TGuuVar(GuuVars[c]).gvName, <span class="hljs-string">' = '</span>, TGuuVar(GuuVars[c]).gvVal);<font></font>
                  inc(c);<font></font>
                <span class="hljs-keyword">end</span>;
             <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">if</span> cmd = <span class="hljs-string">'x'</span> <span class="hljs-keyword">then</span><font></font>
             halt;<font></font>
<font></font>
            <span class="hljs-comment">// Check for method end &amp; make callback</span>
            <span class="hljs-keyword">if</span> (CurrentOp = <span class="hljs-keyword">nil</span>) <span class="hljs-keyword">and</span> (CallBacks.Count &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
             <span class="hljs-keyword">begin</span>
               CurrentOp := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number">1</span>]);<font></font>
               CallBacks.Delete(CallBacks.Count - <span class="hljs-number">1</span>);<font></font>
               Trace.Delete(Trace.Count - <span class="hljs-number">1</span>);
             <span class="hljs-keyword">end</span>;
          <span class="hljs-keyword">end</span>;
       <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">else</span>
       <span class="hljs-keyword">begin</span>
         <span class="hljs-comment">// Only run mode (/run)</span><font></font>
         FreeAndNil(code);<font></font>
<font></font>
         <span class="hljs-keyword">while</span> ((CurrentOp &lt;&gt; <span class="hljs-keyword">nil</span>) <span class="hljs-keyword">or</span> (CallBacks.Count &gt; <span class="hljs-number">0</span>)) <span class="hljs-keyword">and</span> (Trace.Count &lt; STACK_SIZE) <span class="hljs-keyword">do</span>
          <span class="hljs-keyword">begin</span><font></font>
            CurrentOp := CurrentOp.Step(false, CallBacks, Trace);<font></font>
            <span class="hljs-keyword">if</span> (CurrentOp = <span class="hljs-keyword">nil</span>) <span class="hljs-keyword">and</span> (CallBacks.Count &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
             <span class="hljs-keyword">begin</span>
               CurrentOp := TGuuOp(CallBacks[CallBacks.Count - <span class="hljs-number">1</span>]);<font></font>
               CallBacks.Delete(CallBacks.Count - <span class="hljs-number">1</span>);<font></font>
               Trace.Delete(Trace.Count - <span class="hljs-number">1</span>);
             <span class="hljs-keyword">end</span>;
          <span class="hljs-keyword">end</span>;
       <span class="hljs-keyword">end</span>;<font></font>
<font></font>
      <span class="hljs-keyword">if</span> Trace.Count &gt;= STACK_SIZE <span class="hljs-keyword">then</span>
       writeln(<span class="hljs-string">'[Runtime error]: Stack overflow!'</span>);<font></font>
<font></font>
      FreeAndNil(CallBacks);<font></font>
      FreeAndNil(Trace);<font></font>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">else</span><font></font>
    writeln(<font></font>
      <span class="hljs-string">'Guu debugger v1.0.'</span>, sLineBreak,
      <span class="hljs-string">'Author: Pavel Shiryaev (@RoPi0n).'</span>, sLineBreak,
      <span class="hljs-string">'Run: svmc guu_debugger.vmc &lt;guu source file&gt; [arg]'</span>, sLineBreak,
      <span class="hljs-string">'Args:'</span>, sLineBreak,
      <span class="hljs-string">' /run - Run Guu code.'</span><font></font>
    );<font></font>
<span class="hljs-keyword">end</span>.
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジョブの条件により、インターフェースを自由に実装できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本格的なUIを実装し、SynEditをプロジェクトに固定することは可能ですが、私の意見では、スキルを反映していない無駄な作業であり、そのための費用もかかりません:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だから、小さなコンソールUIに限定しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードは複雑ではないので、コメントなしで残すことができます。</font><font style="vertical-align: inherit;">その中で、既製のTGuuOpを取得して、ステップと呼びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解決した問題のスクリーンショット：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/33e/ad0/efa/33ead0efa3a07d77d1a6c07010847035.jpg" alt="画像"><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/3e1/7eb/41e/3e17eb41e99abece612f09b146464f67.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラー情報の表示：</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/659/1c5/ea4/6591c5ea44e67f5068bd7fb0e9c2341e.jpg" alt="画像"><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2a0/3f0/733/2a03f07336c5af1333f259d43e4a1396.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションのリポジトリへのリンク：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリック</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に決まった結果はありません。</font><font style="vertical-align: inherit;">JetBrainsチームでの2か月の仕事とトレーニングの代わりに、夏のほとんどを忙しい休暇に費やして、大学を検索する必要があります（もちろん、試験に合格した場合に備えて）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく来年、新しい投稿がHabréに表示され、すでにJBまたは私にとって興味深い別の会社でのインターンシッププロセスについて説明しているでしょう:)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja454336/index.html">クライアント：-Facebookのコピーの費用はいくらですか？</a></li>
<li><a href="../ja454340/index.html">％tutnazvanievu％は世界で初めて公式にジェットパックを開発した大学です</a></li>
<li><a href="../ja454346/index.html">効率アルゴリズム：Nobelic 2019監視カメラレビュー</a></li>
<li><a href="../ja454348/index.html">Reactフックによる状態の管理-ReduxとコンテキストAPIなし</a></li>
<li><a href="../ja454352/index.html">Pythonの数学的不確実性</a></li>
<li><a href="../ja454356/index.html">Habr Weekly＃3 / Runet vs TV、ARM vs Intel、状態データの統合、スマートフォンなし、2019年、ソビエトの未来の夢</a></li>
<li><a href="../ja454366/index.html">PHDays 9での勝利。3つのパートでライフハックを共有します。パート2</a></li>
<li><a href="../ja454368/index.html">TeamCityプラグイン開発者コンテスト</a></li>
<li><a href="../ja454372/index.html">毎週のニュース：Huaweiにはまだ問題があり、ロシア連邦では「量子電話」、ARMには新しいプロセッサがあります</a></li>
<li><a href="../ja454374/index.html">ホームビデオプロジェクターからの3Dポリマープリンターは、レイヤーのないオブジェクトを作成します</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>