<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔋 🚨 🧝🏻 Développement d'une bibliothèque corporative de composants React. Approche multiplateforme ❗️ 👶🏼 🏐</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cet article raconte l'histoire de la mise en œuvre réussie du système de conception en compagnie de l'un des plus grands détaillants de bricolage. Les...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Développement d'une bibliothèque corporative de composants React. Approche multiplateforme</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/luxoft/blog/501656/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cet article raconte l'histoire de la mise en œuvre réussie du système de conception en compagnie de l'un des plus grands détaillants de bricolage. </font><font style="vertical-align: inherit;">Les principes et approches du développement multiplateforme de composants d'interface utilisateur à l'aide des bibliothèques React et React Native sont décrits, ainsi que la solution au problème de la réutilisation de code entre des projets pour différentes plates-formes.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, quelques mots sur la façon dont tout a commencé et pourquoi l'idée de mettre en œuvre une conception de système est apparue. Tout a commencé avec une application Android mobile pour les vendeurs en magasin. L'application est basée sur le framework React-Native. La fonctionnalité de départ était représentée par seulement quelques modules, tels que la recherche de produits dans le catalogue et la fiche produit, le document de vente. À propos, il s'agit maintenant d'une application assez puissante qui a déjà largement remplacé la fonctionnalité des bureaux d'information dans les magasins. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, des projets d'applications web pour les employés du service logistique, ainsi que divers configurateurs, ont été lancés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, une compréhension des approches générales de la conception de ces applications, ainsi que la présence d'une base de code assez importante, sont apparues. Et il était logique de systématiser l'autre pour une réutilisation ultérieure.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour systématiser UI / UX, il a été décidé de développer un système de conception. Je n'entrerai pas dans les détails de ce que c'est. Sur Internet, vous pouvez trouver de nombreux articles sur ce sujet. Par exemple, sur Habré, le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travail d'Andrei Sundiev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> peut être recommandé à la lecture </font><font style="vertical-align: inherit;">.</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi concevoir un système et quels sont ses avantages? Le premier est une expérience commune et le sentiment d'utiliser des produits. Les utilisateurs obtiennent une interface familière quelle que soit l'application: les boutons ressemblent et fonctionnent comme ils sont habitués, le menu s'ouvre au bon endroit et avec la bonne dynamique, les champs de saisie fonctionnent de la manière habituelle. Le deuxième avantage est l'introduction de certaines normes et approches communes à la fois du côté de la conception et du côté du développement. Chaque nouvelle fonctionnalité est développée selon des canons et des approches déjà établis. Dès les premiers jours, les nouveaux employés reçoivent une ligne de travail claire. La prochaine consiste à réutiliser les composants et à simplifier le développement. Il n'est pas nécessaire de «réinventer la roue» à chaque fois. Vous pouvez créer des interfaces à partir de blocs prêts à l'emploi avec le résultat final attendu.Eh bien, l'avantage principal pour le client est d'économiser temps et argent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alors, qu'avons-nous fait. En fait, nous avons créé non seulement une bibliothèque de composants, mais tout un framework multiplateforme. Le cadre est basé sur un schéma par lots. Nous avons 5 packages core npm. C'est le cœur du déploiement d'applications Web et Android multiplateformes. Forfaits de modules, utilitaires et services. Et un ensemble de composants, qui sera discuté plus tard. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous trouverez ci-dessous le diagramme UML du package de composants. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wi/kn/xs/wiknxsuqj_n4jze72crt4c4u10g.jpeg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il comprend les composants eux-mêmes, dont certains sont indépendants (éléments), et certains sont connectés les uns aux autres, ainsi que le noyau interne ou «sous-noyau».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Examinons plus en détail ce qui est inclus dans le «sous-noyau». Le premier est la couche visuelle de la conception du système. Tout ici concerne la palette de couleurs, la typographie, le système d'indentation, les grilles, etc. Le bloc suivant est les services nécessaires au fonctionnement des composants, tels que: ComponentsConfig (configuration des composants), StyleSet (je discuterai plus tard de ce concept) et Device (une méthode pour travailler avec l'api du périphérique). Et le troisième bloc est toutes sortes d'aides (résolveurs, générateurs de style, etc.).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/7l/f6/fx7lf6zz7n8olddc2yuf7576s6a.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors du développement de la bibliothèque, nous avons utilisé une approche atomique pour la conception des composants. Tout a commencé avec la création de composants ou d'éléments élémentaires. Ce sont des «particules» élémentaires indépendantes les unes des autres. Les principaux sont Affichage, Texte, Image, Icône. Viennent ensuite les composants les plus complexes. Chacun d'eux utilise un ou plusieurs éléments pour construire sa structure. Par exemple, boutons, champs de saisie, sélections, etc. Le niveau suivant est celui des modèles. Ils sont une combinaison de composants pour résoudre tout problème d'interface utilisateur. Par exemple, un formulaire d'autorisation, un en-tête avec paramètres et réglages, ou une carte de produit conçue par un concepteur qui peut être utilisée dans différents modules. Le dernier et le plus difficile et en même temps important niveau est le soi-disant comportement. Ce sont des modules prêts à l'emploi,Implémentation de certaines logiques métier et, éventuellement, y compris l'ensemble nécessaire de requêtes back-end.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/00/jv/e3/00jve3iwyh64n0tifikfxtoz0v4.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons donc à l'implémentation de la bibliothèque de composants. </font><font style="vertical-align: inherit;">Comme je l'ai mentionné précédemment, nous avons deux plates-formes cibles - Web et Android (réactif natif). </font><font style="vertical-align: inherit;">Si sur le web ce sont des éléments bien connus de tous les développeurs web comme div, span, img, header, etc., en react-native ce sont les composants View, Text, Image, Modal. </font><font style="vertical-align: inherit;">Et la première chose sur laquelle nous nous sommes mis d'accord est le nom des composants. </font><font style="vertical-align: inherit;">Nous avons décidé d'utiliser un système de style natif réactif, comme </font><font style="vertical-align: inherit;">d'une part, une base de composants a déjà été implémentée dans les projets, et d'autre part, ces noms sont les plus universels et les plus compréhensibles pour les développeurs web et réactifs. </font><font style="vertical-align: inherit;">Par exemple, considérez le composant View. </font><font style="vertical-align: inherit;">La méthode du composant de rendu conditionnel pour le Web ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
	<span class="hljs-keyword">return</span>(
		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> {<span class="hljs-attr">...props</span>}&gt;</span>
			{children}
		<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><font></font>
	)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ceux. </font><font style="vertical-align: inherit;">sous le capot, ce n'est rien de plus qu'un div avec les accessoires et les descendants nécessaires. </font><font style="vertical-align: inherit;">En react-native, la structure est très similaire, seul le composant View est utilisé à la place des divs:</font></font><br>
<br>
<pre><code class="javascript hljs">render() {
	<span class="hljs-keyword">return</span>(
		<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> {<span class="hljs-attr">...props</span>}&gt;</span>
			{children}
		<span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><font></font>
	)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La question se pose: comment combiner cela en un seul composant et en même temps diviser le rendu? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est là qu'un modèle de réaction appelé HOC ou composant d'ordre supérieur vient à la rescousse. </font><font style="vertical-align: inherit;">Si vous essayez de dessiner un diagramme UML de ce modèle, vous obtenez quelque chose comme ceci:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/73/sz/tb/73sztbbrwdkvgknh3edlwk93gyo.jpeg" alt="image"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, chaque composant se compose d'un soi-disant délégué qui reçoit les accessoires de l'extérieur et est responsable de la logique commune aux deux plates-formes, et de deux parties de plate-forme dans lesquelles les méthodes spécifiques à chaque plate-forme sont déjà encapsulées et le rendu le plus important. </font><font style="vertical-align: inherit;">Par exemple, considérez le code délégué du bouton:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buttonDelegate</span>(<span class="hljs-params">ReactComponent: ComponentType&lt;Props&gt;</span>): <span class="hljs-title">ComponentType</span>&lt;<span class="hljs-title">Props</span>&gt; </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ButtonDelegate</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">Props</span>&gt; </span>{<font></font>
        <font></font>
        <span class="hljs-comment">// Button common methods</span><font></font>
<font></font>
        render() {<font></font>
           <span class="hljs-keyword">const</span> { onPress, onPressIn, onPressOut } = <span class="hljs-keyword">this</span>.props;
            <span class="hljs-keyword">const</span> delegate = {
                <span class="hljs-attr">buttonContent</span>: <span class="hljs-keyword">this</span>.buttonContent,
                <span class="hljs-attr">buttonSize</span>: <span class="hljs-keyword">this</span>.buttonSize,
                <span class="hljs-attr">iconSize</span>: <span class="hljs-keyword">this</span>.iconSize,
                <span class="hljs-attr">onClick</span>: onPress,
                <span class="hljs-attr">onMouseUp</span>: onPressIn,
                <span class="hljs-attr">onMouseDown</span>: onPressOut,
                <span class="hljs-attr">onPress</span>: <span class="hljs-keyword">this</span>.onPress,
                <span class="hljs-attr">textColor</span>: <span class="hljs-keyword">this</span>.textColor,<font></font>
            };<font></font>
            <span class="hljs-keyword">return</span> (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ReactComponent</span> {<span class="hljs-attr">...this.props</span>} <span class="hljs-attr">delegate</span>=<span class="hljs-string">{delegate}</span> /&gt;</span></span>);<font></font>
        }<font></font>
    };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le délégué reçoit en argument la partie plate-forme du composant, implémente des méthodes communes aux deux plates-formes et les transmet à la partie plate-forme. </font><font style="vertical-align: inherit;">La partie plate-forme du composant lui-même est la suivante:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">WebProps</span>, <span class="hljs-title">State</span>&gt; </span>{<font></font>
    <font></font>
   <span class="hljs-comment">// Web specific methods</span><font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">delegate</span>: { onPress, buttonContent } } = <span class="hljs-keyword">this</span>.props;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
                <span class="hljs-attr">className</span>=<span class="hljs-string">{this.classes}</span>
                {<span class="hljs-attr">...buttonProps</span>}
                <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onPress}</span>
                <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>
            &gt;</span>
                {buttonContent(this.spinner, this.iconText)}
            <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> buttonDelegate(Button);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici une méthode de rendu avec toutes ses fonctionnalités de plateforme. La fonctionnalité générale du délégué se présente sous la forme d'un objet via le délégué des accessoires. Un exemple de la partie plate-forme d'un bouton pour une implémentation native native:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Button</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PureComponent</span>&lt;<span class="hljs-title">NativeProps</span>, <span class="hljs-title">State</span>&gt; </span>{<font></font>
<font></font>
    <span class="hljs-comment">// Native specific methods</span><font></font>
<font></font>
    render() {<font></font>
        <span class="hljs-keyword">const</span> { <span class="hljs-attr">delegate</span>: { onPress, buttonContent } } = <span class="hljs-keyword">this</span>.props;
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">styleSet</span>=<span class="hljs-string">{this.styles}</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{style}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">TouchableOpacity</span>
                    {<span class="hljs-attr">...butonProps</span>}
                    <span class="hljs-attr">onPress</span>=<span class="hljs-string">{onPress}</span>
                    <span class="hljs-attr">style</span>=<span class="hljs-string">{this.touchableStyles}</span>
                    {<span class="hljs-attr">...touchableProps</span>}    
                &gt;</span>
                    {buttonContent(this.spinner, this.iconText)}
                <span class="hljs-tag">&lt;/<span class="hljs-name">TouchableOpacity</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span><font></font>
        );<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> buttonDelegate(Button);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, la logique est similaire, mais des composants natifs réactifs sont utilisés. Dans les deux listes, buttonDelegate est un HOC avec une logique commune. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette approche dans la mise en œuvre des composants, la question se pose de la séparation des pièces de la plateforme lors de l'assemblage du projet. Il est nécessaire de s'assurer que le webpack utilisé par nous dans les projets pour le web ne recueille que les parties des composants destinés au web, tandis que le bundler metro en react-native doit «accrocher» ses parties de plateforme, sans prêter attention au composant pour le web. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ce problème, ils ont utilisé la fonctionnalité intégrée de bundler metro, qui vous permet de spécifier le préfixe d'extension de fichier de plate-forme. Dans notre cas, metro.config.js ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-built_in">module</span>.exports = {
    <span class="hljs-attr">resolver</span>: {
        <span class="hljs-attr">useWatchman</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-attr">platforms</span>: [<span class="hljs-string">'native'</span>],<font></font>
    },<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lors de la création du bundle, metro recherche d'abord les fichiers avec l'extension native.js, puis, s'il n'est pas dans le répertoire en cours, il accroche le fichier avec l'extension .js. Cette fonctionnalité a permis de placer les parties de plate-forme des composants dans des fichiers séparés: la partie pour le web est située dans le fichier .js, la partie react-native est placée dans le fichier avec l'extension .native.js. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit dit en passant, webpack a les mêmes fonctionnalités que NormalModuleReplacementPlugin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre objectif de l'approche multiplateforme était de fournir un mécanisme unique pour styliser les composants. Dans le cas des applications Web, nous avons choisi le préprocesseur Sass, qui se compile finalement en CSS standard. Ceux. pour les composants Web, nous avons utilisé les développeurs familiers react className.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les composants natifs de React sont stylisés à l'aide de styles en ligne et de style d'accessoires. </font><font style="vertical-align: inherit;">Il a fallu combiner ces deux approches, permettant d'utiliser des classes de style pour les applications Android. </font><font style="vertical-align: inherit;">À cette fin, le concept de styleSet a été introduit, qui n'est rien de plus qu'un tableau de chaînes - noms de classe:</font></font><br>
<br>
<pre><code class="javascript hljs">styleSet: <span class="hljs-built_in">Array</span>&lt;string&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le même temps, le service StyleSet du même nom a été implémenté pour react-native, ce qui permet d'enregistrer les noms de classe:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> StyleSet.define({
    <span class="hljs-string">'lmui-Button'</span>: {
        <span class="hljs-attr">borderRadius</span>: <span class="hljs-number">6</span>,<font></font>
    },<font></font>
    <span class="hljs-string">'lmui-Button-buttonSize-md'</span>: {
        <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">paddingBottom</span>: <span class="hljs-number">4</span>,
        <span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">12</span>,
        <span class="hljs-attr">paddingRight</span>: <span class="hljs-number">12</span>,<font></font>
    },<font></font>
    <span class="hljs-string">'lmui-Button-buttonSize-lg'</span>: {
        <span class="hljs-attr">paddingTop</span>: <span class="hljs-number">8</span>,
        <span class="hljs-attr">paddingBottom</span>: <span class="hljs-number">8</span>,
        <span class="hljs-attr">paddingLeft</span>: <span class="hljs-number">16</span>,
        <span class="hljs-attr">paddingRight</span>: <span class="hljs-number">16</span>,<font></font>
    },<font></font>
})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les composants Web, styleSet est un tableau de noms de classes css qui sont «collés» à l'aide de la bibliothèque de noms de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">classes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que le projet est multiplateforme, il est évident qu'avec la croissance de la base de code, le nombre de dépendances externes augmente également. De plus, les dépendances sont différentes pour chaque plateforme. Par exemple, pour les composants Web, des bibliothèques telles que style-loader, react-dom, classnames, webpack, etc. sont nécessaires. Pour les composants react-native, un grand nombre de ses bibliothèques «natives» sont utilisées, par exemple, react-native lui-même. Si le projet dans lequel il est censé utiliser la bibliothèque de composants n'a qu'une seule plate-forme cible, l'installation de toutes les dépendances sur une autre plate-forme est irrationnelle. Pour résoudre ce problème, nous avons utilisé le hook postinstall de npm lui-même, dans lequel un script a été installé pour installer les dépendances pour la plate-forme spécifiée. Les dépendances elles-mêmes ont été enregistrées dans la section correspondante de package.json du package,et la plate-forme cible doit être spécifiée dans le package package.json sous forme de tableau.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cette approche a révélé un inconvénient, qui s'est ensuite transformé en plusieurs problèmes lors de l'assemblage dans le système CI. La racine du problème était qu'avec package-lock.json, le script spécifié dans postinstall n'a pas installé toutes les dépendances enregistrées. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai dû chercher une autre solution à ce problème. La solution était simple. Un schéma à deux packages a été appliqué, dans lequel toutes les dépendances de plateforme ont été placées dans la section des dépendances du package de plateforme correspondant. Par exemple, dans le cas du Web, le package est appelé components-web, dans lequel il existe un seul fichier package.json. Il contient toutes les dépendances de la plate-forme Web, ainsi que le package principal avec les composants composants. Cette approche nous a permis de maintenir la séparation des dépendances et de préserver la fonctionnalité de package-lock.json.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusion, je vais donner un exemple de code JSX en utilisant notre bibliothèque de composants:</font></font><br>
<br>
<pre><code class="javascript hljs">&lt;View row&gt;
   <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span>
      <span class="hljs-attr">col-xs</span>=<span class="hljs-string">{12}</span>
      <span class="hljs-attr">col-md</span>=<span class="hljs-string">{8}</span>
      <span class="hljs-attr">col-lg</span>=<span class="hljs-string">{4}</span>
      <span class="hljs-attr">col-xl</span>=<span class="hljs-string">{4}</span>
      <span class="hljs-attr">middle-xs</span>
      <span class="hljs-attr">col-md-offset-3</span>
   /&gt;</span></span>
     <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Text</span> <span class="hljs-attr">size</span>=<span class="hljs-string">”fs1”</span>&gt;</span>Sample text<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span></span><font></font>
   &lt;/View&gt;<font></font>
&lt;/View&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet extrait de code est multiplateforme et fonctionne de la même manière dans une application React pour le Web et dans une application Android sur React-Native. </font><font style="vertical-align: inherit;">Si nécessaire, le même code peut être «liquidé» sous iOS. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la tâche principale à laquelle nous avons été confrontés a été résolue - la réutilisation maximale des deux approches de conception et de la base de code entre divers projets. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez indiquer dans les commentaires quelles questions sur ce sujet étaient intéressantes à apprendre dans le prochain article.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501646/index.html">Go, Vue et 3 jours pour développer: un système de suivi des patients en temps réel</a></li>
<li><a href="../fr501648/index.html">10 extensions pour VS Code, sans lesquelles je ne peux pas programmer</a></li>
<li><a href="../fr501650/index.html">Que contient un fichier .wasm? Présentation de Wasm-Decompile</a></li>
<li><a href="../fr501652/index.html">Nuxt comme serveur fullstack: serveur API frontend + backend (partie 1)</a></li>
<li><a href="../fr501654/index.html">Construire des processus de travail sur un site distant: recommandations pratiques</a></li>
<li><a href="../fr501658/index.html">Comment établir un workflow "à distance": 7 étapes pratiques</a></li>
<li><a href="../fr501662/index.html">Pourquoi Axure a pu plier Sketch et Figma, mais n'a pas plié</a></li>
<li><a href="../fr501664/index.html">La vidéoconférence est désormais un marché et de nouvelles technologies. Longrid, deuxième partie</a></li>
<li><a href="../fr501668/index.html">Fournir des communications d'objets en mouvement et d'outils pour augmenter sa fiabilité</a></li>
<li><a href="../fr501670/index.html">Combien coûte la vie ou 2,1 millions de dollars par injection: une merveilleuse thérapie génique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>