<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚸 👩‍🍳 🚺 PostgreSQLでのEAVのJSONBへの置き換え 🎓 🥖 🤸🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="TL DR：JSONBは、クエリのパフォーマンスを犠牲にすることなく、データベーススキーマの開発を大幅に簡略化できます。
 前書き
 おそらく、リレーショナルデータベース（データベース）の最も古い使用例の1つである古典的な例を挙げてみましょう。エンティティがあり、このエンティティの特定のプロパティ（...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>PostgreSQLでのEAVのJSONBへの置き換え</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/475178/"><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TL </font><font style="vertical-align: inherit;">DR：JSONBは、クエリのパフォーマンスを犠牲にすることなく、データベーススキーマの開発を大幅に簡略化できます。</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、リレーショナルデータベース（データベース）の最も古い使用例の1つである古典的な例を挙げてみましょう。エンティティがあり、このエンティティの特定のプロパティ（属性）を保持する必要があります。ただし、すべてのインスタンスが同じプロパティのセットを持っているとは限らず、将来、さらに多くのプロパティが追加される可能性もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決する最も簡単な方法は、各プロパティ値のデータベーステーブルに列を作成し、特定のエンティティインスタンスに必要な列に入力することです。いいね！問題は解決されます...テーブルに数百万のレコードが含まれ、新しいレコードを追加する必要がなくなるまで。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EAV（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Entity-Attribute-Value）</font></a><font style="vertical-align: inherit;">パターンを検討する</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、それはかなり頻繁に発生します。 1つのテーブルにはエンティティ（レコード）が含まれ、別のテーブルにはプロパティ（属性）の名前が含まれ、3番目のテーブルにはエンティティとその属性が関連付けられ、現在のエンティティのこれらの属性の値が含まれます。これにより、データベースの構造を変更せずに、さまざまなオブジェクトにさまざまなプロパティのセットを設定したり、その場でプロパティを追加したりできます。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、EVAを使用するアプローチに欠点がない場合は、このノートを書きません。したがって、たとえば、それぞれ1つの属性を持つ1つ以上のエンティティを取得するには、クエリで2つの結合（結合）が必要です。1つ目は属性テーブルとの結合、2つ目は値テーブルとの結合です。エンティティに2つの属性がある場合、4つの結合がすでに必要です。さらに、すべての属性は通常文字列として格納されるため、結果とWHERE句の両方で型キャストが発生します。大量のクエリを作成すると、リソースの使用という点でかなり無駄になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの明らかな欠陥にもかかわらず、EAVは長い間、この種の問題を解決するために使用されてきました。これらは避けられない欠陥であり、単により良い代替案はありませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかしその後、PostgreSQLは新しい「テクノロジー」を導入しまし</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
た。PostgreSQL9.4以降、JSONBデータタイプがバイナリJSONデータを格納するために追加されました。</font><font style="vertical-align: inherit;">通常、JSONをこの形式で格納すると、プレーンテキストのJSONよりも少し時間がかかりますが、それを使用した操作ははるかに高速です。</font><font style="vertical-align: inherit;">JSONBはインデックス作成もサポートしているため、クエリをさらに高速化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONBデータ型を使用すると、エンティティテーブルにJSONB列を1つだけ追加することで、かさばるEAVパターンを置き換えることができます。これにより、データベースの設計が大幅に簡略化されます。</font><font style="vertical-align: inherit;">しかし、これには生産性の低下が伴うはずであると多くの人が主張しています...それが私がこの記事に登場した理由です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストデータベースのセットアップ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この比較のために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DigitalOcean</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubuntu 14.04の</font><font style="vertical-align: inherit;">80ドルのビルドにPostgreSQL 9.5の新規インストールでデータベースを作成しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">postgresql.confにいくつかのパラメータを設定した後、</font><font style="vertical-align: inherit;">psqlを使用</font><font style="vertical-align: inherit;">して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプトを</font><font style="vertical-align: inherit;">実行しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次の表は、データをEAVとして表すために作成されました。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> entity ( <font></font>
  id           <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>, 
  <span class="hljs-type">name</span>         <span class="hljs-type">TEXT</span>, <font></font>
  description  <span class="hljs-type">TEXT</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> entity_attribute (<font></font>
  id          <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>, 
  <span class="hljs-type">name</span>        <span class="hljs-type">TEXT</span><font></font>
);<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> entity_attribute_value (<font></font>
  id                  <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>, <font></font>
  entity_id           <span class="hljs-type">INT</span>    <span class="hljs-keyword">REFERENCES</span> entity(id), <font></font>
  entity_attribute_id <span class="hljs-type">INT</span>    <span class="hljs-keyword">REFERENCES</span> entity_attribute(id), 
  <span class="hljs-keyword">value</span>               <span class="hljs-type">TEXT</span><font></font>
);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、同じデータが格納されるテーブルですが、JSONBタイプのcolumn- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">propertiesに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性があり</font><i><font style="vertical-align: inherit;">ます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> entity_jsonb (<font></font>
  id          <span class="hljs-type">SERIAL</span> <span class="hljs-keyword">PRIMARY KEY</span>, 
  <span class="hljs-type">name</span>        <span class="hljs-type">TEXT</span>, <font></font>
  description <span class="hljs-type">TEXT</span>,<font></font>
  properties  <span class="hljs-type">JSONB</span><font></font>
);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ずっと楽に見えますよね？</font><font style="vertical-align: inherit;">次に、</font><font style="vertical-align: inherit;">1,000万のレコード</font><font style="vertical-align: inherit;">がエンティティテーブル（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entity</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＆</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entity_jsonb</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）に</font><font style="vertical-align: inherit;">追加されたため</font><font style="vertical-align: inherit;">、EAVパターンとJSONB列を使用したアプローチ-entity_jsonb.propertiesを使用して、同じテーブルデータが入力され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ました</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">したがって、プロパティのセット全体からいくつかの異なるデータタイプを受け取りました。</font><font style="vertical-align: inherit;">サンプルデータ：</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
  id:          <span class="hljs-number">1</span>
  name:        <span class="hljs-string">"Entity1"</span>
  description: <span class="hljs-string">"Test entity no. 1"</span><font></font>
  properties:  {<font></font>
    color:        <span class="hljs-string">"red"</span>
    lenght:       <span class="hljs-number">120</span>
    width:        <span class="hljs-number">3.1882420</span>
    hassomething: <span class="hljs-literal">true</span>
    country:      <span class="hljs-string">"Belgium"</span><font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、2つのオプションについて同じデータが得られました。</font><font style="vertical-align: inherit;">職場での実装の比較を始めましょう！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">設計の簡素化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EAVに3つのテーブルを使用するのではなく、JSONB列をプロパティに使用することにより、データベースの設計が大幅に簡略化されたと以前に言われていました。</font><font style="vertical-align: inherit;">しかし、これはどのようにリクエストに反映されますか？</font><font style="vertical-align: inherit;">エンティティの1つのプロパティの更新は次のとおりです。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-comment">-- EAV</span>
<span class="hljs-keyword">UPDATE</span> entity_attribute_value 
<span class="hljs-keyword">SET</span> <span class="hljs-keyword">value</span> = <span class="hljs-string">'blue'</span> 
<span class="hljs-keyword">WHERE</span> entity_attribute_id = <span class="hljs-number">1</span> 
  <span class="hljs-keyword">AND</span> entity_id = <span class="hljs-number">120</span>;<font></font>
<font></font>
<span class="hljs-comment">-- JSONB</span>
<span class="hljs-keyword">UPDATE</span> entity_jsonb 
<span class="hljs-keyword">SET</span> properties = jsonb_set(properties, <span class="hljs-string">'{"color"}'</span>, <span class="hljs-string">'"blue"'</span>) 
<span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">120</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、最後のリクエストは簡単には見えません。 JSONBオブジェクトのプロパティの値を更新するには、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsonb_set（）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数を使用し、</font><font style="vertical-align: inherit;">新しい値をJSONBオブジェクトとして渡す必要があります。ただし、識別子を事前に知っておく必要はありません。 EAVの例を見ると、更新するには、entity_idとentity_attribute_idの両方を知っている必要があります。オブジェクトの名前に基づいてJSONB列のプロパティを更新する場合、これはすべて1つの単純な行で行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、新しい色の状態に従って、更新したエンティティを選択します。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-comment">-- EAV</span>
<span class="hljs-keyword">SELECT</span> e.name 
<span class="hljs-keyword">FROM</span> entity e 
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> entity_attribute_value eav <span class="hljs-keyword">ON</span> e.id = eav.entity_id
  <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> entity_attribute ea <span class="hljs-keyword">ON</span> eav.entity_attribute_id = ea.id
<span class="hljs-keyword">WHERE</span> ea.name = <span class="hljs-string">'color'</span> <span class="hljs-keyword">AND</span> eav.<span class="hljs-keyword">value</span> = <span class="hljs-string">'blue'</span>;<font></font>
<font></font>
<span class="hljs-comment">-- JSONB</span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> 
<span class="hljs-keyword">FROM</span> entity_jsonb 
<span class="hljs-keyword">WHERE</span> properties -&gt;&gt; <span class="hljs-string">'color'</span> = <span class="hljs-string">'blue'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の方が（joinを使わないで）短いので、読みやすいことに同意できると思います。</font><font style="vertical-align: inherit;">これがJSONBの勝利です！</font><font style="vertical-align: inherit;">JSON-&gt;&gt;演算子を使用して、JSONBオブジェクトからテキスト値として色を取得します。</font><font style="vertical-align: inherit;">@&gt;演算子を使用してJSONBモデル​​で同じ結果を得る2番目の方法もあります。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-comment">-- JSONB </span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span> 
<span class="hljs-keyword">FROM</span> entity_jsonb 
<span class="hljs-keyword">WHERE</span> properties @&gt; <span class="hljs-string">'{"color": "blue"}'</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは少し複雑です。プロパティ列のJSONオブジェクトに@&gt;演算子の右側のオブジェクトが含まれているかどうかを確認します。</font><font style="vertical-align: inherit;">読みにくく、生産性が高くなります（以下を参照）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のプロパティを一度に選択する必要がある場合は、JSONBの使用をさらに簡素化します。</font><font style="vertical-align: inherit;">これは、JSONBアプローチが本当に当てはまる場所です。結合を必要とせずに、結果セットの追加の列としてプロパティを選択するだけです。</font></font><br>
<br>
<pre><code class="pgsql hljs"><span class="hljs-comment">-- JSONB </span>
<span class="hljs-keyword">SELECT</span> <span class="hljs-type">name</span>
  , properties -&gt;&gt; <span class="hljs-string">'color'</span>
  , properties -&gt;&gt; <span class="hljs-string">'country'</span>
<span class="hljs-keyword">FROM</span> entity_jsonb 
<span class="hljs-keyword">WHERE</span> id = <span class="hljs-number">120</span>;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EAVでは、要求するプロパティごとに2つの結合が必要です。</font><font style="vertical-align: inherit;">私の意見では、上記のクエリはデータベース設計の大幅な簡素化を示しています。</font><font style="vertical-align: inherit;">JSONBリクエストの記述方法の例についても、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">投稿を</font><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、パフォーマンスについて説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パフォーマンスを比較するため</font><font style="vertical-align: inherit;">に、クエリで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EXPLAIN ANALYZE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><font style="vertical-align: inherit;">てランタイムを計算しました。クエリプランナーが初めて時間がかかるため、各要求は少なくとも3回実行されました。最初は、インデックスなしでクエリを実行しました。 EAVに必要な結合でインデックスを使用できなかったため（外部キーフィールドにインデックスが作成されなかったため）、これは明らかにJSONBの利点となりました。その後、EAV値のテーブルに外部キーの2列のインデックス</font><font style="vertical-align: inherit;">と、JSONB列の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GIN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インデックス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">作成し</font><font style="vertical-align: inherit;">ました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データの更新は、次の結果を時間（ミリ秒）で示しました。スケールは対数であることに注意してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xr/ma/ij/xrmaijvxbnlu_t5jd0nmg0syuxc.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の理由により、インデックスを使用しない場合、JSONBはEAVよりもはるかに高速（&gt; 50,000-x）であることがわかります。主キーで列にインデックスを付けると、違いはほとんどなくなりますが、JSONBはEAVより1.3倍高速です。 JSONB列のインデックスは、評価基準でプロパティ列を使用しないため、ここでは効果がないことに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティ値に基づいてデータを選択すると、次の結果（通常のスケール）が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/e6/fp/vb/e6fpvbgyqlq536wcbpke7_wrz9s.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JSONBはインデックスのないEAVよりも高速ですが、EAVにインデックスがある場合でも、JSONBよりも高速に動作します。</font><font style="vertical-align: inherit;">しかし、JSONBリクエストの時間が同じであることがわかり、GINインデックスが機能しなかったという事実に気づきました。</font><font style="vertical-align: inherit;">明らかに、プロパティが入力された列にGINインデックスを使用する場合、インクルード演算子@&gt;を使用する場合にのみ機能します。</font><font style="vertical-align: inherit;">私はこれを新しいテストで使用しました。これは時間に大きな影響を与えました：わずか0.153ミリ秒！</font><font style="vertical-align: inherit;">これは、EAVの15,000倍、オペレーターより25,000倍高速です&gt;&gt;。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十分な速さだったと思います！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DBテーブルサイズ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のアプローチのテーブルサイズを比較してみましょう。 psqlでは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ dti +コマンド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用してすべてのテーブルとインデックスのサイズを表示できます</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p6/9m/la/p69mlax6rsctef8sqcu52btxshi.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。EAVアプローチの場合、テーブルサイズは約3068 MB、インデックスは最大3427 MBであり、合計で6.43 GBになります。 JSONBアプローチを使用すると、テーブルに1817 MB、インデックスに318 MB、つまり2.08 GBが使用されます。 3倍少なくなります。すべてのJSONBオブジェクトにプロパティ名を格納しているので、この事実には少し驚きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべて同じですが、数値自体が意味します。EAVでは、属性値に2つの整数の外部キーを格納し、その結果、8バイトの追加データを取得します。</font><font style="vertical-align: inherit;">さらに、EAVでは、すべてのプロパティ値はテキストとして保存されますが、JSONBは可能な限り内部で数値と論理値を使用するため、ボリュームが少なくなります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概要</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、エンティティプロパティをJSONB形式で保存すると、データベースの設計とメンテナンスを大幅に簡略化できると思います。</font><font style="vertical-align: inherit;">多くのクエリを実行する場合、エンティティと同じテーブルに格納されているすべてのものは、実際にはより効率的に機能します。</font><font style="vertical-align: inherit;">そして、これがデータ間の相互作用を単純化するという事実はすでにプラスですが、結果として得られるデータベースはボリュームが3倍小さくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、テストによると、パフォーマンスの低下はごくわずかであると結論付けることができます。</font><font style="vertical-align: inherit;">場合によっては、JSONBはEAVよりも高速に動作するため、さらに優れています。</font><font style="vertical-align: inherit;">ただし、もちろん、このベンチマークはすべての側面をカバーしているわけではありません（たとえば、非常に多数のプロパティを持つエンティティ、既存のデータのプロパティ数の大幅な増加など）。したがって、それらを改善する方法について提案がある場合は、コメントを残してお気軽に！</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475166/index.html">エレクトロニクス開発。例のプロジェクト監査。暖かい床をすべてのhabrで保存します</a></li>
<li><a href="../ja475168/index.html">低リスクの為替投資：銀行預金の代わりにIIA口座と債券を使用する方法</a></li>
<li><a href="../ja475170/index.html">React.JSでデータ駆動型アプリを作成するための基本パターンの問題</a></li>
<li><a href="../ja475172/index.html">Raspberry Piを有益に使用する5つの方法 パート3</a></li>
<li><a href="../ja475174/index.html">バッテリーの離陸方法または電気パラモーターの小さな理論。パート1</a></li>
<li><a href="../ja475180/index.html">バッテリーの離陸方法、またはSkyMax電気パラモーターの操作方法。パート2</a></li>
<li><a href="../ja475182/index.html">データのような機械学習の競争をどのように決定したか</a></li>
<li><a href="../ja475184/index.html">ファンシーLinuxシステムコール</a></li>
<li><a href="../ja475188/index.html">制約ベースのタイル配置アルゴリズム</a></li>
<li><a href="../ja475192/index.html">地球温暖化防止に役立つ会社での仕事を見つけるには？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>