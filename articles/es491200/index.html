<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öïÔ∏è üõçÔ∏è üëäüèΩ Temporizador de funciones para el controlador industrial Simatic S7-1200 üßöüèª üßìüèª üé¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Incluso para las series S7-300 y S7-400, en el Paso 7, las versiones cl√°sicas de los temporizadores ofrecidos al desarrollador eran suficientes: estos...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Temporizador de funciones para el controlador industrial Simatic S7-1200</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491200/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Incluso para las series S7-300 y S7-400, en el Paso 7, las versiones cl√°sicas de los temporizadores ofrecidos al desarrollador eran suficientes: estos son temporizadores IEC est√°ndar, implementados como bloques de funciones y temporizadores S5 (que, por cierto, todav√≠a existen para la serie S7 1500). Sin embargo, en algunos casos, el desarrollador no us√≥ herramientas est√°ndar e implement√≥ sus propios temporizadores, la mayor√≠a de las veces en forma de funciones. Tales funciones de temporizadores eran necesarias con un enfoque de "TI" para la programaci√≥n, en el que operaban no con instancias separadas de los bloques funcionales de equipos tecnol√≥gicos, con el enlace correspondiente de entradas y salidas, sino con conjuntos de estructuras. Por ejemplo, una matriz de una estructura de tipo de entrada discreta. O una matriz de una estructura agregada. Este enfoque de programaci√≥n tiene derecho a existir, ya que le permite guardar seriamente la memoria de trabajo de la CPU, pero,por otro lado, hace que el c√≥digo del programa sea dif√≠cil de leer. Un programador de terceros y con un simple aspecto de un programa en LAD no puede resolverlo de inmediato, pero no se puede encontrar un mont√≥n de √≠ndices, matrices y funciones para procesarlos; aqu√≠, sin documentaci√≥n para el software (y sin medio litro, por supuesto), en ninguna parte.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estas matrices de estructuras se procesaban t√≠picamente en funciones. En principio, nada imped√≠a el procesamiento de bloques de funciones, pero siempre hab√≠a una pregunta importante: ¬øc√≥mo trabajar con temporizadores en estos casos? Los temporizadores est√°ndar suponen un n√∫mero (S5) o una instancia de un bloque de funciones (IEC). Les recuerdo que se trata de procesar matrices de estructuras para PLC Simatic cl√°sicos y de "torcer" n√∫meros de temporizador en estas estructuras, y a√∫n m√°s, las instancias son dif√≠ciles o simplemente imposibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por esta raz√≥n, creamos nuestra propia funcionalidad de temporizador como funci√≥n. En principio, para el funcionamiento de cualquier temporizador, solo necesita saber algunas cosas: el estado de la entrada, la configuraci√≥n de tiempo y cu√°nto tiempo ha pasado desde la activaci√≥n.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para las series 300 y 400, hab√≠a dos formas de determinar esta vez. </font><font style="vertical-align: inherit;">El primero es observar el tiempo de ejecuci√≥n del OB1 principal (hay una variable correspondiente en el propio OB1) u OB c√≠clicos y aumentar el acumulador de tiempo interno con cada llamada del temporizador, siempre que se ingrese la "verdad". </font><font style="vertical-align: inherit;">No es una buena opci√≥n, ya que esta vez es diferente para OB1 y OB c√≠clicos. </font><font style="vertical-align: inherit;">El segundo m√©todo es la funci√≥n del sistema TIME_TCK, que, con cada llamada, devuelve un valor √∫nico: el contador interno de milisegundos del procesador central. </font></font><br>
<br>
<img src="https://sun9-40.userapi.com/c855036/v855036198/1f8065/UwCQvxh507k.jpg" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, para un temporizador del tipo TON (en retraso), el algoritmo de operaci√≥n fue el siguiente:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el borde ascendente de la solicitud de respuesta, restablezca la salida y recuerde el valor actual del temporizador del sistema TIME_TCK</font></font></li>
<li>       ¬´¬ª          ,        (   ,  TIME_TCK    0  (2 ^ 31 ‚Äî 1),          ).   ,        .    ,    ¬´¬ª,    ‚Äî ¬´¬ª</li>
<li>      ¬´¬ª,   </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con el advenimiento de la serie "mil√©sima", la situaci√≥n ha cambiado un poco. El hecho es que la l√≠nea S7-1500 hered√≥ el soporte para la llamada al sistema TIME_TCK, y los amantes del enfoque "de pie y en una hamaca" (¬øde qu√© otra manera puede llamar a un programa que solo hace lo que procesa matrices de estructuras, mientras opera con √≠ndices espeluznantes?) tranquilamente contin√∫e usando sus mejores pr√°cticas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La serie S7-1200 de controladores base se basa en una arquitectura diferente y tiene varias diferencias con respecto al S7-1500. Incluyendo la falta de una llamada al sistema TIME_TCK. En las filas de desarrolladores que no tienen suficiente flexibilidad de pensamiento, la insatisfacci√≥n ha desaparecido: es imposible ejecutar copias / pastas de programas antiguos. Sin embargo, la tarea de determinar cu√°nto tiempo ha pasado desde la llamada anterior se puede realizar utilizando la funci√≥n de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tiempo de ejecuci√≥n</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta funci√≥n devuelve el tiempo transcurrido desde su llamada anterior, en segundos, como un n√∫mero real de doble precisi√≥n LREAL. Los detalles se describen en la ayuda. Para fines internos, se requiere una variable MEM adicional (tambi√©n del tipo LREAL). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√© las fuentes de la primera aproximaci√≥n de la funci√≥n, y dar√© algunas notas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Declaraci√≥n de funci√≥n:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_OUTPUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con las entradas / salidas, todo est√° claro: IN, Q y PT. Configur√© el ajuste del tiempo en forma real, son segundos. Solo quer√≠a (pero en vano, pero m√°s sobre eso a continuaci√≥n). M√°s sobre las variables del √°rea InOut. Como tenemos una funci√≥n, no tenemos un √°rea STAT, no hay variables que conserven su valor durante la pr√≥xima llamada a la funci√≥n, y se necesitan tales variables: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
INPrv - para determinar el borde positivo de la solicitud </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MEM - variable auxiliar para la llamada al sistema </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tiempo de </font><font style="vertical-align: inherit;">ejecuci√≥n </font><font style="vertical-align: inherit;">TimeACC - acumulador de tiempo , que almacenar√° el n√∫mero de microsegundos del retraso actual.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las variables TimeACC, udiCycle y udiPT se especifican en formato UDINT, un entero sin signo, 4 bytes. </font><font style="vertical-align: inherit;">A pesar de que especifiqu√© el tiempo como real, y la funci√≥n de tiempo de ejecuci√≥n devuelve real tanto como la precisi√≥n doble, prefiero realizar operaciones simples de suma y comparaci√≥n con operandos enteros para ahorrar tiempo de procesador. </font><font style="vertical-align: inherit;">El tiempo en mi caso se tiene en cuenta al microsegundo. </font><font style="vertical-align: inherit;">La raz√≥n es simple: si reduce el tiempo a milisegundos, entonces con el OB1 casi vac√≠o (por ejemplo, si solo se llama a un temporizador en todo el programa del controlador y nada m√°s), son posibles "saltos" de ciclos, el programa a veces se ejecuta durante 250 Œºs. </font><font style="vertical-align: inherit;">Pero en este caso, el valor m√°ximo permitido del acumulador de tiempo ser√° 4,294 segundos, casi 4,295 (2 ^ 32 - 1 = 4,294,967,295). </font><font style="vertical-align: inherit;">No hay nada que hacer, tal "optimizaci√≥n" requiere sacrificio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Texto de funci√≥n</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
    #Q := FALSE;<font></font>
ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
    #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
    <span class="hljs-keyword">IF</span> #TimeACC &gt;=  #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
        #Q := TRUE; <span class="hljs-comment">//  ""</span>
        #TimeACC := #udiPT; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//      </span>
        #Q := FALSE; <span class="hljs-comment">// </span><font></font>
    END_IF;<font></font>
<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
    #Q := FALSE;<font></font>
    #TimeACC := <span class="hljs-number">0</span>;<font></font>
END_IF;<font></font>
<font></font>
#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
<font></font>
ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las primeras dos l√≠neas son el rec√°lculo de la configuraci√≥n del temporizador desde el n√∫mero de segundos especificado en el formato REAL hasta el n√∫mero de microsegundos. </font><font style="vertical-align: inherit;">Tambi√©n se determina el tiempo en microsegundos transcurrido desde la llamada de bloque de programa anterior. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, el algoritmo es el siguiente, y ya lo he dado:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el flanco ascendente de la entrada IN, restablezca la salida Q y restablezca el acumulador de tiempo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si la "verdad" contin√∫a siendo ingresada, aumentamos el tiempo acumulado por el valor udiCycle ya conocido y lo comparamos con la configuraci√≥n de tiempo. </font><font style="vertical-align: inherit;">Si se excede el ajuste de tiempo, el temporizador ha funcionado, d√© la salida "verdadero", de lo contrario, d√© la salida "falso"</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el caso de aplicar una entrada falsa a la entrada IN, restablezca la salida Q y restablezca el acumulador de tiempo.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final de la funci√≥n, para determinar el borde de la entrada IN, recuerde su valor anterior. </font><font style="vertical-align: inherit;">Tambi√©n proporcione a la salida ENO (cuando se utiliza una funci√≥n en lenguajes gr√°ficos, como LAD) el valor de la salida Q. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos aseguramos de que la funci√≥n est√© funcionando, despu√©s de lo cual resulta interesante evaluar su velocidad y, si es necesario, mejorar (ya parece a primera vista que varios c√°lculos van a inactivo y desperdiciando tiempo de CPU en vano). </font><font style="vertical-align: inherit;">Para evaluar el rendimiento, declaro una matriz de 1000 estructuras de datos del temporizador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Declaraci√≥n de la estructura. </font><font style="vertical-align: inherit;">Sus campos duplican las variables de entrada y salida de la funci√≥n del temporizador.</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">TYPE</span> "typePervTONdata"<font></font>
VERSION : <span class="hljs-number">0.1</span><font></font>
   STRUCT<font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//   </span>
      Q : Bool;   <span class="hljs-comment">//  </span>
      INPrv : Bool;   <span class="hljs-comment">//    </span>
      MEM : LReal;   <span class="hljs-comment">//    </span>
      TimeACC : UDInt;   <span class="hljs-comment">//  </span><font></font>
   END_STRUCT;<font></font>
<font></font>
END_TYPE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se declara una serie de estructuras en el bloque de datos global de TortureTON:</font></font><br>
<br>
<pre><code class="delphi hljs">TONs : <span class="hljs-keyword">Array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">999</span>] <span class="hljs-keyword">of</span> "typePervTONdata";
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El siguiente c√≥digo se ejecuta en el bloque organizativo OB1:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-keyword">FOR</span> #i := <span class="hljs-number">0</span> <span class="hljs-keyword">TO</span> <span class="hljs-number">999</span> <span class="hljs-keyword">DO</span>
    "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span> := "startton";<font></font>
    "PerversionTON"(<span class="hljs-keyword">IN</span> := "TortureTON".TONs[#i].<span class="hljs-keyword">IN</span>,<font></font>
                    PT := "TortureTON".TONs[#i].PT,<font></font>
                    Q := "TortureTON".TONs[#i].Q,<font></font>
                    INPrv := "TortureTON".TONs[#i].INPrv,<font></font>
                    MEM := "TortureTON".TONs[#i].MEM,<font></font>
                    TimeACC := "TortureTON".TONs[#i].TimeACC);<font></font>
END_FOR;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anunci√≥ 1000 "instancias" de temporizadores, cada uno de ellos con un tiempo de 10 segundos. Los 1000 temporizadores comienzan a contar el tiempo por el valor de la variable del marcador de inicio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comienzo las funciones de diagn√≥stico del controlador (S7-1214C DC / DC / DC, versi√≥n FW 4.4, versi√≥n Step7 - V16) y miro el tiempo de ciclo de exploraci√≥n del controlador. En "inactivo" (cuando "falso" llega a la entrada de los temporizadores), el millar completo se procesa en promedio durante 36-42 milisegundos. Durante la cuenta regresiva de diez segundos, esta lectura crece unos 6-8 milisegundos y, a veces, se desplaza durante 50 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vemos qu√© se puede mejorar en el c√≥digo de funci√≥n. En primer lugar, las l√≠neas al principio del bloque del programa:</font></font><br>
<br>
<pre><code class="delphi hljs">#udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
#udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Siempre se llaman, independientemente de si el temporizador cuenta el tiempo, no cuenta o ya ha contado. Una gran p√©rdida de dinero es cargar la CPU no muy potente de la serie 1200 con c√°lculos que involucran materiales de doble precisi√≥n. Es razonable transferir ambas l√≠neas a la parte del c√≥digo que procesa la cuenta regresiva (si la "verdad" contin√∫a entrando). Tambi√©n es necesario duplicar el c√°lculo de udiCycle en un c√≥digo que procese un borde positivo en la entrada del temporizador. Esto deber√≠a aliviar la "operaci√≥n inactiva" del temporizador cuando el valor de entrada es falso. En la pr√°ctica, los temporizadores en los controladores l√≥gicos programables suelen funcionar "inactivos". Por ejemplo, el tiempo de filtrado del rebote de contacto es de decenas de milisegundos. El pulso de control de una salida discreta es de unos pocos cientos de milisegundos, generalmente de 0,5 a 1,0 segundos.El tiempo para monitorear la ejecuci√≥n del comando de la unidad (por ejemplo, el tiempo que la v√°lvula se abre por completo) es de decenas de segundos a varios minutos. El PLC en producci√≥n funciona las 24 horas del d√≠a y los 365 (¬°y a veces m√°s!) D√≠as al a√±o. Es decir, la mayor√≠a de las veces la entrada del temporizador es "cero", y el temporizador no cuenta nada, o llega una "unidad" durante mucho tiempo, y el temporizador ya ha contado todo. Para descargar la CPU inactiva de la segunda etapa (el temporizador ya ha contado), es necesario verificar en la etapa "la entrada contin√∫a recibiendo la verdad", si el temporizador ya ha contado todo el tiempo y ha configurado la salida como verdadera. En este caso, no se deben realizar c√°lculos.la mayor√≠a de las veces la entrada del temporizador es "cero", y el temporizador no cuenta nada, o llega una "unidad" durante mucho tiempo, y el temporizador ya ha contado todo. Para descargar la CPU inactiva de la segunda etapa (el temporizador ya ha contado), es necesario verificar en la etapa "la verdad sigue entrando", si el temporizador ya ha contado todo el tiempo y ha configurado la salida como verdadera. En este caso, no se deben realizar c√°lculos.la mayor√≠a de las veces la entrada del temporizador es "cero", y el temporizador no cuenta nada, o llega una "unidad" durante mucho tiempo, y el temporizador ya ha contado todo. Para descargar la CPU inactiva de la segunda etapa (el temporizador ya ha contado), es necesario verificar en la etapa "la entrada contin√∫a recibiendo la verdad", si el temporizador ya ha contado todo el tiempo y ha configurado la salida como verdadera. En este caso, no se deben realizar c√°lculos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para realizar estos cambios, es necesario transferir la salida del temporizador Q desde el √°rea de SALIDA al √°rea de IN_OUT, y el valor de salida se almacenar√° en variables externas (en este ejemplo, en una matriz de estructuras). Despu√©s del refinamiento, el c√≥digo de funci√≥n completo, incluida la declaraci√≥n, es el siguiente:</font></font><br>
<br>
<pre><code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword">FUNCTION</span> "<span class="hljs-title">PerversionTON</span>" :</span> Void
<span class="hljs-comment">{ S7_Optimized_Access := 'TRUE' }</span>
VERSION : <span class="hljs-number">0.1</span><font></font>
   VAR_INPUT <font></font>
      <span class="hljs-keyword">IN</span> : Bool;   <span class="hljs-comment">//  </span>
      PT : Real;   <span class="hljs-comment">//    </span><font></font>
   END_VAR<font></font>
<font></font>
   VAR_IN_OUT <font></font>
      Q : Bool;   <span class="hljs-comment">//  </span><font></font>
      INPrv : Bool;<font></font>
      MEM : LReal;<font></font>
      TimeACC : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
   VAR_TEMP <font></font>
      udiCycle : UDInt;<font></font>
      udiPT : UDInt;<font></font>
   END_VAR<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">BEGIN</span>
	<span class="hljs-keyword">IF</span> (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> (<span class="hljs-keyword">NOT</span> #INPrv)) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//         </span>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	    #Q := FALSE;<font></font>
	    #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">// " "  </span>
	ELSIF (#<span class="hljs-keyword">IN</span> <span class="hljs-keyword">AND</span> #INPrv) <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//     ""</span>
	    <span class="hljs-keyword">IF</span> (<span class="hljs-keyword">NOT</span> #Q) <span class="hljs-keyword">THEN</span>
	        #udiCycle := LREAL_TO_UDINT(RUNTIME(#MEM) * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//     </span>
	        #udiPT := REAL_TO_UDINT(#PT * <span class="hljs-number">1000000</span>); <span class="hljs-comment">//   </span>
	        #TimeACC += #udiCycle; <span class="hljs-comment">//     "    "</span>
	        <span class="hljs-keyword">IF</span> #TimeACC &gt;= #udiPT <span class="hljs-keyword">THEN</span> <span class="hljs-comment">//      </span>
	            #Q := TRUE; <span class="hljs-comment">//  ""</span>
	            #TimeACC := #udiPT; <span class="hljs-comment">//  </span><font></font>
	        END_IF;<font></font>
	    END_IF;<font></font>
	<span class="hljs-keyword">ELSE</span> <span class="hljs-comment">//    -      </span><font></font>
	    #Q := FALSE;<font></font>
	    #TimeACC := <span class="hljs-number">0</span>;<font></font>
	END_IF;<font></font>
	<font></font>
	#INPrv := #<span class="hljs-keyword">IN</span>; <span class="hljs-comment">//  </span><font></font>
	<font></font>
	ENO := #Q; <span class="hljs-comment">// ENO         LAD  FBD</span><font></font>
END_FUNCTION<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despu√©s de eso, el tiempo de ejecuci√≥n mejora: el tiempo de inactividad del procesamiento de los temporizadores es de 23 ms, con un tiempo de filtrado de trabajo de 37-40 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c√≥digo de funci√≥n no verifica un valor no v√°lido de la configuraci√≥n del temporizador: un valor negativo (cuando el material se convierte en un entero sin signo, la configuraci√≥n se distorsionar√°) o un valor mayor de 4294.9 segundos (la configuraci√≥n de tiempo se desbordar√° y distorsionar√°). Debe controlar el valor del valor de PT en el c√≥digo, o confiar la tarea de verificar el rango del ajuste de tiempo (de 0 a 4294.9 segundos) al sistema de operador de nivel superior. La verificaci√≥n del rango mediante el programa PLC aumenta el tiempo de procesamiento a aproximadamente 45-46 ms (y, en general, la forma m√°s correcta es establecer el tiempo del temporizador no en formato REAL, sino en formato UDINT en milisegundos y sin sentido).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El proyecto de aplicaci√≥n con un temporizador para el entorno TIA Portal Step 7 versi√≥n 16 est√° disponible </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491188/index.html">Lo que debe saber el probador de backend</a></li>
<li><a href="../es491190/index.html">Creaci√≥n de una tienda en l√≠nea en Nuxt.js 2 Tutorial Parte 3</a></li>
<li><a href="../es491192/index.html">Figmiro Hacer un complemento para Figma (y un poco para Miro)</a></li>
<li><a href="../es491194/index.html">Gen√©tica de origen. Composici√≥n de la poblaci√≥n</a></li>
<li><a href="../es491198/index.html">Seis consejos para hacer el tutorial del juego correcto</a></li>
<li><a href="../es491202/index.html">Ingenieros vs. Dise√±adores</a></li>
<li><a href="../es491208/index.html">7 h√°bitos que convertir√°n a cualquier introvertido en un maestro de la comunicaci√≥n</a></li>
<li><a href="../es491210/index.html">Mini-serie de videos con animaci√≥n de personajes sobre el juego de intimidaci√≥n Monster Hustle</a></li>
<li><a href="../es491212/index.html">Aceite y vodka: ¬øc√≥mo nos deshacemos de las pegatinas de las computadoras port√°tiles?</a></li>
<li><a href="../es491214/index.html">9 estrategias para comercializar juegos m√≥viles</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>