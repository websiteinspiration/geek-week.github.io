<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📣 🍊 🧚🏼 为ESP32上的嵌入式设备编程游戏：驱动器，电池，声音 ⚰️ 🎖️ 🦒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="开始：组装系统，输入，显示。
 
 第4部分：驱动器
 Odroid Go有一个microSD卡插槽，这对于下载资源（精灵，声音文件，字体），甚至可能保存游戏状态很有用。
 
 读卡器通过SPI连接，但是IDF通过抽象化SPI调用并使用标准POSIX函数（例如fopen，fread和fwrite），...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>为ESP32上的嵌入式设备编程游戏：驱动器，电池，声音</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503876/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg" alt="图片"></div><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始：组装系统，输入，显示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第4部分：驱动器</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go有一个microSD卡插槽，这对于下载资源（精灵，声音文件，字体），甚至可能保存游戏状态很有用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读卡器通过SPI连接，但是IDF通过抽象化SPI调用并使用标准</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数（</font><font style="vertical-align: inherit;">例如</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fopen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fwrite）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">使与SD卡的交互变得容易</font><font style="vertical-align: inherit;">。所有这些都是基于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FatFs</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">库的</font><font style="vertical-align: inherit;">，因此SD卡必须以标准FAT格式格式化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它与LCD连接到相同的SPI总线，但是使用不同的芯片选择线。</font><font style="vertical-align: inherit;">当我们需要读写SD卡时（这种情况很少发生），SPI驱动程序会将CS信号从显示器切换到SD卡读卡器，然后执行操作。</font><font style="vertical-align: inherit;">这意味着在将数据发送到显示器时，我们无法使用SD卡执行任何操作，反之亦然。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目前，我们在一个线程中完成所有操作，并且正在使用通过SPI阻止到显示器的传输，因此SD卡和LCD显示器不能同时进行事务处理。</font><font style="vertical-align: inherit;">无论如何，我们很有可能在启动时加载所有资源。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">修改ESP-IDF</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果在显示初始化后尝试初始化SD卡的接口，则会遇到无法加载Odroid Go的问题。</font><font style="vertical-align: inherit;">与SD卡一起使用时，ESP-IDF v4.0不支持对SPI总线的共享访问。</font><font style="vertical-align: inherit;">最近，开发人员添加了此功能，但尚未稳定发布，因此我们将自己对IDF进行少量修改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
注释掉303 </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp-idf /components/driver/sdspi_host.c行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Initialize SPI bus</span>
<span class="hljs-keyword">esp_err_t</span> ret = spi_bus_initialize((<span class="hljs-keyword">spi_host_device_t</span>)slot, &amp;buscfg,<font></font>
    slot_config-&gt;dma_channel);<font></font>
<span class="hljs-keyword">if</span> (ret != ESP_OK) {<font></font>
    ESP_LOGD(TAG, <span class="hljs-string">"spi_bus_initialize failed with rc=0x%x"</span>, ret);
    <span class="hljs-comment">//return ret;</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
进行更改后，我们仍然会在初始化期间看到一个错误，但是它不会再导致ESP32重新启动，因为错误代码不会在上面传播。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/57f/4f8/b0f/57f4f8b0fcca66e243637eeb68b39ff7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/554/eae/9ec/554eae9ec4a3e850eb44e817e8b7b181.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要告诉IDF哪些ESP32引脚连接到MicroSD读取器，以便它正确配置底层SPI驱动程序，该驱动程序实际上与读取器进行通信。</font><strong><font style="vertical-align: inherit;">图</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
中再次使用了一般性注释</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但我们可以通过它们了解ESP32上的实际联系电话。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化类似于LCD的初始化，但是我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdspi_slot_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替了常规的SPI配置结构，该结构</font><font style="vertical-align: inherit;">是为通过SPI总线连接的SD卡设计的。我们在FatFS系统中配置相应的联系电话和卡安装属性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF文档不建议使用</font><strong><font style="vertical-align: inherit;">esp_vfs_fat_sdmmc_mount</font></strong><font style="vertical-align: inherit;">函数</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在完成程序的代码中。这是一个包装函数，可以为我们执行很多操作，但是到目前为止，它运行正常，并且将来可能不会有任何变化。</font><font style="vertical-align: inherit;">此功能</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ / sdcard”</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参数</font><font style="vertical-align: inherit;">设置SD卡的虚拟安装点，然后在处理文件时将其用作前缀。如果我们的SD卡上有一个名为“ test.txt”的文件，则用于链接到该文件的路径将是“ /sdcard/test.txt”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在初始化SD卡的接口之后，与文件的交互就变得微不足道了：我们可以简单地使用对</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POSIX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数的标准调用</font><font style="vertical-align: inherit;">，这非常方便。</font></font><br>
<br>
<blockquote>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">   8.3</a>,              .    ,   <b>fopen</b>   .        <b>make menuconfig</b>,       ,     <b>8.3</b>.</blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d94/62f/94a/d9462f94aeec7fbdce989e34967e637d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aseprite</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（糟糕）中</font><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">了一个64x64的精灵，它仅使用两种颜色：全黑（禁用像素）和全白（启用像素）。 Aseprite没有选择保存RGB565颜色或导出为原始位图的选项（即没有压缩和图像标题），因此我将Sprite导出为临时PNG格式。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageMagick，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数据转换为PPM文件，该文件将图像转换为带有简单标头的原始未压缩数据。接下来，我在十六进制编辑器中打开图像，删除标题并将24位颜色转换为16位，删除所有出现的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x000000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以及所有出现的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">此处的字节顺序不成问题，因为</font><font style="vertical-align: inherit;">更改字节顺序时</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x0000</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0xFFFF</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原始文件可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">FILE* spriteFile = fopen(<span class="hljs-string">"/sdcard/key"</span>, <span class="hljs-string">"r"</span>);<font></font>
assert(spriteFile);<font></font>
<font></font>
<span class="hljs-keyword">uint16_t</span>* sprite = (<span class="hljs-keyword">uint16_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">64</span> * <span class="hljs-number">64</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>));<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i)<font></font>
{<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; ++j)<font></font>
	{<font></font>
		fread(sprite, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint16_t</span>), <span class="hljs-number">64</span> * <span class="hljs-number">64</span>, spriteFile);<font></font>
	}<font></font>
}<font></font>
<font></font>
fclose(spriteFile);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们打开</font><font style="vertical-align: inherit;">包含原始字节</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">密钥</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件</font><font style="vertical-align: inherit;">，并将其读入缓冲区。</font><font style="vertical-align: inherit;">将来，我们将以不同的方式加载Sprite资源，但是对于演示来说，这已经足够了。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> spriteRow = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">64</span>; ++row)<font></font>
{<font></font>
	spriteCol = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">64</span>; ++col)<font></font>
	{<font></font>
		<span class="hljs-keyword">uint16_t</span> pixelColor = sprite[<span class="hljs-number">64</span> * spriteRow + spriteCol];<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (pixelColor != <span class="hljs-number">0</span>)<font></font>
		{<font></font>
			gFramebuffer[row * LCD_WIDTH + col] = color;<font></font>
		}<font></font>
<font></font>
		++spriteCol;<font></font>
	}<font></font>
<font></font>
	++spriteRow;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了绘制一个精灵，我们迭代遍历它的内容。</font><font style="vertical-align: inherit;">如果像素是白色，则我们将其绘制为按钮选择的颜色。</font><font style="vertical-align: inherit;">如果是黑色，则认为它是背景并且不绘制。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_4/media/sprite_drawing.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我手机的相机颜色严重失真。</font><font style="vertical-align: inherit;">很抱歉摇了她。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要测试图像的记录，我们将键移至屏幕上的某个位置，更改其颜色，然后将帧缓冲区写入SD卡，以便可以在计算机上对其进行查看。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (input.menu)<font></font>
{<font></font>
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* snapFilename = <span class="hljs-string">"/sdcard/framebuf"</span>;<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Writing snapshot to %s"</span>, snapFilename);<font></font>
<font></font>
	FILE* snapFile = fopen(snapFilename, <span class="hljs-string">"wb"</span>);<font></font>
	assert(snapFile);<font></font>
<font></font>
		fwrite(gFramebuffer, <span class="hljs-keyword">sizeof</span>(gFramebuffer[<span class="hljs-number">0</span>]), LCD_WIDTH * LCD_HEIGHT, snapFile);<font></font>
	}<font></font>
<font></font>
	fclose(snapFile);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按菜单键会将帧缓冲区的内容保存到一个名为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">framebuf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的文件中</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这将是原始帧缓冲区，因此像素将仍然保持RGB565格式，并且字节顺序相反。</font><font style="vertical-align: inherit;">我们可以再次使用ImageMagick将这种格式转换为PNG以在计算机上查看。</font></font><br>
<br>
<pre><code class="cpp hljs">convert -depth <span class="hljs-number">16</span> -size <span class="hljs-number">320</span>x240+<span class="hljs-number">0</span> -endian msb rgb565:FRAMEBUF snap.png</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，我们可以实现对BMP / PNG格式的读取/写入，并通过ImageMagick消除所有这些麻烦，但这只是一个演示代码。</font><font style="vertical-align: inherit;">到目前为止，我还没有决定我要使用哪种文件格式来存储精灵。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bd/09c/e66/0bd09ce669a61276676a87b01c15e6f2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他在这里！</font><font style="vertical-align: inherit;">Odroid Go帧缓冲区显示在台式计算机上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid走示意图</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：SDMMC</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第5部分：电池</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go具有锂离子电池，因此我们可以创建一款您可以随时随地玩的游戏。</font><font style="vertical-align: inherit;">对于小时候玩过第一个Gameboy的人来说，这是一个诱人的想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们需要一种方法来请求Odroid Go的电池电量。</font><font style="vertical-align: inherit;">电池连接到ESP32上的触点，因此我们可以读取电压以大致了解剩余工作时间。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方案</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f2/ceb/13b/1f2ceb13bf408d8773f22047464e4e66.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该图显示了</font><font style="vertical-align: inherit;">通过电阻拉到地后，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36已</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电压。两个电阻（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R23</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）形成一个分压器，类似于游戏手柄的交叉部分。电阻再次具有相同的电阻，因此电压是原始电压的一半。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于分压器，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将读取等于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBAT</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一半的电压</font><font style="vertical-align: inherit;">。之所以这样做是因为ESP32上的ADC触点无法读取锂离子电池的高电压（最大充电时为4.2 V）。就是说，这意味着要获得真实电压，您需要将从ADC（ADC）读取的电压加倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
读取</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO36</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值时</font><strong><font style="vertical-align: inherit;">，</font></strong><font style="vertical-align: inherit;">我们获得了一个数字值，但丢失了它代表的模拟值。我们需要一种使用物理模拟电压形式的ADC来解释数字值的方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF允许您校准ADC，ADC尝试根据参考电压提供电压电平。</font><font style="vertical-align: inherit;">默认情况下，</font><font style="vertical-align: inherit;">该参考电压（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vref</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）为1100 mV，但由于物理特性，每个设备都略有不同。 Odroid Go中的ESP32有一个手动定义的Vref，在eFuse中“闪烁”，我们可以将其用作更准确的Vref。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
步骤如下：首先，我们将配置ADC校准，并且当我们想要读取电压时，我们将抽取一定数量的样本（例如20个）来计算平均读数。然后我们使用IDF将这些读数转换为电压。计算平均值可消除噪音并获得更准确的读数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，电压和电池电量之间没有线性连接。当电荷减少时，电压下降，当电荷增加时，电压上升，但是以一种无法预测的方式上升。可以这么说：如果电压低于约3.6 V，则电池会放电，但出乎意料的是，要准确地将电压电平转换为电池电量的百分比，会非常困难。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于我们的项目，这并不是特别重要。</font><font style="vertical-align: inherit;">我们可以实施一个粗略的近似值，以使玩家知道需要为设备快速充电的方法，但是我们不会受苦于尝试获得确切的百分比。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态指示灯</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b52/0ad/2d6/b520ad2d63e2a4c59924debb6c3613bc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Odroid Go屏幕下方的前面板上，有一个蓝色LED（LED），我们可以将其用于任何目的。您可以向他们显示设备已打开并且可以正常工作，但是在这种情况下，在黑暗中播放时，明亮的蓝色LED会在您的脸上发光。因此，我们将用它来指示电池电量低（尽管我更喜欢红色或琥珀色）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用LED，您需要将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">设置</font><font style="vertical-align: inherit;">为输出，然后向其施加高电平或低电平信号以打开和关闭LED。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为一个2kΩ的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电阻</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><strong><font style="vertical-align: inherit;">限流电阻</font></strong><font style="vertical-align: inherit;">）就足够了，这样我们就不会烧毁LED并从GPIO引脚提供太多电流。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LED具有相当低的电阻，因此如果对其施加3.3 V电压，则我们将通过改变电流来对其进行燃烧。</font><font style="vertical-align: inherit;">为了防止这种情况，通常在LED上串联一个电阻。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，LED的限流电阻通常小于2kΩ，因此我不理解为什么</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R7</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电阻</font><font style="vertical-align: inherit;">是这样的电阻。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> BATTERY_READ_PIN = ADC1_GPIO36_CHANNEL;
<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BATTERY_LED_PIN = GPIO_NUM_2;<font></font>
<font></font>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">esp_adc_cal_characteristics_t</span> gCharacteristics;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeBatteryReader</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-comment">// Configure LED</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; BATTERY_LED_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure ADC</span><font></font>
	{<font></font>
		adc1_config_width(ADC_WIDTH_BIT_12);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
    	adc1_config_channel_atten(BATTERY_READ_PIN, ADC_ATTEN_DB_11);<font></font>
<font></font>
    	<span class="hljs-keyword">esp_adc_cal_value_t</span> type = esp_adc_cal_characterize(<font></font>
    		ADC_UNIT_1, ADC_ATTEN_DB_11, ADC_WIDTH_BIT_12, <span class="hljs-number">1100</span>, &amp;gCharacteristics);<font></font>
<font></font>
    	assert(type == ESP_ADC_CAL_VAL_EFUSE_VREF);<font></font>
    }<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Battery reader initialized"</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将GPIO LED设置为输出，以便在必要时可以对其进行切换。</font><font style="vertical-align: inherit;">然后，我们配置ADC引脚，就像在交叉情况下一样-位宽为12，衰减最小。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_characterize</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为我们执行计算以表征ADC的特性，以便以后可以将数字读数转换为物理应力。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电池读取</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">Odroid_ReadBatteryLevel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SAMPLE_COUNT = <span class="hljs-number">20</span>;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> raw = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> sampleIndex = <span class="hljs-number">0</span>; sampleIndex &lt; SAMPLE_COUNT; ++sampleIndex)<font></font>
	{<font></font>
		raw += adc1_get_raw(BATTERY_READ_PIN);<font></font>
	}<font></font>
<font></font>
	raw /= SAMPLE_COUNT;<font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">uint32_t</span> voltage = <span class="hljs-number">2</span> * esp_adc_cal_raw_to_voltage(raw, &amp;gCharacteristics);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> voltage;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从ADC的触点中获取20个原始ADC样本，然后将它们除以得到平均值。如上所述，这有助于减少读数的噪音。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，我们使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_adc_cal_raw_to_voltage</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将原始值转换为实际电压。由于上述分压器，我们将返回值加倍：读取值将为实际电池电压的一半。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们不会想办法将电压转换为电池电量的百分比，而是返回一个简单的电压。让调用函数自己决定如何处理电压-是将其转换为电荷的百分比，还是简单地将其解释为高值或低值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该值以毫伏为单位返回，因此调用函数需要执行适当的转换。</font><font style="vertical-align: inherit;">这样可以防止浮子溢出。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LED设定</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_EnableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">1</span>);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DisableBatteryLight</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	gpio_set_level(BATTERY_LED_PIN, <span class="hljs-number">0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这两个简单的功能足以使用LED。</font><font style="vertical-align: inherit;">我们可以打开或关闭灯。</font><font style="vertical-align: inherit;">让调用函数决定何时执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以创建一个任务，该任务将定期监视电池电压并相应地切换LED的状态，但是我最好在主循环中询问电池电压，然后决定如何从那里设置电池电压。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示版</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">uint32_t</span> batteryLevel = Odroid_ReadBatteryLevel();<font></font>
<font></font>
<span class="hljs-keyword">if</span> (batteryLevel &lt; <span class="hljs-number">3600</span>)<font></font>
{<font></font>
	Odroid_EnableBatteryLight();<font></font>
}<font></font>
<span class="hljs-keyword">else</span><font></font>
{<font></font>
	Odroid_DisableBatteryLight();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以简单地在主循环中请求电池电量，如果电压低于阈值，则打开LED，表明需要充电。</font><font style="vertical-align: inherit;">根据研究的材料，我可以说3600 mV（3.6 V）是锂离子电池电量低的一个好兆头，但是电池本身很复杂。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid走示意图</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电池特性</font></font></a></li>
</ul><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第六部分：声音</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
获得与所有Odroid Go硬件的完整接口的最后一步是编写声音层。完成此操作后，我们可以开始着手于游戏的更通用编程，而与Odroid编程无关。与外围设备的所有交互将通过</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">功能执行</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我缺乏声音编程方面的经验，并且IDF缺乏好的文档，因此在进行项目工作时，声音的实现花费了最多的时间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最终，播放声音不需要太多代码。大部分时间都花在了如何将音频数据转换为所需的ESP32以及如何配置ESP32音频驱动程序以匹配硬件配置上。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字声音基础</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数字声音包括两个部分：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">录制</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">播放</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记录</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了在计算机上记录声音，我们首先需要将其从连续（模拟）信号的空间转换为离散（数字）信号的空间。</font><font style="vertical-align: inherit;">使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模数转换器（ADC）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（在第2部分中讨论叉号时已经讨论过</font><strong><font style="vertical-align: inherit;">）来</font></strong><font style="vertical-align: inherit;">完成此任务</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ADC接收</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">输入波</font><font style="vertical-align: inherit;">的</font><strong><font style="vertical-align: inherit;">样本</font></strong><font style="vertical-align: inherit;">并将其数字化，然后将其保存到文件中。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">玩</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数模转换器（DAC）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将数字声音文件从数字空间返回到模拟空间</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">DAC只能在一定范围内重现值。</font><font style="vertical-align: inherit;">例如，具有3.3 V电源的8位DAC可以以12.9 mV的步长（3.3 V除以256）输出0至3.3 mV范围内的模拟电压。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DAC提取数字值并将其转换回电压，然后可以将其传输到放大器，扬声器或任何其他能够接收模拟音频信号的设备。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样率</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过ADC记录模拟声音时，将以特定频率进行采样，并且每个采样都是声音信号在某个时间点的“快照”。此参数称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样频率</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赫兹为单位</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
采样频率越高，我们越能准确地再现原始信号的频率。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">奈奎斯特-香农（Kotelnikov）定理</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指出（简单而言），采样频率应该是我们要记录的最高信号频率的两倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人耳可以听到的声音范围大约</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为20 Hz至20 kHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此</font><strong><font style="vertical-align: inherit;">44.1 kHz</font></strong><font style="vertical-align: inherit;">的采样频率最常用于再现高质量音乐</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是人耳可以识别的最大频率的两倍多。这样可以确保重新创建完整的乐器频率和声音集。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，每个样本都占用文件中的空间，因此我们无法选择最大采样率。但是，如果采样速度不够快，则可能会丢失重要信息。选择的采样频率应取决于再现的声音中存在的频率。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">播放应与音源以相同的采样频率进行，否则声音及其持续时间将有所不同。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设以16 kHz的采样频率记录了十秒钟的声音。</font><font style="vertical-align: inherit;">如果以8 kHz的频率播放，则其音调会降低，持续时间将为20秒。</font><font style="vertical-align: inherit;">如果以32 kHz的采样频率播放，则可听到的声音会更高，声音本身会持续五秒钟。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该视频通过示例显示了采样率的差异。</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位深</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
采样频率仅为等式的一半。声音还具有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位深度</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即每个样本的位数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当ADC捕获音频信号的样本时，它必须将此模拟值转换为数字值，并且捕获值的范围取决于所使用的位数。 8位（256个值），16位（65,526个值），32位（4,294,967,296个值）等</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每个样本的位数与</font><font style="vertical-align: inherit;">声音</font><font style="vertical-align: inherit;">的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">动态范围有关</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即声音最大，最安静的部分。音乐最常见的位深度是16位。</font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在播放过程中，必须提供与信号源相同的位深度，否则声音及其持续时间会改变。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，您有一个音频文件，其中四个样本存储为8位：[0x25、0xAB，0x34、0x80]。</font><font style="vertical-align: inherit;">如果尝试将它们当作16位来播放，则只会得到两个样本：[0x25AB，0x3480]。</font><font style="vertical-align: inherit;">这不仅会导致声音样本的值不正确，还会使样本数量减半，从而使声音的持续时间减半。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
了解样本的格式也很重要。</font><font style="vertical-align: inherit;">8位无符号，8位无符号，16位无符号，16位无符号等 </font><font style="vertical-align: inherit;">通常8位是无符号的，而16位是有符号的。</font><font style="vertical-align: inherit;">如果感到困惑，声音会大大失真。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该视频通过示例显示了位深度差异。</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAV文件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，计算机上的原始音频数据</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以WAV格式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储，</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">该格式</font></a><font style="vertical-align: inherit;">具有描述声音格式（采样频率，位深，大小等）的简单标头，然后是音频数据本身。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
声音根本没有被压缩（与MP3等格式不同），因此我们可以轻松地播放它而无需编解码器库。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
WAV文件的主要问题是由于缺少压缩，因此它们可能很大。文件大小与持续时间，采样率和位深度直接相关。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大小=持续时间（以秒为单位）x采样率（样本/ s）x位深度（位/样本）</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
采样频率对文件大小的影响最大，因此节省空间的最简单方法是选择一个足够低的值。</font><font style="vertical-align: inherit;">我们将创建一种老式的声音，因此低采样频率适合我们。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32具有外围设备，因此提供与音频设备的接口相对简单：</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IC间声音（I2S）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I2S协议非常简单，仅包含三个信号：时钟信号，通道选择（左或右）以及数据线本身。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
时钟频率取决于采样频率，位深和通道数。节拍被替换为数据的每一位，因此，为了正确再现声音，必须相应地设置时钟频率。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时钟频率=采样频率（样本/秒）x位深度（比特/样本）x通道数</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP32微控制器的I2S驱动器有两种可能的模式：它可以将数据输出到与外部I2S接收器相连的触点，后者可以对协议进行解码并将数据传输到放大器，或者可以将数据传输到内部ESP32 DAC，从而输出可以传输到的模拟信号。放大器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go板上没有任何I2S解码器，因此我们必须使用内部8位ESP32 DAC，也就是说，我们必须使用8位声音。</font><font style="vertical-align: inherit;">该器件具有两个DAC，一个连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">另一个连接</font><font style="vertical-align: inherit;">到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该过程如下所示：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将音频数据传输到I2S驱动程序</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I2S驱动程序将音频数据发送到8位内部DAC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部DAC输出模拟信号</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模拟信号被传输到声音放大器</font></font></li>
<li>      </li>
<li>  </li>
</ol><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d9/d93/a8e/2d9d93a8ed6eceb35846c0f31e336ec9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们看一下</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go电路</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中的音频</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">电路</font></a><font style="vertical-align: inherit;">，将会看到两个GPIO引脚（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）连接到声音放大器（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAM8304A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的输入</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
也连接到</font><font style="vertical-align: inherit;">放大器</font><font style="vertical-align: inherit;">的信号</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD，</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">即打开或关闭放大器的触点（低信号表示关闭）。放大器的输出连接到一个扬声器（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请记住，</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是8位ESP32 DAC的输出，即，一个DAC连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，另一个DAC连接</font><font style="vertical-align: inherit;">到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声音放大器的</font><strong><font style="vertical-align: inherit;">差分输入</font></strong><font style="vertical-align: inherit;">。差分输入用于减少</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">电磁干扰</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引起的噪声</font><font style="vertical-align: inherit;">。一个信号中存在的任何噪声也将在另一信号中存在。一个信号从另一个信号中减去，从而消除了噪声。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您查看</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">声音放大器</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">规格</font></a><font style="vertical-align: inherit;">，则它具有</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">典型应用电路</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这是制造商推荐的使用放大器的方法。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/044/d2a/323/044d2a323366c5ddb3c3b87f918bf5f9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他建议将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接地，将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到输入信号，将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接到开/关信号。如果有0.005 V的噪声，然后用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN- </font></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0V + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将被读取</font><font style="vertical-align: inherit;">，并用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN + 0.005V</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。输入信号必须彼此相减并获得真实信号值（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）且无噪声。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，Odroid Go的设计人员没有使用推荐的配置。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次查看Odroid Go电路，我们看到设计人员将DAC输出连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并且相同的DAC输出连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ SD</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一个低电平有效的关断信号，因此要使放大器工作，您需要设置一个高信号。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这意味着要使用放大器，我们不能将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用作DAC，而必须用作始终具有高信号的GPIO输出。但是，在这种情况下，高信号设置为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这在放大器的规格中不建议这样做（必须接地）。然后，我们必须使用连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的DAC </font><font style="vertical-align: inherit;">，因为我们的I2S输出必须馈入</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN +</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。这意味着我们将无法实现必要的降噪效果，因为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IN-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有接地。扬声器不断发出柔和的声音。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要确保I2S驱动程序的正确配置，因为我们只想使用连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO26</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的DAC </font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果我们使用连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的DAC </font><font style="vertical-align: inherit;">，它将不断关闭放大器的信号，并且声音会很糟糕。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了这种怪异之外，当使用8位内部DAC时，ESP32中的I2S驱动器需要向其发送16位样本，但仅将高字节发送到8位DAC。</font><font style="vertical-align: inherit;">因此，我们需要获取8位声音并将其粘贴到两倍大的缓冲区中，而缓冲区将为一半。</font><font style="vertical-align: inherit;">然后，将其传递给I2S驱动器，并将每个采样的高字节传递给DAC。</font><font style="vertical-align: inherit;">不幸的是，这意味着我们必须“支付” 16位，但是我们只能使用8位。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多任务</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，游戏无法像我最初想要的那样在一个内核上运行，因为I2S驱动程序似乎存在错误。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I2S驱动程序必须使用DMA（类似于SPI驱动程序），也就是说，我们可以只启动I2S的传输，然后在I2S驱动程序正在传输音频数据时继续我们的工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，相反，CPU在声音持续时间内一直处于阻塞状态，这完全不适合游戏。想象一下，您按下跳转按钮，然后在播放跳转声音时，播放器的精灵将其移动暂停100毫秒。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了解决这个问题，我们可以利用ESP32上有两个内核这一事实。</font><font style="vertical-align: inherit;">我们可以在第二个核心中创建一个任务（即线程），该任务将处理声音再现。</font><font style="vertical-align: inherit;">因此，我们可以将指针从游戏的主要任务转移到声音缓冲区，再转移到声音任务，声音任务会启动I2S的传输，并在声音播放期间被阻止。</font><font style="vertical-align: inherit;">但是，第一个内核上的主要任务（带有输入处理和渲染）将继续执行而不会阻塞。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初始化</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
知道了这一点，我们就可以正确地启动I2S驱动程序。</font><font style="vertical-align: inherit;">为此，您只需要几行代码，但是困难在于找出需要设置哪些参数才能正确再现声音。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> AUDIO_AMP_SD_PIN = GPIO_NUM_25;<font></font>
<font></font>
<span class="hljs-keyword">static</span> QueueHandle_t gQueue;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayTask</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span>
</span>{
	<span class="hljs-keyword">for</span>(;;)<font></font>
	{<font></font>
		QueueData data;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (xQueueReceive(gQueue, &amp;data, <span class="hljs-number">10</span>))<font></font>
		{<font></font>
			<span class="hljs-keyword">size_t</span> bytesWritten;<font></font>
			i2s_write(I2S_NUM_0, data.buffer, data.length, &amp;bytesWritten, portMAX_DELAY);<font></font>
			i2s_zero_dma_buffer(I2S_NUM_0);<font></font>
		}<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">1</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_InitializeAudio</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-comment">// Configure the amplifier shutdown signal</span><font></font>
	{<font></font>
		<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
		gpioConfig.mode = GPIO_MODE_OUTPUT;<font></font>
		gpioConfig.pin_bit_mask = <span class="hljs-number">1U</span>LL &lt;&lt; AUDIO_AMP_SD_PIN;<font></font>
<font></font>
		ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));<font></font>
<font></font>
		gpio_set_level(AUDIO_AMP_SD_PIN, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Configure the I2S driver</span><font></font>
	{<font></font>
		<span class="hljs-keyword">i2s_config_t</span> i2sConfig= {};<font></font>
<font></font>
		i2sConfig.mode = I2S_MODE_MASTER | I2S_MODE_TX | I2S_MODE_DAC_BUILT_IN;<font></font>
		i2sConfig.sample_rate = <span class="hljs-number">5012</span>;<font></font>
		i2sConfig.bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT;<font></font>
		i2sConfig.communication_format = I2S_COMM_FORMAT_I2S_MSB;<font></font>
		i2sConfig.channel_format = I2S_CHANNEL_FMT_ONLY_LEFT;<font></font>
		i2sConfig.dma_buf_count = <span class="hljs-number">8</span>;<font></font>
		i2sConfig.dma_buf_len = <span class="hljs-number">64</span>;<font></font>
<font></font>
		ESP_ERROR_CHECK(i2s_driver_install(I2S_NUM_0, &amp;i2sConfig, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>));<font></font>
		ESP_ERROR_CHECK(i2s_set_dac_mode(I2S_DAC_CHANNEL_LEFT_EN));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create task for playing sounds so that our main task isn't blocked</span><font></font>
	{<font></font>
		gQueue = xQueueCreate(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(QueueData));<font></font>
		assert(gQueue);<font></font>
<font></font>
		BaseType_t result = xTaskCreatePinnedToCore(&amp;PlayTask, <span class="hljs-string">"I2S Task"</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">5</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);<font></font>
		assert(result == pdPASS);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，我们将</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO25</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（连接到放大器的关闭信号）配置为输出，以便它可以控制声音放大器，并向其施加高信号以打开放大器。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，我们配置并安装I2S驱动程序本身。</font><font style="vertical-align: inherit;">我将逐行解析配置的每个部分，因为每一行都需要解释：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">模式</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将驱动程序设置为主驱动器（控制总线），将其设置为发送器（因为我们将数据传输到接收者），并将其配置为使用内置的8位DAC（因为Odroid Go板上没有外部DAC）。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">采样率</font></font><ul>
<li>    5012,      ,   ,      .   ,      ,          .    -,           2500 .</li>
</ul></li>
<li>bits_per_sample<ul>
<li>  ,    ESP32  8-,   I2S ,      16    ,   8     .</li>
</ul></li>
<li>communication_format<ul>
<li>      ,   ,   -   ,   8-      16- .</li>
</ul></li>
<li>channel_format<ul>
<li> GPIO,    <strong>IN+</strong>   —  <strong>IO26</strong>,       «»   I2S.  ,  I2S      ,      <strong>IO25</strong>,      ,          .</li>
</ul></li>
<li>dma_buf_count  dma_buf_len<ul>
<li>  DMA-   ( )  ,        ,   ,        IDF.       ,     .</li>
</ul></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们创建一个队列-这是FreeRTOS在任务之间发送数据的方式。我们将数据放在一个任务的队列中，然后从另一任务的队列中提取数据。创建一个名为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的结构</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">该结构</font><font style="vertical-align: inherit;">将指向声音缓冲区的指针和缓冲区的长度组合为一个可以排队的单个结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接下来，创建一个在第二个内核上运行的任务。我们将其连接到</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">，该</font><font style="vertical-align: inherit;">函数</font><font style="vertical-align: inherit;">执行声音播放。任务本身是一个无休止的循环，不断检查队列中是否有任何数据。如果是这样，她会将它们发送给I2S驱动程序，以便可以播放它们。它将阻止</font><strong><font style="vertical-align: inherit;">i2s_write</font></strong><font style="vertical-align: inherit;">调用</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这很适合我们，因为任务是在与游戏主线程不同的内核上执行的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
需要调用</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i2s_zero_dma_buffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，以便在播放完成之后，扬声器不再有声音。</font><font style="vertical-align: inherit;">我不知道这是I2S驱动程序的错误还是预期的行为，但是如果没有它，则在声音缓冲区播放完毕后，扬声器会发出垃圾信号。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">播放声音</font></font></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_PlayAudio</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span>* buffer, <span class="hljs-keyword">size_t</span> length)</span>
</span>{<font></font>
	QueueData data = {};<font></font>
<font></font>
	data.buffer = buffer;<font></font>
	data.length = length;<font></font>
<font></font>
	xQueueSendToBack(gQueue, &amp;data, portMAX_DELAY);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于整个配置已经完成，因此对声音缓冲区播放功能的调用非常简单，因为主要工作是在另一任务中完成的。</font><font style="vertical-align: inherit;">我们将指向缓冲区的指针和缓冲区的长度放入</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QueueData</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结构中</font><font style="vertical-align: inherit;">，然后将其放入</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PlayTask</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数使用的队列中</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于这种操作模式，一个声音缓冲区必须先完成播放，然后才能启动第二个缓冲区。</font><font style="vertical-align: inherit;">因此，如果同时发生跳跃和射击，则第一个声音将在第二个声音之前播放，而不是同时播放。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
很有可能，将来我会将不同的帧声音混合到声音缓冲区中，该声音缓冲区将传输到I2S驱动程序。</font><font style="vertical-align: inherit;">这将允许您同时播放多个声音。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演示版</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jsfxr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">生成自己的声音效果</font><font style="vertical-align: inherit;">，该工具专门设计用于生成所需的游戏声音类型。</font><font style="vertical-align: inherit;">我们可以直接设置采样频率和位深，然后输出WAV文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我创建了一个简单的跳跃声音效果，类似于马里奥的跳跃声音。</font><font style="vertical-align: inherit;">它的采样频率为5012（在初始化时配置），位深度为8（因为DAC为8位）。</font></font><br>
<br>
<div class="oembed"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://austinmorlan.com/posts/embedded_game_programming_6/media/jump.wav</font></font></a></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与其直接在代码中直接解析WAV文件，我们将执行类似于在第4部分的演示中加载Sprite的操作：我们将使用十六进制编辑器从文件中删除WAV标头。因此，从SD卡读取的文件将仅是原始数据。另外，我们不会读取声音的持续时间，而是将其写入代码中。将来，我们将以不同的方式加载声音资源，但这对于演示来说就足够了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原始文件可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Load sound effect</span>
<span class="hljs-keyword">uint16_t</span>* soundBuffer;
<span class="hljs-keyword">int</span> soundEffectLength = <span class="hljs-number">1441</span>;<font></font>
{<font></font>
	FILE* soundFile = fopen(<span class="hljs-string">"/sdcard/jump"</span>, <span class="hljs-string">"r"</span>);<font></font>
	assert(soundFile);<font></font>
<font></font>
	<span class="hljs-keyword">uint8_t</span>* soundEffect = <span class="hljs-built_in">malloc</span>(soundEffectLength);<font></font>
	assert(soundEffect);<font></font>
<font></font>
	soundBuffer = <span class="hljs-built_in">malloc</span>(soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	assert(soundBuffer);<font></font>
<font></font>
	fread(soundEffect, soundEffectLength, <span class="hljs-number">1</span>, soundFile);<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; soundEffectLength; ++i)<font></font>
    {<font></font>
        <span class="hljs-comment">// 16 bits required but only MSB is actually sent to the DAC</span>
        soundBuffer[i] = (soundEffect[i] &lt;&lt; <span class="hljs-number">8u</span>);<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将8位数据加载到8位</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundEffect</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区中</font><font style="vertical-align: inherit;">，然后将此数据复制到16位</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soundBuffer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">缓冲区中</font><font style="vertical-align: inherit;">，数据将存储在高8位中。</font><font style="vertical-align: inherit;">我再说一遍-由于IDF实现的功能，这是必要的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建了16位缓冲区后，我们可以播放单击按钮的声音。</font><font style="vertical-align: inherit;">为此使用音量按钮将是合乎逻辑的。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> lastState = <span class="hljs-number">0</span>;<font></font>
<font></font>
<span class="hljs-keyword">for</span> (;;)<font></font>
{<font></font>
	[...]<font></font>
<font></font>
	<span class="hljs-keyword">int</span> thisState = input.volume;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> ((thisState == <span class="hljs-number">1</span>) &amp;&amp; (thisState != lastState))<font></font>
	{<font></font>
		Odroid_PlayAudio(soundBuffer, soundEffectLength*<span class="hljs-number">2</span>);<font></font>
	}<font></font>
<font></font>
	lastState = thisState;<font></font>
<font></font>
	[...]<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们监视按钮的状态，以便一键按下</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid_PlayAudio</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会被意外</font><strong><font style="vertical-align: inherit;">调用</font></strong><font style="vertical-align: inherit;">多次。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您的浏览器不支持HTML5视频。</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_6/media/demo.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资源</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有源代码都</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid走示意图</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">音频放大器数据表</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：DAC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF文档：I2S</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WAVE文件格式</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频：位深度说明</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频：采样率说明</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503858/index.html">《 Terraform：代码级别的基础架构》一书</a></li>
<li><a href="../zh-CN503860/index.html">设置神经网络环境Mask R-CNN</a></li>
<li><a href="../zh-CN503862/index.html">心理问题是成功创造突破性产品的回报</a></li>
<li><a href="../zh-CN503864/index.html">Flutter的风味组织</a></li>
<li><a href="../zh-CN503866/index.html">发布了2020年路线图开发Zextras Suite</a></li>
<li><a href="../zh-CN503880/index.html">我如何学会不用担心和喜欢机器视觉</a></li>
<li><a href="../zh-CN503884/index.html">如何学习异步工作</a></li>
<li><a href="../zh-CN503888/index.html">AdaBoost算法</a></li>
<li><a href="../zh-CN503890/index.html">我如何在React和React Native Part 1上配置Azure AD B2C的故事（教程）</a></li>
<li><a href="../zh-CN503892/index.html">米塔普：隔离，走开</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>