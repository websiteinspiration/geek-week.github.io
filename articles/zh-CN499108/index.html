<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥔 🙇🏾 🙌🏿 锈。通过迭代器借用检查器 👩🏽‍⚖️ 🧗🏻 🙎🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="哈Ha！
 
 我已经学习了大约一年，在空闲时间，我在书本上写作。我喜欢它的作者如何通过借用的概念解决内存管理问题并免除垃圾收集器的方法。在本文中，我将通过迭代器来实现这个想法。
 
 最近，scala是我的主要语言，因此将与之进行比较，但是其中没有很多比较，而且一切都是直观的，没有魔术:) 
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>锈。通过迭代器借用检查器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">哈Ha！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我已经学习了大约一年，在空闲时间，我在书本上写作。</font><font style="vertical-align: inherit;">我喜欢它的作者如何通过借用的概念解决内存管理问题并免除垃圾收集器的方法。</font><font style="vertical-align: inherit;">在本文中，我将通过迭代器来实现这个想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近，scala是我的主要语言，因此将与之进行比较，但是其中没有很多比较，而且一切都是直观的，没有魔术:) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章是为那些听过生锈但又不做细节的人设计的。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">从这里</font></a><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">从这里</font></a></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
拍摄的照片</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前言</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在jvm语言中，习惯上隐藏带有链接的工作，也就是说，我们几乎总是使用引用数据类型，因此我们决定隐藏“＆”号（＆）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在rasta中，有明确的链接，例如到整数-`＆i32`，可以通过`*`取消引用链接，也可以有指向该链接的链接，然后需要将其取消引用两次**。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编写代码时，通常需要按条件（谓词）过滤集合。</font><font style="vertical-align: inherit;">在岩石中，即使元素也像这样：</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们看一下排序：</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无需深入研究newBuilder的细节，很明显，正在创建一个新的集合，我们对旧集合进行迭代，如果谓词返回true，则添加一个元素。</font><font style="vertical-align: inherit;">尽管该集合是新集合，但实际上它的元素是第一个集合中元素的链接，如果突然之间这些元素是可变的，那么更改它们将是两个集合所共有的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们尝试在rast中执行相同的操作。</font><font style="vertical-align: inherit;">我将立即给出一个工作示例，然后再考虑差异。</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哇，哇？</font><font style="vertical-align: inherit;">双指针解引用？</font><font style="vertical-align: inherit;">只是为了过滤向量？</font><font style="vertical-align: inherit;">困难:(但是有这样做的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们指出一下这段代码与原来的代码有何不同：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在向量上显式获得迭代器（`iter（）`） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在谓词函数中，由于某种原因，我们两次取消了指针的引用 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 调用`collect（）` </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 它也导致引用类型为Vec &lt;＆i32&gt;的向量，而不是普通的整数 </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借阅检查器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么要在集合上显式调用`iter（）`？</font><font style="vertical-align: inherit;">对于任何摇滚乐手来说，很明显，如果调用`.filter（...）`，则需要遍历集合。</font><font style="vertical-align: inherit;">为什么要在一个光栅中显式地写出可以隐式执行的操作？</font><font style="vertical-align: inherit;">因为有</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三个</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不同的迭代器！</font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弄清楚为什么要三个？</font><font style="vertical-align: inherit;">需要触摸</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">借用</font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（借用，借用）</font></font></i> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查器</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'a。</font><font style="vertical-align: inherit;">正是由于这个原因，在没有GC且没有显式内存分配/释放的情况下，光栅也可以正常工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么需要它？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为避免多个指针指向同一存储区的情况，您可以对其进行更改。</font><font style="vertical-align: inherit;">那是比赛条件。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了不多次取消分配相同的内存。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何实现的？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于所有权的概念。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，所有权的概念很简单-只有一个人可以拥有某些东西（甚至是直觉）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有者可能会更改，但他总是一个人。当我们写“ let x：i32 = 25”时，这意味着有一个32位int的内存分配，并且某个`x`拥有它。所有权的概念仅存在于编译器的思想中，即借用检查器中。当所有者（在这种情况下）x离开范围（超出范围）时，将清除其拥有的内存。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是借位检查器不会遗漏的代码：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
“结构X”类似于“案例类X（）”-一种无边界的结构。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我认为，这种行为对每个人来说都是违反直觉的。</font><font style="vertical-align: inherit;">我不知道其他语言无法两次使用相同的``变量''。</font><font style="vertical-align: inherit;">感到这一刻很重要。</font><font style="vertical-align: inherit;">首先根本不是X的引用，它是X的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有者</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">更改所有者后，我们会杀死前一个所有者，借阅检查器将不允许其使用。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么需要创建自己的结构，为什么不使用正整数？</font></font></b>
                        <div class="spoiler_text">    —       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      «»            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回到迭代器。</font><font style="vertical-align: inherit;">其中的“捕获”概念是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">他“吞下”了该系列，并拥有其元素。</font><font style="vertical-align: inherit;">在代码中，这种想法将体现为：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过在coll_1上调用`into_iter（）`，我们将其“变成”一个迭代器，吸收了所有元素，如前面的示例中，“ second`首先吸收”。</font><font style="vertical-align: inherit;">之后，对coll_1的任何调用都会在编译过程中受到借阅检查器的惩罚。</font><font style="vertical-align: inherit;">然后我们使用`collect`函数收集这些元素，创建一个新的向量。</font><font style="vertical-align: inherit;">需要使用`collect`函数来从迭代器中收集集合，为此，您必须明确指定我们要收集的对象的类型。</font><font style="vertical-align: inherit;">因此，coll_2清楚地指示类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的，通常来说，上面的描述对于一种编程语言来说已经足够了，但是每次我们要传输它们时，复制/克隆数据结构都不会非常有效，并且您还需要能够进行一些更改。</font><font style="vertical-align: inherit;">因此，我们去看看指针。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">指针</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们发现，所有者只能是一个。</font><font style="vertical-align: inherit;">但是您可以有任意数量的链接。</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该代码已经有效，因为所有者仍然是一个。仅在编译阶段检查所有所有权逻辑，而不会影响内存分配/移动。此外，您可以看到秒的类型已更改为`＆Y`！也就是说，所有权和链接的语义反映在类型中，这使您可以在编译期间进行检查，例如，是否缺少竞争条件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何在编译时防止竞争状况？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过设置可变链接的数量限制！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
某一时刻的可变链接可以是一个且只有一个（不可变）。也就是说，一个或几个不可变，或一个可变。代码如下：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们来看一下前面相对示例中的更改。首先，我们在结构中添加了一个字段，以便进行某些更改，因为我们需要可变性。其次，mut出现在变量的声明中let mut first = ...，这是编译器关于可变性的标记，例如val和var。第三，所有链接的类型都从“＆X”更改为“＆mut X”（当然看起来很可怕。这没有生命周期……），现在我们可以更改链接存储的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我说我们不能创建几个可变链接，他们说借阅检查器不会给出这个链接，但是我自己创建了两个！是的，但是那里的检查非常棘手，这就是为什么有时编译器发誓有时并不明显的原因。他正在努力确保您的程序能够编译，并且如果绝对没有选项可以满足规则，那么会出错，并且可能不是您正在等待的错误，而是违反了他的最后尝试的，这对于初学者来说是最绝望的，也不是显而易见的： ）例如，尽管您未在任何地方调用任何副本，但系统仍告知您该结构未实现Copy trait。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，由于我们仅使用一个可变链接，因此允许同时存在两个可变链接，也就是说，第二个可变链接可以扔掉，并且什么都不会改变。也'秒'可用于</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高达</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一个“第三”，然后一切都会好的。</font><font style="vertical-align: inherit;">但是，如果您取消注释“ second.x = 33;”，则会发现两个可变链接同时存在，并且您无论如何也不能离开这里-编译时错误。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">迭代器</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们有三种传输类型：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吸收，借用，搬家</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可变链接</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
每种类型都需要有自己的迭代器。</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">吸收原始集合中的对象</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在对象链接上运行</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IterMut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在可变对象引用上运行</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题出现了-什么时候使用。</font><font style="vertical-align: inherit;">没有灵丹妙药-您需要练习，阅读别人的代码，文章。</font><font style="vertical-align: inherit;">我将举一个例子说明这个想法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
假设有一所学校，其中有一个班级，并且班上有学生。</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，我们通过查询数据库来获取小学生的向量。</font><font style="vertical-align: inherit;">接下来，我需要计算班上女生的人数。</font><font style="vertical-align: inherit;">如果我们通过“ into_iter（）”“吞下”向量，则在计数之后，我们将无法再使用此集合来计数男孩：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在线计数男孩的行上会出现错误“移动后在此处使用的值”。</font><font style="vertical-align: inherit;">显而易见，可变的迭代器对我们没有用。</font><font style="vertical-align: inherit;">这就是为什么它只是`iter（）`并使用双重链接的原因：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，为了增加该国潜在的新兵人数，已经需要一个可变的迭代器：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
提出这个想法，我们可以使士兵脱离“家伙”，并展示“吸收”迭代器：</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这个美妙的音符上，也许仅此而已。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后一个问题仍然存在-过滤器中的链接的双重解引用从何而来。</font><font style="vertical-align: inherit;">事实是谓词是一个引用参数的函数（以便不捕获它）：</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谓词是FnMut（大致来说是一个函数），它引用其（自身）项目并返回bool。</font><font style="vertical-align: inherit;">由于我们已经有来自迭代器`.iter（）`的链接，因此第二个出现在过滤器中。</font><font style="vertical-align: inherit;">当被迭代器（`into_iter`）吸收时，对链接的双重取消引用变成了常规链接。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延续性</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我没有写文章的丰富经验，所以我很乐意批评。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果有兴趣，我可以继续。</font><font style="vertical-align: inherit;">主题选项：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 内存释放的方式和时间 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 链接寿命 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 异步编程 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 编写小型Web服务，甚至可以提供api </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">锈书</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于所有权的概念，诸如链接列表之类的基本内容的实现不再是微不足道的。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里有</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几种方法来实现它们。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499092/index.html">参考模型BIAN。它为银行的企业架构提供了哪些新的有用的功能？</a></li>
<li><a href="../zh-CN499096/index.html">漂亮图片中的模糊逻辑。不同隶属函数的响应面</a></li>
<li><a href="../zh-CN499102/index.html">Kubernetes，微服务，CI / CD和Docker的逆行：学习技巧</a></li>
<li><a href="../zh-CN499104/index.html">物联网让您伤痕累累：为什么在冠状病毒时代最受物联网欢迎</a></li>
<li><a href="../zh-CN499106/index.html">进阶HTML</a></li>
<li><a href="../zh-CN499110/index.html">老大哥正在努力为善。数据收集者和程序公司如何参与冠状病毒的斗争</a></li>
<li><a href="../zh-CN499112/index.html">Laravel中的高级资源授权系统。第3部分。读取/写入属性，自己的模型</a></li>
<li><a href="../zh-CN499114/index.html">将联邦通信局编号计划导出到关系数据库</a></li>
<li><a href="../zh-CN499118/index.html">如何制作病毒视频</a></li>
<li><a href="../zh-CN499120/index.html">[书签] CSS：使用缩进和缩进</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>