<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌳 🌭 💸 独自のボクセルエンジンを作成します 👵🏼 👩‍💻 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="注：このプロジェクトの完全なソースコードは、[ source ]から入手できます。
 
 私が取り組んでいるプロジェクトがスチームを使い果たし始めたら、次に進む動機を与える新しい視覚化を追加します。
 
 オリジナルのタスクボットのコンセプト[ハブレへの翻訳 ]のリリース後、私は自分が働いている2次...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>独自のボクセルエンジンを作成します</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474414/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a53/e5f/dea/a53e5fdeab8992f2b647feb66ccf126b.png" alt="画像"></div><br>
<em><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注：</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このプロジェクトの完全なソースコードは、[ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]から</font><font style="vertical-align: inherit;">入手できます</font><font style="vertical-align: inherit;">。</font></font></em><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私が取り組んでいるプロジェクトがスチームを使い果たし始めたら、次に進む動機を与える新しい視覚化を追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オリジナルの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクボットの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンセプト</font><font style="vertical-align: inherit;">[</font><font style="vertical-align: inherit;">ハブレへの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">翻訳</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font><font style="vertical-align: inherit;">のリリース後</font><font style="vertical-align: inherit;">、私は自分が働いている2次元空間に制限されていると感じました。それはボットの緊急行動の可能性を妨げているように思われました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近のOpenGLの学習に失敗した試みは、私の前に精神的な障壁をもたらしましたが、7月の終わりに、私はどういうわけか最終的にそれを突破しました。今日、10月の終わりに、私はすでに概念についてかなりの自信を持っているので、私は自分のシンプルなボクセルエンジンをリリースしました。これは、タスクボットの生活と繁栄のための環境になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
グラフィックを完全に制御する必要があったため、私は自分のエンジンを作成することにしました。その上、自分でテストしたかった。ある意味、私は自転車を発明していましたが、このプロセスが本当に好きでした！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクト全体の最終目標は、エージェントの役割を担うボットが環境を操作して相互作用するエコシステムの完全なシミュレーションでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンはすでにかなり前進しているので、ボットのプログラミングに再び移ります。将来、より高いレベルのタスクに集中するために、エンジン、その機能、実装について投稿することにしました。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンジンコンセプト</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンはC ++で完全にゼロから作成されています（パスの検索など、いくつかの例外があります）。</font><font style="vertical-align: inherit;">SDL2を使用してコンテキストとプロセス入力をレンダリングし、OpenGLを使用して3Dシーンをレンダリングし、DearImguiを使用してシミュレーションを制御します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボクセルを使用することにしたのは、主に多くの利点があるグリッドを操作したかったからです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング用のメッシュを作成することは私にはよく理解されています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">世界のデータストレージ機能はより多様で理解しやすくなっています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はすでに、メッシュに基づいて地形と気候シミュレーションを生成するシステムを作成しました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グリッド内のボットのタスクは、パラメーター化が簡単です。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジンは、ワールドデータシステム、レンダリングシステム、およびいくつかの補助クラス（たとえば、サウンドおよび入力処理用）で構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、機能の現在のリストについて説明するとともに、より複雑なサブシステムについて詳しく説明します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワールドクラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワールドクラスは、ワールド内のすべての情報を格納するための基本クラスとして機能します。</font><font style="vertical-align: inherit;">ブロックデータの生成、読み込み、保存を処理します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブロックのデータは一定サイズ（16 ^ 3）のチャンクに格納され、ワー​​ルドは仮想メモリにロードされたフラグメントのベクトルを格納します。</font><font style="vertical-align: inherit;">大規模な世界では、実際には世界の特定の部分のみを覚えておく必要があるため、このアプローチを選択しました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">World</span>{</span>
<span class="hljs-keyword">public</span>:<font></font>
  World(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> _saveFile){<font></font>
    saveFile = _saveFile;<font></font>
    loadWorld();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Data Storage</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Chunk&gt; chunks;    <span class="hljs-comment">//Loaded Chunks</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; updateModels; <span class="hljs-comment">//Models to be re-meshed</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bufferChunks</span><span class="hljs-params">(View view)</span></span>;<font></font>
<font></font>
  <span class="hljs-comment">//Generation</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate</span><span class="hljs-params">()</span></span>;<font></font>
  Blueprint blueprint;<font></font>
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">evaluateBlueprint</span><span class="hljs-params">(Blueprint &amp;_blueprint)</span></span>;<font></font>
  <font></font>
  <span class="hljs-comment">//File IO Management</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> saveFile;
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">loadWorld</span><span class="hljs-params">()</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">saveWorld</span><span class="hljs-params">()</span></span>;<font></font>
<font></font>
  <span class="hljs-comment">//other...</span>
  <span class="hljs-keyword">int</span> SEED = <span class="hljs-number">100</span>;
  <span class="hljs-keyword">int</span> chunkSize = <span class="hljs-number">16</span>;
  <span class="hljs-keyword">int</span> tickLength = <span class="hljs-number">1</span>;<font></font>
  glm::vec3 dim = glm::vec3(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>);<font></font>
<font></font>
  <span class="hljs-comment">//...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントは、ブロックデータと他のいくつかのメタデータをフラット配列に格納します。</font><font style="vertical-align: inherit;">最初、フラグメントを格納するために独自のスパースオクツリーを実装しましたが、ランダムアクセス時間が長すぎてメッシュを作成できないことがわかりました。</font><font style="vertical-align: inherit;">また、フラットアレイはメモリの観点からは最適ではありませんが、メッシュを非常に迅速に構築してブロックを操作する機能と、検索パスへのアクセスを提供します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chunk</span>{</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">//Position information and size information</span><font></font>
  glm::vec3 pos;<font></font>
  <span class="hljs-keyword">int</span> size;<font></font>
  BiomeType biome;<font></font>
<font></font>
  <span class="hljs-comment">//Data Storage Member</span>
  <span class="hljs-keyword">int</span> data[<span class="hljs-number">16</span>*<span class="hljs-number">16</span>*<span class="hljs-number">16</span>] = {<span class="hljs-number">0</span>};
  <span class="hljs-keyword">bool</span> refreshModel = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  <span class="hljs-comment">//Get the Flat-Array Index</span>
  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIndex</span><span class="hljs-params">(glm::vec3 _p)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPosition</span><span class="hljs-params">(glm::vec3 _p, BlockType _type)</span></span>;
  <span class="hljs-function">BlockType <span class="hljs-title">getPosition</span><span class="hljs-params">(glm::vec3 _p)</span></span>;
  <span class="hljs-function">glm::vec4 <span class="hljs-title">getColorByID</span><span class="hljs-params">(BlockType _type)</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッドの保存と読み込みのフラグメントを実装する場合、フラット配列をスパースオクツリーツリーに変換したり、その逆を行ったりすることで、メモリを節約できます。</font><font style="vertical-align: inherit;">最適化の余地はまだあります！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スパースoctreeの実装はコードに格納されているため、安全に使用できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメントストレージとメモリ処理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントは、現在のカメラ位置のレンダリング距離内にある場合にのみ表示されます。これは、カメラが動くときに、メッシュにフラグメントを動的にロードして構成する必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントは、boostライブラリを使用してシリアル化され、ワー​​ルドデータは単純なテキストファイルとして保存されます。各フラグメントはファイルの1行です。これらはワールドファイルで「順序付け」できるように、特定の順序で生成されます。これは、さらに最適化するために重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大規模なワールドの場合、主なボトルネックは、ワールドファイルの読み取りとフラグメントのロード/書き込みです。理想的には、worldファイルをダウンロードして転送するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この方法では</font></font><code>World::bufferChunks()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想メモリにあるが非表示のフラグメントを削除し、新しいフラグメントをワールドファイルから知的に読み込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インテリジェンスとは、ロードする新しいフラグメントを単純に決定し、保存ファイル内の位置でそれらをソートしてから、シングルパスを実行することを意味します。</font><font style="vertical-align: inherit;">すべてが非常に簡単です。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">World::bufferChunks</span><span class="hljs-params">(View view)</span></span>{
   <span class="hljs-comment">//Load / Reload all Visible Chunks</span><font></font>
   evaluateBlueprint(blueprint);<font></font>
<font></font>
   <span class="hljs-comment">//Chunks that should be loaded</span>
   glm::vec3 a = glm::<span class="hljs-built_in">floor</span>(view.viewPos/glm::vec3(chunkSize))-view.renderDistance;<font></font>
   glm::vec3 b = glm::<span class="hljs-built_in">floor</span>(view.viewPos/glm::vec3(chunkSize))+view.renderDistance;<font></font>
<font></font>
   <span class="hljs-comment">//Can't exceed a certain size</span>
   a = glm::clamp(a, glm::vec3(<span class="hljs-number">0</span>), dim-glm::vec3(<span class="hljs-number">1</span>));<font></font>
   b = glm::clamp(b, glm::vec3(<span class="hljs-number">0</span>), dim-glm::vec3(<span class="hljs-number">1</span>));<font></font>
<font></font>
   <span class="hljs-comment">//Chunks that need to be removed / loaded</span>
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; remove;
   <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::vec3&gt; load;<font></font>
<font></font>
   <span class="hljs-comment">//Construct the Vector of chunks we should load</span>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = a.x; i &lt;= b.x; i ++){
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = a.y; j &lt;= b.y; j ++){
       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = a.z; k &lt;= b.z; k ++){
         <span class="hljs-comment">//Add the vector that we should be loading</span><font></font>
         load.push_back(glm::vec3(i, j, k));<font></font>
       }<font></font>
     }<font></font>
   }<font></font>
<font></font>
   <span class="hljs-comment">//Loop over all existing chunks</span>
   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chunks.size(); i++){
     <span class="hljs-comment">//Check if any of these chunks are outside of the limits</span>
     <span class="hljs-keyword">if</span>(glm::any(glm::lessThan(chunks[i].pos, a)) || glm::any(glm::greaterThan(chunks[i].pos, b))){
       <span class="hljs-comment">//Add the chunk to the erase pile</span><font></font>
       remove.push(i);<font></font>
     }<font></font>
<font></font>
     <span class="hljs-comment">//Don't reload chunks that remain</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; load.size(); j++){
        <span class="hljs-keyword">if</span>(glm::all(glm::equal(load[j], chunks[i].pos))){
            <span class="hljs-comment">//Remove the element from load</span><font></font>
            load.erase(load.begin()+j);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//Flags for the Viewclass to use later</span><font></font>
    updateModels = remove;<font></font>
<font></font>
    <span class="hljs-comment">//Loop over the erase pile, delete the relevant chunks.</span>
    <span class="hljs-keyword">while</span>(!remove.empty()){<font></font>
        chunks.erase(chunks.begin()+remove.top());<font></font>
        remove.pop();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//Check if we want to load any guys</span>
    <span class="hljs-keyword">if</span>(!load.empty()){
        <span class="hljs-comment">//Sort the loading vector, for single file-pass</span>
         <span class="hljs-built_in">std</span>::sort(load.begin(), load.end(),<font></font>
             [](<span class="hljs-keyword">const</span> glm::vec3&amp; a, <span class="hljs-keyword">const</span> glm::vec3&amp; b) {
               <span class="hljs-keyword">if</span>(a.x &gt; b.x) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
               <span class="hljs-keyword">if</span>(a.x &lt; b.x) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
               <span class="hljs-keyword">if</span>(a.y &gt; b.y) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
               <span class="hljs-keyword">if</span>(a.y &lt; b.y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
               <span class="hljs-keyword">if</span>(a.z &gt; b.z) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
               <span class="hljs-keyword">if</span>(a.z &lt; b.z) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
             });<font></font>
<font></font>
        boost::<span class="hljs-function">filesystem::path <span class="hljs-title">data_dir</span><span class="hljs-params">( boost::filesystem::current_path() )</span></span>;<font></font>
        data_dir /= <span class="hljs-string">"save"</span>;<font></font>
        data_dir /= saveFile;<font></font>
        <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">in</span><span class="hljs-params">((data_dir/<span class="hljs-string">"world.region"</span>).<span class="hljs-built_in">string</span>())</span></span>;<font></font>
<font></font>
        Chunk _chunk;<font></font>
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">while</span>(!load.empty()){
            <span class="hljs-comment">//Skip Lines (this is dumb)</span>
            <span class="hljs-keyword">while</span>(n &lt; load.back().x*dim.z*dim.y+load.back().y*dim.z+load.back().z){<font></font>
                in.ignore(<span class="hljs-number">1000000</span>,<span class="hljs-string">'\n'</span>);<font></font>
                n++;<font></font>
            }<font></font>
            <font></font>
            <span class="hljs-comment">//Load the Chunk</span><font></font>
            {<font></font>
            boost::<span class="hljs-function">archive::text_iarchive <span class="hljs-title">ia</span><span class="hljs-params">(in)</span></span>;<font></font>
            ia &gt;&gt; _chunk;<font></font>
            chunks.push_back(_chunk);<font></font>
            load.pop_back();<font></font>
            }<font></font>
        }<font></font>
        in.close();<font></font>
    }<font></font>
}</code></pre><br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="http://weigert.vsos.ethz.ch/wp-content/uploads/2019/10/chunkload.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング距離が短いフラグメントの読み込みの例。</font><font style="vertical-align: inherit;">画面の歪みによるアーティファクトは、ビデオ録画ソフトウェアによって引き起こされます。</font><font style="vertical-align: inherit;">主にメッシュの作成が原因で、顕著な負荷ピークが発生することがあります</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
さらに、ロードされたフラグメントのメッシュをレンダラーが再作成する必要があることを示すフラグを設定しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブループリントクラスとeditBuffer</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
editBufferは、ワールドスペースおよびフラグメントスペースでの編集に関する情報を含む、ソート可能なbufferObjectsコンテナです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//EditBuffer Object Struct</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">bufferObject</span> {</span><font></font>
  glm::vec3 pos;<font></font>
  glm::vec3 cpos;<font></font>
  BlockType type;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">//Edit Buffer!</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;bufferObject&gt; editBuffer;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
世界に変更を加える場合、変更を加えた直後にファイルに書き込む場合、テキストファイル全体を転送してすべての変更を書き込む必要があります。</font><font style="vertical-align: inherit;">これはパフォーマンスの面でひどいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、最初にaddEditBufferメソッドを使用してeditBufferに加える必要のあるすべての変更を書き込みます（これにより、フラグメントスペース内の変更の位置も計算されます）。</font><font style="vertical-align: inherit;">それらをファイルに書き込む前に、変更が属するフラグメントの順序で変更をファイル内の場所で並べ替えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ファイルへの変更の書き込みは、1行のファイル転送、つまり各行（フラグメント）の読み込みで構成され、editBufferで変更が行われ、すべての変更が加えられ、editBufferが空になるまで一時ファイルに書き込まれます。</font><font style="vertical-align: inherit;">これは関数で行われます。</font></font><code>evaluateBlueprint()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十分速いです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">World::evaluateBlueprint</span><span class="hljs-params">(Blueprint &amp;_blueprint)</span></span>{
  <span class="hljs-comment">//Check if the editBuffer isn't empty!</span>
  <span class="hljs-keyword">if</span>(_blueprint.editBuffer.empty()){
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Sort the editBuffer</span>
  <span class="hljs-built_in">std</span>::sort(_blueprint.editBuffer.begin(), _blueprint.editBuffer.end(), <span class="hljs-built_in">std</span>::greater&lt;bufferObject&gt;());<font></font>
<font></font>
  <span class="hljs-comment">//Open the File</span>
  boost::<span class="hljs-function">filesystem::path <span class="hljs-title">data_dir</span><span class="hljs-params">(boost::filesystem::current_path())</span></span>;<font></font>
  data_dir /= <span class="hljs-string">"save"</span>;<font></font>
  data_dir /= saveFile;<font></font>
<font></font>
  <span class="hljs-comment">//Load File and Write File</span>
  <span class="hljs-function"><span class="hljs-built_in">std</span>::ifstream <span class="hljs-title">in</span><span class="hljs-params">((data_dir/<span class="hljs-string">"world.region"</span>).<span class="hljs-built_in">string</span>())</span></span>;
  <span class="hljs-function"><span class="hljs-built_in">std</span>::ofstream <span class="hljs-title">out</span><span class="hljs-params">((data_dir/<span class="hljs-string">"world.region.temp"</span>).<span class="hljs-built_in">string</span>(), <span class="hljs-built_in">std</span>::ofstream::app)</span></span>;<font></font>
<font></font>
  <span class="hljs-comment">//Chunk for Saving Data</span><font></font>
  Chunk _chunk;<font></font>
  <span class="hljs-keyword">int</span> n_chunks = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">//Loop over the Guy</span>
  <span class="hljs-keyword">while</span>(n_chunks &lt; dim.x*dim.y*dim.z){
    <span class="hljs-keyword">if</span>(in.eof()){
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//Archive Serializers</span>
    boost::<span class="hljs-function">archive::text_oarchive <span class="hljs-title">oa</span><span class="hljs-params">(out)</span></span>;<font></font>
    boost::<span class="hljs-function">archive::text_iarchive <span class="hljs-title">ia</span><span class="hljs-params">(in)</span></span>;<font></font>
<font></font>
    <span class="hljs-comment">//Load the Chunk</span><font></font>
    ia &gt;&gt; _chunk;<font></font>
<font></font>
    <span class="hljs-comment">//Overwrite relevant portions</span>
    <span class="hljs-keyword">while</span>(!_blueprint.editBuffer.empty() &amp;&amp; glm::all(glm::equal(_chunk.pos, _blueprint.editBuffer.back().cpos))){
      <span class="hljs-comment">//Change the Guy</span><font></font>
      _chunk.setPosition(glm::mod(_blueprint.editBuffer.back().pos, glm::vec3(chunkSize)), _blueprint.editBuffer.back().type);<font></font>
      _blueprint.editBuffer.pop_back();<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//Write the chunk back</span><font></font>
    oa &lt;&lt; _chunk;<font></font>
    n_chunks++;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">//Close the fstream and ifstream</span><font></font>
  in.close();<font></font>
  out.close();<font></font>
<font></font>
  <span class="hljs-comment">//Delete the first file, rename the temp file</span>
  boost::filesystem::remove_all((data_dir/<span class="hljs-string">"world.region"</span>).<span class="hljs-built_in">string</span>());<font></font>
  boost::filesystem::rename((data_dir/<span class="hljs-string">"world.region.temp"</span>).<span class="hljs-built_in">string</span>(),(data_dir/<span class="hljs-string">"world.region"</span>).<span class="hljs-built_in">string</span>());<font></font>
<font></font>
  <span class="hljs-comment">//Success!</span>
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
blueprintクラスには、editBufferと、特定のオブジェクト（ツリー、サボテン、小屋など）のeditBufferを作成できるいくつかのメソッドが含まれています。次に、設計図をオブジェクトを配置する位置に変換し、それを単に世界の記憶に書き込むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フラグメントを操作する際の最大の問題の1つは、フラグメントの境界間のいくつかのブロックの変更が、多くの算術剰余を含み、変更をいくつかの部分に分割する単調なプロセスであることが判明する可能性があることです。これは、blueprintクラスが見事に処理する主な問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はワールドジェネレーションの段階で積極的に使用して、変更をファイルに書き込む「ボトルネック」を拡大しています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">World::generate</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">//Create an editBuffer that contains a flat surface!</span><font></font>
  blueprint.flatSurface(dim.x*chunkSize, dim.z*chunkSize);<font></font>
  <span class="hljs-comment">//Write the current blueprint to the world file.</span><font></font>
  evaluateBlueprint(blueprint);<font></font>
<font></font>
  <span class="hljs-comment">//Add a tree</span><font></font>
  Blueprint _tree;<font></font>
  evaluateBlueprint(_tree.translate(glm::vec3(x, y, z)));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ワールドクラスは、ワールドに加えられた変更の独自の青写真を格納するため、bufferChunks（）が呼び出されると、すべての変更が1回のパスでハードディスクに書き込まれ、仮想メモリから削除されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダラーの構造はそれほど複雑ではありませんが、理解するにはOpenGLの知識が必要です。</font><font style="vertical-align: inherit;">すべてのパーツが興味深いわけではありませんが、主にOpenGL機能ラッパーです。</font><font style="vertical-align: inherit;">私はかなり前から視覚化の実験をしていて、好きなものを手に入れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シミュレーションは一人称ではないので、正投影を選びました。</font><font style="vertical-align: inherit;">疑似3D形式で実装することもできます（つまり、タイルを事前に投影してソフトウェアレンダラーでオーバーレイするなど）が、私にはばかげているように見えました。</font><font style="vertical-align: inherit;">OpenGLに切り替えてよかったです。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/61e/923/40e/61e92340e2801dc8f6dd63b54badc438.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レンダリングの基本クラスはViewと呼ばれ、シミュレーションレンダリングを制御する重要な変数のほとんどが含まれています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面サイズとシャドウテクスチャ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーオブジェクト、カメラ、マトリックスなどのズーム係数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ほとんどすべてのレンダラー関数のブール値</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メニュー、フォグ、被写界深度、木目テクスチャなど</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明、霧、空、ウィンドウ選択などの色。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、OpenGL自体のレンダリングとラッピングを行うヘルパークラスがいくつかあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスシェーダー</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSLシェーダーの読み込み、コンパイル、コンパイル、使用</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルクラス</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリング用のVAO（Vertex Arrays Object）データフラグメント、メッシュ作成機能、およびレンダリング方法が含まれています。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスの看板</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レンダリングするFBO（FrameBufferオブジェクト）が含まれています-ポストプロセッシングやシャドウイング効果の作成に役立ちます。</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スプライトクラス</font></font><ul>
<li>    ,     (   ).    !</li>
</ul></li>
<li> Interface<ul>
<li>   ImGUI</li>
</ul></li>
<li> Audio<ul>
<li>    (   ,  “M”)</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/0f3/ef6/6e50f3ef66d7d71dd5ae76b94b3c168a.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高被写界深度（DOF）。</font><font style="vertical-align: inherit;">レンダリング距離が長い場合は遅くなる可能性がありますが、すべてラップトップで行いました。</font><font style="vertical-align: inherit;">おそらく良いコンピュータでは、ブレーキは見えなくなります。</font><font style="vertical-align: inherit;">私はそれが私の目を疲れさせて、楽しみのためだけにそうしたことを理解しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上の画像は、操作中に変更できるいくつかのパラメーターを示しています。</font><font style="vertical-align: inherit;">全画面モードへの切り替えも実装しました。</font><font style="vertical-align: inherit;">この画像は、カメラに向かってテクスチャ化された四辺形としてレンダリングされたボットスプライトの例を示しています。</font><font style="vertical-align: inherit;">画像の家とサボテンは、青写真を使用して構築されています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメントメッシュの作成</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、メッシュを作成する単純なバージョンを使用しました。私は、立方体を作成し、空のスペースに触れていない頂点を破棄しました。ただし、このソリューションは遅く、新しいフラグメントをロードするときに、メッシュの作成はファイルへのアクセスよりもさらに狭い「ボトルネック」であることが判明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な問題は、フラグメントからレンダリングされたVBOの効率的な作成でしたが、C ++で独自のバージョンの「貪欲なメッシュ」（OpenGLと互換性のある（ループの奇妙な構造なし））を実装できました。私のコードは明確に良心的に使用できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Model::fromChunkGreedy</span><span class="hljs-params">(Chunk chunk)</span></span>{
<span class="hljs-comment">//... (this is part of the model class - find on github!)</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、貪欲なメッシュへの移行により、描画される四角形の数が平均60％減少しました。</font><font style="vertical-align: inherit;">次に、さらにマイナーな最適化（VBOインデックス作成）を行った後、数をさらに1/3減らしました（エッジごとに6つの頂点から4つの頂点に）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最大化されていないウィンドウで5x1x5フラグメントのシーンをレンダリングすると、平均で約140 FPS（VSYNCが無効）になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この結果には非常に満足していますが、世界のデータから3次以外のモデルをレンダリングするためのシステムを思いついています。</font><font style="vertical-align: inherit;">貪欲なメッシュとの統合はそれほど簡単ではないため、検討する価値があります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーとボクセルの強調表示</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GLSLシェーダーの実装は、GPUでのデバッグが複雑なため、エンジンを作成する上で最も面倒な要素であると同時に最も煩わしい部分の1つでもあります。私はGLSLの専門家ではないので、外出先で多くのことを学ぶ必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が実装した効果は、FBOとテクスチャサンプリング（たとえば、ぼかし、シャドウイング、深度情報の使用）を積極的に使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在の照明モデルは「暗い」部分をうまく処理できないため、私はまだ好きではありません。昼と夜を変えるサイクルに取り組むときに、これが修正されることを願っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、変更されたBresenhamアルゴリズムを使用して簡単なボクセル選択関数を実装しました（これはボクセルを使用するもう1つの利点です）。</font><font style="vertical-align: inherit;">シミュレーション中に空間情報を取得するのに役立ちます。</font><font style="vertical-align: inherit;">私の実装は正射投影でのみ機能しますが、使用できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/020/f2c/c60020f2cd1b4507152fdee4ef16e0ea.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ハイライト」されたカボチャ。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲームクラス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力の処理、メッセージのデバッグ、および基本機能を備えた個別のItemクラス（さらに拡張される）のために、いくつかの補助クラスが作成されました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">eventHandler</span>{</span>
<span class="hljs-comment">/*
This class handles user input, creates an appropriate stack of activated events and handles them so that user inputs have continuous effect.
*/</span>
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">//Queued Inputs</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;SDL_Event*&gt; inputs; <span class="hljs-comment">//General Key Inputs</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;SDL_Event*&gt; scroll; <span class="hljs-comment">//General Key Inputs</span>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;SDL_Event*&gt; rotate; <span class="hljs-comment">//Rotate Key Inputs</span>
  SDL_Event* mouse; <span class="hljs-comment">//Whatever the mouse is doing at a moment</span>
  SDL_Event* windowevent; <span class="hljs-comment">//Whatever the mouse is doing at a moment</span>
  <span class="hljs-keyword">bool</span> _window;
  <span class="hljs-keyword">bool</span> move = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">bool</span> click = <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">bool</span> fullscreen = <span class="hljs-literal">false</span>;<font></font>
<font></font>
  <span class="hljs-comment">//Take inputs and add them to stack</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">input</span><span class="hljs-params">(SDL_Event *e, <span class="hljs-keyword">bool</span> &amp;quit, <span class="hljs-keyword">bool</span> &amp;paused)</span></span>;<font></font>
<font></font>
  <span class="hljs-comment">//Handle the existing stack every tick</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(World &amp;world, Player &amp;player, Population &amp;population, View &amp;view, Audio &amp;audio)</span></span>;<font></font>
<font></font>
  <span class="hljs-comment">//Handle Individual Types of Events</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handlePlayerMove</span><span class="hljs-params">(World &amp;world, Player &amp;player, View &amp;view, <span class="hljs-keyword">int</span> a)</span></span>;
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleCameraMove</span><span class="hljs-params">(World &amp;world, View &amp;view)</span></span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のイベントハンドラーは醜いですが、機能しています。</font><font style="vertical-align: inherit;">特にSDL投票イベントの使用に関して、その改善に関する推奨事項を喜んで受け入れます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最新のメモ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンジン自体は、タスクボットを配置したシステムにすぎません（次の投稿で詳しく説明します）。</font><font style="vertical-align: inherit;">しかし、あなたが私の方法を面白くして、もっと知りたいのなら、私に書いてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、タスクボットシステム（このプロジェクトの真の中心）を3Dの世界に移植し、その機能を大幅に拡張しましたが、後でさらに詳しく説明します（ただし、コードは既にオンラインで投稿されています）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474400/index.html">色のコントラストの可用性に関する神話</a></li>
<li><a href="../ja474402/index.html">VavrコレクションAPIガイド</a></li>
<li><a href="../ja474404/index.html">Yandex（フロントエンド開発）2019のプログラミング選手権で解決された問題の分析</a></li>
<li><a href="../ja474406/index.html">ワイルドでのBlueKeepの初登場</a></li>
<li><a href="../ja474408/index.html">ページオブジェクトモデルの革命または進化？</a></li>
<li><a href="../ja474418/index.html">DEFCON 27カンファレンス。macOSのハッカー製品の恩恵を受けています。パート1</a></li>
<li><a href="../ja474420/index.html">Становление термостата: как это получилось</a></li>
<li><a href="../ja474424/index.html">混合トレーニング-それは何で、どのように機能するか</a></li>
<li><a href="../ja474426/index.html">アニメシリーズ「数学サークル」</a></li>
<li><a href="../ja474430/index.html">DevOpsDays Moscow-コミュニティがコミュニティのために行う会議</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>