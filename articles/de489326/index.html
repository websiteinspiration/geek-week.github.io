<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏿 🖼️ 🧒 Überlegungen zu effektiven Unternehmenstests 🙇🏿 🌂 🎎</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Vor kurzem sind wir zu einer gründlichen Untersuchung des Testthemas zurückgekehrt, und in den absehbaren Plänen haben wir sogar ein a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Überlegungen zu effektiven Unternehmenstests</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor kurzem sind wir zu einer gründlichen Untersuchung des Testthemas zurückgekehrt, und in den absehbaren Plänen haben wir sogar ein ausgezeichnetes Buch über Unit-Tests. </font><font style="vertical-align: inherit;">Gleichzeitig glauben wir, dass der Kontext in diesem Thema wie nirgendwo anders wichtig ist. Deshalb bieten wir heute eine Übersetzung von zwei Veröffentlichungen (zu einer zusammengefasst) an, die auf dem Blog eines bekannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezialisten </font><font style="vertical-align: inherit;">Sebastian Dashner veröffentlicht wurden - nämlich 1/6 und 2/6 aus der Reihe „ Gedanken zu effizienten Unternehmenstests. "</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unternehmenstests sind ein Thema, das noch nicht so ausführlich untersucht wurde, wie wir es gerne hätten. </font><font style="vertical-align: inherit;">Das Schreiben und insbesondere das Unterstützen von Tests erfordert viel Zeit und Mühe. Es ist jedoch keine Option, Zeit zu sparen, indem die Tests abgebrochen werden. </font><font style="vertical-align: inherit;">Welche Aufgaben, Ansätze und Testtechnologien sollten untersucht werden, um die Effektivität des Testens zu erhöhen?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einführung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig von den verschiedenen Arten von Tests und ihrem Umfang besteht der Zweck der Vorbereitung einer Reihe von Tests darin, auf diesem Material sicherzustellen, dass unsere Anwendung in der Produktion genau wie erwartet funktioniert. </font><font style="vertical-align: inherit;">Diese Motivation sollte die Hauptmotivation sein, wenn geprüft wird, ob das System die Aufgabe erfüllt, wenn wir dieses System aus Sicht des Benutzers betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Aufmerksamkeitsspanne und Kontextwechsel zu berücksichtigen sind, müssen wir sicherstellen, dass unsere Tests nicht lange ausgeführt und getestet werden und dass die Testergebnisse vorhersehbar sind. </font><font style="vertical-align: inherit;">Beim Schreiben von Code ist eine schnelle Überprüfung des Codes (innerhalb einer Sekunde möglich) von entscheidender Bedeutung - dies gewährleistet eine hohe Produktivität und Konzentration während der Arbeit.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite müssen wir die Testunterstützung sicherstellen. Softwareänderungen treten sehr häufig auf, und bei einer umfassenden Abdeckung des Codes mit Funktionstests erfordert jede Funktionsänderung im Produktionscode eine Änderung auf Testebene. Im Idealfall sollte sich der Testcode nur ändern, wenn sich die Funktionalität, d. H. Die Geschäftslogik, ändert, und nicht, wenn unnötiger Code bereinigt und umgestaltet wird. Im Allgemeinen sollten Testszenarien die Möglichkeit nichtfunktionaler struktureller Änderungen beinhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die verschiedenen Anwendungsbereiche von Tests betrachten, stellt sich die Frage: Welche dieser Bereiche sind die Zeit und Mühe wert? </font><font style="vertical-align: inherit;">Beispielsweise sind in Mikroservice-Anwendungen sowie in jedem System, das erhebliche Arbeit an der Verteilung und Integration von Code leistet, Integrationstests besonders wichtig, um die Grenzen des Systems zu erfassen. </font><font style="vertical-align: inherit;">Daher benötigen wir eine effektive Methode, um die gesamte Anwendung während der lokalen Entwicklung zu testen und gleichzeitig die Umgebung und Struktur dieser Anwendung in einer Form zu erhalten, die so produktionsnah wie möglich ist.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinzipien und Einschränkungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabhängig von den ausgewählten Lösungen definieren wir die folgenden Prinzipien und Einschränkungen für unsere Testsuite:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : «     HTTP-  gRPC,   JSON  -      enterprise-, ..?”.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    « »,  ,    ,          , , ,  “dev”  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">watch-and-deploy</a> («  »)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Komponententest überprüft das Verhalten eines einzelnen Moduls, normalerweise einer Klasse, während alle externen Faktoren, die nicht mit der Struktur des Moduls zusammenhängen, ignoriert oder simuliert werden. Unit-Tests sollten die Geschäftslogik einzelner Module überprüfen, ohne deren weitere Integration oder Konfiguration zu überprüfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach meiner Erfahrung haben die meisten Unternehmensentwickler eine ziemlich gute Vorstellung davon, wie Komponententests kompiliert werden. Um einen Eindruck davon zu hinterlassen, können Sie dieses Beispiel in meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Kaffeetestprojekt sehen</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In den meisten Projekten wird JUnit in Kombination mit Mockito verwendet, um Abhängigkeiten zu simulieren, und idealerweise mit AssertJ, um lesbare Anweisungen effizient zu definieren. Ich betone immer, dass Unit-Tests ohne spezielle Erweiterungen oder Starter durchgeführt werden können, dh mit der üblichen JUnit. Die Erklärung ist einfach: Es geht nur um die Laufzeit, da wir die Fähigkeit benötigen, Hunderte von Tests in Millisekunden auszuführen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unit-Tests laufen in der Regel sehr schnell und es ist einfach, komplexe Testsuiten oder spezielle Workflows daraus zusammenzustellen, da sie einfach auszuführen sind und den Lebenszyklus des Tests nicht einschränken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jedoch viele Komponententests haben, die die Abhängigkeiten der getesteten Klasse simulieren, gibt es einen Nachteil: Sie hängen eng mit der Implementierung zusammen (dies gilt insbesondere für Klassen und Methoden), weshalb unser Code schwer umzugestalten ist. Mit anderen Worten, für jeden Refactoring-Vorgang im Produktionscode sind auch Änderungen am Testcode erforderlich. Im schlimmsten Fall lehnen Entwickler das Refactoring sogar teilweise ab, einfach weil es zu aufwändig ist und die Qualität des Codes im Projekt rapide abnimmt. Im Idealfall sollte der Entwickler in der Lage sein, die Elemente umzugestalten und neu anzuordnen, vorausgesetzt, es gibt keine Änderungen in der Anwendung, die für den Benutzer erkennbar sind. Unit-Tests vereinfachen keinesfalls immer die Umgestaltung des Produktionscodes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erfahrung zeigt jedoch, dass Komponententests sehr effektiv bei der Überprüfung von Code sind, der dicht mit präziser Logik gefüllt ist oder die Implementierung einer bestimmten Funktion, beispielsweise eines Algorithmus, beschreibt und gleichzeitig nicht sehr aktiv mit anderen Komponenten interagiert. Je weniger komplex oder dicht der Code in einer bestimmten Klasse ist, je geringer seine zyklomatische Komplexität ist oder je aktiver er mit anderen Komponenten interagiert, desto weniger effektiv sind Unit-Tests beim Testen dieser Klasse. Insbesondere in Fällen mit Microservices, in denen relativ wenig Geschäftslogik enthalten ist, aber eine umfassende Integration mit externen Systemen bereitgestellt wird, besteht möglicherweise in vielen Fällen keine Notwendigkeit, Komponententests zu verwenden. In solchen Systemen enthalten einzelne Module (mit seltenen Ausnahmen) normalerweise wenig spezialisierte Logik. Dies sollte bei der Entscheidung berücksichtigt werdenWas ist angemessener, um Zeit und Mühe zu verbringen.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungssituationen testen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem der engen Verknüpfung von Tests mit der Implementierung zu lösen, können Sie einen etwas anderen Ansatz ausprobieren, um den Umfang der Tests zu erweitern. </font><font style="vertical-align: inherit;">In meinem Buch schrieb ich über Komponententests, weil ich keinen besseren Begriff finden konnte; </font><font style="vertical-align: inherit;">Im Wesentlichen geht es in diesem Fall jedoch darum, angewandte Situationen zu testen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anwendungssituationstests sind Integrationstests, die auf Codeebene ausgeführt werden und keine integrierten Container verwenden. Sie werden abgebrochen, um den Start zu beschleunigen. </font><font style="vertical-align: inherit;">Sie testen die Geschäftslogik gut koordinierter Komponenten, die normalerweise in einem bestimmten praktischen Fall verwendet werden, von der Grenzmethode bis hin zu allen ihnen zugeordneten Komponenten. </font><font style="vertical-align: inherit;">Die Integration in externe Systeme, beispielsweise in Datenbanken, wird mithilfe von Mocks nachgeahmt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen solcher Szenarien ohne den Einsatz fortschrittlicherer Technologien, die Komponenten automatisch verbinden, scheint eine große Arbeit zu sein. Wir definieren jedoch wiederverwendbare Testkomponenten. Sie sind auch Testgegenstücke, die Komponenten durch Simulieren, Verbinden und Hinzufügen von Testkonfigurationen erweitern. All dies geschieht, um den Gesamtaufwand für das Refactoring zu minimieren. Ziel ist es, die einzigen Verantwortlichkeiten zu schaffen, die den Einfluss von Änderungen auf eine einzelne Klasse (oder mehrere Klassen) im Testbereich begrenzen. Wenn wir solche Arbeiten durchführen, um sie wiederzuverwenden, reduzieren wir den Gesamtaufwand für die erforderliche Arbeit. Eine solche Strategie ist gerechtfertigt, wenn das Projekt wächst. Jede Komponente erfordert jedoch nur geringfügige Reparaturen, und diese Arbeiten werden schnell amortisiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir testen eine Klasse, die die Reihenfolge des Kaffees beschreibt, um sich das alles besser vorstellen zu können. Diese Klasse enthält zwei weitere Klassen: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen von Test verdoppelt, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden im Testbereich des Projekts befinden, wo sie die Komponenten erben </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich </font><font style="vertical-align: inherit;">im Hauptbereich des Programms. Testgegenstücke können die erforderliche Simulations- und Verbindungslogik festlegen und möglicherweise die öffentliche Schnittstelle der Klasse mithilfe der in dieser Anwendung benötigten Simulationsmethoden oder durch Überprüfungsmethoden erweitern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende zeigt die Testdoppelklasse für die Komponente </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Test-Doppelklasse kann auf die Felder und Konstruktoren der CoffeeShop-Basisklasse zugreifen, um Abhängigkeiten herzustellen. Hier werden in Form von Testzwillingen auch Varianten anderer Komponenten verwendet, insbesondere werden </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie benötigt, um zusätzliche Simulations- oder Verifizierungsmethoden aufzurufen, die Teil des praktischen Falls sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen von Testdoppeln sind wiederverwendbare Komponenten, von denen jede einmal pro Umfang jedes Projekts geschrieben wird und dann in vielen praktischen Fällen verwendet wird:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Komponententest überprüft in diesem Fall den spezifischen Fall der Geschäftslogik, die am Einstiegspunkt aufgerufen wird </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Solche Tests werden präzise und lesbar erhalten, da alle Verbindungen und Simulationen in separaten Testzwillingen durchgeführt werden und später hochspezialisierte Screening-Techniken verwendet werden können, wie z </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, erweitert die Testklasse den Bereich der Produktionsklasse, sodass Sie mokee installieren und Methoden verwenden können, die das Verhalten überprüfen. Trotz der Tatsache, dass die Einrichtung eines solchen Systems anscheinend viel Aufwand erfordert, werden diese Kosten schnell amortisiert, wenn wir im Rahmen des gesamten Projekts viele praktische Fälle haben, in denen Komponenten wiederverwendet werden können. Je mehr unser Projekt wächst, desto nützlicher wird dieser Ansatz - insbesondere, wenn Sie auf die Zeit achten, die für die Durchführung der Tests benötigt wird. Alle unsere Testfälle werden weiterhin mit JUnit ausgeführt und in kürzester Zeit in Hunderten ausgeführt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der Hauptvorteil dieses Ansatzes: Komponententests werden genauso schnell ausgeführt wie reguläre Komponententests. Sie stimulieren jedoch das Refactoring des Produktionscodes, da Änderungen an einer einzelnen Komponente oder nur an wenigen Komponenten vorgenommen werden müssen. </font><font style="vertical-align: inherit;">Durch die Verbesserung der Testgegenstücke mit ausdrucksstarken Optimierungs- und Überprüfungsmethoden, die für unser Fachgebiet spezifisch sind, verbessern wir außerdem die Lesbarkeit unseres Codes, erleichtern dessen Verwendung und beseitigen stereotypen Code in Testskripten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489298/index.html">Ein informelles Interview mit Maria Dolgusheva (HR aus dem Silicon Valley)</a></li>
<li><a href="../de489302/index.html">Problem Nr. 31: IT-Schulung - aktuelle Probleme und Herausforderungen führender Unternehmen</a></li>
<li><a href="../de489304/index.html">ChIP-seq-Datenanalyse: von Histonen zu Computeraufgaben</a></li>
<li><a href="../de489306/index.html">[Habr]: Donuts</a></li>
<li><a href="../de489310/index.html">Top 10: die besten Berichte von Heisenbug 2019 Moskau</a></li>
<li><a href="../de489328/index.html">Null hat sich eingeschlichen: Scala Option mit Java brechen</a></li>
<li><a href="../de489332/index.html">Wesentliche Assistenten für die Intelligenz des effektivsten Geheimdienstes der Welt (Teil 3)</a></li>
<li><a href="../de489336/index.html">Interface Bikes Giftiger Großvater. „Lerne, lerne und lerne wieder“ (s1 e3)</a></li>
<li><a href="../de489340/index.html">Als maximale Einheit für die Übertragung von Informationen im Internet wurden 1500 Bytes</a></li>
<li><a href="../de489342/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 4. Bereitstellen von Cisco 3850-Switches für das Gateway-Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>