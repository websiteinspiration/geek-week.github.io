<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§üüèø üñºÔ∏è üßí √úberlegungen zu effektiven Unternehmenstests üôáüèø üåÇ üéé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Habr! 
 
 Vor kurzem sind wir zu einer gr√ºndlichen Untersuchung des Testthemas zur√ºckgekehrt, und in den absehbaren Pl√§nen haben wir sogar ein a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>√úberlegungen zu effektiven Unternehmenstests</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489326/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vor kurzem sind wir zu einer gr√ºndlichen Untersuchung des Testthemas zur√ºckgekehrt, und in den absehbaren Pl√§nen haben wir sogar ein ausgezeichnetes Buch √ºber Unit-Tests. </font><font style="vertical-align: inherit;">Gleichzeitig glauben wir, dass der Kontext in diesem Thema wie nirgendwo anders wichtig ist. Deshalb bieten wir heute eine √úbersetzung von zwei Ver√∂ffentlichungen (zu einer zusammengefasst) an, die auf dem Blog eines bekannten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java EE-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezialisten </font><font style="vertical-align: inherit;">Sebastian Dashner ver√∂ffentlicht wurden - n√§mlich 1/6 und 2/6 aus der Reihe ‚Äû Gedanken zu effizienten Unternehmenstests. "</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unternehmenstests sind ein Thema, das noch nicht so ausf√ºhrlich untersucht wurde, wie wir es gerne h√§tten. </font><font style="vertical-align: inherit;">Das Schreiben und insbesondere das Unterst√ºtzen von Tests erfordert viel Zeit und M√ºhe. Es ist jedoch keine Option, Zeit zu sparen, indem die Tests abgebrochen werden. </font><font style="vertical-align: inherit;">Welche Aufgaben, Ans√§tze und Testtechnologien sollten untersucht werden, um die Effektivit√§t des Testens zu erh√∂hen?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºhrung</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabh√§ngig von den verschiedenen Arten von Tests und ihrem Umfang besteht der Zweck der Vorbereitung einer Reihe von Tests darin, auf diesem Material sicherzustellen, dass unsere Anwendung in der Produktion genau wie erwartet funktioniert. </font><font style="vertical-align: inherit;">Diese Motivation sollte die Hauptmotivation sein, wenn gepr√ºft wird, ob das System die Aufgabe erf√ºllt, wenn wir dieses System aus Sicht des Benutzers betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Aufmerksamkeitsspanne und Kontextwechsel zu ber√ºcksichtigen sind, m√ºssen wir sicherstellen, dass unsere Tests nicht lange ausgef√ºhrt und getestet werden und dass die Testergebnisse vorhersehbar sind. </font><font style="vertical-align: inherit;">Beim Schreiben von Code ist eine schnelle √úberpr√ºfung des Codes (innerhalb einer Sekunde m√∂glich) von entscheidender Bedeutung - dies gew√§hrleistet eine hohe Produktivit√§t und Konzentration w√§hrend der Arbeit.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf der anderen Seite m√ºssen wir die Testunterst√ºtzung sicherstellen. Software√§nderungen treten sehr h√§ufig auf, und bei einer umfassenden Abdeckung des Codes mit Funktionstests erfordert jede Funktions√§nderung im Produktionscode eine √Ñnderung auf Testebene. Im Idealfall sollte sich der Testcode nur √§ndern, wenn sich die Funktionalit√§t, d. H. Die Gesch√§ftslogik, √§ndert, und nicht, wenn unn√∂tiger Code bereinigt und umgestaltet wird. Im Allgemeinen sollten Testszenarien die M√∂glichkeit nichtfunktionaler struktureller √Ñnderungen beinhalten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir die verschiedenen Anwendungsbereiche von Tests betrachten, stellt sich die Frage: Welche dieser Bereiche sind die Zeit und M√ºhe wert? </font><font style="vertical-align: inherit;">Beispielsweise sind in Mikroservice-Anwendungen sowie in jedem System, das erhebliche Arbeit an der Verteilung und Integration von Code leistet, Integrationstests besonders wichtig, um die Grenzen des Systems zu erfassen. </font><font style="vertical-align: inherit;">Daher ben√∂tigen wir eine effektive Methode, um die gesamte Anwendung w√§hrend der lokalen Entwicklung zu testen und gleichzeitig die Umgebung und Struktur dieser Anwendung in einer Form zu erhalten, die so produktionsnah wie m√∂glich ist.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prinzipien und Einschr√§nkungen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unabh√§ngig von den ausgew√§hlten L√∂sungen definieren wir die folgenden Prinzipien und Einschr√§nkungen f√ºr unsere Testsuite:</font></font><br>
<br>
<ul>
<li>     ,      .          ,           .    ,      ,       .</li>
<li>        ,   ,    .   ,     ,   ,    . ,       ,           .</li>
<li>     -       .    ,      ,        .</li>
<li>   ,      ,         . : ¬´     HTTP-  gRPC,   JSON  -      enterprise-, ..?‚Äù.</li>
<li>           ,     ,   -.        API,   DSL    .</li>
<li>    ¬´ ¬ª,  ,    ,          , , ,  ‚Äúdev‚Äù  debug ()  ,  dev  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Quarkus'</a>, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Telepresence</a>,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">watch-and-deploy</a> (¬´  ¬ª)  .</li>
<li>              .  ,             , ,    ,          .                .</li>
<li>        , ,   -,        ,  ,         .     ,          , ,       .</li>
</ul><br>
<h4> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Komponententest √ºberpr√ºft das Verhalten eines einzelnen Moduls, normalerweise einer Klasse, w√§hrend alle externen Faktoren, die nicht mit der Struktur des Moduls zusammenh√§ngen, ignoriert oder simuliert werden. Unit-Tests sollten die Gesch√§ftslogik einzelner Module √ºberpr√ºfen, ohne deren weitere Integration oder Konfiguration zu √ºberpr√ºfen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach meiner Erfahrung haben die meisten Unternehmensentwickler eine ziemlich gute Vorstellung davon, wie Komponententests kompiliert werden. Um einen Eindruck davon zu hinterlassen, k√∂nnen Sie dieses Beispiel in meinem </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">Kaffeetestprojekt sehen</font></a><font style="vertical-align: inherit;"> .</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In den meisten Projekten wird JUnit in Kombination mit Mockito verwendet, um Abh√§ngigkeiten zu simulieren, und idealerweise mit AssertJ, um lesbare Anweisungen effizient zu definieren. Ich betone immer, dass Unit-Tests ohne spezielle Erweiterungen oder Starter durchgef√ºhrt werden k√∂nnen, dh mit der √ºblichen JUnit. Die Erkl√§rung ist einfach: Es geht nur um die Laufzeit, da wir die F√§higkeit ben√∂tigen, Hunderte von Tests in Millisekunden auszuf√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unit-Tests laufen in der Regel sehr schnell und es ist einfach, komplexe Testsuiten oder spezielle Workflows daraus zusammenzustellen, da sie einfach auszuf√ºhren sind und den Lebenszyklus des Tests nicht einschr√§nken.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie jedoch viele Komponententests haben, die die Abh√§ngigkeiten der getesteten Klasse simulieren, gibt es einen Nachteil: Sie h√§ngen eng mit der Implementierung zusammen (dies gilt insbesondere f√ºr Klassen und Methoden), weshalb unser Code schwer umzugestalten ist. Mit anderen Worten, f√ºr jeden Refactoring-Vorgang im Produktionscode sind auch √Ñnderungen am Testcode erforderlich. Im schlimmsten Fall lehnen Entwickler das Refactoring sogar teilweise ab, einfach weil es zu aufw√§ndig ist und die Qualit√§t des Codes im Projekt rapide abnimmt. Im Idealfall sollte der Entwickler in der Lage sein, die Elemente umzugestalten und neu anzuordnen, vorausgesetzt, es gibt keine √Ñnderungen in der Anwendung, die f√ºr den Benutzer erkennbar sind. Unit-Tests vereinfachen keinesfalls immer die Umgestaltung des Produktionscodes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Erfahrung zeigt jedoch, dass Komponententests sehr effektiv bei der √úberpr√ºfung von Code sind, der dicht mit pr√§ziser Logik gef√ºllt ist oder die Implementierung einer bestimmten Funktion, beispielsweise eines Algorithmus, beschreibt und gleichzeitig nicht sehr aktiv mit anderen Komponenten interagiert. Je weniger komplex oder dicht der Code in einer bestimmten Klasse ist, je geringer seine zyklomatische Komplexit√§t ist oder je aktiver er mit anderen Komponenten interagiert, desto weniger effektiv sind Unit-Tests beim Testen dieser Klasse. Insbesondere in F√§llen mit Microservices, in denen relativ wenig Gesch√§ftslogik enthalten ist, aber eine umfassende Integration mit externen Systemen bereitgestellt wird, besteht m√∂glicherweise in vielen F√§llen keine Notwendigkeit, Komponententests zu verwenden. In solchen Systemen enthalten einzelne Module (mit seltenen Ausnahmen) normalerweise wenig spezialisierte Logik. Dies sollte bei der Entscheidung ber√ºcksichtigt werdenWas ist angemessener, um Zeit und M√ºhe zu verbringen.</font></font><br>
 <br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anwendungssituationen testen</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Problem der engen Verkn√ºpfung von Tests mit der Implementierung zu l√∂sen, k√∂nnen Sie einen etwas anderen Ansatz ausprobieren, um den Umfang der Tests zu erweitern. </font><font style="vertical-align: inherit;">In meinem Buch schrieb ich √ºber Komponententests, weil ich keinen besseren Begriff finden konnte; </font><font style="vertical-align: inherit;">Im Wesentlichen geht es in diesem Fall jedoch darum, angewandte Situationen zu testen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anwendungssituationstests sind Integrationstests, die auf Codeebene ausgef√ºhrt werden und keine integrierten Container verwenden. Sie werden abgebrochen, um den Start zu beschleunigen. </font><font style="vertical-align: inherit;">Sie testen die Gesch√§ftslogik gut koordinierter Komponenten, die normalerweise in einem bestimmten praktischen Fall verwendet werden, von der Grenzmethode bis hin zu allen ihnen zugeordneten Komponenten. </font><font style="vertical-align: inherit;">Die Integration in externe Systeme, beispielsweise in Datenbanken, wird mithilfe von Mocks nachgeahmt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen solcher Szenarien ohne den Einsatz fortschrittlicherer Technologien, die Komponenten automatisch verbinden, scheint eine gro√üe Arbeit zu sein. Wir definieren jedoch wiederverwendbare Testkomponenten. Sie sind auch Testgegenst√ºcke, die Komponenten durch Simulieren, Verbinden und Hinzuf√ºgen von Testkonfigurationen erweitern. All dies geschieht, um den Gesamtaufwand f√ºr das Refactoring zu minimieren. Ziel ist es, die einzigen Verantwortlichkeiten zu schaffen, die den Einfluss von √Ñnderungen auf eine einzelne Klasse (oder mehrere Klassen) im Testbereich begrenzen. Wenn wir solche Arbeiten durchf√ºhren, um sie wiederzuverwenden, reduzieren wir den Gesamtaufwand f√ºr die erforderliche Arbeit. Eine solche Strategie ist gerechtfertigt, wenn das Projekt w√§chst. Jede Komponente erfordert jedoch nur geringf√ºgige Reparaturen, und diese Arbeiten werden schnell amortisiert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nehmen wir an, wir testen eine Klasse, die die Reihenfolge des Kaffees beschreibt, um sich das alles besser vorstellen zu k√∂nnen. Diese Klasse enth√§lt zwei weitere Klassen: </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gp/xj/tb/gpxjtb-txbhrd0hzssooxzh1lw0.png"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen von Test verdoppelt, </font></font><code>CoffeeShopTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>*TD</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden im Testbereich des Projekts befinden, wo sie die Komponenten erben </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>OrderProcessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befindet sich </font><font style="vertical-align: inherit;">im Hauptbereich des Programms. Testgegenst√ºcke k√∂nnen die erforderliche Simulations- und Verbindungslogik festlegen und m√∂glicherweise die √∂ffentliche Schnittstelle der Klasse mithilfe der in dieser Anwendung ben√∂tigten Simulationsmethoden oder durch √úberpr√ºfungsmethoden erweitern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Folgende zeigt die Testdoppelklasse f√ºr die Komponente </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTestDouble</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CoffeeShop</span> </span>{<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeShopTestDouble</span><span class="hljs-params">(OrderProcessorTestDouble orderProcessorTestDouble)</span> </span>{<font></font>
        entityManager = mock(EntityManager.class);<font></font>
        orderProcessor = orderProcessorTestDouble;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyCreateOrder</span><span class="hljs-params">(Order order)</span> </span>{<font></font>
        verify(entityManager).merge(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">verifyProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        verify(entityManager).createNamedQuery(Order.FIND_UNFINISHED, Order.class);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">answerForUnfinishedOrders</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> </span>{
        <span class="hljs-comment">//     </span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Test-Doppelklasse kann auf die Felder und Konstruktoren der CoffeeShop-Basisklasse zugreifen, um Abh√§ngigkeiten herzustellen. Hier werden in Form von Testzwillingen auch Varianten anderer Komponenten verwendet, insbesondere werden </font></font><code> OrderProcessorTestDouble</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie ben√∂tigt, um zus√§tzliche Simulations- oder Verifizierungsmethoden aufzurufen, die Teil des praktischen Falls sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Klassen von Testdoppeln sind wiederverwendbare Komponenten, von denen jede einmal pro Umfang jedes Projekts geschrieben wird und dann in vielen praktischen F√§llen verwendet wird:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeShopTest</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">private</span> CoffeeShopTestDouble coffeeShop;
    <span class="hljs-keyword">private</span> OrderProcessorTestDouble orderProcessor;<font></font>
<font></font>
    <span class="hljs-meta">@BeforeEach</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setUp</span><span class="hljs-params">()</span> </span>{<font></font>
        orderProcessor = <span class="hljs-keyword">new</span> OrderProcessorTestDouble();<font></font>
        coffeeShop = <span class="hljs-keyword">new</span> CoffeeShopTestDouble(orderProcessor);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testCreateOrder</span><span class="hljs-params">()</span> </span>{<font></font>
        Order order = <span class="hljs-keyword">new</span> Order();<font></font>
        coffeeShop.createOrder(order);<font></font>
        coffeeShop.verifyCreateOrder(order);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testProcessUnfinishedOrders</span><span class="hljs-params">()</span> </span>{<font></font>
        List&lt;Order&gt; orders = Arrays.asList(...);<font></font>
        coffeeShop.answerForUnfinishedOrders(orders);<font></font>
<font></font>
        coffeeShop.processUnfinishedOrders();<font></font>
<font></font>
        coffeeShop.verifyProcessUnfinishedOrders();<font></font>
        orderProcessor.verifyProcessOrders(orders);<font></font>
    }<font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Komponententest √ºberpr√ºft in diesem Fall den spezifischen Fall der Gesch√§ftslogik, die am Einstiegspunkt aufgerufen wird </font></font><code>CoffeeShop</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Solche Tests werden pr√§zise und lesbar erhalten, da alle Verbindungen und Simulationen in separaten Testzwillingen durchgef√ºhrt werden und sp√§ter hochspezialisierte Screening-Techniken verwendet werden k√∂nnen, wie z </font></font><code>verifyProcessOrders()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen k√∂nnen, erweitert die Testklasse den Bereich der Produktionsklasse, sodass Sie mokee installieren und Methoden verwenden k√∂nnen, die das Verhalten √ºberpr√ºfen. Trotz der Tatsache, dass die Einrichtung eines solchen Systems anscheinend viel Aufwand erfordert, werden diese Kosten schnell amortisiert, wenn wir im Rahmen des gesamten Projekts viele praktische F√§lle haben, in denen Komponenten wiederverwendet werden k√∂nnen. Je mehr unser Projekt w√§chst, desto n√ºtzlicher wird dieser Ansatz - insbesondere, wenn Sie auf die Zeit achten, die f√ºr die Durchf√ºhrung der Tests ben√∂tigt wird. Alle unsere Testf√§lle werden weiterhin mit JUnit ausgef√ºhrt und in k√ºrzester Zeit in Hunderten ausgef√ºhrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist der Hauptvorteil dieses Ansatzes: Komponententests werden genauso schnell ausgef√ºhrt wie regul√§re Komponententests. Sie stimulieren jedoch das Refactoring des Produktionscodes, da √Ñnderungen an einer einzelnen Komponente oder nur an wenigen Komponenten vorgenommen werden m√ºssen. </font><font style="vertical-align: inherit;">Durch die Verbesserung der Testgegenst√ºcke mit ausdrucksstarken Optimierungs- und √úberpr√ºfungsmethoden, die f√ºr unser Fachgebiet spezifisch sind, verbessern wir au√üerdem die Lesbarkeit unseres Codes, erleichtern dessen Verwendung und beseitigen stereotypen Code in Testskripten.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489298/index.html">Ein informelles Interview mit Maria Dolgusheva (HR aus dem Silicon Valley)</a></li>
<li><a href="../de489302/index.html">Problem Nr. 31: IT-Schulung - aktuelle Probleme und Herausforderungen f√ºhrender Unternehmen</a></li>
<li><a href="../de489304/index.html">ChIP-seq-Datenanalyse: von Histonen zu Computeraufgaben</a></li>
<li><a href="../de489306/index.html">[Habr]: Donuts</a></li>
<li><a href="../de489310/index.html">Top 10: die besten Berichte von Heisenbug 2019 Moskau</a></li>
<li><a href="../de489328/index.html">Null hat sich eingeschlichen: Scala Option mit Java brechen</a></li>
<li><a href="../de489332/index.html">Wesentliche Assistenten f√ºr die Intelligenz des effektivsten Geheimdienstes der Welt (Teil 3)</a></li>
<li><a href="../de489336/index.html">Interface Bikes Giftiger Gro√üvater. ‚ÄûLerne, lerne und lerne wieder‚Äú (s1 e3)</a></li>
<li><a href="../de489340/index.html">Als maximale Einheit f√ºr die √úbertragung von Informationen im Internet wurden 1500 Bytes</a></li>
<li><a href="../de489342/index.html">Aufbau einer fehlertoleranten IT-Infrastruktur. Teil 4. Bereitstellen von Cisco 3850-Switches f√ºr das Gateway-Routing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>