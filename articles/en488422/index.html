<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßíüèª üßëüèº‚Äçü§ù‚Äçüßëüèº ‚ö°Ô∏è 10 lines of code to reduce the pain of your Vue project üìà üëá ‚è∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... or familiarity with Vue JS plugins as an example of an integrated event bus
 A few words about ...
 Hello everyone! I‚Äôll make a reservation right ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>10 lines of code to reduce the pain of your Vue project</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odin_ingram_micro/blog/488422/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... or familiarity with Vue JS plugins as an example of an integrated event bus</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A few words about ...</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hello everyone! </font><font style="vertical-align: inherit;">I‚Äôll make a reservation right away. </font><font style="vertical-align: inherit;">I really love VueJS, I have been actively writing on it for more than 2 years and I do not think that development on it can hurt at least to some significant degree :)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On the other hand, we are always trying to find universal solutions that will help to spend less time on mechanical work and more on what is really interesting. Sometimes the solution is particularly successful. One of these I want to share with you. The 10 lines that will be discussed (spoiler: at the end there will be a little more) were born in the process of working on the Cloud Blue - Connect project, which is a fairly large application with 400+ components. The solution we found is already integrated into various points of the system and for more than half a year it has never required corrections, so it can be safely considered successfully tested for stability.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And the last one. </font><font style="vertical-align: inherit;">Before proceeding directly to the solution, I would like to dwell a little more on the description of the three types of interaction between Vue components among themselves: the principles of unidirectional flow, the pattern of the store, and the event bus. </font><font style="vertical-align: inherit;">If this explanation is unnecessary (or boring) for you, go directly to the section with the solution - everything is as brief and technical as possible.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A little bit about how Vue components communicate with each other</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhaps the first question that a person who has written his first component raises is how he will receive data for work and how, in turn, he will transmit the data he received ‚Äúout‚Äù. </font><font style="vertical-align: inherit;">The interaction principle adopted in the Vue JS framework is called ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unidirectional data stream</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short, this principle sounds like "properties - down, events - up." That is, to receive data from the outside (‚Äúfrom above‚Äù), we register a special property inside the component into which the framework writes, if necessary, our data received ‚Äúfrom the outside‚Äù. In order to transfer data ‚Äúup‚Äù, inside the component in the right place, we call the special $ emit framework method, which passes our data to the handler of the parent component. At the same time, in Vue JS we can‚Äôt just ‚Äúbroadcast‚Äù the event up to unlimited depth (as for example in Angular 1.x). It "pops up" only one level, to the immediate parent. The same goes for events. To transfer them to the next level, for each of them you also need to register a special interface - properties and events that will transmit our ‚Äúmessage‚Äù further.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This can be described as an office building in which workers can only move from their floors to the neighboring ones - one up and one down. So, in order to transfer the ‚Äúdocument for signature‚Äù from the fifth floor to the second, a chain of three workers will be required who will deliver it from the fifth floor to the second, and then three more who will deliver it back to the fifth. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúBut this is inconvenient!‚Äù Of course, this is not always convenient from a development point of view, but looking at the code of each component, we can see what and to whom it passes. We do not need to keep in mind the entire structure of the application in order to understand whether our component is ‚Äúon the way‚Äù to the event or not. We can see this from the parent component.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Although the advantages of this approach are understandable, it also has obvious disadvantages, namely, the high cohesion of components. </font><font style="vertical-align: inherit;">Simply put, in order for us to place some component in the structure, we need to overlay it with the necessary interfaces in order to manage its state. </font><font style="vertical-align: inherit;">In order to reduce this connectivity, they often use ‚Äústate management tools‚Äù. </font><font style="vertical-align: inherit;">Perhaps the most popular tool for Vue is ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vuex (side)</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Continuing our analogy with an office building, Vuex Stor is an internal postal service. Imagine that on each floor of the office there is a window for issuing and receiving parcels. On the fifth floor they transfer document No. 11 for signature, and on the second they periodically ask: ‚ÄúAre there any documents for signature?‚Äù, Sign the existing ones and give them back. On the fifth one they also ask: ‚ÄúAre there any signatories?‚Äù At the same time, employees can move to other floors or to other rooms - the principle of work will not change while the mail is working. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Approximately by this principle the pattern called Store also works. Using the Vuex interface, a global data warehouse is registered and configured, and components subscribe to it. And it doesn‚Äôt matter at what level of what structure the appeal occurred, the store will always give the right information.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It would seem that on this all the problems have already been resolved. But at some point in our metaphorical building, one employee wants to call another for lunch ... or report some kind of mistake. And here the strange begins. The message itself does not require transmission as such. But in order to use the mail you need to transfer something. Then our employees come up with a code. One green ball - go to lunch, two red cubes - an application error E-981273 occurred, three yellow coins - check your mail and so on.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is easy to guess that with the help of this awkward metaphor I describe situations when we need to ensure the response of our component to an event that occurred in another component, which in itself is not connected in any way with the data stream. </font><font style="vertical-align: inherit;">Saving of a new item is completed - you need to retake the collection. </font><font style="vertical-align: inherit;">An 403 Unauthorized error has occurred - you need to start a user logout and so on. </font><font style="vertical-align: inherit;">The usual (and far from the best) practice in this case is to create flags inside the store or to indirectly interpret the stored data and its changes. </font><font style="vertical-align: inherit;">This quickly leads to pollution of both the store itself and the logic of the components around it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this stage, we begin to think about how to pass events directly, bypassing the entire chain of components. </font><font style="vertical-align: inherit;">And, a little google or rummaging in the documentation, we come across a pattern ...</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Event bus</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
From a technical point of view, the event bus is an object that allows using one special method to launch an ‚Äúevent‚Äù and subscribe to it using another. In other words, when signing up for the eventA event, this object stores the passed-in handler function inside its structure, which it will call when the launch method with the eventA key is called somewhere in the application. To sign or run it is enough to access it through import or by reference, and you're done. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metaphorically, in our ‚Äúbuilding‚Äù, a bus is a common chat in the messenger. Components subscribe to a "general chat" to which other components send messages. As soon as a ‚Äúmessage‚Äù appears on the ‚Äúchat‚Äù, to which the component has subscribed, the handler will start.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are many different ways to create an event bus. </font><font style="vertical-align: inherit;">You can write it yourself or you can use ready-made solutions - the same RxJS, which provides huge functionality for working with entire streams of events. </font><font style="vertical-align: inherit;">But most often when working with VueJS they use, oddly enough, VueJS itself. </font><font style="vertical-align: inherit;">The Vue instance created through the constructor (new Vue ()) provides a beautiful and concise event interface, described in the official documentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we come close to the next question ...</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What do we want?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And we want to build an event bus in our application. </font><font style="vertical-align: inherit;">But we have two additional requirements:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It should be easily accessible in every component. </font><font style="vertical-align: inherit;">Separate imports into each of the dozens of components seems redundant to us.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It must be modular. </font><font style="vertical-align: inherit;">We do not want to keep all event names in mind in order to avoid the situation when the ‚Äúitem-created‚Äù event fires handlers from the entire application. </font><font style="vertical-align: inherit;">Therefore, we want to be able to easily separate a small fragment of the component tree into a separate module and broadcast its events inside it, and not outside.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to implement such impressive functionality, we use the powerful plug-in interface that VueJS provides us with. </font><font style="vertical-align: inherit;">You can familiarize yourself with it in more detail </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the page with official documentation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's register our plugin first. </font><font style="vertical-align: inherit;">To do this, right before the initialization point of our Vue application (before calling Vue. $ Mount ()) we place the following block:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { }, <font></font>
});<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In fact, Vue plugins are a way to extend the functionality of the framework at the whole application level. The plugin interface provides several ways to integrate into the component, but today we will introduce the mixin interface. This method accepts an object that extends the descriptor of each component before starting the life cycle in the application.</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(The component code that we write is more likely not the component itself, but a description of its behavior and encapsulation of a certain part of the logic that the framework uses at various stages of its life cycle. The plug-in initialization is outside the component life cycle, preceding it, therefore we we say ‚Äúdescriptor‚Äù, not a component, to emphasize that exactly the code that is written in our file, and not some entity that is a product of the framework‚Äôs work, will be transferred to the mixin section of the plugin)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) {     <font></font>
    vue.mixin({}); <span class="hljs-comment">// &lt;--</span><font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is this empty object that will contain the extensions for our components. But for starters, another stop. In our case, we want to create an interface for accessing the bus at the level of each component. Let's add the '$ broadcast' field to our descriptor, it will store a link to our bus. To do this, use Vue.prototype:</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <span class="hljs-comment">// &lt;--</span><font></font>
    vue.mixin({}); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we need to create the bus itself, but first let's recall the requirement of modularity and assume that in the component descriptor we will declare a new module with the ‚Äú$ module‚Äù field with some text value (we will need it a bit later). </font><font style="vertical-align: inherit;">If the $ module field is specified in the component itself, we will create a new bus for it; if not, we will pass the link to the parent via the $ parent field. </font><font style="vertical-align: inherit;">Note that the descriptor fields will be available to us through the $ options field. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will place the creation of our bus at the earliest possible stage - in the beforeCreate hook.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({<font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() {  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
 	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) {  <span class="hljs-comment">// &lt;--</span><font></font>
         <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, let's fill in the logical branches. </font><font style="vertical-align: inherit;">If the descriptor contains a new module declaration, create a new bus instance, if not, take the link from $ parent.</font></font><br>
<br>
<pre><code class="javascript hljs">Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>; <font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue();  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast;  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We discard the plugin‚Äôs announcement, we consider ... 1, 2, 3, 4 ... 10 lines, as I promised! </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Can we do it better?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course we can. </font><font style="vertical-align: inherit;">This code is easily extensible. </font><font style="vertical-align: inherit;">For example, in our case, in addition to $ broadcast, we decided to add the $ rootBroadcast interface, which gives access to a single bus for the entire application. </font><font style="vertical-align: inherit;">Events that the user runs on the $ broadcast bus are duplicated on the $ rootBroadcast bus so that you can subscribe to either all events of a particular module (in this case, the event name will be passed to the handler as the first argument) or to all application events in general (then the module name will be passed to the handler with the first argument, the event name with the second, and the data transmitted with the event will be passed with the following arguments). </font><font style="vertical-align: inherit;">This design will allow us to establish interaction between the modules, as well as hang a single handler on the events of different modules.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// This one emits event  </span>
<span class="hljs-keyword">this</span>.$broadcast.$emit(‚Äòmy-event‚Äô, ‚ÄòPARAM_A‚Äô); 
<span class="hljs-comment">// This is standard subscription inside module </span>
<span class="hljs-keyword">this</span>.$broadcast.$on(‚Äòmy-event‚Äô, (paramA) =&gt; {‚Ä¶}); 
<span class="hljs-comment">// This subscription will work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‚Äòmy-event‚Äô, (<span class="hljs-built_in">module</span>, paramA) =&gt; {‚Ä¶}); 
<span class="hljs-comment">// This subscription will also work for the same event </span>
<span class="hljs-keyword">this</span>.$rootBroadcast.$on(‚Äò*‚Äô, (event, <span class="hljs-built_in">module</span>, paramA) =&gt; {‚Ä¶});
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's see how we can achieve this: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, create a single bus, which will be organized through $ rootBroadcast, and the field itself with a link:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue(); <span class="hljs-comment">// &lt;--</span><font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus; <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we need module membership in each component, so let's expand the definition of modularity like this:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">new</span> Vue(); <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast = <span class="hljs-keyword">this</span>.$parent.$broadcast; <font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Next, we need to make the event on the modular local bus reflect in the way we need to the root. </font><font style="vertical-align: inherit;">To do this, we first have to create a simple proxy interface and place the bus itself in the conditionally private property of $ bus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <span class="hljs-comment">// &lt;--</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };  <span class="hljs-comment">// &lt;--</span><font></font>
        } <font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And finally, add proxy methods to the object - because now the $ broadcast field does not provide direct access to the bus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
        <span class="hljs-comment">// &gt;&gt;&gt;</span>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">‚Ä¶attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(‚Ä¶attrs);           
          <span class="hljs-keyword">const</span> [event, ‚Ä¶attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, ‚Ä¶attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‚Äò*‚Äô, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, ‚Ä¶attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">‚Ä¶attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(‚Ä¶attrs);<font></font>
        };<font></font>
        <span class="hljs-comment">// &lt;&lt;&lt;</span><font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, as a final touch, let's remember that we get access to the bus by closing, which means that the handlers added once will not be cleared with the component, but will live during the whole time of working with the application. This can cause unpleasant side effects, so let's add a listener cleanup function to our bus at the end of the component‚Äôs life cycle:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> $rootBus = <span class="hljs-keyword">new</span> Vue();<font></font>
<font></font>
Vue.use({   <font></font>
  install(vue) { <font></font>
    vue.prototype.$broadcast = <span class="hljs-literal">null</span>;<font></font>
    vue.mixin({<font></font>
      beforeDestroy() {                               <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">this</span>.$broadcast.$off(<span class="hljs-keyword">this</span>.$broadcastEvents);  <span class="hljs-comment">// &lt;--</span><font></font>
      },<font></font>
<font></font>
      beforeCreate() { <font></font>
        vue.prototype.$rootBroadcast = $rootBus;<font></font>
        <span class="hljs-keyword">this</span>.$broadcastEvents = [];  <span class="hljs-comment">// &lt;--</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>) {
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$options.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">new</span> Vue() };  <font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$parent &amp;&amp; <span class="hljs-keyword">this</span>.$parent.$broadcast) { 
          <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span> = <span class="hljs-keyword">this</span>.$parent.$<span class="hljs-built_in">module</span>;
          <span class="hljs-keyword">this</span>.$broadcast = { <span class="hljs-attr">$bus</span>: <span class="hljs-keyword">this</span>.$parent.$broadcast.$bus };<font></font>
        } <font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$emit = <span class="hljs-function">(<span class="hljs-params">‚Ä¶attrs</span>) =&gt;</span> {
          <span class="hljs-keyword">this</span>.$broadcastEvents.push(attrs[<span class="hljs-number">0</span>]);   <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$emit(‚Ä¶attrs);           
          <span class="hljs-keyword">const</span> [event, ‚Ä¶attributes] = attrs; 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, ‚Ä¶attributes)); 
          <span class="hljs-keyword">this</span>.$rootBroadcast.$emit(‚Äò*‚Äô, event, <span class="hljs-keyword">this</span>.$<span class="hljs-built_in">module</span>, ‚Ä¶attributes)<font></font>
        };<font></font>
        <font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$on = <span class="hljs-function">(<span class="hljs-params">‚Ä¶attrs</span>) =&gt;</span> {           
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$on(‚Ä¶attrs);<font></font>
        };<font></font>
<font></font>
        <span class="hljs-keyword">this</span>.$broadcast.$off =: <span class="hljs-function">(<span class="hljs-params">...attrs</span>) =&gt;</span> {  <span class="hljs-comment">// &lt;--</span>
          <span class="hljs-keyword">this</span>.$broadcast.$bus.$off(...attrs);   <span class="hljs-comment">// &lt;--</span><font></font>
        };<font></font>
      }, <font></font>
    }); <font></font>
  }, <font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, this option provides a more interesting functionality, although less concise. </font><font style="vertical-align: inherit;">With it, you can implement a complete system of alternative communication between components. </font><font style="vertical-align: inherit;">Moreover, he is completely under our control and does not bring external dependencies into our project. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope that after reading you acquired or refreshed your knowledge of Vue plugins, and perhaps the next time you need to add some generic functionality to your application, you can implement it more efficiently - without adding external dependencies.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en488408/index.html">STM32 Ethernet-RS485 IoT Gateway</a></li>
<li><a href="../en488410/index.html">7 lessons that I learned in ten years in development</a></li>
<li><a href="../en488412/index.html">Creating a Discord bot based on discord.js</a></li>
<li><a href="../en488416/index.html">SLAE - Security Linux Assembly Expert Exam</a></li>
<li><a href="../en488418/index.html">REST API Authentication with Spring Security and MongoDB</a></li>
<li><a href="../en488424/index.html">What will happen to ITSM in 2020?</a></li>
<li><a href="../en488426/index.html">How to do a code review? Part 2: review navigation, speed, comments, conflicts</a></li>
<li><a href="../en488428/index.html">How do we predict the future in Yandex search: from bug fixes to discovery queries</a></li>
<li><a href="../en488432/index.html">Snoop Project an incredible tool for Internet intelligence, which RuNet users have been waiting for so long - is available</a></li>
<li><a href="../en488436/index.html">Quickly create open-source chiptune music</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>