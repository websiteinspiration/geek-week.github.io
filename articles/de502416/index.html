<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💌 ✨ ⛔️ SQL ergänzen. Teil 1. Die Komplexität des Parsens. Geschichten zum Finalisieren der ANTLR-Datei 🛎️ 🚒 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich veröffentliche den Originalartikel über Habr, dessen Übersetzung im Codingsight- Blog veröffentlicht ist .
 
 Was wird in diesem Artikel passieren...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SQL ergänzen. Teil 1. Die Komplexität des Parsens. Geschichten zum Finalisieren der ANTLR-Datei</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502416/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich veröffentliche den Originalartikel über Habr, dessen Übersetzung im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codingsight-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Blog veröffentlicht ist </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was wird in diesem Artikel passieren?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich arbeite seit mehr als fünf Jahren in der Firma, die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDE- </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Linie</font></a><font style="vertical-align: inherit;"> für die Arbeit mit Datenbanken entwickelt hat. Als ich mit der Arbeit an diesem Artikel begann, konnte ich mir nicht vorstellen, an wie viele interessante Geschichten ich mich erinnern konnte, denn als ich fertig war, bekam ich mehr als 30 Seiten Text. Nach einigem Nachdenken gruppierte ich die Geschichten nach Themen und teilte den Artikel in mehrere. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während ich veröffentliche, werde ich Links zu den folgenden Teilen hinzufügen: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1. Die Komplexität des Parsens. Geschichten zum Finalisieren von ANTLR mit einer Datei</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Teil 2. Optimierung der Arbeit mit Zeichenfolgen und Öffnen von Dateien </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teil 3. Lebensdauer der Erweiterungen für Visual Studio. Arbeite mit IO. Ungewöhnliche Verwendung von SQL </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teil 4. Arbeiten mit Ausnahmen, die Auswirkungen von Daten auf den Entwicklungsprozess. Verwenden von ML.NET</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während der Arbeit sind viele interessante Dinge passiert: Wir haben mehrere Fehler in .NET gefunden, einige Funktionen viele Male optimiert und einige nur in Prozent, beim ersten Mal etwas sehr Cooles getan und etwas, das uns selbst nach einigen nicht gelungen ist Versuche. </font><font style="vertical-align: inherit;">Mein Team entwickelt und unterstützt IDE-Sprachfunktionen, die wichtigste ist die Code-Vervollständigung. </font><font style="vertical-align: inherit;">Daher der Name der Artikelserie. </font><font style="vertical-align: inherit;">In jedem ihrer Teile werde ich verschiedene Geschichten erzählen: einige über Erfolge, einige über Misserfolge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil werde ich mich auf die Probleme beim Parsen von SQL, den Kampf gegen diese Probleme und die Fehler konzentrieren, die in diesem Kampf gemacht wurden.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hg/xl/vm/hgxlvmyga2eic3ul4c_i72mrxma.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für diejenigen, die nur an einem Teil davon interessiert sind und nur für eine einfache Navigation, ist der Inhalt des Artikels:</font></font><br>
<br>
<h3><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></u></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer ich bin?</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind die Schwierigkeiten?</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-Entwicklung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsen von SQL und Dialekten</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prädikatenkriege</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coole </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrrad</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Lösungen</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grammatikvererbung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Nachbearbeitung von ANTLR</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baumloses Parsen</font></font></a></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></a></li>
</ul><br>
<a name="Who"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wer ich bin?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich kam als Juni mit sehr wenig Erfahrung zu diesem Job. </font><font style="vertical-align: inherit;">Ich bin, wie viele, zum Programmieren gekommen, weil ich Spielzeug machen wollte. </font><font style="vertical-align: inherit;">Einige sogar recht erfolgreich gemacht. </font><font style="vertical-align: inherit;">Ich habe hier sogar über die Entwicklung eines </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solchen geschrieben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Vor kurzem hat er sie übrigens auf einem anderen Server wiederbelebt. Es gab immer noch ein Dutzend Spiele, die in verschiedenen Phasen der Bereitschaft gemacht oder abgebrochen wurden. Zusätzlich zu den Spielen konnte ich vor dieser Arbeit mehrere freiberufliche Projekte abschließen. Die größte davon war die Social-Media-Anwendung, ein Fußballportal mit Turniertischen, Spielerdaten und der Möglichkeit, Benutzer über das Endergebnis oder die erzielten Tore per SMS zu informieren. Dies wurde vor fast 10 Jahren getan. Zu dieser Zeit ging nicht jeder mit Smartphones, und wer früher häufiger ohne Internet oder mit der dreifach verfluchten EDGE war, auf der eine Textseite geöffnet werden konnte, war nicht immer möglich. Die Idee kam mir also gut vor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Irgendwie stellte sich heraus, dass ich neben Spielen auch andere Tunings für mich oder andere Entwickler erstellen wollte. Manchmal war er nah an dem, was ich etwas später bei der Arbeit tun musste. Eines der Projekte, die ich beim Studium der Win32-API durchgeführt habe, war beispielsweise ein Programm, das XML-Code in Rich Edit Control hervorhebt. Darüber hinaus war es möglich, hintergrundbeleuchteten Code in BMP-, HTML- oder BB-Codes hochzuladen, die damals in verschiedenen Foren in Mode waren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein anderes Projekt, das sich als verdammt nah an dem herausstellte, was ich gerade bei der Arbeit gemacht habe, war ein Programm, das C / C ++ - Code analysiert und daraus ein Blockdiagramm erstellt. Das Flussdiagramm entsprach genau den Anforderungen eines Lehrers an der Universität. Es wurde ungeschickt in der Stirn gemacht, ohne Kenntnis der Theorie der syntaktischen Analyse, und arbeitete ausschließlich an meinem beschissenen Charakter. Ein paar Jahre später, als ich den Computer von altem Müll </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">befreite</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , stolperte ich darüber und konnte ihn nicht entfernen. </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Deshalb habe</font></a><font style="vertical-align: inherit;"> ich ihn </font><font style="vertical-align: inherit;">aus Gründen der Geschichte </font><font style="vertical-align: inherit;">auf </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Github</font></a><font style="vertical-align: inherit;"> gepostet </font><font style="vertical-align: inherit;">.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Experimente, gepaart mit freiberuflichen Tätigkeiten, machten eine ziemlich gute Erfahrung und ermöglichten es, einen Job zu bekommen. </font><font style="vertical-align: inherit;">Im Laufe der Zeit, nach ein paar Dutzend in Blut und Tränen getränkten Bewertungen, fange ich sogar an, dem Unternehmen und dem Produkt zu nützen. </font><font style="vertical-align: inherit;">Umgekehrt ist es ziemlich lustig zu verstehen, dass ich nach mehreren Unfällen genau das tat, was mich anzog.</font></font><br>
<a name="difficulties"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Was sind die Schwierigkeiten?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Block wird benötigt, um den Leser in den Kontext dessen einzutauchen, was wir tatsächlich tun.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bp/sh/st/bpshstukfseasxycc6eyk1epb3s.jpeg"><br>
<a name="desktop"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desktop-Entwicklung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vielleicht ist dies nicht einmal Komplexität, weil es bereits ein sehr ausgereiftes Gebiet ist, in dem es nicht viel Unbekanntes gibt, die Bibliotheken stabil sind, Best-Practice bekannt ist. </font><font style="vertical-align: inherit;">Diese Funktion unseres Projekts ist hier, weil ich, wie viele andere Programmierer, anfällig für Neuheiten bin und Neuheiten jetzt alle im Web verschwunden sind. </font><font style="vertical-align: inherit;">Es gab Tage, an denen ich im Regen auf die Fensterbank kletterte, bedeckt mit einer Decke, mit einem Becher Kakao, und über Redis, Reagieren, Hochladen und verteilte Systeme nachdachte, die gerade irgendwo ohne mich entwickelt werden. </font><font style="vertical-align: inherit;">Die andere Seite dieses Problems ist, dass es nicht einfach ist, vertrauten Entwicklern die Komplexität des Projekts bei Bier zu beschreiben. Wenn Sie an Anwendungen arbeiten, die nach grundlegend unterschiedlichen Gesetzen arbeiten, wird es noch schwieriger.</font></font><br>
<br>
<a name="dialects"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parsen von SQL und Dialekten</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe vor dieser Arbeit auch kleine Parser für verschiedene Sprachen geschrieben. Für einige Zeit unterrichtete ich .NET-Kurse. Für einige Gruppen wurde als zusätzliche Aufgabe im Rahmen des Themas "Zeichenfolge" vorgeschlagen, einen eigenen einfachen JSON-Parser zu schreiben. Nur SQL und seine Varianten sind weit entfernt von XML oder JSON, die für Parser und Benutzer gleichermaßen verständlich sind. Darüber hinaus ist SQL syntaktisch komplexer als C / C ++, da sich viele Funktionen über einen langen Zeitraum angesammelt haben. SQL ist anders strukturiert, sie haben versucht, es übrigens recht erfolgreich wie eine natürliche Sprache aussehen zu lassen. Die Sprache hat mehrere tausend (je nach Dialekt) Schlüsselwörter. Um einen Ausdruck von einem anderen zu unterscheiden, müssen Sie häufig zwei oder mehr Wörter (Token) nach vorne schauen. Dieser Ansatz wird Lookahead genannt. Es gibt eine Klassifizierung der Parser nachWie weit sie vorausschauen können: LA (1), LA (2) oder LA (*), was bedeutet, dass der Parser so weit nach vorne schauen kann, wie er kann, um den richtigen Zweig zu bestimmen. Manchmal fällt das optionale Ende einer Klausel in einer SQL-Anweisung mit dem Beginn einer anderen zusammen, was ebenfalls optional ist: Solche Situationen machen Parser viel komplizierter. T-SQL schüttet Wasser in das Feuer, in dem das Semikolon optional ist, und das mögliche, aber nicht obligatorische Ende einiger SQL-Anweisungen kann mit dem Anfang anderer in Konflikt stehen.Solche Situationen erschweren Parser erheblich. T-SQL schüttet Wasser in das Feuer, in dem das Semikolon optional ist, und das mögliche, aber nicht obligatorische Ende einiger SQL-Anweisungen kann mit dem Anfang anderer in Konflikt stehen.Solche Situationen erschweren Parser erheblich. T-SQL schüttet Wasser in das Feuer, in dem das Semikolon optional ist, und das mögliche, aber nicht obligatorische Ende einiger SQL-Anweisungen kann mit dem Anfang anderer in Konflikt stehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immer noch nicht glauben? Es gibt einen Mechanismus zur Beschreibung formaler Sprachen durch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grammatiken</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Grammatik ist ein Code in einer Sprache, der eine andere beschreibt. Aus einer Grammatik können Sie häufig einen Parser mit einem Tool generieren. Die bekanntesten Grammatikbeschreibungswerkzeuge und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-sprachen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sind </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">YACC</font></a><font style="vertical-align: inherit;"> und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Von YACC generierte Parser werden direkt in den </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MariaDB-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">PostgreSQL-</font></a><font style="vertical-align: inherit;"> Engines verwendet</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Sie könnten versuchen, sie direkt aus Open Source zu übernehmen und Code-Vervollständigung und andere Funktionen basierend auf der darauf basierenden SQL-Analyse zu entwickeln. Darüber hinaus würde eine solche Implementierung kostenlose Aktualisierungen in Bezug auf die Entwicklung erhalten, und der Parser würde sich garantiert so verhalten, dass er mit dem Datenbankmodul identisch ist. Warum verwenden wir ANTLR? Es unterstützt qualitativ C # /. NET, es gibt gute Werkzeuge, um damit zu arbeiten, seine Syntax ist viel einfacher zu lesen und zu schreiben. Die ANTLR-Syntax erwies sich als so praktisch, dass Microsoft sie kürzlich in der offiziellen </font><font style="vertical-align: inherit;">C # </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Dokumentation verwendet hat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kehren wir zu meinem Beweis der Komplexität von SQL im Vergleich zu anderen Sprachen in Bezug auf das Parsen zurück. Dazu möchte ich die Grammatikgrößen für verschiedene öffentlich verfügbare Sprachen vergleichen. In dbForge verwenden wir unsere eigenen Grammatiken. Sie sind vollständiger als die öffentlich verfügbaren, aber leider sehr verstopft mit C # -Code-Einfügungen, um verschiedene Funktionen zu unterstützen. Weitere Informationen hierzu finden Sie im Abschnitt „Parsen ohne Bäume“ im Abschnitt „Fehler“. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachfolgend sind die Grammatikgrößen für verschiedene Sprachen aufgeführt: </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 475 Zeilen Parser + 273 Lexer = 748 Zeilen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 615 Zeilen Parser + 211 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 826 Zeilen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C #</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1159 Zeilen Parser + 433 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1592 Zeilen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1933 Zeilen </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MySQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 2515 Zeilen Parser + 1189 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 3704 Zeilen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T-SQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 4035 Zeilen Parser + 896 Zeilen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 4931 Zeilen </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PL SQL</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 6719 Zeilen Parser + 2366 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lexer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 9085 Zeilen </font><i><font style="vertical-align: inherit;">Am Ende einiger </font></i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Lexer </font></a></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">steht eine Aufzählung von Unicode-Zeichen in der Sprache zur Verfügung Einschätzung der Komplexität der Sprache. Ich habe die Anzahl der Zeilen genommen, bevor ich mit solchen Übertragungen begonnen habe. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kann Fragen zur Komplexität des Parsens einer Sprache geben, die auf der Anzahl der Zeilen in ihrer Grammatik basiert. Fragen können sich auch auf die Fülle offener Grammatiken im Vergleich zur tatsächlichen Syntax von Sprachen beziehen. Trotzdem halte ich es immer noch für nützlich, diese Zahlen anzugeben, da der Spread zu groß ist.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist nicht alles, da wir nicht nur mehrere Dateien in SQL analysieren müssen. Wir machen eine IDE, was bedeutet, dass wir an unvollständigen oder ungültigen Skripten arbeiten müssen. Selbst wenn Sie Ihre Skripte fehlerfrei schreiben, schreiben Sie sie möglicherweise inkonsistent. Es ist unwahrscheinlich, dass das Skript während des gesamten Entwicklungsprozesses gültig ist. Zum Beispiel schreibe ich zuerst "SELECT FROM", danach freue ich mich über die Liste der verfügbaren Tabellen. Wenn ich eine Tabelle auswähle, ordne ich den Wagen auf SELECT um, drücke die Leertaste und warte auf die Liste der Spalten aus dieser bestimmten Tabelle. Dies ist ein sehr einfaches Beispiel, aber es zeigt, dass der Parser, der die Code-Vervollständigung in der IDE bereitstellt, nicht abstürzen kann, außer wenn ein ungültiges Skript auftritt. Wir mussten uns viele Tricks einfallen lassen, um sicherzustellen, dass der Tooltip in vielen solchen Szenarien korrekt funktioniert.Benutzer senden jedoch immer noch unterschiedliche Szenarien für die Arbeit mit unvollendeten Skripten, was bedeutet, dass wir uns neue Tricks einfallen lassen müssen.</font></font><br>
<a name="predicates"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prädikatenkriege</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Parsen des Codes gibt es manchmal Situationen, in denen das nächste Wort nicht klar macht, welche der beiden Alternativen zu wählen ist. </font><font style="vertical-align: inherit;">Manchmal reicht es aus, im Voraus eine genau definierte Anzahl von Wörtern zu betrachten, und Sie können definitiv eine Alternative auswählen. </font><font style="vertical-align: inherit;">Der Mechanismus zur Behebung dieser Art von Ungenauigkeit wird als ANTLR-Lookahead bezeichnet. </font><font style="vertical-align: inherit;">Die Parser-Methode ist in diesem Fall als eingebettete Kette von ifs aufgebaut, von denen jede ein Wort weiter schaut. </font><font style="vertical-align: inherit;">Nachfolgend finden Sie ein Beispiel für eine Grammatik, die eine solche Unsicherheit erzeugt.</font></font><br>
<br>
<pre><code class="lisp hljs">rule1:<font></font>
    'a' rule2 | rule3<font></font>
    <span class="hljs-comment">;</span><font></font>
<font></font>
rule2:<font></font>
    'b' 'c' 'd'<font></font>
    <span class="hljs-comment">;</span><font></font>
<font></font>
rule3:<font></font>
    'b' 'c' 'e'<font></font>
    <span class="hljs-comment">;</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Mitte von Regel 1 muss der Parser, nachdem er bereits das Token 'a' übergeben hat, 2 Token vorausschauen, um zu entscheiden, welcher Regel er folgen soll. Diese Überprüfung wird erneut innerhalb der Regel durchgeführt. Diese Grammatik kann so umgeschrieben werden, dass dieser Lookahead nicht existiert. Leider leidet die Struktur häufig unter solchen Optimierungen, und der Leistungsgewinn ist relativ hoch. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt komplexere Mechanismen, um komplexere Unsicherheiten aufzulösen. Einer davon ist der Syntaxprädikatmechanismus (synpred) in ANTLR3.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Er kommt zur Rettung in den Fällen, in denen sich beispielsweise die optionale Vervollständigung einer Klausel mit dem Beginn der optionalen anderen Klausel überschneidet. </font><font style="vertical-align: inherit;">Das Prädikat ist in ANTLR3-Begriffen die generierte Methode, die gemäß einer der Alternativen eine virtuelle Passage durch den Text durchführt und bei Erfolg true zurückgibt. Diese Vervollständigung des Prädikats wird als erfolgreich bezeichnet. </font><font style="vertical-align: inherit;">Der virtuelle Pass wird auch als Backtracking-Pass bezeichnet. </font><font style="vertical-align: inherit;">Wenn das Prädikat erfolgreich funktioniert hat, wird ein echter Pass erstellt. </font><font style="vertical-align: inherit;">Dies wird zu einem Problem, wenn ein anderes Prädikat innerhalb eines Prädikats beginnt und ein Abschnitt hunderttausend Mal durchlaufen werden kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie ein vereinfachtes Beispiel. </font><font style="vertical-align: inherit;">Es gibt 3 Unsicherheitspunkte (A, B, C).</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Parser gibt A ein, merkt sich die Position im Text und beginnt eine virtuelle Passage der 1. Ebene.</font></font></li>
<li>   B,    ,    2- .</li>
<li>   C,    ,    3- .</li>
<li>     3- ,   2    .</li>
<li>     2 ,   1   B   .</li>
<li>    ,       A, B  .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit werden alle Überprüfungen innerhalb von C 4 Mal, B - 3 Mal, A - 2 Mal durchgeführt. Was aber, wenn die geeignete Alternative an zweiter oder dritter Stelle in der Liste steht? Dann schlägt irgendwann eines der Prädikate fehl, die Position im Text wird zurückgesetzt und ein anderes Prädikat wird ausgeführt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei wiederholter Analyse der Ursache für das Einfrieren der Anwendung stießen wir auf Fälle, in denen der synpred „Schwanz“ mehrere tausend Mal ausgeführt wurde. Synpreds sind in rekursiven Regeln besonders problematisch. Leider ist SQL von Natur aus rekursiv, was zumindest die Fähigkeit ist, eine Unterabfrage fast überall zu verwenden. Manchmal stellt sich mit Hilfe verschiedener Tricks und Tricks heraus, dass die Regel so ausfällt, dass das Prädikat verschwunden ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Synpred wirkt sich natürlich negativ auf die Leistung aus. Irgendwann war es notwendig, ihre Bevölkerung unter strenge Kontrolle zu bringen. Das einzige Problem ist, dass beim Schreiben von Grammatikcode das Erscheinungsbild von Synpred möglicherweise nicht offensichtlich ist. Darüber hinaus führt manchmal eine Änderung einer Regel zum Auftreten eines Prädikats in einer anderen. Dies kann nicht manuell gesteuert werden. Um die Anzahl der Prädikate zu steuern, haben wir einen einfachen Regular geschrieben, der von einer speziellen MsBuild-Task aufgerufen wurde. Wenn sich die Anzahl der Prädikate von der in einer separaten Datei angegebenen Anzahl unterschied, unterbrach Task die Assembly und meldete einen Fehler. Als der Entwickler einen solchen Fehler bemerkte, musste er den Regelcode mehrmals umschreiben, um unnötige Prädikate zu entfernen und möglicherweise andere Entwickler in das Problem einzubeziehen. Wenn ein Prädikat unvermeidlich ist,Anschließend aktualisiert der Entwickler die Anzahl der Prädikate in der entsprechenden Datei. Eine Änderung dieser Datei macht besonders auf die Überprüfung aufmerksam.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In seltenen Fällen haben wir sogar unsere eigenen Prädikate in C # geschrieben, um die von ANTLR generierten zu umgehen. </font><font style="vertical-align: inherit;">Glücklicherweise gibt es auch einen solchen Mechanismus.</font></font><br>
<a name="bikes"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coole </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fahrrad</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Lösungen</font></font></h2><br>
<img src="https://habrastorage.org/webt/r2/sr/zk/r2srzksxi_3aseqm2bv50nwjfby.jpeg"><br>
<a name="inheritance"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grammatikvererbung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Ankündigung von Änderungen in jedem von uns unterstützten DBMS beginnt unsere Arbeit, diese zu unterstützen. Der Ausgangspunkt dafür ist fast immer die Unterstützung syntaktischer Konstruktionen in der Grammatik. Für jeden SQL-Dialekt schreiben wir unsere eigene Grammatik. Dies führt zu einer gewissen Wiederholung des Codes, aber letztendlich ist es einfacher, nach einer gemeinsamen Grammatik zu suchen. Noch vor ein paar Jahren waren sich MySQL und MariaDB sehr ähnlich, das Schreiben separater Grammatiken war unpraktisch. Da diese wenigen Konstruktionen in MariaDB, aber nicht in MySQL enthalten waren, haben wir sie in der MySQL-Grammatik unterstützt. Dies war ein unangenehmer Moment: Für den MySQL-Benutzer könnten wir Konstrukte vorschlagen, die nicht gültig sind. In den letzten Jahren sind MariaDB und MySQL in Bezug auf Syntax und mehr sehr unterschiedlich geworden. Es wurde offensichtlichdass es falsch ist, zwei verschiedene Sprachen innerhalb derselben Grammatik zu unterstützen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine mögliche Lösung könnte eine vollständige Kopie der Grammatik sein, nach der jede separat unterstützt wird. Nach einer langen Diskussion haben wir eine mutige Entscheidung getroffen. Ich bin sehr froh, dass wir den Code nicht kopiert haben, jede Zelle in mir hat sich dieser Entscheidung widersetzt. Es wurde beschlossen, einen eigenen Grammatik-Präprozessor ANTLR zu schreiben, der den Mechanismus der Grammatik-Vererbung implementiert. Vor einiger Zeit bin ich auf eine ANTLR3-Grammatik im offiziellen Repository von ANTLR4-Grammatiken gestoßen. Ich denke, dieser Satz muss mehrmals gelesen werden, um die Tiefe des Wahnsinns zu erkennen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als wir die Idee der Vererbung diskutierten, wurde uns schnell klar, dass wir einen Mechanismus für Polymorphismus haben möchten. Die Fähigkeit in der Grammatik des Erben, nicht nur die Regel neu zu definieren, sondern auch die Basis zu nennen. Außerdem möchte ich die Position des Aufrufs der Grundregel steuern: Anfang, Mitte oder Ende. Wir haben beschlossen, dass alle Regeln neu definiert werden können, dafür müssen Sie nichts weiter angeben. Um eine Regel neu zu definieren, reicht es aus, eine gleichnamige Regel in der Nachfolgegrammatik zu deklarieren. Danach steht die Regel aus der übergeordneten Grammatik unter einem anderen Namen zur Verfügung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ANTLR ist ein angenehmes Werkzeug für die Entwicklung durch Tuning - es gibt eine Erweiterung für VS, es gibt ANTLRWorks. Durch die Einführung des Vererbungsmechanismus möchte ich diese Gelegenheit nicht verpassen. Aber wie soll man dann die grundlegende Grammatik angeben? Sie können sich eine Art Konvention für die Benennung von Dateien einfallen lassen, aber dies ist überhaupt nicht offensichtlich. Eine andere Möglichkeit könnte darin bestehen, solche zusätzlichen Informationen in einer separaten Datei anzugeben, aber selbst jetzt, als ich diese Zeilen tippte, spürte ich den Gestank dieser Lösung. Die Ausgabe war ein Hinweis auf die grundlegende Grammatik in der Grammatik des Erben im Format eines ANTLR-Kommentars. Alle Tools ignorieren diesen Text einfach und wir können den Code, der uns interessiert, leicht herausziehen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Anforderungen wurden gebildet, es ist Zeit, sie umzusetzen. Wir haben die MsBuild-Task geschrieben, die als Pre-Build-Aktion in das allgemeine Build-System integriert wurde. Die Aufgabe führte die Arbeit des ANTLR-Grammatikpräprozessors aus, wobei die resultierende Grammatik aus der Basis generiert und geerbt wurde. Die resultierende Grammatik wurde bereits von ANTLR selbst verarbeitet. Wenn in der Nachfolgegrammatik eine Regel mit demselben Namen wie im übergeordneten Element gefunden wurde, wurde die Grundregel umbenannt: Der Name der übergeordneten Grammatik wurde nach dem Unterstrich zu ihrem Namen hinzugefügt. Unter diesem Namen konnte er im Erben kontaktiert werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Präprozessormechanismus selbst nahm nicht viel Zeit in Anspruch, aber zusammen mit der Generierung des Parsers stellte sich heraus, dass er jeden Zusammenbau des Projekts um 10 bis 20 Sekunden verlangsamte. </font><font style="vertical-align: inherit;">Irgendwann hörte das auf, uns zu passen. </font><font style="vertical-align: inherit;">Wir haben uns überlegt, wie dies optimiert werden kann. </font><font style="vertical-align: inherit;">Die Lösung bestand darin, den Hash der Summe aller Grammatiken, von denen er abhängt, in Form eines Kommentars zum Header der CS-Parser-Datei hinzuzufügen. </font><font style="vertical-align: inherit;">Bevor etwas unternommen wurde, verglich der Präprozessor diese Hashes mit den Hashes der Dateien auf der Festplatte. Wenn sie sich nicht unterscheiden, wurde die Parser-Datei als relevant angesehen. </font><font style="vertical-align: inherit;">In der anfänglichen Entwicklungsphase mussten wir mehr als einmal auf den Rechen ungültiger Parser und Grammatiken treten, die von der veralteten Version des Präprozessors gesammelt wurden. </font><font style="vertical-align: inherit;">Infolgedessen wurde die Hash-Summe der Assembly mit dem Präprozessor im Header-Kommentar angezeigt.</font></font><br>
<a name="postprocessing"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine weitere Nachbearbeitung von ANTLR</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in vielen Programmiersprachen das Wort der Schlüssel ist, kann es nicht mehr als Name des Objekts verwendet werden. In SQL je nach Dialekt 800 bis 3000 Schlüsselwörter. Die meisten von ihnen sind eng mit dem Themenbereich verwandt, außerdem wurden nicht alle sofort eingeführt, sodass ein Verbot, sie alle als Objektnamen zu verwenden, mit Empörung einhergehen würde. SQL führt das Konzept der reservierten und nicht reservierten Schlüsselwörter ein. Sie können ein Objekt nicht wie ein reserviertes Schlüsselwort (SELECT, FROM usw.) benennen, ohne es in Anführungszeichen zu setzen, da es kein reserviertes Schlüsselwort (CONVERSATION, AVAILABILITY usw.) ist. Dieses Verhalten erschwert die Entwicklung des Parsers. Zum Zeitpunkt der lexikalischen Analyse ist der Kontext unbekannt, der Parser benötigt jedoch unterschiedliche Nummern für den Bezeichner und das Schlüsselwort. Um dieses Problem zu lösen, haben wir dem ANTLR-Parser eine weitere Nachbearbeitung hinzugefügt.Die Nachbearbeitung ersetzt alle expliziten Prüfungen durch einen Bezeichner und ruft eine spezielle Methode auf. Diese Methode implementiert eine schwierigere Prüfung. Wenn ein Bezeichner eingegeben wird und ein Bezeichner weiter erwartet wird, ist alles in Ordnung. Wenn jedoch ein nicht reserviertes Schlüsselwort für die Eingabe angegeben wird, muss es zusätzlich überprüft werden. Eine zusätzliche Überprüfung besteht darin, dass die Methode im aktuellen Kontext bei der Suche nach Zweigen untersucht wird, wobei dieses nicht reservierte Schlüsselwort genau als Schlüsselwort verwendet werden kann. Wenn es keine solchen Zweige gibt, kann es als Bezeichner verwendet werden.Wenn jedoch ein nicht reserviertes Schlüsselwort eingegeben wird, muss es zusätzlich überprüft werden. Eine zusätzliche Überprüfung besteht darin, dass die Methode im aktuellen Kontext bei der Suche nach Zweigen untersucht wird, wobei dieses nicht reservierte Schlüsselwort genau als Schlüsselwort verwendet werden kann. Wenn es keine solchen Zweige gibt, kann es als Bezeichner verwendet werden.Wenn jedoch ein nicht reserviertes Schlüsselwort eingegeben wird, muss es zusätzlich überprüft werden. Eine zusätzliche Überprüfung besteht darin, dass die Methode im aktuellen Kontext bei der Suche nach Zweigen untersucht wird, wobei dieses nicht reservierte Schlüsselwort genau als Schlüsselwort verwendet werden kann. Wenn es keine solchen Zweige gibt, kann es als Bezeichner verwendet werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau genommen kann dieses Problem nur mit ANTLR gelöst werden, aber eine solche Lösung ist nicht optimal. </font><font style="vertical-align: inherit;">Eine klassische Lösung für dieses Problem besteht darin, eine Regel zu erstellen, in der alle nicht reservierten Schlüsselwörter und ein Bezeichner-Token aufgelistet sind. </font><font style="vertical-align: inherit;">Wo immer es zulässig ist, einen Bezeichner zu verwenden, wird das Bezeichner-Token des Bezeichners nicht mehr verwendet, dies ist jedoch eine Sonderregel. </font><font style="vertical-align: inherit;">Eine solche Lösung erinnert Sie nicht nur daran, das Schlüsselwort bei der Eingabe hinzuzufügen, nicht nur dort, wo es verwendet wird, sondern auch in dieser Sonderregel viel langsamer.</font></font><br>
<a name="mistakes"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fehler</font></font></h2><br>
<a name="trees"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baumloses Parsen</font></font></h3><br>
<img src="https://habrastorage.org/webt/g1/ty/qw/g1tyqwxs43omgbkeozhr5ygvxw0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Ergebnis des Parsers ist in der Regel ein Syntaxbaum. </font><font style="vertical-align: inherit;">Ein Syntaxbaum ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abstrakt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konkret</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ist eine Datenstruktur, die den Programmtext durch das Prisma der formalen Grammatik widerspiegelt. </font><font style="vertical-align: inherit;">Wenn Sie einen Code-Editor mit automatischer Vervollständigung für die Sprache implementieren möchten, die Sie kürzlich entwickelt haben, nachdem Sie das Problem untersucht haben, implementieren Sie wahrscheinlich ungefähr den folgenden Algorithmus:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysieren Sie den Text im Editor. </font><font style="vertical-align: inherit;">Holen Sie sich den Syntaxbaum.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finde den Knoten unter dem Wagen. </font><font style="vertical-align: inherit;">Ordne es der Grammatik zu. </font><font style="vertical-align: inherit;">Finden Sie heraus, welche Schlüsselwörter und Objekttypen zu diesem Zeitpunkt verfügbar sein werden.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Fall wird die Grammatik bequem als Graph oder Finite-State-Maschine dargestellt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider existierte die IDE ANTLR zu Beginn der Entwicklung in ihrer dritten Version. Die vierte Version wurde von Grund auf neu geschrieben und unterscheidet sich grundlegend von der dritten. Durch Übergeben des Codes generiert der Parser automatisch einen Analysebaum ohne eine einzige zusätzliche Zeile. In der dritten Version gab es einen Mechanismus, mit dem man ANTLR sagen konnte, wie man einen Baum baut, aber es war nicht sehr angenehm, ihn zu benutzen. Darüber hinaus wurde in vielen Beispielen und Artikeln zu diesem Thema vorgeschlagen, den Aktionsmechanismus zum Ausführen von Code zu verwenden, sobald der Parser die Regel übergibt. Dieser Mechanismus ist unglaublich praktisch und ermöglicht es Ihnen, schnell Ergebnisse zu erzielen. Leider führte diese Lösung zu großen architektonischen Problemen bei der Entwicklung des Produkts und zu einer zunehmenden Komplexität der Unterstützung neuer Funktionen. Tatsache ist, dass in einer Datei, in einer Grammatikdatei,Es häuften sich Aktionen, die mit einer großen Anzahl unterschiedlicher Funktionen verbunden waren, die sich auf verschiedene Baugruppen verteilen ließen. In Zukunft konnten wir die Aktionshandler für verschiedene Assemblys verteilen, indem wir eine ziemlich knifflige Version des Abonnenten-Benachrichtigungsmusters implementierten. Die Aufrufe selbst, die die erforderlichen Informationen übermitteln, überladen jedoch weiterhin unsere Grammatik, erschweren die Unterstützung neuer Funktionen und legen der Architektur schwerwiegende und unangenehme Einschränkungen auf.erschweren die Unterstützung neuer Funktionen und legen der Architektur schwerwiegende und unangenehme Einschränkungen auf.erschweren die Unterstützung neuer Funktionen und legen der Architektur schwerwiegende und unangenehme Einschränkungen auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber alles ist nicht so offensichtlich, wie es scheinen mag. </font><font style="vertical-align: inherit;">Tatsache ist, dass ANTLR3 viel schneller ist als ANTLR4. </font><font style="vertical-align: inherit;">Nach unseren Messungen betragen die Unterschiede etwa das 6-fache. </font><font style="vertical-align: inherit;">Darüber hinaus kann der Syntaxbaum für große Skripte viel RAM-Speicherplatz beanspruchen. Solange wir im 32-Bit-Adressraum von Visual- und SqlServer Management-Studios überleben müssen, kann dies von entscheidender Bedeutung sein.</font></font><br>
<a name="end"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zwischensummen können wie folgt sein:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR ist ein leistungsstarkes Tool zum Erstellen von Parsern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Vorteil gegenüber anderen sind Tools, eine praktische Syntax und eine große Anzahl unterstützter Sprachen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANTLR4 wurde von Grund auf neu geschrieben und impliziert die Arbeit mit dem Parser, der sich von der dritten Version unterscheidet</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt immer eine Möglichkeit, ein bisschen mehr aus ThirdParty-Bibliotheken herauszuholen, als sie geben</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL-spezifische Sprache, Parser dafür zu erstellen, ist keine leichte Aufgabe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Parsen von Code für Aufgaben im Zusammenhang mit dem Erstellen einer IDE hat seine eigenen Besonderheiten: Sie müssen in Betracht ziehen, an Skripten zu arbeiten, die nicht geschlossen oder ungültig sind</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir sehen uns im nächsten Teil!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de502406/index.html">Antiquitäten: Ein zweiter Ansatz für VHS, Hi-Fi-Stereo und Soapy-Video</a></li>
<li><a href="../de502408/index.html">Fälschungen und Verschwörungstheorien. Wie kann man nicht selbst verrückt werden und andere retten?</a></li>
<li><a href="../de502410/index.html">29. erfolgreicher Start des Jahres. USA. Militärstart. "Raumflugzeug" X-37</a></li>
<li><a href="../de502412/index.html">Guilloche auf eine andere Art und Weise</a></li>
<li><a href="../de502414/index.html">FOSS News Nr. 16 - eine Überprüfung der freien und Open-Source-Software für den 11. bis 17. Mai 2020</a></li>
<li><a href="../de502418/index.html">3D-Bildmonitor</a></li>
<li><a href="../de502420/index.html">Interessante CSS-Funde im Twitter-Design</a></li>
<li><a href="../de502432/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 415 (11.-17. Mai 2020)</a></li>
<li><a href="../de502436/index.html">CI TeamCity - Automatisierung von Build-Prozessen für Android- und UI-Tests</a></li>
<li><a href="../de502438/index.html">Material Python. Benutzerdefinierte Karten mit OpenGL-Effekten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>