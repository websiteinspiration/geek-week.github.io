<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏼‍💼 👾 🚀 レイマーチング距離フィールド：Unityでの説明と実装 ⬅️ 💪🏻 🆓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="レイマーチングは、リアルタイムシーンのレンダリングに使用されるかなり新しい手法です。これは、画面スペースのシェーダーで完全に計算されるため、特に興味深いものです。つまり、レンダラーはこれらのメッシュにアクセスできず、シーンはカメラの可視領域全体をカバーする単一の四角形に描画されます。シーン内のオブジ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>レイマーチング距離フィールド：Unityでの説明と実装</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503554/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/244/286/4a4/2442864a40f38cd658275532f8841522.png" alt="画像"></div><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイマーチング</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、リアルタイムシーンのレンダリングに使用されるかなり新しい手法です。これは、画面スペースのシェーダーで完全に計算されるため、特に興味深いものです。つまり、レンダラーはこれらのメッシュにアクセスできず、シーンはカメラの可視領域全体をカバーする単一の四角形に描画されます。シーン内のオブジェクトは、シーン内のすべてのオブジェクトのポイントとサーフェスの間の最短距離を表す分析方程式によって定義されます（したがって、この手法は</font><em><font style="vertical-align: inherit;">レイマーチング距離フィールド</font></em><font style="vertical-align: inherit;">と呼ばれ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）この情報だけでも、驚くほど複雑で美しいシーンを作成できることがわかりました。さらに、ポリゴンメッシュを使用しない（そして数式が代わりに使用される）ため、ここでは、従来のレンダラーとは異なり、完全に滑らかなサーフェスを設定できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2f/07d/4dd/e2f07d4dd3aaf8e405a67376f828cfb2.png"></div><br>
<i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カタツムリ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inigo Kilezaは、レイマーチングを使用して完全に作成されました。</font><font style="vertical-align: inherit;">レイマーチングシーンの他の例は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadertoyにあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、最初にレイマーチングの基本的な概念と理論について説明し、次にUnityゲームエンジンで最も単純なレイマーチャーを実装する方法を示します。</font><font style="vertical-align: inherit;">次に、レイマーチのオブジェクトを通常のゲームオブジェクトとオーバーラップさせて、実際のUnityゲームでレイマーチを練習する方法を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なコードは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このGithubリポジトリにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raymarchingの概要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイマーチングは、光線が各ピクセルのシーンに放出されるという点で、従来のレイトレーシングに似ています。レイトレーサーには、レイとレンダリングされたオブジェクトの交差を決定する一連の方程式があります。これにより、ビームが交差するオブジェクト（つまり、カメラが見るオブジェクト）を見つけることができます。また、この方法では、球と光線の式を知るだけで十分なので、球などの非多角形オブジェクトをレンダリングすることができます。ただし、レイトレーシングは非常にコストがかかります。特に、シーンに多くのオブジェクトがあり、複雑な照明がある場合は特にそうです。さらに、雲や水などのバルク材料を通過する光線を追跡することはできません。したがって、レイトレーシングがリアルタイムアプリケーションの要件を満たすことはほとんどありません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/8e5/da6/c218e5da67dd1204cfc4cf352de53332.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図1：レイトレーサーの簡略図。</font><font style="vertical-align: inherit;">太い黒線は、ピクセルをレンダリングするためにカメラから放射される光線の例です。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイマーチングは、光線とオブジェクトが交差する問題を解決する別の方法を提供します。</font><font style="vertical-align: inherit;">Raymarchingは、この交差を分析的に直接計算することを試みません。</font><font style="vertical-align: inherit;">これにより</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ポイントがオブジェクトと交差する場所が見つかるまで、レイに沿ってポイントを「ステップ」します</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ビームに沿ってこのポイントをサンプリングすることは、比較的単純で低コストの操作であり、リアルタイムではるかに実用的であることがわかります。</font><font style="vertical-align: inherit;">図2からわかるように、この方法はレイトレーシングほど正確ではありません（よく見ると、交点が少しずれていることがわかります）。</font><font style="vertical-align: inherit;">ただし、ゲームに適しているだけでなく、ポリゴンレンダリングの効率と従来のレイトレーシングの精度との間の大きな妥協点です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9b2/562/4f9/9b25624f940dc7cbd740977ea20d0037.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図2：ステップ間隔が固定されたレイマーチング関数（レイマーチャーと呼ばれる）の簡単な実装。</font><font style="vertical-align: inherit;">赤い点はすべてのサンプルポイントを示します。</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離フィールド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、図2に示すように、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間隔</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が</font><em><font style="vertical-align: inherit;">固定され</font></em><font style="vertical-align: inherit;">たレイマーチング関数</font><font style="vertical-align: inherit;">は、ボリュームのある透明な表面など、多くのアプリケーションに十分対応できます。</font><font style="vertical-align: inherit;">ただし、不透明なオブジェクトの場合は、別の最適化を導入できます。</font><font style="vertical-align: inherit;">この最適化では、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">符号付き距離フィールドを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用する必要があり</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。</font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離フィールド</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、入力でポイントを受け取り、このポイントからシーン内の各オブジェクトの表面までの最短距離を返す関数です</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><em><font style="vertical-align: inherit;">符号付き</font></em><font style="vertical-align: inherit;">距離フィールド</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイントがオブジェクト内にある場合、さらに負の数を返します。</font><font style="vertical-align: inherit;">距離フィールドは、ビームに沿ってレイマーチするときにサンプルの数を制限できるため、優れたツールです。</font><font style="vertical-align: inherit;">例を見る：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b91/a1f/2fd/b91a1f2fd7a2b0255f955b1690de350e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図3：符号付き距離フィールドを使用したレイマーチャーの視覚化。</font><font style="vertical-align: inherit;">赤い点はすべてのサンプルポイントを示します。</font><font style="vertical-align: inherit;">青い円は、オブジェクトが含まれていないことが保証されている領域を示します（距離フィールド関数の結果に含まれるため）。</font><font style="vertical-align: inherit;">緑の破線は、各サンプルポイントとシーンの間の真の最短ベクトルを示しています。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、距離フィールドを使用すると、ビームに沿って各ステップで最大距離に移動できます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も単純なレイマーチャーの実装</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイマーチングアルゴリズムは各ピクセルに対して実行されるため、Unityのレイマーチャーは基本的に後処理シェーダーになります。</font><font style="vertical-align: inherit;">このため、ここで作成するC＃コードの大部分は、フルスクリーンイメージ効果に使用したものと似ています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像効果スクリプトの準備</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な画像効果をロードするスクリプトを実装しましょう。</font><font style="vertical-align: inherit;">注：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SceneViewFilter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリプトを使用して</font><font style="vertical-align: inherit;">、シーンモードで画像フィルターを自動的に適用します。</font><font style="vertical-align: inherit;">これにより、シェーダーのデバッグが簡単になります。</font><font style="vertical-align: inherit;">これを使用するには、代わりに画像効果スクリプト</font></font><code>MonoBehaviour</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を展開する必要があります</font></font><code>SceneViewFilter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ボイラープレートコードに悩まされないように、最も単純なイメージ効果のスクリプトを以下に示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> System.Collections;<font></font>
<font></font>
[<span class="hljs-meta">ExecuteInEditMode</span>]<font></font>
[<span class="hljs-meta">RequireComponent(typeof(Camera))</span>]<font></font>
[<span class="hljs-meta">AddComponentMenu(<span class="hljs-meta-string">"Effects/Raymarch (Generic)"</span>)</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TutorialRaymarch</span> : <span class="hljs-title">SceneViewFilter</span> {<font></font>
<font></font>
    [<span class="hljs-meta">SerializeField</span>]
    <span class="hljs-keyword">private</span> Shader _EffectShader;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> Material EffectMaterial<font></font>
    {<font></font>
        <span class="hljs-keyword">get</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (!_EffectMaterial &amp;&amp; _EffectShader)<font></font>
            {<font></font>
                _EffectMaterial = <span class="hljs-keyword">new</span> Material(_EffectShader);<font></font>
                _EffectMaterial.hideFlags = HideFlags.HideAndDontSave;<font></font>
            }<font></font>
<font></font>
            <span class="hljs-keyword">return</span> _EffectMaterial;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">private</span> Material _EffectMaterial;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> Camera CurrentCamera<font></font>
    {<font></font>
        <span class="hljs-keyword">get</span><font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (!_CurrentCamera)<font></font>
                _CurrentCamera = GetComponent&lt;Camera&gt;();<font></font>
            <span class="hljs-keyword">return</span> _CurrentCamera;<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">private</span> Camera _CurrentCamera;<font></font>
<font></font>
    [<span class="hljs-meta">ImageEffectOpaque</span>]
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (!EffectMaterial)<font></font>
        {<font></font>
            Graphics.Blit(source, destination); <span class="hljs-comment">// do nothing</span>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        Graphics.Blit(source, destination, EffectMaterial, <span class="hljs-number">0</span>); <span class="hljs-comment">// use given effect shader as image effect</span><font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスクリプトを使用するには、スクリプトをカメラに接続し、イメージエフェクトシェーダーを「エフェクトシェーダー」フィールドにドラッグする必要があります。</font><font style="vertical-align: inherit;">テストとして、画面を反転させるだけの標準のイメージエフェクトシェーダー（[アセット]&gt; [作成]&gt; [シェーダー]&gt; [イメージエフェクトシェーダー]）を使用できます。</font><font style="vertical-align: inherit;">これに対処したので、実装のより技術的な側面に取り掛かることができます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグメントシェーダーに光線を渡す</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイマーチャーを実装する最初のステップは、各ピクセルに使用するレイを計算することです。</font><font style="vertical-align: inherit;">さらに、Unityレンダリングパラメータ（カメラの位置と回転、FOVなど）に一致させるために、これらの光線が必要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/593/690/d1c/593690d1cfe18437e101bbc9366e90a0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図4：カメラから送信された光線の視覚化</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これを行う方法はたくさん</font><i><font style="vertical-align: inherit;">あり</font></i><font style="vertical-align: inherit;">ますが、各フレームで次の手順を使用することにしました。</font></font><br>
<br>
<ol>
<li>    ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">   (Camera View Frustum)</a>.       «»  :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d6/b8d/cd5/1d6b8dcd537895343bf779edcdc6fb90.png"></div><br>
<i>   ,    </i></li>
<li>   raymarcher          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Graphics.Blit()</a>.  , Graphics.Blit     ,       .   ,     <em>  ,     1</em>.       ,         !</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーでは、ステージ2からフラグメントシェーダーにシェーダーの方向を渡します。</font><font style="vertical-align: inherit;">Cgは、各ピクセルの光線方向を自動的に補間して、真の光線方向を作成します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、上記のプロセスを実装しましょう。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ1：視界のピラミッドの角度を計算する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラのピラミッドの角度の光線を計算するには、カメラのスコープとそのアスペクト比を考慮する必要があります。</font><font style="vertical-align: inherit;">以下の関数でこれを行いました</font></font><code>GetFrustumCorners</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag">///</span> \brief Stores the normalized rays representing the camera frustum in a 4x4 matrix.  Each row is a vector.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> The following rays are stored in each row (in eyespace, not worldspace):</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Top Left corner:     row=0</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Top Right corner:    row=1</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Bottom Right corner: row=2</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Bottom Left corner:  row=3</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> Matrix4x4 <span class="hljs-title">GetFrustumCorners</span>(<span class="hljs-params">Camera cam</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">float</span> camFov = cam.fieldOfView;
    <span class="hljs-keyword">float</span> camAspect = cam.aspect;<font></font>
<font></font>
    Matrix4x4 frustumCorners = Matrix4x4.identity;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> fovWHalf = camFov * <span class="hljs-number">0.5f</span>;<font></font>
<font></font>
    <span class="hljs-keyword">float</span> tan_fov = Mathf.Tan(fovWHalf * Mathf.Deg2Rad);<font></font>
<font></font>
    Vector3 toRight = Vector3.right * tan_fov * camAspect;<font></font>
    Vector3 toTop = Vector3.up * tan_fov;<font></font>
<font></font>
    Vector3 topLeft = (-Vector3.forward - toRight + toTop);<font></font>
    Vector3 topRight = (-Vector3.forward + toRight + toTop);<font></font>
    Vector3 bottomRight = (-Vector3.forward + toRight - toTop);<font></font>
    Vector3 bottomLeft = (-Vector3.forward - toRight - toTop);<font></font>
<font></font>
    frustumCorners.SetRow(<span class="hljs-number">0</span>, topLeft);<font></font>
    frustumCorners.SetRow(<span class="hljs-number">1</span>, topRight);<font></font>
    frustumCorners.SetRow(<span class="hljs-number">2</span>, bottomRight);<font></font>
    frustumCorners.SetRow(<span class="hljs-number">3</span>, bottomLeft);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> frustumCorners;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、この機能について少し説明する価値があります。</font><font style="vertical-align: inherit;">まず、</font></font><code>Matrix4x4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vector3の配列ではなくを</font><font style="vertical-align: inherit;">返します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これのおかげで、ベクトルを1つの変数でシェーダーに渡すことができます（配列は必要ありません）。</font><font style="vertical-align: inherit;">第二に、それは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目の空間（目の空間）に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ある視界のピラミッドの角の光線を返します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">つまり、（0,0,0）はカメラの位置であり、光線自体はカメラの視点から放出されます（たとえば、ワールドスペース（worldspace）ではない）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ2：光線をGPUに送信する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マトリックスをシェーダーに渡すには、画像効果スクリプトに小さな変更を加える必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">ImageEffectOpaque</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">if</span> (!EffectMaterial)<font></font>
    {<font></font>
        Graphics.Blit(source, destination); <span class="hljs-comment">// do nothing</span>
        <span class="hljs-keyword">return</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// pass frustum rays to shader</span>
    EffectMaterial.SetMatrix(<span class="hljs-string">"_FrustumCornersES"</span>, GetFrustumCorners(CurrentCamera));<font></font>
    EffectMaterial.SetMatrix(<span class="hljs-string">"_CameraInvViewMatrix"</span>, CurrentCamera.cameraToWorldMatrix);<font></font>
    EffectMaterial.SetVector(<span class="hljs-string">"_CameraWS"</span>, CurrentCamera.transform.position);<font></font>
<font></font>
    Graphics.Blit(source, destination, EffectMaterial, <span class="hljs-number">0</span>); <span class="hljs-comment">// use given effect shader as image effect</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、イメージエフェクトシェーダー自体の作業を開始すると、uniformを使用してマトリックスにアクセスできます</font></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。また、後で必要になるカメラに関する情報も追加しました（これ</font></font><code>_CameraInvViewMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、光線を目の空間からワールド空間に変換するために使用され</font></font><code>_CameraWS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これはカメラの位置です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このマトリックスを正しく解釈するためのツールを頂点シェーダーに提供する必要があります。覚えておいてください：画像効果は画面全体に描画された四角形にすぎないため、対応するインデックスを頂点シェーダーの各頂点に渡す必要があり</font></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。これには、独自の代替品を使用する必要があります</font></font><code>Graphics.Blit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（上記の13行目を参照）。</font><font style="vertical-align: inherit;">この修正バージョンでは、トリッキーなトリックを行いました。四角形は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">正射影</font></a></font><code>Graphics.Blit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して描画される</font><font style="vertical-align: inherit;">ため、</font><font style="vertical-align: inherit;">各頂点の位置は</font><font style="vertical-align: inherit;">完成した画像に影響しません。</font><font style="vertical-align: inherit;">したがって、</font><font style="vertical-align: inherit;">各頂点の</font><font style="vertical-align: inherit;">座標を介して</font><font style="vertical-align: inherit;">対応するインデックス</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すだけ</font><font style="vertical-align: inherit;">です！</font><font style="vertical-align: inherit;">複雑に聞こえますが、実際には非常に簡単です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><code>z</code><font style="vertical-align: inherit;"></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"></font><code>z</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment"><span class="hljs-doctag">///</span> \brief Custom version of Graphics.Blit that encodes frustum corner indices into the input vertices.</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> In a shader you can expect the following frustum cornder index information to get passed to the z coordinate:</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Top Left vertex:     z=0, u=0, v=0</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Top Right vertex:    z=1, u=1, v=0</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Bottom Right vertex: z=2, u=1, v=1</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> Bottom Left vertex:  z=3, u=1, v=0</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> </span>
<span class="hljs-comment"><span class="hljs-doctag">///</span> \warning You may need to account for flipped UVs on DirectX machines due to differing UV semantics</span>
<span class="hljs-comment"><span class="hljs-doctag">///</span>          between OpenGL and DirectX.  Use the shader define UNITY_UV_STARTS_AT_TOP to account for this.</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">CustomGraphicsBlit</span>(<span class="hljs-params">RenderTexture source, RenderTexture dest, Material fxMaterial, <span class="hljs-keyword">int</span> passNr</span>)</span><font></font>
{<font></font>
    RenderTexture.active = dest;<font></font>
<font></font>
    fxMaterial.SetTexture(<span class="hljs-string">"_MainTex"</span>, source);<font></font>
<font></font>
    GL.PushMatrix();<font></font>
    GL.LoadOrtho(); <span class="hljs-comment">// Note: z value of vertices don't make a difference because we are using ortho projection</span><font></font>
<font></font>
    fxMaterial.SetPass(passNr);<font></font>
<font></font>
    GL.Begin(GL.QUADS);<font></font>
<font></font>
    <span class="hljs-comment">// Here, GL.MultitexCoord2(0, x, y) assigns the value (x, y) to the TEXCOORD0 slot in the shader.</span>
    <span class="hljs-comment">// GL.Vertex3(x,y,z) queues up a vertex at position (x, y, z) to be drawn.  Note that we are storing</span>
    <span class="hljs-comment">// our own custom frustum information in the z coordinate.</span>
    GL.MultiTexCoord2(<span class="hljs-number">0</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>);<font></font>
    GL.Vertex3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">3.0f</span>); <span class="hljs-comment">// BL</span><font></font>
<font></font>
    GL.MultiTexCoord2(<span class="hljs-number">0</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>);<font></font>
    GL.Vertex3(<span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">2.0f</span>); <span class="hljs-comment">// BR</span><font></font>
<font></font>
    GL.MultiTexCoord2(<span class="hljs-number">0</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<font></font>
    GL.Vertex3(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>); <span class="hljs-comment">// TR</span><font></font>
<font></font>
    GL.MultiTexCoord2(<span class="hljs-number">0</span>, <span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>);<font></font>
    GL.Vertex3(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>); <span class="hljs-comment">// TL</span><font></font>
    <font></font>
    GL.End();<font></font>
    GL.PopMatrix();<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span>
    EffectMaterial.SetMatrix(<span class="hljs-string">"_FrustumCornersES"</span>, GetFrustumCorners(CurrentCamera));<font></font>
<font></font>
    CustomGraphicsBlit(source, destination, EffectMaterial, <span class="hljs-number">0</span>); <span class="hljs-comment">// Replace Graphics.Blit with CustomGraphicsBlit</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常の実装では、</font></font><code>Graphics.Blit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4つの呼び出しすべてで</font></font><code>GL.Vertex3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z座標が0になります。ただし、変更を行った後、対応するzインデックスをz座標に割り当て</font></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ステージ3：シェーダーでレイの方向を取得する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ようやくレイマーチングシェーダーを作成する準備が整いました。基本として、標準の画像効果シェーダー（アセット&gt;作成&gt;シェーダー&gt;画像効果シェーダー）から始めます。最初に、頂点シェーダーを編集して正しく解釈できるようにする必要があります</font></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Provided by our script</span><font></font>
uniform float4x4 _FrustumCornersES;<font></font>
uniform sampler2D _MainTex;<font></font>
uniform float4 _MainTex_TexelSize;<font></font>
uniform float4x4 _CameraInvViewMatrix;<font></font>
<font></font>
<span class="hljs-comment">// Input to vertex shader</span>
<span class="hljs-keyword">struct</span> appdata<font></font>
{<font></font>
    <span class="hljs-comment">// Remember, the z value here contains the index of _FrustumCornersES to use</span><font></font>
    float4 vertex : POSITION;<font></font>
    float2 uv : TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Output of vertex shader / input to fragment shader</span>
<span class="hljs-keyword">struct</span> v2f<font></font>
{<font></font>
    float4 pos : SV_POSITION;<font></font>
    float2 uv : TEXCOORD0;<font></font>
    float3 ray : TEXCOORD1;<font></font>
};<font></font>
<font></font>
<span class="hljs-function">v2f <span class="hljs-title">vert</span> (<span class="hljs-params">appdata v</span>)</span><font></font>
{<font></font>
    v2f o;<font></font>
    <font></font>
    <span class="hljs-comment">// Index passed via custom blit function in RaymarchGeneric.cs</span><font></font>
    half index = v.vertex.z;<font></font>
    v.vertex.z = <span class="hljs-number">0.1</span>;<font></font>
    <font></font>
    o.pos = mul(UNITY_MATRIX_MVP, v.vertex);<font></font>
    o.uv = v.uv.xy;<font></font>
    <font></font>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span>
    <span class="hljs-keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)<font></font>
        o.uv.y = <span class="hljs-number">1</span> - o.uv.y;
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
    <span class="hljs-comment">// Get the eyespace view ray (normalized)</span>
    o.ray = _FrustumCornersES[(<span class="hljs-keyword">int</span>)index].xyz;<font></font>
<font></font>
    <span class="hljs-comment">// Transform the ray from eyespace to worldspace</span>
    <span class="hljs-comment">// Note: _CameraInvViewMatrix was provided by the script</span><font></font>
    o.ray = mul(_CameraInvViewMatrix, o.ray);<font></font>
    <span class="hljs-keyword">return</span> o;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頂点シェーダーの大部分はUnityグラフィックプログラマーにとって馴染みのあるものである必要があります。ほとんどのイメージエフェクトシェーダーと同様に、頂点の位置とデータをUVフラグメントシェーダーに渡します。</font><font style="vertical-align: inherit;">また、場合によっては、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">出力の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フリップを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">回避</font></a><font style="vertical-align: inherit;">する</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ため</font></a><font style="vertical-align: inherit;">に、Y軸に沿ってUVをフリップする必要があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もちろん、</font></font><code>_FrustumCornersES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力頂点のZ座標</font><font style="vertical-align: inherit;">から対応する関心のあるレイも抽出し</font><font style="vertical-align: inherit;">ます（これらの値はステージ2でZ座標に挿入されました）。</font><font style="vertical-align: inherit;">頂点シェーダーが完了すると、GPUは各ピクセルの光線を補間します。</font><font style="vertical-align: inherit;">これで、これらの補間された光線をフラグメントシェーダーで使用できるようになりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストとして、フラグメントシェーダーでビーム方向を返してみましょう。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">fixed4 <span class="hljs-title">frag</span> (<span class="hljs-params">v2f i</span>) : SV_Target</span><font></font>
{<font></font>
    fixed4 col = fixed4(i.ray, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span> col;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityでは、これにより次のような視覚化が作成されます。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;">Your browser does not support HTML5 video.<source src="https://adrianb.io/gfycat_old/SaltyIckyFiddlercrab.mp4" type="video/mp4"></video></div></div></div><br>
<i>        . ,   ,  .     (0, 1, 0).</i><br>
<br>
<h3>  </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、距離フィールドを作成することです。これは、今後使用します。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離フィールド</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、レンダリングするものを決定することを</font><font style="vertical-align: inherit;">思い出させてください</font><font style="vertical-align: inherit;">（従来のレンダラーの3Dモデル/メッシュとは異なります）。</font><font style="vertical-align: inherit;">距離フィールドの関数は、入力でポイントを受け取り、このポイントからシーン内の最も近いオブジェクトの表面までの距離を返します。</font><font style="vertical-align: inherit;">ポイントがオブジェクトの内側にある場合、距離フィールドは負になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
距離フィールドの構築は非常に複雑なトピックであり、その研究はおそらく私たちの記事には当てはまりません。</font><font style="vertical-align: inherit;">幸いなことに、距離フィールドに関するすばらしいリソースがインターネット上にあります。たとえば、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">距離フィールドの標準プリミティブは</font></a><font style="vertical-align: inherit;">、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">この驚くべきInigo Kilezaリソースにリストさ</font></a><font style="vertical-align: inherit;">れてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私の記事では、Inigoからデータを借りて、原点に単純なトーラスを描画します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Torus</span>
<span class="hljs-comment">// t.x: diameter</span>
<span class="hljs-comment">// t.y: thickness</span>
<span class="hljs-comment">// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdTorus</span>(<span class="hljs-params">float3 p, float2 t</span>)</span><font></font>
{<font></font>
    float2 q = float2(length(p.xz) - t.x, p.y);<font></font>
    <span class="hljs-keyword">return</span> length(q) - t.y;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// This is the distance field function.  The distance field represents the closest distance to the surface</span>
<span class="hljs-comment">// of any object we put in the scene.  If the given point (point p) is inside of an object, we return a</span>
<span class="hljs-comment">// negative answer.</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">map</span>(<span class="hljs-params">float3 p</span>)</span> {
    <span class="hljs-keyword">return</span> sdTorus(p, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0.2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーンの原点の中心に位置する、直径1.0、厚さ0.2のトーラスを表す距離フィールドを設定します。</font><font style="vertical-align: inherit;">この機能</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はおそらくレイマーチングの最もクリエイティブで興味深い側面であるため、いじってみることをお勧めします！</font><font style="vertical-align: inherit;">新しいプリミティブ、プリミティブの組み合わせ、または独自の奇妙な形状を試してください！</font><font style="vertical-align: inherit;">繰り返しますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このリソースを調べて、距離フィールドの他の方程式を見つけてください</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Raymarch関数の作成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サンプリングする距離フィールドを作成したので、基本的なレイマーチループを記述できます。このループは、フラグメントシェーダーから呼び出されます。この投稿の冒頭で説明したように、彼は現在のピクセルの光線に沿ってサンプリングされた点の「行進」を担当します。 raymarch関数は、光線が衝突するオブジェクトの色（オブジェクトが見つからない場合は完全に透明な色）を返します。本質的に、raymarch関数は</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下に示すよう</font><font style="vertical-align: inherit;">な単純なループ</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">要約</font><font style="vertical-align: inherit;">されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Raymarch along given ray</span>
<span class="hljs-comment">// ro: ray origin</span>
<span class="hljs-comment">// rd: ray direction</span>
<span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd</span>)</span> {<font></font>
    fixed4 ret = fixed4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {<font></font>
        float3 p = ro + rd * t; <span class="hljs-comment">// World space position of sample</span>
        <span class="hljs-keyword">float</span> d = map(p);       <span class="hljs-comment">// Sample of distance field (see map())</span><font></font>
<font></font>
        <span class="hljs-comment">// If the sample &lt;= 0, we have hit something (see map()).</span>
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.001</span>) {
            <span class="hljs-comment">// Simply return a gray color if we have hit an object</span>
            <span class="hljs-comment">// We will deal with lighting later.</span>
            ret = fixed4(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// If the sample &gt; 0, we haven't hit anything yet so we should march forward</span>
        <span class="hljs-comment">// We step forward by distance d, because d is the minimum distance possible to intersect</span>
        <span class="hljs-comment">// an object (see map()).</span><font></font>
        t += d;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイマーチループの各反復で、レイに沿ってポイントをサンプリングします。何かに遭遇した場合、ループを終了して色（つまり、オブジェクトの色）を返します。何も発生しない場合（結果が</font></font><code>map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロより大きい場合）、距離フィールドによって報告された距離に進みます。混乱している場合は、記事の冒頭で説明した理論に戻ってください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
細かいディテールが多い非常に複雑なシーンを作成する場合。次に、</font></font><code>maxstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7行目で</font><font style="vertical-align: inherit;">定数を増やす必要</font><font style="vertical-align: inherit;">がある場合があります（ただし、パフォーマンスの低下に伴い、これを支払う必要があります）。また、注意深く調整</font></font><code>maxstep</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、取得できるサンプル数を理解</font><font style="vertical-align: inherit;">することも</font><font style="vertical-align: inherit;">できます（単純なトーラスの場合、64サンプルはやり過ぎですが、例として、この値は残しておきます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>raymarch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、フラグメントシェーダーから</font><font style="vertical-align: inherit;">呼び出す必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは簡単に行えます：</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Provided by our script</span><font></font>
uniform float3 _CameraWS;<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-function">fixed4 <span class="hljs-title">frag</span> (<span class="hljs-params">v2f i</span>) : SV_Target</span><font></font>
{<font></font>
    <span class="hljs-comment">// ray direction</span><font></font>
    float3 rd = normalize(i.ray.xyz);<font></font>
    <span class="hljs-comment">// ray origin (camera position)</span><font></font>
    float3 ro = _CameraWS;<font></font>
<font></font>
    fixed3 col = tex2D(_MainTex,i.uv); <span class="hljs-comment">// Color of the scene before this shader was run</span>
    fixed4 <span class="hljs-keyword">add</span> = raymarch(ro, rd);<font></font>
<font></font>
    <span class="hljs-comment">// Returns final color using alpha blending</span>
    <span class="hljs-keyword">return</span> fixed4(col*(<span class="hljs-number">1.0</span> - <span class="hljs-keyword">add</span>.w) + <span class="hljs-keyword">add</span>.xyz * <span class="hljs-keyword">add</span>.w,<span class="hljs-number">1.0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで行うのは、頂点シェーダーから光線データを取得して関数に渡すことだけ</font></font><code>raymarch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">最後に、</font></font><code>_MainTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アルファブレンディング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、このシェーダーを適用する前にレンダリングされたシーン</font><font style="vertical-align: inherit;">と結果を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">混合し</font></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これ</font></font><code>_CameraWS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はワールドスペースでのカメラの位置を表し、C＃スクリプトの前半で均一としてシェーダーに渡された</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">思い出してください</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityをもう一度開いて見てください！</font><font style="vertical-align: inherit;">トーラスです！</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://adrianb.io/gfycat_old/WholeWeirdFirefly.mp4" type="video/mp4"></video></div></div></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、ポリゴンはありません！</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">照明を追加する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはすでに深刻な進歩を遂げています。これで、レイマーチングにより、無限の解像度で任意の形状をレンダリングできます。ただし、もちろん、レンダリングされたレイマーチングオブジェクトをゲームに使用することは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
照明オブジェクトの計算を実行できるようにするには、まずオブジェクトの法線を計算する必要があります。光は、法線の関数としてオブジェクトから反射されます。より具体的には、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BDRF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は入力として通常の表面を必要とします。通常のポリゴン3Dメッシュでは、三角形の法線の検索は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">簡単に解決できる問題</font></a><font style="vertical-align: inherit;">であるため、オブジェクトの法線を見つけるのは簡単です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、私たちの場合、距離フィールド内のオブジェクトの法線の定義はそれほど明白ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
距離フィールドで指定されたサーフェス上の任意の点で、距離フィールドの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">勾配は</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その点でのオブジェクトの法線と同じであることがわかります。</font><font style="vertical-align: inherit;">スカラーフィールドの勾配（たとえば、符号付きの距離フィールド）は、本質的にはx、y、z方向のフィールドの導関数です。</font><font style="vertical-align: inherit;">言い換えると、各次元</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について</font><font style="vertical-align: inherit;">、他の</font><font style="vertical-align: inherit;">2つの次元を固定し、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿った場の導関数を近似し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">直感的に、距離フィールドの値は、オブジェクトから離れるように（つまり、その法線に沿って）直接移動すると、より速く増加します。</font><font style="vertical-align: inherit;">したがって、あるポイントで勾配を計算することにより、このポイントでの表面の法線も計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この勾配がコードでどのように近似するかを次に示します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">float3 <span class="hljs-title">calcNormal</span>(<span class="hljs-params"><span class="hljs-keyword">in</span> float3 pos</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// epsilon - used to approximate dx when taking the derivative</span>
    <span class="hljs-keyword">const</span> float2 eps = float2(<span class="hljs-number">0.001</span>, <span class="hljs-number">0.0</span>);<font></font>
<font></font>
    <span class="hljs-comment">// The idea here is to find the "gradient" of the distance field at pos</span>
    <span class="hljs-comment">// Remember, the distance field is not boolean - even if you are inside an object</span>
    <span class="hljs-comment">// the number is negative, so this calculation still works.</span>
    <span class="hljs-comment">// Essentially you are approximating the derivative of the distance field at this point.</span><font></font>
    float3 nor = float3(<font></font>
        map(pos + eps.xyy).x - map(pos - eps.xyy).x,<font></font>
        map(pos + eps.yxy).x - map(pos - eps.yxy).x,<font></font>
        map(pos + eps.yyx).x - map(pos - eps.yyx).x);<font></font>
    <span class="hljs-keyword">return</span> normalize(nor);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、この手法は非常に高価であるため、注意してください。</font><font style="vertical-align: inherit;">勾配を見つけるには、各ピクセルについて距離フィールドをさらに6回計算する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトの法線を計算できるようになったので、オブジェクトの照明を開始できます！</font><font style="vertical-align: inherit;">もちろん、最初に光源が必要です。</font><font style="vertical-align: inherit;">光源をシェーダーに転送するには、スクリプトを少し変更する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TutorialRaymarch</span> : <span class="hljs-title">SceneViewFilter</span> {<font></font>
<font></font>
    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    <span class="hljs-keyword">public</span> Transform SunLight;<font></font>
<font></font>
    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
    {<font></font>
        <span class="hljs-comment">// ...</span><font></font>
<font></font>
        EffectMaterial.SetVector(<span class="hljs-string">"_LightDir"</span>, SunLight ? SunLight.forward : Vector3.down);<font></font>
<font></font>
        <span class="hljs-comment">// ...</span><font></font>
<font></font>
        CustomGraphicsBlit(source, destination, EffectMaterial, <span class="hljs-number">0</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのアドオンは、単に太陽の方向を表すベクトルをシェーダーに伝えます。</font><font style="vertical-align: inherit;">必要に応じて、他の情報（たとえば、光の明るさ、色など）を送信できますが、ここでは例を単純なままにし、これが明るさ1.0の単純な指向性照明であると仮定します。</font><font style="vertical-align: inherit;">このベクトルは、均一な</font></font><code>_LightDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーを</font><font style="vertical-align: inherit;">介してスクリプトに渡されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">と</font></font><code>_LightDir</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一緒に</font><font style="vertical-align: inherit;">使用</font><font style="vertical-align: inherit;">して</font></font><code>calcNormal()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトを照らします。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// ...</span><font></font>
<font></font>
uniform float3 _LightDir;<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd</span>)</span> {<font></font>
    fixed4 ret = fixed4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {<font></font>
        float3 p = ro + rd * t; <span class="hljs-comment">// World space position of sample</span>
        <span class="hljs-keyword">float</span> d = map(p);       <span class="hljs-comment">// Sample of distance field (see map())</span><font></font>
<font></font>
        <span class="hljs-comment">// If the sample &lt;= 0, we have hit something (see map()).</span>
        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0.001</span>) {
            <span class="hljs-comment">// Lambertian Lighting</span><font></font>
            float3 n = calcNormal(p);<font></font>
            ret = fixed4(dot(-_LightDir.xyz, n).rrr, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// If the sample &gt; 0, we haven't hit anything yet so we should march forward</span>
        <span class="hljs-comment">// We step forward by distance d, because d is the minimum distance possible to intersect</span>
        <span class="hljs-comment">// an object (see map()).</span><font></font>
        t += d;<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ...</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードの18〜20行目で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、反射のランバートモデル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">て</font></a><font style="vertical-align: inherit;">いますが、任意の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BDRF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用できます</font><font style="vertical-align: inherit;">（通常の3Dモデルと同じように！）。</font><font style="vertical-align: inherit;">Unityエディターに戻り、「Sun Light」スクリプトの属性をシーンの指向性照明のソースに割り当てます。その後、美しく照らされたTorが実際に表示されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f72/f0f/0ad/f72f0f0ad608dc2778a14f2449af591e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランバート照明付きのトーチ</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッシュからのオブジェクトとの相互作用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、距離フィールドを使用してすでにいくつかのオブジェクトを作成しており、それらをUnityプロジェクトに埋め込む準備ができています。</font><font style="vertical-align: inherit;">ただし、非常にすぐに重大な問題が発生します。メッシュからのオブジェクトとレイマーチングによって受信されたオブジェクトは、相互作用して互いに接触することができません。</font><font style="vertical-align: inherit;">実際、</font><font style="vertical-align: inherit;">レイマーチャーは深さを考慮していないため、レイマーチ</font><font style="vertical-align: inherit;">によって受信されたオブジェクトは</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべての上に浮かびます。</font><font style="vertical-align: inherit;">これはビデオで見ることができます：</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://adrianb.io/gfycat_old/GrossThoroughEasternnewt.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を解決するには、メッシュから最も近いオブジェクトが配置されている各光線に沿った距離を見つける必要があります。レイマーチループがこのポイントを超えた場合、このオブジェクトを終了してレンダリングします（レイマーチによって受信される潜在的なオブジェクトの前にあるため）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この距離を見つけるには、深度バッファーを使用する必要があります。深度バッファは、すべてのイメージエフェクトシェーダーで使用でき、各ピクセルについて、シーン内の最も近いオブジェクトの深度を</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アイスペースに</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格納し</font><em><font style="vertical-align: inherit;">ます</font></em><font style="vertical-align: inherit;">。下の図5を参照してください。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f46/df8/75d/f46df875db1d31609f19aeeaac39fff8.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5：深さの計算に関係する測定チャート。赤い線は、任意のピクセルの光線です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">図5 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の値</font><font style="vertical-align: inherit;">は、見つけようとしている値（深さ、レイマーチサイクルを終了する必要がある深さ）です。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">は、デプスバッファーのこのピクセルに対して取るアイスペースの深度です（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dは</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遠近法を考慮していない</font><font style="vertical-align: inherit;">ため、</font><em><font style="vertical-align: inherit;">d</font></em><font style="vertical-align: inherit;">は</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも短い</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">）。</font><em><font style="vertical-align: inherit;">r</font></em><font style="vertical-align: inherit;"> 
の値を見つけるには</font><font style="vertical-align: inherit;">、三角形の相似ルールを使用するだけです。検討</font><em><font style="vertical-align: inherit;">のR </font></em><em><sub><font style="vertical-align: inherit;">nは</font></sub></em><font style="vertical-align: inherit;">、同じ方向を有するベクトル</font><em><font style="vertical-align: inherit;">Rを</font></em></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z方向の長さは1.0です。次のように書くことができる</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rを</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として、以下：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ÷（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.Z</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
上記式において、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rの</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dは</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ方向を有するベクトルであり</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が、換言すれば、任意の長さ（我々に伝達される光線ベクトルのシェーダー）。図5から、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nが</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2つの類似した三角形を形成し</font><font style="vertical-align: inherit;">ていることは明らかです</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掛けると</font><font style="vertical-align: inherit;">（深度バッファーからわかる）、</font><font style="vertical-align: inherit;">次のように</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とその値を</font><font style="vertical-align: inherit;">取得できます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font><font style="vertical-align: inherit;">/ </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / 1.0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
| </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> | </font><font style="vertical-align: inherit;">= </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></sub></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> × </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーで深度バッファーを使用します</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の理論と一致するように、コードに変更を加える必要があります。</font><font style="vertical-align: inherit;">最初に、頂点シェーダーを変更して</font><font style="vertical-align: inherit;">、</font><em><font style="vertical-align: inherit;">r </font></em><em><sub><font style="vertical-align: inherit;">d</font></sub></em><font style="vertical-align: inherit;">ではなく</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">返すようにする必要があります</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub></em><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">v2f <span class="hljs-title">vert</span> (<span class="hljs-params">appdata v</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    <span class="hljs-comment">// Dividing by z "normalizes" it in the z axis</span>
    <span class="hljs-comment">// Therefore multiplying the ray by some number i gives the viewspace position</span>
    <span class="hljs-comment">// of the point on the ray with [viewspace z]=i</span><font></font>
    o.ray /= abs(o.ray.z);<font></font>
<font></font>
    <span class="hljs-comment">// Transform the ray from eyespace to worldspace</span><font></font>
    o.ray = mul(_CameraInvViewMatrix, o.ray);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> o;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>abs(o.ray.z)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">だけでなく、で</font><font style="vertical-align: inherit;">
除算していることに注意してください</font></font><code>o.ray.z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。目の空間の座標で</font></font><code>z &lt; 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は前方向に対応する</font><font style="vertical-align: inherit;">ため、これは必要</font><font style="vertical-align: inherit;">です。負の数で除算すると、除算時にビームの方向が逆になります（つまり、レイマーチングによって取得されたシーン自体も逆さまになります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のステップは、フラグメントシェーダーとraymarchループに深度を埋め込むことです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Raymarch along given ray</span>
<span class="hljs-comment">// ro: ray origin</span>
<span class="hljs-comment">// rd: ray direction</span>
<span class="hljs-comment">// s: unity depth buffer</span>
<span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd, <span class="hljs-keyword">float</span> s</span>)</span> {<font></font>
    fixed4 ret = fixed4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {
        <span class="hljs-comment">// If we run past the depth buffer, stop and return nothing (transparent pixel)</span>
        <span class="hljs-comment">// this way raymarched objects and traditional meshes can coexist.</span>
        <span class="hljs-keyword">if</span> (t &gt;= s) {<font></font>
            ret = fixed4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// ...</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
uniform sampler2D _CameraDepthTexture;<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-function">fixed4 <span class="hljs-title">frag</span> (<span class="hljs-params">v2f i</span>) : SV_Target</span><font></font>
{<font></font>
    <span class="hljs-comment">// ray direction</span><font></font>
    float3 rd = normalize(i.ray.xyz);<font></font>
    <span class="hljs-comment">// ray origin (camera position)</span><font></font>
    float3 ro = _CameraWS;<font></font>
<font></font>
    float2 duv = i.uv;<font></font>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_UV_STARTS_AT_TOP</span>
    <span class="hljs-keyword">if</span> (_MainTex_TexelSize.y &lt; <span class="hljs-number">0</span>)<font></font>
        duv.y = <span class="hljs-number">1</span> - duv.y;
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
    <span class="hljs-comment">// Convert from depth buffer (eye space) to true distance from camera</span>
    <span class="hljs-comment">// This is done by multiplying the eyespace depth by the length of the "z-normalized"</span>
    <span class="hljs-comment">// ray (see vert()).  Think of similar triangles: the view-space z-distance between a point</span>
    <span class="hljs-comment">// and the camera is proportional to the absolute distance.</span>
    <span class="hljs-keyword">float</span> depth = LinearEyeDepth(tex2D(_CameraDepthTexture, duv).r);<font></font>
    depth *= length(i.ray.xyz);<font></font>
<font></font>
    fixed3 col = tex2D(_MainTex,i.uv);<font></font>
    fixed4 <span class="hljs-keyword">add</span> = raymarch(ro, rd, depth);<font></font>
<font></font>
    <span class="hljs-comment">// Returns final color using alpha blending</span>
    <span class="hljs-keyword">return</span> fixed4(col*(<span class="hljs-number">1.0</span> - <span class="hljs-keyword">add</span>.w) + <span class="hljs-keyword">add</span>.xyz * <span class="hljs-keyword">add</span>.w,<span class="hljs-number">1.0</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
45行目で、標準の</font></font><code>_CameraDepthTexture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityシェーダー</font><font style="vertical-align: inherit;">を使用してUnity Depth Textureにアクセスし、を使用して</font><font style="vertical-align: inherit;">それを目の深さに変換し</font></font><code>LinearEyeDepth()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このページのUnityマニュアルから、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度テクスチャとUnityの詳細を読むことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。次に、46行目で</font><font style="vertical-align: inherit;">、頂点シェーダーから渡さ</font><font style="vertical-align: inherit;">れた長さ</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nを</font></font></sub></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">深度に乗算し、</font><font style="vertical-align: inherit;">上記の方程式に従ってすべてを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、深さを新しいパラメーターとして渡します</font></font><code>raymarch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 raymarchループでは、深度バッファーで指定された値を超えて移動すると、終了して完全に透明な色を返します（13〜16行目を参照）。 Unityに戻ると、レイマーチングによって受信されたオブジェクトはメッシュからの通常のオブジェクトと共存します。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://adrianb.io/gfycat_old/SimpleInfiniteBlackandtancoonhound.mp4" type="video/mp4"></video></div></div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">距離フィールドのあるエンターテインメント</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでレイマーチャーの準備が整い、機能するようになったので、シーンの作成を開始できます。</font><font style="vertical-align: inherit;">上で述べたように、これは非常に深いウサギの穴であり、距離フィールドの構築は記事の範囲を完全に超えています。</font><font style="vertical-align: inherit;">しかし、以下は私が実験したいくつかの単純な力学です。</font><font style="vertical-align: inherit;">私はインスピレーションを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">得る</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">シェーダートイの</font></a><font style="vertical-align: inherit;">例を研究することをお勧めし</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">とにかく、以下はあなたができることの小さなセットです：</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純な変換</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッシュからの3Dモデルの場合と同様に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルマトリックス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">て</font></a><font style="vertical-align: inherit;">オブジェクト変換を実行できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、この場合、</font><font style="vertical-align: inherit;">実際にはモデル自体を変換しないため</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、モデルの逆行列</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を計算する必要があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">代わりに、距離フィールドのサンプリングに使用されるポイントを変換します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの変換を実装するには、まずイメージエフェクトスクリプトでモデルマトリックスを作成し、次に逆マトリックスをシェーダーに渡します。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">ImageEffectOpaque</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
    <font></font>
    <span class="hljs-comment">// Construct a Model Matrix for the Torus</span><font></font>
    Matrix4x4 MatTorus = Matrix4x4.TRS(<font></font>
        Vector3.right * Mathf.Sin(Time.time) * <span class="hljs-number">5</span>, <font></font>
        Quaternion.identity,<font></font>
        Vector3.one);<font></font>
    MatTorus *= Matrix4x4.TRS(<font></font>
        Vector3.zero, <font></font>
        Quaternion.Euler(<span class="hljs-keyword">new</span> Vector3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (Time.time * <span class="hljs-number">200</span>) % <span class="hljs-number">360</span>)), <font></font>
        Vector3.one);<font></font>
    <span class="hljs-comment">// Send the torus matrix to our shader</span>
    EffectMaterial.SetMatrix(<span class="hljs-string">"_MatTorus_InvModel"</span>, MatTorus.inverse);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"></font><code>Time.time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトのアニメーション化</font><font style="vertical-align: inherit;">
に使用できるものを検討する価値があり</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">スクリプト（Unityアニメーションシステムを含む）の変数を使用して、データをこれらの変換に転送することもできます。</font><font style="vertical-align: inherit;">次に、シェーダーでモデルマトリックスを取得し、それをトーラスに適用します。</font></font><br>
<br>
<pre><code class="cs hljs">uniform float4x4 _MatTorus_InvModel;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">map</span>(<span class="hljs-params">float3 p</span>)</span> {<font></font>
    float4 q = mul(_MatTorus_InvModel, float4(p,<span class="hljs-number">1</span>));<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> sdTorus(q.xyz, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0.2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityのトーラスが美しく前後に移動していることがわかります（アニメーションを表示するには、再生モードを実行します）。</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのブラウザはHTML5ビデオをサポートしていません。</font></font><source src="https://adrianb.io/gfycat_old/TalkativeHopefulHowlermonkey.mp4" type="video/mp4"></video></div></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを組み合わせる</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを組み合わせて、より複雑な形状を作成することもできます。</font><font style="vertical-align: inherit;">これを行うには、距離フィールドを結合する単純な演算を使用します：（</font><font style="vertical-align: inherit;">和集合、</font></font><code>opU()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">共役）、</font></font><code>opI()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（交差、交差）および</font></font><code>opS()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（減算、減算）。</font><font style="vertical-align: inherit;">以下は、これらの操作の結果を示す距離フィールド関数の例です。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-comment">// Box</span>
<span class="hljs-comment">// b: size of box in x/y/z</span>
<span class="hljs-comment">// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdBox</span>(<span class="hljs-params">float3 p, float3 b</span>)</span><font></font>
{<font></font>
    float3 d = abs(p) - b;<font></font>
    <span class="hljs-keyword">return</span> min(max(d.x, max(d.y, d.z)), <span class="hljs-number">0.0</span>) +<font></font>
        length(max(d, <span class="hljs-number">0.0</span>));<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Union</span>
<span class="hljs-comment">// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">opU</span>(<span class="hljs-params"> <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2 </span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> min(d1,d2);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Subtraction</span>
<span class="hljs-comment">// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">opS</span>(<span class="hljs-params"> <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2 </span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> max(-d1,d2);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Intersection</span>
<span class="hljs-comment">// Adapted from: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">opI</span>(<span class="hljs-params"> <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2 </span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> max(d1,d2);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">map</span>(<span class="hljs-params">float3 p</span>)</span> {
    <span class="hljs-keyword">float</span> union_box = opU(<font></font>
        sdBox(p - float3(<span class="hljs-number">-4.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)), <font></font>
        sdBox(p - float3(<span class="hljs-number">-3.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<font></font>
    );<font></font>
    <span class="hljs-keyword">float</span> subtr_box = opS(<font></font>
        sdBox(p - float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1.01</span>)), <font></font>
        sdBox(p - float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<font></font>
    );<font></font>
    <span class="hljs-keyword">float</span> insec_box = opI(<font></font>
        sdBox(p - float3(<span class="hljs-number">3.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)), <font></font>
        sdBox(p - float3(<span class="hljs-number">4.5</span>, <span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>), float3(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<font></font>
    );<font></font>
<font></font>
    <span class="hljs-keyword">float</span> ret = opU(union_box, subtr_box);<font></font>
    ret = opU(ret, insec_box);<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityでの操作の結果：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a61/a7c/710/a61a7c710901cf728a45bca00f5854e2.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左から右へ：活用、減算、交差</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかの材料</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
距離フィールドの機能を拡張して、材料データも返すようにすることができます。</font><font style="vertical-align: inherit;">関数</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が各オブジェクトに関連するマテリアル情報を返す</font><font style="vertical-align: inherit;">ようにするだけ</font><font style="vertical-align: inherit;">です。以下の例では、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランプカラーテンプレートの</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャを使用して各オブジェクトの色を選択します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、いくつかのマテリアルをサポートするには、上記の機能を変更する必要があり</font></font><code>opU()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86c/81b/02d/86c81b02dab7e1059395d0fd4aafe579.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しているカラーパターン（カラーランプ）。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつものように、イメージエフェクトスクリプトを通じてシェーダーにカラーランプを渡す必要があります。</font></font><br>
<br>
<pre><code class="cs hljs">[<span class="hljs-meta">SerializeField</span>]
<span class="hljs-keyword">private</span> Texture2D _ColorRamp;<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
[<span class="hljs-meta">ImageEffectOpaque</span>]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnRenderImage</span>(<span class="hljs-params">RenderTexture source, RenderTexture destination</span>)</span><font></font>
{<font></font>
    <span class="hljs-comment">// ...</span><font></font>
<font></font>
    EffectMaterial.SetTexture(<span class="hljs-string">"_ColorRamp"</span>, _ColorRamp);<font></font>
<font></font>
    <span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に</font></font><code>_ColorRamp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、シェーダーで</font><font style="vertical-align: inherit;">新しいユニフォーム</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">上記のように、マテリアルのこれらのさまざまなプロパティを使用するには、の変更と</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、でのライティングの計算が</font><font style="vertical-align: inherit;">必要</font></font><code>raymarch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="cs hljs">uniform sampler2D _ColorRamp;<font></font>
<font></font>
<span class="hljs-comment">// ...</span><font></font>
<font></font>
<span class="hljs-comment">// Union (with material data)</span>
<span class="hljs-function">float2 <span class="hljs-title">opU</span>(<span class="hljs-params"> float2 d1, float2 d2 </span>)</span><font></font>
{<font></font>
    <span class="hljs-keyword">return</span> (d1.x &lt; d2.x) ? d1 : d2;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Notice how map() now returns a float2</span>
<span class="hljs-comment">// \return.x: Distance field value</span>
<span class="hljs-comment">// \return.y: Color of closest object (0 - 1)</span>
<span class="hljs-function">float2 <span class="hljs-title">map</span>(<span class="hljs-params">float3 p</span>)</span> {<font></font>
    float2 d_torus = float2(sdTorus(p, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0.2</span>)), <span class="hljs-number">0.5</span>);<font></font>
    float2 d_box = float2(sdBox(p - float3(<span class="hljs-number">-3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), float3(<span class="hljs-number">0.75</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.5</span>)), <span class="hljs-number">0.25</span>);<font></font>
    float2 d_sphere = float2(sdSphere(p - float3(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>), <span class="hljs-number">1</span>), <span class="hljs-number">0.75</span>);<font></font>
<font></font>
    float2 ret = opU(d_torus, d_box);<font></font>
    ret = opU(ret, d_sphere);<font></font>
    <font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd, <span class="hljs-keyword">float</span> s</span>)</span> {<font></font>
    fixed4 ret = fixed4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {
        <span class="hljs-comment">// ...</span><font></font>
<font></font>
        float3 p = ro + rd * t; <span class="hljs-comment">// World space position of sample</span>
        float2 d = map(p);      <span class="hljs-comment">// Sample of distance field (see map())</span>
                                <span class="hljs-comment">// d.x: distance field output</span>
                                <span class="hljs-comment">// d.y: material data</span><font></font>
<font></font>
        <span class="hljs-comment">// If the sample &lt;= 0, we have hit something (see map()).</span>
        <span class="hljs-keyword">if</span> (d.x &lt; <span class="hljs-number">0.001</span>) {<font></font>
            float3 n = calcNormal(p);<font></font>
            <span class="hljs-keyword">float</span> light = dot(-_LightDir.xyz, n);
            <span class="hljs-comment">// Use y value given by map() to choose a color from our Color Ramp</span>
            ret = fixed4(tex2D(_ColorRamp, float2(d.y,<span class="hljs-number">0</span>)).xyz * light, <span class="hljs-number">1</span>);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// ...</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、色の異なる3つのオブジェクトができました。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/528/62a/b6c/52862ab6c26622abf1ea4847d01093c2.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のマテリアルによるレイマーチング</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性能試験</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その一部は、レイマーチシェーダーのパフォーマンスをテストするために必要です。</font><font style="vertical-align: inherit;">これは、各フレームでそれが呼び出される頻度を調べることによって行うのが最適</font></font><code>map()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><code>raymarch()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フレームごとのサンプル数を表示するように</font><font style="vertical-align: inherit;">変更する</font><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">で、これを美しく視覚化できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">前のセクションと同様に、現在のピクセルのサンプル数をカラーランプにバインドするだけです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd, <span class="hljs-keyword">float</span> s</span>)</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span><font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {<font></font>
        float3 p = ro + rd * t; <span class="hljs-comment">// World space position of sample</span>
        float2 d = map(p);      <span class="hljs-comment">// Sample of distance field (see map())</span><font></font>
<font></font>
        <span class="hljs-comment">// If the sample &lt;= 0, we have hit something (see map()).</span>
        <span class="hljs-keyword">if</span> (d.x &lt; <span class="hljs-number">0.001</span>) {
            <span class="hljs-comment">// Simply return the number of steps taken, mapped to a color ramp.</span>
            <span class="hljs-keyword">float</span> perf = (<span class="hljs-keyword">float</span>)i / maxstep;
            <span class="hljs-keyword">return</span> fixed4(tex2D(_ColorRamp, float2(perf, <span class="hljs-number">0</span>)).xyz, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        t += d;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// By this point the loop guard (i &lt; maxstep) is false.  Therefore</span>
    <span class="hljs-comment">// we have reached maxstep steps.</span>
    <span class="hljs-keyword">return</span> fixed4(tex2D(_ColorRamp, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)).xyz, <span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityでのこれの視覚化は次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4e/1a8/5dd/b4e1a85dd4bb7ae9bf212ba53fafb4e0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンスの視覚化。</font><font style="vertical-align: inherit;">青=より少ないステップ、赤=より多くのステップ。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記の視覚化は、アルゴリズムの深刻な問題を強調しています。</font><font style="vertical-align: inherit;">レイマーチングによって形成されたオブジェクトを表示しないピクセル（およびこれらのピクセルのほとんど）は、最大ステップサイズを示します！</font><font style="vertical-align: inherit;">これは非常に論理的です。これらのピクセルから放出される光線は何にも衝突しないため、無限に前進します。</font><font style="vertical-align: inherit;">このパフォーマンスの問題を修正するために、最大レンダリング距離を追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd, <span class="hljs-keyword">float</span> s</span>)</span> {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> drawdist = <span class="hljs-number">40</span>; <span class="hljs-comment">// draw distance in unity units</span><font></font>
<font></font>
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span><font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {<font></font>
        float3 p = ro + rd * t; <span class="hljs-comment">// World space position of sample</span>
        float2 d = map(p);      <span class="hljs-comment">// Sample of distance field (see map())</span><font></font>
<font></font>
        <span class="hljs-comment">// If the sample &lt;= 0, we have hit something (see map()).</span>
        <span class="hljs-comment">// If t &gt; drawdist, we can safely bail because we have reached the max draw distance</span>
        <span class="hljs-keyword">if</span> (d.x &lt; <span class="hljs-number">0.001</span> || t &gt; drawdist) {
            <span class="hljs-comment">// Simply return the number of steps taken, mapped to a color ramp.</span>
            <span class="hljs-keyword">float</span> perf = (<span class="hljs-keyword">float</span>)i / maxstep;
            <span class="hljs-keyword">return</span> fixed4(tex2D(_ColorRamp, float2(perf, <span class="hljs-number">0</span>)).xyz, <span class="hljs-number">1</span>);<font></font>
        }<font></font>
<font></font>
        t += d;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">// By this point the loop guard (i &lt; maxstep) is false.  Therefore</span>
    <span class="hljs-comment">// we have reached maxstep steps.</span>
    <span class="hljs-keyword">return</span> fixed4(tex2D(_ColorRamp, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)).xyz, <span class="hljs-number">1</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この最適化後のヒートマップは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/244/286/4a4/2442864a40f38cd658275532f8841522.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最適化後の別のパフォーマンスの視覚化。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ずっといい！</font><font style="vertical-align: inherit;">デプスバッファートランケーションチェックに描画距離チェックを追加することで、この最適化を通常のレイマーチループに組み込むことができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function">fixed4 <span class="hljs-title">raymarch</span>(<span class="hljs-params">float3 ro, float3 rd, <span class="hljs-keyword">float</span> s</span>)</span> {<font></font>
    fixed4 ret = fixed4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxstep = <span class="hljs-number">64</span>;
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> drawdist = <span class="hljs-number">40</span>; <span class="hljs-comment">// draw distance in unity units</span><font></font>
<font></font>
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0</span>; <span class="hljs-comment">// current distance traveled along ray</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxstep; ++i) {
        <span class="hljs-keyword">if</span> (t &gt;= s || t &gt; drawdist) { <span class="hljs-comment">// check draw distance in additon to depth</span>
            ret = fixed4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        <span class="hljs-comment">// ...</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> ret;<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最終的に</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事がレイマーチングの距離場の良い入門になったといいのですが。</font><font style="vertical-align: inherit;">完全な実装は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このGithubリポジトリにあります</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">詳細を知りたい場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadertoy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とリソースの</font><font style="vertical-align: inherit;">例を</font><font style="vertical-align: inherit;">以下のリンクで</font><font style="vertical-align: inherit;">学習することをお勧めします</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">距離フィールドレイマーチングで使用されるテクニックのほとんどは正式に文書化されていないため、自分で探す必要があります。</font><font style="vertical-align: inherit;">理論的な観点からは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャドウ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、アンビエントオクルージョン、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑な領域</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">での</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">操作、複雑</font></a><font style="vertical-align: inherit;">な手続き型テクスチャリングのテクニック</font><font style="vertical-align: inherit;">など</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">レイマーチングに関連する興味深いトピック全体には触れませんでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらすべてのトリックを自分で学ぶことをお勧めします！</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<ul>
<li>-, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">  </a> —      Raymarching-.        raymarching-.<br>
 <ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"> ,  </a>         .</li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">  9bit Science</a> —    ,    raymarching-.</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">Shadertoy</a> —     ,       raymarching- (     raymarching-, ,  ).          ,       .</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gamedev Stackexchangeに関するこのディスカッションは、レイマーチング</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーの基本について興味深い洞察を提供し、サラウンドライティングなどのレイマーチングの代替使用法も提供します。</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503542/index.html">NMEAデータの例でのカルマンフィルターの経験</a></li>
<li><a href="../ja503544/index.html">ポッドキャスト：スタジアムでのAR、現実世界のプロセスモデリング、学際的なゲーム開発者</a></li>
<li><a href="../ja503546/index.html">Rの国別のアルコール嗜好のクラスター分析の簡単な例</a></li>
<li><a href="../ja503550/index.html">SQLを補完します。パート2.行の操作とファイルのオープンの最適化</a></li>
<li><a href="../ja503552/index.html">DITモスクワ、パスをチェックすると、次の10年間広告を送信する許可が与えられます</a></li>
<li><a href="../ja503556/index.html">stdについて知っておくべきことすべて::</a></li>
<li><a href="../ja503560/index.html">Scalaの学習：パート1-ヘビゲーム</a></li>
<li><a href="../ja503562/index.html">モバイル開発者向けの興味深い資料の要約＃345（5月18〜24日）</a></li>
<li><a href="../ja503564/index.html">データサイエンス-リトルワイルドウェスト</a></li>
<li><a href="../ja503566/index.html">LinuxデスクトップをWindowsインフラストラクチャで使用することは可能ですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>