<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔕 👩🏿‍🤝‍👩🏽 👨🏾‍🎨 非同期/ Cで待つ：コンセプト、内部設計、便利なトリック ☑️ 😮 🌖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="良い一日。今回は、C＃言語のすべての自尊心のある支持者が理解し始めたトピックについて話します。タスクを使用した非同期プログラミング、または一般的な人々では、非同期/待機です。Microsoftはうまくいきました。ほとんどの場合、非同期を使用するには、構文だけを知っておく必要があります。その他の詳細は...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>非同期/ Cで待つ：コンセプト、内部設計、便利なトリック</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470830/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">良い一日。</font><font style="vertical-align: inherit;">今回は、C＃言語のすべての自尊心のある支持者が理解し始めたトピックについて話します。タスクを使用した非同期プログラミング、または一般的な人々では、非同期/待機です。</font><font style="vertical-align: inherit;">Microsoftはうまくいきました。ほとんどの場合、非同期を使用するには、構文だけを知っておく必要があります。その他の詳細は必要ありません。</font><font style="vertical-align: inherit;">しかし、深く掘り下げると、トピックは非常に膨大で複雑です。</font><font style="vertical-align: inherit;">それは多くの人によって、それぞれ独自のスタイルで述べられました。</font><font style="vertical-align: inherit;">このトピックに関するクールな記事はたくさんありますが、それについてはまだ多くの誤解があります。</font><font style="vertical-align: inherit;">深さや理解を犠牲にすることなく、状況を修正し、材料をできるだけ噛むようにします。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zn/or/r1/znorr1o7rsk1tzudgdrmgchrss4.jpeg"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
取り上げるトピック/章：</font></font><br>
<br>
<ol>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期性の概念</font></font></a></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -「ブロックされた」スレッドに関する非同期性と神話の利点</font></font></li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">TAP.    </a></b> —      </li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   TAP</a></b> —        ( ,      )</li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> :  </a></b> —       </li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> .    </a></b> —         </li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">      TAP</a></b> —  ,           TAP</li>
</ol><a name="conception"></a><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期自体は決して新しいものではありません。通常、非同期とは、呼び出し元のスレッドをブロックすることを意味しないスタイルで操作を実行すること、つまり操作の完了を待たずに操作を開始することを意味します。ブロッキングは、説明されているほど悪ではありません。ブロックされたスレッドがCPU時間を浪費し、動作が遅くなり、雨が発生するという主張に出くわす場合があります。後者はありそうにありませんか？実際、前の2つの点は同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OSスケジューラーレベルでは、スレッドが「ブロックされた」状態にある場合、貴重なプロセッサー時間はそれに割り当てられません。スケジューラ呼び出しは、原則として、ブロッキング、タイマー割り込み、およびその他の割り込みを引き起こす操作に依存します。つまり、たとえば、ディスクコントローラが読み取り操作を完了し、適切な割り込みを開始すると、スケジューラが起動します。彼は、この操作によってブロックされたスレッドを開始するか、より高い優先順位を持つ他のスレッドを開始するかを決定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遅い仕事はさらにばかげているようです。実際、実際、仕事はまったく同じです。非同期操作を実行する場合にのみ、小さなオーバーヘッドが追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
雨の挑戦は、一般的にこの地域からのものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主なブロッキングの問題は、コンピュータリソースの不当な消費です。</font><font style="vertical-align: inherit;">スレッドを作成してスレッドのプールを操作する時間を忘れても、ブロックされたすべてのスレッドが余分なスペースを消費します。</font><font style="vertical-align: inherit;">まあ、1つのスレッドだけが特定の作業（たとえば、UIスレッド）を実行できるシナリオがあります。</font><font style="vertical-align: inherit;">したがって、私は彼が別のスレッドが実行できるタスクで忙しくなりたくないので、彼のための排他的操作のパフォーマンスを犠牲にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期は非常に広範な概念であり、さまざまな方法で実現できます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NETの履歴では、以下を区別できます</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EAP（イベントベースの非同期パターン）-名前が示すように、トリップは、操作が完了したときに発生するイベントと、この操作を呼び出す通常のメソッドに基づいています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APM（非同期プログラミングモデル）-2つの方法に基づいています。</font><font style="vertical-align: inherit;">BeginSmthメソッドは、IAsyncResultインターフェイスを返します。</font><font style="vertical-align: inherit;">EndSmthメソッドはIAsyncResultを受け入れます（EndSmthが呼び出されるまでに操作が完了しない場合、スレッドはブロックされます）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAP（タスクベースの非同期パターン）は同じasync / awaitです（厳密に言うと、これらの単語はアプローチの後に表示され、タイプTaskおよびTask &lt;TResult&gt;が表示されますが、async / awaitはこの概念を大幅に改善しました）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後者のアプローチは非常に成功したため、誰もが前のものを忘れることに成功しました。</font><font style="vertical-align: inherit;">だから、それは彼についてです。</font></font><br>
<a name="tap_syntax"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクベースの非同期パターン。</font><font style="vertical-align: inherit;">構文およびコンパイル条件</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
標準のTAPスタイルの非同期メソッドは、非常に簡単に記述できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これを行うには、次のものが必要です</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ol>
<li>    Task, Task&lt;T&gt;  void ( ,  ).  C# 7  Task-like  (   ).  C# 8      IAsyncEnumerable&lt;T&gt;  IAsyncEnumerator&lt;T&gt;</li>
<li>      async,    await.      .      await,    async,  ,  </li>
<li>      Async. ,       .      ,      CancellationToken (   )</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのようなメソッドの場合、コンパイラーは深刻な仕事をします。</font><font style="vertical-align: inherit;">そして、それらは舞台裏で完全に認識できなくなりますが、その詳細については後で説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッドにはawaitキーワードを含める必要があると述べられました。</font><font style="vertical-align: inherit;">それ（単語）は、タスクが実行されるのを非同期に待機する必要があることを示します。これは、タスクが適用されるタスクオブジェクトです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクオブジェクトにはawaitを適用できるように特定の条件もあります。</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予期される型には、パブリック（または内部）GetAwaiter（）メソッドが必要です。拡張メソッドにすることもできます。</font><font style="vertical-align: inherit;">このメソッドは待機オブジェクトを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機オブジェクトはINotifyCompletionインターフェイスを実装する必要があります。これには、void OnCompleted（アクション継続）メソッドの実装が必要です。</font><font style="vertical-align: inherit;">また、インスタンスプロパティbool IsCompleted、つまりvoid GetResult（）メソッドも必要です。</font><font style="vertical-align: inherit;">構造またはクラスのいずれかです。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下の例は、intを期待し、実行しない方法を示しています。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張整数</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WeirdExtensions</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AnyTypeAwaiter <span class="hljs-title">GetAwaiter</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-keyword">int</span> number</span>)</span> =&gt; <span class="hljs-keyword">new</span> AnyTypeAwaiter();<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AnyTypeAwaiter</span> : <span class="hljs-title">INotifyCompletion</span><font></font>
    {<font></font>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> IsCompleted =&gt; <span class="hljs-literal">false</span>;<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCompleted</span>(<span class="hljs-params">Action continuation</span>)</span> { }<font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GetResult</span>(<span class="hljs-params"></span>)</span> { }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<a name="tap_progr"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAPを使用する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かがどう機能するかを理解せずにジャングルに入るのは難しい。</font><font style="vertical-align: inherit;">プログラムの動作の観点からTAPを検討してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
用語：検討中の非同期メソッド（コードが検討される）、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期メソッド</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出し、その</font><font style="vertical-align: inherit;">内部で呼び出された非同期メソッドを</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期操作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼び</font><b><font style="vertical-align: inherit;">ます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純な例を考えてみましょう。非同期操作として、ストリームをブロックせずに指定された時間だけ遅延するTask.Delayを取ります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DelayOperationAsync</span>(<span class="hljs-params"></span>) <span class="hljs-comment">//  </span></span><font></font>
{<font></font>
    BeforeCall();<font></font>
    Task task = Task.Delay(<span class="hljs-number">1000</span>); <span class="hljs-comment">// </span><font></font>
    AfterCall();<font></font>
    <span class="hljs-keyword">await</span> task;<font></font>
    AfterAwait();<font></font>
} <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
動作に関するメソッドの実装は次のとおりです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期操作の呼び出しに先行するすべてのコードが実行されます。</font><font style="vertical-align: inherit;">この場合、これは</font><i><font style="vertical-align: inherit;">BeforeCall</font></i><font style="vertical-align: inherit;">メソッドです</font></font><i><font style="vertical-align: inherit;"></font></i></li>
<li>   .         .     —    (  Task),     </li>
<li>     ,    (await).   — <i>AfterCall</i></li>
<li>     (    ) — await task.<br>
<br>
      ,    ,    .<br>
<br>
    ,   ,         (.. ),           .</li>
<li>    — <i>AfterAwait</i> —    ,    ,       , ,   ,   ,    (   )</li>
</ol><br>
<a name="internals"></a><br>
<h2> .  </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、私たちのメソッドはコンパイラによって、生成されたクラス（ステートマシン）が初期化されるスタブメソッドに変換されます。次に、それ（マシン）が起動し、ステップ2で使用されたTaskオブジェクトがメソッドから返されます</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特に興味深いのは</font><font style="vertical-align: inherit;">、ステートマシンの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><i><font style="vertical-align: inherit;">です</font></i><font style="vertical-align: inherit;">。このメソッドは、非同期メソッドでの変換前の処理を実行します。各待機呼び出しの間のコードを中断します。各パーツは、マシンの特定の条件で実行されます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MoveNext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド自体は</font><font style="vertical-align: inherit;">、継続として待機オブジェクトにアタッチされます。国家の維持は、論理的に期待に沿ったその部分の正確な実行を保証します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らが言うように、100回聞くよりも1回見るほうがよいので、以下の例を理解することを強くお勧めします。</font><font style="vertical-align: inherit;">私はコードを少し書き直し、変数の命名を改善し、寛大にコメントしました。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Delays</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
     Console.WriteLine(<span class="hljs-number">1</span>);
     <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
     Console.WriteLine(<span class="hljs-number">2</span>);
     <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
     Console.WriteLine(<span class="hljs-number">3</span>);
     <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
     Console.WriteLine(<span class="hljs-number">4</span>);
     <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
     Console.WriteLine(<span class="hljs-number">5</span>);
     <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">1000</span>);<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタブ方式</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">AsyncStateMachine(typeof(DelaysStateMachine))</span>]<font></font>
[<span class="hljs-meta">DebuggerStepThrough</span>]
<span class="hljs-function"><span class="hljs-keyword">public</span> Task <span class="hljs-title">Delays</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
     DelaysStateMachine stateMachine = <span class="hljs-keyword">new</span> DelaysStateMachine();<font></font>
     stateMachine.taskMethodBuilder = AsyncTaskMethodBuilder.Create();<font></font>
     stateMachine.currentState = <span class="hljs-number">-1</span>;<font></font>
     AsyncTaskMethodBuilder builder = stateMachine.taskMethodBuilder;<font></font>
     taskMethodBuilder.Start(<span class="hljs-keyword">ref</span> stateMachine);
     <span class="hljs-keyword">return</span> stateMachine.taskMethodBuilder.Task;<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態機械</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs">[<span class="hljs-meta">CompilerGenerated</span>]
<span class="hljs-keyword">private</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DelaysStateMachine</span> : <span class="hljs-title">IAsyncStateMachine</span><font></font>
{<font></font>
    <span class="hljs-comment">//  ,     await  </span>
    <span class="hljs-comment">//       await'a</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> currentState; 
    <span class="hljs-keyword">public</span> AsyncTaskMethodBuilder taskMethodBuilder;
    <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">private</span> TaskAwaiter taskAwaiter;<font></font>
<font></font>
    <span class="hljs-comment">//  ,             "" </span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> paramInt;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> localInt;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MoveNext</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">int</span> num = currentState;
        <span class="hljs-keyword">try</span><font></font>
        {<font></font>
            TaskAwaiter awaiter5;<font></font>
            TaskAwaiter awaiter4;<font></font>
            TaskAwaiter awaiter3;<font></font>
            TaskAwaiter awaiter2;<font></font>
            TaskAwaiter awaiter;<font></font>
            <span class="hljs-keyword">switch</span> (num)<font></font>
            {<font></font>
                <span class="hljs-keyword">default</span>:<font></font>
                    localInt = paramInt;  <span class="hljs-comment">//  await</span>
                    Console.WriteLine(<span class="hljs-number">1</span>);  <span class="hljs-comment">//  await</span>
                    awaiter5 = Task.Delay(<span class="hljs-number">1000</span>).GetAwaiter();  <span class="hljs-comment">//  await</span>
                    <span class="hljs-keyword">if</span> (!awaiter5.IsCompleted) <span class="hljs-comment">//  await. ,   </span><font></font>
                    {<font></font>
                        num = (currentState = <span class="hljs-number">0</span>); <span class="hljs-comment">// ,     </span>
                        taskAwaiter = awaiter5; <span class="hljs-comment">//    ,       </span>
                        DelaysStateMachine stateMachine = <span class="hljs-keyword">this</span>; <span class="hljs-comment">//   </span>
                        taskMethodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter5, <span class="hljs-keyword">ref</span> stateMachine); <span class="hljs-comment">//                </span>
                        <span class="hljs-keyword">return</span>;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">goto</span> Il_AfterFirstAwait; <span class="hljs-comment">//  ,   ,   </span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">//            ,        .   ,         </span>
                    awaiter5 = taskAwaiter; <span class="hljs-comment">//  </span>
                    taskAwaiter = <span class="hljs-keyword">default</span>(TaskAwaiter); <span class="hljs-comment">//  </span>
                    num = (currentState = <span class="hljs-number">-1</span>); <span class="hljs-comment">// </span>
                    <span class="hljs-keyword">goto</span> Il_AfterFirstAwait; <span class="hljs-comment">//      </span>
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">//  ,      ,    ,     .</span><font></font>
                    awaiter4 = taskAwaiter;<font></font>
                    taskAwaiter = <span class="hljs-keyword">default</span>(TaskAwaiter);<font></font>
                    num = (currentState = <span class="hljs-number">-1</span>);
                    <span class="hljs-keyword">goto</span> Il_AfterSecondAwait;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// ,     .</span><font></font>
                    awaiter3 = taskAwaiter;<font></font>
                    taskAwaiter = <span class="hljs-keyword">default</span>(TaskAwaiter);<font></font>
                    num = (currentState = <span class="hljs-number">-1</span>);
                    <span class="hljs-keyword">goto</span> Il_AfterThirdAwait;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-comment">//   </span><font></font>
                    awaiter2 = taskAwaiter;<font></font>
                    taskAwaiter = <span class="hljs-keyword">default</span>(TaskAwaiter);<font></font>
                    num = (currentState = <span class="hljs-number">-1</span>);
                    <span class="hljs-keyword">goto</span> Il_AfterFourthAwait;
                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-comment">//   </span><font></font>
                    {<font></font>
                        awaiter = taskAwaiter;<font></font>
                        taskAwaiter = <span class="hljs-keyword">default</span>(TaskAwaiter);<font></font>
                        num = (currentState = <span class="hljs-number">-1</span>);
                        <span class="hljs-keyword">break</span>;<font></font>
                    }<font></font>
<font></font>
                    Il_AfterFourthAwait:<font></font>
                    awaiter2.GetResult();<font></font>
                    Console.WriteLine(<span class="hljs-number">5</span>); <span class="hljs-comment">//    </span>
                    awaiter = Task.Delay(<span class="hljs-number">1000</span>).GetAwaiter(); <span class="hljs-comment">//  </span>
                    <span class="hljs-keyword">if</span> (!awaiter.IsCompleted)<font></font>
                    {<font></font>
                        num = (currentState = <span class="hljs-number">4</span>);<font></font>
                        taskAwaiter = awaiter;<font></font>
                        DelaysStateMachine stateMachine = <span class="hljs-keyword">this</span>;<font></font>
                        taskMethodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter, <span class="hljs-keyword">ref</span> stateMachine);
                        <span class="hljs-keyword">return</span>;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
                    Il_AfterFirstAwait: <span class="hljs-comment">//  ,       </span>
                    awaiter5.GetResult(); <span class="hljs-comment">//      </span>
                    Console.WriteLine(<span class="hljs-number">2</span>); <span class="hljs-comment">//  ,     await</span>
                    awaiter4 = Task.Delay(<span class="hljs-number">1000</span>).GetAwaiter(); <span class="hljs-comment">//   </span>
                    <span class="hljs-keyword">if</span> (!awaiter4.IsCompleted) <font></font>
                    {<font></font>
                        num = (currentState = <span class="hljs-number">1</span>);<font></font>
                        taskAwaiter = awaiter4;<font></font>
                        DelaysStateMachine stateMachine = <span class="hljs-keyword">this</span>;<font></font>
                        taskMethodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter4, <span class="hljs-keyword">ref</span> stateMachine);
                        <span class="hljs-keyword">return</span>;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">goto</span> Il_AfterSecondAwait;<font></font>
<font></font>
                    Il_AfterThirdAwait:<font></font>
                    awaiter3.GetResult();<font></font>
                    Console.WriteLine(<span class="hljs-number">4</span>); <span class="hljs-comment">//    </span>
                    awaiter2 = Task.Delay(<span class="hljs-number">1000</span>).GetAwaiter(); <span class="hljs-comment">//  </span>
                    <span class="hljs-keyword">if</span> (!awaiter2.IsCompleted)<font></font>
                    {<font></font>
                        num = (currentState = <span class="hljs-number">3</span>);<font></font>
                        taskAwaiter = awaiter2;<font></font>
                        DelaysStateMachine stateMachine = <span class="hljs-keyword">this</span>;<font></font>
                        taskMethodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter2, <span class="hljs-keyword">ref</span> stateMachine);
                        <span class="hljs-keyword">return</span>;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">goto</span> Il_AfterFourthAwait;<font></font>
<font></font>
                    Il_AfterSecondAwait:<font></font>
                    awaiter4.GetResult();<font></font>
                    Console.WriteLine(<span class="hljs-number">3</span>); <span class="hljs-comment">//    </span>
                    awaiter3 = Task.Delay(<span class="hljs-number">1000</span>).GetAwaiter(); <span class="hljs-comment">//  </span>
                    <span class="hljs-keyword">if</span> (!awaiter3.IsCompleted)<font></font>
                    {<font></font>
                        num = (currentState = <span class="hljs-number">2</span>);<font></font>
                        taskAwaiter = awaiter3;<font></font>
                        DelaysStateMachine stateMachine = <span class="hljs-keyword">this</span>;<font></font>
                        taskMethodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter3, <span class="hljs-keyword">ref</span> stateMachine);
                        <span class="hljs-keyword">return</span>;<font></font>
                    }<font></font>
                    <span class="hljs-keyword">goto</span> Il_AfterThirdAwait;<font></font>
            }<font></font>
            awaiter.GetResult();<font></font>
        }<font></font>
        <span class="hljs-keyword">catch</span> (Exception exception)<font></font>
        {<font></font>
            currentState = <span class="hljs-number">-2</span>;<font></font>
            taskMethodBuilder.SetException(exception);<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        currentState = <span class="hljs-number">-2</span>;<font></font>
        taskMethodBuilder.SetResult(); <span class="hljs-comment">//    ,   ,      </span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> IAsyncStateMachine.MoveNext() {...}<font></font>
<font></font>
    [<span class="hljs-meta">DebuggerHidden</span>]
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetStateMachine</span>(<span class="hljs-params">IAsyncStateMachine stateMachine</span>)</span> {...}<font></font>
<font></font>
    <span class="hljs-keyword">void</span> IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine) {...}<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「現時点では同期的に実行されていません」というフレーズに焦点を当てます。</font><font style="vertical-align: inherit;">非同期操作は、同期実行パスをたどることもできます。</font><font style="vertical-align: inherit;">現在の非同期メソッドが同期的に、つまりスレッドを変更せずに実行されるための主な条件は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証時の非同期操作の完全性</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この例は、この動作を明確に示しています。</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment">//1</span>
    Task task = Task.Delay(<span class="hljs-number">1000</span>);<font></font>
    Thread.Sleep(<span class="hljs-number">1700</span>);
    <span class="hljs-keyword">await</span> task;<font></font>
    Console.WriteLine(Thread.CurrentThread.ManagedThreadId); <span class="hljs-comment">//1</span><font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同期コンテキストについて。</font><font style="vertical-align: inherit;">マシンで</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを</font><font style="vertical-align: inherit;">使用すると、最終的には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.SetContinuationForAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドが呼び出され</font><font style="vertical-align: inherit;">ます。このメソッドでは、現在の同期コンテキスト</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext.Current</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が取得されます</font><font style="vertical-align: inherit;">。同期コンテキストは、一種のストリームとして解釈できます。特定のものがある場合（たとえば、UIスレッドのコンテキスト）、継続は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContextAwaitTaskContinuation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスを使用して作成され</font><font style="vertical-align: inherit;">ます。継続を開始するこのクラスは、保存されたコンテキストでPostメソッドを呼び出します。これにより、メソッドが実行された正確なコンテキストで継続が確実に実行されます。継続を実行するための特定のロジックは、</font><i><font style="vertical-align: inherit;">Post</font></i><font style="vertical-align: inherit;">メソッドによって異なります。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">控えめに言っても、速度については有名ではありません。</font><font style="vertical-align: inherit;">同期コンテキストがなかった場合（または、前の章で説明するConfigureAwait（false）を使用して実行が継続されるコンテキストが問題ではないことが示されている場合）、継続はプールのスレッドによって実行されます。</font><font style="vertical-align: inherit;">ASP NET Coreでは、要求を処理するスレッドにコンテキストがなくなったことに言及する価値があります（喜ばしいことですが、デッドロックの非常に一般的な理由は1つ少なくなります）。</font></font><br>
<a name="libs"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期の起源。</font><font style="vertical-align: inherit;">デバイスの標準非同期メソッド</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
asyncとawaitを使用するメソッドがどのように見えるか、そして舞台裏で何が起こるかを見ました。この情報は珍しいことではありません。ただし、非同期操作の性質を理解することが重要です。ステートマシンで見たように、非同期操作は、結果がより巧妙に処理されない限り、コードで呼び出されます。しかし、非同期操作自体の中で何が起こるのでしょうか？おそらく同じですが、これは無限に起こることはありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要なタスクは、非同期の性質を理解することです。非同期性を理解しようとすると、「今は明確」と「わかりにくい」という交互の状態があります。そして、この交替は、非同期の原因が理解されるまで続きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期で作業するときは、タスクを操作します。これはストリームとまったく同じではありません。 1つのタスクを多数のスレッドで実行でき、1つのスレッドで多数のタスクを実行できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期は通常、（たとえば）Taskを返すメソッドで始まりますが、asyncのタグが付いていないため、内部ではawaitを使用しません。このメソッドはコンパイラの変更を許容せず、そのまま実行されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それでは、非同期のルーツのいくつかを見てみましょう。</font></font></b><br>
<br>
<ol>
<li>Task.Run, new Task(..).Start(), Factory.StartNew   .      .       ,       .   ,         .   ,   .  ,       (CPU-bound)   </li>
<li>TaskCompletionSource.  ,     .   ,              .    API — SetResult, SetError  ,     .      Task. ,     ,          .          </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追加の段落で、標準ライブラリのメソッドを作成できます。</font><font style="vertical-align: inherit;">これらには、ファイルの読み取り/書き込み、ネットワークの操作などが含まれます。</font><font style="vertical-align: inherit;">原則として、そのような一般的で一般的な方法は、プラットフォームごとに異なるシステムコールを使用し、そのデバイスは非常に楽しいものです。</font><font style="vertical-align: inherit;">ファイルとネットワークでの作業を検討してください。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイル</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
重要な注意-ファイルを操作する場合は、FileStream useAsync = trueを作成するときに非同期で指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてがファイルに整理されており、紛らわしくなく混乱します。 FileStreamクラスはパーシャルとして宣言されています。さらに、プラットフォーム固有のアドオンが6つあります。したがって、Unixでは、任意のファイルへの非同期アクセスは、原則として、別のスレッドで同期操作を使用します。 Windowsには、非同期操作のシステムコールがありますが、これはもちろん使用されます。これにより、プラットフォーム間でパフォーマンスに違いが生じます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unix</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
書き込みまたは読み取り時の標準的な動作は、バッファが許可し、ストリームが別の操作でビジー状態でない場合、操作を同期的に実行することです</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。1. </font><font style="vertical-align: inherit;">ストリームは</font><font style="vertical-align: inherit;">別の操作でビジーで</font><font style="vertical-align: inherit;">はあり</font><font style="vertical-align: inherit;">ません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Filestreamクラスには、パラメーター（1、1）を持つSemaphoreSlimから継承されたオブジェクトがあります。つまり、重要なセクションです。このセマフォによって保護されたコードフラグメントは、一度に1つのスレッドだけが実行できます。このセマフォは、読み取りと書き込みの両方に使用されます。つまり、読み取りと書き込みの両方を同時に行うことはできません。この場合、セマフォでのブロッキングは発生しません。 this._asyncState.WaitAsync（）メソッドが呼び出され、タスクオブジェクトが返されます（ロックまたは待機がない場合、メソッドの結果にawaitキーワードが適用された場合）。このタスクオブジェクトが完了していない場合、つまりセマフォがキャプチャされた場合、操作が実行される継続（Task.ContinueWith）が返された待機オブジェクトにアタッチされます。オブジェクトが空いている場合は、次のことを確認する必要があります</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.バッファにより、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの動作は操作の性質によって異なります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記録の場合-ファイル内の書き込み+位置のデータのサイズがバッファーのサイズ（デフォルトでは4096バイト）より小さいことが確認されます。つまり、最初から4096バイト、オフセットが2048バイトの2048バイトというように書き込む必要があります。この場合、操作は同期的に実行されます。それ以外の場合、継続がアタッチされます（Task.ContinueWith）。続編は通常の同期システムコールを使用します。バッファがいっぱいになると、同期的にディスクに書き込まれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りの場合-必要なデータをすべて返すために、バッファーに十分なデータがあるかどうかがチェックされます。そうでない場合は、再び、同期システムコールによる継続（Task.ContinueWith）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、面白いディテールがあります。 1つのデータがバッファ全体を占める場合、それらはバッファの関与なしにファイルに直接書き込まれます。同時に、バッファのサイズよりも多くのデータが存在する状況がありますが、それらはすべて通過します。これは、バッファにすでに何かがある場合に発生します。次に、データは2つの部分に分割されます。1つはバッファを最後まで満たし、データはファイルに書き込まれます。2つ目は、バッファに入った場合はバッファに、そうでない場合は直接ファイルに書き込まれます。したがって、ストリームを作成して4097バイトを書き込むと、Disposeを呼び出さなくても、ファイルにすぐに表示されます。 4095と書くと、ファイルには何も含まれません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ウィンドウズ</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windowsでは、バッファを使用して直接書き込むアルゴリズムは非常によく似ています。ただし、非同期システムの書き込みと読み取りの呼び出しでは、大きな違いが直接見られます。システムコールの詳細に触れずに話すと、このようなオーバーラップ構造があります。それは私たちにとって重要なフィールドを持っています-HANDLE hEvent。これは、操作が完了するとアラーム状態になる手動リセットイベントです。実装に戻ります。直接書き込むだけでなく、バ​​ッファーに書き込む場合も、上記の構造体をパラメーターとして使用する非同期システムコールを使用します。記録すると、FileStreamCompletionSourceオブジェクトが作成されます-IOCallbackが指定されているTaskCompletionSourceの継承です。操作が完了すると、プールの空きスレッドによって呼び出されます。コールバックでは、Overlapped構造が解析され、それに応じてTaskオブジェクトが更新されます。それはすべて魔法です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通信網</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出所を理解するために私が見たすべてを説明するのは難しい。</font><font style="vertical-align: inherit;">私のパスは、HttpClientからSocket、UnixのSocketAsyncContextまでありました。</font><font style="vertical-align: inherit;">一般的なスキームはファイルの場合と同じです。</font><font style="vertical-align: inherit;">Windowsでは、前述のオーバーラップ構造が使用され、操作は非同期で実行されます。</font><font style="vertical-align: inherit;">Unixでは、ネットワーク操作もコールバック関数を使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして少し説明。注意深い読者は、呼び出しとコールバックの間で非同期呼び出しを使用するときに、何らかの方法でデータを処理する特定の空があることに気付くでしょう。ここで、完全性を明確にすることは価値があります。ファイルの例では、ディスクコントローラーはディスクコントローラーによってディスクを直接操作し、ヘッドを目的のセクターに移動するなどの信号を出します。現在、プロセッサは空いています。ディスクとの通信は、入力/出力ポートを介して行われます。これらは、操作のタイプ、ディスク上のデータの場所などを示します。次に、コントローラーとディスクがこの操作を実行し、作業が完了すると割り込みが生成されます。したがって、非同期システムコールは入力/出力ポートにのみ情報を提供し、同期システムコールも結果を待って、ストリームをブロッキング状態にします。このスキームは（この記事についてではなく）完全に正確なふりをするわけではありませんが、作業の概念的な理解を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これでプロセスの性質が明確になりました。しかし、誰かが非同期性をどうするかを尋ねるかもしれませんか？メソッドに対して非同期で永久に書き込むことは不可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一に。アプリケーションはサービスとして作成できます。さらに、エントリポイント-Main-は最初から作成されます。最近まで、Mainは非同期ではありませんでした。言語のバージョン7では、この機能が追加されました。ただし、基本的に何も変更されません。コンパイラは通常のMainを生成するだけで、非同期のものから静的メソッドが作成されます。これはMainで呼び出され、その完了は同期的に期待されます。そのため、おそらく、長命のアクションがいくつかあります。何らかの理由で、現時点では、多くの人がこのビジネスのスレッドを作成する方法について考え始めます。何かに違いがあるはずなので、一般にTask、ThreadPool、またはThreadを介して。答えは簡単です-もちろんタスクです。 TAPアプローチを使用する場合は、スレッドの手動作成を妨げないでください。これは、ほとんどすべての要求に対してHttpClientを使用するのに似ており、POSTはソケットを介して独立して行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に。</font><font style="vertical-align: inherit;">Webアプリケーション。</font><font style="vertical-align: inherit;">着信要求ごとに、新しいスレッドがThreadPoolからプルされて処理されます。</font><font style="vertical-align: inherit;">もちろん、プールは大きいですが、無限ではありません。</font><font style="vertical-align: inherit;">リクエストが多い場合、スレッドが足りない可能性があり、すべての新しいリクエストは処理のためにキューに入れられます。</font><font style="vertical-align: inherit;">この状況は飢餓と呼ばれます。</font><font style="vertical-align: inherit;">ただし、前述のように非同期コントローラーを使用する場合、ストリームはプールに戻り、新しい要求を処理するために使用できます。</font><font style="vertical-align: inherit;">したがって、サーバーのスループットが大幅に向上します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期プロセスを最初から最後まで調べました。</font><font style="vertical-align: inherit;">そして、人間の性質と矛盾するこのすべての非同期性の理解を武器に、非同期コードを扱うときにいくつかの便利なトリックを検討します。</font></font><br>
 <a name="api"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TAPを使用する際の便利なクラスとテクニック</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Taskクラスの静的な多様性。</font></font></h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Taskクラスには、いくつかの便利な静的メソッドがあります。</font><font style="vertical-align: inherit;">以下が主なものです。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAny（..）は、タスクオブジェクトのIEnumerable / paramsを取り、完了した最初のタスクが完了したときに完了するタスクオブジェクトを返すコンビネーターです。</font><font style="vertical-align: inherit;">つまり、実行中のいくつかのタスクの1つを待つことができます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.WhenAll（..）-コンビネータ。タスクオブジェクトのIEnumerable / paramsを受け入れ、転送されたすべてのタスクが完了すると完了するタスクオブジェクトを返します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.FromResult &lt;T&gt;（T値）-完了したタスクにラップされた同じ値を返します。</font><font style="vertical-align: inherit;">非同期メソッドを使用して既存のインターフェースを実装する場合にしばしば必要</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Delay（..）-指定された時間、非同期に待機します</font></font></li>
<li>Task.Yield() —  .   ,      .  ,    ,     </li>
</ol><br>
<h3>ConfigureAwait</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、最も人気のある「高度な」機能。このメソッドはTaskクラスに属しており、非同期操作が呼び出されたのと同じコンテキストで続行する必要があるかどうかを指定できます。デフォルトでは、このメソッドを使用しない場合、コンテキストは前述のPostメソッドを使用して記憶され、継続されます。ただし、前述したように、Postは非常に高価な楽しみです。したがって、パフォーマンスが1位で、継続によってUIが更新されないことが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかった</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は、</font><i><font style="vertical-align: inherit;">.ConfigureAwait（false）</font></i><font style="vertical-align: inherit;">待機オブジェクトで指定できます</font><font style="vertical-align: inherit;">。これは、継続がどこで実行されるかは重要ではないことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今問題について。彼らが言うように、怖いは無知ではなく、誤った知識です。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どういうわけか、偶然にも、各非同期呼び出しがこのアクセラレータで装飾されているWebアプリケーションのコードを観察しました。</font><font style="vertical-align: inherit;">これは視覚的な嫌悪感以外の効果はありません。</font><font style="vertical-align: inherit;">標準のASP.NET Core Webアプリケーションには、固有のコンテキストはありません（もちろん、自分で記述しない限り）。</font><font style="vertical-align: inherit;">したがって、Postメソッドはそこで呼び出されません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource &lt;T&gt;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Taskオブジェクトの管理を容易にするクラス。</font><font style="vertical-align: inherit;">クラスには十分な機会がありますが、イベントで終了するアクションでタスクをラップしたい場合に最も役立ちます。</font><font style="vertical-align: inherit;">一般に、このクラスは古い非同期メソッドをTAPに適合させるために作成されましたが、これまで見てきたように、これはこのクラスだけでなく使用されます。</font><font style="vertical-align: inherit;">このクラスでの作業の小さな例：</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Task&lt;<span class="hljs-keyword">string</span>&gt; <span class="hljs-title">GetSomeDataAsync</span>(<span class="hljs-params"></span>)</span><font></font>
{<font></font>
    TaskCompletionSource&lt;<span class="hljs-keyword">string</span>&gt; tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-keyword">string</span>&gt;();<font></font>
    FileSystemWatcher watcher = <span class="hljs-keyword">new</span> FileSystemWatcher<font></font>
    {<font></font>
        Path = Directory.GetCurrentDirectory(),<font></font>
        NotifyFilter = NotifyFilters.LastAccess,<font></font>
        EnableRaisingEvents = <span class="hljs-literal">true</span><font></font>
    };<font></font>
    watcher.Changed += (o, e) =&gt; tcs.SetResult(e.FullPath);<font></font>
    <span class="hljs-keyword">return</span> tcs.Task;<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、現在のフォルダーでアクセスされたファイルの名前を取得する非同期ラッパーを作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellationTokenSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期操作をキャンセルできます。</font><font style="vertical-align: inherit;">一般的な概要は、TaskCompletionSourceの使用に似ています。</font><font style="vertical-align: inherit;">最初に、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var cts = new CancellationTokenSource（）が作成されます</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これはIDisposableであり、次に</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Token</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が非同期操作に渡されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">さらに、いくつかのロジックに従って、特定の条件下で</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cts.Cancel（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドが</font><i><font style="vertical-align: inherit;">呼び出され</font></i><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">また、イベントやその他のものをサブスクライブすることもできます。</font><i><font style="vertical-align: inherit;">CancellationToken</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を使用することをお</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">勧めし</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">バックグラウンドで動作する非同期メソッドを作成するとき、たとえば無限の間に、ループの本体に1行を挿入するだけです</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。cancellationToken.ThrowIfCancellationRequested（）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、例外をスローします</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この例外は操作のキャンセルとして扱われ、タスクオブジェクト内の例外として保存されません。</font><font style="vertical-align: inherit;">また、</font><font style="vertical-align: inherit;">Taskオブジェクトの</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IsCanceled</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティ</font><font style="vertical-align: inherit;">がtrueになります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロングラン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、特にサービスを作成するとき、サービスの存続期間全体にわたって、または非常に長い間機能するいくつかのタスクを作成する場合があります。</font><font style="vertical-align: inherit;">記憶しているように、スレッドプールの使用は、スレッドを作成するオーバーヘッドです。</font><font style="vertical-align: inherit;">ただし、ストリームがほとんど作成されない場合（および1時間に1回でも）、これらのコストは平準化され、安全に別のストリームを作成できます。</font><font style="vertical-align: inherit;">これを行うには、タスクを作成するときに、特別なオプションを指定できます</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Task.Factory.StartNew（action、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCreationOptions.LongRunning</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
とにかく、私は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Task.Factory.StartNewの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてのオーバーロードを確認することをお勧めします</font><font style="vertical-align: inherit;">。特定のニーズに合わせてタスクの実行を柔軟に構成するには、多くの方法があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非同期コード実行の非決定論的な性質のため、例外の問題は非常に関連があります。例外をキャッチできず、左側のスレッドにスローされてプロセスが強制終了されるのは残念です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ExceptionDispatchInfo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラスは、1つのスレッドで例外をキャッチしてその中にスローするために作成されました</font><font style="vertical-align: inherit;">。例外をキャッチするために、</font><i><font style="vertical-align: inherit;">ExceptionDispatchInfo </font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返す</font><font style="vertical-align: inherit;">静的メソッド</font><i><font style="vertical-align: inherit;">ExceptionDispatchInfo.Capture（ex）が使用され</font></i></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このオブジェクトへのリンクは、任意のスレッドに渡すことができ、その後、Throw（）メソッドを呼び出してそれを破棄します。スロー自体は、非同期操作の呼び出しの場所では発生しませんが、await演算子の使用の場所で発生します（メソッドが非同期としてマークされている場合、それ以外の場合、コンパイラーは変換を実行しません。つまり、メソッドは単純なメソッドとして機能し、例外をキャッチして再スローしません）。そしてご存じのように、awaitはvoidに適用できません。したがって、例外は、私たちの制御下になく、キャッチされないストリームで発生します。そして、これはほぼ100％アプリケーションのクラッシュにつながります（常にダーティなハックがあります）。そして、ここでは、TaskまたはTask &lt;T&gt;を使用する必要がありますが、無効にするべきではないという事実を実践します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてさらに。スケジューラーに</font><i><font style="vertical-align: inherit;">TaskScheduler.UnobservedTaskException</font></i><font style="vertical-align: inherit;">イベントがあります</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UnobservedTaskExceptionが</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スローされたときに発生し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">この例外は、GCが未処理の例外を持つタスクオブジェクトを収集しようとするガベージコレクション中にスローされます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃8および.NET Core 3.0より前のバージョンでは、非同期メソッドで収量反復子を使用することができませんでした。そのため、ライフが複雑になり、タスク&lt;IEnumerable &lt;T &gt;&gt;が返されました。完全に受信されるまで、コレクションを反復処理する方法はありませんでした。今、そのような機会があります。詳細については、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちらを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧ください</font><font style="vertical-align: inherit;">。このため、戻り値の型は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerable &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IAsyncEnumerator &lt;T&gt;</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）で</font><font style="vertical-align: inherit;">なければなりません</font><font style="vertical-align: inherit;">。このようなコレクションをトラバースするには、awaitキーワードを指定したforeachループを使用する必要があります。また、操作の結果に対して</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WithCancellation</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ConfigureAwait</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドを呼び出して、</font><font style="vertical-align: inherit;">使用されたCancelationTokenと同じコンテキストで続行する必要があることを示すことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
予想通り、すべては可能な限り遅延して行われます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は彼の例と結論です。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Stopwatch sw = <span class="hljs-keyword">new</span> Stopwatch();<font></font>
        sw.Start();<font></font>
        IAsyncEnumerable&lt;<span class="hljs-keyword">int</span>&gt; enumerable = AsyncYielding();<font></font>
        Console.WriteLine(<span class="hljs-string">$"Time after calling: <span class="hljs-subst">{sw.ElapsedMilliseconds}</span>"</span>);<font></font>
<font></font>
        <span class="hljs-keyword">await</span> <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> element <span class="hljs-keyword">in</span> enumerable.WithCancellation(..).ConfigureAwait(<span class="hljs-literal">false</span>))<font></font>
        {<font></font>
            Console.WriteLine(<span class="hljs-string">$"element: <span class="hljs-subst">{element}</span>"</span>);<font></font>
            Console.WriteLine(<span class="hljs-string">$"Time: <span class="hljs-subst">{sw.ElapsedMilliseconds}</span>"</span>);<font></font>
        }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> IAsyncEnumerable&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">AsyncYielding</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> uselessElement <span class="hljs-keyword">in</span> Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>))<font></font>
        {<font></font>
            Task task = Task.Delay(TimeSpan.FromSeconds(uselessElement));<font></font>
            Console.WriteLine(<span class="hljs-string">$"Task run: <span class="hljs-subst">{uselessElement}</span>"</span>);
            <span class="hljs-keyword">await</span> task;
            <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> uselessElement;<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出し後の時間：0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク実行：1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素：1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間：1033 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク実行：2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素：2 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間：3034 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスク実行：3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要素：3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間：6035</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドプール</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このクラスは、TAPでプログラミングするときに積極的に使用されます。したがって、その実装の最小限の詳細を示します。内部では、ThreadPoolにキューの配列があります。各スレッドに1つ+グローバルに1つです。新しいジョブをプールに追加するとき、追加を開始したスレッドが考慮されます。これがプールからのスレッドである場合、別のスレッド（グローバルスレッド）の場合、作業はこのスレッドの独自のキューに入れられます。機能するスレッドが選択されると、そのローカルキューが最初に検索されます。空の場合、スレッドはグローバルからジョブを取得します。空の場合、他から盗み始めます。また、実際には順序がないため、作業の順序に依存しないでください。プール内のデフォルトのスレッド数は、アドレススペースのサイズなど、多くの要因によって異なります。実行要求がさらにある場合は、使用可能なスレッドの数よりも、要求はキューに入れられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドプール内のスレッドはバックグラウンドスレッドです（プロパティisBackground = true）。</font><font style="vertical-align: inherit;">このタイプのスレッドは、すべてのフォアグラウンドスレッドが完了した場合、プロセスの寿命をサポートしません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムスレッドは、待機ハンドルのステータスを監視します。</font><font style="vertical-align: inherit;">待機操作が終了すると、転送されたコールバックがスレッドからプールから実行されます（Windowsのファイルを思い出してください）。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクのようなタイプ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述のとおり、このタイプ（構造またはクラス）は、非同期メソッドからの戻り値として使用できます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[AsyncMethodBuilder（..）]</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">属性を使用して、ビルダータイプをこのタイプに関連付ける必要があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このタイプにawaitキーワードを適用できるようにするには、このタイプに上記の特性が必要です。</font><font style="vertical-align: inherit;">値を返さないメソッド用にパラメーター化され、返されるメソッド用にパラメーター化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルダー自体は、フレームワークが以下の例に示されているクラスまたは構造です。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドに</font><font style="vertical-align: inherit;">は、Tによってパラメーター化されたタスクのような型のT型のパラメーターがあります。パラメーター化されていない型の場合、メソッドにはパラメーターがありません。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なビルドインターフェイス</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskMethodBuilder</span>&lt;T&gt;<font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyTaskMethodBuilder&lt;T&gt; <span class="hljs-title">Create</span>(<span class="hljs-params"></span>)</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword">ref</span> TStateMachine stateMachine)
        <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetStateMachine</span>(<span class="hljs-params">IAsyncStateMachine stateMachine</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetException</span>(<span class="hljs-params">Exception exception</span>)</span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetResult</span>(<span class="hljs-params">T result</span>)</span>;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(
        <span class="hljs-keyword">ref</span> TAwaiter awaiter, <span class="hljs-keyword">ref</span> TStateMachine stateMachine)
        <span class="hljs-keyword">where</span> TAwaiter : INotifyCompletion
        <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(
        <span class="hljs-keyword">ref</span> TAwaiter awaiter, <span class="hljs-keyword">ref</span> TStateMachine stateMachine)
        <span class="hljs-keyword">where</span> TAwaiter : ICriticalNotifyCompletion
        <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> MyTask&lt;T&gt; Task { <span class="hljs-keyword">get</span>; }<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タスクライクなタイプを書くという観点からの作業の原理を以下に説明します。これのほとんどは、コンパイラーによって生成されたコードを解析するときにすでに説明されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラーは、これらすべてのタイプを使用して状態マシンを生成します。コンパイラーは、彼が認識している型に使用するビルダーを知っています。ここでは、コード生成時に何が使用されるかを自分で示します。ステートマシンが構造体の場合、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetStateMachineを</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出すとパックされ</font><font style="vertical-align: inherit;">、ビルダーは必要に応じてパックされたコピーをキャッシュできます。ビルダー</font><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">Start</font></i><font style="vertical-align: inherit;">メソッドで、</font><font style="vertical-align: inherit;">または</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出さ</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れた</font><font style="vertical-align: inherit;">後</font><font style="vertical-align: inherit;">で、</font><i><font style="vertical-align: inherit;">stateMachine.MoveNext</font></i><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">て、</font><font style="vertical-align: inherit;">実行を開始し、ステートマシンを進める</font><font style="vertical-align: inherit;">必要があります</font><font style="vertical-align: inherit;">。</font><i><font style="vertical-align: inherit;">Startを</font></i><font style="vertical-align: inherit;">呼び出した後</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、タスクプロパティはメソッドから返されます。スタブメソッドに戻ってこれらの手順を確認することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ステートマシンが正常に完了すると、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetResult</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドが</font><i><font style="vertical-align: inherit;">呼び出され</font></i><font style="vertical-align: inherit;">、それ以外の場合は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SetException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が</font><i><font style="vertical-align: inherit;">呼び出され</font></i><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。ステートマシンが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">達すると、</font><font style="vertical-align: inherit;">タスクのようなタイプ</font><font style="vertical-align: inherit;">の</font><i><font style="vertical-align: inherit;">GetAwaiter（）</font></i><font style="vertical-align: inherit;">メソッドが実行され</font><font style="vertical-align: inherit;">ます。待機オブジェクトが</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ICriticalNotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">実装し、</font><i><font style="vertical-align: inherit;">IsCompleted</font></i><font style="vertical-align: inherit;"> = falseの場合、ステートマシンは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitUnsafeOnCompleted（ref awaiter、ref stateMachine）を使用し</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AwaitUnsafeOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">は</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">awaiter.OnCompleted（action）を</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">呼び出す必要があります。</font><i><font style="vertical-align: inherit;">実際に</font></i><font style="vertical-align: inherit;">は、</font><i><font style="vertical-align: inherit;">stateMachine.MoveNext</font></i><font style="vertical-align: inherit;">への呼び出しが必要</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待機オブジェクトが完了したとき。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INotifyCompletion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターフェース</font><font style="vertical-align: inherit;">と</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">builder.AwaitOnCompleted</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド</font><font style="vertical-align: inherit;">についても同様です</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これの使い方はあなた次第です。</font><font style="vertical-align: inherit;">しかし、これを本番環境に適用する前に514回考えることをお勧めします。甘やかすためではありません。</font><font style="vertical-align: inherit;">以下は使用例です。</font><font style="vertical-align: inherit;">どのメソッドがいつ呼び出されたかをコンソールに表示する標準ビルダーのプロキシだけをスケッチしました。</font><font style="vertical-align: inherit;">ちなみに、非同期のMain（）はカスタムの待機タイプをサポートしたくありません（Microsoftによるこのミスが原因で、複数のプロダクションプロジェクトが破損したと思われます）。</font><font style="vertical-align: inherit;">必要に応じて、通常のロガーを使用してより多くの情報をログに記録し、プロキシロガーを変更できます。</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロギングプロキシタスク</font></font></b>
                        <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><font></font>
{<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">"Start"</span>);<font></font>
        JustMethod().Task.Wait(); <span class="hljs-comment">//  </span>
        Console.WriteLine(<span class="hljs-string">"Stop"</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> LogTask <span class="hljs-title">JustMethod</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">await</span> DelayWrapper(<span class="hljs-number">1000</span>);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LogTask <span class="hljs-title">DelayWrapper</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> milliseconds</span>)</span> =&gt; <span class="hljs-keyword">new</span> LogTask { Task = Task.Delay(milliseconds)};<font></font>
}<font></font>
<font></font>
[<span class="hljs-meta">AsyncMethodBuilder(typeof(LogMethodBuilder))</span>]
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogTask</span><font></font>
{<font></font>
    <span class="hljs-keyword">public</span> Task Task { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskAwaiter <span class="hljs-title">GetAwaiter</span>(<span class="hljs-params"></span>)</span> =&gt; Task.GetAwaiter();<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LogMethodBuilder</span><font></font>
{<font></font>
    <span class="hljs-keyword">private</span> AsyncTaskMethodBuilder _methodBuilder = AsyncTaskMethodBuilder.Create();
    <span class="hljs-keyword">private</span> LogTask _task;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LogMethodBuilder <span class="hljs-title">Create</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: Create; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LogMethodBuilder();<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> Start&lt;TStateMachine&gt;(<span class="hljs-keyword">ref</span> TStateMachine stateMachine) <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine<font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: Start; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.Start(<span class="hljs-keyword">ref</span> stateMachine);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetStateMachine</span>(<span class="hljs-params">IAsyncStateMachine stateMachine</span>)</span><font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: SetStateMachine; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.SetStateMachine(stateMachine);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetException</span>(<span class="hljs-params">Exception exception</span>)</span><font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: SetException; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.SetException(exception);<font></font>
    }<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetResult</span>(<span class="hljs-params"></span>)</span><font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: SetResult; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.SetResult();<font></font>
    }    <font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> AwaitOnCompleted&lt;TAwaiter, TStateMachine&gt;(<span class="hljs-keyword">ref</span> TAwaiter awaiter, <span class="hljs-keyword">ref</span> TStateMachine stateMachine)
        <span class="hljs-keyword">where</span> TAwaiter : INotifyCompletion
        <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine<font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: AwaitOnCompleted; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.AwaitOnCompleted(<span class="hljs-keyword">ref</span> awaiter, <span class="hljs-keyword">ref</span> stateMachine);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> AwaitUnsafeOnCompleted&lt;TAwaiter, TStateMachine&gt;(<span class="hljs-keyword">ref</span> TAwaiter awaiter, <span class="hljs-keyword">ref</span> TStateMachine stateMachine)
        <span class="hljs-keyword">where</span> TAwaiter : ICriticalNotifyCompletion
        <span class="hljs-keyword">where</span> TStateMachine : IAsyncStateMachine<font></font>
    {<font></font>
        Console.WriteLine(<span class="hljs-string">$"Method: AwaitUnsafeOnCompleted; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);<font></font>
        _methodBuilder.AwaitUnsafeOnCompleted(<span class="hljs-keyword">ref</span> awaiter, <span class="hljs-keyword">ref</span> stateMachine);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">public</span> LogTask Task<font></font>
    {<font></font>
        <span class="hljs-keyword">get</span><font></font>
        {<font></font>
            Console.WriteLine(<span class="hljs-string">$"Property: Task; <span class="hljs-subst">{DateTime.Now :O}</span>"</span>);
            <span class="hljs-keyword">return</span> _task ??= <span class="hljs-keyword">new</span> LogTask {Task = _methodBuilder.Task};<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> =&gt; _task = <span class="hljs-keyword">value</span>;<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論：</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開始</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド：作成。</font><font style="vertical-align: inherit;">2019-10-09T17：55：13.7152733 + 03：00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方法：開始。</font><font style="vertical-align: inherit;">2019-10-09T17：55：13.7262226 + 03：00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド：AwaitUnsafeOnCompleted; </font><font style="vertical-align: inherit;">2019-10-09T17：55：13.7275206 + 03：00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロパティ：タスク。</font><font style="vertical-align: inherit;">2019-10-09T17：55：13.7292005 + 03：00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メソッド：SetResult; </font><font style="vertical-align: inherit;">2019-10-09T17：55：14.7297967 + 03：00 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
停止</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これですべてです。ありがとうございます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470820/index.html">数十の仮説の簡単なテスト：ルーチンから抜け出し、別の都市での議論をどのように調整するか</a></li>
<li><a href="../ja470822/index.html">企業内の温度監視</a></li>
<li><a href="../ja470824/index.html">約束の対話</a></li>
<li><a href="../ja470826/index.html">鉱山労働者、ダイバーサー、コバルト：安全なインターネットアクセスをお客様に提供する方法</a></li>
<li><a href="../ja470828/index.html">Pythonリンクリスト：ボックス内の猫</a></li>
<li><a href="../ja470834/index.html">重複感染、抗生物質、ゾンビの黙示録モデル</a></li>
<li><a href="../ja470838/index.html">CI / CDのコンテナーセキュリティ</a></li>
<li><a href="../ja470844/index.html">ドゥロフ兄弟の新しいプロジェクト：Telegram Open Network</a></li>
<li><a href="../ja470852/index.html">100ドルのGoを使用して、専用サーバーで1000万プロジェクトの40 TBのコードを処理</a></li>
<li><a href="../ja470856/index.html">Telegram GRAM Wallet：利用規約</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>