<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº‚ÄçüöÄ üåßÔ∏è üëÇüèª Pixockets: how we wrote our own network library for the game server üì® üëó üèÇüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! Connected Stanislav Yablonsky, Lead Server Developer of Pixonic. 
 
 When I first came to Pixonic, our game servers were applications based on ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pixockets: how we wrote our own network library for the game server</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/499642/"><img src="https://habrastorage.org/webt/1m/i0/kx/1mi0kx5zzmixsjdadghss9rpeic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hello! Connected Stanislav Yablonsky, Lead Server Developer of Pixonic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When I first came to Pixonic, our game servers were applications based on the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photon Realtime SDK</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a multifunctional, but very heavy framework. This solution, it would seem, was to simplify the work with the server. So it was - until a certain point.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Photon Realtime tied us to itself by having to use it to exchange data between players and the server - and also tied it to Windows, since it can only work on it. This imposed restrictions on us both from the point of view of runtime (runtime): it was impossible to change many important settings of the .NET virtual machine, and the operating system. We are used to working with Linux servers, not Windows. In addition, they cost us less. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also, the use of Photon hit performance both on the server and on the client, and when profiling, a decent load on the garbage collector and a large amount of boxing / unboxing formed.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In short, the solution with Photon Realtime was far from optimal for us, and for a long time it was necessary to do something with it - but there were always more urgent tasks, and hands did not reach the solution of problems with the server. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since it was interesting for me not only to solve the problem, but also to better understand the network, I decided to take the initiative in my own hands and try to write a library myself. </font><font style="vertical-align: inherit;">But, you understand, at home - at home, at work - work, as a result, the time to develop the library was only in transport. </font><font style="vertical-align: inherit;">However, this did not stop the idea from coming to fruition. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What came of it - read on.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Library ideology</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since we are developing online games, it is very important for us to work without pauses, so low overheads have become the main requirement for the library. For us, this is, above all, a low load on the garbage collector. To achieve it, I tried to avoid allocations, and in cases where it was difficult to achieve or did not work out at all, we made pools (for byte buffers, connection states, headers, etc.).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For simplicity and convenience of support and assembly, we began to use only C # and system sockets. In addition, it was important to fit into the time budget per frame, because the data from the server should have arrived on time. Therefore, I tried to reduce the execution time, even at the cost of some non-optimality: that is, in some places it was worth replacing the fast and partly more complex algorithms and data structures with simpler and more predictable ones. For example, we did not use lock-free queues, since they created a load on the garbage collector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Typically for multiplayer shooters, our data is sent via UDP. Still on top of it was added fragmentation and assembly of packets for sending data of a larger size than the frame size, as well as reliable delivery due to forwarding and establishing a connection.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The UDP frame in our library defaults to 1200 bytes. </font><font style="vertical-align: inherit;">Packets of this size should be transmitted in modern networks with a fairly low risk of fragmentation, since the MTU in most modern networks is higher than this value. </font><font style="vertical-align: inherit;">At the same time, usually this amount is enough to fit the changes that need to be sent to the player after the next tick (status update) in the game.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Architecture</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our library we use a two-layer socket:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first layer is responsible for working with system calls and provides a more convenient API for the next level;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second layer is work directly with the session, fragmentation / assembly of packets, their forwarding, etc.</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/r_/na/zq/r_nazqva4twkyhnouvkr6dhowek.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The class for working with connection, in turn, is also divided into two levels:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The lower level (SockBase) is responsible for sending and receiving data over UDP. </font><font style="vertical-align: inherit;">It is a thin wrapper over a socket system object.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Top Level (SmartSock) provides additional functionality over UDP. </font><font style="vertical-align: inherit;">Cutting and gluing packages, forwarding data that has not reached, rejection of duplicates - all this is his area of ‚Äã‚Äãresponsibility.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The lower level is divided into two classes: BareSock and ThreadSock.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BareSock works in the same thread where the call originated, sending and receiving data in non-blocking mode. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ThreadSock puts packets in queues and thus creates separate threads for sending and receiving data. </font><font style="vertical-align: inherit;">When accessing it, there is only one operation: adding or removing data from the queue.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BareSock is often used to work with the client, ThreadSock - with the server.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Features of work</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I also wrote two types of low-level sockets:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first is synchronous single-threaded. </font><font style="vertical-align: inherit;">In it, we get the minimum overhead for memory and the processor, but at the same time system calls occur directly when accessing the socket. </font><font style="vertical-align: inherit;">This minimizes overhead in general (no need to use queues and additional buffers), but the call itself may take longer than taking an item from the queue.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second is asynchronous with separate threads for reading and writing. </font><font style="vertical-align: inherit;">In this case, we get additional overhead for the queue, synchronization, and sending / receiving time (within a few milliseconds), since at the time of access to the socket, the read or write thread is paused.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We also tried using SocketAsyncEventArgs - perhaps the most advanced networking API in .NET that I know of. But it turned out that it probably doesn‚Äôt work for UDP: the TCP stack through it works fine, but UDP gives errors about getting strangely clipped frames and even crashing inside .NET - as if memory in the native part of the virtual machine were corrupted. I did not find examples of the operation of such a scheme.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Another important feature of our library is reduced data loss. We got the impression that in order to get rid of duplicates, many libraries discard old data packages, as we later saw from our own experience. Of course, such an implementation is much simpler, because in its case one counter with the number of the last frame arrived is enough, but it didn‚Äôt suit us very much. Therefore, Pixockets uses a circular buffer from the numbers of the last frames to filter out duplicates: newly arrived numbers are overwritten instead of the old ones, and duplicates are searched for among the last received frames.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/2y/cb/di/2ycbdijeldlgssku0tq5p3e5dmc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, if a packet was sent before the current frame, but came after, it will still reach the destination. </font><font style="vertical-align: inherit;">This can greatly help, for example, in the case of position interpolation. </font><font style="vertical-align: inherit;">In this case, we will have a more complete story.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data packet structure</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The data in the library is transmitted as follows: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hw/gc/1j/hwgc1jlbxz5s4ng9h1vrenehqui.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the beginning of the package is the header:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It starts with the size of the packet, which in turn is limited to 64 kilobytes. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The size is followed by a byte with flags. </font><font style="vertical-align: inherit;">The interpretation of the rest of the title depends on their availability.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Next is the identifier for the session or connection. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
With the appropriate flags, then we get:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the flag with the packet number in turn is set, the packet number is transmitted after the session identifier. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Following him - also in the case of the flag set - the number of confirmed packets and their numbers.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At the end of the header is information about the fragment: </font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">identifier of the sequence of fragments, which is necessary in order to distinguish fragments of different messages; </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sequence number of the fragment;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">total number of fragments in the message. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Information about the fragment also requires setting the corresponding flag.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The library is written. </font><font style="vertical-align: inherit;">What's next?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to have more accurate synchronous connection information, we later organized an explicit connection. This helped us to clearly understand situations when one side thinks that the connection is established and not interrupted, and the other - that it was interrupted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the first version of Pixockets, this was not: the client did not need to call the Connect (host, port) method - it just started sending data to a known address and port. Then the server called the Listen (port) method and began to receive data from a specific address. Session data was initialized upon receipt / transmission of the packet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now, to establish a connection, a ‚Äúhandshake‚Äù has become necessary ‚Äî the exchange of specially formed packets ‚Äî and the client must call Connect.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition, one of my colleagues forked the library, paying more attention to network security, and also adding some features, such as the ability to reconnect directly inside the socket: for example, when switching between Wi-Fi and 4G, the connection is now restored automatically. </font><font style="vertical-align: inherit;">But we will talk about this later.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Testing</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Of course, we wrote unit tests for the library: they check all the main ways to establish a connection, send and receive data, fragmentation and assembly of packets, various anomalies in sending and receiving data - such as duplication, loss, mismatch in the order of sending and receiving. For the initial performance check, I wrote special test applications for integration testing: a ping client, a ping server and an application that synchronizes the position, color and number of colored circles on the screen over the network. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the test applications proved the functionality of our library, we started comparing it with other libraries: with our old Photon Realtime and with the UDP library LiteNetLib 0.7.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We tested a simplified version of a game server that simply collects input from players and sends back the ‚Äúglued‚Äù result. We took 500 players in rooms of 6 people, the refresh rate is 30 times per second. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/e-/1e/fy/e-1efyiufgmkgsifktigenhbil0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The load on the garbage collector and processor consumption turned out to be lower in the case of Pixockets, as well as the percentage of missing packets - apparently due to the fact that, unlike other versions of UDP, we do not ignore late packets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After we received confirmation of the advantage of our solution in synthetic tests, the next step was to run the library on a real project.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At that time, in the project we selected, clients and game servers synchronized through Photon Server. </font><font style="vertical-align: inherit;">I added Pixockets support to the client and server, making it possible to control the choice of protocol from the matchmaking server - the one to which the clients send a request to enter the game. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For some period, clients played simultaneously on both protocols, and at that time we collected statistics on how they were doing. </font><font style="vertical-align: inherit;">At the end of statistics collection, it turned out that the results do not differ from synthetic tests: the load on the garbage collector and the processor has decreased, packet loss, too. </font><font style="vertical-align: inherit;">At the same time, ping became a little lower. </font><font style="vertical-align: inherit;">Therefore, the next version of the game has already been released completely on Pixockets without using the Photon Realtime SDK.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hr/gz/gs/hrgzgsslampwgbbr_u2puvpbhmq.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Future plans</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now we want to implement the following features in the library:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simplified connection: now it does not work optimally, and after calling Connect on the client, you need to call Read until the connection status changes;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Explicit shutdown: at the moment, shutdown on the other side occurs only by timer;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Built-in pings to maintain connectivity;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Automatic determination of the optimal frame size (now just a constant is used).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can view and participate in the further development of Pixockets </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at the repository address.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en499628/index.html">Development interviews: choose friends</a></li>
<li><a href="../en499630/index.html">Flutter. Spring Update 2020</a></li>
<li><a href="../en499632/index.html">Improving Google Duo Audio Quality with WaveNetEQ</a></li>
<li><a href="../en499634/index.html">Advanced TypeScript</a></li>
<li><a href="../en499636/index.html">React Native for the little ones. Mobile Development Experience</a></li>
<li><a href="../en499644/index.html">Robot Creation (RPA) with AutoTest Tools</a></li>
<li><a href="../en499646/index.html">5 rules for integrating UX in Agile and Scrum</a></li>
<li><a href="../en499648/index.html">‚ÄúA game designer is always a gamer‚Äù: what does a specialist do, what skills are important</a></li>
<li><a href="../en499652/index.html">Is there life in development after the decree</a></li>
<li><a href="../en499654/index.html">How to implement CRM on a remote site and win?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>