<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐵 ⭐️ 🤳🏼 我们从数学协处理器8087的晶体中提取常数 👇🏾 📅 🛤️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1980年，英特尔推出了8087芯片，以加速8086处理器上浮点数的处理，并在原始IBM PC中使用了该芯片。由于第一个微处理器仅使用整数，因此使用浮点数的运算速度很慢，并且具有反正切或对数等先验函数，因此情况甚至更糟。将8087协处理器芯片添加到系统中后，浮点数最多可加速100倍。
 
 我打开了...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>我们从数学协处理器8087的晶体中提取常数</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503034/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1980年，英特尔推出了8087芯片，以加速8086处理器上浮点数的处理，并在原始IBM PC中使用了该芯片。由于第一个微处理器仅使用整数，因此使用浮点数的运算速度很慢，并且具有</font><font style="vertical-align: inherit;">反正切或对数等</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">先验函数</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因此情况甚至更糟。将8087协处理器芯片添加到系统中后，浮点数最多可加速100倍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我打开了8087芯片，并在显微镜下拍摄了几张照片。下图显示了一个微小的硅芯片晶体。在其侧面，细小的导体将其与40条外部支脚相连。图片中主要功能块的标记是我通过逆向工程完成的。如果仔细研究该芯片，则可以从其ROM中提取各种常数-计算中芯片使用的π等数字。</font><i><font style="vertical-align: inherit;">英特尔8087芯片芯片，用于浮点操作，带有标记的主要功能块。具有常量的ROM以绿色标记。可点击的。</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/1o/ee/_a/1oee_auvu5lyuaxcrdoxcrm0vv4.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在芯片的上半部分是控制电路。执行浮点指令可能需要多达1000个步骤； 8087使用微码描述了这些步骤。在水晶的照片中，您可以看到从微码启动程序的“机制”。实际上，它是一个简单的CPU。它旁边是一个大ROM，用于存储微代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
芯片底部是处理浮点数的电路。浮点数由小数部分（也称为数字或尾数的有效部分），指数和符号位组成。以十进制表示法，数字6.02×10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">23</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尾数为6.02，指数为23。单独的芯片电路同时处理尾数和指数。尾数处理方案支持67位值-一个64位尾数和三个附加位以确保准确性。尾数运算方案从左到右由具有常数的ROM，移位寄存器，加法器/减法器和寄存器堆栈组成。本文的主题是具有常量的ROM；在照片中以绿色突出显示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8087是8086处理器的协处理器，当8086处理器遇到与浮点数有关的特殊指令时，它会忽略它，并为8087提供了并行执行的机会。 8086和8087的交互安排得相当巧妙。为了简化，然后8087查看指令流8086，并执行与8087相关的任何指令。困难之处在于8086具有预取指令的缓冲区，因此8086当前正在接收的指令与该指令不匹配。他表演。因此，8087复制了指令8086的正向样本的缓冲区（或指令8088的正向样本的较小缓冲区），以便知道8086忙于什么（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处将描述更多详细信息）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）另一个困难与使用8086内部寄存器的复杂8086寻址模式有关。8087无法执行这些寻址模式，因为它无法访问8086寄存器，而是当8086看到8087的指令时，它从内存中的指定位置请求数据并忽略结果。同时，如果他需要，8087从总线上获取地址。在您看来，如果未安装8087，则会在此位置形成陷阱-但这不会发生。在没有8087的系统上，链接器将重写8087指令，并将其替换为来自仿真库的子例程调用。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我不会详细介绍8087的内部工作原理，但通常来说，浮点运算是通过整数的加法，减法和移位来实现的。</font><font style="vertical-align: inherit;">要添加或减去两个浮点数，请先将数字转换为8087，直到二进制逗号对齐（类似于小数点，仅在二进制系统中），然后再添加或减去尾数。</font><font style="vertical-align: inherit;">乘法，除法和取平方根由连续的移位和加法/减法执行。</font><font style="vertical-align: inherit;">超越函数（正切，反正切，对数，度）使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CORDIC算法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，该</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">算法</font></a><font style="vertical-align: inherit;">使用移位和特殊常数相加来提高计算效率。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROM实施</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文介绍了用于存储常量的ROM。不要将其与存储微码的更大的四级ROM混淆-这最后一个是使用一种不寻常的技术实现的，该技术每个晶体管存储两位。使用三种不同尺寸的晶体管或在每个位置都没有晶体管来完成此操作。这四个选项指示两位。</font><font style="vertical-align: inherit;">为了将大型ROM装入8087芯片，需要</font><font style="vertical-align: inherit;">此项</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">复杂的技术</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
常数ROM使用标准技术来存储8087计算所需的常数（例如π，ln（2）和√2）。下图显示了带有常量的ROM的一部分。为了看到晶体本身，已从其中去除了金属层。浅粉红色的区域是带有杂质的硅，赋予其不同的性能，浅红色和绿色的线条是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多晶硅</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，一种特殊的硅布线位于顶部。注意ROM的结构，类似于正确的晶格。 ROM由两列存储位的晶体管组成。为了解释其工作方案，我将从晶体管的工作方案开始。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/10e/594/914/10e594914b3b11d2fa9fa57e2fed653f.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有常数的ROM的一部分，带有去除的金属层。三列较大的晶体管用于选择行。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1970年代的高密度集成电路（IC）通常由</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">N-MOS</font></a><font style="vertical-align: inherit;">晶体管制成</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">（现代计算机由CMOS制成，由与它们相反的N-MOS和P-MOS组成）。</font><font style="vertical-align: inherit;">下图显示了N-MOS晶体管的结构。</font><font style="vertical-align: inherit;">IC由在其上形成晶体管的硅基板组装而成。</font><font style="vertical-align: inherit;">将杂质添加到硅部位，从而产生具有所需电性能的“扩散”区域。</font><font style="vertical-align: inherit;">晶体管可以看作是一个开关，它允许电流在扩散的两个部分之间流动，这两个部分称为源极和漏极。</font><font style="vertical-align: inherit;">晶体管由特殊类型的硅-多晶硅制成的栅极控制。</font><font style="vertical-align: inherit;">向栅极施加电压可使电流在源极和漏极之间流动；</font><font style="vertical-align: inherit;">否则，没有电流流过。</font><font style="vertical-align: inherit;">8087非常复杂，上面装有约40,000个晶体管。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不同的来源为8087提供了不同数量的晶体管：英特尔说大约40,000，维基百科说大约45,000。也许整个问题在于不同的计算方法。由于ROM，PLA或其他类似结构中的晶体管数量取决于存储的数据，因此源通常指示“潜在”晶体管的数量，而不是实际晶体管的数量。您也可以考虑或不考虑上拉晶体管，或者将高电流驱动器视为一个晶体管或几个并联的晶体管。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/a8d/708/2ad/a8d7082ad4689514eafa3beb87976a76.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IP中实现的MOS结构</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过放大，可以考虑单个ROM晶体管。浅粉红色的区域是硅，杂质形成源极和漏极。多晶硅垂直选择总线形成晶体管栅极。硅的标记区域接地，并下拉每个晶体管的一侧。圆圈是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VIA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，即上面的硅和金属轮胎之间的夹层通孔。对于照片，将金属轮胎拆下；橙色线显示其中一个的位置。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/b64/c66/060/b64c66060496c9b3b31ffe4e4223da59.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有常数的ROM的一部分。每个采样总线选择一个特定的常数。晶体管以黄色显示。 X标记对应于位0的缺少的晶体管。橙色线表示金属导体的位置。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ROM的一个重要特征是缺少一些晶体管-上排没有第一个，下排则有两个标有X的晶体管。</font><font style="vertical-align: inherit;">通过改变向硅中添加杂质的电路来对ROM中的位进行编程，从而形成晶体管或留下绝缘区域。</font><font style="vertical-align: inherit;">每个可用或缺少的晶体管代表一位。</font><font style="vertical-align: inherit;">激活采样总线后，此列中的所有晶体管都会打开，从而拉低相应的输出总线。</font><font style="vertical-align: inherit;">但是，如果在所选位置没有晶体管，则相应的输出将保持高电平。</font><font style="vertical-align: inherit;">因此，通过激活采样总线从ROM读取值，该采样总线将值从ROM输出到输出总线。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ROM内容</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
具有常数的ROM由143行和21列组成。它包含134行21位，左上角有一个6×6晶体管。因此，具有常数的ROM的物理大小为2946位。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/9e4/07f/179/9e407f179428233808d1a084487ce41e.jpg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据ROM方案，缺少部分意味着前12个常量是64位而不是67位。这些是与CORDIC无关的常数，并且显然不需要额外的精度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在显微镜下，ROM位模式可见，因此可以从那里删除。但是，以后如何解释这些位一点也不明显。第一个问题是晶体管的存在指示0还是1（后来证明晶体管的存在为1）。第二个问题是如何将134×21位网格转换为值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以用两种方式定义位编码。第一个是跟踪从ROM读取数据的电路，并查看其用法。第二个是在原始数据中寻找模式并尝试理解它们。由于8087非常复杂，因此在研究常量时我想避免进行完全逆向工程，因此我使用了第二种方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
芯片的数据路径由67个水平行组成，因此很明显ROM中的134行对应两组67位常量。我从奇数序列中提取了一组常量，从偶数序列中提取了另一组常量，但是获得的值没有意义。再想一想，我意识到行并没有交替，而是重复了ABBA顺序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这些行的顺序为ABBAABBAABBA ...，其中A行包含一组常量的位，而B行包含另一组常量的位。使用这种电路来代替简单地交替使用ABAW，可能是因为一个触点可以控制两个相邻的晶体管。即，一个导体可以选择组AA和BB中的每一个。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当考虑ABBA顺序时，我得到了一堆熟悉的常数，包括π和1。下图显示了这些常数的位。在照片中，位1为绿色条，位0为红色。在二进制系统中，π为11.001001 ...，并且该值在标记位的上一行中可见。下限值是常数1。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/ed4/8f7/4d6/ed48f74d62beb0e29a0700831a82ef3d.jpg"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一行是数字π，下一行是1。与其他图表相比，该图旋转了90°。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
解释的下一个困难是仅尾数存储在ROM中，而不存储在指数中（到目前为止，我还没有找到包含指数的单独ROM）。我尝试了各种参展商，直到获得有意义的价值。有些立即清楚了：例如，常数1.204120 </font><font style="vertical-align: inherit;">使用指数2 </font><sup><font style="vertical-align: inherit;">-2</font></sup><font style="vertical-align: inherit;">给出对数</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font><font style="vertical-align: inherit;">。其他的则较难理解，例如1,734723。最后，我意识到1.734723×2 </font><sup><font style="vertical-align: inherit;">59</font></sup><font style="vertical-align: inherit;"> = 10 </font><sup><font style="vertical-align: inherit;">18</font></sup><font style="vertical-align: inherit;">。为什么在8087中会有这样的常数？也许是因为8087支持</font><font style="vertical-align: inherit;">18个字符的</font><font style="vertical-align: inherit;">压缩</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">二进制十进制代码</font></a><font style="vertical-align: inherit;">。</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有些指数很难找到，我使用了蛮力法来查看结果是否会产生任何对数或一定数量的度数。</font><font style="vertical-align: inherit;">最困难的是确定ln（2）/ 3的常数。</font><font style="vertical-align: inherit;">我不清楚这个数字的重要性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是ROM中常量的完整列表。</font><font style="vertical-align: inherit;">“含义”列是我对含义的描述。</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常数</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十进制值</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">含义</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.204120×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3010300</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日志</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（2）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.386294×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1</font></font></sup></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.6931472</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ln（2）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.442695×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.426950 </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日志</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（e）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.570796×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1415927</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">π</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.000000×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.000000 </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.660964×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.219281 </font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">日志</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（10）</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.734723×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.00e + 18</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sup></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.734723×2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">59</font></font></sup> </td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.00e + 18</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sup></td>
</tr>
<tr>
<td>1.848392×2<sup>-3</sup></td>
<td>0.2310491</td>
<td>ln(2)/3</td>
</tr>
<tr>
<td>1.082021×2<sup>2</sup> </td>
<td>4.280851 </td>
<td>3*log<sub>2</sub>(e)</td>
</tr>
<tr>
<td>1.442695×2<sup>0</sup> </td>
<td>1.426950 </td>
<td>log<sub>2</sub> (e)</td>
</tr>
<tr>
<td>1.414214×2<sup>0</sup> </td>
<td>1.4142136</td>
<td>√2</td>
</tr>
<tr>
<td>1.570796×2<sup>-1</sup></td>
<td>0.7853982</td>
<td>atan(2<sup>0</sup>)</td>
</tr>
<tr>
<td>1.854590×2<sup>-2</sup></td>
<td>0.4636476</td>
<td>atan(2<sup>-1</sup>)</td>
</tr>
<tr>
<td>2.000000×2<sup>-15</sup></td>
<td>0.0000610</td>
<td>atan(2<sup>-14</sup>)</td>
</tr>
<tr>
<td>2.000000×2<sup>-16</sup></td>
<td>0.0000305</td>
<td>atan(2<sup>-15</sup>)</td>
</tr>
<tr>
<td>1.959829×2<sup>-3</sup></td>
<td>0.2449787</td>
<td>atan(2<sup>-2</sup>)</td>
</tr>
<tr>
<td>1.989680×2<sup>-4</sup></td>
<td>0.1243550</td>
<td>atan(2<sup>-3</sup>)</td>
</tr>
<tr>
<td>2.000000×2<sup>-13</sup></td>
<td>0.0002441</td>
<td>atan(2<sup>-12</sup>)</td>
</tr>
<tr>
<td>2.000000×2<sup>-14</sup></td>
<td>0.0001221</td>
<td>atan(2<sup>-13</sup>)</td>
</tr>
<tr>
<td>1.997402×2<sup>-5</sup></td>
<td>0.0624188</td>
<td>atan(2<sup>-4</sup>)</td>
</tr>
<tr>
<td>1.999349×2<sup>-6</sup></td>
<td>0.0312398</td>
<td>atan(2<sup>-5</sup>)</td>
</tr>
<tr>
<td>1.999999×2<sup>-11</sup></td>
<td>0.0009766</td>
<td>atan(2<sup>-10</sup>)</td>
</tr>
<tr>
<td>2.000000×2<sup>-12</sup></td>
<td>0.0004883</td>
<td>atan(2<sup>-11</sup>)</td>
</tr>
<tr>
<td>1.999837×2<sup>-7</sup></td>
<td>0.0156237</td>
<td>atan(2<sup>-6</sup>)</td>
</tr>
<tr>
<td>1.999959×2<sup>-8</sup></td>
<td>0.0078123</td>
<td>atan(2<sup>-7</sup>)</td>
</tr>
<tr>
<td>1.999990×2<sup>-9</sup></td>
<td>0.0039062</td>
<td>atan(2<sup>-8</sup>)</td>
</tr>
<tr>
<td>1.999997×2<sup>-10</sup></td>
<td>0.0019531</td>
<td>atan(2<sup>-9</sup>)</td>
</tr>
<tr>
<td>1.441288×2<sup>-9</sup></td>
<td>0.0028150</td>
<td>log<sub>2</sub>(1+2<sup>-9</sup>)</td>
</tr>
<tr>
<td>1.439885×2<sup>-8</sup></td>
<td>0.0056245</td>
<td>log<sub>2</sub>(1+2<sup>-8</sup>)</td>
</tr>
<tr>
<td>1.437089×2<sup>-7</sup></td>
<td>0.0112273</td>
<td>log<sub>2</sub>(1+2<sup>-7</sup>)</td>
</tr>
<tr>
<td>1.431540×2<sup>-6</sup></td>
<td>0.0223678</td>
<td>log<sub>2</sub>(1+2<sup>-6</sup>)</td>
</tr>
<tr>
<td>1.442343×2<sup>-11</sup></td>
<td>0.0007043</td>
<td>log<sub>2</sub>(1+2<sup>-11</sup>)</td>
</tr>
<tr>
<td>1.441991×2<sup>-10</sup></td>
<td>0.0014082</td>
<td>log<sub>2</sub>(1+2<sup>-10</sup>)</td>
</tr>
<tr>
<td>1.420612×2<sup>-5</sup></td>
<td>0.0443941</td>
<td>log<sub>2</sub>(1+2<sup>-5</sup>)</td>
</tr>
<tr>
<td>1.399405×2<sup>-4</sup></td>
<td>0.0874628</td>
<td>log<sub>2</sub>(1+2<sup>-4</sup>)</td>
</tr>
<tr>
<td>1.442607×2<sup>-13</sup></td>
<td>0.0001761</td>
<td>log<sub>2</sub>(1+2<sup>-13</sup>)</td>
</tr>
<tr>
<td>1.442519×2<sup>-12</sup></td>
<td>0.0003522</td>
<td>log<sub>2</sub>(1+2<sup>-12</sup>)</td>
</tr>
<tr>
<td>1.359400×2<sup>-3</sup></td>
<td>0.1699250</td>
<td>log<sub>2</sub>(1+2<sup>-3</sup>)</td>
</tr>
<tr>
<td>1.287712×2<sup>-2</sup></td>
<td>0.3219281</td>
<td>log<sub>2</sub>(1+2<sup>-2</sup>)</td>
</tr>
<tr>
<td>1.442673×2<sup>-15</sup></td>
<td>0.0000440</td>
<td>log<sub>2</sub>(1+2<sup>-15</sup>)</td>
</tr>
<tr>
<td>1.442651×2<sup>-14</sup></td>
<td>0.0000881</td>
<td>log<sub>2</sub>(1+2<sup>-14</sup>)</td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不知道为什么</font><font style="vertical-align: inherit;">重复</font><font style="vertical-align: inherit;">10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18-</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许差异是指数的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在物理上，常数位于三组中。第一组是用户能够加载（1，π，登录值</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10，登录</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> E，日志</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2和Ln），以及在内部使用（值10 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">18</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，LN（2）/ 3，3 * log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（e），log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（e）和√2）。第二组由16个反正切常数组成，第三组由14个log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常数组成</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在8087中，有七个直接加载常量的指令。指令FDLZ，FLD1，FLDPI，FLD2T，FLD2E，FLDLG2和FLDLN2将常数0、1，π，log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10，log </font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">加载到堆栈中</font></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e，分别记录</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2和ln 2。</font><font style="vertical-align: inherit;">除了0以外，所有这些常量都存储在ROM中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后两组常数用于使用CORDIC算法计算先验函数。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CORDIC算法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过ROM中的常量，您可以找到8087算法的一些操作细节.ROM包含16个反正切值，反正切从2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-n值开始</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在（1 + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的基数2上还存储了14个对数</font><font style="vertical-align: inherit;">。这样的值看似不寻常，但它们被用于1958年发明的高效CORDIC算法中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CORDIC的想法是可以通过将矢量旋转这些角度将角度分成更小的角度来计算切线和反正切。诀窍是，如果选择合适的较小角度，则可以通过有效的移位和加法运算而不是三角函数来计算每次旋转。假设我们需要找到tan（z）。我们可以将z分成小角度的和：z≈{atan（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或0} + {atan（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或0} + {atan（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或0} + ... + {atan（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-16</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或0}。您可以</font><font style="vertical-align: inherit;">通过乘以2 </font><sup><font style="vertical-align: inherit;">-2</font></sup><font style="vertical-align: inherit;">并相加</font><font style="vertical-align: inherit;">来将</font><font style="vertical-align: inherit;">向量旋转atan（2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">。最重要的是，乘以2 </font><sup><font style="vertical-align: inherit;">-2是</font></sup><font style="vertical-align: inherit;">通过快速按位移位进行的，考虑到所有这些，您可以通过将z与atan常数进行比较来计算tan（z），然后经过16个加法和移位循环，在铁上快速完成。预先计算出atan并将其存储在ROM中，反正切的计算方法与此类似，反之亦然-在旋转过程中，对角度（来自具有常数的ROM）求和并给出最终的角度。</font></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><sup><font style="vertical-align: inherit;"></font></sup><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在计算对数和指数时，还使用CORDIC算法及其对应的对数常数。这里最主要的是，</font><font style="vertical-align: inherit;">可以借助移位和加法快速完成</font><font style="vertical-align: inherit;">（1 + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）的</font><font style="vertical-align: inherit;">乘法运算</font><font style="vertical-align: inherit;">。对数和指数可以通过将方程的一侧与一系列值相乘，然后将对应的对数常数加到另一侧来计算。根据用于计算8087文档的对数和指数的算法，我没有找到它。我认为它们与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一篇文章中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述的相似</font><font style="vertical-align: inherit;">，只有8087使用基数2而不是e。我不明白为什么8087没有</font><font style="vertical-align: inherit;">该算法所需</font><font style="vertical-align: inherit;">的log </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常数</font><font style="vertical-align: inherit;">（1 + 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-1</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在8087中对先验功能的支持并不像您期望的那样广泛。</font><font style="vertical-align: inherit;">它仅支持切线和反正切，没有正弦和余弦。</font><font style="vertical-align: inherit;">要计算后者，必须应用三角恒等式。</font><font style="vertical-align: inherit;">对数和指数仅支持2的底数-对于10或e的底数，用户将必须应用比例因子。</font><font style="vertical-align: inherit;">一次，8087扩展了芯片容量的限制，因此指令的数量减至最少。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
8087是一个复杂的芯片，乍一看它看上去就像是一个无望的纠结迷宫。但是，在大多数情况下，经过仔细研究后可以理解。在其ROM中存储了42个常量，可以使用显微镜提取它们的值。预期某些常数（例如π），而其他常数（例如ln（2）/ 3）提出了更多问题。许多常量用于使用CORDIC算法计算正切，反正切，对数和度。</font><i><font style="vertical-align: inherit;">不含金属层的晶体8087的照片。可点击的。</font></i></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/er/8g/3t/er8g3tlcli1uc7ag_qe-todazvy.jpeg"></a><br>
<i><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管40年前就推出了用于浮点运算的英特尔8087，但仍能感受到它的影响。</font><font style="vertical-align: inherit;">他催生了用于大多数算术计算的IEEE 754标准浮点数，并且8087指令仍然是大多数计算机上使用的x86处理器的一部分。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN503014/index.html">拖把的几根吸管</a></li>
<li><a href="../zh-CN503024/index.html">品牌保护：欧盟和2020年扩大规模</a></li>
<li><a href="../zh-CN503026/index.html">升级CSS动画</a></li>
<li><a href="../zh-CN503028/index.html">在.NET Core中加载和处理图像</a></li>
<li><a href="../zh-CN503032/index.html">Kubernetes中的长DNS解析</a></li>
<li><a href="../zh-CN503040/index.html">像僵尸病毒一样的“西班牙人”能否在永冻土中生存？</a></li>
<li><a href="../zh-CN503042/index.html">关于红色团队的5个神话</a></li>
<li><a href="../zh-CN503052/index.html">Microfront的自动化，或如何在Tinkoff中测试组件库</a></li>
<li><a href="../zh-CN503054/index.html">一杯咖啡滴与量子力学之间有什么共同点？</a></li>
<li><a href="../zh-CN503056/index.html">5月23日，在线酒吧：关于云，JS和手机的Holivarim</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>