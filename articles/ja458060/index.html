<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🚒 👌🏿 💔 Unityエンジンでグラスシェーダーを作成する 📢 💈 ☝🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このチュートリアルでは、ジオメトリシェーダーを作成して、入力メッシュの上部から草の葉を生成し、テッセレーションを使用して草の密度を制御する方法を示します。
 
 この記事では、Unityでグラスシェーダーを作成する手順について説明します。シェーダーは入力メッシュを受け取り、メッシュの各頂点から、幾何...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Unityエンジンでグラスシェーダーを作成する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458060/"><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルでは、ジオメトリシェーダーを作成して、入力メッシュの上部から草の葉を生成し、テッセレーションを使用して草の密度を制御する方法を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、Unityでグラスシェーダーを作成する手順について説明します。シェーダーは入力メッシュを受け取り、メッシュの各頂点から、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幾何学的シェーダー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">草の</font><font style="vertical-align: inherit;">葉を生成し</font><font style="vertical-align: inherit;">ます。興味とリアリズムのために、草の葉は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ランダムなサイズ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回転</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を持ち、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">風の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影響も受け</font><font style="vertical-align: inherit;">ます。草の密度を制御するために、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用</font><font style="vertical-align: inherit;">して入力メッシュを分離します。草ができるようになります</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャスト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受信</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">影を。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完成したプロジェクト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">記事の最後にレイアウト。</font><font style="vertical-align: inherit;">生成されたシェーダーファイルには、理解を簡単にする多数のコメントが含まれています。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要条件</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルを完了するには、Unityエンジンに関する実践的な知識と、シェーダーの構文と機能の最初の理解が必要です。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロジェクトのドラフト（.zip）をダウンロードし</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">働き始める</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトのドラフトをダウンロードし、Unityエディターで開きます。</font><font style="vertical-align: inherit;">シーン</font></font><code>Main</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を開き、コードエディターでシェーダーを開きます</font></font><code>Grass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このファイルには、白色を生成するシェーダーと、このチュートリアルで使用するいくつかの関数が含まれています。</font><font style="vertical-align: inherit;">これらの関数は、頂点シェーダーとともに、の</font><em><font style="vertical-align: inherit;">外側</font></em><font style="vertical-align: inherit;">にあるブロック</font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">含まれています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このブロックに配置されたコード</font><font style="vertical-align: inherit;">は、シェーダーの</font><strong><font style="vertical-align: inherit;">すべてのパス</font></strong><font style="vertical-align: inherit;">に</font><strong><font style="vertical-align: inherit;">自動的に含まれ</font></strong><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">シェーダーには複数のパスがあるため、これは後で便利になります。</font><font style="vertical-align: inherit;">
まず</font><font style="vertical-align: inherit;">、メッシュの表面の各頂点から三角形を生成</font><font style="vertical-align: inherit;">する</font><strong><font style="vertical-align: inherit;">幾何学的シェーダー</font></strong><font style="vertical-align: inherit;">を作成します。</font></font><em><font style="vertical-align: inherit;"></font></em> <code>SubShader</code><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.幾何学的シェーダー</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幾何学的シェーダーは、レンダリングパイプラインのオプションの部分です。</font><font style="vertical-align: inherit;">これらは</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点シェーダー（またはテッセレーションが使用されている場合はテッセレーションシェーダー）の後で、フラグメントシェーダーの頂点が処理される前に</font><font style="vertical-align: inherit;">実行され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef7/c01/458/ef7c01458cadf7cd0cf46695d7114f96.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Direct3Dグラフィックパイプライン11.この図では、フラグメントシェーダーが</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ピクセルシェーダー</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれていることに注意してください</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
幾何学的シェーダーは、入力で単一の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリミティブ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を受け取り、</font><font style="vertical-align: inherit;">ゼロ、1つ、または多くのプリミティブを生成できます。</font><font style="vertical-align: inherit;">まず、入力で</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（または</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポイント</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を受け取り、</font><font style="vertical-align: inherit;">草の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">葉を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表す</font><strong><font style="vertical-align: inherit;">1つの三角形に</font></strong><font style="vertical-align: inherit;">フィード</font><font style="vertical-align: inherit;">する幾何学的シェーダーを記述</font><font style="vertical-align: inherit;">します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add inside the CGINCLUDE block.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">geometryOutput</span>
{</span><font></font>
	float4 pos : SV_POSITION;<font></font>
};<font></font>
<font></font>
[maxvertexcount(<span class="hljs-number">3</span>)]
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">geo</span><span class="hljs-params">(triangle float4 IN[<span class="hljs-number">3</span>] : SV_POSITION, inout TriangleStream&lt;geometryOutput&gt; triStream)</span>
</span>{<font></font>
}<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add inside the SubShader Pass, just below the #pragma fragment frag line.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> geometry geo</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のコードは</font></font><code>geo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、2つのパラメーターで</font><font style="vertical-align: inherit;">名前が付けられた幾何学的シェーダーを宣言してい</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">最初の1つは</font></font><code>triangle float4 IN[3]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、1つの三角形（3つの点で構成される）を入力として受け取ると報告しています。</font><font style="vertical-align: inherit;">2番目は、のように</font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、各頂点が構造を使用してデータを送信するように、三角形のストリームを出力する</font><font style="vertical-align: inherit;">よう</font><font style="vertical-align: inherit;">にシェーダーを設定します</font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーは1つの頂点を受け取り、草の葉を出力することを前述しました。</font><font style="vertical-align: inherit;">なぜ三角形になるのですか？</font></font></b><div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入力として受け取る方が安価</font></font><code></code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは次のように行うことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">geo</span><span class="hljs-params">(point vertexOutput IN[<span class="hljs-number">1</span>], inout TriangleStream&lt;geometryOutput&gt; triStream)</span></span></code></pre><br>
     (    <code>GrassPlane10x10</code>,    <code>Mesh</code>)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a>,           .    <strong></strong>  DirectX HLSL,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  OpenGL</a>,    .</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、関数宣言の上に括弧内の最後のパラメーターを追加します</font></font><code>[maxvertexcount(3)]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼はGPUに</font><em><font style="vertical-align: inherit;">、</font></em><font style="vertical-align: inherit;"> 3つ</font><em><font style="vertical-align: inherit;">以下の</font></em><font style="vertical-align: inherit;">頂点</font><font style="vertical-align: inherit;">を出力する（ただし</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必須で</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はない）</font><strong><font style="vertical-align: inherit;">と</font></strong><font style="vertical-align: inherit;">伝えます</font><font style="vertical-align: inherit;">。また、</font><font style="vertical-align: inherit;">内部で宣言することにより、ジオメトリックシェーダーを使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">
ジオメトリシェーダーはまだ何もしていません。三角形を描画するには、ジオメトリックシェーダー内に次のコードを追加します。</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><code>SubShader</code><font style="vertical-align: inherit;"></font><code>Pass</code><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs">geometryOutput o;<font></font>
<font></font>
o.pos = float4(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
triStream.Append(o);<font></font>
<font></font>
o.pos = float4(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
triStream.Append(o);<font></font>
<font></font>
o.pos = float4(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<font></font>
triStream.Append(o);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0db/534/ac1/0db534ac10c125955829fd53b9923cd7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは非常に奇妙な結果をもたらしました。カメラを動かすと、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面スペースに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形がレンダリングされていることがはっきりし</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。これは論理的です。ジオメトリックシェーダーは頂点を処理する直前に実行されるため、頂点シェーダーから頂点</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が切り捨て空間に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示される責任</font><strong><font style="vertical-align: inherit;">が取り除かれます</font></strong><font style="vertical-align: inherit;">。これを反映するようにコードを変更します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Update the return call in the vertex shader.</span>
<span class="hljs-comment">//return UnityObjectToClipPos(vertex);</span>
<span class="hljs-keyword">return</span> vertex;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Update each assignment of o.pos in the geometry shader.</span>
o.pos = UnityObjectToClipPos(float4(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<font></font>
<font></font>
…<font></font>
<font></font>
o.pos = UnityObjectToClipPos(float4(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));<font></font>
<font></font>
…<font></font>
<font></font>
o.pos = UnityObjectToClipPos(float4(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/221/912/b3e/221912b3e6bc0581126a0f415b6e79c5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、三角形が世界で正しくレンダリングされました。</font><font style="vertical-align: inherit;">ただし、1つしか作成されていないようです。</font><font style="vertical-align: inherit;">実際、</font><font style="vertical-align: inherit;">メッシュの頂点ごと</font><font style="vertical-align: inherit;">に1つの三角形が</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描画さ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れますが、三角形の頂点に割り当てられた位置は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、入力頂点ごとに変化しません。</font><font style="vertical-align: inherit;">したがって、すべての三角形は他の三角形の上に配置されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを修正する</font><font style="vertical-align: inherit;">には、入力</font><font style="vertical-align: inherit;">頂点</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基準にして</font><font style="vertical-align: inherit;">出力頂点の位置を</font><strong><font style="vertical-align: inherit;">オフセットし</font></strong><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the top of the geometry shader.</span>
float3 pos = IN[<span class="hljs-number">0</span>];<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Update each assignment of o.pos.</span>
o.pos = UnityObjectToClipPos(pos + float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<font></font>
<font></font>
…<font></font>
<font></font>
o.pos = UnityObjectToClipPos(pos + float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<font></font>
<font></font>
…<font></font>
<font></font>
o.pos = UnityObjectToClipPos(pos + float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6b2/ac4/84c/6b2ac484c5a033b18e88400e10191779.png"></div><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一部の頂点が三角形を作成しないのはなぜですか？</font></font></b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cab/447/d9c/cab447d9c4c82d8208a28e7cee2f7807.png"></div><br>
   ,     <strong></strong>,     <strong></strong>   ,   . ,         ,     ,          .<br>
<br>
     ,        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Points</a>.</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形は正しく描画され、それらのベースはそれらを放出するピークに位置しています。</font><font style="vertical-align: inherit;">次に進む前に、オブジェクトを</font><font style="vertical-align: inherit;">シーン内で</font></font><code>GrassPlane</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非アクティブ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にし</font></font><code>GrassBall</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">オブジェクトを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブにし</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">さまざまなタイプのサーフェスで芝生を正しく生成したいので、さまざまな形状のメッシュで芝生をテストすることが重要です。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19b/f67/8fb/19bf678fbb6ce3c03956dbdf068004f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、すべての三角形は一方向に放出されており、球の表面から外向きには放出されていません。</font><font style="vertical-align: inherit;">この問題を解決するために、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線空間</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に草の葉を作成します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.接線スペース</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的には、草の葉が放出されるサーフェスの角度を考慮せずに、異なる幅、高さ、曲率、回転を設定して、草の葉を作成したいと考えています。簡単に言えば、それを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">放出する頂点にローカル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">な空間に草の葉を定義し、</font><font style="vertical-align: inherit;">それを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッシュにローカルに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なるように変換し</font><font style="vertical-align: inherit;">ます。この空間は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">空間と呼ばれ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fd/8f7/c39/3fd8f7c394bf4eb18cb988aceafe342b.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線空間では、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸</font><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸</font><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸</font><font style="vertical-align: inherit;">は、法線とサーフェスの位置（この場合は頂点）を基準にして定義されます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
他の空間と同様に、3つのベクトル（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">right</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forward</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">up）で</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点の接線空間を定義できます</font><font style="vertical-align: inherit;">。これらのベクトルを使用して、芝生のブレードを接線からローカル空間に向けるための行列を作成できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはベクトルにアクセスすることができ</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、右</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アップ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しい入力頂点データを追加することによって。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertexInput</span>
{</span><font></font>
	float4 vertex : POSITION;<font></font>
	float3 normal : NORMAL;<font></font>
	float4 tangent : TANGENT;<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vertexOutput</span>
{</span><font></font>
	float4 vertex : SV_POSITION;<font></font>
	float3 normal : NORMAL;<font></font>
	float4 tangent : TANGENT;<font></font>
};<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the vertex shader.</span>
<span class="hljs-function">vertexOutput <span class="hljs-title">vert</span><span class="hljs-params">(vertexInput v)</span>
</span>{<font></font>
	vertexOutput o;<font></font>
	o.vertex = v.vertex;<font></font>
	o.normal = v.normal;<font></font>
	o.tangent = v.tangent;<font></font>
	<span class="hljs-keyword">return</span> o;<font></font>
}<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the input for the geometry shader. Note that the SV_POSITION semantic is removed.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">geo</span><span class="hljs-params">(triangle vertexOutput IN[<span class="hljs-number">3</span>], inout TriangleStream&lt;geometryOutput&gt; triStream)</span>

…

<span class="hljs-comment">// Modify the existing line declaring pos.</span>
float3 pos </span>= IN[<span class="hljs-number">0</span>].vertex;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のベクトルは</font><font style="vertical-align: inherit;">、他の2つの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトルの積</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をとることによって計算できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ベクトル積は、</font><font style="vertical-align: inherit;">2つの入力</font><font style="vertical-align: inherit;">ベクトルに</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">垂直な</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトルを返します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Place in the geometry shader, below the line declaring float3 pos.		</span>
float3 vNormal = IN[<span class="hljs-number">0</span>].normal;<font></font>
float4 vTangent = IN[<span class="hljs-number">0</span>].tangent;<font></font>
float3 vBinormal = cross(vNormal, vTangent) * vTangent.w;</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベクトル積の結果に接線wの座標が乗算されるのはなぜですか？</font></font></b><div class="spoiler_text">    3D-     (  <em>   </em>),     .     Unity           <strong>w</strong>.    ,         .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>.</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つのベクトルすべてを使用して、接線空間とローカル空間の間の変換のための行列を作成できます。</font></font><code>UnityObjectToClipPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ローカル空間の頂点を期待する</font><font style="vertical-align: inherit;">を渡す前に、草の葉の各頂点にこの行列を乗算し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the lines declaring the three vectors.</span><font></font>
float3x3 tangentToLocal = float3x3(<font></font>
	vTangent.x, vBinormal.x, vNormal.x,<font></font>
	vTangent.y, vBinormal.y, vNormal.y,<font></font>
	vTangent.z, vBinormal.z, vNormal.z<font></font>
	);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
行列を使用する前に、同じコード行を何度も記述しないように、頂点出力コードを関数に転送します。</font><font style="vertical-align: inherit;">これは呼ばれる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRY原則を</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、または</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自分自身を繰り返さないでください</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-function">geometryOutput <span class="hljs-title">VertexOutput</span><span class="hljs-params">(float3 pos)</span>
</span>{<font></font>
	geometryOutput o;<font></font>
	o.pos = UnityObjectToClipPos(pos);<font></font>
	<span class="hljs-keyword">return</span> o;<font></font>
}<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Remove the following from the geometry shader.</span>
<span class="hljs-comment">//geometryOutput o;</span><font></font>
<font></font>
<span class="hljs-comment">//o.pos = UnityObjectToClipPos(pos + float3(0.5, 0, 0));</span>
<span class="hljs-comment">//triStream.Append(o);</span><font></font>
<font></font>
<span class="hljs-comment">//o.pos = UnityObjectToClipPos(pos + float3(-0.5, 0, 0));</span>
<span class="hljs-comment">//triStream.Append(o);</span><font></font>
<font></font>
<span class="hljs-comment">//o.pos = UnityObjectToClipPos(pos + float3(0, 1, 0));</span>
<span class="hljs-comment">//triStream.Append(o);</span><font></font>
<font></font>
<span class="hljs-comment">// ...and replace it with the code below.</span>
triStream.Append(VertexOutput(pos + float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、出力頂点に行列を掛けて</font></font><code>tangentToLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、入力点の法線と正しく位置合わせします。</font></font><br>
<br>
<pre><code class="cpp hljs">triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))));<font></font>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))));<font></font>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>))));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c95/3f8/286/c953f828675a9d4e202c0c9349d37f9d.png" alt="画像"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私たちが必要としているものに似ていますが、正しくありません。</font><font style="vertical-align: inherit;">ここでの問題は、最初に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸の「上」（上）の方向を割り当てたこと</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">ただし、接線空間では、上方向は通常</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸に沿って配置されます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次に、これらの変更を行います。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Modify the position of the third vertex being emitted.</span>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0cf/f51/ddb/0cff51ddbea12280cb78a1db9ada1786.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.草の出現</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形を草の葉のように見せるには、色とバリエーションを追加する必要があります。</font><font style="vertical-align: inherit;">まず</font><font style="vertical-align: inherit;">、草の葉の上から下に向かって</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラデーション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.1色のグラデーション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの目標は、アーティストが上と下の2つの色を設定できるようにし、これら2つの色の間を補間して、草の葉の根元に向けることです。</font><font style="vertical-align: inherit;">これらの色は、シェーダーファイルでもすでに定義されてい</font></font><code>_TopColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font><code>_BottomColor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">適切にサンプリングするには、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV座標</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をフラグメントシェーダーに渡す必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the geometryOutput struct.</span><font></font>
float2 uv : TEXCOORD0;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the VertexOutput function signature.</span>
<span class="hljs-function">geometryOutput <span class="hljs-title">VertexOutput</span><span class="hljs-params">(float3 pos, float2 uv)</span>

…

<span class="hljs-comment">// Add to VertexOutput, just below the line assigning o.pos.</span>
o.uv </span>= uv;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing lines in the geometry shader.</span>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(tangentToLocal, float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)), float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>)));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形の形をした草の葉のUV座標を作成しました。ベースの2つの頂点は左下と右下にあり、先端の上部は中央の上部にあります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/165/e39/932/165e399323aaa07e7c4cee728c0c9988.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">草の葉の3つの頂点のUV座標。</font><font style="vertical-align: inherit;">草の葉を単純なグラデーションでペイントしますが、テクスチャを同様に配置すると、テクスチャをオーバーレイできます。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、UVを使用してフラグメントシェーダーの上部と下部の色をサンプリングし、を使用してそれらを補間できます</font></font><code>lerp</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また、フラグメントシェーダーのパラメーターを変更して</font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、位置だけでなく</font><font style="vertical-align: inherit;">入力データを作成する必要もあります</font></font><code>float4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Modify the function signature of the fragment shader.</span>
<span class="hljs-function">float4 <span class="hljs-title">frag</span> <span class="hljs-params">(geometryOutput i, fixed facing : VFACE)</span> : SV_Target

…

<span class="hljs-comment">// Replace the existing return call.</span>
<span class="hljs-keyword">return</span> <span class="hljs-title">float4</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<font></font>
<font></font>
<span class="hljs-keyword">return</span> lerp(_BottomColor, _TopColor, i.uv.y);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/596/510/51f/59651051f474907a88740e83bc9d4532.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2草の葉のランダムな方向</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バリエーションを作成して芝生をより自然な外観にするために、芝生の各ブレードをランダムな方向に向けます。これを行うには、草のブレードを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アップ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸を中心にランダムに回転させる回転行列を作成する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うのに役立つシェーダーファイルには2つの関数があります</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。3次元入力から乱数を生成し</font></font><code>AngleAxis3x3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、角度（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ラジアン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">受け取り、</font><font style="vertical-align: inherit;">この値を指定された軸を中心に回転させる行列を返します。後者の関数は、C＃</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quaternion.AngleAxis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数とまったく同じように機能します</font><font style="vertical-align: inherit;">（</font></font><code>AngleAxis3x3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">四元数ではなく行列</font><font style="vertical-align: inherit;">のみを</font><font style="vertical-align: inherit;">返します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数</font></font><code>rand</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は0 ... 1の範囲の数値を返します。それを掛けます</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角度値の全範囲を取得するには、</font><strong><font style="vertical-align: inherit;">2 Pi</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring the tangentToLocal matrix.</span>
float3x3 facingRotationMatrix = AngleAxis3x3(rand(pos) * UNITY_TWO_PI, float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力位置</font></font><code>pos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をランダム回転のシードとして</font><font style="vertical-align: inherit;">使用し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このため、草の各ブレードには、各フレームで一定の独自の回転があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作成した行列を掛けることで、草の葉に回転を適用できます</font></font><code>tangentToLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">行列の乗算は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">可換で</font></a><font style="vertical-align: inherit;">は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></strong> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">オペランドの順序は</font><strong><font style="vertical-align: inherit;">重要</font></strong><font style="vertical-align: inherit;">です。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring facingRotationMatrix.</span><font></font>
float3x3 transformationMatrix = mul(tangentToLocal, facingRotationMatrix);<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Replace the multiplication matrix operand with our new transformationMatrix.</span>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(<span class="hljs-number">0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(<span class="hljs-number">-0.5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)), float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>)));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09f/c2f/e80/09fc2fe8028b51f78989954e65812cd3.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3ランダム前方曲げ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の葉がすべて完全に揃っている場合、それらは同じように見えます。</font><font style="vertical-align: inherit;">これは、整えられた芝生など、手入れの行き届いた芝生に適しているかもしれませんが、自然では芝生はそのようには育ちません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">沿って草を回転させるための新しい行列と、</font><font style="vertical-align: inherit;">この回転を制御するプロパティを作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as a new property.</span>
_BendRotationRandom(<span class="hljs-string">"Bend Rotation Random"</span>, Range(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) = <span class="hljs-number">0.2</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-keyword">float</span> _BendRotationRandom;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the geometry shader, below the line declaring facingRotationMatrix.</span>
float3x3 bendRotationMatrix = AngleAxis3x3(rand(pos.zzx) * _BendRotationRandom * UNITY_PI * <span class="hljs-number">0.5</span>, float3(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、草の葉の位置をランダムシードとして使用</font><font style="vertical-align: inherit;">します。</font><font style="vertical-align: inherit;">今度は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">スイープし</font></a><font style="vertical-align: inherit;">て一意のシードを作成します。</font><font style="vertical-align: inherit;">また</font></font><code>UNITY_PI</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.5を</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">掛け</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">これにより、0〜90度のランダムな間隔が得られます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この行列を回転によって再度適用し、すべてを正しい順序で乗算します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Modify the existing line.</span>
float3x3 transformationMatrix = mul(mul(tangentToLocal, facingRotationMatrix), bendRotationMatrix);</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/49c/122/534/49c122534d7298c0f9c646501a708daa.gif"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.4幅と高さ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の葉のサイズは幅1ユニット、高さ1ユニットに制限されています。</font><font style="vertical-align: inherit;">サイズを制御するためのプロパティと、ランダムなバリエーションを追加するためのプロパティを追加します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as new properties.</span>
_BladeWidth(<span class="hljs-string">"Blade Width"</span>, Float) = <span class="hljs-number">0.05</span>
_BladeWidthRandom(<span class="hljs-string">"Blade Width Random"</span>, Float) = <span class="hljs-number">0.02</span>
_BladeHeight(<span class="hljs-string">"Blade Height"</span>, Float) = <span class="hljs-number">0.5</span>
_BladeHeightRandom(<span class="hljs-string">"Blade Height Random"</span>, Float) = <span class="hljs-number">0.3</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-keyword">float</span> _BladeHeight;
<span class="hljs-keyword">float</span> _BladeHeightRandom;	
<span class="hljs-keyword">float</span> _BladeWidth;
<span class="hljs-keyword">float</span> _BladeWidthRandom;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the geometry shader, above the triStream.Append calls.</span>
<span class="hljs-keyword">float</span> height = (rand(pos.zyx) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * _BladeHeightRandom + _BladeHeight;
<span class="hljs-keyword">float</span> width = (rand(pos.xzy) * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * _BladeWidthRandom + _BladeWidth;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing positions with our new height and width.</span>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(-width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(transformationMatrix, float3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, height)), float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>)));</code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35b/22e/f34/35b22ef34945a576100a152a0e25eec5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
三角形は今や草の葉のようになっていますが、少なすぎます。</font><font style="vertical-align: inherit;">入力メッシュには、密集したフィールドの印象を作成するのに十分なピークがないだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つの解決策は、C＃を使用するか、3Dエディターで新しい、より高密度のメッシュを作成することです。</font><font style="vertical-align: inherit;">これは機能しますが、草の密度を動的に制御することはできません。</font><font style="vertical-align: inherit;">代わりに、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して入力メッシュを分割し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.テセレーション</font></font></h2><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーション</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、レンダリングパイプラインのオプションのステージであり、頂点シェーダーの後で、ジオメトリシェーダー（存在する場合）の前に実行されます。そのタスクは、1つの入力サーフェスを多くのプリミティブに分割することです。テッセレーションは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダー</font><font style="vertical-align: inherit;">と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメイン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーの</font><font style="vertical-align: inherit;">2つのプログラム可能なステップで実装され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーフェスシェーダーの場合、Unityには</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーションの実装が組み込まれてい</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。ただし、</font><font style="vertical-align: inherit;">サーフェスシェーダーを</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用しないため</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、独自のシェルシェーダーとドメインシェーダーを実装する必要があります。この記事では、テッセレーションの実装については詳しく説明しません</font></font><code>CustomTessellation.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">既存のファイルをそのまま使用します</font><font style="vertical-align: inherit;">。このファイルは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">Catlike Coding</font></a><font style="vertical-align: inherit;">から</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">改変</font></a><font style="vertical-align: inherit;">されたもの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、Unityのテッセレーション実装に関する優れた情報源です。</font><font style="vertical-align: inherit;">シーンに</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを含めると、</font></font><code>TessellationExample</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーションを実装するマテリアルがすでに含まれていることがわかります。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tessellation Uniform</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロパティを変更すると</font><font style="vertical-align: inherit;">、サブディビジョンの効果がわかります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d8/8a7/f01/2d88a7f01e3a7462ffd0c8f20953b5ca.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プレーンの密度を制御するためにグラスシェーダーにテッセレーションを実装し、生成されるグラスのブレードの数を制御します。</font><font style="vertical-align: inherit;">まず、ファイルを追加する必要があります</font></font><code>CustomTessellation.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">シェーダーへの</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相対</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスで</font><font style="vertical-align: inherit;">参照し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add inside the CGINCLUDE block, below the other #include statements.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"Shaders/CustomTessellation.cginc"</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開くと</font></font><code>CustomTessellation.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、構造</font></font><code>vertexInput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>vertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点シェーダーが</font><font style="vertical-align: inherit;">既に定義されていること</font><font style="vertical-align: inherit;">がわかります。</font><font style="vertical-align: inherit;">グラスシェーダーで再定義する必要はありません。</font><font style="vertical-align: inherit;">削除できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/*struct vertexInput
{
	float4 vertex : POSITION;
	float3 normal : NORMAL;
	float4 tangent : TANGENT;
};

struct vertexOutput
{
	float4 vertex : SV_POSITION;
	float3 normal : NORMAL;
	float4 tangent : TANGENT;
};

vertexOutput vert(vertexInput v)
{
	vertexOutput o;
	o.vertex = v.vertex;
	o.normal = v.normal;
	o.tangent = v.tangent;
	return o;
}*/</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
の頂点シェーダー</font></font><code>vert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><code>CustomTessellation.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単に入力を直接テッセレーションステージに渡す</font><font style="vertical-align: inherit;">ことに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">構造を作成するタスクは</font><font style="vertical-align: inherit;">、ドメインシェーダー内で呼び出される</font></font><code>vertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に引き継がれ</font></font><code>tessVert</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェル</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダー</font><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメイン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シェーダーをグラスシェーダーに</font><font style="vertical-align: inherit;">追加でき</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">また</font></font><code>_TessellationUniform</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ユニットサイズを制御</font><font style="vertical-align: inherit;">する新しいプロパティ</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">追加</font><font style="vertical-align: inherit;">し</font></font><code>CustomTessellation.cginc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このプロパティに対応する変数は、ですでに宣言されています</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as a new property.			</span>
_TessellationUniform(<span class="hljs-string">"Tessellation Uniform"</span>, Range(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>)) = <span class="hljs-number">1</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add below the other #pragma statements in the SubShader Pass.</span><font></font>
#pragma hull hull<font></font>
#pragma domain domain</code></pre><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テッセレーションの均一</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
プロパティを変更する</font><font style="vertical-align: inherit;">と、芝生の密度を制御できます。</font><font style="vertical-align: inherit;">値</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で良い結果が得られることがわかりました</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/280/d93/c14/280d93c1420a9744bd56f2d2496f96ab.gif"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.風</font></font></h2><br><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歪みテクスチャを</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
サンプリングして風を実装し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">このテクスチャは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、通常のマップの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ように見えます</font><font style="vertical-align: inherit;">。3つのチャネルではなく、2つしかありません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">風向としてこれら2つのチャネルを使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a58/aaa/687/a58aaa68742934ff1bddf1cbaf9564f5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
風のテクスチャをサンプリングする前に、UV座標を作成する必要があります。</font><font style="vertical-align: inherit;">メッシュに割り当てられたテクスチャ座標を使用する代わりに、入力ポイントの位置を適用します。</font><font style="vertical-align: inherit;">これのおかげで、世界にいくつかの草メッシュがある場合、それらがすべて同じ風システムの一部であるという幻想が作成されます。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みのシェーダー変数</font></font></a> <code>_Time</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">、草の表面に沿って風のテクスチャをスクロールします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as new properties.</span>
_WindDistortionMap(<span class="hljs-string">"Wind Distortion Map"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> {}<font></font>
_WindFrequency(<span class="hljs-string">"Wind Frequency"</span>, Vector) = (<span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the CGINCLUDE block.</span><font></font>
sampler2D _WindDistortionMap;<font></font>
float4 _WindDistortionMap_ST;<font></font>
<font></font>
float2 _WindFrequency;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the geometry shader, just above the line declaring the transformationMatrix.</span>
float2 uv = pos.xz * _WindDistortionMap_ST.xy + _WindDistortionMap_ST.zw + _WindFrequency * _Time.y;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スケールとオフセットを位置</font></font><code>_WindDistortionMap</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">適用してから、</font><font style="vertical-align: inherit;">さらにシフトし</font></font><code>_Time.y</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、スケールし</font></font><code>_WindFrequency</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">次に、これらのUVを使用してテクスチャをサンプリングし、風の強さを制御するプロパティを作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as a new property.</span>
_WindStrength(<span class="hljs-string">"Wind Strength"</span>, Float) = <span class="hljs-number">1</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-keyword">float</span> _WindStrength;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add below the line declaring float2 uv.</span>
float2 windSample = (tex2Dlod(_WindDistortionMap, float4(uv, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)).xy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * _WindStrength;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テクスチャからサンプリングされた値を0 ... 1の間隔から-1 ... 1の間隔にスケーリングすることに注意してください。</font><font style="vertical-align: inherit;">次に、風の方向を示す正規化されたベクトルを作成できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring float2 windSample.</span>
float3 wind = normalize(float3(windSample.x, windSample.y, <span class="hljs-number">0</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、このベクトルを中心に回転するマトリックスを作成し、それを乗算します</font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring float3 wind.</span><font></font>
float3x3 windRotation = AngleAxis3x3(UNITY_PI * windSample, wind);<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing line.</span>
float3x3 transformationMatrix = mul(mul(mul(tangentToLocal, windRotation), facingRotationMatrix), bendRotationMatrix);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後</font></font><code>Wind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に、</font><font style="vertical-align: inherit;">Unityエディターのテクスチャー</font><font style="vertical-align: inherit;">（プロジェクトのルートにあります）を</font><font style="vertical-align: inherit;">グラスマテリアルの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wind Distortion Map</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フィールドに</font><font style="vertical-align: inherit;">転送し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">また、</font><font style="vertical-align: inherit;">テクスチャの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiling</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータを</font><font style="vertical-align: inherit;">値に設定します</font></font><code>0.01, 0.01</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シーン</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ウィンドウ</font><font style="vertical-align: inherit;">] </font><font style="vertical-align: inherit;">で芝生がアニメーション化されていない場合は</font><font style="vertical-align: inherit;">、[ </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スカイボックス、フォグ、およびその他のさまざまな効果</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><strong><font style="vertical-align: inherit;">切り替え</font></strong><font style="vertical-align: inherit;"> ]ボタン</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">クリック</font><font style="vertical-align: inherit;">して、アニメーションマテリアルを有効にし</font><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遠くから見ると芝生は正しいように見えますが、芝生の刃をよく見ると、芝生の刃全体が回転していることがわかります。そのため、土台が地面に取り付けられていません。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e9/148/51e/6e914851e888c448c30080a7abefae33.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">草の葉の基部は地面に接続されなくなりましたが、それと交差し（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赤で表示</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、地面（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">緑の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線で</font><font style="vertical-align: inherit;">示されています）の上にぶら下がっています</font><font style="vertical-align: inherit;">。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを修正するには、ベースの2つの頂点にのみ適用される2番目の変換行列を定義します。</font><font style="vertical-align: inherit;">この行列に</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">されない</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マトリックスを含ん</font></font><code>windRotation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>bendRotationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ベースが草の表面に付着されているおかげ。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring float3x3 transformationMatrix.</span><font></font>
float3x3 transformationMatrixFacing = mul(tangentToLocal, facingRotationMatrix);<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing lines outputting the base vertex positions.</span>
triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)));<font></font>
triStream.Append(VertexOutput(pos + mul(transformationMatrixFacing, float3(-width, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)), float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6.草の葉の曲率</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、個々の草の葉は1つの三角形によって定義されます。距離が離れている場合、これは問題ではありませんが、草の葉の近くでは、有機的で鮮やかではなく、非常に硬くて幾何学的に見えます。これを修正するには、いくつかの三角形から草の葉を構築し、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲線に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沿って曲げます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の各ブレードは、いくつかの</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セグメントに</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割され</font><font style="vertical-align: inherit;">ます。各セグメントは長方形の形状をしており、上のセグメントを除いて2つの三角形で構成されます-それは草の葉の先端を示す1つの三角形になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、頂点を3つだけ描画し、1つの三角形を作成しました。では、頂点がさらにある場合、ジオメトリシェーダーはどの頂点を結合して三角形を形成するかをどのようにして知るのでしょうか。答えはデータ構造にあります</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トライアングルストリップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。最初の3つの頂点は結合して三角形を形成し、新しい各頂点は前の2つの頂点と三角形を形成します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/871/8ec/676/8718ec676d7efd819718bd25d5b27b54.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三角形の帯として表され、一度に1つの頂点を作成する、細分化された草の葉。最初の3つの頂点の後、新しい各頂点は、前の2つの頂点と新しい三角形を形成します。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
これはメモリ使用量の点でより効率的であるだけでなく、コード内で簡単かつ迅速に三角形シーケンスを作成することもできます。三角形のストライプをいくつか作成したい場合は、</font></font><code>TriangleStream</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">に対して</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RestartStrip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を呼び出すことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジオメトリックシェーダーからより多くの頂点を描画する前に、それを増やす必要があり</font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。このデザイン</font></font><code>#define</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用して、シェーダーの作成者がセグメントの数を制御し、そこから表示される頂点の数を計算できるようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BLADE_SEGMENTS 3</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing line defining the maxvertexcount.</span>
[maxvertexcount(BLADE_SEGMENTS * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、セグメントの数を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に設定し、セグメント</font></font><code>maxvertexcount</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の数に基づいて頂点の数を計算するために</font><font style="vertical-align: inherit;">更新</font><font style="vertical-align: inherit;">します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
セグメント化された草の葉を作成するには、サイクルを使用します</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ループを繰り返すたびに、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2つの頂点</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">右）</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">が追加され</font><font style="vertical-align: inherit;">ます。先端を完了したら、最後の頂点を草の葉の先端に追加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行う前に、コードの草の葉の頂点の計算位置の一部を関数に移動すると便利です。ループの内側と外側でこのコードを数回使用するためです。</font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font><font style="vertical-align: inherit;">をブロックに追加し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">geometryOutput <span class="hljs-title">GenerateGrassVertex</span><span class="hljs-params">(float3 vertexPosition, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, float2 uv, float3x3 transformMatrix)</span>
</span>{<font></font>
	float3 tangentPoint = float3(width, <span class="hljs-number">0</span>, height);<font></font>
<font></font>
	float3 localPosition = vertexPosition + mul(transformMatrix, tangentPoint);<font></font>
	<span class="hljs-keyword">return</span> VertexOutput(localPosition, uv);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この関数は、以前に渡した引数を渡し</font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て草の葉の頂点を生成する</font><font style="vertical-align: inherit;">ため、同じタスクを実行し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">位置、高さ、幅を取得し、送信された行列を使用して頂点を正しく変換し、UV座標を割り当てます。</font><font style="vertical-align: inherit;">関数が適切に機能するように既存のコードを更新します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Update the existing code outputting the vertices.</span>
triStream.Append(GenerateGrassVertex(pos, width, <span class="hljs-number">0</span>, float2(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), transformationMatrixFacing));<font></font>
triStream.Append(GenerateGrassVertex(pos, -width, <span class="hljs-number">0</span>, float2(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>), transformationMatrixFacing));<font></font>
triStream.Append(GenerateGrassVertex(pos, <span class="hljs-number">0</span>, height, float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>), transformationMatrix));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数が正しく機能し始め、頂点生成コードをループに移動する準備が整いました</font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>float width</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">次</font><font style="vertical-align: inherit;">の行を追加し</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; BLADE_SEGMENTS; i++)<font></font>
{<font></font>
	<span class="hljs-keyword">float</span> t = i / (<span class="hljs-keyword">float</span>)BLADE_SEGMENTS;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の各ブレードセグメントに対して1回実行されるサイクルをアナウンスします。</font><font style="vertical-align: inherit;">ループ内に変数を追加します</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この変数は0〜1の範囲の値を格納し、草の葉に沿ってどれだけ移動したかを示します。</font><font style="vertical-align: inherit;">この値を使用して、ループの各反復でのセグメントの幅と高さを計算します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring float t.</span>
<span class="hljs-keyword">float</span> segmentHeight = height * t;
<span class="hljs-keyword">float</span> segmentWidth = width * (<span class="hljs-number">1</span> - t);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の葉を上に移動すると、高さが増加し、幅が減少します。</font><font style="vertical-align: inherit;">これで、ループの呼び出しを</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加して、三角形のストリームに頂点を追加できます。</font><font style="vertical-align: inherit;">また</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ループの外側</font><font style="vertical-align: inherit;">に1つの呼び出しを追加</font><font style="vertical-align: inherit;">して、草の葉の先端を作成します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the line declaring float segmentWidth.</span>
float3x3 transformMatrix = i == <span class="hljs-number">0</span> ? transformationMatrixFacing : transformationMatrix;<font></font>
<font></font>
triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, float2(<span class="hljs-number">0</span>, t), transformMatrix));<font></font>
triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, float2(<span class="hljs-number">1</span>, t), transformMatrix));<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add just below the loop to insert the vertex at the tip of the blade.</span>
triStream.Append(GenerateGrassVertex(pos, <span class="hljs-number">0</span>, height, float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>), transformationMatrix));<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Remove the existing calls to triStream.Append.</span>
<span class="hljs-comment">//triStream.Append(GenerateGrassVertex(pos, width, 0, float2(0, 0), transformationMatrixFacing));</span>
<span class="hljs-comment">//triStream.Append(GenerateGrassVertex(pos, -width, 0, float2(1, 0), transformationMatrixFacing));</span>
<span class="hljs-comment">//triStream.Append(GenerateGrassVertex(pos, 0, height, float2(0.5, 1), transformationMatrix));</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
宣言のある行を見てみましょう。</font></font><code>float3x3 transformMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは、2つの変換行列の1つを選択します</font><font style="vertical-align: inherit;">。</font></font><code>transformationMatrixFacing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベースの頂点と</font></font><code>transformationMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のすべての</font><font style="vertical-align: inherit;">頂点</font><font style="vertical-align: inherit;">をとり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02b/211/61c/02b21161cd4afc0cca35ae71ffe2570e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
草の葉は現在、多くのセグメントに分割されていますが、刃の表面はまだ平らです-新しい三角形はまだ含まれていません。</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">頂点の位置をシフトして、草の曲率のブレードを追加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">まず、</font><strong><font style="vertical-align: inherit;">Yの</font></strong></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オフセットを取得するよう</font><font style="vertical-align: inherit;">に関数を変更する必要</font><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これをと呼びます</font><font style="vertical-align: inherit;">。</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><code>forward</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Update the function signature of GenerateGrassVertex.</span>
<span class="hljs-function">geometryOutput <span class="hljs-title">GenerateGrassVertex</span><span class="hljs-params">(float3 vertexPosition, <span class="hljs-keyword">float</span> width, <span class="hljs-keyword">float</span> height, <span class="hljs-keyword">float</span> forward, float2 uv, float3x3 transformMatrix)</span>

…

<span class="hljs-comment">// Modify the Y coordinate assignment of tangentPoint.</span>
float3 tangentPoint </span>= float3(width, forward, height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各頂点の変位を計算するには、関数に</font></font><code>pow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">を代入し</font><font style="vertical-align: inherit;">ます</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">引き上げ後</font></font><code>t</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の電力を、前方変位にその効果があろう</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非線形</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲線に草のブレードを回します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add as new properties.</span>
_BladeForward(<span class="hljs-string">"Blade Forward Amount"</span>, Float) = <span class="hljs-number">0.38</span>
_BladeCurve(<span class="hljs-string">"Blade Curvature Amount"</span>, Range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)) = <span class="hljs-number">2</span><font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the CGINCLUDE block.</span>
<span class="hljs-keyword">float</span> _BladeForward;
<span class="hljs-keyword">float</span> _BladeCurve;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add inside the geometry shader, below the line declaring float width.</span>
<span class="hljs-keyword">float</span> forward = rand(pos.yyz) * _BladeForward;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add inside the loop, below the line declaring segmentWidth.</span>
<span class="hljs-keyword">float</span> segmentForward = <span class="hljs-built_in">pow</span>(t, _BladeCurve) * forward;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the GenerateGrassVertex calls inside the loop.</span>
triStream.Append(GenerateGrassVertex(pos, segmentWidth, segmentHeight, segmentForward, float2(<span class="hljs-number">0</span>, t), transformMatrix));<font></font>
triStream.Append(GenerateGrassVertex(pos, -segmentWidth, segmentHeight, segmentForward, float2(<span class="hljs-number">1</span>, t), transformMatrix));<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the GenerateGrassVertex calls outside the loop.</span>
triStream.Append(GenerateGrassVertex(pos, <span class="hljs-number">0</span>, height, forward, float2(<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>), transformationMatrix));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはかなり大きなコードですが、すべての作業は、草の葉の幅と高さに対して行ったのと同じように行われます。</font><font style="vertical-align: inherit;">値が小さい</font></font><code>_BladeForward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>_BladeCurve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">整頓された手入れの行き届いた芝生が得られ、値が大きいと反対の効果が得られます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c1f/cbc/e43/c1fcbce43fa5e1c1be319dc1f5190f3d.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.照明と影</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダーを完成させる最後のステップとして、</font><font style="vertical-align: inherit;">シャドウ</font><font style="vertical-align: inherit;">を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">キャスト</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">受け取る</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機能を追加し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">また、主な指向性光源からの単純な照明を追加します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.1影付け</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityでシャドウをキャストするには、シェーダーに2番目のパスを追加する必要があります。このパッセージは、シーン内のシャドウを作成する光源によって使用され、草の深度を</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シャドウマップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にレンダリングします</font><font style="vertical-align: inherit;">。これは、草の葉が影を落とすことができるように、幾何学的シェーダーを影の通路で起動する必要があることを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジオメトリックシェーダーはブロック内に記述されるため、</font></font><code>CGINCLUDE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルのどのパスでも使用できます。フラグメントシェーダーを除いて、最初のパスと同じシェーダーを使用する2番目のパスを作成します。出力を処理するマクロを書き込む新しいパスを定義します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add below the existing Pass.</span><font></font>
Pass<font></font>
{<font></font>
	Tags<font></font>
	{<font></font>
		<span class="hljs-string">"LightMode"</span> = <span class="hljs-string">"ShadowCaster"</span><font></font>
	}<font></font>
<font></font>
	CGPROGRAM<font></font>
	#pragma vertex vert<font></font>
	#pragma geometry geo<font></font>
	#pragma fragment frag<font></font>
	#pragma hull hull<font></font>
	#pragma domain domain<font></font>
	#pragma target <span class="hljs-number">4.6</span><font></font>
	#pragma multi_compile_shadowcaster<font></font>
<font></font>
	float4 frag(geometryOutput i) : SV_Target<font></font>
	{<font></font>
		SHADOW_CASTER_FRAGMENT(i)<font></font>
	}<font></font>
<font></font>
	ENDCG<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいフラグメントシェーダーの作成に加えて、このパッセージにはいくつかの重要な違いがあります。</font><font style="vertical-align: inherit;">ラベルは</font></font><code>LightMode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要</font></font><code>ShadowCaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、オブジェクトをシャドウマップにレンダリングするためにこのパッセージを使用する必要があることをUnityに伝えます。</font><font style="vertical-align: inherit;">ここにはプリプロセッサディレクティブもあります</font></font><code>multi_compile_shadowcaster</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">シェーダーが影を落とすのに必要なすべてのオプションを確実にコンパイルするようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゲームオブジェクトを</font><font style="vertical-align: inherit;">シーンで</font></font><code>Fence</code> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アクティブ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">にします。</font><font style="vertical-align: inherit;">だから、草の葉が影を落とすことができる表面を得ます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/640/6cf/c576406cf284fe41e4b04d8af264d96e.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.2シャドウの取得</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unityが光源を作成するシャドウの視点からシャドウマップをレンダリングした後、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スクリーンスペースの</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テクスチャにシャドウを「収集」する通路を起動し</font><strong><font style="vertical-align: inherit;">ます</font></strong><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このテクスチャをサンプリングするには、スクリーンスペース内の頂点の位置を計算し、フラグメントシェーダーに転送する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the geometryOutput struct.</span><font></font>
unityShadowCoord4 _ShadowCoord : TEXCOORD1;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the VertexOutput function, just above the return call.	</span>
o._ShadowCoord = ComputeScreenPos(o.pos);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パッセージのフラグメントシェーダーでは</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、マクロを使用して</font></font><code>float</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、サーフェスがシャドウにあるかどうかを示す</font><font style="vertical-align: inherit;">値を取得できます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この値の範囲は0 ... 1で、0は完全なシェーディング、1は完全な照明です。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画面空間のUV座標が_ShadowCoordと呼ばれるのはなぜですか？</font><font style="vertical-align: inherit;">これは、以前の命名規則に準拠していません。</font></font></b><div class="spoiler_text">   Unity           (       ).          <code>SHADOW_ATTENUATION</code>.         <code>Autolight.cginc</code>,  ,       .<br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHADOW_ATTENUATION(a) unitySampleShadow(a._ShadowCoord)</span></code></pre><br>
             -    ,            .</div></div><br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the ForwardBase pass's fragment shader, replacing the existing return call.</span>
<span class="hljs-keyword">return</span> SHADOW_ATTENUATION(i);<font></font>
<font></font>
<span class="hljs-comment">//return lerp(_BottomColor, _TopColor, i.uv.y);</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、シャドウを受け取るようにシェーダーを適切に構成する必要があります。</font><font style="vertical-align: inherit;">これを行うには、</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プリプロセッサディレクティブ</font><font style="vertical-align: inherit;">をパスに追加</font><font style="vertical-align: inherit;">して、必要なすべてのシェーダーオプションをコンパイルするようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the ForwardBase pass's preprocessor directives, below #pragma target 4.6.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> multi_compile_fwdbase</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90a/491/468/90a491468a1ad129d35bea03b0b51898.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カメラを近づけると、草の葉の表面にアーティファクトが見られます。</font><font style="vertical-align: inherit;">それらは草の個々のブレードが自分自身に影を落とすという事実によって引き起こされます。</font><font style="vertical-align: inherit;">これを修正するには、</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形シフトを</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適用する</font><font style="vertical-align: inherit;">か、切り捨て空間内の頂点の位置を画面から少し離します。</font><font style="vertical-align: inherit;">これにはUnityマクロを使用し、それをデザインに含め</font></font><code>#if</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">て、操作がシャドウパスでのみ実行されるようにします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add at the end of the VertexOutput function, just above the return call.</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> UNITY_PASS_SHADOWCASTER</span>
	<span class="hljs-comment">// Applying the bias prevents artifacts from appearing on the surface.</span><font></font>
	o.pos = UnityApplyLinearShadowBias(o.pos);<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dca/ec0/d88/dcaec0d88eea1893b6a07eb45724a0b6.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">線形シャドウシフトを適用すると、ストライプの形のシャドウアーティファクトが三角形の表面から消えます。</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遮光された草の葉の端にアーチファクトがあるのはなぜですか？</font></font></b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08a/12e/af1/08a12eaf1af17fc9b35de7d07a64afca.png"></div><br>
     (multisample anti-aliasing <strong>MSAA</strong>) Unity <em> </em>     ,        .        ,  .<br>
<br>
   —  ,    ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  Unity</a>.      (     );     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">    Unity</a>.</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7.3照明</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常にシンプルで一般的な拡散照明計算アルゴリズムを使用して照明を実装します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/404/3ae/452/4043ae452046c0b4b405aa88afe8d2b7.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...ここで、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はサーフェスの法線、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は指向性ライティングの主な光源の正規化された方向、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は計算されたライティングです。</font><font style="vertical-align: inherit;">このチュートリアルで</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反射照明を実装し</font><strong><font style="vertical-align: inherit;">ません</font></strong><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現時点では、草の葉の上部には法線が割り当てられていません。</font><font style="vertical-align: inherit;">頂点の位置と同様に、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接線空間の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法線を最初に計算し</font><font style="vertical-align: inherit;">てから、ローカルに変換します。</font><strong><font style="vertical-align: inherit;">Blade Curvature Amount</font></strong><font style="vertical-align: inherit;">が</font><strong><font style="vertical-align: inherit;">1</font></strong><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">設定されている</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合、</font><font style="vertical-align: inherit;">接線空間内のすべての芝生のブレードは一方向に向けられます：</font><strong><font style="vertical-align: inherit;">Y</font></strong><font style="vertical-align: inherit;">軸の真向かい</font></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ソリューションの最初のパスとして、曲率がないと仮定して、法線を計算します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the GenerateGrassVertex function, belowing the line declaring tangentPoint.</span>
float3 tangentNormal = float3(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<font></font>
float3 localNormal = mul(transformMatrix, tangentNormal);</code></pre><br>
<code>tangentNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸の反対側として定義され</font><font style="vertical-align: inherit;">、接点をローカル空間に変換するために使用したのと同じ行列によって変換されます。</font><font style="vertical-align: inherit;">これを関数に渡し</font></font><code>VertexOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に構造体に</font><font style="vertical-align: inherit;">渡すことができ</font></font><code>geometryOutput</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Modify the return call in GenerateGrassVertex.</span>
<span class="hljs-keyword">return</span> VertexOutput(localPosition, uv, localNormal);<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Add to the geometryOutput struct.</span><font></font>
float3 normal : NORMAL;<font></font>
<font></font>
…<font></font>
<font></font>
<span class="hljs-comment">// Modify the existing function signature.</span>
<span class="hljs-function">geometryOutput <span class="hljs-title">VertexOutput</span><span class="hljs-params">(float3 pos, float2 uv, float3 normal)</span>

…

<span class="hljs-comment">// Add to the VertexOutput function to pass the normal through to the fragment shader.</span>
o.normal </span>= UnityObjectToWorldNormal(normal);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結論の前に、法線を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ワールド空間に</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変換することに注意してください</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Unityは、シェーダーにワールドスペースの指向性ライトの主な光源の方向を伝えるため、この変換が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、フラグメントシェーダーの法線を視覚化して</font></font><code>ForwardBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、作業の結果を確認できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the ForwardBase fragment shader.</span>
float3 normal = facing &gt; <span class="hljs-number">0</span> ? i.normal : -i.normal;<font></font>
<font></font>
<span class="hljs-keyword">return</span> float4(normal * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>);<font></font>
<font></font>
<span class="hljs-comment">// Remove the existing return call.</span>
<span class="hljs-comment">//return SHADOW_ATTENUATION(i);</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シェーダー</font><font style="vertical-align: inherit;">で</font></font><code>Cull</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値が割り当てられ</font><font style="vertical-align: inherit;">ているため、</font></font><code>Off</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">草の葉の両側がレンダリングされます。</font><font style="vertical-align: inherit;">法線を正しい方向に向ける</font></font><code>VFACE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ために、フラグメントシェーダーに追加し</font><font style="vertical-align: inherit;">た補助パラメーターを使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数</font></font><code>fixed facing</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font><font style="vertical-align: inherit;">、表面の前面を表示する場合は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数</font><font style="vertical-align: inherit;">を返し</font><font style="vertical-align: inherit;">、反対の場合</font><font style="vertical-align: inherit;">は</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">負の</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数</font><font style="vertical-align: inherit;">を返し</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">上記のコードでこれを使用して、必要に応じて法線を反転します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1b/8ca/965/e1b8ca965ed8e80b539a9773d1adeb0c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブレード曲率量が</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1より大きい、接線</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の位置</font><font style="vertical-align: inherit;">、各頂点は、量だけシフトされる</font></font><code>forward</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数に渡されます</font></font><code>GenerateGrassVertex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この値を使用して、</font><font style="vertical-align: inherit;">法線の</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">軸を比例的にスケーリングし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Modify the existing line in GenerateGrassVertex.</span>
float3 tangentNormal = normalize(float3(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, forward));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、コードをフラグメントシェーダーに追加して、シャドウ、指向性ライティング、アンビエントライティングを組み合わせます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トゥーンシェーダーに関するチュートリアルで</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、シェーダーでのカスタム照明の実装に関する詳細情報を学習することをお勧めし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Add to the ForwardBase fragment shader, below the line declaring float3 normal.</span>
<span class="hljs-keyword">float</span> shadow = SHADOW_ATTENUATION(i);
<span class="hljs-keyword">float</span> NdotL = saturate(saturate(dot(normal, _WorldSpaceLightPos0)) + _TranslucentGain) * shadow;<font></font>
<font></font>
float3 ambient = ShadeSH9(float4(normal, <span class="hljs-number">1</span>));<font></font>
float4 lightIntensity = NdotL * _LightColor0 + float4(ambient, <span class="hljs-number">1</span>);<font></font>
float4 col = lerp(_BottomColor, _TopColor * lightIntensity, i.uv.y);<font></font>
<font></font>
<span class="hljs-keyword">return</span> col;<font></font>
<font></font>
<span class="hljs-comment">// Remove the existing return call.</span>
<span class="hljs-comment">//return float4(normal * 0.5 + 0.5, 1);</span></code></pre><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c14/894/d14/c14894d14edc336b770f4b94bedd3708.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このチュートリアルでは、草は10x10ユニットの小さな領域をカバーしています。</font><font style="vertical-align: inherit;">シェーダーが高いパフォーマンスを維持しながら広いオープンスペースをカバーするには、最適化を行う必要があります。</font><font style="vertical-align: inherit;">距離に基づいてテッセレーションを適用して、カメラから離れてレンダリングされる芝生のブレードを減らすことができます。</font><font style="vertical-align: inherit;">さらに、長距離では、個々の草の葉ではなく、単一の四角形を重ね合わせたテクスチャで草の葉のグループを描画できます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/a05/e86/5a7a05e8690c152f9196bb3c94fada19.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unityエンジンの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準アセット</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージに含まれて</font><font style="vertical-align: inherit;">いる</font><font style="vertical-align: inherit;">グラステクスチャ</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">草の多くのブレードが1つの四角形に描かれているため、シーン内の三角形の数が減ります。</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネイティブではサーフェスシェーダーで幾何学的シェーダーを使用することはできませんが、ライティングとシェーディングの機能を改善または拡張するために、標準のUnity照明モデルを使用する必要がある場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このGitHubリポジトリを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調べることができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GitHubリポジトリのシェーダーソースコード</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加：協力</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
相互運用性がないと、グラフィック効果は静的または活気がないように見えます。</font><font style="vertical-align: inherit;">このチュートリアルは既に非常に長いため、ワールドオブジェクトと芝生の相互作用に関するセクションは追加しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インタラクティブハーブの単純な実装には、2つのコンポーネントが含まれます。ゲームの世界で</font><font style="vertical-align: inherit;">、シェーダーに</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><strong><font style="vertical-align: inherit;">送信</font></strong><font style="vertical-align: inherit;">して、草のどの部分が相互作用しているかを伝えることができるものと、</font><font style="vertical-align: inherit;">このデータ</font><font style="vertical-align: inherit;">を</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解釈</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するためのシェーダーのコード</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを水で実装する方法の例を以下に示し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">草での作業に適応できます。</font><font style="vertical-align: inherit;">キャラクターがいる場所に波紋を描く代わりに、草の葉を下げて、ステップの効果をシミュレートできます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja458044/index.html">地方の情報セキュリティ-停滞か発展か？</a></li>
<li><a href="../ja458046/index.html">Gradleチートシート</a></li>
<li><a href="../ja458048/index.html">マネージャーツールとしての委任</a></li>
<li><a href="../ja458050/index.html">メビウス2019パイターはいかがでしたか（そして次のメビウスについて少し）</a></li>
<li><a href="../ja458052/index.html">HabrによるAMA 10。最後の*問題</a></li>
<li><a href="../ja458062/index.html">UserGateプラットフォームの概要</a></li>
<li><a href="../ja458070/index.html">﻿PVS-Studio for Visual Studio</a></li>
<li><a href="../ja458072/index.html">﻿PVS-Studioがクラウドに移行-Travis CIで分析を開始</a></li>
<li><a href="../ja458074/index.html">言語を選択：ORMの選択</a></li>
<li><a href="../ja458080/index.html">7月25日、モスクワ-QIWI iOS Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>