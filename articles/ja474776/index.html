<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥄 👂🏾 🦖 仮想化x86の一般理論と考古学 🌽 🤷🏻 🖖🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前書き
 著者のチーム
 著者：アントン・ズバンコフ（AntonVirtual、cloudarchitect.cc）
 共著者：Grigory Pryalukhin、Evgeny Parfenov
 
 仮想化の一般的な概念
仮想化とは 何かについて多くの解釈を見て、多くの論争に耳を傾けなければなり...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>仮想化x86の一般理論と考古学</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/474776/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前書き</font></font></h2><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">著者のチーム</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
著者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アントン・ズバンコフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AntonVirtual</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloudarchitect.cc</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共著者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grigory Pryalukhin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Evgeny Parfenov</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化の一般的な概念</font></font></h3><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化とは</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
何かについて多くの解釈を見</font><font style="vertical-align: inherit;">て、多くの論争に耳を傾けなければなりませんでしたが、実際の結果について議論するのに少しは近づきませんでした。</font><font style="vertical-align: inherit;">そしてご存じのように、2人の賢い人々の議論は定義についての議論に帰着します。</font><font style="vertical-align: inherit;">仮想化とは何か、それから何が生まれるかを定義しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、仮想化の最も近い定義は、オブジェクト指向プログラミングから「抽象化」することでしょう。</font><font style="vertical-align: inherit;">または、通常のロシア語に翻訳すると、これは実装を抽象インターフェースの背後に隠しています。</font><font style="vertical-align: inherit;">もちろん、これは一度にすべてを説明しました。</font><font style="vertical-align: inherit;">もう一度やってみましょうが、プログラミングを勉強していない人のために。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化-リソース/データにアクセスする普遍的な標準化された方法の背後に特定の実装を隠す。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この定義を実践に移そうとすると、それは完全に予想外のテーマで機能することがわかります。時計としましょう。ですから、日時計は数千年前に発明され、中世には機械式のものが発明されました。共通点は何ですか？太陽とギア？ナンセンス。そして、水晶発振器と他のすべて。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
肝心なのは、標準的なインターフェース-普遍的な標準形式で現在時刻を示すポインターまたはデジタルポインターがあることです。しかし、時間が十分に正確に示されている場合、このメカニズムがボックス内でどのように具体的に実装されているかは重要ですか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 「私を聞かせて」と言うこともできますが、「仮想化はそこにあるマシンやプロセッサーなどに関するものだと思っていました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、それは車とプロセッサについてですが、これは特別な場合にすぎません。</font><font style="vertical-align: inherit;">記事は一般的な理論を大胆に主張しているので、もっと広く見てみましょう。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">POZOR！</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">うわが！</font><font style="vertical-align: inherit;">Achtung！</font><font style="vertical-align: inherit;">ポザー！</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、</font><font style="vertical-align: inherit;">一連のテクノロジー全体と恐ろしい言葉を歴史とともに特定の構造にリンクするための</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般的な教育</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目的であり、この状況により、かなりの量の</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意図的な</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">簡略化</font><font style="vertical-align: inherit;">が含まれています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">もちろん、これには多くの迷惑な省略も含まれており、タイプミスによる単純なエラーも含まれています。</font><font style="vertical-align: inherit;">建設的な批判は、特に「私にあなたにこの部分を思い起こさせよう」という形でのみ歓迎されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化のタイプ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全に抽象的な概念から、愛するコンピュータに慣れ親しんだものに戻りましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ仮想化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1つ目は、おそらく、初心者が遭遇する仮想化のタイプ、つまりデータストレージシステムの仮想化です。</font><font style="vertical-align: inherit;">この場合、ストレージシステムは、ファイバーチャネルを介して接続されたディスクを持つ大規模なアレイという意味ではなく、長期的なデータストレージを担当する論理サブシステムとして使用されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FS-&gt; LBA-&gt; CHS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単一のハード磁気ディスク上のストレージシステムの最も単純なケースを取り上げます。データを処理するための通常の形式は、論理ドライブにあるファイルです。ファイルは開く、読み取る、閉じることができます。しかし、ファイルなどのオブジェクトは単に物理的には存在しません。「ドライブ：\ folder1 \ folder2 \ file」という形式のアドレス指定方法を使用して特定のデータブロックにアクセスする方法しかありません。それら。仮想化の最初のレイヤーに対応します-ニーモニックで理解できるすべてのものから人間に至るまで、すべてをシステムが理解できるアドレスに変換します。メタデータテーブルでは、ファイルシステムドライバーがどのような種類のデータブロックが存在するかを検索し、論理ブロックアドレス（LBA）システムでアドレスを取得します。 LBAシステムでは、ブロックのサイズは固定されており、互いに線形に続きます。どういうわけかそれは磁気テープにデータを保存することと関係があるかもしれません、しかし、ハードドライブは完全に異なります！そして、ここで仮想化の第2レイヤーに進みます。LBAアドレッシングからCHS（シリンダー/ヘッド/セクター）への変換です。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/e95/940/bd4/e95940bd4389a0187c2bf3d82406e118.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、CHSは既にハードディスクコントローラーにあり、読み取り用の物理パラメーターに変換され始めますが、これはまったく別の話です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、メモを使ってビデオを表示するためのファイルへの単純なアクセスであっても、仮想化の3つの層にすぐに出会いました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レイヤーがランダムな順序でさまざまな方法でオーバーラップし始めなければ、すべてが単純すぎます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAID</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの人々が誤って仮想化を考慮していない仮想化の次の層はRAID（安価で独立したディスクの冗長アレイ）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明されている概念の文脈におけるRAIDの主要な機能は、特定の物理ディスクの障害からデータを保護する機能ではありません。</font><font style="vertical-align: inherit;">RAIDは、いくつかの（時には非常に多くの）独立したLBAアドレスに加えて、第2レベルのLBAアドレス指定を提供します。</font><font style="vertical-align: inherit;">RAIDレベルに関係なく、RAIDなしの単一ディスクとまったく同じ方法でRAIDにアクセスできるため、自信を持って言うことができます。</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAIDはディスク仮想化です。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、RAIDコントローラーは、複数の物理ディスクから1つの大きな仮想ディスクを作成するだけでなく、仮想化の別のレイヤーを追加することで任意の数の物理ディスクを作成できます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化を表示</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの多くがほぼ毎日使用している次のタイプの仮想化は、仮想化とは考えていませんが、デスクトップへのリモート接続です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターミナルサーバー、VDI、さらにサーバーへのVPN経由のRDPも、すべてセッション仮想化です。</font><font style="vertical-align: inherit;">標準のインターフェイス（モニター、キーボード、マウス）を使用して、実際のマシン、またはコンテナー化されたアプリケーションを持つリンククローン上の仮想デスクトップからの理解できないデザインを使用して、そこからデータをバッファー経由でストリーミング配信のアプリケーションに転送します。</font><font style="vertical-align: inherit;">それを設計した人以外に、誰がそれを理解するのか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86仮想化の概要</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセッサの歴史と概要</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムの実行</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別なプログラミングコースの最初のレッスンで、ウラジミールデニソビッチレリュフ（彼のために休んでいる）は生徒に次のように話しました。コンピュータは、その名前にもかかわらず、数えることはできません。しかし、何かがアヒルのように見え、アヒルのように歩き、アヒルのように鳴く場合、実用的な観点からは、アヒルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このことを覚えて、さらに実用に活用しましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンピュータ、具体的にはプロセッサは実際には何もしません-特定の場所でいくつかの入力パラメータを期待し、ひどい黒魔術によって特定の場所でいくつかの結果を出します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合のプログラムは、厳密に順次実行されるコマンドの特定のストリームであり、その結果、特定の結果が期待されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、プログラムが実行されている場合、データはどのように入力できますか？そして一般的に、どういうわけかコンピュータ上で相互作用しますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このために、ハードウェア割り込みが発明されました。ユーザーがキーを押すと、キーボードコントローラがこれを通知し、現在のコードスレッドの実行が中断されます。割り込みハンドラのアドレスは特定のメモリ領域に記録され、現在の状態を保存した後、制御は割り込みハンドラに移ります。次に、理論的には、ハンドラーはすべてをすばやく処理し、次にハンドラーとハンドラーは、目的のバッファーで押されたキーを書き留め、制御を戻します。したがって、アプリケーションが実行されているように見え、システムと対話できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
割り込みハンドラー（およびハンドラーの主な種類はデバイスドライバー）は、このモードを終了する前に他の割り込みを実装できない場合に、特別なプロセッサモードに入ることができます。</font><font style="vertical-align: inherit;">結局、どちらがハングアップの問題につながることがよくありました-ドライバーのエラーにより、中断を終了できませんでした。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチタスク</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数のプログラム（データとメモリ構造を含むコードストリーム）を同時に実行する必要がある場合はどうすればよいですか？明らかに、それらを実行できるデバイスよりも多くのコードストリームがある場合、これは問題です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
疑似マルチタスクは、タスクに直接切り替えて実行すると表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、協調型（非プリエンプティブマルチタスク）が登場します。実行可能タスク自体は、プロセッサリソースが不要であることを理解し、他の誰かに制御を与えます。しかし、これだけでは十分ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここでもまた、中断+ふりをする能力が私たちを救います。厳密に同時に実行されることは、ユーザーにとって重要ではありません。そのように見えるだけで十分です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、ハンドラーは単にハングアップしてタイマーに割り込み、タイマーは次に実行するコードストリームを制御し始めます。</font><font style="vertical-align: inherit;">タイマーがかなり頻繁に（たとえば15ms）トリガーされると、ユーザーにとってはすべてが並列操作のように見えます。</font><font style="vertical-align: inherit;">そして、現代の混雑したマルチタスクがあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リアルモード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事のフレームワークにおける実際のプロセッサー・モードは、非常に簡単に説明できます。つまり、すべてのメモリーを誰でも利用できます。</font><font style="vertical-align: inherit;">マルウェア（マルウェア、悪意のあるソフトウェア）を含むすべてのアプリケーションは、読み取りと書き込みの両方のためにどこにでもアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Intel x86ファミリーのプロセッサーの初期動作モードです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保護モード</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1982年、Intel 80286プロセッサ（以降、単に286）に革新的な技術が登場しました。これは、保護された動作モードであり、メモリを使った作業の編成に革新をもたらしました（たとえば、メモリセグメントのタイプの割り当て-コード、データ、スタック）。しかし、286プロセッサがx86の世界にもたらした最も重要なことは、現在も使用されている保護リングの概念です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
保護リングの概念は、部分的にソフトウェアが実装されたGE645メインフレーム（1967）のMultics OS、およびHoneywell 6180システムではすでに1970年に完全にハードウェアとして登場しました。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/2a9/249/522/2a9249522d8bdb211dbb4eb0aec70b75.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
防衛リングの主なアイデアは、複数レベルの中世の要塞に似ています。最も価値のあるものは、複数の壁の後ろのまさに中心にあります。この場合、最も価値があるのは、RAMの任意の領域への無制限の直接アクセスとすべてのプロセスの制御です。それらは、ゼロの保護リングで機能するプロセスに所有されています。壁の向こう側、最初のリングでは、デバイスドライバーなどのそれほど重要ではないプロセスが機能し、最後にはユーザーアプリケーションが機能します。原則は簡単です-内側から外側に行くことができますが、外側から内側に行くことは禁止されています。それら。以前のリアルモードで可能だったように、ユーザープロセスはOSカーネルメモリにアクセスできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Honeywell 6180の最初の完全実装では、8つの保護リングが実装されましたが、Intelは回路を4つに簡略化することを決定しました。実際には、OSメーカーは2つだけを使用し始めました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">32ビット</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1985年に、x86ラインでアーキテクチャ的に重要なもう1つのプロセッサ、80386（以降386）がリリースされました。これは、32ビットのメモリアドレス指定を実装し、32ビットの命令を使用しました。</font><font style="vertical-align: inherit;">そしてもちろん、メモリの仮想化。</font><font style="vertical-align: inherit;">すでに述べたように、仮想化は、人工的な「仮想」リソースの提供による実際の実装の隠蔽です。</font><font style="vertical-align: inherit;">ここでは、メモリのアドレス指定について説明します。</font><font style="vertical-align: inherit;">メモリセグメントには独自のアドレス指定があり、メモリセルの実際の場所とは関係ありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このプロセッサーは、2007年より前に製造されたほど需要が高いことがわかりました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IntelによるアーキテクチャはIA32と呼ばれます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64ビット</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、2000年代半ばに仮想化がなくても、業界はすでに32ビットの限界に達していました。 PAE（Physical Address Extension）の形で部分的な回避策がありましたが、それらは複雑になり、コードを遅くしました。 64ビットへの移行は、まったくの結論でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AMDは、AMD64と呼ばれるアーキテクチャのバージョンを導入しました。 Intelでは、Itaniumとも呼ばれるIA64プラットフォーム（Intel Architecture 64）を望んでいました。ただし、市場はこのアーキテクチャにあまり熱意を持たずに対応し、その結果、IntelはAMD64命令の独自のサポートを実装せざるを得なくなりました。これは最初はEM64Tと呼ばれ、次にIntel 64と呼ばれていまし</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
た。結局のところ、このアーキテクチャはすべてAMD64、x86-64、x86_64、または時にはx64が発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当時のサーバーの主な用途は仮想化なしの物理的なものであると想定されていたため、仮想化の最初の64ビットプロセッサで技術的におかしいことが起こりました。ネストされたハイパーバイザーはラボサーバーとしてよく使用されていましたが、誰もが物理サーバーのクラスターをいくつか用意できるわけではありませんでした。そして最終的に、組み込みハイパーバイザーのロードVMは32ビットモードでのみ機能することがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のx86-64プロセッサでは、開発者は32ビットオペレーティングモードとの完全な互換性を維持しながら、64ビットモードの機能の大部分を捨てました。</font><font style="vertical-align: inherit;">この場合、問題はメモリのセグメンテーションを大幅に簡素化することでした。</font><font style="vertical-align: inherit;">ハイパーバイザー例外ハンドラーが機能するVMの小さなメモリの整合性を保証する機能は削除されました。</font><font style="vertical-align: inherit;">したがって、ゲストOSはそれを変更できました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、AMDはセグメントを制限する可能性を返し、Intelは単にハードウェア仮想化の導入を待ちました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UMA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
X86マルチプロセッサシステムはUMA（Uniform Memory Access）モードで動作し始めました。このモードでは、任意のプロセッサ（メモリセルへのアクセスの遅延）から任意のメモリバーまでの距離は同じです。</font><font style="vertical-align: inherit;">Intelプロセッサでは、54xx世代（Harpertown）までのマルチコアプロセッサが登場した後も、この作業スキームは維持されていました。</font><font style="vertical-align: inherit;">55xx（Nehalem）世代以降、プロセッサはNUMAアーキテクチャに切り替わりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行ロジックの観点から見ると、これは、並行して実行するコードストリームを割り当てることができる追加のハードウェアスレッドの外観です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NUMA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NUMA（Non Uniform Memory Access）-メモリへのアクセスが不均一なアーキテクチャ。</font><font style="vertical-align: inherit;">このアーキテクチャ内では、各プロセッサに独自のローカルメモリがあり、アクセスは低レイテンシで直接実行されます。</font><font style="vertical-align: inherit;">他のプロセッサのメモリは、より高いレイテンシで間接的にアクセスされるため、パフォーマンスが低下します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2019 Intel Xeon Scalable v2プロセッサーの場合、内部アーキテクチャーはソケット内でUMAのままであり、他のソケットのNUMAに変わります（実際にはそうではありませんが、実際はそうではありません）。</font><font style="vertical-align: inherit;">AMDのOpteronプロセッサは、最も古いUMA Xeonの時代でさえNUMAアーキテクチャを備えていたため、NUMA =ソケットに戻ったローマの最後の世代まで、NUMAはソケットの内部にも均一になりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想マシン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシン（英語、仮想マシンのVM）は、特定のプラットフォーム（ターゲットはターゲットまたはゲストプラットフォーム）のハードウェアをエミュレートし、ホストプラットフォーム上のターゲットプラットフォーム用のプログラムを実行するソフトウェアまたはハードウェアシステムです（ホストはホストプラットフォームです）。 、ホストプラットフォーム）、またはプラットフォームを仮想化し、プログラムおよびオペレーティングシステムを相互に分離する環境を作成します。ウィキペディア</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、「システムマシン」を意味する「仮想マシン」と呼び、すべてのリソースとハードウェアをソフトウェア構造の形で完全にシミュレーションできるようにします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想マシンを作成するソフトウェアには、主に2つのタイプがあります。不完全な仮想化。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">完全仮想化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-プロセッサを含むすべてのハードウェアがエミュレートされるアプローチ。ハードウェアに依存しない環境を作成し、SPARCシステムのx86プラットフォームのOSやアプリケーションソフトウェア、またはおなじみのx86のZ80プロセッサーを搭載した有名なスペクトラムエミュレーターなどを実行できます。完全な独立の裏側は、プロセッサを仮想化するためのオーバーヘッドが高く、全体的なパフォーマンスが低いことです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不完全な仮想化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-ハードウェアの100％が仮想化されないアプローチ。</font><font style="vertical-align: inherit;">不完全な仮想化は業界で最も一般的であるため、それについて説明します。</font><font style="vertical-align: inherit;">x86アーキテクチャの不完全な仮想化を備えたシステム仮想マシンのプラットフォームとテクノロジーについて。</font><font style="vertical-align: inherit;">この場合、プロセッサの仮想化は不完全です。</font><font style="vertical-align: inherit;">特定のシステムコールの部分的な置換または非表示を除いて、仮想マシンのバイナリコードはプロセッサによって直接実行されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェア仮想化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ゼロリングで動作するプロセッサアーキテクチャとオペレーティングシステムの習慣の明らかな結果が問題でした-ゲストOSカーネルは通常の場所では動作しません。ゼロリングはハイパーバイザーによって占有されており、ゲストOSもそこに到達させる必要があります-一方では、すべての結果を伴うリアルモードに戻り、もう一方では、ゲストOSはそこに誰もいないと予想し、すべてのデータ構造を即座に破壊して車をドロップします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべてが非常に簡単に決定されました。ハイパーバイザーの場合、ゲストOSは完全な直接アクセスが可能なメモリページのセットであり、仮想プロセッサはコマンドのキューにすぎないので、それらを書き直してみませんか？</font><font style="vertical-align: inherit;">その場で、ハイパーバイザーは仮想プロセッサーで実行するために命令のキューからスローし、ゼロリング特権を必要とするすべての命令を、より特権の少ない命令に置き換えます。</font><font style="vertical-align: inherit;">ただし、これらの指示の結果は、ゲストOSがゼロリングにある場合とまったく同じ方法で表示されます。</font><font style="vertical-align: inherit;">したがって、ゲストOSが完全になくなるまで、何でも仮想化できます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、開発チームによって1999年にVMware Workstation製品に実装され、その後2001年にGSXサーバーハイパーバイザー（Workstationのような2番目のタイプ）とESX（最初のタイプ）に実装されました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準仮想化</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">準仮想化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は非常に単純な概念であり、ゲストOSが仮想マシン内にあること、および特定のシステム機能のためにホストOSにアクセスする方法を知っていることを前提としています。これにより、ゼロリングのエミュレーションの問題が解消されます。ゲストOSはゼロリングにないことを認識し、それに応じて動作します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
x86の準仮想化は、Linux Xenプロジェクトで2003年に登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の準仮想化機能は、ハイパーバイザーと通信して仮想化のオーバーヘッドを削減するゲストOSの特別な仮想ドライバーを介して完全仮想化を備えたハイパーバイザーにも実装されます。</font><font style="vertical-align: inherit;">たとえば、VM用のVMware ESXiには準仮想化SCSIアダプターPVSCSIがあり、ロードされたDBMSなど、ディスク操作が集中するVMの全体的なパフォーマンスが向上します。</font><font style="vertical-align: inherit;">準仮想デバイス用のドライバーは、追加のパッケージ（VMware Toolsなど）で提供されるか、すでにLinuxディストリビューション（open-vm-tools）に含まれています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハードウェア仮想化</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想化の発展と人気の高まりに伴い、両方のプラットフォームメーカーがサポートコストを削減し、セキュリティの観点からハードウェアでの保護を保証するという要望が生じました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は非常に単純な方法で解決されました。ハイパーバイザーの最初の保護リングを除いて、技術的な詳細を破棄すると、Intel VT-xおよびAMD-V独自のハードウェア仮想化テクノロジーが追加されました。</font><font style="vertical-align: inherit;">このようにして、ようやくOSに馴染みのゼロリングでの作業状況が確定しました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパーバイザーのタイプ</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ2（ホスト型）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタイプのハイパーバイザーは、ホストオペレーティングシステム上で実行されるアプリケーションです。すべての仮想マシンの呼び出しは、上流のホストオペレーティングシステムによって処理されます。 2番目のタイプのハイパーバイザーは、パフォーマンスが大幅に制限されています。これは、ハイパーバイザーのアプリケーションは、コンピューティングリソースを排他的に割り当てる権利がないため、他のユーザーアプリケーションと競合することを強いられるためです。セキュリティに関して、2番目のタイプのハイパーバイザーは、ユーザーOSのセキュリティポリシーと攻撃に対する脆弱性に直接依存します。今日、このようなエンタープライズレベルの仮想化プラットフォームは適切ではないという意見が全業界で一致しています。ただし、管理と展開が容易であるため、ソフトウェア開発者のマシンに直接スタンドをクロスプラットフォームで開発および展開するのに適しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のタイプのハイパーバイザーの例：VMware Workstation / Fusion、Oracle VM VirtualBox、Parallels Desktop、VMware Server（ex-GSX）、Microsoft Virtual Server 2005</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ1（ベアメタル）</font></font></h4><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のタイプのハイパーバイザーは、以前のものとは異なり、汎用OSを必要としません。ハイパーバイザー自体は、コンピューティングリソースの割り当てとI / Oの両方を制御するモノリスです。マイクロコアはゼロ安全リング内にあり、その上ですべての制御構造が機能します。このアーキテクチャでは、ハイパーバイザーがコンピューティングリソースの分散を制御し、デバイスに対するすべての仮想マシンの呼び出しを制御します。 VMware ESXは、長い間、x86の最初のタイプの最初のハイパーバイザーと見なされていましたが、今では1+に起因すると考えられます。今日、このタイプの唯一の「正直な」代表は、VMware ESXiです。RHELで親セクションから少し離れた後、ESXの後継です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ESXiアーキテクチャについて考えてみます。</font><font style="vertical-align: inherit;">ハイパーバイザー管理コマンドは、VMkernel上で実行されるエージェントAPIを介して実行されます。</font><font style="vertical-align: inherit;">これはハイパーバイザーへの直接接続のように見えるかもしれませんが、そうではありません。</font><font style="vertical-align: inherit;">ハイパーバイザーに直接アクセスすることはできません。このため、このタイプのハイパーバイザーは、セキュリティの点で2番目のタイプのハイパーバイザーと区別されます。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/361/f83/77d/361f8377d29345aa2498b31b9af66030.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでの欠点はデバイスドライバーです。プラットフォームの「薄さ」を確保し、バージョン間で不要な複雑さを排除するために、デバイスドライバーがローテーションされ、物理インフラストラクチャがHCL（ハードウェア互換性リスト）に依存します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプ1+（ハイブリッドハイパーバイザー）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハイブリッドタイプのハイパーバイザー（タイプ1 +、1a、1.5でもあります）は、ベースOSを親パーティション（Microsoft Hyper-V用語では親パーティション）または親ドメイン（Xen用語ではドメインdom0）と呼ばれる特別なエンティティに分離することを特徴としています。したがって、ハイパーバイザーの役割をインストールした後、カーネルは仮想化サポートモードに入り、ハイパーバイザーはホスト上のリソースの割り当てを担当します。ただし、親セクションは、デバイスドライバーとI / Oへの呼び出しを処理する機能を担います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、親セクションは、仮想化スタックのすべてのエンティティ間の一種のプロバイダーになります。このアプローチは、機器との互換性の観点から便利です。ESXiの場合のように、ハイパーバイザーにデバイスドライバーを埋め込む必要はありません。つまり、デバイスのリストが大幅に拡張され、HCLへの依存度が低くなります。親セクションはすべての呼び出しを処理するので、デバイスドライバーへの呼び出しを処理するタスクからハイパーバイザーをアンロードする利点があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイプ1+ハイパーバイザーの最上位アーキテクチャーは次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/89c/b74/eb3/89cb74eb3f97b6a8af063fbd447b1c87.jpg" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このタイプのハイパーバイザーには、故人のVMware ESX、Microsoft Hyper-V、Xenベースのハイパーバイザー（さまざまなLinuxディストリビューションでのCitrix XenServerおよびXenの実装）が含まれます。</font><font style="vertical-align: inherit;">Citrix XenServerはRHELベースのOSを少し省略したものであり、そのバージョンと機能はRed-Hat Enterprise Linuxの現在のバージョンに直接依存していたことを思い出してください。</font><font style="vertical-align: inherit;">他のXen実装の場合、状況はそれほど異なりません。Xenハイパーバイザーモードの同じLinuxカーネルとdom0ドメインのベースOSです。</font><font style="vertical-align: inherit;">これにより、Xenベースのハイパーバイザーはハイブリッドタイプであり、正直なタイプ1ハイパーバイザーではないという明確な結論につながります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">産業プラットフォームの主な技術</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基礎は、最も技術的に高度な仮想化プラットフォームとしてのVMwareの用語を採用します。</font><font style="vertical-align: inherit;">この記事では、ハイパーバイザー自体のテクノロジーと基本的な制御システムに限定します。</font><font style="vertical-align: inherit;">追加のお金のために追加の製品によって実装されるすべての高度な機能は、舞台裏に残されます。</font><font style="vertical-align: inherit;">テクノロジーは、作者に思われるように、主な目的のために条件付きグループにグループ化されています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SLA</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、主にアクセシビリティ（RPO / RTO）のSLAのパフォーマンスに影響を与えるテクノロジのコレクションです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
高可用性-ハイパーバイザーによってクラスター内のVMの高可用性を確保するためのテクノロジー。</font><font style="vertical-align: inherit;">ホストが停止した場合、VMは残りのホストで自動的に再起動します。</font><font style="vertical-align: inherit;">効果：HA +再起動OS /サービスのタイムアウト前にRTOを最小化します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FT</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フォールトトレランス-ホストが停止した場合でもVMの継続的な運用を保証するテクノロジー。</font><font style="vertical-align: inherit;">シャドウVMが2番目のホスト上に作成されます。これはメインのVMと完全に同一で、その背後にある指示を繰り返します。</font><font style="vertical-align: inherit;">したがって、VM状態の違いは数十ミリ秒または数百ミリ秒単位で測定され、多くのサービスで許容されます。</font><font style="vertical-align: inherit;">ホストが停止すると、実行は自動的にシャドウVMに切り替わります。</font><font style="vertical-align: inherit;">効果：RTOをゼロに最小化します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tco</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは主にTCOに影響を与えるテクノロジーのコレクションです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vMotion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vMotionは、完全に機能するホスト間でVM実行ポイントをライブマイグレーションするためのテクノロジーです。</font><font style="vertical-align: inherit;">同時に、実行ポイントの切り替えポイントはネットワーク接続のタイムアウトよりも短いため、移行をライブと見なすことができます。</font><font style="vertical-align: inherit;">生産的なサービスの作業を中断することなく。</font><font style="vertical-align: inherit;">効果：サーバーメンテナンスの計画的停止のRTOをゼロに減らし、その結果、停止自体の部分的な排除。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Storage vMotion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Storage vMotionは、完全に機能するストレージ間でVMストレージポイントをライブマイグレーションするためのテクノロジーです。</font><font style="vertical-align: inherit;">同時に、ディスクシステムでの作業は停止せず、移行はライブと見なされます。</font><font style="vertical-align: inherit;">効果：ストレージシステムの保守のために計画された停止のRTOをゼロに減らし、その結果、停止自体の部分的な排除。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DPM</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散電源管理-クラスターの負荷が変化したときに、ホストの負荷レベルとホストの電源オン/オフを制御するテクノロジー。</font><font style="vertical-align: inherit;">操作にはDRSが必要です。</font><font style="vertical-align: inherit;">効果：消費電力の全体的な削減。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散型vSwitch</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
分散vSwitchは、仮想ホストスイッチのネットワーク設定を集中管理するためのテクノロジーです。</font><font style="vertical-align: inherit;">効果：ネットワークサブシステムの再構成に関する作業の量と複雑さを減らし、エラーのリスクを減らします。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">EVC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
強化されたvMotion互換性は、自動モードでVMに使用可能なプロセッサ命令をマスキングできるテクノロジーです。</font><font style="vertical-align: inherit;">これは、不均一なクラスター内のVMの作業を最も古いプロセッサーファミリーに合わせるために使用され、VMを任意のホストに移行する機能を提供します。</font><font style="vertical-align: inherit;">効果：徐々に容量を増やしながら、インフラストラクチャの複雑さを軽減し、クラスターを部分的にアップグレードします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、サービス品質の観点から主にSLAパフォーマンスに影響を与えるテクノロジーのコレクションです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vNUMA</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
vNUMAは、ゲストOSがワイドマシン（vCPUまたはvRAM&gt; NUMAノード）のVM仮想NUMAトポロジと通信できるようにするテクノロジです。</font><font style="vertical-align: inherit;">効果：NUMAをサポートするアプリケーションソフトウェアのパフォーマンスに対するペナルティの欠如。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースプール</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リソースプール-複数のVMを1つのリソースプールに結合して、消費を制御したり、リソースの割り当てを保証したりするテクノロジー。</font><font style="vertical-align: inherit;">効果：管理を簡素化し、サービスのレベルを提供します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">制限/予約</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロセッサとメモリを制限して冗長化すると、リソースの割り当てを制限したり、その逆を行ったりして、不足や競争の状況でリソースの割り当てを保証し、優先度の高いVM /プールを確実に維持できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DRS</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dynamic Resource Scheduler-負荷に応じたホストによるVMの自動バランシングにより、クラスター内のリソースの断片化を減らし、VMに一定レベルのサービスを提供します。</font><font style="vertical-align: inherit;">vMotionサポートが必要です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージIO制御</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストレージIO制御は、ディスクの負荷が高い優先度の低いマシンである「騒々しい隣人」を制限して、生産的なワークロードに利用可能な高価なストレージシステムのパフォーマンスを維持するテクノロジーです。</font><font style="vertical-align: inherit;">例として、インデックスシステム/内部検索エンジンと生産的なDBMS。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワークIO制御</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワークIOコントロールは、「ノイズの多いネイバー」、つまりネットワーク負荷が高い優先度の低いマシンを制限するテクノロジーです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストレージ統合（VAAIなど）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2つのカテゴリーのテクノロジーが統合セクションに分類されます。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仮想化管理システムとストレージ管理システムを統合することで、ハイパーバイザーへのボリューム/ストレージバルーンの選択と表示を大幅に簡素化し、エラーのリスクと作業の複雑さを軽減できます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロトコルレベルの統合-VAAI、ODX。</font><font style="vertical-align: inherit;">これらのテクノロジーを使用すると、ディスクサブシステムをアンロードして、標準的な負荷の一部をインテリジェントストレージの処理に移すことができます。</font><font style="vertical-align: inherit;">たとえば、このカテゴリには、ブロックのゼロ化、VMのクローン作成などの操作が含まれます。</font><font style="vertical-align: inherit;">これにより、ストレージシステムへのチャネルの負荷が大幅に軽減され、ストレージシステム自体がより最適な方法でディスク操作を実行します。</font></font></li>
</ul><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全保障</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロセグメンテーション</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に使用されている仮想ネットワークのマイクロセグメンテーションは、ホスト内の仮想ネットワークを制御する仮想分散ファイアウォールを構築する機能です。</font><font style="vertical-align: inherit;">仮想ネットワークのセキュリティを大幅に強化します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エージェントレスAV</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
技術サポートエージェントレスアンチウイルス。</font><font style="vertical-align: inherit;">ゲストOSのエージェントによってチェックされる代わりに、VMディスク操作のトラフィックは、ハイパーバイザーによって選択されたサービスVMに送信されます。</font><font style="vertical-align: inherit;">プロセッサとディスクシステムの負荷を大幅に軽減し、「アンチウイルスストーム」を効果的に停止します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパーコンバージドシステム</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前が示すように、コンバージドシステムは、機能を組み合わせたシステムです。</font><font style="vertical-align: inherit;">この場合、ストレージとVMの実行の組み合わせを意味します。</font><font style="vertical-align: inherit;">簡単なように見えますが、マーケティングは突然介入します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マーケターは初めて、統合システムで市場に参入します。</font><font style="vertical-align: inherit;">コンバージドシステムは、通常のクラシックサーバー+ストレージ+スイッチを販売しました。</font><font style="vertical-align: inherit;">1つのパートナー番号のすぐ下。</font><font style="vertical-align: inherit;">または、彼らは販売さえしていませんでしたが、「リファレンスアーキテクチャ」と呼ばれる論文が作成されました。</font><font style="vertical-align: inherit;">私たちはこのアプローチを心から非難し、アーキテクチャの検討に移ります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建築</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アーキテクチャの原則として収束を維持しながら、単一のシステムでVMのストレージポイントと実行ポイントの組み合わせを取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、コンバージドアーキテクチャは、VMの実行とローカルディスクへの格納の両方に同じハードウェアサービスを使用することを意味します。</font><font style="vertical-align: inherit;">まあ、フォールトトレランスがあるはずです-コンバージドアーキテクチャでは、分散SDSのレイヤーがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我々が得る：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">従来のシステム-ソフトウェア、ストレージ、スイッチング、およびサーバーは、顧客/インテグレーターの手によって組み合わされたさまざまな場所にあります。</font><font style="vertical-align: inherit;">個別のサポート契約。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">統合システム-すべて1つのソース、1つのサポート、1つのパートナー番号から。</font><font style="vertical-align: inherit;">1つのベンダーからの自己組織化と混同しないでください。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私たちのコンバージドアーキテクチャの用語はすでに採用されていることがわかります。</font><font style="vertical-align: inherit;">監督者と全く同じ状況。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ハイパーコンバージドシステム</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -コンバージドアーキテクチャを備えたコンバージドシステム。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、それはマーケティング担当者の再来なしではありませんでした。</font><font style="vertical-align: inherit;">ストレージの組み合わせがない統合システムが登場しましたが、分散SDSの制御下にある専用ストレージノードがあります。</font><font style="vertical-align: inherit;">マーケティング戦争の枠組みの中で、特別な用語である分解されたHCI（分解されたハイパーバージェニックインフラストラクチャ）さえ登場しました。</font><font style="vertical-align: inherit;">特に、たとえば、同様のシステムを備えたNetAppは、最初、そのシステムをハイパーコンバージェントと呼ぶ権利を求めてかなり集中的に戦いましたが、最終的には降伏しました。</font><font style="vertical-align: inherit;">今日のNetApp HCI（2019年後半）-ハイブリッドクラウドインフラストラクチャ。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装オプション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハイパーコンバージドシステムは仮想化で動作するため、実装には実際には2つ半のオプションがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.カーネルモジュール。</font><font style="vertical-align: inherit;">SDSは、ハイパーバイザーのコア内でモノリスとして機能します（vSAN + ESXiなど）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.5親セクションモジュール。</font><font style="vertical-align: inherit;">SDSは、ハイパーバイザーの親セクション内のサービスとして機能します（例：S2D + Hyper-V）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.仮想マシン。</font><font style="vertical-align: inherit;">SDSは、各ホストの専用仮想マシンとして実装されます。</font><font style="vertical-align: inherit;">Nutanix、Cisco Hyperflex、HPE Simplivity。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、パフォーマンスへの埋め込みの影響で議論された問題に加えて、サードパーティのハイパーバイザーの分離とサポートの非常に重要な問題があります。</font><font style="vertical-align: inherit;">ケース1の場合、これはハイパーバイザーのプロバイダーからの単一のシステムにしかできないことは明らかですが、2は任意のハイパーバイザーで機能する可能性があります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーの仮想化は、技術的には完全な仮想化とは非常に異なりますが、構造は非常にシンプルに見えます。</font><font style="vertical-align: inherit;">OSIネットワークモデルと同様に、問題はレベルです。</font><font style="vertical-align: inherit;">コンテナの仮想化は、物理環境ではなく、アプリケーション環境のレベルで、より高いレベルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナー仮想化の主なタスクは、OSを独立した部分に分割することです。独立したアプリケーションが互いに干渉することはありません。</font><font style="vertical-align: inherit;">完全仮想化はOSではなく物理サーバーによって共有されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VMとコンテナ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のアプローチの長所と短所は非常にシンプルで正反対です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全仮想化（VM）は、完全に独立したOS、ディスク、およびネットワークスタックを含む、アイアンのレベルに完全な独立性を与えます。一方、各アプリケーションは、スキーム1アプリケーション= 1サーバーに準拠しているため、独自のOS、独自のディスク、およびネットワークスタックを必要とします。それら。リソースの複数の支出があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナーには、ホストOSと共通のディスクスタックとネットワークスタックがあり、それらがすべて一緒になって、物理サーバー全体（最近では、まあ仮想）で1つのコアを使用します。これにより、全体として、同種ランドスケープのリソースを大幅に節約できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
歴史的に、x86には当初、物理サーバーとともにすべてのもののコンテナーがありました。</font><font style="vertical-align: inherit;">完全な仮想化の登場後、コンテナの重要性は15年近く劇的に低下し、シックVMが企業の世界で君臨しました。</font><font style="vertical-align: inherit;">当時、コンテナは、軽量が要求されていた数百もの同じタイプのWebサーバーを提供するホスティング会社にありました。</font><font style="vertical-align: inherit;">しかし、近年、2015年頃から、コンテナはクラウドネイティブアプリケーションの形で企業の現実に戻ってきました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ0.1</font></font></h3><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chroot</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1979年のコンテナのプロトタイプはchrootでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ChrootはUnixライクなオペレーティングシステムでルートディレクトリを変更する操作です。</font><font style="vertical-align: inherit;">変更されたルートディレクトリで起動されたプログラムは、このディレクトリに含まれているファイルにのみアクセスできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それら。</font><font style="vertical-align: inherit;">実際、分離はファイルシステムレベルでのみ行われます。それ以外の場合は、OSにおける通常のプロセスです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Freebsd刑務所</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに進んだのは、1999年に登場した無料のBSDの刑務所でした。</font><font style="vertical-align: inherit;">Jailを使用すると、ベースのFreeBSDに基づく独自のアプリケーションセットと構成ファイルを使用して、本格的な仮想OSインスタンスを作成できます。</font><font style="vertical-align: inherit;">きっと言う人がいるでしょう-そして、刑務所がコンテナで何をするか、これは準仮想化だからです！</font><font style="vertical-align: inherit;">そして、それらは部分的に正しいでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、完全仮想化（および準仮想化の形式のバリアント）の前は、jailにはゲストVMで異なるバージョンのカーネルを実行したり、VMを別のホストシステムに移行してクラスタリングしたりする機能がありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solarisゾーン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solarisゾーンは、2004年にSun Solarisに導入されたオペレーティングシステム仮想化テクノロジ（コンテナ仮想化）です。</font><font style="vertical-align: inherit;">基本原則は、仮想化のオーバーヘッドが少ないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あまり人気がなく、OpenSolarisとそれに基づくディストリビューションに移行し、2019年に利用可能になりました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ1.0</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナ1.0の時代には、コンテナ化の2つの主な方向が現れました。これらは、ホスティングプロバイダー向けの商用製品と、アプリケーションのコンテナ化です。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Virtuozzo / OpenVZ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアのSWsoftは、2001年に、ホスティングプロバイダーの市場を対象とした最初のバージョンのコンテナー仮想化Virtuozzoを発表しました。</font><font style="vertical-align: inherit;">決意と特定の商業的対象読者のために、製品は非常に成功し、人気を得ました。</font><font style="vertical-align: inherit;">技術的には、2002年に、8プロセッササーバーでの2500コンテナの同時操作が実証されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2005年に、OpenVZと呼ばれるLinux用のVirtuozzoコンテナのオープンバージョンが登場しました。</font><font style="vertical-align: inherit;">そして、VPSをホストするためのゴールドスタンダードになりました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LXC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LinuXコンテナー（LXC）は、2008年に登場した名前空間とcgroupに基づくもう1つのよく知られているコンテナー仮想化です。これは、現在人気のあるドッカーなどの基礎となるものです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ1.1（アプリケーションの仮想化）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りのコンテナがベースOSをセグメントに分割するように設計されている場合は、システムのこの層を切り離して、アプリケーションとその周囲のすべてを1つのボックスに詰めてください。</font><font style="vertical-align: inherit;">そして、この既製のパッケージを通常のユーザーレベルのアプリケーションとして起動できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリ-v</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft Application Virtualization（App-V）、以前はSoftricity SoftGrid-分離されたサンドボックスに特定のアプリケーション（コンテナーは反対）をコンテナー化するためのテクノロジ。</font><font style="vertical-align: inherit;">2006年、マイクロソフトはSoftricityの新興企業を買収しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thinapp</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VMware ThinApp（旧Thinstall）は、2008年にVMwareが買収したJiltのアプリケーションコンテナー化製品です。</font><font style="vertical-align: inherit;">ヴイエムウェアでは、世界中のパッケージアプリケーションの90〜95％がこの特定のテクノロジーを使用していると推定しています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナ2.0</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナ2.0の出現の歴史は、ソフトウェア開発プロセスの変化と非常に関連しています。市場投入までの時間などの重要なパラメーターを削減するというビジネスの要望により、開発者はソフトウェア製品を作成するアプローチを再考する必要がありました。ウォーターフォール開発方法論（長いリリースサイクル、アプリケーション全体が更新されます）はアジャイル（短い、時間固定のリリースサイクル、アプリケーションコンポーネントは個別に更新されます）に置き換えられ、開発者はモノリシックアプリケーションをコンポーネントに分離する必要があります。モノリシックアプリケーションのコンポーネントは依然として非常に大きく、仮想マシンに配置できるコンポーネントは多くありませんが、1つのアプリケーションが数十または数百のコンポーネントで構成される場合、仮想マシンはあまり適していません。さらに、補助ソフトウェア、ライブラリ、および依存関係のバージョンの問題も発生します。多くの場合、コンポーネントごとに異なるバージョンや異なる構成の環境変数が必要になる状況があります。このようなコンポーネントは、異なる仮想マシンに分散する必要があります。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。ライブラリと依存関係では、多くの場合、異なるコンポーネントが異なるバージョンまたは異なる構成の環境変数を必要とする状況があります。このようなコンポーネントは、異なる仮想マシンに分散する必要があります。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。ライブラリと依存関係では、多くの場合、異なるコンポーネントが異なるバージョンまたは異なる構成の環境変数を必要とする状況があります。このようなコンポーネントは、異なる仮想マシンに分散する必要があります。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。異なるコンポーネントが異なるバージョンまたは異なる構成の環境変数を必要とする場合。このようなコンポーネントは、異なる仮想マシンに分散する必要があります。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。異なるコンポーネントが異なるバージョンまたは異なる構成の環境変数を必要とする場合。このようなコンポーネントは、異なる仮想マシンに分散する必要があります。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。同じOS内で複数のバージョンのソフトウェアを同時に実行することはほとんど不可能です。 VMの数は雪崩のように増加し始めます。ここでは、コンテナがステージに表示され、1つのゲストOSのフレームワーク内で、アプリケーションコンポーネントを起動するための複数の分離された環境を作成できます。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。アプリケーションのコンテナー化により、モノリシックアプリケーションをさらに小さなコンポーネントにセグメント化し続け、1つのタスク= 1つのコンポーネント（コンテナー）のパラダイムに移行できます。これはマイクロサービスアプローチと呼ばれ、そのような各コンポーネントはマイクロサービスです。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボンネットの下のコンテナ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システム管理者から一目でコンテナを見ると、これらは独自のpidを持つLinuxプロセスにすぎません。</font><font style="vertical-align: inherit;">コンテナーで実行されているプロセスを互いに分離して、ゲストOSリソースを共同で消費することを可能にするものは何ですか？</font><font style="vertical-align: inherit;">最新のLinuxディストリビューションのカーネルに存在する2つの標準メカニズム。</font><font style="vertical-align: inherit;">最初のLinux名前空間は、各プロセスが独自のOS表現（ファイルシステム、ネットワークインターフェイス、ホスト名など）を確実に参照できるようにし、2番目のLinux制御グループ（cgroups）は、ゲストOSリソース（CPU、メモリ）の消費にプロセスを制限します。ネットワーク帯域幅など）。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux名前空間</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、すべてのLinuxシステムに1つの名前空間が含まれています。</font><font style="vertical-align: inherit;">ファイルシステム、プロセス識別子（プロセスID）、ユーザー識別子（ユーザーID）、ネットワークインターフェイスなどのすべてのシステムリソースは、この名前空間に属します。</font><font style="vertical-align: inherit;">しかし、追加の名前空間を作成したり、それらの間でシステムリソースを再配布したりするのを妨げるものは誰もいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいプロセスが開始すると、名前空間、システム標準、または作成されたプロセスのいずれかで開始されます。</font><font style="vertical-align: inherit;">そして、このプロセスは、それを実行するために使用される名前空間で使用可能なリソースのみを表示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべてがそれほど単純ではないため、各プロセスは1つの単一の名前空間に属しているのではなく、各カテゴリの1つの名前空間に属しています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マウント（MNT）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスID（pid）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ネットワーク（ネット）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセス間通信（ipc）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UTS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーID（ユーザー）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
名前空間の各タイプは、対応するリソースグループを分離します。</font><font style="vertical-align: inherit;">たとえば、UTSスペースは、プロセスから見えるホスト名とドメイン名を定義します。</font><font style="vertical-align: inherit;">したがって、ゲストOS内の2つのプロセスは、異なるサーバー上で実行されていると想定できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ネットワーク名前空間は、ネットワークインターフェイスの可視性を決定します。内部のプロセスには、この名前空間に属するインターフェイスのみが表示されます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linuxコントロールグループ（cgroups）</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxコントロールグループ（cgroups）は、プロセスによるシステムリソースの消費を制限するLinuxシステムのカーネルシステムメカニズム（カーネル）です。</font><font style="vertical-align: inherit;">各プロセスまたはプロセスのグループは、割り当てられているよりも多くのリソース（CPU、メモリ、ネットワーク帯域幅など）を取得できず、「他の」リソース（隣接プロセスのリソース）をキャプチャできません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Docker</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、Dockerはコンテナ自体を発明していません。コンテナーは長年存在します（LXCベースのコンテナーを含む）が、異なるマシン間でコンテナーを簡単かつ簡単に転送できる最初のシステムを作成することにより、Dockerは非常に人気がありました。 Dockerはコンテナを作成するためのツールを作成しました-アプリケーションとその依存関係をパッケージ化し、DockerがインストールされているLinuxシステムでコンテナを実行します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerの重要な機能は、アプリケーション自体と完全に異なるLinuxディストリビューション間のその依存関係だけでなく、環境とファイルシステムの移植性です。たとえば、CentOSで作成されたコンテナは、Ubuntuシステムで実行できます。この場合、起動されたコンテナー内では、ファイルシステムはCentOSから継承され、アプリケーションはCentOSの上で実行されていると見なします。これは仮想マシンのOVFイメージにいくぶん似ていますが、Dockerイメージのコンセプトはレイヤーを使用しています。つまり、イメージの一部のみを更新する場合、イメージ全体を再度ダウンロードする必要はなく、OVFイメージがイメージ全体を更新せずにOSを更新できるかのように、変更されたレイヤーのみをダウンロードするだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dockerは、コンテナーを作成、保存、転送、および起動するためのエコシステムを作成しました。</font><font style="vertical-align: inherit;">Dockerの世界には3つの主要なコンポーネントがあります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">画像-画像。これは、アプリケーション、必要な環境、およびコンテナの起動に必要なその他のメタデータを含むエンティティです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レジスタ-Dockerイメージのリポジトリ、保管場所。</font><font style="vertical-align: inherit;">公式リポジトリ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-hub.docker.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">から</font><font style="vertical-align: inherit;">企業のインフラストラクチャにデプロイされたプライベート</font><font style="vertical-align: inherit;">リポジトリまで、さまざまなリポジトリがあり</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテナー-コンテナー、Dockerイメージから作成されたLinuxコンテナー。</font><font style="vertical-align: inherit;">上記のように、これはDockerがインストールされたLinuxシステムで実行されるLinuxプロセスであり、他のプロセスやOS自体から分離されています。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテナのライフサイクルを検討してください。</font><font style="vertical-align: inherit;">最初に、開発者は自分のアプリケーション（docker buildコマンド）でDockerイメージを作成します。完全にゼロから作成するか、すでに作成されたイメージをベースとして使用します（レイヤーについて覚えておいてください）。</font><font style="vertical-align: inherit;">さらに、このイメージは、開発者が自分のマシンで直接起動することも、別のマシン（サーバー）に転送することもできます。</font><font style="vertical-align: inherit;">移植性のために、リポジトリがよく使用されます（docker pushコマンド）。イメージはリポジトリにロードされます。</font><font style="vertical-align: inherit;">その後、イメージを他のマシンまたはサーバーにダウンロードできます（docker pull）。</font><font style="vertical-align: inherit;">最後に、このイメージから作業コンテナー（docker run）を作成します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kubernetes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、マイクロサービスの概念は、モノリシックアプリケーションを多くの小さなサービスに分割し、通常は1つの機能を実行することを意味します。このようなサービスが数十ある場合は、Dockerなどを使用して手動で管理できます。しかし、そのようなサービスが数百、数千ある場合はどうすればよいでしょうか。産業環境に加えて、製品のさまざまなバージョンに対応するテスト環境と追加の環境が必要です。 2倍、3倍、またはそれ以上。グーグルも同じ問題に直面し、そのエンジニアは工業規模でコンテナを使用した最初の人の一人でした。そのため、Kubernetes（K8s）が誕生し、Google製品の壁にBorgという名前で作成され、後に一般に公開されて名前が変更されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
K8sは、コンテナー化されたアプリケーション（マイクロサービス）の展開、管理、監視を簡単にするシステムです。すでにご存じのように、どのLinuxマシンもコンテナーの起動に適しており、コンテナーはそれぞれ互いに分離されており、K8はさまざまなハードウェアでさまざまなLinuxディストリビューションの制御下にあるさまざまなサーバーを管理できます。これらはすべて、利用可能なハードウェアを効果的に使用するのに役立ちます。仮想化と同様に、K8sは、マイクロサービスの起動、管理、監視のための共通のリソースプールを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は主に仮想化エンジニアを対象としているため、K8の動作原理と主要コンポーネントを一般的に理解するために、K8とVMware vSphereの類似点を理解するための記事に精通することをお勧めします。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">https://medium.com/@pryalukhin/kubernetes-introduction-for-vmware-users-232cc2f69c58</a><br>
<br>
<h2>   x86</h2><br>
<h3>VMware</h3> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VMwareは1998年に登場し、2番目のタイプのハイパーバイザの開発から始まりました。これは、後にVMware Workstationとして知られるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同社は、2001年にGSX（Ground Storm X、2番目のタイプ）とESX（Elastic Sky X、1番目のタイプ）の2つのハイパーバイザーでサーバー市場に参入しました。時間の経過とともに、サーバーアプリケーションの2番目のタイプの見通しが明らかになりました。無し。そして、有料のGSXは最初に無料のVMwareサーバーになり、その後完全に停止して埋められました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2003年には、Virtual Center中央管理システム、vSMPテクノロジ、および仮想マシンのライブマイグレーションが登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2004年、VMwareはストレージ大手のEMCに買収されましたが、運用は独立しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2008年に業界の事実上の標準となったVMwareは、Citrix、Microsoftなどの競争力のあるオファーの急速な成長を刺激しました。ESXの親セクションとして、完全に商用のRHELが使用されていたため、ハイパーバイザーの無料バージョンを入手する必要性が明らかになりました。 RHELをより簡単で無料なものに置き換えるプロジェクトは、2008年にbusyboxシステムで実装されました。その結果、ESXiが誕生しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
並行して、同社は社内プロジェクトとスタートアップの買収を通じて開発を進めています。</font><font style="vertical-align: inherit;">数年前、VMware製品のリストにA4ページが数ページ含まれていたため、一言だけ言っておきましょう。</font><font style="vertical-align: inherit;">2019年のVMwareは、70％を超える市場シェアを持ち、絶対的なテクノロジーリーダーであるオンプレミス企業の完全仮想化市場における事実上の標準であり、歴史の詳細なレビューは別の非常に大きな記事に値します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connectix</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connectixは1988年に設立され、仮想化を開始するまでさまざまなシステムユーティリティに取り組みました。</font><font style="vertical-align: inherit;">1997年、Apple Macintosh用の最初のVirtualPC製品が作成され、Windowsを仮想マシンで実行できるようになりました。</font><font style="vertical-align: inherit;">VirtualPC for Windowsの最初のバージョンは2001年に登場しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2003年、マイクロソフトはVirtualPCを購入し、Connectixとの合意により、開発者はマイクロソフトに切り替えました。</font><font style="vertical-align: inherit;">その後、Connectixは終了しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VHD（仮想ハードディスク）フォーマットはConnectix for VirtualPCによって開発され、Hyper-Vマシンの仮想ディスクはシグネチャに「conectix」が含まれていることを思い出してください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仮想PCは、ご想像のとおり、2番目のタイプのクラシックデスクトップハイパーバイザーです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロソフト</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoftの産業用仮想化への取り組みは、Connectixの購入とMicrosoft Virtual PC 2004でのConnectix Virtual PCのブランド変更から始まりました。しばらくの間開発されたVirtual PCは、Windows 7ではWindows Virtual PCという名前で含まれていました。Windows8以降では、Virtual PCはHyper-Vのデスクトップバージョン。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Virtual PCに基づいて、サーバーサーバーVirtual Serverが作成されました。これは、2008年の初めまで存在していました。 VMware ESXの前に明らかな技術的損失があったため、独自の最初のタイプのハイパーバイザであるHyper-Vを優先して、2番目のタイプのハイパーバイザの開発を削減することが決定されました。業界では、Hyper-Vは意外にもXenとアーキテクチャが似ているという非公式の意見があります。 Javaの.Netとほぼ同じです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「もちろん、MicrosoftがJavaのアイデアを盗んだと思うかもしれません。」</font><font style="vertical-align: inherit;">しかし、これは真実ではありません、マイクロソフトは彼女にインスピレーションを与えました！</font><font style="vertical-align: inherit;">-（Windows 2003 ServerのプレゼンテーションでのMicrosoft担当者のスピーチから）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
奇妙な瞬間から、Microsoftの内部では、ゼロ年での独自の仮想化製品の使用は、穏やかに言えば、オプションでした。</font><font style="vertical-align: inherit;">仮想化に関する記事のTechnetのスクリーンショットがあり、VMware Toolsのロゴがトレイに明確に表示されています。</font><font style="vertical-align: inherit;">また、モスクワの2009プラットフォームのMark Russinovichは、VMware Workstationを使用してデモンストレーションを行いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoftは、新しい市場に参入するために、プラットフォームとしてHyper-V、S2D、SDNをサポートする高度に変更されたNano Serverを使用して、独自のパブリッククラウドAzureを作成しました。注目に値するのは、当初、Azureがいくつかの点でオンプレミスシステムに大きく遅れをとっていたことです。たとえば、第2世代の仮想マシンのサポート（セキュアブート、GPTパーティションからのブート、PXEブートなどのサポート）は、Azureで2018年にのみ登場しました。オンプレミスでは、第2世代のVMはWindows Server 2012R2以降で知られています。同じことがポータルソリューションにも当てはまります。2017年まで、AzureとWindows Azure Pack（2013年にSystem Center App Controllerに代わる、SDNとShielded VMをサポートするマルチテナンシークラウドソリューション）は同じポータルデザインを使用していました。マイクロソフトがパブリッククラウドに関するコースを発表した後、Azureは、さまざまなノウハウの開発と実装に一歩前進しました。 2016年頃に、完全に論理的な全体像を見ることができます。WindowsServerのすべての革新はAzureからもたらされますが、反対方向ではありません。ドキュメントの一部をAzureからオンプレミスに「現状のまま」コピーするという事実（Azure SDNおよびネットワークコントローラーのドキュメントを参照）はこれを示し、一方ではオンプレミスソリューションへの態度を示し、もう一方ではソリューションの関係を示します。エンティティとアーキテクチャの観点から。誰から誰がどのようにコピーしたか-議論の余地のある質問です。ドキュメントの一部をAzureからオンプレミスに「現状のまま」コピーするという事実（Azure SDNおよびネットワークコントローラーのドキュメントを参照）はこれを示し、一方ではオンプレミスソリューションへの態度を示し、もう一方ではソリューションの関係を示します。エンティティとアーキテクチャの観点から。誰から誰がどのようにコピーしたか-議論の余地のある質問です。ドキュメントの一部をAzureからオンプレミスに「現状のまま」コピーするという事実（Azure SDNおよびネットワークコントローラーのドキュメントを参照）はこれを示し、一方ではオンプレミスソリューションへの態度を示し、もう一方ではソリューションの関係を示します。エンティティとアーキテクチャの観点から。誰から誰がどのようにコピーしたか-議論の余地のある質問です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年3月、Satya Nadela（Microsoft CEO）は、パブリッククラウドが同社の優先事項になりつつあることを正式に発表しました。</font><font style="vertical-align: inherit;">明らかに、オンプレミス製品のサーバーラインの段階的なフォールディングとフェードを象徴しています（ただし、2016年に停滞が見られましたが、最初のWindows Serverベータ版と残りのオンプレミス製品ラインで確認されました）。ただし、Azure Edge-必要最小限のサーバークラウドに導入できないサービスのための顧客のオフィスのインフラストラクチャ。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バーチャルアイアン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2003年に設立されたVirtual Ironは、Xenの商用バージョンを提供し、完全なハードウェア仮想化サポートを市場に提供した最初の1つでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2009年、Oracleは仮想化Oracle VMの独自のラインを開発し、x86で拡張することに吸収されました。</font><font style="vertical-align: inherit;">これ以前は、Oracle VMはSPARCプラットフォームでのみ提供されていました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Innotek</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2007年の初めに、Innotek GmbHは2番目のタイプの専用デスクトップハイパーバイザーであるVirtualBoxをリリースしました。</font><font style="vertical-align: inherit;">同年、オープンソース版がリリースされた。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2008年にSunが買収し、SunがOracleに買収されました。</font><font style="vertical-align: inherit;">オラクルは、非営利目的での製品の無料使用を維持しています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VirtualBoxは、VDI（ネイティブ）、VMDK（VMware）、VHD（Microsoft）の3つの形式の仮想ディスクをサポートしています。</font><font style="vertical-align: inherit;">サポートされるホストOSは、Windows、macOS、Linux、Solaris、およびOpenSolarisです。</font><font style="vertical-align: inherit;">VirtualBox for FreeBSDのフォークは知られています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ibm</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メインフレームは、大量の内部メモリと外部メモリを備えたデータセンターのメインコンピュータです（参考：60年代には、1 MBのメモリは非現実的に大きいと見なされていました）。実際、メインフレームはコンピューティングセンターでした。最初のコンピューターは機械室全体を占め、巨大なラックで構成されていました。今日ではデータセンターと呼ばれています。しかし、同じマシンルーム内のデータセンターでは数千台のコンピューターが存在し、コンピューティングテクノロジーの黎明期には、1台のコンピューターが部屋全体を占めていました。各ラックは1つの（！）コンピュータデバイスを販売しました（メモリ付きの個別のラック、ストレージデバイス付きの個別のラック、および個別の周辺機器）。この巨大なマシンの中核は、プロセッサを搭載したラックでした。これはメイン（メインフレーム）と呼ばれていました。トランジスタ集積回路に切り替えた後、この科学と工学の奇跡のサイズは大幅に減少し、IBMのメインフレームとその類似物はメインフレームとして理解され始めました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XX世紀の60年代には、メインフレーム全体のコンピューティングパワーのレンタルは、購入は言うまでもなく、多額の費用がかかりました。このような贅沢を提供できる企業や機関はほとんどありません。コンピューティングパワーのリースは1時間ごとでした（パブリッククラウドでモデル化する最新のPay as goのプロトタイプですね）。計算のためのテナントへのアクセスは順次許可されました。論理的な解決策は、計算負荷を並列化し、テナントの計算を互いに分離することでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初めて、1つのメインフレームでオペレーティングシステムの複数のインスタンスを分離するというアイデアが、IBMシステム/ 360-67メインフレームに基づいてIBM Cambridge Science Centerによって提案されました。開発はCP / CMSと呼ばれ、実際、最初のハイパーバイザーであり、準仮想化を提供しました。 CP（制御プログラム）-いくつかの独立した「仮想マシン」（VM）を作成したハイパーバイザー自体。 CMS（当初はCambridge Monitor System、後にConversational Monitor Systemに改名）は、軽量のシングルユーザーオペレーティングシステムでした。奇妙なことに、CMSは現在も存続しており、最新世代のz / VMメインフレームでも使用されています。その当時から90年代までは、仮想マシンは物理ディスクを論理的に分離することを意味していました（ディスクまたはストレージデバイスは共有されていましたが、ハイパーバイザーは、独自のニーズに応じたストレージを提供しませんでした）タイムシェアリングテクノロジーを使用した専用の仮想メモリとプロセッサ時間。その当時のVMはデータの計算と保存に関するものであり、データの転送に関するものではなかったため、VMはネットワークの相互作用を提供していませんでした。この意味で、当時のVMは、現代的な意味でのVMよりもコンテナーのようでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1972年8月2日に、VM / 370と呼ばれる、CP / CMSベースの最初の商用ハイパーバイザーがSystem / 370シリーズのメインフレームに登場しました。このオペレーティングシステムファミリの一般名はVMであり、このセクションのフレームワーク内では、VMはまさにIBMハイパーバイザを意味します。同時に複数のオペレーティングシステムを実行し、システムの安定性を保証し、ユーザーを互いに分離する機能（あるユーザーのOSのエラーが別のユーザーの計算に影響を与えることはありませんでした）-革新的であり、VM / 370の商業的成功の重要な要素となりました。奇妙な事実：ソビエト連邦における当時のコンピュータサイエンス科学研究所（ミンスク）の取り組みは、システム/ 370アーキテクチャを非常にうまくクローン化し、EUコンピュータの名前で独自のアナログVM / 370を作成しました（組み込み仮想化をサポートしています！-最も基本的なOSの開発の可能性のため）。このようなメインフレームは、社会主義キャンプの研究機関や防衛企業によって使用されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
80年代は安全に「メインフレーム時代」と呼ぶことができます。 VMはオペレーティングシステムの開発者に成功し、アプリケーションはそのために作成され、計算が行われました。これは、VM OSが支配するデータベースのシェアがメインフレームで普及し始めた10年間でした。最も重要な変更の1つは、2つのレベルの仮想化を実際に提供する論理パーティション（Logical Partition Access ResourcesまたはLPAR）でした。クライアントは、異なるLPARで実行されているVMシステムで同じプロセッサ、I / Oデバイス、およびモデムのセットを使用できるようになり、リソースをVMシステム間で移行できるようになりました。これにより、IT組織は、ワークロードの急上昇を処理しながら、一貫したパフォーマンスを提供できました。増加する顧客ベースを合理化するために、VMは3つの個別の製品に分割されました。80年代後半に利用可能：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VM / SP-System zサーバー用の通常の多目的仮想化オペレーティングシステム</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
HPO（高性能オプション）-古いSystem zサーバーモデル用の高性能VM / SP </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
VM / XA（拡張アーキテクチャ）-拡張S / SアーキテクチャをサポートするVMバージョン370</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
90年代初頭、x86アーキテクチャのシンプルさと利便性は顧客にとってより魅力的になり、メインフレームは急速に関連性を失っていました。</font><font style="vertical-align: inherit;">メインフレームは、glamメタルを同時に置き換えるグランジのようなクラスターシステムに置き換えられました。</font><font style="vertical-align: inherit;">ただし、たとえば集中型データウェアハウスを構築する場合など、特定のクラスのタスクでは、メインフレームは生産性の観点と経済的な観点の両方で正当化されます。</font><font style="vertical-align: inherit;">したがって、一部の企業は依然としてインフラストラクチャでメインフレームを使用しており、IBMは新世代を設計、リリース、サポートしています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux Xen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Xen（zenと発音）は、ケンブリッジ大学のコンピューターラボでIan Prattの指導の下で開発され、GPLの下で配布されているハイパーバイザーです。</font><font style="vertical-align: inherit;">最初の公開バージョンは2003年に登場しました。</font><font style="vertical-align: inherit;">その後、Ianは引き続き商用バージョンでハイパーバイザーに取り組み、XenSourceという会社を設立しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年、XenはLinux Foundationの管理下に置かれました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XenSource</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XenServerおよびXenEnterprise製品とともに数年間市場に存在し、2007年末にCitrixに買収されました。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Citrix XenServer</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XenSourceを5億ドルで吸収したため、Citrixはこの問題を商品化できませんでした。</font><font style="vertical-align: inherit;">むしろ、私は実際にそれをやろうとはせず、XenServerを主な製品とは考えず、永久ライセンスの安価さに依存していました。</font><font style="vertical-align: inherit;">非常に成功したVMware ESXのなかで率直に言って不成功に終わった後、2009年にXenServerを無料で完全なオープンソースで世界にリリースすることが決定されました。</font><font style="vertical-align: inherit;">ただし、XenCenter独自の管理システムコードは開きませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
企業が常に非常に親密であったという事実にもかかわらず、産業用仮想化の分野におけるCitrixとMicrosoftの取り組みの興味深い年代順の偶然に注目することは間違いありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
共通のマーケティング名にもかかわらず、Citrix XenAppおよびXenDesktopはXenハイパーバイザーとは何の関係もありません。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アマゾン</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Amazonは、2006年にEC2（Elastic Compute）と呼ばれるパブリックIaaSクラウド製品を発表しました。</font><font style="vertical-align: inherit;">最初、EC2プラットフォームはXenハイパーバイザーを使用し、その後、Amazonはプラットフォームを3つの部分に分割し、それぞれがハイパーバイザーの個別のブランチとバージョンを使用して、サービスの可用性に対するコードのエラーの影響を最小限に抑えました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2017年、EC2では追加のハイパーバイザーとして高負荷用のKVMが登場しました。</font><font style="vertical-align: inherit;">これはEC2が完全に将来的にKVMに段階的に移行することを示しているという意見があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linux QEMU / KVM</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QEMU（Quick EMUlator）は、GPL v2ライセンスの下で配布される、さまざまなプラットフォームのハードウェアをエミュレートするためのユニバーサルソフトウェアです。</font><font style="vertical-align: inherit;">x86に加えて、ARM、MIPS、RISC-V、PowerPC、SPARC、SPARC64もサポートされています。</font><font style="vertical-align: inherit;">完全仮想化を備えたプラットフォームの多様性により、QEMUは非仮想化システムに匹敵するパフォーマンスに欠けていました。</font><font style="vertical-align: inherit;">x86でのQEMUの処理を高速化するために、2つの主要なオプションが提供されましたが、最終的には拒否され、QumranetのKVM（カーネルベースの仮想マシン）開発が支持されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはKVMと言います-私たちはQEMU KVMを意味し、それに応じて、KVMハイパーバイザーに基づくすべてのプラットフォーム用のqcow2仮想ディスク形式（QEMUコピーオンライト2）を取得します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
QEMUは最初は2番目のタイプのハイパーバイザーとして機能しますが、QEMU / KVMは最初のタイプのハイパーバイザーです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クムラネ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KVMハイパーバイザーとSPICEプロトコルの元開発者でメインスポンサーであるイスラエルの会社。</font><font style="vertical-align: inherit;">2005年に設立され、LinuxカーネルにKVMを組み込んだことで有名になりました。</font><font style="vertical-align: inherit;">2008年9月4日、Red Hatが買収。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">赤い帽子</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのGNU / Linuxディストリビューションメーカーと同様、2010年まで、Red HatはディストリビューションにXenハイパーバイザーの組み込みサポートを備えていました。</font><font style="vertical-align: inherit;">しかし、市場の主要なプレーヤーであり、真面目なブランドであるため、私は自分自身のハイパーバイザーの実装について考えました。</font><font style="vertical-align: inherit;">その後、その基礎は目立たないが有望なKVMハイパーバイザーによって採用されました。</font><font style="vertical-align: inherit;">Red Hat Enterprise Virtualization 2.2（RHEV）の最初のバージョンは2010年に導入され、2年前に買収されたQumranetの開発により、CitrixおよびVMwareとVDIソリューション市場の一部で競争すると主張しました。</font><font style="vertical-align: inherit;">すぐに使用できる高可用性クラスター、ライブマイグレーション、M2Mマイグレーションツール（RHELのみ）が利用可能でした。</font><font style="vertical-align: inherit;">当時のドキュメントから判断すると、Red Hatがソリューションアーキテクチャを説明する際にXenの表記を保持していることは注目に値します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年10月28日、IBMはRed Hatの購入を発表しました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンスタック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
歴史的に、OpenStackプロジェクトは、x86の重いサーバー仮想化の分野で、VMwareの実際の独占と何かを対比するイニシアチブとして浮上しました。</font><font style="vertical-align: inherit;">このプロジェクトは、Rackspace Hosting（クラウドプロバイダー）とNASA（独自のNebulaプラットフォームのコードをオープンした）の共同作業のおかげで2010年に登場しました。</font><font style="vertical-align: inherit;">この状況の特徴は、VMwareが2012年にOpenStackプロジェクト管理に参加し、創設活動家の間で憤慨の波を引き起こしたことによってもたらされました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、Canonical（Ubuntu Linux）、Debian、SUSE、Red Hat、HP、Oracleがプロジェクトに参加しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、すべてがスムーズであったわけではありません。</font><font style="vertical-align: inherit;">2012年、NASAはAWSを選択してプロジェクトを辞めました。</font><font style="vertical-align: inherit;">2016年の初めに、HPEはOpenStackに基づくHelionプロジェクトを完全に閉鎖しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStackプロジェクトの一部として、KVMが標準ハイパーバイザーとして採用されています。ただし、アプローチのモジュール性により、OpenStackベースのシステムは、他のハイパーバイザーを使用して実装でき、たとえば、OpenStackの制御システムのみが残ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStackプロジェクトに関しては、熱狂的な崇拝から深刻な懐疑論、厳しい批判まで、幅広い意見があります。批判には理由がないわけではありません。OpenStackを使用すると、かなりの数の問題とデータ損失が記録されました。ただし、それによってファンがすべてを否定したり、システムの実装と操作の曲率を参照したりするのを止めることはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OpenStackプロジェクトは仮想化だけに限定されているわけではありませんが、時間の経過とともに、パブリッククラウドサービススタックの領域で拡張するために、かなりの数のさまざまなサブプロジェクトとコンポーネントに成長しました。</font><font style="vertical-align: inherit;">さらに、OpenStackの重要性はおそらくこの部分で正確に評価する価値があります。これらのコンポーネントは、仮想化の分野とそれ以外の分野の両方で、多くの商用製品やシステムで重要になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアでは、パブリッククラウド外のOpenStackは、主にインポート置換における役割で主に知られています。</font><font style="vertical-align: inherit;">ハイパーコンバージドシステムを含む仮想化ソリューションと製品の大部分は、OpenStackによってパッケージ化されており、さまざまな改良が施されています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nutanix AHV</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nutanixは、当初からVMware vSphere専用の製品およびプラットフォームです。</font><font style="vertical-align: inherit;">しかし、VMwareとの関係における政治的危機のために、他のハイパーバイザーの提供を拡大したいという理由もあって、ボックス化されたプラットフォームを完成させ、サードパーティ製品を放棄できる独自のハイパーバイザーを開発することが決定されました。</font><font style="vertical-align: inherit;">KVMは、プラットフォーム内でAHV（Acropolis HyperVisor）と呼ばれる独自のハイパーバイザーとして選択されました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallels</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Virtuozzoのバージョン7では、同社は独自のハイパーバイザーからKVMに切り替えました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロキシモックス</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proxmox VE（仮想環境）は、オーストリアの会社であるProxmox Server Solutions GmbHのオープンソースプロジェクトで、Debian Linuxをベースとしています。</font><font style="vertical-align: inherit;">最初のリリースは2008年でした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この製品は、LXCコンテナー仮想化（以前のOpenVZ）、およびKVMハイパーバイザーによる完全仮想化をサポートしています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallels / Virtuozzo / Rosplatform</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SWsoftは1999年にSergey Belousovによって設立され、ホスティング管理ソフトウェアを採用しました。 2003年に、ノボシビルスクのライバル会社Pleskが買収されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SWsoftは2004年に、その製品Parallels Workstation（Windowsで2番目のタイプのデスクトップハイパーバイザー）を使用して、ロシアの会社Parallels Nikolai Dobrovolskyを買収しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
合併後の会社はParallelsという名前を保持しており、Parallels Desktop for Mac（MacOSの2番目のタイプのデスクトップハイパーバイザー）で市場を爆発的に拡大します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
サーバー仮想化の一部として、企業の使用ではなく、ホスティングプロバイダーとデータセンターに重点が置かれています。この市場の特性により、システム仮想マシンではなく、VirtuozzoおよびOpenVZコンテナが主要製品となりました。その後、Parallelsは大きな成功を収めることなく、Parallels Bare Metal Server製品（続いてParallels HypervisorとCloud Server、次にVirtuozzo）を使用してエンタープライズサーバー仮想化市場に参入しようとし、クラウドストレージにハイパーコンバージェンスを追加します。ホスティングプロバイダーの自動化とオーケストレーションの作業が続けられています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2015年には、サーバー仮想化製品に基づいて、Rosplatformプラットフォームプロジェクトが作成されました-技術的には（法的および組織的な問題を除いて）同じVirtuozzoを使用し、変更された壁紙とロシアのソフトウェアレジストリのみを使用します。</font><font style="vertical-align: inherit;">RosplatformプラットフォームソフトウェアとDepo機器に基づいて、IBSはScala-Rパッケージのハイパーコンバージドオファーを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バージョン7より前は、Virtuozzoは独自の設計のハイパーバイザを使用していましたが、バージョン7ではKVMへの移行が行われました。</font><font style="vertical-align: inherit;">したがって、RosplatformもKVMに基づいています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの合併、買収、ブランド変更を経て、次の構図は2019年までに形成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parallels DesktopはParallelsの子会社であり、Corelに販売されています。</font><font style="vertical-align: inherit;">すべての自動化はオーディンに行き、イングラムマイクロに売られました。</font><font style="vertical-align: inherit;">サーバーの仮想化は、Virtuozzo / Rosplatformプラットフォームブランドの下に残りました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja474760/index.html">Angularアプリケーションでngx-translateを固定します。実践的なウォークスルー</a></li>
<li><a href="../ja474762/index.html">ワークショップ：ビジネス向けのハイブリッドITソリューション。11月14日、モスクワ</a></li>
<li><a href="../ja474768/index.html">メインホールHighLoad ++ 2019の公開放送</a></li>
<li><a href="../ja474770/index.html">SAP HCMでの給与回帰テストの実施方法</a></li>
<li><a href="../ja474772/index.html">21日でAIを使用して治療法を開発したスタートアップ</a></li>
<li><a href="../ja474782/index.html">音声合成技術の概要</a></li>
<li><a href="../ja474784/index.html">アーケードスティックストーリー</a></li>
<li><a href="../ja474788/index.html">ララヴェルのルートの整理</a></li>
<li><a href="../ja474790/index.html">交渉人の物語</a></li>
<li><a href="../ja474792/index.html">12月6〜8日-Rosbank Tech.Madness Hackathon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>