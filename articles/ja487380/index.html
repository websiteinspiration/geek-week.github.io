<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💸 🔊 👊🏾 大規模なPostgreSQLクエリの最適化。キリル・ボロビコフ（テンソル） 🐻 👩🏼 👩‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このレポートでは、SQLクエリのパフォーマンスを1日あたり数百万におよび、数百の制御されたPostgreSQLサーバーがある場合に、SQLクエリのパフォーマンスを監視できるいくつかのアプローチを紹介しています。
 
 このような大量の情報を効率的に処理できるようにする技術的ソリューションと、それが通...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>大規模なPostgreSQLクエリの最適化。キリル・ボロビコフ（テンソル）</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/487380/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このレポートでは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、SQLクエリのパフォーマンスを1日あたり数百万に</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および、数百の制御されたPostgreSQLサーバー</font><b><font style="vertical-align: inherit;">がある場合に、SQLクエリのパフォーマンスを監視</font></b><font style="vertical-align: inherit;">できるいくつかのアプローチを紹介してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような大量の情報を効率的に処理できるようにする技術的ソリューションと、それが通常の開発者の生活を促進する方法。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/5XKbFb-l5Do" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQLクエリ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を最適化し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、PostgreSQLの一般的なDBA問題を解決する</font><b><font style="vertical-align: inherit;">ための特定の問題とさまざまな手法を分析することに</font></b><font style="vertical-align: inherit;"> 
興味があるのは誰</font><font style="vertical-align: inherit;">か？このトピック</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関する一連の記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">も</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">読む</font></a><font style="vertical-align: inherit;">こと</font><font style="vertical-align: inherit;">ができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/rj/lq/ao/rjlqaolzkdl1dwerrz6q1f41exs.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私の名前はキリルボロビコフです。私は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テンソル」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">会社</font></a><font style="vertical-align: inherit;">を代表してい</font><font style="vertical-align: inherit;">ます。具体的には、当社のデータベースの操作を専門としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今日は、単一のリクエストのパフォーマンスを「ピックアップ」する必要はないが、問題をまとめて解決する必要がある場合の、クエリの最適化の方法について説明します。何百万ものリクエストがあり、</font><font style="vertical-align: inherit;">この大きな問題</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を解決</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するためのいくつかの</font><b><font style="vertical-align: inherit;">アプローチを</font></b><font style="vertical-align: inherit;">見つける必要がある</font><font style="vertical-align: inherit;">場合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、100万人のお客様の「Tensor」は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VLSIです</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、社内ソーシャルネットワーク、ビデオ通信ソリューション、内部および外部のドキュメント管理、簿記および保管用の会計システムなどです。これは100以上の異なる内部プロジェクトです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが正常に機能し、正常に開発できるようにするために、全国に10か所の開発センターがあり、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000人以上の開発者がい</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは2008年からPostgreSQLを使用しており、処理するデータ（クライアントデータ、統計情報、分析データ、外部情報システムからのデータなど）を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">400 TBを超える量で蓄積してい</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。 「運用中」のサーバーは約250台で、監視対象のデータベースサーバーは合計で約1000台です</font></font><br>
<br>
<img src="https://habrastorage.org/webt/dx/sb/ej/dxsbejtgor4d4qc7u1cpkmxptx8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。SQLは宣言型言語です。何かが「どのように」機能するかではなく、受け取りたい「何」を説明します。 DBMSはJOINを作成する方法をよりよく理解しています-タブレットを接続する方法、課す条件、インデックスによるもの、そうでないもの...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のDBMSは、「いいえ、これらの2つのタブレットをそのようなキューに接続します」というヒントを受け入れますが、PostgreSQLはそうではありません。これは、主要な開発者の意識的な立場です。「開発者が何らかのヒントを使用できるようにするよりも、クエリオプティマイザを完成させるほうがよいでしょう。」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、PostgreSQLでは「外部」が自分自身を制御することを許可していないという事実にもかかわらず、</font><font style="vertical-align: inherit;">クエリを実行したときに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「内部」で何が発生</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、問題がある場所を</font><font style="vertical-align: inherit;">完全に</font><b><font style="vertical-align: inherit;">確認</font></b><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/k_/wc/q0/k_wcq0dayliwb4tturtbl3dmyre.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、開発者は通常どのような典型的な問題で[DBAに来る]のですか？ 「ここで私たちは要求を満たしました、そして</font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべてが遅く</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、すべてがハングし、何かが起こります...なんらかのトラブル！」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理由はほとんど同じです：</font></font><br>
<br>
<ul>
<li><b>  </b><br>
: «   SQL  10   JOIN...» —  ,       «»,     .    ,       (10    FROM)   - . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>]</li>
<li><b> </b><br>
     PostgreSQL,     «»  ,   —     «»  .       10 ,   10 ,  PostgreSQL      ,      . [<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="></a>]</li>
<li><b>«»  </b><br>
          ,     , ,   .  … -   ,       .</li>
<li><b></b><br>
 ,         (INSERT, UPDATE, DELETE) —    .</li>
</ul><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
...そして、他のすべてのために、私たち</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は計画が必要</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です！サーバー内部で何が起こっているかを確認する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/c8/ni/rt/c8nirti-tkun1t6z4sxgpnwfwbw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PostgreSQLのクエリ実行プランは、テキスト形式のクエリ実行アルゴリズムのツリーです。これは、計画担当者による分析の結果、最も効果的であると認識されたアルゴリズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各ツリーノードは操作です。テーブルまたはインデックスからのデータの抽出、ビットマップの作成、2つのテーブルの結合、結合、交差、またはサンプルの削除です。リクエストの実行は、このツリーのノードを通過します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クエリプランを取得するには、ステートメントを実行するのが最も簡単な方法です</font></font><code>EXPLAIN</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。すべての実際の属性を取得するには、つまり、実際に-に基づくクエリを実行します</font></font><code>EXPLAIN (ANALYZE, BUFFERS) SELECT ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悪い点：それを実行すると、「今ここ」で発生するため、ローカルデバッグのみに適しています。データの変化が激しいストリームの下にある高負荷のサーバーを使用すると、次のようになります。ここでは、</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xia</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の要求</font><font style="vertical-align: inherit;">が遅くなります</font><font style="vertical-align: inherit;">。」 30分、1時間前-実行してログからこのリクエストを取得し、サーバーに再度送信している間に、データセット全体と統計情報が変更されました。あなたはそれをデバッグするために実行します-そしてそれは速く走ります！なぜ、なぜ、そして、あなたは理解できない</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことだった</font></font></b></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅いです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y9/-t/fu/y9-tfu3qhvhayjt86xoy02qy4ju.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストがサーバーで実行されたときの正確な状況を理解するために、賢い人々は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">auto_explainモジュールを</font></a><font style="vertical-align: inherit;">書きました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは、ほとんどすべての最も一般的なPostgreSQLディストリビューションに存在し、設定ファイルでアクティブ化できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼があなたが言った境界よりも長く実行されているリクエストを理解している場合、彼は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このリクエストの計画の「スナップショット」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を取り、</font><b><font style="vertical-align: inherit;">それらをまとめてログに書き込みます</font></b><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/qh/cs/c1/qhcsc15sgsaruhdj6ghcjggfz7c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが順調に進んでいるようです。ログに移動してそこを確認します... [text footstep]。しかし、完了までに11ミリ秒を要したため、これは優れた計画であるという事実を除いて、彼については何も言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては問題ないようですが、実際に何が起こったのかは明確ではありません。合計時間に加えて、あまり表示されません。そのような「ラトゥハ」を見るのはプレーンテキストが一般に愛されているからです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、たとえ愛されていても、不快ではありますが、さらに大きな問題があります。</font></font><br>
<br>
<ul>
<li>   <b>    </b>  .     ,       Index Scan    — ,     -  .    ,    «»   , CTE —     « ».</li>
<li> : ,    , —  <b>   </b>.      , ,    ,  ,      loops —   .         .    ,  ,        ,      — - « ».</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような状況では、「最も弱いリンクは誰ですか」を理解してください。</font><font style="vertical-align: inherit;">ほとんど非現実的。</font><font style="vertical-align: inherit;">したがって、「マニュアル」の開発者自身も、「</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計画を理解することは、学ぶ、経験する必要がある芸術である</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」と書いて</font><i><font style="vertical-align: inherit;">います</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちは1000人の開発者を抱えており、それぞれがこの経験を頭に伝えません。</font><font style="vertical-align: inherit;">私、あなた、彼-彼らは知っています、そして向こうの誰か-はもうそこにはいません。</font><font style="vertical-align: inherit;">たぶん彼は学ぶかもしれないし、そうでないかもしれないが、彼は今働かなければならない-そしてどこでこの経験を得るか。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">視覚化の計画</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、これらの問題に対処するために</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、計画を適切に視覚化</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">する必要があることに気づきました</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[記事]</font></font></a><br>
<br>
<img src="https://habrastorage.org/webt/ev/nz/3g/evnz3gitzrva603ckfpd42ilzas.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私たちは最初に「市場の周り」に行きました-一般的に存在するものについてインターネットを見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、多かれ少なかれ開発された比較的「ライブ」のソリューションはほとんどないことが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">わかりました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -文字通り、一つのこと：</font><font style="vertical-align: inherit;">Hubert LubaczewskiのExplain.depesz.com。</font><font style="vertical-align: inherit;">フィールドの入り口に、計画のテキスト表現「feed」があり、解析されたデータを含むプレートが表示されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">適切なノード稼働時間</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブツリー全体の合計時間</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取得され、統計的に予想されたレコードの数</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ノード本体自体</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサービスには、リンクのアーカイブを共有する機能もあります。あなたはそこにあなたの計画を投げて言った：「ねえ、ヴァシャ、ここにあなたのためのリンクがあります、そこで何かが間違っています。」</font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/td/ik/odtdikeo22jwnlaxmizq2jodns0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、いくつかの小さな問題があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、大量のコピーと貼り付け。ログの一部を取り、そこに置き、何度も繰り返します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読み取られたデータの量の分析はありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -それが表示するバッファそのものであり</font></font><code>EXPLAIN (ANALYZE, BUFFERS)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ここではわかりません。彼は単にそれらを分解し、理解し、それらを扱う方法を知りません。大量のデータを読み取り、ディスクとメモリのキャッシュで誤って「分解」できることを理解している場合、この情報は非常に重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のマイナス点は、このプロジェクトの開発が非常に弱いことです。コミットは非常に小さく、6か月ごとに行うのが適切で、コードはPerlで記述されています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/d9/zu/o6/d9zuo6g5etaeqqdpfsozjtzv09c.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これはすべて「歌詞」であり、どういうわけかそれと共存することができますが、このサービスから私たちを遠ざけたのが1つあります。これらは、共通テーブル式（CTE）分析エラーと、InitPlan / SubPlanなどのさまざまな動的ノードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この図を信じると、各ノードの合計実行時間は、リクエスト全体の合計実行時間よりも大きくなります。簡単</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。このCTEの生成時間は、CTEスキャンノードから差し引かれていません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。したがって、正しい答えはわかりません。CTEスキャン自体にどれだけかかりましたか。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uj/gt/8a/ujgt8auhv331ek_visf6ew7jslq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それから、私たちは自分で書く時間だと気づきました-やったー！各開発者は言います：「今、私たちは自分で書くつもりです、それはただスーパーになるでしょう！」</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは典型的なWebサービススタックを採用しました。Node.js+ Expressのコア、Bootstrapのプル、そして美しい図のためのD3.jsです。</font><font style="vertical-align: inherit;">そして私たちの期待は正当化されました-私たちは2週間で最初のプロトタイプを受け取りました：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のプランパーサー</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
つまり、一般に、PostgreSQLによって生成されたプランから任意のプランを解析できます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的ノードの正しい分析</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -CTEスキャン、InitPlan、SubPlan</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファの分布の分析</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -メモリからデータのページが読み取られる場所、ローカルキャッシュから、ディスクから</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可視性を受け取った</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ので、「ログに記録されている」のではなく、「掘り下げている」のではなく、画像にすぐに「最も弱いリンク」が表示されています。</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/ou/gb/jf/ougbjf30wnktdmvhpqtjj6feqto.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこのようなものを得ました-構文の強調表示ですぐに。しかし、通常、私たちの開発者は、計画の完全なプレゼンテーションではなく、より短いもので作業しています。結局のところ、すべての桁を解析して左右に投げ、中央の最初の行だけを残しました。ノードの種類は、CTEスキャン、CTE、または何らかのタイプのラベルによるSeqスキャンです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この省略されたビューは、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プランテンプレート</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と呼ばれるもの</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zg/do/j_/zgdoj_caxmbjnyiq_gkiy0cfniw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他に何が便利でしょうか？合計時間のどのノードのどの割合が割り当てられているかを確認して、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">円グラフを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">横に「固定」すると便利</font><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードをポイントして見ると、Seq Scanが全体の4分の1未満の時間で済み、残りの3/4がCTE Scanであることがわかりました。ホラー！これは、CTEスキャンをクエリで積極的に使用する場合の、CTEスキャンの「発射速度」に関する小さな見解です。それらはそれほど高速ではありません-通常のテーブルスキャンにさえ負けます。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[記事] </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[記事]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
しかし、通常、このようなダイアグラムは、セグメントをすぐに指すと、より興味深く、より複雑になり、たとえば、常に半分以上のSeq Scanが「食べた」ことがわかります。さらに、中にはある種のフィルターがあり、大量のレコードがドロップされていました...この写真を開発者に直接投げて、次のように言うことができます。わかりました、見てください-何かが間違っています！」</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ul/4i/2q/ul4i2q_4iasvokxfdcwp7jd9tj0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、「熊手」がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らが最初に「踏み出した」のは、丸めの問題です。計画の各個人のノード時間は、1μsの精度で示されます。そして、ノードサイクルの数がたとえば1000を超えると、PostgreSQLはそれを「最大」に分割した後、逆の計算で「0.95ミリ秒から1.05ミリ秒の間」の合計時間を取得します。アカウントがマイクロ秒単位で費やされる場合-まだ何もしていませんが、すでに[ミリ]秒の間-「誰がどれだけ消費したか」のノード上のリソースを「アンタイト」するときにこの情報を考慮する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fp/ds/f9/fpdsf9qkt6t_0q810uqhmrivc-k.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のポイント、より複雑なのは、動的ノード間でのリソースの分散（同じバッファー）です。これにより、プロトタイプの最初の2週間と第4週のプラスがかかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を取得するのは非常に簡単です。CTEを作成し、その中の何かを読んでいると思われます。実際、PostgreSQLは賢く、そこには何も読み込まれません。次に、最初のレコードをそこから取得し、最初の100件を同じCTEから取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s5/fv/rg/s5fvrgut9bky4uqjgmawpm97ks4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは計画を見て理解します-奇妙なことに、Seq Scanで「消費」された3つのバッファー（データページ）があり、CTEスキャンでもう1つ、2番目のCTEスキャンでさらに2つあります。つまり、すべてを単純に合計すると6になりますが、プレートからは3しか読み取れません。 CTEスキャンはどこからも何も読み取りませんが、プロセスメモリを直接操作します。つまり、明らかに何かが間違っています！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、ここでは、Seq Scanから要求されたこれらの3ページのデータすべてが、最初の1つが最初のCTEスキャンを要求し、次に2番目が要求し、さらに2つを読み取ったことがわかります。つまり、合計3ページが読み取られました。データではなく6。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3q/5q/nh/3q5qnhygdtg3fh1os2fa-1kixhg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてこの写真から、計画の実装はもはやツリーではなく、ある種の非循環グラフであることがわかりました。</font><font style="vertical-align: inherit;">そして、「どこから来たのか」を理解できるように、このようなグラフを入手しました。</font><font style="vertical-align: inherit;">つまり、ここではpg_classからCTEを作成し、それを2回要求しました。2回目に要求したときに、ほとんどの場合、ブランチを使用しました。</font><font style="vertical-align: inherit;">101番目のレコードの読み取りは、タブレットの最初のレコードよりもはるかにコストがかかることは明らかです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yg/kx/3o/ygkx3o3reytihnn6mkhyys3j7l8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらく息を吐きました。</font><font style="vertical-align: inherit;">彼らは言った：「今、ネオ、あなたはカンフーを知っています！</font><font style="vertical-align: inherit;">今、私たちの経験はあなたの画面上にあります。</font><font style="vertical-align: inherit;">これで使用できます。」</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[論文]</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ログの統合</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの1000人の開発者は、安堵のため息をつきました。しかし、私たちは数百の「戦闘」サーバーしかないことを理解しており、開発者によるこのすべての「コピーアンドペースト」はまったく便利ではありません。自分で集める必要があることに気づきました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jl/1t/od/jl1todhk17wci0h_ekudinbrruw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、統計を収集できる通常のモジュールがありますが、構成でアクティブ化する必要もあり</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">はpg_stat_statementsモジュールです</font></a><font style="vertical-align: inherit;">。しかし、彼は私たちに合わなかった。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、同じデータベース内の異なるスキームの同じクエリに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">異なるQueryId</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を割り当てます</font><font style="vertical-align: inherit;">。つまり、最初にを実行し</font></font><code>SET search_path = '01'; SELECT * FROM user LIMIT 1;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、次に</font></font><code>SET search_path = '02';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同じ要求を行うと、このモジュールの統計には異なるエントリが含まれ、スキームを考慮しないと、この要求プロファイルのコンテキストで一般的な統計を正確に収集できなくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちがそれを使用できなかった2番目の点は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">計画</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><b><font style="vertical-align: inherit;">欠如です</font></b><font style="vertical-align: inherit;">。つまり、計画はなく、リクエスト自体だけです。何が減速していたのかはわかりますが、その理由はわかりません。そしてここで、急速に変化するデータセットの問題に戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後のポイントは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「事実」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><b><font style="vertical-align: inherit;">欠如です</font></b><font style="vertical-align: inherit;">。つまり、クエリ実行の特定のインスタンスに対処することは不可能です。そこにはありません。集計された統計しかありません。それを使用することは可能ですが、それは非常に困難です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7x/sr/ij/7xsrijw56i20-dz5oiw0hurx9aq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、私たちは「コピー・ペースト」と戦うことを決定し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コレクター</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を書き始めました</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コレクターはSSHを介して接続され、証明書を使用してデータベースとサーバーへの安全な接続を「プル」</font></font><code>tail -F</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">し、ログファイルに</font><font style="vertical-align: inherit;">「固定</font><font style="vertical-align: inherit;">」します。このセッションでは</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーバーが生成する</font><b><font style="vertical-align: inherit;">ログファイル全体の完全な「ミラー」を取得</font></b><font style="vertical-align: inherit;">します。サーバー自体の負荷は最小限です。そこでは何も解析しないため、トラフィックをミラーリングするだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでにNode.jsでインターフェースの作成を開始しているため、引き続きコレクターを作成します。また、JavaScriptを使用してフォーマットが不十分なテキストデータ（ログ）を操作するのは非常に便利であるため、このテクノロジーは成果を上げています。また、バックエンドプラットフォームとしてのNode.jsインフラストラクチャ自体を使用すると、ネットワーク接続を簡単かつ便利に操作でき、実際にある種のデータストリームを使用できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、2つの接続を「プル」します。1つ目はログ自体を「リッスン」してそれを自分で取得することであり、2つ目は定期的にデータベースに問い合わせることです。 「しかし、ログにはOID 123のプレートがブロックされていることがわかりましたが、開発者には何も言われていません。データベースに「OID = 123とは何ですか？」と尋ねるとよいでしょう。そのため、私たちは定期的に、まだ自宅ではわからないことをベースに求めています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/vi/ft/gtviftgv1xepi43a7dayhn5-kxy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「あなたは考慮に入れなかっただけで、象のような蜂がいるのです！..」10台のサーバーを監視したいと思ったときに、このシステムの開発を開始しました。理解する上で最も重要であり、対処が困難な問題がいくつかありました。しかし、第1四半期には、監視のために100名を獲得しました。システムが「入った」ため、誰もがそれを望み、誰もが快適でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてを追加する必要があります。データストリームは大きく、アクティブです。実際、私たちは何を処理できるかを監視し、それを使用します。データウェアハウスとしてPostgreSQLも使用しています。しかし、</font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まだ</font><font style="vertical-align: inherit;">オペレーターが</font><font style="vertical-align: inherit;">いない</font><font style="vertical-align: inherit;">ほど、データを「注ぐ」のに最も速い方法は</font><font style="vertical-align: inherit;">ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、データを「注ぐ」だけでは、実際には私たちのテクノロジーではありません。 100台のサーバーで1秒あたり約5万のリクエストがある場合、1日あたり100〜150 GBのログが生成されるためです。そのため、ベースを注意深く「見」なければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、私たちは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毎日</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><b><font style="vertical-align: inherit;">パーティショニング</font></b><font style="vertical-align: inherit;">を行いました</font><font style="vertical-align: inherit;">。なぜなら、概して、誰も日の間の相関関係に興味がないからです。あなたが昨日持っていた違いは何ですか、今夜あなたがアプリケーションの新しいバージョンをロールアウトした場合-そしてすでにいくつかの新しい統計。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、を</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して非常に迅速に書く</font></font><code>COPY</code></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことを学びました（強制されました）</font><font style="vertical-align: inherit;">。つまり、</font></font><code>COPY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはよりも速いだけ</font></font><code>INSERT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でなく、さらに速いからです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rm/ik/nj/rmiknjdu2ydi-yrbk7v369qe8eu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3番目のポイント-私は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それぞれトリガーを、そして外部キーから放棄し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なけれ</font><b><font style="vertical-align: inherit;">ばなり</font></b><font style="vertical-align: inherit;">ませんでし</font><b><font style="vertical-align: inherit;">た</font></b><font style="vertical-align: inherit;">。つまり、絶対的な参照整合性はありません。 FKのペアがあるテーブルがあり、データベース構造で「ログエントリはFKを参照している、たとえば、レコードのグループである」と言う場合、テーブルを挿入すると、PostgreSQLは何もしません。</font></font><code>SELECT 1 FROM master_fk1_table WHERE ...</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">挿入しようとしている識別子</font><font style="vertical-align: inherit;">を取得して正直に実行する方法</font><font style="vertical-align: inherit;">-このエントリが存在することを確認するために、挿入でこの外部キーを「分割」していないことを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ターゲットテーブルとそのインデックスの1つのレコードの代わりに、それが参照するすべてのテーブルからの読み取りが追加されます。そして、それはまったく必要ありません。私たちの仕事は、できるだけ少ない負荷で、できるだけ多く、できるだけ早く書き留めることです。だからFK-ダウン！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のポイントは、集約とハッシュです。当初、これらはデータベースに実装されていました。結局のところ、レコーディングが到着したら</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すぐに、トリガー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内のある種類のプレートで</font><b><font style="vertical-align: inherit;">「プラス1」を</font></b><font style="vertical-align: inherit;">作成すると便利</font><font style="vertical-align: inherit;">です。これは便利ですが、同じことは悪いことです。1つのレコードを挿入しますが、別のテーブルから何かを読み書きする必要があります。さらに、それだけでなく、読み取りと書き込みを行い、毎回それを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、特定のホストで渡されたリクエストの数を単純に数えるプレートがあると想像してください。</font></font><code>+1, +1, +1, ..., +1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。そして、原則として、あなたはそれを必要としません-これらすべて</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コレクターのメモリに合計さ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ、一度にデータベースに送信されます</font></font><code>+10</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、いくつかの誤動作が発生した場合、論理的整合性が「バラバラ」になる可能性がありますが、これはほとんど非現実的なケースです-通常のサーバーがあり、コントローラーにバッテリーがあり、トランザクションログ、ファイルシステムのログがあります...一般的には、価値がある。トリガー/ FKの作業、同時に発生するコストが原因で生じる生産性の損失は価値がありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハッシュについても同じことが言えます。特定のリクエストがあなたに飛んでいき、そこからデータベースから特定の識別子を計算し、データベースに書き込み、それを全員に伝えます。すべてが順調です。録音するときに、それを録音したい2人目の人物があなたのところにやって来るまで、そしてあなたはロックをかけていて、これはすでに悪い状態です。したがって、クライアントで（データベースに対して）一部のIDの生成を削除できる場合は、これを行うことをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエスト、プラン、テンプレートなど、テキストからMD5を使用するのに最適でした。コレクター側で計算し、既製のIDをデータベースに「注ぎ込み」ます。 MD5の長さと毎日のパーティション分割により、衝突の可能性を心配する必要がなくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3c/yz/uz/3cyzuzpcxxmshllydd9cjcclc9i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらすべてをすばやく録音するには、録音手順自体を変更する必要がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、どのようにデータを書き込みますか？ある種のデータセットがあり、それをいくつかのテーブルに分解してからコピーします-最初に最初に、次に2番目、3番目に... 1つのデータストリームを3つのステップで順番に書き込むため、これは不便です。不快。より速くすることは可能ですか？できる！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、これらのフローを互いに並行して分解するだけで十分です。エラー、リクエスト、テンプレート、ロック、別々のストリームでの飛行などがあり、すべてを並行して書き込みます。これを行うには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">個々のターゲットテーブルでCOPYチャネルを永続的に開いたままにします</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/v_/0z/vvv_0zw3lqqoqoznvaaqpvm19wq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、コレクターには</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常にストリームがあります。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必要なデータをそこに書き込むことができます。しかし、データベースがこのデータを認識し、誰かがロックでハングしてこのデータが書き込まれるのを待機しないようにするには、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COPYを特定の頻度で中断する必要があります</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。私たちにとって、100msのオーダーの期間が最も効果的であることがわかりました-同じテーブルで閉じてすぐに再び開きます。そして、いくつかのピークで1つのストリームがない場合は、特定の制限までプールします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、このような負荷プロファイルでは、レコードがパケットに収集されるときの集約は悪であることもわかりました。古典的な悪は</font></font><code>INSERT ... VALUES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000レコードを超えています。この時点で、あなたはメディアにピークのレコーディングを持っているので、ディスクに何かを書き込もうとしている他の誰もが待つでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような異常を取り除くには、単に何も集約せず、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まったくバッファリングしない</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><b><font style="vertical-align: inherit;">ください</font></b><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">そして、ディスクへのバッファリングが発生した場合（幸いなことに、Node.jsのStream APIで確認できます）-この接続を延期します。</font><font style="vertical-align: inherit;">それがイベントがあなたに来るとき、それは再び自由です-蓄積されたキューからそれに書き込みます。</font><font style="vertical-align: inherit;">それまでの間、ビジー状態です。次の空きプールをプールから取り出して書き込みます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータ記録へのアプローチを実装する前は、約4Kの書き込み操作があり、この方法で負荷を4分の1に削減しました。</font><font style="vertical-align: inherit;">現在、新しい観測可能なベースにより、最大6倍の100MB /秒を達成しています。</font><font style="vertical-align: inherit;">そして今、私たちは過去3か月のログを約10〜15 TBの量で保存し、わずか3か月ですべての開発者が問題を解決できることを期待しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは問題を理解しています</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、このすべてのデータを収集するだけで十分であり、有用で適切ですが、十分ではありません。理解する必要があります。</font><font style="vertical-align: inherit;">1日あたり数百万もの異なる計画があるからです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j6/kw/jg/j6kwjgsvci1xw-p_vgxpnq6ynag.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、数百万は制御不能なため、まず「少ない」ことを実行する必要があります。</font><font style="vertical-align: inherit;">そして、まず、この「小さい」ものをどのように整理するかを決定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは自分たちのために3つの重要なポイントを特定しました：</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がこのリクエスト</font><b><font style="vertical-align: inherit;">を</font></b><font style="vertical-align: inherit;">送信したか、</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、どのアプリケーションから彼が「飛んだ」か：ウェブインターフェース、バックエンド、支払いシステムなど。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはどこの</font></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
特定のサーバーで</font><font style="vertical-align: inherit;">発生しましたか</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1つのアプリケーションの下に複数のサーバーがあり、1つが突然「鈍化」した場合（「ディスクが破損した」、「メモリリーク」、その他の問題が原因）、サーバーに具体的に対処する必要があるためです。</font></font></li>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題が何らかの形で</font><b><font style="vertical-align: inherit;">どのように</font></b><font style="vertical-align: inherit;">現れた</font><b><font style="vertical-align: inherit;">か</font></b></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「だれが」リクエストを送信したかを理解するために、通常のツールを使用して-セッション変数を設定します。- </font></font><code>SET application_name = '{bl-host}:{bl-method}';</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リクエスト元のビジネスロジックのホスト名と、リクエストを開始したメソッドまたはアプリケーションの名前を送信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リクエストの「所有者」を渡した後、それをログに表示する必要があります</font></font><code>log_line_prefix = ' %m [%p:%v] [%d] %r %a'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このために変数を構成します</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">興味のある人なら誰でも</font><font style="vertical-align: inherit;">これが何を意味するのかを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マニュアルで見る</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ことができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ログに表示されることがわかります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時間</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロセスおよびトランザクション識別子</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ベース名</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このリクエストを送信した人のIP</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">およびメソッド名</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/9d/ms/_c/9dms_cgsmfbpgjiyndalqfyadf8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、異なるサーバー間の1つの要求の相関関係を確認することはあまり面白くないことに気づきました。あちこちで平等にクラップする1つのアプリケーションがある場合、まれに発生します。ただし、同じであっても、これらのサーバーのいずれかを確認します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「1台のサーバー-1日」セクション</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、どの分析にも十分であることがわかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の分析セクションは、まさに</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「テンプレート」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">であり、すべての数値インジケーターを取り除いた、計画の省略形のプレゼンテーションです。 2番目のセクションはアプリケーションまたはメソッドで、3番目のセクションは問題を引き起こした計画の特定のノードです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のインスタンスからテンプレートに移行すると、すぐに2つの利点が得られました。</font></font><br>
<br>
<ul>
<li><b>     </b><br>
         ,    .</li>
<li><b></b><br>
 ,  «»   - ,       .     ,     -  , ,   ,    —   ,  ,     —     , ,      .    ,  ,  .</li>
</ul><br>
<br>
<img src="https://habrastorage.org/webt/_1/gb/is/_1gbissbzxhnibnhpb5kb5ebuuu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残りの方法は、計画から抽出したインジケーターに基づいています。そのようなテンプレートが発生した回数、合計時間と平均時間、ディスクから読み取られたデータの量、およびメモリからの量... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ホストごとに分析ページ</font><font style="vertical-align: inherit;">にアクセスしている</font><font style="vertical-align: inherit;">ため、次を参照してください-ディスクに何かが多すぎて最初を読み込めません。サーバー上のディスクは対応していません-そして誰がそれから読み取りますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、任意の列で並べ替えて、現在処理するものを決定できます-プロセッサまたはディスクの負荷、またはリクエストの総数...並べ替え、「上位」に表示、修復-アプリケーションの新しいバージョンをロールアウトします。</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ビデオ講義]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
そして、あなたはすぐに同じテンプレートに付属する異なるアプリケーションを次のようなリクエストから見ることができます</font></font><code>SELECT * FROM users WHERE login = 'Vasya'</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。フロントエンド、バックエンド、処理...そして、ユーザーが操作しないのになぜユーザーが処理を読む必要があるのか​​疑問に思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逆の方法は、アプリケーションから何をしているのかを即座に確認することです。たとえば、フロントエンドはこれ、これ、これ、これは1時間に1回です（タイムラインだけが役立ちます）。そしてすぐに問題が発生します。1時間に1回何かを行うのはフロントエンドの仕事ではないようです... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z7/z-/4n/z7z-4nvcqjd8xktjpl1ilja63eo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しばらくして</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、計画ノードの観点から</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計された</font><b><font style="vertical-align: inherit;">統計が</font></b><font style="vertical-align: inherit;">ないことに気付きました</font><font style="vertical-align: inherit;">。テーブル自体のデータで何かを実行するノードのみをプランから分離しました（インデックスによって読み取りまたは書き込みを行うかどうか）。実際、前の図と比較して、1つの側面のみが追加され</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。このノードが持ってきたレコードの数と、ノードが</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除した数（フィルターによって削除された行）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたはプレートに適切なインデックスを持っていません、あなたはそれに要求を出します、それはインデックスを通り過ぎて、Seqスキャンに落ちます...あなたは1つを除いてすべてのレコードを除外しました。そして、なぜ1日に100Mのフィルター処理されたレコードが必要なのですか？</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tk/bw/j9/tkbwj9b2v1gmeifbmblipiya86q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ノードごとにすべての計画を調べたところ、疑わしいと思われる可能性が高いいくつかの典型的な構造が計画にあることがわかりました。そして、開発者に言っておくとよいでしょう。「フレンド、ここでは最初にインデックスで読み取り、次にソートしてからカットします」-通常、レコードは1つです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンでクエリを書いた人はおそらく出くわすでしょう。「Vasyaの最後の注文、彼の日付を教えて」日付によるインデックスがない場合、または使用されているインデックスに日付がない場合は、そのような「レーキ」に正確に進んでください。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これは「レーキ」であることはわかっています。開発者に何をすべきかをすぐに伝えないでください。</font><font style="vertical-align: inherit;">したがって、今すぐプランを開くと、開発者はすぐにプロンプ​​トの付いた美しい画像を見て、すぐに「こことここに問題がありますが、この方法で解決されます」と言われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、当初は問題を解決するために必要であった経験の量が大幅に減少しました。</font><font style="vertical-align: inherit;">ここにそのようなツールがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/1g/g6/si1gg6ffbtpgsb3q2ew_cgudqa4.jpeg"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja487370/index.html">msgr.ruのデータに基づく不動産市場分析</a></li>
<li><a href="../ja487372/index.html">IBMデータサイエンスプロフェッショナル認定を取得</a></li>
<li><a href="../ja487374/index.html">ポール・グラハム：流行の問題</a></li>
<li><a href="../ja487376/index.html">あなたが見逃した10の便利なAngular機能</a></li>
<li><a href="../ja487378/index.html">2020年のベストスモールビジネスサーバー</a></li>
<li><a href="../ja487384/index.html">職業：フロントエンド開発者</a></li>
<li><a href="../ja487386/index.html">ソフトエントリーツールとしての適応チェックリスト</a></li>
<li><a href="../ja487388/index.html">自然な発展：eラーニングからナレッジマネジメントに移行する方法</a></li>
<li><a href="../ja487390/index.html">Shadow DOMのないWebコンポーネント</a></li>
<li><a href="../ja487392/index.html">マグネットは顧客について何を知りたいですか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>