<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛎️ 👃🏽 🎋 Répéter l'analyse de cohorte Power BI à l'aide de Python 👩🏻‍⚖️ 👨🏿‍⚖️ 🙉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, chers lecteurs! La raison de la rédaction de cette publication était un webinaire que j'ai consulté sur Youtube. Il s'est consacré à une anal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Répéter l'analyse de cohorte Power BI à l'aide de Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501492/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour, chers lecteurs! </font><font style="vertical-align: inherit;">La raison de la rédaction de cette publication était un webinaire que j'ai consulté sur Youtube. </font><font style="vertical-align: inherit;">Il s'est consacré à une analyse de cohorte des ventes. </font><font style="vertical-align: inherit;">L'auteur a utilisé la plateforme Power BI Desktop pour travailler avec des données. </font><font style="vertical-align: inherit;">Je ne fournirai pas de lien vers la vidéo spécifiée afin que cet article ne soit pas considéré comme une publicité, mais au cours de la narration j'essaierai de faire des spoilers à la source d'origine afin de mieux expliquer la logique de ma propre décision. </font><font style="vertical-align: inherit;">Ce webinaire m'a donné l'idée qu'il serait intéressant de répéter les possibilités des formules DAX avec les fonctions de la bibliothèque Pandas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux points sur lesquels je veux me concentrer. Premièrement, ce matériel est destiné aux analystes débutants qui font leurs premiers pas dans l'utilisation du langage de programmation Python. Idéal si les lecteurs connaissent la plate-forme d'analyse Power BI BI. Deuxièmement, étant donné que les calculs DAX ont servi de source d’inspiration, je vais «copier» les algorithmes de l’auteur dans la mesure du possible, et il y aura inévitablement un écart par rapport aux principaux paradigmes de programmation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec l'introduction, c'est tout. Prenons la route!</font></font><br>
<br>
<a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous effectuerons tous les calculs dans l'environnement JupyterLab. Les solutions pour ordinateur portable sont disponibles sur ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lien</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les données sont chargées dans Power BI à l'aide de l'outil Power Query (en fait, c'est un éditeur visuel qui génère des requêtes dans le langage M). La règle suivante doit être suivie pendant le développement: tout le prétraitement des données doit être effectué à l'aide de Power Query et les mesures doivent être calculées à l'aide de Power Pivot. Puisque notre bibliothèque principale est Pandas, nous utilisons immédiatement ses capacités.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   </span>
path_to_data = <span class="hljs-string">"C:/Users/Pavel/Documents/Demo/"</span>
<span class="hljs-comment"># </span>
df = pd.read_csv(os.path.join(path_to_data, <span class="hljs-string">"ohortAnalysis_2016_2018.csv"</span>), sep=<span class="hljs-string">";"</span>, parse_dates=[<span class="hljs-string">"date"</span>], dayfirst=<span class="hljs-literal">True</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous testerons les lignes de code lors de l'exécution afin d'établir les sections les plus chronophages à l'avenir. Pour définir le chemin d'accès complet au fichier lu, utilisez la bibliothèque os. Pour simplifier le processus de développement d'un ordinateur portable, vous pouvez vous en passer. L'ensemble de données lui-même est composé de manière aléatoire. Il y a 1 048 575 lignes dans le fichier CSV. La lecture de données avec la fonction read_csv () est généralement simple. Il suffit de spécifier le séparateur de colonnes et la colonne avec les dates, le cas échéant, dans le tableau. Si les informations ont été téléchargées avec certaines "fonctionnalités", vous devrez peut-être configurer des paramètres supplémentaires, par exemple, en spécifiant l'encodage pour chaque colonne.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction head () sera souvent utilisée dans le cas pour surveiller visuellement la progression de la transformation des données. Toutes les erreurs ne peuvent pas être supprimées, mais des défauts évidents peuvent être corrigés sur place. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir chargé les données dans le modèle, l'auteur du webinaire trie le tableau de données. Ceci est fait afin d'ajouter une colonne auxiliaire avec des index. Dans notre cas, cette colonne ne sera pas utilisée, mais les données seront également triées afin de contrôler plus facilement le calcul correct des champs dans les tableaux.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  ,      </span>
df.sort_values([<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"date"</span>], inplace = <span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/t7/ek/x9/t7ekx9mfwh5z7cahruxyrvlvetq.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'étape suivante, la solution sur la plateforme Power BI propose de créer une table auxiliaire, dont les données seront extraites dans le tableau principal. La création d'une table se fait à l'aide de la fonction SUMMARIZE (). Il crée un tableau </font></font><code> df_groupby_user = SUMMARIZE(df;df[user_id];"first_date_transaction";MIN(df[date]);"total_amount_user";SUM(df[amount]);"count_transaction_user";COUNT(df[amount]))</code><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
croisé dynamique </font><font style="vertical-align: inherit;">avec des totaux agrégés pour les groupes sélectionnés: </font><font style="vertical-align: inherit;">La bibliothèque Pandas a son homologue - la fonction groupby (). Pour appliquer groupby (), il suffit de spécifier le bloc de données nécessaire, les colonnes groupables, à la fin de la liste les colonnes pour lesquelles les fonctions d'agrégation seront utilisées. Le résultat obtenu est réduit au format de la trame de données habituelle par la fonction reset_index (). En conclusion, renommez les champs.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#       user_id. </span>
df_groupby_user = df.groupby(by = [<span class="hljs-string">"user_id"</span>]).agg({<span class="hljs-string">"date"</span>: <span class="hljs-string">"min"</span>, <span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>,<span class="hljs-string">"count"</span>]})<font></font>
df_groupby_user.reset_index(inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment"># </span>
new_columns = [<span class="hljs-string">"user_id"</span>,<span class="hljs-string">"first_date_transaction"</span>, <span class="hljs-string">"total_amount_user"</span>,<span class="hljs-string">"count_transaction_user"</span>]<font></font>
df_groupby_user.columns = new_columns</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus de la mesure «première date d'achat», le nombre de transactions par client et le montant total des achats des clients pour toute la période sont calculés. Les mesures n'ont pas trouvé leur application dans l'ordinateur portable, mais nous ne les supprimerons pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous revenons au webinaire. La nouvelle mesure "année-mois du premier achat" est calculée. Formule DAX: </font></font><code> first_transaction = FORMAT(df_groupby_user[first_date_transaction];"YYYY-MM")</code><br>
<br>
<img src="https://habrastorage.org/webt/4l/3n/xo/4l3nxosdn2pddiqx3pffvtrniec.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python utilise la syntaxe dt.strftime ('% Y-% m'). Vous trouverez une explication détaillée de son fonctionnement dans les publications en ligne concernant l'utilisation de la date et de l'heure en Python. À ce stade, autre chose est important. Faites attention au moment de l'opération. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas du tout des performances de type pandas (24,8 sec.). La ligne de code est plus lente que toutes les précédentes. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette fiche devient le premier candidat à une éventuelle refactorisation.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  -</span>
df_groupby_user[<span class="hljs-string">"first_transaction"</span>] = df_groupby_user[<span class="hljs-string">"first_date_transaction"</span>].dt.strftime(<span class="hljs-string">'%Y-%m'</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de revenir au webinaire. </font><font style="vertical-align: inherit;">Il y a une union de tables par un champ clé. </font><font style="vertical-align: inherit;">Ensuite, les champs nécessaires sont tirés dans la table principale à l'aide de la fonction RELATED (). </font><font style="vertical-align: inherit;">Pandas n'a pas cette fonctionnalité. </font><font style="vertical-align: inherit;">Mais il y a merge (), join (), concat (). </font><font style="vertical-align: inherit;">Dans ce cas, il est préférable d'appliquer la première option.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment"># </span>
df_final = pd.merge(df, df_groupby_user, how = <span class="hljs-string">"left"</span>, on = <span class="hljs-string">"user_id"</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois que les données avec la date de la première transaction sont tombées dans le tableau principal, vous pouvez calculer le delta. </font><font style="vertical-align: inherit;">Nous utilisons la construction apply (lambda x: ...) pour montrer clairement à quel point ce processus est gourmand en ressources (39,7 sec.). </font><font style="vertical-align: inherit;">Voici un autre candidat pour la réécriture de code.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#   "    "</span>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"date"</span>] - df_final[<span class="hljs-string">"first_date_transaction"</span>]<font></font>
df_final[<span class="hljs-string">"delta_days"</span>] = df_final[<span class="hljs-string">"delta_days"</span>].apply(<span class="hljs-keyword">lambda</span> x: x.days)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La table principale a déjà un delta par jour, vous pouvez donc diviser les données de la colonne en cohortes. Principe: 0 (c'est-à-dire la première vente au client) - cohorte 0; les valeurs supérieures à 0, mais inférieures ou égales à 30 sont 30; les valeurs supérieures à 30, mais inférieures ou égales à 90 sont 90, etc. À ces fins, dans DAX, vous pouvez utiliser la fonction CEILING (). Il arrondit le nombre à l'entier le plus proche, un multiple de la valeur du deuxième paramètre.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/mu/rh/sdmurhtsdqarznw92jwbklpvjvs.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En Python, je n'ai pas trouvé de fonction mathématique similaire, même si j'avais prévu de la trouver dans le module mathématique (j'ai peut-être mal cherché). Par conséquent, j'ai dû faire le tour et appliquer la fonction cut (). Après avoir réparti les données en cohortes, NaN a été mappé à des valeurs numériques de 0. Nous ne pouvons pas résoudre ce problème en utilisant la fonction fillna (), car nous avons affaire à des données catégorielles. Vous devez d'abord ajouter une nouvelle valeur à la catégorie. À la fin de cette liste de codes, changez le type de données en int. Ceci est fait de sorte qu'à l'avenir, lors de la construction d'un tableau croisé dynamique à l'aide d'un bloc de données, la nouvelle cohorte n'apparaisse pas à la fin d'une série de valeurs.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  . </span>
cut_labels_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">30</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
cut_bins_days = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range (<span class="hljs-number">0</span>, <span class="hljs-number">1230</span>, <span class="hljs-number">30</span>)]<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>] = pd.cut(df_final[<span class="hljs-string">"delta_days"</span>], bins = cut_bins_days, labels=cut_labels_days, right = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)<font></font>
%%time<font></font>
<span class="hljs-comment">#     .   fillna   !</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].cat.add_categories([<span class="hljs-number">0</span>])<font></font>
df_final[<span class="hljs-string">"cohort_days"</span>].fillna(<span class="hljs-number">0</span>, inplace = <span class="hljs-literal">True</span>)
<span class="hljs-comment">#    .    ,  "0"        ,     </span>
<span class="hljs-comment">#    .</span>
df_final[<span class="hljs-string">"cohort_days"</span>] = df_final[<span class="hljs-string">"cohort_days"</span>].astype(int)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant la fonction pivot_table (), nous obtenons le tableau croisé dynamique souhaité. Nous obtenons beaucoup de cohortes, donc le résultat ne peut pas être complètement affiché à l'écran. Pour éviter cela, lors de la résolution d'un cas réel, vous pouvez prendre un intervalle de temps plus court pour l'analyse ou agrandir les plages de valeurs des cohortes elles-mêmes.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#  </span>
df_pivot_table = pd.pivot_table(df_final, values=[<span class="hljs-string">"amount"</span>], index=[<span class="hljs-string">"first_transaction"</span>], columns=[<span class="hljs-string">"cohort_days"</span>], aggfunc=np.sum, fill_value = <span class="hljs-number">0</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/e2/dn/u-/e2dnu-fry4n2hd4fl7_coqm_5mo.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans Power BI, vous devez utiliser l'outil Matrix pour créer une telle visualisation. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sx/qh/gh/sxqhghd3km7lwdo-aycsry8xnn4.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prochaine étape consiste à comploter. La nuance de la situation est que nous avons besoin du montant selon la comptabilité d'exercice. Dans Power BI, sélectionnez simplement l'élément de menu «Action rapide» requis et la formule DAX nécessaire sera automatiquement générée. Avec la bibliothèque Pandas, la situation est un peu plus compliquée. Nous groupons de manière séquentielle la trame de données existante et appliquons la fonction cumsum (). Puisque le résultat sera toujours utilisé, nous allons faire une copie du bloc de données pour construire le graphique. Les valeurs des ventes cumulées étaient assez importantes, nous divisons donc les valeurs par 1 000 000 et arrondissons le résultat à deux chiffres après la virgule décimale.</font></font><br>
<br>
<pre><code class="python hljs">%%time
<span class="hljs-comment">#     amount</span>
df_pivot_table_cumsum = df_final.groupby(by = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>]).agg({<span class="hljs-string">"amount"</span>: [<span class="hljs-string">"sum"</span>]}).groupby(level=<span class="hljs-number">0</span>).cumsum().reset_index()<font></font>
df_pivot_table_cumsum.columns = [<span class="hljs-string">"first_transaction"</span>,<span class="hljs-string">"cohort_days"</span>,<span class="hljs-string">"cumsum_amount"</span>]<font></font>
%%time<font></font>
<span class="hljs-comment">#     </span><font></font>
df_pivot_table_cumsum_chart = copy.deepcopy(df_pivot_table_cumsum)<font></font>
<span class="hljs-comment">#     ,       Y.</span>
df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]=round(df_pivot_table_cumsum_chart[<span class="hljs-string">"cumsum_amount"</span>]/<span class="hljs-number">1000000</span>, <span class="hljs-number">2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utilisons les capacités de la bibliothèque pour construire le graphique. Un diagramme est construit en une seule ligne de code, mais le résultat n'est pas impressionnant. Ce graphique perd clairement aux visualisations sur n'importe quelle plateforme de BI. Vous pouvez connecter la bibliothèque Plotly et évoquer des modules complémentaires, mais cela représente des coûts de main-d'œuvre complètement différents par rapport à l'approche présentée dans la vidéo.</font></font><br>
<br>
<pre><code class="python hljs">%%time<font></font>
df_pivot_table_cumsum_chart.pivot(index=<span class="hljs-string">"cohort_days"</span>, columns=<span class="hljs-string">"first_transaction"</span>, values=<span class="hljs-string">"cumsum_amount"</span>).plot(figsize = (<span class="hljs-number">15</span>,<span class="hljs-number">11</span>))</code></pre><br>
<img src="https://habrastorage.org/webt/ya/2f/sj/ya2fsjju2epd-vvcn96gms0i5rm.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faisons de brèves conclusions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes de calculs, la bibliothèque Pandas pourrait bien remplacer Power Pivot (DAX). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La faisabilité d'un tel remplacement reste en dehors de la conversation. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DAX, comme les fonctions de la bibliothèque Python, fait un bon travail pour effectuer des opérations sur des champs entiers d'une table. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En termes de vitesse, de simplicité et de facilité de conception de la visualisation, Power BI est supérieur aux Pandas. </font><font style="vertical-align: inherit;">À mon avis, les graphiques intégrés (ainsi que ceux créés à l'aide du matplotlib, des bibliothèques marines) sont appropriés pour s'appliquer dans deux cas: analyse express d'un certain nombre de données pour les valeurs aberrantes, minima / maxima locaux ou préparation de diapositives pour la présentation. </font><font style="vertical-align: inherit;">Il est préférable de laisser le développement de panneaux de contrôle graphiques aux solutions BI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est tout. </font><font style="vertical-align: inherit;">Toute santé, bonne chance et réussite professionnelle!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501480/index.html">Deno v1.0: Secure Runtime pour JavaScript et TypeScript. Présentation des fonctionnalités</a></li>
<li><a href="../fr501482/index.html">Centaures extraterrestres</a></li>
<li><a href="../fr501484/index.html">Le programmeur doit décider</a></li>
<li><a href="../fr501488/index.html">Du moyen au senior</a></li>
<li><a href="../fr501490/index.html">Quoi de neuf attendu dans Python 3.9</a></li>
<li><a href="../fr501494/index.html">Pas un gramme pour l'âme: l'histoire de l'échec de la crypto-monnaie Durov</a></li>
<li><a href="../fr501496/index.html">Lac Comet, achèvement de l'itération</a></li>
<li><a href="../fr501498/index.html">Quelle quantité de code C ++ doit être écrite pour analyser l'en-tête HTTP d'autorisation à l'aide d'easy_parser de RESTinio?</a></li>
<li><a href="../fr501500/index.html">Piratage visuel: ce qui menace et comment se protéger de l'espionnage</a></li>
<li><a href="../fr501502/index.html">Le nouveau laboratoire de synthèse numérique poursuit Harris Book et aide à créer un jeu vidéo FPGA</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>