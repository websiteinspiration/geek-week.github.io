<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎛️ 🚆 🥖 Antipatterns PostgreSQL: quelle est la profondeur du trou du lapin? passer par la hiérarchie 🤱🏿 👩‍⚖️ 😁</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans les systèmes ERP complexes, de nombreuses entités ont une nature hiérarchique , lorsque des objets homogènes s'alignent dans une arborescence de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Antipatterns PostgreSQL: quelle est la profondeur du trou du lapin? passer par la hiérarchie</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/tensor/blog/501614/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans les systèmes ERP complexes, de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombreuses entités ont une nature hiérarchique</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lorsque des objets homogènes s'alignent dans une </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arborescence de relations ancêtre-descendant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - il s'agit de la structure organisationnelle de l'entreprise (toutes ces branches, départements et groupes de travail), et du catalogue de produits, des zones de travail et de la géographie. points de vente, ... </font><font style="vertical-align: inherit;">
En fait, il n'y a pas une seule </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">sphère de l'automatisation des affaires</font></a><font style="vertical-align: inherit;"> où au moins une certaine hiérarchie ne serait pas le résultat. Mais même si vous ne travaillez pas «pour les affaires», vous pouvez toujours rencontrer facilement des relations hiérarchiques. Trite, même votre arbre généalogique ou plan d'étage des locaux dans le centre commercial est la même structure. </font><font style="vertical-align: inherit;">
Il existe de nombreuses façons de stocker une telle arborescence dans un SGBD, mais aujourd'hui, nous nous concentrerons sur une seule option:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/-o/tq/ad/-otqadbymksleulmgjdpxf6e2bo.png"></a><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> hier(
  <span class="hljs-keyword">id</span>
    <span class="hljs-built_in">integer</span>
      PRIMARY <span class="hljs-keyword">KEY</span><font></font>
, pid<font></font>
    <span class="hljs-built_in">integer</span>
      <span class="hljs-keyword">REFERENCES</span> hier<font></font>
, <span class="hljs-keyword">data</span>
    <span class="hljs-keyword">json</span><font></font>
);<font></font>
<font></font>
<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">ON</span> hier(pid); <span class="hljs-comment">--  ,  FK    ,    PK</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pendant que vous regardez dans les profondeurs de la hiérarchie, il attend patiemment la façon dont [naïf] vos manières "naïves" de travailler avec une telle structure se révéleront.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/na/_z/nxna_zsl1hv506-owlmrxybpute.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Analysons les tâches émergentes typiques, leur implémentation en SQL et essayons d'améliorer leurs performances.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#1. </font><font style="vertical-align: inherit;">Quelle est la profondeur du terrier du lapin?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Supposons, pour être précis, que cette structure reflétera la subordination des départements dans la structure de l'organisation: départements, divisions, secteurs, branches, groupes de travail ... peu importe comment vous les appelez.</font></font><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/kl/yg/ck/klygckuyurttjnrskva_a6clwfy.png"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tout d'abord, nous générons notre «arbre» ​​d'éléments 10K</font></font></b>
                        <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> hier
<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-number">1</span>::<span class="hljs-built_in">integer</span> <span class="hljs-keyword">id</span>
  , <span class="hljs-string">'{1}'</span>::<span class="hljs-built_in">integer</span>[] pids
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>
  , pids[<span class="hljs-number">1</span>:(random() * array_length(pids, <span class="hljs-number">1</span>))::<span class="hljs-built_in">integer</span>] || (<span class="hljs-keyword">id</span> + <span class="hljs-number">1</span>)
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> &lt; <span class="hljs-number">10000</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  pids[array_length(pids, <span class="hljs-number">1</span>)] <span class="hljs-keyword">id</span>
, pids[array_length(pids, <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>] pid
<span class="hljs-keyword">FROM</span>
  T;</code></pre></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par la tâche la plus simple - trouver tous les employés qui travaillent dans un secteur spécifique, ou en termes de hiérarchie - pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trouver tous les descendants d'un nœud</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il serait également intéressant d'obtenir la «profondeur» du descendant ... Tout cela peut être nécessaire, par exemple, pour construire une sorte de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sélection complexe à partir de la liste des identifiants de ces employés</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout irait bien s'il n'y avait que quelques niveaux de ces descendants et quantitativement dans une douzaine, mais s'il y a plus de 5 niveaux et qu'il y a déjà des dizaines de descendants, il peut y avoir des problèmes. </font><font style="vertical-align: inherit;">Voyons comment les options de recherche traditionnelles «en bas de l'arbre» ​​sont écrites (et fonctionnent). </font><font style="vertical-align: inherit;">Mais d'abord, nous déterminons lequel des nœuds sera le plus intéressant pour notre recherche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les </font><font style="vertical-align: inherit;">sous-arbres </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"les plus profonds"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span><font></font>
  , pid<font></font>
  , <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">path</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    pid <span class="hljs-keyword">IS</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  , hier.pid<font></font>
  , T.path || hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> array_length(<span class="hljs-keyword">path</span>, <span class="hljs-number">1</span>) <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs"> id  | pid  | path<font></font>
---------------------------------------------<font></font>
7624 | 7623 | {7615,7620,7621,7622,7623,7624}<font></font>
4995 | 4994 | {4983,4985,4988,4993,4994,4995}<font></font>
4991 | 4990 | {4983,4985,4988,4989,4990,4991}<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les </font><font style="vertical-align: inherit;">sous-arbres </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"les plus larges"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="sql hljs">...
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">path</span>[<span class="hljs-number">1</span>] <span class="hljs-keyword">id</span>
, <span class="hljs-keyword">count</span>(*)
<span class="hljs-keyword">FROM</span><font></font>
  T<font></font>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">1</span>
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>
  <span class="hljs-number">2</span> <span class="hljs-keyword">DESC</span>;</code></pre><br>
<pre><code class="plaintext hljs">id   | count<font></font>
------------<font></font>
5300 |   30<font></font>
 450 |   28<font></font>
1239 |   27<font></font>
1573 |   25<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour ces requêtes, nous avons utilisé un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JOIN récursif</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> typique </font><font style="vertical-align: inherit;">: </font></font><br>
<img src="https://habrastorage.org/webt/lx/cx/3n/lxcx3n6k4cttix3mbrcoj8hyap8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Évidemment, avec ce modèle de requête, le </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombre d'itérations coïncidera avec le nombre total de descendants</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (et il y en a plusieurs dizaines), et cela peut prendre des ressources assez importantes et, par conséquent, du temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vérifions le sous-arbre "le plus large":</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-keyword">id</span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    hier.id<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span><font></font>
    hier<font></font>
      <span class="hljs-keyword">ON</span> hier.pid = T.id<font></font>
)<font></font>
<span class="hljs-keyword">TABLE</span> T;</code></pre><br>
<img src="https://habrastorage.org/webt/gx/xg/q6/gxxgq6p6c0eynpmffoohetg2iye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[regardez</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
expliquez.tensor.ru </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">]</font></a><font style="vertical-align: inherit;"> Comme prévu, nous avons trouvé les 30 entrées. </font><font style="vertical-align: inherit;">Mais ils y ont consacré 60% du temps - car ils ont effectué 30 recherches sur l'index. </font><font style="vertical-align: inherit;">Et moins - vous le pouvez?</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relecture en masse par index</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et pour chaque nœud, devons-nous faire une demande d'index distincte? Il s'avère que non - nous pouvons lire à partir de l'index </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sur plusieurs touches à la fois</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec </font><b><font style="vertical-align: inherit;">un seul appel</font></b></font><code>= ANY(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans chacun de ces groupes d'identifiants, nous pouvons prendre tous les identifiants trouvés à l'étape précédente par des «nœuds». Autrement dit, à chaque étape suivante, nous </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rechercherons immédiatement tous les descendants d'un certain niveau à la fois</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais, par malchance, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dans une sélection récursive, vous ne pouvez pas vous référer à vous-même dans une sous-requête</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais nous devons simplement sélectionner en quelque sorte exactement ce qui a été trouvé au niveau précédent ... Il s'avère que vous ne pouvez pas faire une sous-requête à l'ensemble de l'échantillon, mais à son champ spécifique - pouvez. Et ce champ peut également être un tableau - c'est ce que nous devons utiliser</font></font><code>ANY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela semble un peu sauvage, mais sur le diagramme - tout est simple.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fm/_t/qz/fm_tqzx1c9ri4-mbrgtxqvjizri.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>[<span class="hljs-keyword">id</span>] <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span>
    <span class="hljs-built_in">ARRAY</span>(
      <span class="hljs-keyword">SELECT</span>
        <span class="hljs-keyword">id</span>
      <span class="hljs-keyword">FROM</span><font></font>
        hier<font></font>
      <span class="hljs-keyword">WHERE</span>
        pid = <span class="hljs-keyword">ANY</span>(T.id$)<font></font>
    ) <span class="hljs-keyword">id</span>$
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">coalesce</span>(<span class="hljs-keyword">id</span>$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span> <span class="hljs-comment">--     -  </span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/i0/a-/sk/i0a-sk-ytooivrkxwyxsq-ipnoi.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[regardez expliquez.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Et ici, la chose la plus importante n'est même pas de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gagner 1,5 fois dans le temps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais que nous avons soustrait moins de tampons, car nous n'avons que 5 appels à l'index au lieu de 30! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un bonus supplémentaire est le fait qu'après la dernière version, les identifiants ne seront pas classés par «niveaux».</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balise de nœud</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La prochaine considération qui contribuera à améliorer la productivité est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que les «feuilles» ne peuvent pas avoir d’enfants</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c’est-à-dire qu’elles n’ont pas besoin de regarder vers le bas. Dans la formulation de notre tâche, cela signifie que si nous suivons la chaîne des départements et atteignons l'employé, il n'est pas nécessaire de chercher plus loin dans cette branche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Introduisons un </font><b><font style="vertical-align: inherit;">champ </font></b></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">supplémentaire</font></font><code>boolean</code><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans notre table </font><font style="vertical-align: inherit;">, qui nous dira tout de suite si cette entrée particulière dans notre arbre est un «nœud» </font><b><font style="vertical-align: inherit;">- c'est-à-dire</font></b><font style="vertical-align: inherit;"> , si elle peut avoir des enfants.</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> hier
  <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">COLUMN</span> branch <span class="hljs-built_in">boolean</span>;<font></font>
<font></font>
<span class="hljs-keyword">UPDATE</span><font></font>
  hier T<font></font>
<span class="hljs-keyword">SET</span>
  branch = <span class="hljs-literal">TRUE</span>
<span class="hljs-keyword">WHERE</span>
  <span class="hljs-keyword">EXISTS</span>(
    <span class="hljs-keyword">SELECT</span>
      <span class="hljs-literal">NULL</span>
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span><font></font>
      pid = T.id<font></font>
    <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">1</span><font></font>
);<font></font>
<span class="hljs-comment">--   : 3033    42 .</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien! </font><font style="vertical-align: inherit;">Il s'avère que seulement un peu plus de 30% de tous les éléments d'arbre ont des descendants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, </font></font><code>LATERAL</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous allons </font><font style="vertical-align: inherit;">appliquer une mécanique légèrement différente - la connexion à la partie récursive </font><font style="vertical-align: inherit;">, qui nous permettra d'accéder immédiatement aux champs de la "table" récursive, et d'utiliser la fonction d'agrégation avec la condition de filtre par l'attribut du nœud pour réduire le jeu de clés:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f1/3x/vb/f13xvb2zblngijramviz8kpidks.png"><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> T <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
  , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
  <span class="hljs-keyword">FROM</span><font></font>
    hier<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-number">5300</span>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">SELECT</span><font></font>
    X.*<font></font>
  <span class="hljs-keyword">FROM</span><font></font>
    T<font></font>
  <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">LATERAL</span> (
    <span class="hljs-keyword">SELECT</span>
      array_agg(<span class="hljs-keyword">id</span>) <span class="hljs-keyword">id</span>$<font></font>
    , array_agg(<span class="hljs-keyword">id</span>) FILTER(<span class="hljs-keyword">WHERE</span> branch) ns$
    <span class="hljs-keyword">FROM</span><font></font>
      hier<font></font>
    <span class="hljs-keyword">WHERE</span>
      pid = <span class="hljs-keyword">ANY</span>(T.ns$)<font></font>
  ) X<font></font>
    <span class="hljs-keyword">ON</span> <span class="hljs-keyword">coalesce</span>(T.ns$, <span class="hljs-string">'{}'</span>) &lt;&gt; <span class="hljs-string">'{}'</span><font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(<span class="hljs-keyword">id</span>$) <span class="hljs-keyword">id</span>
<span class="hljs-keyword">FROM</span>
  T;</code></pre><br>
<img src="https://habrastorage.org/webt/jc/6r/fa/jc6rfaqvbbvy6avqifoi1bf5chk.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[regardez expliquez.tensor.ru]</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nous avons pu réduire un autre appel à l'indice et avons </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gagné plus de 2 fois en termes de montant</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> déduit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"># 2 </font><font style="vertical-align: inherit;">Retour aux sources</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet algorithme sera utile si vous devez collecter des enregistrements pour tous les éléments «dans l'arborescence», tout en conservant des informations sur la feuille source (et avec quels indicateurs) qui l'a fait tomber dans l'échantillon - par exemple, pour générer un rapport récapitulatif avec agrégation des nœuds.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ah/xs/xb/ahxsxbntkmfs884ggqqqvoeyqbc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La seconde doit être considérée exclusivement comme une preuve de concept, car la demande est très lourde. </font><font style="vertical-align: inherit;">Mais s'il domine votre base de données - il vaut la peine d'envisager l'utilisation de telles techniques. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par quelques déclarations simples:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">préférable de ne lire</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le même enregistrement de la base de données </font><b><font style="vertical-align: inherit;">qu'une seule fois</font></b><font style="vertical-align: inherit;"> .</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les entrées de la base de données sont </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lues plus efficacement dans un "ensemble"</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> qu'individuellement.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons maintenant de concevoir la requête dont nous avons besoin.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 1</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Évidemment, lors de l'initialisation de la récursion (où sans elle!) Nous devrons soustraire les enregistrements des feuilles eux-mêmes de l'ensemble des identifiants de source:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span>
    rec <span class="hljs-comment">--    </span>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld <span class="hljs-comment">--  ""    </span>
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  ...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
S'il semble étrange à quelqu'un que «l'ensemble» soit stocké dans une chaîne, pas dans un tableau, alors il y a une explication simple. </font><font style="vertical-align: inherit;">Pour les chaînes, il existe une fonction intégrée de «collage» d'agrégation </font></font><code>string_agg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mais pour les tableaux, non. </font><font style="vertical-align: inherit;">Bien qu'il </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soit </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">pas difficile de le mettre en œuvre vous-même</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 2</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous aurions un ensemble d'ID de section qui devront être soustraits davantage. </font><font style="vertical-align: inherit;">Presque toujours, ils seront dupliqués dans différents enregistrements de l'ensemble source - nous les </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regrouperions donc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tout en conservant les informations sur les feuilles source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais ici trois problèmes nous attendent:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La partie "sous-récursive" d'une requête ne peut pas contenir de fonctions d'agrégation c </font></font><code>GROUP BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un appel à une «table» récursive ne peut pas être dans une sous-requête imbriquée.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Une requête dans la partie récursive ne peut pas contenir un CTE.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, tous ces problèmes sont facilement contournés. </font><font style="vertical-align: inherit;">Commençons par la fin.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CTE dans la partie récursive</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce n'est </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme </font><b><font style="vertical-align: inherit;">ça</font></b><font style="vertical-align: inherit;"> que </font><b><font style="vertical-align: inherit;">ça</font></b><font style="vertical-align: inherit;"> marche:</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span>
  <span class="hljs-keyword">WITH</span> T (...)
  <span class="hljs-keyword">SELECT</span> ...<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et donc ça marche, les parenthèses décident!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (<font></font>
  ...<font></font>
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> T (...)
    <span class="hljs-keyword">SELECT</span> ...<font></font>
  )<font></font>
)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requête imbriquée pour une "table" récursive</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hmm ... Un appel à un CTE récursif ne peut pas être dans une sous-requête. </font><font style="vertical-align: inherit;">Mais ça peut être à l'intérieur du CTE! </font><font style="vertical-align: inherit;">Une sous-demande peut déjà faire référence à ce CTE!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GROUPE PAR récursivité intérieure</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est désagréable, mais ... Nous avons aussi un moyen simple de simuler GROUP BY en utilisant </font></font><code>DISTINCT ON</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les fonctions de la fenêtre!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>
<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> <span class="hljs-number">1</span> <span class="hljs-comment">--  !</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et donc ça marche!</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
  (rec).pid <span class="hljs-keyword">id</span>
, string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
<span class="hljs-keyword">FROM</span><font></font>
  tree<font></font>
<span class="hljs-keyword">WHERE</span>
  (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous voyons maintenant pourquoi l'ID numérique s'est transformé en texte - afin qu'ils puissent être collés avec une virgule!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 3</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour la finale, il ne nous reste plus rien:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nous lisons des enregistrements de "sections" sur un ensemble d'ID groupés</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faire correspondre les sections soustraites avec les «ensembles» de feuilles source</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Développez" la chaîne définie à l'aide de </font></font><code>unnest(string_to_array(chld, ',')::integer[])</code></li>
</ul><br>
<pre><code class="sql hljs"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> tree <span class="hljs-keyword">AS</span> (
  <span class="hljs-keyword">SELECT</span><font></font>
    rec<font></font>
  , <span class="hljs-keyword">id</span>::<span class="hljs-built_in">text</span> chld
  <span class="hljs-keyword">FROM</span><font></font>
    hier rec<font></font>
  <span class="hljs-keyword">WHERE</span>
    <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-string">'{1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192}'</span>::<span class="hljs-built_in">integer</span>[])
<span class="hljs-keyword">UNION</span> <span class="hljs-keyword">ALL</span><font></font>
  (<font></font>
    <span class="hljs-keyword">WITH</span> prnt <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-keyword">ON</span>((rec).pid)<font></font>
        (rec).pid <span class="hljs-keyword">id</span>
      , string_agg(chld::<span class="hljs-built_in">text</span>, <span class="hljs-string">','</span>) <span class="hljs-keyword">OVER</span>(<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> (rec).pid) chld
      <span class="hljs-keyword">FROM</span><font></font>
        tree<font></font>
      <span class="hljs-keyword">WHERE</span>
        (rec).pid <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span><font></font>
    )<font></font>
    , nodes <span class="hljs-keyword">AS</span> (
      <span class="hljs-keyword">SELECT</span><font></font>
        rec<font></font>
      <span class="hljs-keyword">FROM</span><font></font>
        hier rec<font></font>
      <span class="hljs-keyword">WHERE</span>
        <span class="hljs-keyword">id</span> = <span class="hljs-keyword">ANY</span>(<span class="hljs-built_in">ARRAY</span>(
          <span class="hljs-keyword">SELECT</span>
            <span class="hljs-keyword">id</span>
          <span class="hljs-keyword">FROM</span><font></font>
            prnt<font></font>
        ))<font></font>
    )<font></font>
    <span class="hljs-keyword">SELECT</span><font></font>
      nodes.rec<font></font>
    , prnt.chld<font></font>
    <span class="hljs-keyword">FROM</span><font></font>
      prnt<font></font>
    <span class="hljs-keyword">JOIN</span><font></font>
      nodes<font></font>
        <span class="hljs-keyword">ON</span> (nodes.rec).id = prnt.id<font></font>
  )<font></font>
)<font></font>
<span class="hljs-keyword">SELECT</span>
  <span class="hljs-keyword">unnest</span>(string_to_array(chld, <span class="hljs-string">','</span>)::<span class="hljs-built_in">integer</span>[]) leaf<font></font>
, (rec).*<font></font>
<span class="hljs-keyword">FROM</span>
  tree;</code></pre><br>
<img src="https://habrastorage.org/webt/hl/e5/jn/hle5jn8eolot086fr-ecmutxlye.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">[  explain.tensor.ru]</a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr501598/index.html">Un guide modeste des schémas de base de données</a></li>
<li><a href="../fr501600/index.html">Console de jeux stm32</a></li>
<li><a href="../fr501604/index.html">Traduction du livre d'Andrew Un, Passion for Machine Learning. Chapitres 51 et 52</a></li>
<li><a href="../fr501610/index.html">Barre de défilement personnalisée en angulaire</a></li>
<li><a href="../fr501612/index.html">Quelle carte graphique choisir pour votre ordinateur en 2020</a></li>
<li><a href="../fr501616/index.html">Portrait du client: composer et compter</a></li>
<li><a href="../fr501622/index.html">Cas: comment créer un plan de contenu pour un blog B2B basé sur la sémantique de l'information</a></li>
<li><a href="../fr501624/index.html">Modèles réels de localisation linguistique dans le domaine de l'informatique et des communications numériques. Partie 2</a></li>
<li><a href="../fr501628/index.html">Entretien avec Alexander Filippov, concepteur de jeu en chef World of Tanks Blitz</a></li>
<li><a href="../fr501630/index.html">Cinq risques de sécurité lors d'un travail à distance</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>