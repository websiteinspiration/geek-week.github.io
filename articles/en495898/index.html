<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üéûÔ∏è üë®üèæ‚Äç‚öïÔ∏è üõ£Ô∏è A practical guide to dealing with memory leaks in Node.js ‚ÜôÔ∏è üëâüèΩ üì≤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Memory leaks are similar to entities parasitic on an application. They quietly penetrate into the system, at first without causing any harm. But if th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>A practical guide to dealing with memory leaks in Node.js</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/495898/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory leaks are similar to entities parasitic on an application. </font><font style="vertical-align: inherit;">They quietly penetrate into the system, at first without causing any harm. </font><font style="vertical-align: inherit;">But if the leak turns out to be strong enough, it can bring the application to disaster. </font><font style="vertical-align: inherit;">For example - to slow it down strongly or simply to ‚Äúkill‚Äù it. </font><font style="vertical-align: inherit;">
The author of the article, the translation of which we are publishing today, suggests talking about memory leaks in JavaScript. </font><font style="vertical-align: inherit;">In particular, we will talk about memory management in JavaScript, how to identify memory leaks in real applications, and how to deal with memory leaks.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/ut/sj/t-/utsjt-d80r9mqkvrexbbkws-eae.png"></a><br>
<br><font style="vertical-align: inherit;"></font><br>
<a name="habracut"></a><br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is a memory leak?</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A memory leak is, in a broad sense, a piece of memory allocated to an application that this application no longer needs, but cannot be returned to the operating system for future use. </font><font style="vertical-align: inherit;">In other words, it is a memory block that is captured by the application without the intention of using this memory in the future.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory management</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory management is a mechanism for allocating system memory to an application that needs it, and a mechanism for returning unnecessary memory to the operating system. </font><font style="vertical-align: inherit;">There are many approaches to memory management. </font><font style="vertical-align: inherit;">Which approach is used depends on the programming language used. </font><font style="vertical-align: inherit;">Here is an overview of several common approaches to memory management:</font></font><br>
<br>
<ul>
<li>  .           .         .       ,    .        C  C++.   ,   ,   <code>malloc</code>  <code>free</code>,      .</li>
<li>   . ,      ,   ,       .   ,  ,    ,        . ,     ,  ,      ,   .         .  ‚Äî JavaScript, ,   JVM (Java, Scala, Kotlin), Golang, Python, Ruby  .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application of the concept of ownership of memory. </font><font style="vertical-align: inherit;">With this approach, each variable should have its own owner. </font><font style="vertical-align: inherit;">As soon as the owner is out of scope, the value in the variable is destroyed, freeing memory. </font><font style="vertical-align: inherit;">This idea is used in Rust.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are other approaches to memory management used in different programming languages. </font><font style="vertical-align: inherit;">For example, C ++ 11 uses the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> idiom </font><font style="vertical-align: inherit;">, while Swift uses the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ARC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mechanism </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But talking about it is beyond the scope of this article. </font><font style="vertical-align: inherit;">In order to compare the above methods of memory management, to understand their pros and cons, we need a separate article. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
JavaScript, a language without which web programmers cannot imagine their work, uses the idea of ‚Äã‚Äãgarbage collection. </font><font style="vertical-align: inherit;">Therefore, we will talk more about how this mechanism works.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JavaScript garbage collection</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As already mentioned, JavaScript is a language that uses the concept of garbage collection. </font><font style="vertical-align: inherit;">During the operation of JS programs, a mechanism called a garbage collector is periodically launched. </font><font style="vertical-align: inherit;">He finds out which parts of the allocated memory can be accessed from the application code. </font><font style="vertical-align: inherit;">That is, which variables are referenced. </font><font style="vertical-align: inherit;">If the garbage collector finds out that a piece of memory is no longer accessed from the application code, it frees this memory. </font><font style="vertical-align: inherit;">The above approach can be implemented using two main algorithms. </font><font style="vertical-align: inherit;">The first is the so-called Mark and Sweep algorithm. </font><font style="vertical-align: inherit;">It is used in JavaScript. </font><font style="vertical-align: inherit;">The second is Reference Counting. </font><font style="vertical-align: inherit;">It is used in Python and PHP.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ee/8ac/c60/3ee8acc608afe85e6a4c6f202cb1e8fe.gif"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Phases Mark (marking) and Sweep (cleaning) of the Mark and Sweep</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
algorithm When implementing the marking algorithm, a list of root nodes represented by global environment variables (this is an object in the browser</font></font><code>window</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) is created first, and then the resulting tree is crawled from root to leaf nodes marked with all met on the way objects. </font><font style="vertical-align: inherit;">Memory on the heap that is occupied by unlabeled objects is freed.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memory leaks in Node.js applications</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To date, we have analyzed enough theoretical concepts related to memory leaks and garbage collection. </font><font style="vertical-align: inherit;">So - we are ready to look at how it all looks in real applications. </font><font style="vertical-align: inherit;">In this section, we will write a Node.js server that has a memory leak. </font><font style="vertical-align: inherit;">We will try to identify this leak using various tools, and then we will eliminate it.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Familiarity with a code that has a memory leak</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For demonstration purposes, I wrote an Express server that has a memory leak route. </font><font style="vertical-align: inherit;">We will debug this server.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>)<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Example app listening on port <span class="hljs-subst">${port}</span>!`</span>));
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is an array </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that is outside the scope of the API request processing code. </font><font style="vertical-align: inherit;">As a result, every time the corresponding code is executed, new elements are simply added to the array. </font><font style="vertical-align: inherit;">The array is never cleared. </font><font style="vertical-align: inherit;">Since the link to this array does not disappear after exiting the request handler, the garbage collector never frees the memory it uses.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçCall memory leak</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we come to the most interesting. Many articles have been written about how, using </font></font><code>node --inspect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, to debug server memory leaks, after filling up the server with requests using something like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artillery</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But this approach has one important drawback. Imagine you have an API server that has thousands of endpoints. Each of them takes a lot of parameters, the particular code that will be called depends on the features of which. As a result, in real conditions, if the developer does not know where the memory leak lies, he will have to access each API many times using all possible combinations of parameters to fill the memory. As for me, it is not easy to do so. The solution to this problem, however, is facilitated by using something like</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goreplay</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a system that allows you to record and "play" real traffic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to cope with our problem, we are going to do debugging in production. </font><font style="vertical-align: inherit;">That is, we will allow our server to overflow memory during its actual use (as it receives a variety of API requests). </font><font style="vertical-align: inherit;">And after we find a suspicious increase in the amount of memory allocated to it, we will do debugging.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Heap Dump</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to understand what a heap dump is, we first need to find out the meaning of the concept of a heap. If you describe this concept as simply as possible, it turns out that the heap is the place where everything that the memory is allocated falls into. All this is on the heap until the garbage collector removes from it everything that is deemed unnecessary. A heap dump is a bit of a snapshot of the current state of the heap. The dump contains all internal variables and variables declared by the programmer. It represents all the memory allocated on the heap at the time the dump was received.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As a result, if we could somehow compare the heap dump of the server just started with the dump of the server heap, which has been running for a long time and overflowing memory, then we could identify suspicious objects that the application does not need, but are not deleted by the garbage collector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before continuing the conversation, let's talk about how to create heap dumps. </font><font style="vertical-align: inherit;">To solve this problem, we will use the npm package </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heapdump</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows you to programmatically obtain a dump of the server heap. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Install the package:</font></font><br>
<br>
<pre><code class="bash hljs">npm i heapdump
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We‚Äôll make some changes to the server code that will allow us to use this package:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> heapdump = <span class="hljs-built_in">require</span>(<span class="hljs-string">"heapdump"</span>);<font></font>
<font></font>
<span class="hljs-keyword">const</span> app = express();
<span class="hljs-keyword">const</span> port = <span class="hljs-number">3000</span>;<font></font>
<font></font>
<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
<font></font>
app.get(<span class="hljs-string">'/heapdump'</span>, (req, res) =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDump-<span class="hljs-subst">${<span class="hljs-built_in">Date</span>.now()}</span>.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a bloated server written to"</span>, filename);<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">msg</span>: <span class="hljs-string">"successfully took a heap dump"</span>})<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
<font></font>
app.listen(port, () =&gt; {<font></font>
&nbsp;&nbsp;heapdump.writeSnapshot(<span class="hljs-string">`heapDumpAtServerStart.heapsnapshot`</span>, (err, filename) =&gt; {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Heap dump of a fresh server written to"</span>, filename);<font></font>
&nbsp;&nbsp;});<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here we used this package to dump a freshly launched server. </font><font style="vertical-align: inherit;">We also created an API </font></font><code>/heapdump</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">designed to create a heap when accessing it. </font><font style="vertical-align: inherit;">We will turn to this API at the moment when we realize that the server began to consume too much memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If your server is running in a Kubernetes cluster, then you will not be able, without additional efforts, to turn to that very pod whose server is running in which consumes too much memory. </font><font style="vertical-align: inherit;">In order to do this, you can use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">port forwarding</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">In addition, since you will not have access to the file system that you need to download dump files, it would be better to upload these files to external cloud storage (like S3).</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñç Memory leak detection</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
And now, the server is deployed. He has been working for several days. It receives a lot of requests (in our case, only requests of the same type) and we paid attention to the increase in the amount of memory consumed by the server. A memory leak can be detected using monitoring tools like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Express Status Monitor</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clinic</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prometheus</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . After that, we call the API to dump the heap. This dump will contain all objects that the garbage collector could not delete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here's what the query looks like to create a dump:</font></font><br>
<br>
<pre><code class="bash hljs">curl --location --request GET <span class="hljs-string">'http://localhost:3000/heapdump'</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When a heap dump is created, the garbage collector is forced to run. As a result, we do not need to worry about those objects that may be removed by the garbage collector in the future, but are still on the heap. That is - about the objects when working with which memory leaks do not occur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After we have both dumps at our disposal (a dump of a freshly launched server and a dump of a server that has worked for some time), we can begin to compare them. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Getting a memory dump is a blocking operation that takes a lot of memory to complete. Therefore, it must be carried out with caution. You can read more about the possible problems encountered during this operation </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Launch Chrome and press the key.</font></font><code>F12</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This will lead to the discovery of developer tools. </font><font style="vertical-align: inherit;">Here you need to go to the tab </font></font><code>Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and load both snapshots of memory.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c1/252/992/5c125299224be08bb5bb73f74842f0b8.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Downloading memory dumps on the Memory tab of the Chrome developer tools</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
After downloading both snapshots, you need to change</font></font><code>perspective</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to</font></font><code>Comparison</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and click on the snapshot of the memory of the server that worked for some time.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a99/7c7/224/a997c7224ac3d053651be9e848380e75.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start comparing snapshots</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Here we can analyze the column</font></font><code>Constructor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and look for objects that the garbage collector cannot remove. </font><font style="vertical-align: inherit;">Most of these objects will be represented by internal links that nodes use. </font><font style="vertical-align: inherit;">Here it is useful to use one trick, which consists in sorting the list by field</font></font><code>Alloc. Size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This will quickly find the objects that use the most memory. </font><font style="vertical-align: inherit;">If you expand the block</font></font><code>(array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and then -</font></font><code>(object elements)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, you can see an array</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">containing a huge number of objects that cannot be deleted using the garbage collector.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e85/02c/0a2/e8502c0a2dcd1cf635f229eaef8d9e90.png"></div><br>
<i><font color="#999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analysis of a suspicious array</font></font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This technique will allow us to go to the array</font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and understand that it is the incorrect operation with it that causes a memory leak.</font></font><br>
<br>
<h3><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ñçFix memory leak</font></font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that we know that the "culprit" is an array </font></font><code>leaks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we can analyze the code and find out that the problem is that the array is declared outside the request handler. </font><font style="vertical-align: inherit;">As a result, it turns out that the link to it is never deleted. </font><font style="vertical-align: inherit;">To fix this problem is quite simple - just transfer the declaration of the array to the handler:</font></font><br>
<br>
<pre><code class="javascript hljs">app.get(<span class="hljs-string">'/bloatMyServer'</span>, (req, res) =&gt; {
&nbsp;&nbsp;<span class="hljs-keyword">const</span> redundantObj = {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">memory</span>: <span class="hljs-string">"leaked"</span>,
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-attr">joke</span>: <span class="hljs-string">"meta"</span><font></font>
&nbsp;&nbsp;};<font></font>
<font></font>
&nbsp;&nbsp;<span class="hljs-keyword">const</span> leaks = [];<font></font>
<font></font>
&nbsp;&nbsp;[...Array(<span class="hljs-number">10000</span>)].map(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> leaks.push(redundantObj));<font></font>
<font></font>
&nbsp;&nbsp;res.status(<span class="hljs-number">200</span>).send({<span class="hljs-attr">size</span>: leaks.length})<font></font>
});<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order to verify the effectiveness of the measures taken, it is enough to repeat the above steps and compare the heap images again.</font></font><br>
<br>
<h2><font color="#3AC1EF"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Memory leaks happen in different languages. </font><font style="vertical-align: inherit;">In particular, in - those that use garbage collection mechanisms. </font><font style="vertical-align: inherit;">For example, in JavaScript. </font><font style="vertical-align: inherit;">It is usually not difficult to fix a leak - the real difficulties arise only when you search for it. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, you familiarized yourself with the basics of memory management, and how memory management is organized in different languages. </font><font style="vertical-align: inherit;">Here we reproduced a real scenario of a memory leak and described a method for troubleshooting. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dear readers! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you encountered memory leaks in your web projects?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/webt/iq/fi/b4/iqfib45pgphfrxv--zfemt0qnmw.jpeg"></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en495888/index.html">PyCon Russia has opened CFP for future speakers. Participation Forms and Expected Topics</a></li>
<li><a href="../en495890/index.html">Configuring a Nginx / LetsEncrypt Bundle in Docker Swarm</a></li>
<li><a href="../en495892/index.html">Do you really know what arrays are?</a></li>
<li><a href="../en495894/index.html">Javascript Performance Measurement</a></li>
<li><a href="../en495896/index.html">Use-sound Package: Sound Effects in React Applications</a></li>
<li><a href="../en495902/index.html">CAPTCHA: killing conversion</a></li>
<li><a href="../en495904/index.html">Can an epidemic be predicted?</a></li>
<li><a href="../en495908/index.html">The path to the reward</a></li>
<li><a href="../en495910/index.html">Installing ROS in a Ubuntu Single-Board IMG Image</a></li>
<li><a href="../en495912/index.html">Smart replay stickers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>