<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕔 🍁 🧛🏼 Bagaimana layar pesan VK ditampilkan? ⛏️ 🚎 👂🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apa yang VK lakukan untuk mengurangi rendering lag? Bagaimana cara menampilkan pesan yang sangat besar dan tidak membunuh UiThread? Bagaimana cara men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Bagaimana layar pesan VK ditampilkan?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/vk/blog/501988/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang VK lakukan untuk mengurangi rendering lag? </font><font style="vertical-align: inherit;">Bagaimana cara menampilkan pesan yang sangat besar dan tidak membunuh UiThread? </font><font style="vertical-align: inherit;">Bagaimana cara mengurangi penundaan bergulir di RecyclerView? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vs/2s/jg/vs2sjg1iyfq7cdkohrmgpuy5mla.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengalaman saya didasarkan pada pekerjaan menggambar layar pesan di aplikasi VK Android, di mana perlu untuk menunjukkan sejumlah besar informasi dengan rem minimal pada UI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya telah memprogram untuk Android selama hampir sepuluh tahun, saya sebelumnya freelance untuk PHP / Node.js. </font><font style="vertical-align: inherit;">Sekarang - pengembang senior Android VKontakte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah potongan video dan transkrip laporan saya dari konferensi Mobius 2019 Moscow.</font></font><a name="habracut"></a><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/GZkTwgetUWI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laporan ini mengungkapkan tiga topik</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi standar adalah prinsip dasar bagaimana layar pesan VK bekerja. </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi non-standar adalah solusi yang kurang dikenal atau asli yang memungkinkan meminimalkan kelambatan UI.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatifnya adalah tentang berbagai perpustakaan dan implementasi, serta mengapa pengembang VK tidak menggunakannya.</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihatlah layar:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/he/h2/xj/heh2xjq-ij5pnzsu49cf11uuabu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pesan ini ada di suatu tempat di lima layar. </font><font style="vertical-align: inherit;">Dan mereka mungkin bersama kami (dalam hal meneruskan pesan). </font><font style="vertical-align: inherit;">Alat standar tidak lagi berfungsi. </font><font style="vertical-align: inherit;">Bahkan di perangkat teratas, semuanya bisa ketinggalan. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, UI itu sendiri cukup beragam:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memuat tanggal dan indikator,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pesan layanan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">teks (emoji, tautan, email, tagar),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keyboard bot</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">~ 40 cara untuk menampilkan lampiran,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pohon pesan yang diteruskan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muncul pertanyaan: bagaimana cara membuat jumlah kelambatan sekecil mungkin? </font><font style="vertical-align: inherit;">Baik dalam hal pesan sederhana, dan dalam kasus pesan massal (tepi-kasus dari video di atas).</font></font><br>
<a name="ordinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi Standar</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecyclerView dan add-on-nya</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada berbagai add-on untuk RecyclerView.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setHasFixedSize ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak orang berpikir bahwa bendera ini diperlukan ketika item daftar berukuran sama. </font><font style="vertical-align: inherit;">Namun faktanya, dilihat dari dokumentasi, yang terjadi adalah sebaliknya. </font><font style="vertical-align: inherit;">Ini terjadi ketika ukuran RecyclerView konstan dan independen dari elemen (kira-kira, tidak wrap_content). </font><font style="vertical-align: inherit;">Mengatur bendera membantu sedikit meningkatkan kecepatan RecyclerView sehingga menghindari perhitungan yang tidak perlu.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setNestedScrollingEnabled ( </font></font><code>boolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Optimalisasi minor yang menonaktifkan dukungan NestedScroll. </font><font style="vertical-align: inherit;">Kami tidak memiliki CollapsingToolbar atau fitur lainnya tergantung pada NestedScroll di layar ini, sehingga kami dapat dengan aman mengatur flag ini ke false.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setItemViewCacheSize ( </font></font><code>cache_size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menyiapkan cache RecyclerView internal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak orang berpikir bahwa mekanisme RecyclerView adalah:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada ViewHolder yang ditampilkan di layar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada RecycledViewPool menyimpan ViewHolder;</font></font></li>
<li> ViewHolder    —    RecycledViewPool.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam praktiknya, semuanya sedikit lebih rumit, karena ada cache antara antara dua hal ini. </font><font style="vertical-align: inherit;">Ini disebut ItemViewCache. </font><font style="vertical-align: inherit;">Apa esensinya? </font><font style="vertical-align: inherit;">Ketika ViewHolder meninggalkan layar, itu tidak ditempatkan di RecycledViewPool, tetapi di cache perantara (ItemViewCache). </font><font style="vertical-align: inherit;">Semua perubahan pada adaptor berlaku untuk ViewHolder yang terlihat dan ViewHolder di dalam ItemViewCache. </font><font style="vertical-align: inherit;">Dan untuk ViewHolder di dalam RecycledViewPool, perubahan tidak diterapkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Melalui setItemViewCacheSize kita dapat mengatur ukuran cache perantara ini. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semakin besar, semakin cepat gulir akan jarak pendek, tetapi operasi pembaruan akan lebih lama (karena ViewHolder.onBind, dll.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana RecyclerView diimplementasikan dan bagaimana cache terstruktur adalah topik yang agak besar dan kompleks. </font><font style="vertical-align: inherit;">Anda dapat membaca </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">artikel yang</font></a><font style="vertical-align: inherit;"> bagus</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, di mana mereka berbicara secara detail tentang segalanya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimasi OnCreate / OnBind</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi klasik lainnya adalah mengoptimalkan onCreateViewHolder / onBindViewHolder:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tata letak yang mudah (kami mencoba menggunakan FrameLayout atau Custom ViewGroup sebanyak mungkin),</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">operasi berat (parsing links / emoji) dilakukan secara tidak sinkron pada tahap pemuatan pesan,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StringBuilder untuk memformat nama, tanggal, dll.,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan solusi lain yang mengurangi waktu kerja metode ini.</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Adapter.onFailedToRecyclerView ()</font></font></h3><br>
<img src="https://habrastorage.org/webt/8l/eo/1n/8leo1nki7gxrit4wg8mhhv0q3ua.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda memiliki daftar di mana beberapa elemen (atau bagiannya) dianimasikan dengan alpha. </font><font style="vertical-align: inherit;">Pada saat View, sedang dalam proses animasi, meninggalkan layar, maka itu tidak menuju ke RecycledViewPool. </font><font style="vertical-align: inherit;">Mengapa? </font><font style="vertical-align: inherit;">RecycledViewPool melihat bahwa View sekarang dianimasikan oleh flag View.hasTransientState, dan abaikan saja. </font><font style="vertical-align: inherit;">Oleh karena itu, lain kali Anda menggulir ke atas dan ke bawah, gambar tidak akan diambil dari RecycledViewPool, tetapi akan dibuat lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keputusan yang paling benar adalah ketika ViewHolder meninggalkan layar, Anda harus membatalkan semua animasi. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-7/1r/rh/-71rrhbw5idwburnf60gtfllcau.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memerlukan perbaikan terbaru sesegera mungkin atau Anda adalah pengembang yang malas, maka dalam metode onFailedToRecycle Anda dapat selalu mengembalikan true dan semuanya akan berfungsi, tetapi saya tidak akan menyarankan melakukannya.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/iu/se/ha/iusehamefbgzcvc6miixbtfmfoy.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pelacakan Overdraw dan Profiler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara klasik untuk mendeteksi masalah adalah penarikan berlebih dan pelacakan profiler. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overdraw - jumlah redraws piksel: semakin sedikit layer dan semakin sedikit redraw pixel, semakin cepat. Tetapi menurut pengamatan saya, dalam kenyataan modern, ini tidak begitu mempengaruhi kinerja. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0h/-d/fh/0h-dfhogberhs_hsy1eseaexkwa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Profiler - alias Monitor Android, yang ada di Android Studio. Di dalamnya, Anda dapat menganalisis semua metode yang disebut. Misalnya, buka pesan, gulir ke atas dan ke bawah dan lihat metode apa yang dipanggil dan berapa lama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dz/la/wy/dzlawyqmpqtzxbnpcbezvfoq_ww.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua yang ada di bagian kiri adalah panggilan sistem Android yang diperlukan untuk membuat / menyajikan View / ViewHolder. Kami tidak dapat memengaruhi mereka, atau kami harus menghabiskan banyak upaya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setengah bagian kanan adalah kode kami yang berjalan di ViewHolder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blok panggilan di nomor 1 adalah panggilan ke ekspresi reguler: di suatu tempat mereka mengabaikan dan lupa untuk menempatkan operasi pada utas latar belakang, sehingga memperlambat gulir dengan ~ 20%. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Blokir panggilan di nomor 2 - Fresco, perpustakaan untuk menampilkan gambar. </font><font style="vertical-align: inherit;">Ini tidak optimal di beberapa tempat. Belum jelas apa yang harus dilakukan dengan lag ini, tetapi jika kita bisa menyelesaikannya, kita akan menghemat ~ 15% lagi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, memperbaiki masalah ini, kita bisa mendapatkan peningkatan ~ 35%, yang cukup keren.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diffiff</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak dari Anda menggunakan DiffUtil dalam bentuk standar: ada dua daftar - yang disebut, dibandingkan dan didorong perubahan. Melakukan semua ini pada utas utama agak mahal karena daftarnya bisa sangat besar. Jadi biasanya perhitungan DiffUtil berjalan pada utas latar belakang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ListAdapter dan AsyncListDiffer melakukan ini untuk Anda. ListAdapter memperluas Adaptor biasa dan memulai semuanya secara tidak sinkron - cukup buat submitList dan seluruh kalkulasi perubahannya terbang ke utas latar belakang internal. ListAdapter dapat mempertimbangkan kasus pembaruan yang sering terjadi: jika Anda menyebutnya tiga kali berturut-turut, itu hanya akan mengambil hasil terakhir.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
DiffUtil sendiri kami gunakan hanya untuk beberapa perubahan struktural - tampilan pesan, perubahan dan penghapusannya. </font><font style="vertical-align: inherit;">Untuk beberapa data perubahan cepat, itu tidak cocok. </font><font style="vertical-align: inherit;">Misalnya, ketika kita mengunggah foto atau memutar audio. </font><font style="vertical-align: inherit;">Peristiwa semacam itu sering terjadi - beberapa kali per detik, dan jika Anda menjalankan DiffUtil setiap kali, Anda akan mendapatkan banyak pekerjaan tambahan.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali waktu ada kerangka Animasi - agak sedikit, tetapi masih sesuatu. </font><font style="vertical-align: inherit;">Kami bekerja dengannya seperti ini:</font></font><br>
<br>
<pre><code class="java hljs">view.startAnimation(TranslateAnimation(fromX = <span class="hljs-number">0</span>, toX = <span class="hljs-number">300</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah parameter getTranslationX () akan mengembalikan nilai yang sama sebelum dan sesudah animasi. </font><font style="vertical-align: inherit;">Ini karena Animasi mengubah representasi visual, tetapi tidak mengubah sifat fisik. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/f0/uu/tw/f0uutwhihhopkcfvps8itszyt_a.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Android 3.0, kerangka Animator muncul, yang lebih tepat karena mengubah properti fisik spesifik objek. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ib/qy/q2ibqywrlcla5cxqpslznxbxxm0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian, ViewPropertyAnimator muncul dan semua orang masih tidak benar-benar memahami perbedaannya dari Animator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan menjelaskan. </font><font style="vertical-align: inherit;">Katakanlah Anda perlu melakukan terjemahan secara diagonal - menggeser Tampilan di sepanjang sumbu x, y. </font><font style="vertical-align: inherit;">Kemungkinan besar Anda akan menulis kode khas:</font></font><br>
<br>
<pre><code class="java hljs">val animX = ObjectAnimator.ofFloat(view, “translationX”, <span class="hljs-number">100f</span>)<font></font>
val animY = ObjectAnimator.ofFloat(view, “translationY”, <span class="hljs-number">200f</span>)<font></font>
AnimatorSet().apply {<font></font>
    playTogether(animX, animY)<font></font>
    start()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan Anda bisa membuatnya lebih pendek:</font></font><br>
<br>
<pre><code class="java hljs">view.animate().translationX(<span class="hljs-number">100f</span>).translationY(<span class="hljs-number">200f</span>) </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika Anda menjalankan view.animate (), Anda secara implisit meluncurkan ViewPropertyAnimator. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa itu dibutuhkan?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih mudah membaca dan memelihara kode.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi operasi batch.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus terakhir kami, kami mengubah dua properti. Ketika kita melakukan ini melalui animator, kutu animasi akan dipanggil secara terpisah untuk setiap Animator. Yaitu, setTranslationX dan setTranslationY akan dipanggil secara terpisah, dan View akan melakukan operasi pembaruan secara terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus ViewPropertyAnimator, perubahan terjadi pada saat yang sama, sehingga ada penghematan karena operasi yang lebih sedikit dan perubahan properti itu sendiri lebih baik dioptimalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat mencapai ini dengan Animator, tetapi Anda harus menulis lebih banyak kode. </font><font style="vertical-align: inherit;">Selain itu, menggunakan ViewPropertyAnimator, Anda dapat yakin bahwa animasinya akan dioptimalkan sebanyak mungkin. </font><font style="vertical-align: inherit;">Mengapa? </font><font style="vertical-align: inherit;">Android memiliki RenderNode (DisplayList). </font><font style="vertical-align: inherit;">Sangat kasar, mereka men-cache hasil onDraw dan menggunakannya saat menggambar ulang. </font><font style="vertical-align: inherit;">ViewPropertyAnimator bekerja langsung dengan RenderNode dan menerapkan animasi untuk itu, menghindari panggilan onDraw. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak properti Tampilan juga dapat secara langsung mempengaruhi RenderNode, tetapi tidak semua. </font><font style="vertical-align: inherit;">Artinya, saat menggunakan ViewPropertyAnimator, Anda dijamin menggunakan cara yang paling efisien. </font><font style="vertical-align: inherit;">Jika Anda tiba-tiba memiliki semacam animasi yang tidak dapat dilakukan dengan ViewPropertyAnimator, maka mungkin Anda harus memikirkannya dan mengubahnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animasi: TransitionManager</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Biasanya, orang mengasosiasikan bahwa kerangka kerja ini digunakan untuk berpindah dari satu Kegiatan ke Kegiatan lainnya. Bahkan, dapat digunakan secara berbeda dan sangat menyederhanakan implementasi animasi perubahan struktural. Misalkan kita memiliki layar tempat pesan suara diputar. Kami menutupnya dengan salib, dan mati naik. Bagaimana cara melakukannya? Animasi ini cukup rumit: pemain ditutup dengan alfa, sementara bergerak bukan melalui terjemahan, tetapi mengubah ketinggiannya. Pada saat yang sama, daftar kami naik dan juga mengubah ketinggian. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mv/ff/kh/mvffkhe5udzkypeumimmusvhiig.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pemain adalah bagian dari daftar, maka animasinya akan cukup sederhana. Tetapi bersama kami, pemain bukanlah elemen dari daftar, tetapi pandangan yang sepenuhnya independen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin kita akan mulai menulis semacam Animator, kemudian kita akan menghadapi masalah, crash, mulai menggergaji kruk dan menggandakan kode. </font><font style="vertical-align: inherit;">Dan akan mendapatkan sesuatu seperti layar di bawah ini. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/wd/0d/k-/wd0dk-urz2lfr6xugvvpmp16rdk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan TransitionManager, Anda dapat membuat semuanya lebih sederhana:</font></font><br>
<br>
<pre><code class="java hljs">TransitionManager.beginDelayedTransition(<font></font>
        viewGroup = &lt;LinearLayoutManager&gt;,<font></font>
        transition = AutoTransition())<font></font>
playerView.visibility = View.GONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua animasi terjadi secara otomatis di bawah tenda. </font><font style="vertical-align: inherit;">Ini terlihat seperti sulap, tetapi jika Anda masuk jauh ke dalam dan melihat cara kerjanya, ternyata TransitionManager hanya berlangganan semua Tampilan, menangkap perubahan dalam propertinya, menghitung diff, membuat animator atau ViewPropertyAnimator yang diperlukan di mana diperlukan, dan melakukan segala sesuatu seefisien mungkin. </font><font style="vertical-align: inherit;">TransitionManager memungkinkan kita membuat animasi di bagian pesan dengan cepat dan mudah diimplementasikan.</font></font><a name="extrodinary"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi khusus</font></font></h2><br>
<img src="https://habrastorage.org/webt/u2/rx/ji/u2rxjicmid-zkuhvqsxc4kxbeem.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah hal yang paling mendasar yang menjadi dasar kinerja dan masalah yang mengikuti. Apa yang harus dilakukan ketika pesan Anda ada di 10 layar? Jika Anda memperhatikan, maka semua elemen kami terletak persis di bawah satu sama lain. Jika kami menerima bahwa ViewHolder bukan satu pesan, tetapi puluhan ViewHolder yang berbeda, maka semuanya menjadi lebih sederhana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagi kami bukan masalah bahwa pesannya telah menjadi 10 layar, karena sekarang kami hanya menampilkan enam ViewHolders dalam contoh nyata. Kami mendapat tata letak yang mudah, kode lebih mudah dipelihara, dan tidak ada masalah khusus, kecuali satu - bagaimana melakukan ini?</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/gh/ui/hoghuifbuntyzu3uszyjr6vij_0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada ViewHolders sederhana - ini adalah pemisah tanggal klasik, Memuat lebih banyak, dan sebagainya. </font><font style="vertical-align: inherit;">Dan BaseViewHolder - ViewHolder dasar bersyarat untuk pesan. </font><font style="vertical-align: inherit;">Ini memiliki implementasi dasar dan beberapa yang spesifik - TextViewHolder, PhotoViewHolder, AudioViewHolder, ReplyViewHolder dan sebagainya. </font><font style="vertical-align: inherit;">Ada sekitar 70 di antaranya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang menjadi tanggung jawab BaseViewHolder?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolder hanya bertanggung jawab untuk menggambar avatar dan potongan gelembung yang diinginkan, serta garis untuk pesan yang diteruskan - biru ke kiri. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6o/yh/ia/6oyhiaag8f94wm6s69vskpv6r4u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Implementasi konkret konten sudah dilakukan oleh pewaris BaseViewHolder lainnya: TextViewHolder hanya menampilkan teks, FwdSenderViewHolder - penulis pesan yang diteruskan, AudioMsgViewHolder - pesan suara, dan sebagainya. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/th/wi/sdthwihnbm9jm4xehrbh4mmrv20.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah: apa yang harus dilakukan dengan lebar? Bayangkan sebuah pesan di setidaknya dua layar. Tidak terlalu jelas lebar yang harus diatur, karena setengah terlihat, setengah tidak terlihat (dan bahkan belum dibuat). Benar-benar semuanya tidak dapat diukur, karena ada. Saya harus sedikit kruk, sayangnya. Ada kasus sederhana ketika pesannya sangat sederhana: teks atau suara murni - secara umum, terdiri dari satu Item.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_q/i0/ov/_qi0ovd7qibtvqzcya0tzv_o4vq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, gunakan konten klasik wrap_content. </font><font style="vertical-align: inherit;">Untuk kasus kompleks, ketika pesan terdiri dari beberapa bagian, kami mengambil dan memaksa setiap ViewHolder lebar tetap. </font><font style="vertical-align: inherit;">Khususnya di sini - 220 dp. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/yi/fa/5t/yifa5tx6chfyxf2c26zeak-kaeu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika teksnya sangat pendek dan pesan diteruskan, ada ruang kosong di sebelah kanan. </font><font style="vertical-align: inherit;">Tidak ada jalan keluar dari ini, karena kinerja lebih penting. </font><font style="vertical-align: inherit;">Selama beberapa tahun, tidak ada keluhan - mungkin seseorang memperhatikan, tetapi secara umum, semua orang terbiasa dengan itu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/mz/0l/qbmz0lzz-o_lvhongodanb3fh1m.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada kasus tepi. </font><font style="vertical-align: inherit;">Jika kami menanggapi pesan dengan stiker, maka kami dapat menentukan lebar khusus untuk kasus tersebut, sehingga terlihat lebih cantik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami berpisah menjadi ViewHolders pada tahap memuat pesan: kami mulai memuat latar belakang pesan, mengubahnya menjadi item, mereka langsung ditampilkan di ViewHolders.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/12/w_/x7/12w_x7wp4a4a4s5f_dqeqrevlbc.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Global RecycledViewPool</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme menggunakan messenger kita sedemikian rupa sehingga orang tidak duduk dalam obrolan yang sama, tetapi terus-menerus pergi di antara mereka. </font><font style="vertical-align: inherit;">Dalam pendekatan standar, ketika kami masuk ke obrolan dan meninggalkannya, RecycledViewPool (dan ViewHolder di dalamnya) dihancurkan, dan setiap kali kami menghabiskan sumber daya menciptakan ViewHolder. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini dapat dipecahkan oleh global RecycledViewPool:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam kerangka Aplikasi, RecycledViewPool hidup sebagai singleton;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan kembali pada layar pesan ketika pengguna berjalan di antara layar;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atur sebagai RecyclerView.setRecycledViewPool (pool).</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada jebakan, penting untuk mengingat dua hal:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda pergi ke layar, klik kembali, keluar. </font><font style="vertical-align: inherit;">Masalahnya adalah bahwa ViewHolders yang ada di layar dibuang, dan tidak dikembalikan ke kolam. </font><font style="vertical-align: inherit;">Ini diperbaiki sebagai berikut:</font></font><br>
<pre><code class="java hljs">LinearLayoutManager.recycleChildrenOnDetach = <span class="hljs-keyword">true</span></code></pre></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RecycledViewPool memiliki batasan: tidak lebih dari lima ViewHolders yang dapat disimpan untuk setiap tipe tampilan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika 9 TextViews ditampilkan di layar, hanya lima item yang akan dikembalikan ke RecycledViewPool, dan sisanya akan dibuang. </font><font style="vertical-align: inherit;">Anda dapat mengubah ukuran RecycledViewPool: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RecycledViewPool.setMaxRecycledViews (viewType, size) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi entah bagaimana sedih untuk meresepkan setiap ViewType dengan tangan Anda, karena Anda dapat menulis RecycledViewPool Anda, memperluas yang standar, dan menjadikannya NoLimit. </font><font style="vertical-align: inherit;">Dengan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda dapat mengunduh implementasi yang telah selesai.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesulitan tidak selalu berguna</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah kasing klasik - unduh, putar trek audio, dan pesan suara. </font><font style="vertical-align: inherit;">Dalam hal ini, DiffUtil memanggil spam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ho/3o/lt/ho3oltgo6763hgc65xxel-ccopa.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BaseViewHolder kami memiliki metode pemutakhiranUploadProgress abstrak.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseViewHolder</span> : <span class="hljs-title">ViewHolder</span> </span>{<font></font>
    …<font></font>
    <span class="hljs-function">fun <span class="hljs-title">updateUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span>
    …        
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengadakan acara, kita perlu melewati semua ViewHolder yang terlihat:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">fun <span class="hljs-title">onUploadProgress</span><span class="hljs-params">(attachId: Int, progress: Float)</span> </span>{<font></font>
    forEachActiveViewHolder {<font></font>
        it.updateUploadProgress(attachId, progress)<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah operasi yang sederhana, tidak mungkin kita memiliki lebih dari sepuluh ViewHolder di layar. </font><font style="vertical-align: inherit;">Pendekatan seperti itu tidak bisa ketinggalan pada prinsipnya. </font><font style="vertical-align: inherit;">Bagaimana menemukan ViewHolder yang terlihat? </font><font style="vertical-align: inherit;">Implementasi yang naif akan seperti ini:</font></font><br>
<br>
<pre><code class="java hljs">val firstVisiblePosition = &lt;...&gt;<font></font>
val lastVisiblePosition = &lt;...&gt;<font></font>
<span class="hljs-keyword">for</span> (i in firstVisiblePosition.. lastVisiblePosition) {<font></font>
    val viewHolder = recycler.View.findViewHolderForAdapterPosition(i)<font></font>
    viewHolder.updateUploadProgress(..)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi ada masalah. </font><font style="vertical-align: inherit;">Cache antara yang saya sebutkan sebelumnya, ItemViewCache, berisi ViewHolders aktif yang tidak muncul di layar. </font><font style="vertical-align: inherit;">Kode di atas tidak akan memengaruhi mereka. </font><font style="vertical-align: inherit;">Secara langsung, kami juga tidak bisa mengatasinya. </font><font style="vertical-align: inherit;">Dan kemudian kruk membantu kami. </font><font style="vertical-align: inherit;">Buat WeakSet yang menyimpan tautan ke ViewHolder. </font><font style="vertical-align: inherit;">Selanjutnya cukup bagi kita untuk hanya memotong WeakSet ini.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> : <span class="hljs-title">RecyclerView</span>.<span class="hljs-title">Adapter</span> </span>{<font></font>
    val activeViewHolders = WeakSet&lt;ViewHolder&gt;()<font></font>
        <font></font>
    <span class="hljs-function">fun <span class="hljs-title">onBindViewHolder</span><span class="hljs-params">(holder: ViewHolder, position: Int)</span> </span>{<font></font>
        activeViewHolders.add(holder)<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">onViewRecycled</span><span class="hljs-params">(holder: ViewHolder)</span> </span>{<font></font>
        activeViewHolders.remove(holder)<font></font>
    }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hamparan ViewHolder</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan contoh cerita. Sebelumnya, jika seseorang bereaksi terhadap sebuah cerita dengan stiker, kami menampilkannya seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/rc/kd/z1/rckdz16ebmfwftxzfpql2lwmsko.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu terlihat sangat jelek. Saya ingin melakukan yang lebih baik, karena ceritanya sangat menarik, dan kami memiliki kotak kecil di sana. Tapi kami ingin mendapatkan sesuatu seperti ini: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vj/ma/51/vjma51z9m4eqwlhiagc7xvu2kg0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah: pesan kami dipecah menjadi ViewHolder, mereka terletak di bawah satu sama lain, tetapi di sini mereka tumpang tindih. Segera tidak jelas bagaimana menyelesaikannya. Anda dapat membuat ViewType lainnya "riwayat + stiker" atau "riwayat + pesan suara". Jadi, alih-alih 70 ViewType, kita akan memiliki 140 ... Tidak, kita perlu membuat sesuatu yang lebih nyaman.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/01/mr/5j/01mr5jqsfdpq_zcq4s3b-vf9pyq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu kruk favorit Anda di Android muncul di benak Anda. </font><font style="vertical-align: inherit;">Misalnya, kami melakukan sesuatu, tetapi Pixel Perfect tidak bertemu. </font><font style="vertical-align: inherit;">Untuk mengatasinya, Anda harus menghapus semuanya dan menulis dari awal, tetapi kemalasan. </font><font style="vertical-align: inherit;">Sebagai hasilnya, kita dapat membuat margin = -2dp (negatif), dan sekarang semuanya masuk ke tempatnya. </font><font style="vertical-align: inherit;">Tetapi pendekatan seperti itu tidak bisa digunakan di sini. </font><font style="vertical-align: inherit;">Jika Anda menetapkan margin negatif, stiker akan bergerak, tetapi tempat yang ditempati akan tetap kosong. </font><font style="vertical-align: inherit;">Tapi kami memiliki ItemDecoration, di mana itemOffset kami dapat membuat angka negatif. </font><font style="vertical-align: inherit;">Dan itu berhasil! </font><font style="vertical-align: inherit;">Akibatnya, kami mendapatkan hamparan yang diharapkan dan pada saat yang sama masih ada paradigma di mana setiap ViewHolder adalah teman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi yang indah dalam satu baris.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffsetItemDecoration</span> : <span class="hljs-title">RecyclerViewItemDecoration</span>() </span>{
    <span class="hljs-function">overrride fun <span class="hljs-title">getItemOffsets</span><span class="hljs-params">(offset: Rect, …)</span> </span>{<font></font>
        offset.top = -<span class="hljs-number">100</span>dp<font></font>
    }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idlehandler</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah kasus dengan tanda bintang, itu kompleks dan tidak begitu sering diperlukan dalam praktik, tetapi penting untuk mengetahui tentang keberadaan metode semacam itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, saya akan memberi tahu Anda bagaimana utas utama UiThread bekerja. Skema umum: ada antrian acara tugas di mana tugas ditetapkan melalui handler.post, dan loop tak terbatas yang melewati antrian ini. Yaitu, UiThread hanya sementara (benar). Jika ada tugas, kami menjalankannya, jika tidak, kami menunggu sampai tugas itu muncul.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y3/ee/nn/y3eennjezxs29i4lkbvggnqkgjw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam realitas kita yang biasa, Handler bertanggung jawab untuk menempatkan tugas ke dalam antrian, dan Looper tanpa henti melewati antrian. </font><font style="vertical-align: inherit;">Ada tugas yang tidak terlalu penting untuk UI. </font><font style="vertical-align: inherit;">Misalnya, pengguna membaca pesan - tidak begitu penting bagi kami ketika kami menampilkannya di UI, sekarang atau setelah 20 ms. </font><font style="vertical-align: inherit;">Pengguna tidak akan melihat perbedaannya. </font><font style="vertical-align: inherit;">Lalu, mungkin layak menjalankan tugas ini di utas utama hanya saat gratis? </font><font style="vertical-align: inherit;">Artinya, alangkah baiknya bagi kita untuk mengetahui kapan garis awaitNewTask dipanggil. </font><font style="vertical-align: inherit;">Untuk kasus ini, Looper memiliki addIdleHandler yang menyala ketika kode task.isEmpty diaktifkan. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Looper.myQueue (). AddIdleHandler ()</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dan implementasi IdleHandler yang paling sederhana akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@AnyThread</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleHandler</span> </span>{
    <span class="hljs-keyword">private</span> val handler = Handler(Looper.getMainLooper())<font></font>
<font></font>
    <span class="hljs-function">fun <span class="hljs-title">post</span><span class="hljs-params">(task: Runnable)</span> </span>{<font></font>
        handler.post {<font></font>
            Looper.myQueue().addIdleHandler {<font></font>
                task.run()<font></font>
                <span class="hljs-keyword">return</span><span class="hljs-meta">@addIdleHandler</span> <span class="hljs-keyword">false</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan cara yang sama, Anda dapat mengukur awal yang dingin dari aplikasi ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emoji</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menggunakan emoji khusus kami alih-alih yang sistem. Berikut adalah contoh bagaimana emoji terlihat pada platform berbeda di tahun yang berbeda. Emoji kiri dan kanan cukup bagus, tetapi di tengah ... </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bv/71/m3/bv71m3d7rginefvtev6ogcgwess.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah kedua: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/dw/-1/nx/dw-1nxxjfpggaxcjo_-idb0ofce.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap baris adalah emoji yang sama, tetapi emosi yang mereka hasilkan berbeda. Saya paling suka bagian kanan bawah, saya masih tidak mengerti apa artinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada sepeda dari VKontakte. Di ~ 2014, kami sedikit mengubah satu emoji. Mungkin seseorang ingat - "Marshmallow" tadi. Setelah perubahannya, kerusuhan kecil dimulai. Tentu saja, dia tidak mencapai level "kembalilah ke tembok", tetapi reaksinya cukup menarik. Dan ini memberitahu kita tentang pentingnya menafsirkan emoji.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana emoji dibuat: kita memiliki bitmap besar, di mana mereka semua dikumpulkan dalam satu "atlas" besar. </font><font style="vertical-align: inherit;">Ada beberapa dari mereka - di bawah DPI berbeda. </font><font style="vertical-align: inherit;">Dan ada EmojiSpan yang berisi informasi: Saya menggambar emoji "ini-dan-itu", itu berada dalam bitmap ini-dan-itu di lokasi ini-dan-itu (x, y). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ada ReplacementSpan yang memungkinkan Anda untuk menampilkan sesuatu, bukan teks di bawah Span. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, Anda menemukan emoji dalam teks, membungkusnya dengan EmojiSpan, dan sistem menggambar emoji yang diinginkan daripada sistem satu.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/y5/tq/agy5tq5wl0ys8vbwuqgwhpfeoli.png"><a name="alt"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alternatif</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memompa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seseorang mungkin mengatakan bahwa karena mengembang lambat, mengapa tidak hanya membuat tata letak dengan tangan Anda, menghindari mengembang. </font><font style="vertical-align: inherit;">Dan dengan demikian mempercepat semuanya dengan menghindari 100500 ViewHolder. </font><font style="vertical-align: inherit;">Itu hanya khayalan. </font><font style="vertical-align: inherit;">Sebelum Anda melakukan sesuatu, ada baiknya mengukurnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Android memiliki kelas Debug, ia memiliki startMethodTracing dan stopMethodTracing.</font></font><br>
<br>
<pre><code class="java hljs">Debug.startMethodTracing(“trace»)<font></font>
inflate(...)<font></font>
Debug.stopMethodTracing()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini akan memungkinkan kami untuk mengumpulkan informasi tentang waktu eksekusi potongan kode tertentu. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ea/hz/wa/eahzwatykq-cflwr2ul3qnwbvq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kita melihat bahwa di sini mengembang seperti itu bahkan tidak terlihat. </font><font style="vertical-align: inherit;">Seperempat dari waktu dihabiskan memuat gambar, seperempatnya memuat warna. </font><font style="vertical-align: inherit;">Dan hanya di suatu tempat di bagian dll yang mengembang kami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mencoba menerjemahkan tata letak XML ke dalam kode dan menyimpan sekitar 0,5 ms. </font><font style="vertical-align: inherit;">Sebenarnya, peningkatan itu bukan yang paling mengesankan. </font><font style="vertical-align: inherit;">Dan kodenya menjadi jauh lebih rumit. </font><font style="vertical-align: inherit;">Artinya, menulis ulang tidak masuk akal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, dalam praktiknya, banyak yang tidak akan menemui masalah ini sama sekali, karena inflasi yang lama biasanya terjadi hanya ketika aplikasi menjadi sangat besar. </font><font style="vertical-align: inherit;">Dalam aplikasi VKontakte kami, misalnya, ada sekitar 200-300 layar berbeda, dan pemuatan semua sumber daya macet. </font><font style="vertical-align: inherit;">Apa yang harus dilakukan dengan ini masih belum jelas. </font><font style="vertical-align: inherit;">Kemungkinan besar, Anda harus menulis manajer sumber daya Anda sendiri.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anko</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anko baru-baru ini menjadi usang. </font><font style="vertical-align: inherit;">Bagaimanapun, Anko bukanlah sihir, tetapi gula sintaksis sederhana. </font><font style="vertical-align: inherit;">Ini menerjemahkan semuanya ke View baru bersyarat () dengan cara yang sama. </font><font style="vertical-align: inherit;">Karena itu, tidak ada manfaat dari Anko.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Litho / Bergetar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa saya menggabungkan dua hal yang sama sekali tidak terkait? </font><font style="vertical-align: inherit;">Karena ini bukan tentang teknologi, tetapi tentang kompleksitas migrasi ke sana. </font><font style="vertical-align: inherit;">Anda tidak bisa hanya meminjam dan pindah ke perpustakaan baru. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak jelas apakah ini akan memberi kita peningkatan kinerja. </font><font style="vertical-align: inherit;">Dan kami tidak akan mendapatkan masalah baru, karena jutaan orang dengan perangkat yang sangat berbeda menggunakan aplikasi kami setiap menit (Anda mungkin belum pernah mendengar tentang seperempat dari mereka). </font><font style="vertical-align: inherit;">Selain itu, pesan adalah basis kode yang sangat besar. </font><font style="vertical-align: inherit;">Tidak mungkin untuk menulis ulang semuanya secara instan. </font><font style="vertical-align: inherit;">Dan melakukannya karena hype teknologi itu bodoh. </font><font style="vertical-align: inherit;">Terutama ketika Jetpack Compose tampak di suatu tempat yang jauh.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menulis Jetpack</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Google semua menjanjikan kita manna dari surga dalam bentuk perpustakaan ini, tetapi masih dalam alfa. </font><font style="vertical-align: inherit;">Dan kapan akan di rilis - tidak jelas. </font><font style="vertical-align: inherit;">Apakah kita bisa mendapatkannya dalam bentuk saat ini juga tidak jelas. </font><font style="vertical-align: inherit;">Masih terlalu dini untuk bereksperimen. </font><font style="vertical-align: inherit;">Biarkan keluar dengan stabil, biarkan bug utama tutup. </font><font style="vertical-align: inherit;">Dan baru kemudian kita akan melihat ke arahnya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu Tampilan Kustom Besar</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada pendekatan lain yang dibicarakan oleh para pengirim pesan instan: "ambil dan tulis satu Tampilan Kustom yang besar, tidak ada hierarki yang rumit." </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa kerugiannya?</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sulit dipertahankan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itu tidak masuk akal dalam kenyataan saat ini.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan Android 4.3, sistem caching internal di dalam View dipompa. </font><font style="vertical-align: inherit;">Misalnya, onMeasure tidak dipanggil jika tampilan tidak berubah. </font><font style="vertical-align: inherit;">Dan hasil pengukuran sebelumnya digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan Android 4.3-4.4, RenderNode (DisplayList) muncul, render caching. </font><font style="vertical-align: inherit;">Mari kita lihat sebuah contoh. </font><font style="vertical-align: inherit;">Misalkan ada sel dalam daftar dialog: avatar, judul, subtitle, status baca, waktu, avatar lain. </font><font style="vertical-align: inherit;">Persyaratan - 10 elemen. </font><font style="vertical-align: inherit;">Dan kami menulis Tampilan Kustom. </font><font style="vertical-align: inherit;">Dalam hal ini, ketika mengubah satu properti, kami akan mengukur ulang semua elemen. </font><font style="vertical-align: inherit;">Artinya, hanya menghabiskan sumber daya tambahan. </font><font style="vertical-align: inherit;">Dalam kasus ViewGroup, di mana setiap elemen adalah Tampilan terpisah, ketika Anda mengubah satu Tampilan, kami hanya akan membatalkan satu Tampilan (kecuali bila Tampilan ini memengaruhi ukuran yang lain).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, Anda telah belajar bahwa kami menggunakan RecyclerView klasik dengan optimisasi standar. Ada bagian yang tidak standar, di mana yang paling penting dan mendasar adalah membagi pesan menjadi ViewHolder. Tentu saja, Anda dapat mengatakan bahwa ini berlaku secara sempit, tetapi pendekatan ini juga dapat diproyeksikan ke hal-hal lain, misalnya, pada teks besar 10 ribu karakter. Ini dapat dibagi menjadi paragraf, di mana setiap paragraf adalah ViewHolder terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini juga layak memaksimalkan segala sesuatu di @WorkerThread: tautan parsing, DiffUtils - dengan demikian membongkar @UiThead sebanyak mungkin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Global RecycledViewPool memungkinkan Anda berjalan di antara layar pesan dan tidak membuat ViewHolder setiap kali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi ada hal-hal penting lainnya yang belum kami putuskan, misalnya, inflasi yang lama, atau lebih tepatnya, memuat data dari sumber daya.</font></font><br>
<br>
<blockquote>    ,   Mobius 2019 Piter  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>,     .     ,     ,  SQLite,     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mobius 2020 Piter</a>     .</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id501978/index.html">Bagaimana cara kerja histogram Prometheus?</a></li>
<li><a href="../id501980/index.html">Sejarah satu proyek atau bagaimana saya membuat 7 tahun PBX berdasarkan Asterisk dan Php</a></li>
<li><a href="../id501982/index.html">Cara mentransfer shader dari mesin game ke Substance Painter</a></li>
<li><a href="../id501984/index.html">Apa yang harus dilihat di karantina? Pilihan bahan dari Technostream (bagian 4)</a></li>
<li><a href="../id501986/index.html">Rahasia kesuksesan Apple AirPods yang luar biasa</a></li>
<li><a href="../id501990/index.html">Pos yang berguna: 4 acara untuk menyelesaikan masalah hari kedua di OpenShift dan membuat operator</a></li>
<li><a href="../id501992/index.html">Bagaimana mengatur pengujian untuk mempercepat dan menstabilkan rilis produk. Bagian 1</a></li>
<li><a href="../id501994/index.html">Orchestrator untuk MySQL: mengapa proyek gagal-aman tidak dapat dibangun tanpanya</a></li>
<li><a href="../id501996/index.html">Zen Go (Versi Saku)</a></li>
<li><a href="../id501998/index.html">Harga gaya mahal. Laporan Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>