<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§∑üèº üåü ü•£ Usando a biblioteca OpenCV para reconhecer arcos el√≠pticos em se√ß√µes 2D de nuvens de pontos 3D üè¶ üóΩ üíµ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Em conex√£o com a ampla gama de scanners a laser acess√≠veis (lidares) capazes de receber nuvens de pontos 3D ( 3dOT ) e a aplica√ß√£o mais ampla dessa te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Usando a biblioteca OpenCV para reconhecer arcos el√≠pticos em se√ß√µes 2D de nuvens de pontos 3D</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em conex√£o com a ampla gama de scanners a laser acess√≠veis (lidares) capazes de receber nuvens de pontos 3D ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) e a aplica√ß√£o mais ampla dessa tecnologia em v√°rios campos (da engenharia mec√¢nica √† seguran√ßa, da ind√∫stria do petr√≥leo √† arquitetura), o interesse pelos algoritmos de processamento foi revivido nuvens de pontos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma das aplica√ß√µes populares do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na ind√∫stria √© a cria√ß√£o de documenta√ß√£o de projeto apenas para equipamentos constru√≠dos, antigos ou convertidos, que geralmente consistem em tubula√ß√µes e outras estruturas de geometria cil√≠ndrica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para detectar primitivas geom√©tricas no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , geralmente s√£o usadas bibliotecas 3D especializadas, por exemplo, </font><em><font style="vertical-align: inherit;">Microsoft PCL</font></em><font style="vertical-align: inherit;"> .</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. A abordagem com o uso de bibliotecas prontas, al√©m de vantagens, apresenta desvantagens. Por exemplo, √© dif√≠cil incorpor√°-los aos esquemas de processamento Kadov existentes, que geralmente t√™m uma dimens√£o 2D. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos considerar como seria poss√≠vel processar o </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por exemplo, uma esta√ß√£o de bombeamento, come√ßando com se√ß√µes 2D e usando todo o arsenal de processamento 2D, dispon√≠vel em bibliotecas confi√°veis ‚Äã‚Äãe otimizadas de processamento de imagem, por exemplo, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 1. Modelo 3D OT de uma esta√ß√£o de bombeamento</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O principal elemento das se√ß√µes obtidas pela varredura de v√°rias estruturas de tubos s√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arcos el√≠pticos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 2. Se√ß√£o transversal horizontal de um modelo 3D de uma esta√ß√£o de bombeamento em um n√≠vel m√©dio.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para este artigo, restringimos nossa considera√ß√£o a um algoritmo chave que nos permite detectar arcos el√≠pticos arbitr√°rios - este √© um algoritmo iterativo para o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crescimento de segmentos de arco e liga√ß√£o de </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regi√£o</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><em><font style="vertical-align: inherit;">crescimento de regi√£o e liga√ß√£o de borda</font></em><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os algoritmos de crescimento s√£o os mais √≥bvios e facilmente verific√°veis, embora demorados em compara√ß√£o com os algoritmos estat√≠sticos, que s√£o mais adequados para o caso em que a cena cont√©m objetos distantes e fracamente acoplados que pertencem a uma elipse. </font><font style="vertical-align: inherit;">Esses algoritmos ser√£o discutidos em artigos futuros.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por enquanto, por simplicidade, omitimos o procedimento para obter uma se√ß√£o do arquivo </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> origem </font><font style="vertical-align: inherit;">, pr√©-processando uma se√ß√£o, agrupando-a para isolar primitivas geom√©tricas, bem como opera√ß√µes subsequentes de liga√ß√£o, retifica√ß√£o e outras opera√ß√µes fotogram√©tricas necess√°rias para obter os par√¢metros do modelo. N√£o discutiremos a parametriza√ß√£o de algoritmos de pesquisa heur√≠stica da mesma maneira. Vamos descrever todas as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opera√ß√µes b√°sicas a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> partir das quais o algoritmo √© constru√≠do. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assumimos que precisamos detectar (reconhecer, classificar) um arco el√≠ptico (isto √©, calcular os par√¢metros da elipse, bem como o √¢ngulo inicial e final do arco el√≠ptico) nesta imagem, cortados na se√ß√£o horizontal da nuvem de pontos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 3. Um dos arcos el√≠pticos da se√ß√£o transversal do modelo 3D (ap√≥s suaviza√ß√£o)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fim de minimizar o trabalho com a varredura √†s cegas, realizaremos todas as opera√ß√µes com a varredura atrav√©s do </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esbo√ßo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedimento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findCours do </font></font></em><font style="vertical-align: inherit;"><em><font style="vertical-align: inherit;">OpenCV</font></em><font style="vertical-align: inherit;"> localiza no raster </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> todos os </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contornos</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> externos (sem formas internas) </font><font style="vertical-align: inherit;">na forma de um vetor de vetores de pontos inteiros (em coordenadas raster):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© a nossa opera√ß√£o principal, que em alguns casos simples </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolve completamente a tarefa</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Por√©m, como nem sempre s√£o encontrados casos degenerados, vamos considerar com mais detalhes a tecnologia de processamento atrav√©s do contorno. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A opera√ß√£o reversa, gerando uma varredura de acordo com o circuito externo existente usando a </font><font style="vertical-align: inherit;">fun√ß√£o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tamb√©m parece simples:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamb√©m √© frequentemente usado para mascarar contornos, desenhar ou calcular √°reas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, no est√°gio inicial, temos um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjunto de remendos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pe√ßas de uma determinada curva) que precisam ser conectados a um arco el√≠ptico, eliminando partes de outros componentes da estrutura (por exemplo, fixadores) ou ru√≠do √≥ptico causado por sombras durante a digitaliza√ß√£o e outras raz√µes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos criar uma </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√£o discriminante</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> que retornar√° o tipo de contorno (elipse, segmento linear, hachura ou outra coisa), bem como os pontos finais do contorno e seu ret√¢ngulo de contorno girado:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A propor√ß√£o do comprimento e largura do ret√¢ngulo ajuda a discriminar rapidamente contornos pr√≥ximos a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segmentos lineares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , bem como pequenos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contornos de ru√≠do</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O ret√¢ngulo girado no </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possui um </font><font style="vertical-align: inherit;">sistema de coordenadas </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">complexo</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Se n√£o √© o pr√≥prio √¢ngulo que √© necess√°rio, mas suas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fun√ß√µes trigonom√©tricas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , √© mais ou menos √≥bvio do contexto. Se o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valor absoluto do √¢ngulo for usado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , deve-se </font><font style="vertical-align: inherit;">levar </font><font style="vertical-align: inherit;">em considera√ß√£o que o </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√¢ngulo √© contado da horizontal at√© a primeira aresta do ret√¢ngulo no sentido anti-hor√°rio e tem um valor negativo</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Os pontos finais dos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contornos el√≠pticos s√£o encontrados usando nosso procedimento, que recebe o raster </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">com um contorno discriminado extra√≠do da imagem original mascarando e retornando o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defeito m√°ximo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, ‚Ä¶ );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo principal para esta fun√ß√£o √© chamar dois procedimentos </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O primeiro procedimento encontra um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pol√≠gono convexo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o contorno em estudo, o segundo - calcula todos os </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defeitos de convexidade</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tomamos apenas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o maior</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> defeito em termos de convexidade, considerando que ele determina os pontos finais do contorno. Pode n√£o ser esse o caso se os limites externos ou internos do contorno tiverem </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recursos</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suaviz√°-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> los </font><font style="vertical-align: inherit;">, aplicamos suaviza√ß√£o adicional ao contorno em estudo (e n√£o √† imagem inteira, para n√£o "emba√ßar" os istmuses entre os contornos e n√£o violar a topologia original). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 4. C√°lculo do defeito de protuber√¢ncia A </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√ß√£o (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> define erroneamente o ponto final vermelho. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Op√ß√£o (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">define corretamente os pontos de extremidade. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A op√ß√£o (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> redefine os pontos finais na forma original. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como na tecnologia adotada, o circuito √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regenerado a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cada vez </font><font style="vertical-align: inherit;">, √© preciso procurar novamente os pontos de correspond√™ncia (ou melhor, seus √≠ndices) pelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exaustivo</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> procedimento de </font><i><font style="vertical-align: inherit;">busca</font></i><font style="vertical-align: inherit;"> :</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos casos em que n√£o √© poss√≠vel se livrar completamente dos recursos, tamb√©m foi implementado um modo adicional de </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">separa√ß√£o</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font><u><font style="vertical-align: inherit;">arco</font></u><font style="vertical-align: inherit;"> (trabalhe separadamente com o arco interno / externo). Isso √© importante, por exemplo, nos casos em que o arco externo do contorno est√° em </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contato</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> com outros objetos ou √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barulhento</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Nesse caso, voc√™ pode trabalhar com o arco interno. Nesse caso, n√£o √© necess√°rio processar os arcos externo e interno separadamente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, de acordo com a f√≥rmula conhecida para a raz√£o da </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convexidade do arco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">raio do</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> c√≠rculo </font><font style="vertical-align: inherit;">√© estimado aproximadamente </font><font style="vertical-align: inherit;">e elipses muito grandes s√£o rejeitadas:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Assim, para todos os contornos, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">foi</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> encontrada sua </font><i><font style="vertical-align: inherit;">m√©trica de defeito de convexidade</font></i><font style="vertical-align: inherit;"> (ou s√£o classificados como lineares ou pequenos e removidos do procedimento). </font><font style="vertical-align: inherit;">No √∫ltimo est√°gio, par√¢metros adicionais s√£o adicionados √† m√©trica inicial, como o par√¢metro de dimens√£o girada, etc., e o conjunto completo das m√©tricas estudadas √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ordenado por tamanho</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo para vincular segmentos de arco nos pontos finais</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O algoritmo de crescimento √© claro e √≥bvio: pegamos o maior contorno como </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">semente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e tentamos cultiv√°-lo, ou seja, encontramos e anexamos os patches mais pr√≥ximos aos seus pontos finais que satisfazem as condi√ß√µes de crescimento. Na figura adulta, inserimos o </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arco el√≠ptico desejado</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mascarar e </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtrair a</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> figura do conjunto original. Repetimos o procedimento de crescimento </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at√© que o conjunto inicial acabe</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O procedimento b√°sico do algoritmo de crescimento √© assim:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
onde </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contorno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o contorno em estudo, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© seu defeito de convexidade, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">casco</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o pol√≠gono convexo de toda a regi√£o, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© a matriz de buffer auxiliar. Na sa√≠da, obtemos um contorno de vetor aumentado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O procedimento consiste em um ciclo de tentativas de semear o crescimento, terminando esgotando os patches dispon√≠veis para o crescimento ou limitados pelo </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√¢metro do n√∫mero m√°ximo de itera√ß√µes</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 5. Muitas amostras para crescimento sem semente A</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
principal dificuldade √© selecionar as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amostras mais pr√≥ximas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aos pontos finais do contorno, para que a figura cres√ßa apenas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para a frente</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dire√ß√£o tangencial</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomamos a linha m√©dia pertencente ao arco nas proximidades do ponto final. Na </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 6, s√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exibidos os candidatos √† conex√£o com a semente em uma determinada itera√ß√£o. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 6. Sementes cercadas por uma pluralidade de amostras candidatas a crescimento</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Para cada amostra candidata, √© calculada a seguinte m√©trica:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somente manchas que caem no </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cone tangencial s√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> levadas em considera√ß√£o </font><font style="vertical-align: inherit;">. Em seguida, o patch com a menor dist√¢ncia √© selecionado e, imprimindo a se√ß√£o de conex√£o na varredura, se </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conecta</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √† extremidade correspondente da semente. Para a outra extremidade da semente, √© pesquisado um patch correspondente aos par√¢metros e, se encontrado, tamb√©m √© conectado √† semente. Em seguida, a semente √© </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mascarada e subtra√≠da</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dos muitos fragmentos. O procedimento √© repetido desde o in√≠cio. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao final do processo de crescimento, obtivemos um </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arco el√≠ptico</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que ainda </font><font style="vertical-align: inherit;">precisa </font><font style="vertical-align: inherit;">ser verificado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para come√ßar, use o </font><i><font style="vertical-align: inherit;">OpenCV</font></i><font style="vertical-align: inherit;"> padr√£o</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o procedimento que nosso patch recebe (na forma de um caminho, lembramos que o caminho e a varredura s√£o intercambi√°veis ‚Äã‚Äãconosco) e retorna a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dimens√£o girada</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ou seja, uma elipse completa.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em seguida, rejeitamos elipses muito grandes e muito pequenas e aplicamos nosso procedimento original para </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comparar as √°reas do</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> arco el√≠ptico resultante e o fragmento inicial de crescimento na </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forma de varredura</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Este procedimento inclui alguns truques disfar√ßados, portanto omitiremos sua descri√ß√£o por enquanto. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, finalmente, encontramos os par√¢metros restantes da elipse detectada - os </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√¢ngulos de in√≠cio e fim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (j√° conhecemos os semi-eixos do </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fitEllipse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para determinar os √¢ngulos inicial e final, procedemos da seguinte forma: transformamos nossa elipse completa, de </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volta ao pol√≠gono</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font><i><font style="vertical-align: inherit;">,</font></i><font style="vertical-align: inherit;"> por enumera√ß√£o direta, encontramos seus pontos mais pr√≥ximos √†s nossas extremidades. Suas </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coordenadas angulares</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(de fato, √≠ndices) e ser√£o os √¢ngulos inicial e final de um arco el√≠ptico. </font><font style="vertical-align: inherit;">No c√≥digo, fica assim (um pouco simplificado):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nosso procedimento </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides leva</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> em considera√ß√£o a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">topologia</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> transversal do arco el√≠ptico. </font><font style="vertical-align: inherit;">No total, oito poss√≠veis casos de desvio dos √≠ndices </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> devem ser considerados </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Vamos ao longo do contorno externo ou interno e qual dos √≠ndices √© maior, inicial ou final? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais f√°cil de ver c√≥digo:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alguns resultados da detec√ß√£o de elipses em casos complexos s√£o mostrados na </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figura 7</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nos artigos a seguir, ser√£o considerados m√©todos de detec√ß√£o estat√≠stica.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt490386/index.html">De que outra forma ganhar dinheiro na bolsa de valores e reduzir o risco: a√ß√µes de empresas com pagamento de dividendos</a></li>
<li><a href="../pt490390/index.html">Olga Makushenko, diretora administrativa da 101XP: ‚Äú5 erros-chave no desenvolvimento de um jogo como empresa‚Äù</a></li>
<li><a href="../pt490392/index.html">Catchain: Algoritmo de consenso em TON Blockchain</a></li>
<li><a href="../pt490394/index.html">Comodoro Amiga 500+: ningu√©m fique ofendido</a></li>
<li><a href="../pt490398/index.html">Hogwarts vermelha. Oficiais, ou Por que um historiador √© como um detetive</a></li>
<li><a href="../pt490404/index.html">Por que e como o 5G mudar√° tudo: tecnologia, implementa√ß√£o em fases e base de elementos para equipamentos de assinantes</a></li>
<li><a href="../pt490406/index.html">Inexpressivelmente atraente: como criamos um haniot que n√£o pode ser exposto</a></li>
<li><a href="../pt490408/index.html">FreeBSD: –≥–æ—Ä–∞–∑–¥–æ –ª—É—á—à–µ GNU/Linux</a></li>
<li><a href="../pt490410/index.html">Neur√¥nios vivos e artificiais conectados via Internet</a></li>
<li><a href="../pt490416/index.html">V√≠deo da Palestra do Clube de Ci√™ncia da Computa√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>