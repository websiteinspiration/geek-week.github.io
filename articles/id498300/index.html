<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😀 🌂 🐽 Blitz.Engine: Sistem Aset 👩🏻‍🔧 🎋 🤹🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sebelum kita memahami bagaimana sistem aset Blitz. Mesin mesin bekerja , kita perlu memutuskan apa aset itu dan apa yang sebenarnya kita maksudkan den...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz.Engine: Sistem Aset</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498300/"><img src="https://habrastorage.org/webt/yk/rv/sv/ykrvsv2-nadxe5rvvs7gj8iw-9w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita memahami bagaimana sistem aset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blitz.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mesin mesin </font><b><font style="vertical-align: inherit;">bekerja</font></b><font style="vertical-align: inherit;"> , kita perlu memutuskan apa aset itu dan apa yang sebenarnya kita maksudkan dengan sistem aset. Menurut Wikipedia, aset game adalah objek digital, terutama terdiri dari data yang sama, entitas yang tidak dapat dibagi yang mewakili bagian dari konten game dan memiliki properti tertentu. Dari sudut pandang model program, aset dapat muncul sebagai objek yang dibuat pada beberapa kumpulan data. Aset dapat disimpan sebagai file terpisah. Pada gilirannya, sistem aset banyak kode program yang bertanggung jawab untuk memuat dan mengoperasikan berbagai jenis aset.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, sistem aset adalah bagian besar dari mesin permainan, yang dapat menjadi asisten setia bagi pengembang game atau mengubah hidup mereka menjadi neraka. </font><font style="vertical-align: inherit;">Menurut pendapat saya, keputusan logis adalah untuk memusatkan "neraka" ini di satu tempat, dengan hati-hati melindungi pengembang tim lain darinya. </font><font style="vertical-align: inherit;">Kami akan memberi tahu Anda apa yang kami lakukan dalam serangkaian artikel ini - ayo!</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel yang direncanakan pada topik:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pernyataan persyaratan dan tinjauan arsitektur</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Siklus Hidup Aset</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ikhtisar kelas AssetManager terperinci</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Integrasi dalam ECS</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GlobalAssetCache</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persyaratan dan Alasan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persyaratan sistem pemuatan aset lahir antara batu dan tempat yang keras. </font><font style="vertical-align: inherit;">Landasan adalah keinginan untuk melakukan sesuatu yang terlampir pada dirinya sendiri sehingga akan bekerja tanpa menulis kode eksternal. </font><font style="vertical-align: inherit;">Baik, atau hampir tanpa menulis kode eksternal. </font><font style="vertical-align: inherit;">Palu menjadi kenyataan. </font><font style="vertical-align: inherit;">Dan inilah yang akhirnya kami lakukan:</font></font><br>
<br>
<ol>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manajemen memori otomatis</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang berarti tidak perlu memanggil fungsi pelepasan untuk aset. </font><font style="vertical-align: inherit;">Yaitu, segera setelah semua objek eksternal menggunakan aset dihancurkan, aset dihancurkan. </font><font style="vertical-align: inherit;">Motivasi di sini sederhana - tulis lebih sedikit kode. </font><font style="vertical-align: inherit;">Lebih sedikit kode berarti lebih sedikit kesalahan.</font></font></li>
<li><i> <b></b>  </i>,           (    AssetManager’a).   ,      .   —      .       ,     «»    .<br>
    ,      ,       ().       —    ,  . ,     ,              .         ,      ,    .        ,   ,    .</li>
<li><i>   </i>      .  :        .         ,         .</li>
<li><i> (shared)  </i>. ,         .  ,    .           «» ,               .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prioritaskan pemuatan aset</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hanya ada 3 level prioritas: Tinggi, Sedang, Rendah. </font><font style="vertical-align: inherit;">Dalam prioritas yang sama, aset dimuat sesuai urutan permintaan. </font><font style="vertical-align: inherit;">Bayangkan sebuah situasi: seorang pemain mengklik "Untuk bertarung", dan pemuatan level dimulai. </font><font style="vertical-align: inherit;">Bersamaan dengan ini, tugas mempersiapkan sprite dari layar memuat masuk ke dalam antrian unduhan. </font><font style="vertical-align: inherit;">Tetapi karena beberapa aset level masuk ke antrian sebelum sprite, pemain melihat layar hitam untuk beberapa waktu.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, kami merumuskan aturan sederhana untuk diri kita sendiri: "Segala sesuatu yang dapat dilakukan pada utas AssetManager harus dilakukan pada utas AssetManager." </font><font style="vertical-align: inherit;">Misalnya, menyiapkan partisi lanskap dan tekstur normals berdasarkan peta ketinggian, menghubungkan program GPU, dll.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa detail implementasi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita mulai memahami cara kerja sistem pemuatan aset, kita perlu membiasakan diri dengan dua kelas yang banyak digunakan di Blitz. Mesin mesin:</font></font><br>
<br>
<ul>
<li><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: informasi runtime tentang beberapa jenis. </font><font style="vertical-align: inherit;">Tipe ini mirip dengan tipe </font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari bahasa C #, dengan pengecualian bahwa itu tidak menyediakan akses ke bidang dan metode tipe. </font><font style="vertical-align: inherit;">Berisi: ketikkan nama, sejumlah tanda suka </font></font><code>is_floating, is_pointer, is_const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dll. </font><font style="vertical-align: inherit;">Metode </font></font><code>Type::instance&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan konstanta dalam satu peluncuran aplikasi </font></font><code>const Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang memungkinkan Anda untuk melakukan pemeriksaan formulir</font></font><code>if (type == Type::instance&lt;T&gt;())</code></li>
<li><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: memungkinkan Anda untuk mengemas nilai jenis apa pun yang bergerak atau dapat disalin. </font><font style="vertical-align: inherit;">Pengetahuan tentang jenis apa yang dikemas </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">disimpan sebagai const </font></font><code>Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tahu cara menghitung hash menurut isinya, dan juga tahu cara membandingkan konten untuk kesetaraan. </font><font style="vertical-align: inherit;">Sepanjang jalan, ini memungkinkan Anda untuk melakukan konversi dari jenis saat ini ke yang lain. </font><font style="vertical-align: inherit;">Ini adalah semacam memikirkan kembali kelas apa pun dari perpustakaan standar atau meningkatkan perpustakaan.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua sistem pembebanan daftar aset didasarkan pada tiga kelas: </font></font><code>AssetManager, AssetBase, IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Namun, sebelum melanjutkan ke deskripsi kelas-kelas ini, harus dikatakan bahwa kode eksternal menggunakan alias </font></font><code>Asset&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dideklarasikan seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">Asset = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
di mana T adalah AssetBase atau jenis aset tertentu. Menggunakan shared_ptr di mana-mana, kami mencapai pemenuhan persyaratan nomor 1 (Manajemen memori otomatis). </font></font><br>
<br>
<code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah kelas terbatas yang tidak memiliki ahli waris. Kelas ini mendefinisikan siklus hidup suatu aset dan mengirimkan pesan tentang perubahan status aset. Itu juga </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyimpan pohon ketergantungan antara aset dan aset yang mengikat file pada disk, mendengarkan </font></font><code>FileWatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengimplementasikan pemuatan aset. Dan yang paling penting, </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">meluncurkan utas terpisah, mengimplementasikan antrian tugas untuk mempersiapkan aset, dan merangkum semua sinkronisasi dengan utas aplikasi lainnya (permintaan aset dapat dijalankan dari utas aplikasi apa pun, termasuk aliran unduhan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada saat yang sama </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beroperasi dengan aset abstrak</font></font><code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mendelegasikan tugas membuat dan memuat aset jenis tertentu ke ahli waris dari </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya akan memberi tahu Anda lebih banyak tentang bagaimana ini terjadi dalam artikel-artikel berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai bagian dari persyaratan nomor 4 (Pembagian aset), salah satu pertanyaan terpanas adalah "apa yang harus digunakan sebagai pengidentifikasi aset?" </font><font style="vertical-align: inherit;">Solusi paling sederhana dan tampaknya jelas adalah menggunakan jalur ke file yang akan diunduh. </font><font style="vertical-align: inherit;">Namun, keputusan ini membebankan sejumlah batasan serius:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk membuat aset, yang terakhir harus direpresentasikan sebagai file pada disk, yang menghilangkan kemampuan untuk membuat aset runtime berdasarkan aset lain.</font></font></li>
<li>    . ,    GPUProgram     (defines).      ,       .</li>
<li>         ,   .</li>
<li>        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak menganggap paragraf 3 dan 4 sebagai argumen di awal, karena bahkan tidak ada pemikiran bahwa ini mungkin berguna. Namun, fitur-fitur ini selanjutnya sangat memudahkan pengembangan editor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena itu, kami memutuskan untuk menggunakan kunci aset sebagai pengidentifikasi, yang pada level </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diwakili oleh jenisnya </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pewaris tahu </font><font style="vertical-align: inherit;">bagaimana menafsirkan </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Itu sendiri </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya tahu hubungan antara jenis kunci dan ahli waris </font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kode yang meminta aset biasanya tahu jenis aset apa yang dibutuhkan dan beroperasi dengan kunci jenis tertentu. Semuanya berjalan seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span>:</span> <span class="hljs-keyword">public</span> AssetBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PathKey</span>
    {</span><font></font>
        FilePath path;<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PathKey&amp; other);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryKey</span>
    {</span>
        u32 width = <span class="hljs-number">1</span>;<font></font>
        u32 height = <span class="hljs-number">1</span>;<font></font>
        u32 level_count = <span class="hljs-number">1</span>;<font></font>
        TextureFormat format = RBGA8;<font></font>
        TextureType type = TEX_2D;<font></font>
        <span class="hljs-function">Vector&lt;Vector&lt;u8*&gt;&gt; data</span>; <span class="hljs-comment">// Face&lt;MipLevels&lt;Image&gt;&gt;</span><font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MemoryKey&amp; other);<font></font>
    };<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureSerializer</span>:</span> <span class="hljs-keyword">public</span> IAssetSerializer<font></font>
{<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssetManager</span> <span class="hljs-title">final</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    Asset&lt;T&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;
    <span class="hljs-function">Asset&lt;AssetBase&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
   ...<font></font>
   <span class="hljs-function">Texture::PathKey <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-string">"/path_to_asset"</span>)</span></span>;<font></font>
   Asset&lt;Texture&gt; asset = asset_manager-&gt;get_asset&lt;Texture&gt;(key);<font></font>
   ...<font></font>
<font></font>
   Texture::MemoryKey mem_key;<font></font>
   mem_key.width = <span class="hljs-number">128</span>;<font></font>
   mem_key.format = <span class="hljs-number">128</span>;<font></font>
   mem_key.level_count = <span class="hljs-number">1</span>;<font></font>
   mem_key.format = A8;<font></font>
   mem_key.type = TEX_2D;<font></font>
   Vector&lt;u8*&gt;&amp; mip_chain = mem_key.data.emplace_back();<font></font>
   mip_chain.push_back(generage_sdf_font());<font></font>
   <font></font>
   Asset&lt;Texture&gt; sdf_font_texture = asset_manager-&gt;get_asset&lt;Texture&gt;(mem_key);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode </font></font><code>hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan operator pembanding di dalam </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diperlukan untuk memfungsikan operasi kelas yang sesuai </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi kami tidak akan membahasnya secara rinci. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, apa yang terjadi pada kode di atas: pada saat panggilan, </font></font><code>get_asset(key)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci akan disalin ke objek sementara dari tipe </font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang, pada gilirannya, akan diteruskan ke metode </font></font><code>get_asset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Selanjutnya, </font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ambil jenis kunci dari argumen. Dalam kasus kami, itu akan menjadi:</font></font><br>
<br>
<pre><code class="cpp hljs">Type::instance&lt;MyAsset::PathKey&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan tipe ini, ia akan menemukan objek serializer dan mendelegasikan ke serializer semua operasi selanjutnya (pembuatan dan pemuatan). </font></font><br>
<br>
<code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah kelas dasar untuk semua jenis aset di mesin. </font><font style="vertical-align: inherit;">Kelas ini menyimpan kunci aset, keadaan saat ini dari aset (dimuat, dalam antrian, dll.), Serta teks kesalahan jika pemuatan aset gagal. </font><font style="vertical-align: inherit;">Sebenarnya, struktur internal sedikit lebih rumit, tetapi kami akan mempertimbangkan ini bersama dengan siklus hidup aset. </font></font><br>
<br>
<code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, seperti namanya, adalah kelas dasar untuk entitas yang menyiapkan aset. </font><font style="vertical-align: inherit;">Bahkan, pewaris kelas ini tidak hanya memuat aset:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alokasi dan alokasi objek aset jenis tertentu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memuat aset dari jenis tertentu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyusun daftar jalur file berdasarkan aset yang dibangun. </font><font style="vertical-align: inherit;">Daftar ini diperlukan untuk mekanisme pemuatan aset saat file berubah. </font><font style="vertical-align: inherit;">Muncul pertanyaan: mengapa daftar jalur, dan bukan satu jalur? </font><font style="vertical-align: inherit;">Aset sederhana, seperti tekstur, dapat benar-benar dibangun berdasarkan satu file. </font><font style="vertical-align: inherit;">Namun, jika kita melihat shader, kita akan melihat bahwa reboot harus terjadi tidak hanya jika teks shader berubah, tetapi juga jika file yang terhubung ke shader diubah melalui include directive.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyimpan aset ke disk. </font><font style="vertical-align: inherit;">Ini digunakan secara aktif saat mengedit aset dan dalam mempersiapkan aset untuk game.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laporkan jenis kunci yang didukungnya.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan pertanyaan terakhir yang ingin saya bahas dalam kerangka artikel ini: mengapa Anda mungkin perlu memiliki beberapa jenis kunci untuk satu serializer / aset? </font><font style="vertical-align: inherit;">Mari kita bereskan pada gilirannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu serializer - beberapa jenis tombol</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita ambil contoh aset </font></font><code>GPUProgram</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(yaitu, shader). </font><font style="vertical-align: inherit;">Untuk memuat shader di mesin kami, informasi berikut diperlukan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Path ke file shader.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Daftar definisi preprosesor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tahap dimana shader dirangkai dan dikompilasi (vertex, fragmen, compute).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nama titik masuknya.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengumpulkan informasi ini bersama-sama, kita mendapatkan kunci shader, yang digunakan dalam game. Namun, selama pengembangan game atau mesin, seringkali perlu untuk menampilkan beberapa informasi debug pada layar, kadang-kadang dengan shader tertentu. Dan dalam situasi ini akan lebih mudah untuk menulis teks shader langsung dalam kode. Untuk melakukan ini, kita bisa mendapatkan tipe kunci kedua, yang alih-alih path ke file dan daftar definisi preprocessor akan berisi teks shader. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan contoh lain: tekstur. Cara termudah untuk membuat tekstur adalah dengan memuatnya dari disk. Untuk melakukan ini, kita perlu path ke file ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Tetapi kita juga dapat menghasilkan konten tekstur secara algoritmik dan membuat tekstur dari array byte ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Jenis kunci ketiga bisa menjadi kunci untuk membuat </font></font><code>RenderTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tekstur ( </font></font><code>RTKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bergantung pada jenis kuncinya, berbagai mesin rasterisasi mesin terbang dapat digunakan: stb (StbFontKey), FreeType (FTFontKet) atau generator font bidang tandatangan yang ditandatangani sendiri (SDFFontKey). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animasi keyframe dapat dimuat ( </font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) atau dihasilkan oleh kode ( </font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu aset - beberapa jenis kunci</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bayangkan bahwa kita memiliki </font></font><code>ParticleEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aset yang menjelaskan aturan untuk pembuatan partikel. Selain itu, kami memiliki editor yang nyaman untuk aset ini. Pada saat yang sama, editor level dan editor partikel adalah satu aplikasi multi-jendela. Ini nyaman karena Anda dapat membuka level, menempatkan sumber partikel di dalamnya dan melihat efeknya di lingkungan level, sambil mengedit efek itu sendiri. Jika kita memiliki satu jenis kunci, maka objek efek yang digunakan di dunia pengeditan efek dan di dunia level adalah satu dan sama. Semua perubahan yang dilakukan pada editor efek akan segera terlihat di tingkat. Pada pandangan pertama, ini mungkin tampak seperti ide yang keren, tetapi mari kita lihat skenario berikut ini:</font></font><br>
<br>
<ol>
<li>    ,   ,    ,    .   ,            . </li>
<li>-       ,    .        ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, sebuah situasi dimungkinkan di mana kami membuat dua jenis aset yang berbeda dari satu file pada disk menggunakan dua jenis kunci yang berbeda. </font><font style="vertical-align: inherit;">Menggunakan tipe "game" kunci, kami membuat struktur data yang dioptimalkan untuk kerja cepat dalam game. </font><font style="vertical-align: inherit;">Menggunakan tipe kunci "editorial", kami membuat struktur data yang nyaman untuk diedit. </font><font style="vertical-align: inherit;">Dengan cara ini, editor kami mengimplementasikan pengeditan </font></font><code>BlendTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk animasi kerangka. </font><font style="vertical-align: inherit;">Berdasarkan satu jenis kunci, sistem aset membangun kita sebuah aset dengan pohon jujur ​​di dalamnya dan banyak sinyal tentang perubahan topologi, yang sangat nyaman saat mengedit, tetapi agak lambat dalam permainan. </font><font style="vertical-align: inherit;">Menggunakan jenis kunci yang berbeda, serializer membuat jenis aset lain: aset tidak memiliki metode untuk mengubah pohon, dan pohon itu sendiri diubah menjadi array node, di mana tautan ke node adalah indeks dalam array.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epilog</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kesimpulannya, saya ingin memusatkan perhatian Anda pada solusi yang paling memengaruhi pengembangan mesin:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan struktur khusus sebagai kunci aset, bukan jalur file.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemuatan aset hanya dalam mode asinkron.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema yang fleksibel untuk mengelola pembagian aset (satu aset - beberapa jenis kunci).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemampuan untuk menerima aset dengan tipe yang sama menggunakan sumber data yang berbeda (mendukung beberapa jenis kunci dalam satu serializer).</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda akan belajar bagaimana tepatnya keputusan-keputusan ini memengaruhi penerapan kode internal dan eksternal di seri berikutnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penulis:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exmix</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id498290/index.html">Hidrologi prosedural: simulasi dinamis sungai dan danau</a></li>
<li><a href="../id498292/index.html">Hemat banyak uang untuk volume besar di PostgreSQL</a></li>
<li><a href="../id498294/index.html">Deteksi Objek Kenali dan aturankan. Bagian 1</a></li>
<li><a href="../id498296/index.html">Desain di tingkat sistem. Bagian 1. Dari ide ke sistem</a></li>
<li><a href="../id498298/index.html">Perusahaan menggunakan karunia bug untuk membeli keheningan peretas</a></li>
<li><a href="../id498302/index.html">Lisensi Lanjutan ILO. Mengapa itu dibutuhkan saat ini?</a></li>
<li><a href="../id498304/index.html">Mengotomatiskan Tugas Administrasi VMware vSphere API Menggunakan Ansible</a></li>
<li><a href="../id498308/index.html">Algoritma genetik python untuk menemukan ekstrema global</a></li>
<li><a href="../id498310/index.html">Tiga perangkap pembelajaran mesin dan cara menghindarinya</a></li>
<li><a href="../id498312/index.html">Pengembangan jaringan listrik pesawat terbang menggunakan desain berorientasi model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>