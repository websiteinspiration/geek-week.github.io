<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈🏿 🔒 ✋🏾 ZX Spectrum dari coronavirus and sticks (sebenarnya, tidak juga) 👴🏼 👂🏿 🔅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Isolasi diri adalah momok kemanusiaan modern. Di sini, misalnya, di kota tetangga, pada hari Jumat dan Sabtu, setelah bertepuk tangan tradisional pada...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ZX Spectrum dari coronavirus and sticks (sebenarnya, tidak juga)</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498222/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Isolasi diri adalah momok kemanusiaan modern. Di sini, misalnya, di kota tetangga, pada hari Jumat dan Sabtu, setelah bertepuk tangan tradisional pada pukul 8 malam, mereka menyelenggarakan konser balkon. Mereka merasa baik, rumah mereka tinggi dan tetangga mereka masih muda. Tetangga kami sudah tua, mereka tidak ingin konser. Dan rumah-rumahnya rendah, yang juga tidak berkontribusi pada kemalasan. Karena itu, kita diselamatkan semampu kita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sore hari, di situs terpencil, tidak terlalu buruk. Seperti pada malam hari, hingga anak-anak tertidur. Seperti di beberapa hari pertama, sampai buku habis dan seri bosan. Tapi satu bulan berlalu, diikuti oleh yang lain. Jiwa membutuhkan besi tua. Tapi tidak adil, tetapi dengan penyimpangan. Dan saya mencari-cari tempat sampah dan menemukan prosesor Zilog Z80 di sana:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7f1/fe7/7c9/7f1fe77c9972b2270ad8478702521555.jpg" alt="gambar"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harus mengatakan, saya sangat menyukai prosesor ini. Mungkin satu-satunya hal yang saya sukai dari dia adalah chip ke-486, tetapi tangan saya tidak akan segera mencapainya, karena sulit dan tidak ada gunanya memasukkannya ke papan tempat memotong roti. Harus disolder. Tapi saya belum mau solder. Dan bahkan lebih dari Z80 itu sendiri, saya suka komputer ZX Spectrum yang dibangun atas dasar itu. Tapi Spectrum asli menderita bencana dalam bentuk chip logika kustom ULA, dan klonnya di sisi longgar, meskipun tidak terlalu sulit untuk dibangun dan disempurnakan, masih tidak untuk model papan tempat memotong roti, dan memang, mengapa begitu banyak kekhawatiran ketika ada arduino?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembaca yang cerdas, seimbang, dan memadai di sini akan berhenti membaca atau melempar sesuatu seperti "1 mikrosirkuit FPGA akan mengakomodasi kelas komputer Spectrum" sebelum berhenti. Saya tidak pintar, tidak memadai, meskipun seimbang, tetapi saya hanya tahu tentang FPGA bahwa itu keren. Saya hanya bisa melakukan Arduino. Tapi benar-benar ingin menyodok kabel di Z80. Sangat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ayo mulai </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, mari kita mulai. Tapi pertama-tama, Penafian.</font></font><b>,   ,   ,    .  —       .      ,    , .      ,    (,   ?), ,   ,   ,     ,  .       ,    ,  ,   ,   ,    .</b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai dengan, apa yang dimaksud dengan komputer 8-bit yang memadai. Ini sebenarnya adalah prosesor yang terhubung ke ROM dan RAM, dan di sampingnya ada beberapa penghitung untuk ditampilkan pada layar komposit. Terkadang, timer mencicit. ZX Spectrum tidak berbeda dengan skema tradisional, kecuali satu tetapi. Ada ULA. Ini, sebenarnya, adalah "chipset" dari Spectrum. ULA mengelola periferal, seperti tape recorder, tweeter, keyboard (sebagian), output ke layar (ya, ya, kartu video terintegrasi muncul dalam chipset Spectrum bahkan sebelum menjadi mainstream). Ada juga peringatan bersama, 16 KiB RAM pertama (alamat dari 0x4000 hingga 0x5B00). Dari sana, ULA menarik komposit ke layar, dan agar Z80 tidak akan meraba-raba di sana ketika tidak diperlukan, ULA dapat menghentikan prosesor, jika perlu, karena sinyal jam pada Z80 berasal dari itu. Artinya, jika ULA bekerja dengan memori, dan terdeteksi,bahwa prosesor juga merayap ke dalam memori ini (untuk ini, ia terus-menerus memonitor garis MREQ dan A15 dan A14), itu hanya menghentikan clocking prosesor sampai itu sendiri selesai melakukan apa yang diperlukan. By the way, untuk menghindari korupsi data di bus, bagian-bagian bus di sisi prosesor dan di sisi ULA dibatasi oleh ... resistor ... Selain itu, memori duduk di bus dari sisi ULA dan, dengan demikian, jika terjadi tabrakan, sepenuhnya mengabaikan data dan alamat dari sisi prosesor.benar-benar mengabaikan data dan alamat dari prosesor.benar-benar mengabaikan data dan alamat dari prosesor.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, Spectrum memiliki ROM (alamat 0x0000 - 0x3FFF) dan memori prosesornya sendiri (0x8000 - 0xFFFF), di mana ULA tidak memiliki akses, dan yang bekerja lebih cepat dari 16 KiB memori bersama, karena prosesor tidak mengganggu ULA di area ini. . Tapi itu hanya pada versi 48K dari komputer. Dalam versi dasar, hanya ada ROM dan 16 KiB yang kompatibel dengan ULA. Kami akan mulai dengannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sangat nyaman bahwa prosesor Z80 dapat membuat ulang DRAM, tetapi bagaimanapun saya tidak ingin repot dengannya, karena SRAM lebih mudah ditemukan dan saya tidak memiliki multiplexer (atau saya tidak dapat menemukannya). Jadi, kita akan menggunakan SRAM. Untuk memulainya, kita akan merakit kerangka utama, di mana semua yang lain bisa digantung. Kerangka akan menjadi prosesor, ROM dengan firmware, dipetakan ke alamat Spectrum's ROM, RAM, dipetakan ke 16 KiB pertama setelah ROM dan beberapa chip untuk membungkus semuanya ... Saya harus mengatakan bahwa untuk waktu yang lama saya tidak ingin memutar, karena saya memiliki tata letak Cina $ 1 untuk 2 lembar dalam ibee. Tapi, bagi saya, keributan itu sepadan. Jika Anda tidak ingin dipusingkan untuk waktu yang lama, lakukan tata letak yang baik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, instal Z80. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lembar data</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ,</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ee/n6/i0/een6i0aw3zjgv2b4gah5oo9t2ja.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prosesor memiliki 40 pin yang dibagi menjadi beberapa kelompok: bus alamat, bus data, kontrol sistem, kontrol prosesor, kontrol bus prosesor, well, daya dan jam. Tidak semua kesimpulan ini digunakan dalam sistem nyata, seperti ZX Spectrum, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seperti yang dapat dilihat dari diagram.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dari "kontrol prosesor" grup dalam Spectrum, hanya sinyal INT dan RESET yang digunakan. Sinyal M1 tidak digunakan dari grup "sistem kontrol", grup "kontrol bus" tidak digunakan sama sekali. Ada alasan untuk ini. Sistem 8-bit yang lama sangat sederhana, dan Spectrum dibuat dengan gagasan sesederhana mungkin dan segala sesuatu yang dapat diabaikan diabaikan. Tentu saja, produsen perangkat dapat menggunakan interupsi (sinyal INT dan NMI), mereka diarahkan ke slot ekspansi, tetapi NMI tidak digunakan dalam spektrum itu sendiri. Seperti dapat dilihat dari diagram di atas, sinyal NMI, WAIT, BUSREQ ditarik oleh resistor daya, karena ini adalah input tingkat rendah yang diaktifkan (ini ditunjukkan oleh bilah di atas nama sinyal), dan harus ada unit logis (mis. + 5V) sehingga Tuhan melarang sinyal yang tidak perlu tidak bekerja. Dan inilah temuannya, BUSACK, HALT, M1,dan menggantung di udara, tidak terhubung dengan apa pun. Omong-omong, perhatikan bahwa tidak ada tombol reset di Spectrum. Pin reset terhubung melalui</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rantai RC</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke daya (RESET juga diaktifkan oleh level rendah), karena, menurut lembar data, setelah mengaktifkan RESET, setidaknya 3 siklus clock harus aktif agar prosesor memasuki mode operasi. Sirkuit RC ini menjaga level rendah hingga kapasitor dibebankan ke level tinggi melalui resistor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita secara singkat memeriksa sisa sinyal: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M1.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami tidak membutuhkan. Dia melaporkan bahwa prosesor mulai menjalankan instruksi berikutnya. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MREQ.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Saya membutuhkannya. Ini melaporkan bahwa prosesor sedang mengakses memori. Jika sinyal ini menjadi rendah (yaitu, terhubung ke catu daya), maka kita harus mengaktifkan memori yang terhubung ke prosesor. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IOREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya membutuhkannya. Ini melaporkan bahwa prosesor sedang mengakses perangkat periferal. Misalnya ke keyboard.</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya membutuhkannya. Menginformasikan bahwa prosesor akan membaca data dari memori (jika MREQ aktif) atau periferal (IOREQ). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya membutuhkannya. Laporan bahwa prosesor akan menulis data ke memori / periferal. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFSH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Saya membutuhkannya. Secara umum, sinyal ini diperlukan untuk memori dinamis (DRAM). Saya tidak berencana untuk menggunakannya, karena pengalamatannya lebih sulit (matriks, bukan linier, yaitu, akan diperlukan untuk menginstal multiplexer), dan secara umum, di zaman kita, mikrosirkulasi SRAM berkapasitas rendah lebih mudah didapat. Tetapi karena prosesor itu sendiri meregenerasi DRAM dengan mengurutkan alamat pada bus memori, sinyal ini akan memungkinkan kita untuk mengabaikan siklus regenerasi dan tidak mengaktifkan memori dengan RFSH aktif. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HALT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tidak dibutuhkan. Menunjukkan bahwa prosesor dihentikan. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TUNGGU</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tidak dibutuhkan. Sinyal ini diperlukan untuk meminta prosesor berhenti dan menunggu sebentar. Biasanya digunakan oleh periferal atau memori yang lambat. Tapi tidak dalam Spectrum. Ketika dalam peripheral Spectrum (ULA) memutuskan untuk menghentikan prosesor, maka ia hanya berhenti mengirim sinyal jam ke sana. Ini lebih dapat diandalkan, karena setelah menerima WAIT, prosesor tidak segera berhenti. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mengganggu. Belum jelas. Kami berasumsi bahwa itu belum diperlukan. Lalu kita akan mencari tahu. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NMI</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Gangguan yang tak terduga. Super interupsi. Tidak perlu. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RESET</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tanpanya, itu tidak akan terbang. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSREQ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tidak dibutuhkan. Meminta prosesor untuk memutuskan koneksi dari data / bus alamat, serta sinyal kontrol. Diperlukan jika beberapa perangkat ingin mendapatkan kendali atas bus. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BUSACK</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tidak dibutuhkan. Berfungsi untuk memberi tahu perangkat yang melakukan BUSREQ bahwa bus itu gratis. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JAM</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sinyal jam. Jelas, dia dibutuhkan. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Makanan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juga dibutuhkan. Glory ke pengembang, hanya + 5V / GND. Tidak ada 3 tekanan untuk Anda. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A0-A15</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah bus alamat. Di atasnya, prosesor menampilkan alamat memori (MREQ aktif) atau alamat port I / O (IOREQ aktif) dengan panggilan yang sesuai. Seperti yang Anda lihat, bus berukuran 16 bit, yang memungkinkan Anda untuk langsung menangani memori 64 KiB. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">D0-D7</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - bus data. Prosesor menghasilkan (WR aktif), atau membaca darinya (RD aktif) data yang diminta. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kita akan menempatkan prosesor di atas papan tempat memotong roti. Jadi kesimpulannya secara fisik terletak:</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/dcb/b3f/2c4/dcbb3f2c401007d7aa3e1083e403f301.png" alt="gambar"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hubungkan daya (pin 11 dan 29). Untuk jaga-jaga, saya juga meletakkan kapasitor 10 pF di antara kedua kaki ini. Tetapi pada akhirnya dia tidak membantu saya. Pin 27, 23, 18 mungkin tetap tidak terhubung dengan apa pun. Pin 26, 25, 24, 17, 16 terhubung melalui resistor (saya menggunakan 10 kOhm) ke catu daya. Saya membawa bus alamat (pin 1-5 dan 30-40) ke sisi berlawanan dari papan tempat memotong roti, dan bus data (pin 7-10 dan 12-15) ke bus data terpisah yang terbuat dari bus listrik prototipe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pin 6 (sinyal jam) dan 26 (RESET) terhubung (kemudian) ke Arduin sehingga Anda dapat mengontrol prosesor dari itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ternyata seperti ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/in/rx/jminrxjfjixmm4pod6jhxw3kzfy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sampai Anda memperhatikan kabel dari atas, mereka pergi dari ROM, kami akan pindah sedikit nanti. Juga, dalam foto di sebelah prosesor, satu chip lagi terlihat. Kami membutuhkannya untuk memecahkan kode bit atas alamat. Seperti yang saya katakan di atas, ada 3 jenis memori dalam Spectrum. Lebih rendah 16 KiB dari ruang alamat adalah ROM. Dengan demikian, jika terminal A14 dan A15 dalam keadaan rendah (0 Volts), kita perlu memutuskan segalanya kecuali chip ROM dari bus. Selanjutnya adalah 16 KiB memori bersama. Oleh karena itu, kita perlu menghubungkan memori ini ke bus (dan lepaskan sisanya) jika output A15 rendah dan A14 tinggi (+5 Volts). Nah, kemudian datang memori cepat 32 KiB. Kami akan memasang memori ini nanti, dan kami akan mengaktifkannya jika output A15 dalam keadaan tinggi. Selain itu, jangan lupa bahwa kami hanya mengaktifkan memori saat aktif (di sini, aktif - rendah,0 Volt) MREQ dan tidak aktif (di sini, tidak aktif - tinggi, + 5V) RFSH. Semua ini cukup sederhana untuk diterapkan pada logika standar, pada NAND yang sama, seperti 74HC00, atau Orthodox K155LA3, dan saya mengerti tugas ini adalah untuk kelompok persiapan TK, namun, saya hanya dapat berpikir dalam tabel kebenaran dalam kebebasan dan dalam penahanan.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memiliki diagram Harlequin lengkap di sana</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dari mana Anda dapat mengambil bagian di mana U4 ditarik (74HC138, untungnya saya memiliki sekitar seratus dari mereka). </font><font style="vertical-align: inherit;">Kami akan mengabaikan U11 untuk kejelasan, karena 32KiB atas tidak menarik bagi kami sejauh ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menghubungkan sangat sederhana. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/2h/my/p2/2hmyp2xuiiuejpixie4e1mnoo1w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang bisa dilihat dari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uraian singkatnya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microcircuit adalah dekoder yang menerima angka biner dari 000 hingga 111 pada terminal 1 hingga 3 dan mengaktifkan salah satu dari 8 output (kaki 7 dan 9 hingga 15) yang sesuai dengan nomor ini. </font><font style="vertical-align: inherit;">Karena hanya 8 angka berbeda yang dapat disimpan dalam 3 bit, hanya ada delapan output. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, kesimpulannya terbalik, yaitu yang akan aktif akan memiliki level 0V, dan yang lainnya +5V. </font><font style="vertical-align: inherit;">Selain itu, kunci dalam bentuk gerbang 3-input tipe "I" dibangun ke dalam chip, dan dua dari tiga inputnya juga terbalik.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus kami, kami menghubungkan dekoder itu sendiri sebagai berikut: bit yang paling signifikan (leg ke-3) ke tanah, akan selalu ada 0. Bit tengah adalah untuk garis A15. Hanya akan ada 1 jika prosesor mengakses memori 32KiB atas (alamat 0x8000 - 0xFFFF, atau 1000000000000000 - 111111111111111111 dalam biner, ketika bit paling signifikan selalu disetel ke 1). Kami menghubungkan bit paling tidak signifikan ke garis A14, di mana level tinggi akan dalam hal mengakses baik memori setelah 16 KiB pertama, tetapi naik ke atas 32 KiB (alamat 0x4000 - 0x7FFF, atau 0100000000000000 - 011111111111111111 dalam bentuk biner), atau ke 16 KiB terbaru dari alamat spasi (alamat 0xB000 - 0xFFFF, atau 1100000000000000 - 111111111111111111 dalam bentuk biner). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat apa hasilnya pada masing-masing kasus:</font></font><br>
<br>
<ul>
<li>  14  15    ,       16  ,    ,     000,  0    (    ),     Y0 (15 ).      ,      .</li>
<li>  14   ,   15 —  ,         16 ,   32 ,    001,  1   ,     Y1 (14 ).      ,  16 ,       .</li>
<li>  14   ,   15 —  ,     -  32   48 ,    010,     Y2 (13 ).      ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kedua saluran (A14 dan A15) aktif, prosesor mengakses 16 KiB memori teratas, dari 48 hingga 64 KiB, kami tidak memilikinya, sehingga pin Y3 (pin ke-12) juga ada di udara.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, berkat elemen lain, rangkaian mikro akan mengaktifkan temuannya hanya jika input 4 dan 5 rendah dan 6 tinggi. </font><font style="vertical-align: inherit;">Input ke-4 selalu dalam kondisi rendah (terhubung langsung ke ground), input ke-5 hanya akan rendah ketika prosesor mengakses memori (ingat, MREQ dalam kondisi rendah berarti mengakses memori), dan ke-6 akan menjadi tinggi ketika prosesor tidak melakukan siklus pembaruan DRAM (kami memiliki SRAM, jadi siklus pembaruan DRAM adalah cara teraman untuk diabaikan). </font><font style="vertical-align: inherit;">Ternyata bagus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, letakkan ROM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengambil W27C512 karena harganya murah, ceria, semuanya akan pas dan Anda juga bisa bank. 64KiB! 4 firmware dapat diunggah. Ya, saya punya sekitar satu juta dari sirkuit mikro ini. Saya memutuskan bahwa saya hanya akan menjahit bagian atas, karena pada Harlequin kaki A15 diikat ke + 5V, dan A14 disesuaikan dengan jumper. Jadi, saya bisa menguji firmware pada Harlequin agar tidak dipusingkan untuk waktu yang lama. Lembar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">data</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> smorim </font><font style="vertical-align: inherit;">. Kami menempatkan chip di papan tempat memotong roti. Sekali lagi, saya meletakkannya di sudut kanan untuk menempatkan bus alamat di sebelah kiri. Kami menarik kaki A15 ke kekuasaan, kabel A14 ke tanah. Pengkabelan - ini agar Anda dapat mengubah bank memori. Karena A15 akan selalu berada pada level tinggi, hanya 32 KiB flash drive teratas yang akan tersedia untuk kita. Dari jumlah tersebut, garis A14 akan memilih 16 KiB atas (+ 5V) atau lebih rendah. Di dalamnya, saya mengisi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gambar uji dengan</font></a><font style="vertical-align: inherit;"> programmer</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">48K</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> firmware </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">DASAR</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
14 baris alamat yang tersisa (A0 - A13) terhubung ke bus alamat di sebelah kiri. Kami menghubungkan bus data (Q0 - Q7) ke bus improvisasi kami dalam bentuk bus listrik dari model papan tempat memotong roti. Jangan lupakan makanan!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang sinyal kontrol. </font><font style="vertical-align: inherit;">OE adalah keluaran yang memungkinkan. </font><font style="vertical-align: inherit;">Kami membutuhkan ROM untuk mengirim data ke bus data ketika prosesor membacanya. </font><font style="vertical-align: inherit;">Jadi kami terhubung langsung ke output prosesor RD. </font><font style="vertical-align: inherit;">Dengan mudah, kedua pin, baik OE pada ROM dan RD pada prosesor, aktif dalam kondisi rendah. </font><font style="vertical-align: inherit;">Ini penting, Anda tidak perlu membalikkan apa pun. </font><font style="vertical-align: inherit;">Selain itu, ROM memiliki input CS, juga aktif dalam kondisi rendah. </font><font style="vertical-align: inherit;">Jika input ini tidak aktif, ROM akan mengabaikan semua sinyal lain dan tidak akan mengeluarkan apa pun ke bus data. </font><font style="vertical-align: inherit;">Kami akan menghubungkan input ini ke pin Y0 (15 pin) dari chip 74HC138, yang juga aktif dalam kondisi rendah. </font><font style="vertical-align: inherit;">Di sirkuit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">sinyal ini, untuk beberapa alasan, terhubung melalui resistor. </font><font style="vertical-align: inherit;">Kami akan melakukan hal yang sama. </font><font style="vertical-align: inherit;">Kenapa, saya tidak tahu. </font><font style="vertical-align: inherit;">Mungkin orang pintar memberi tahu saya dalam komentar ... </font><i><font style="vertical-align: inherit;">Mereka memberi tahu</font></i><font style="vertical-align: inherit;"> saya </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Terima kasih</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sterr</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><blockquote>  .       ,    «» .            .</blockquote></i><br>
<br>
<img src="https://habrastorage.org/webt/1k/n7/h3/1kn7h3nfgruh121jefz2qfhucts.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang RAM. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih sulit dengan itu, karena tidak hanya prosesor, tetapi juga ULA, atau, dalam kasus kami, Arduino, bekerja dengan RAM (dengan 16 KiB kami). Karena itu perlu untuk membaca sesuatu yang ditampilkan di layar. Oleh karena itu, kita harus dapat memutus sinyal kontrol dan bus alamat RAM dari prosesor. Kami tidak akan memutus bus data, kami akan bertindak seperti dalam spektrum asli (dan dalam Harlequin): kami akan membagi bus dengan resistor (470-500 Ohm). Di satu sisi, resistor akan menjadi prosesor dan ROM, di sisi lain, RAM dan Arduino. Jadi, jika terjadi konflik pada bus data, itu akan berfungsi sebagai 2 bus terpisah. Tetapi untuk sisanya kami menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seperti pada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harlequin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (U43, U44 dalam diagram), meskipun dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speccy ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada juga resistor (antara IC1 di satu sisi, ini adalah ULA, dan IC3, IC4 di sisi lain). </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">74HC245</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah buffer bus 8-bit. Tetapi kami memiliki 2 sinyal kontrol (RD - dalam hal membaca dari memori dan CE untuk mengaktifkan RAM itu sendiri. Kami akan berurusan dengan WR dalam kasus penulisan ke memori nanti) dan 14 bit alamat: ingat, di atas kami telah menghasilkan sinyal ke memori hanya menggunakan 74HC138 jika prosesor mengaktifkan A14 dengan A15 tidak aktif, jadi kita tidak perlu melakukan decoding alamat tambahan, memori hanya akan berfungsi saat mengakses 16 KiB pertama setelah ROM. Nah, tentu saja, untuk mengatasi 16 KiB Anda hanya perlu 14 baris alamat (A0-A13). Secara total, 16 sinyal diperoleh, jadi kita membutuhkan 2 sirkuit mikro 74HC245. Kami menghubungkan mereka ke papan tempat memotong roti di sebelah kiri, di tempat bus alamat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dari lembar data pada 74HC245 jelas bahwa, secara umum, tidak masalah ke sisi mana untuk menyambungkan sirkuit mikro, tetapi karena saya mulai membangun tata letak dari bawah ke atas, dan semua sirkuit mikro lainnya dipasang dengan pin pertama ke kiri, bus alamat akan terhubung ke sisi A (pin 2) -9 chip, dalam lembar data ditetapkan sebagai A0-A7). Arah transfer selalu dari prosesor ke RAM, karena RAM tidak pernah menetapkan alamat, tetapi hanya menerimanya. Pada 74HC245, pin 1 (DIR) bertanggung jawab untuk arah transmisi. Menurut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">datasheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga output yang sama dengan input dari sisi A muncul di sisi B, DIR harus diatur ke TINGGI. Jadi hubungkan pin 1 dari kedua sirkuit ke + 5V. OE (pin ke-20, diaktifkan oleh level rendah) terhubung menggunakan kabel ke ground sehingga dapat dengan cepat beralih ke +5V dan terputus dari prosesor. Lebih sederhana. Hubungkan daya untuk kedua chip. Pin paling kanan dari rangkaian mikro kanan (pin 8 dan 9, input A6 dan A7) akan menjadi sinyal kontrol. Saya menghubungkan A7 ke terminal RD prosesor, dan A6 ke pin Y1 dari chip 74HC138, karena akan ada level rendah hanya ketika prosesor mengakses RAM kami. Kesimpulan yang tersisa dari sisi A dari kedua sirkuit mikro (kaki 2–9 untuk kiri dan kaki 2–7 untuk kanan) Saya terhubung ke bus alamat, terminal A13-A0. Kita tidak memerlukan 2 bit atas dari alamat, karena mereka sudah diterjemahkan dalam sinyal dari 74HC138.Sekarang tentang RAM itu sendiri. Secara alami, saya menggunakan apa yang sudah saya miliki: chip cache dari motherboard lama. Saya menemukan</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IS61C256</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pada 20 ns, tetapi siapa pun akan melakukannya. Speccy bekerja pada frekuensi 3,5 MHz, tetapi untuk sekarang kita umumnya akan memperlakukan Arduinki. Jika 100 kHz keluar, akan ada kebahagiaan! Jadi, kami terhubung. Tentu saja, jangan lupa soal makanan. Kesimpulan I / O0 - I / O7 terhubung ke papan tempat memotong roti data SETELAH resistor. Saya beruntung (pada kenyataannya, tidak), pada maket Cina saya, bus-bus listrik terbagi persis di tengah. Saya menggunakan fitur ini untuk memisahkan bus dengan resistor. Jika tata letak Anda salah, Anda harus </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diselewengkan</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat bus data kedua, dan hubungkan dengan resistor ke yang pertama. Kesimpulan A0-A13 dilemparkan ke B-kesimpulan yang sesuai dari chip 74HC245, tidak lupa bahwa yang paling kanan terhubung bukan ke bus data, tetapi ke sinyal kontrol. A14 - dengan pilihan, baik ke tanah, atau ke + 5V. Chip 32 KiB, jadi kesimpulan ini akan menentukan setengah mana yang akan kita gunakan. Jika Anda menemukan SRAM 16 KiB, tidak akan ada garis A14 di dalamnya. Outputnya adalah KAMI (memungkinkan diaktifkan), CE (memungkinkan chip) dan OE (memungkinkan output). Semua diaktifkan rendah. OE harus terhubung ke RD prosesor, tetapi, tentu saja, tidak secara langsung, tetapi melalui 74HC245 kanan, di mana RD datang ke kaki A7 saya, dan karenanya keluar dari kaki B7 (pin ke-11). Di sana dan terhubung. CE harus terhubung ke Y1 dari 74HC138, yang menerjemahkan kode alamat. Sinyal nya datang kepada saya di A6 dari chip yang tepat 74HC245, masing-masing,keluar dari kaki B6 (12 pin). KITA AKU langsung terhubung ke output prosesor WR. Saya juga memasang kawat jumper dari sinyal OE dan menempelkannya hanya di bagian papan tempat memotong roti yang tidak digunakan. Dengan menghubungkan kabel ini ke catu daya, saya dapat memaksa RAM untuk diaktifkan ketika saya membacanya dari Arduinka. Namun, saya menarik semua sinyal kontrol RAM ke + 5V menggunakan resistor 10 kOhm. Untuk berjaga-jaga. Ternyata seperti ini:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9y/0k/3h/9y0k3ht6ehvrsvzoehp70h428mo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, di sini, dan jika sama sekali, di awal, harus ada program pendidikan tentang waktu sinyal pada ban. Saya tidak akan melakukan ini, karena telah dilakukan berkali-kali di jaringan oleh orang-orang yang jauh lebih cerdas daripada saya. Bagi yang tertarik, saya dapat merekomendasikan video ini:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/i_wrxBdXTgM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, jika Anda tidak berlangganan saluran ini dan tertarik pada elektronik sebagai amatir, dan bukan sebagai profesional, saya sangat merekomendasikannya kepada Anda. Ini adalah konten berkualitas sangat tinggi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, itu hampir semuanya. Sekarang Anda hanya perlu memahami cara membaca data dari RAM di Arduino. Untuk mulai dengan, mari kita hitung berapa banyak kesimpulan Arduinki yang kita butuhkan. Kita perlu memberi sinyal jam dan mengontrol RESET, ini adalah 2 pin. 8 bit bus data - 8 pin lainnya. Ditambah 13 bit alamat, total 23 pin. Selain itu, kita perlu berkomunikasi dengan Arduinka, kita akan melakukan ini melalui antarmuka serialnya, ini adalah 2 pin lainnya. Sayangnya, hanya ada 20 kesimpulan tentang DNA saya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yah, itu tidak masalah. Saya tidak tahu satu orang pun yang memiliki Arduino dan tidak memiliki 74HC595. Sepertinya saya hanya dijual dalam kit. Setidaknya saya hanya memiliki chip 74HC00 lebih dari 595x. Jadi kami menggunakannya. Selain itu, saya akan menghemat ruang dalam artikel, karena pekerjaan 595x dengan Arduino dijelaskan dengan sempurna </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. 595mi kami akan menghasilkan alamat. Chip akan membutuhkan 2 buah (karena kita memiliki 13 bit alamat, dan 595 memiliki 8 pin). Cara menghubungkan beberapa 595x untuk ekspansi bus dijelaskan secara rinci di tautan di atas. Saya hanya mencatat bahwa pada contoh di tautan OE (pin 13) 595x ditarik ke tanah. Kami pasti tidak akan melakukan ini, kami akan mengirim sinyal dari Arduinki di sana, karena pin 595x akan terhubung langsung ke bus alamat RAM, dan kami tidak memerlukan sinyal palsu di sana. Setelah menghubungkan pin 595x ke bus alamat RAM, tidak ada lagi yang perlu dilakukan pada mock-up. Saatnya menghubungkan arduinka. Tapi pertama-tama, tulis sketsa:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_CLOCK_PIN 2</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CPU_RESET_PIN 3</span><font></font>
<font></font>
<span class="hljs-comment">// RAM defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_OUTPUT_ENABLE_PIN 4</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_WRITE_ENABLE_PIN 5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_CHIP_ENABLE_PIN 6</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RAM_BUFFER_PIN 7</span><font></font>
<font></font>
<span class="hljs-comment">// Shift Register defines</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_DATA_PIN 8</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_OUTPUT_ENABLE_PIN 9</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_LATCH_PIN 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SR_CLOCK_PIN 11</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// All CPU and RAM control signals need to be configured as inputs by default</span>
  <span class="hljs-comment">// and only changed to outputs when used.</span>
  <span class="hljs-comment">// Shift register control signals may be preconfigured</span><font></font>
<font></font>
  <span class="hljs-comment">// CPU controls seetup</span><font></font>
  DDRC = B00000000;<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, INPUT);<font></font>
<font></font>
  <span class="hljs-comment">// RAM setup</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_BUFFER_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_BUFFER_PIN, LOW);<font></font>
<font></font>
  <span class="hljs-comment">// SR setup</span><font></font>
  pinMode(SR_LATCH_PIN, OUTPUT);<font></font>
  pinMode(SR_CLOCK_PIN, OUTPUT);<font></font>
  pinMode(SR_DATA_PIN, OUTPUT);<font></font>
  pinMode(SR_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
<font></font>
  <span class="hljs-comment">// common setup</span>
  Serial.begin(<span class="hljs-number">9600</span>);<font></font>
  Serial.println(<span class="hljs-string">"Hello"</span>);<font></font>
}<span class="hljs-comment">// setup</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shiftReadValueFromAddress</span><span class="hljs-params">(<span class="hljs-keyword">uint16_t</span> address, <span class="hljs-keyword">uint8_t</span> *value)</span> </span>{
  <span class="hljs-comment">// disable RAM output</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_WRITE_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// set address</span><font></font>
  digitalWrite(SR_LATCH_PIN, LOW);<font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address&gt;&gt;<span class="hljs-number">8</span>); <font></font>
  shiftOut(SR_DATA_PIN, SR_CLOCK_PIN, MSBFIRST, address);  <font></font>
  digitalWrite(SR_LATCH_PIN, HIGH);<font></font>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// write value to RAM</span>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, LOW); <span class="hljs-comment">// active low</span>
  delay(<span class="hljs-number">1</span>);<font></font>
  DDRC = B00000000;<font></font>
  *value = PINC;<font></font>
  digitalWrite(RAM_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span>
  <span class="hljs-comment">// disable SR</span>
  digitalWrite(SR_OUTPUT_ENABLE_PIN, HIGH); <span class="hljs-comment">// active low</span><font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// shiftWriteValueToAddress</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">runClock</span><span class="hljs-params">(<span class="hljs-keyword">uint32_t</span> cycles)</span> </span>{
  <span class="hljs-keyword">uint32_t</span> currCycle = <span class="hljs-number">0</span>;<font></font>
  pinMode(CPU_CLOCK_PIN, OUTPUT);<font></font>
  <span class="hljs-keyword">while</span>(currCycle &lt; cycles) {<font></font>
    digitalWrite(CPU_CLOCK_PIN, HIGH);<font></font>
    digitalWrite(CPU_CLOCK_PIN, LOW);<font></font>
    currCycle++;<font></font>
  }<font></font>
  pinMode(CPU_CLOCK_PIN, INPUT);<font></font>
}<span class="hljs-comment">// runClock</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">trySpectrum</span><span class="hljs-params">()</span> </span>{<font></font>
  pinMode(RAM_WRITE_ENABLE_PIN, INPUT);<font></font>
  pinMode(RAM_OUTPUT_ENABLE_PIN, INPUT);<font></font>
  pinMode(CPU_RESET_PIN, OUTPUT);<font></font>
  digitalWrite(CPU_RESET_PIN, LOW);<font></font>
  runClock(<span class="hljs-number">30</span>);<font></font>
  digitalWrite(CPU_RESET_PIN, HIGH);<font></font>
  runClock(<span class="hljs-number">12500000</span>);<font></font>
}<span class="hljs-comment">// trySpectrum</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">readDisplayLines</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">uint8_t</span> value;<font></font>
  digitalWrite(RAM_BUFFER_PIN, HIGH);<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, OUTPUT);<font></font>
  digitalWrite(RAM_CHIP_ENABLE_PIN, LOW);<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">uint16_t</span> i=<span class="hljs-number">16384</span>; i&lt;<span class="hljs-number">16384</span>+<span class="hljs-number">6144</span>;i++) {<font></font>
    shiftReadValueFromAddress(i, &amp;value);<font></font>
    Serial.println(value);<font></font>
  }<font></font>
  pinMode(RAM_CHIP_ENABLE_PIN, INPUT);<font></font>
}<span class="hljs-comment">// readDisplayLines</span><font></font>
<font></font>
<span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
  trySpectrum();<font></font>
  Serial.println(<span class="hljs-string">"Hope we are ok now. Please set up memory for reading"</span>);<font></font>
  delay(<span class="hljs-number">40000</span>);<font></font>
  Serial.println(<span class="hljs-string">"Reading memory"</span>);<font></font>
  readDisplayLines();<font></font>
  Serial.println(<span class="hljs-string">"Done"</span>);<font></font>
  delay(<span class="hljs-number">100000</span>);<font></font>
}<span class="hljs-comment">// loop</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang dapat Anda lihat dari sketsa (well, sungguh, tiba-tiba, seseorang membacanya), saya membaca data bus ke port C. Seperti yang diingat Arduischik, di CID port C adalah 6 pin. Artinya, saya hanya membaca 6 bit. Ya, untuk kesederhanaan proses, saya mengabaikan 2 bit tinggi di setiap byte dari buffer layar. Ini akan menghasilkan fakta bahwa setiap 2 piksel setelah 6 akan selalu ada warna latar belakang. Sambil naik, maka perbaiki. Ini kerangkanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang untuk koneksi itu sendiri. Pada prinsipnya, semuanya dilukis di bagian paling atas sketsa:</font></font><br>
<br>
<pre><code class="plaintext hljs">// CPU defines<font></font>
#define CPU_CLOCK_PIN 2 -  2     6  ( )<font></font>
#define CPU_RESET_PIN 3 -  3     26  (RESET)<font></font>
<font></font>
// RAM defines<font></font>
#define RAM_OUTPUT_ENABLE_PIN 4 -  4     22  (OE)<font></font>
#define RAM_WRITE_ENABLE_PIN 5 -  5    .     .<font></font>
#define RAM_CHIP_ENABLE_PIN 6 -  6     .        ,        .   - ,   -  .   ,   .<font></font>
#define RAM_BUFFER_PIN 7 -  ,    6,    .<font></font>
<font></font>
// Shift Register defines<font></font>
#define SR_DATA_PIN 8   -  8     14 "" 595.        9 ,     .<font></font>
#define SR_OUTPUT_ENABLE_PIN 9 -   13  595<font></font>
#define SR_LATCH_PIN 10 -   12  595<font></font>
#define SR_CLOCK_PIN 11 -   11  595.<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya sederhana. Begini tampilannya seperti semua yang ada di koleksi saya (arduinka terpotong di gambar, tapi tidak banyak yang bisa dilihat): </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pj/q5/si/pjq5siebaxafimb_nqnjxyry6_u.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat startup, Arduino dengan ceria mengatakan Halo ke port serial komputer (walaupun virtual), dan mulai menyiksa prosesor. Setelah benar-benar menyiksanya (beberapa menit), program ini akan menghentikan orang miskin dan akan menawarkan Anda untuk mengatur ulang jumper dengan pena di papan tempat memotong roti, melepaskan memori dari bus alamat dan sinyal kontrol prosesor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu menggunakan pegangan untuk mengatur ulang kabel yang terhubung ke pin 19 dari kedua 74HC245 dari ground ke + 5V. Jadi, kami memutuskan prosesor dari RAM. Pin 22 dari chip RAM itu sendiri harus terhubung ke tanah (saya menulis di atas tentang kabel, yang saya hanya terjebak di papan tempat memotong roti sejauh ini, di tempat yang tidak digunakan). Jadi, kami secara paksa menyalakan RAM.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, setelah menunggu sedikit, Arduinka akan mulai membaca isi dari memori dan mengeluarkannya dalam kolom ke port serial. Akan ada banyak, banyak angka. Sekarang Anda dapat menyalin data ini dari sana dan menempelkannya, katakanlah, ke file teks, tanpa lupa untuk membersihkan semua teks yang tidak perlu (beberapa baris di bagian atas, dan "Selesai" di bagian bawah), kami hanya perlu angka. Inilah yang Speccy kami rekam dalam memori video. Tetap hanya untuk melihat apa yang ada di memori video. Dan memori video Spectrum </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak mudah</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat, pikselnya sendiri disimpan secara terpisah dari warnanya. Kami akan mengabaikan warna untuk saat ini, mari kita baca sendiri pikselnya. Tetapi mereka tidak begitu mudah untuk diterjemahkan. Setelah banyak kesakitan di Visual Studio, saya sampai pada solusi elegan ini:</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;windows.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdint.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span></span>;
<span class="hljs-keyword">uint8_t</span> *scrData;<font></font>
<font></font>
<span class="hljs-function">VOID <span class="hljs-title">OnPaint</span><span class="hljs-params">(HDC hdc)</span> </span>{
	<span class="hljs-keyword">size_t</span> arrSize = <span class="hljs-number">6144</span>;<span class="hljs-comment">//sizeof(scrData) / sizeof(scrData[0]);</span>
	<span class="hljs-comment">//int currRow = 0, currX = 0, currBlock = 0, currY = 0, currBase = 0;</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> arrPos = <span class="hljs-number">0</span>; arrPos &lt; arrSize; arrPos++) {
		<span class="hljs-keyword">int</span> blockPos = arrPos % <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currBase = (blockPos % <span class="hljs-number">256</span>) / <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currX = blockPos % <span class="hljs-number">32</span>;
		<span class="hljs-keyword">int</span> currBlock = arrPos / <span class="hljs-number">2048</span>;
		<span class="hljs-keyword">int</span> currRow = blockPos / <span class="hljs-number">256</span>;
		<span class="hljs-keyword">int</span> currY = currBlock * <span class="hljs-number">64</span> + currBase * <span class="hljs-number">8</span> + currRow;
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> trueX = <span class="hljs-number">0</span>; trueX &lt; <span class="hljs-number">8</span>; trueX++) {
			<span class="hljs-keyword">char</span> r = ((scrData[arrPos] &gt;&gt; trueX) &amp; <span class="hljs-number">1</span>)*<span class="hljs-number">255</span>;<font></font>
			SetPixel(hdc, currX * <span class="hljs-number">8</span> + (<span class="hljs-number">8</span>-trueX), currY, RGB(r, r, r));<font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span> </span>{<font></font>
	FILE *file;<font></font>
	<span class="hljs-keyword">errno_t</span> err;
	<span class="hljs-keyword">if</span> ((err = fopen_s(&amp;file, <span class="hljs-string">"data.txt"</span>, <span class="hljs-string">"r"</span>))) {<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L"Unable to oopen the file"</span>, <span class="hljs-string">L"Error"</span>, <span class="hljs-number">1</span>);<font></font>
	}<font></font>
	scrData = (<span class="hljs-keyword">uint8_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">6144</span>);
	<span class="hljs-keyword">int</span> currDataPos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">char</span> buffer[<span class="hljs-number">256</span>];
	<span class="hljs-keyword">char</span> currChar = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> currLinePos = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">while</span> (currChar != EOF) {<font></font>
		currChar = getc(file);<font></font>
		buffer[currLinePos++] = currChar;<font></font>
		<span class="hljs-keyword">if</span> (currChar == <span class="hljs-string">'\n'</span>) {<font></font>
			buffer[currLinePos] = <span class="hljs-number">0</span>;<font></font>
			scrData[currDataPos++] = (<span class="hljs-keyword">uint8_t</span>)atoi(buffer);<font></font>
			currLinePos = <span class="hljs-number">0</span>;<font></font>
		}<font></font>
	}<font></font>
	fclose(file);<font></font>
}<font></font>
<font></font>
<span class="hljs-function">INT WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE, PSTR, INT iCmdShow)</span> </span>{<font></font>
	HWND                hWnd;<font></font>
	MSG                 msg;<font></font>
	WNDCLASS            wndClass;<font></font>
	wndClass.style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wndClass.lpfnWndProc = WndProc;<font></font>
	wndClass.cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wndClass.hInstance = hInstance;<font></font>
	wndClass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wndClass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wndClass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wndClass.lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wndClass.lpszClassName = TEXT(<span class="hljs-string">"GettingStarted"</span>);<font></font>
	RegisterClass(&amp;wndClass);<font></font>
	hWnd = CreateWindow(<font></font>
		TEXT(<span class="hljs-string">"GettingStarted"</span>),   <span class="hljs-comment">// window class name</span>
		TEXT(<span class="hljs-string">"Getting Started"</span>),  <span class="hljs-comment">// window caption</span>
		WS_OVERLAPPEDWINDOW,      <span class="hljs-comment">// window style</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y position</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial x size</span>
		CW_USEDEFAULT,            <span class="hljs-comment">// initial y size</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// parent window handle</span>
		<span class="hljs-literal">NULL</span>,                     <span class="hljs-comment">// window menu handle</span>
		hInstance,                <span class="hljs-comment">// program instance handle</span>
		<span class="hljs-literal">NULL</span>);                    <span class="hljs-comment">// creation parameters</span><font></font>
	loadData();<font></font>
	ShowWindow(hWnd, iCmdShow);<font></font>
	UpdateWindow(hWnd);<font></font>
	<span class="hljs-keyword">while</span> (GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) {<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> msg.wParam;<font></font>
}  <span class="hljs-comment">// WinMain</span><font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)</span> </span>{<font></font>
	HDC          hdc;<font></font>
	PAINTSTRUCT  ps;<font></font>
	<span class="hljs-keyword">switch</span> (message) {
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hdc = BeginPaint(hWnd, &amp;ps);<font></font>
		OnPaint(hdc);<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, message, wParam, lParam);<font></font>
	}<font></font>
} <span class="hljs-comment">// WndProc</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program membuka file data.txt dari direktori-nya. </font><font style="vertical-align: inherit;">Dalam file ini, output teks dari Arduino (setelah menghapus semua baris tambahan, seperti yang disebutkan di atas.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami memberi makan file yang dihasilkan, dan sebagai hasilnya: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/ai/3f/tvai3fcvvg-y53dlrcxogjo9o-c.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ya, sementara hasilnya sangat jauh dari ideal, tetapi jelas merupakan output ke layar. </font><font style="vertical-align: inherit;">Apalagi yang dibutuhkan. </font><font style="vertical-align: inherit;">Dari ROM dengan firmware diagnostik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerangka komputer sudah siap. </font><font style="vertical-align: inherit;">Ya, belum memungkinkan untuk menggunakannya, tetapi Anda dapat melihat betapa sangat sederhana komputer 8-bit lama itu diatur. </font><font style="vertical-align: inherit;">Saya masih berdetak sedikit di atas papan tempat memotong roti, tetapi kesimpulannya hanya bertambah buruk. </font><font style="vertical-align: inherit;">Tampaknya langkah selanjutnya adalah menyolder papan tempat memotong roti yang normal dan tidak terjual, dengan daya normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi apakah itu perlu?</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id498208/index.html">Security Week 17: Implikasi Serangan Server Linux</a></li>
<li><a href="../id498214/index.html">Maria Popova: "Beberapa orang pertama kali mengetahui tentang OpenStreetMap karena mereka menandai hogweed di peta"</a></li>
<li><a href="../id498216/index.html">Mewarnai teks dalam html dan Bereaksi</a></li>
<li><a href="../id498218/index.html">Saat saya menulis musik dari sinar kosmik</a></li>
<li><a href="../id498220/index.html">Как коронавирус (COVID-XX) может помочь 1С захватить мир?</a></li>
<li><a href="../id498224/index.html">Buat pameran interaktif dengan .NET, Fungsi Azure, dan keajaiban layanan kognitif</a></li>
<li><a href="../id498226/index.html">Penguraian. Cara membongkar proyek besar menjadi segmen yang bisa dimengerti untuk penilaian awal</a></li>
<li><a href="../id498234/index.html">Mitos Manajemen Nyata Tentang DevOps</a></li>
<li><a href="../id498238/index.html">Polimer konduktif listrik: bagaimana para ilmuwan membuat plastik dari logam</a></li>
<li><a href="../id498242/index.html">Menggunakan penyimpanan dalam konten media</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>