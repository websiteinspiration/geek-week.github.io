<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèª „Ä∞Ô∏è üßôüèø Programa√ß√£o de GPU em Java üßëüèø‚Äçü§ù‚ÄçüßëüèΩ üõ∞Ô∏è üé°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O acesso √† GPU a partir de Java revela um poder tremendo. Ele descreve como a GPU funciona e como acessar a partir de Java. 
 
 A programa√ß√£o de GPU √©...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programa√ß√£o de GPU em Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O acesso √† GPU a partir de Java revela um poder tremendo. </font><font style="vertical-align: inherit;">Ele descreve como a GPU funciona e como acessar a partir de Java. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A programa√ß√£o de GPU √© um mundo alt√≠ssimo para programadores de Java. </font><font style="vertical-align: inherit;">Isso √© compreens√≠vel, pois tarefas Java normais n√£o s√£o adequadas para a GPU. </font><font style="vertical-align: inherit;">No entanto, as GPUs possuem teraflops de desempenho, ent√£o vamos explorar seus recursos. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para tornar o t√≥pico acess√≠vel, passarei algum tempo explicando a arquitetura da GPU, juntamente com um pouco de hist√≥ria que facilitar√° uma imers√£o na programa√ß√£o de ferro.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma vez mostradas as diferen√ßas entre a GPU e a computa√ß√£o da CPU, mostrarei como usar a GPU no mundo Java. </font><font style="vertical-align: inherit;">Finalmente, descreverei as principais estruturas e bibliotecas dispon√≠veis para escrever c√≥digo Java e execut√°-los na GPU, e darei alguns exemplos de c√≥digo.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um pouco de fundo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A GPU foi popularizada pela NVIDIA em 1999. √â um processador especial projetado para processar dados gr√°ficos antes de serem transferidos para a tela. </font><font style="vertical-align: inherit;">Em muitos casos, isso permite que alguns c√°lculos descarreguem a CPU, liberando recursos da CPU que aceleram esses c√°lculos descarregados. </font><font style="vertical-align: inherit;">O resultado √© que uma entrada grande pode ser processada e apresentada com uma resolu√ß√£o de sa√≠da mais alta, tornando a apresenta√ß√£o visual mais atraente e a taxa de quadros mais suave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A ess√™ncia do processamento 2D / 3D est√° principalmente na manipula√ß√£o de matrizes, que pode ser controlada usando uma abordagem distribu√≠da. </font><font style="vertical-align: inherit;">Qual ser√° uma abordagem eficaz para o processamento de imagens? </font><font style="vertical-align: inherit;">Para responder a isso, vamos comparar a arquitetura padr√£o da CPU (mostrada na Figura 1.) e a GPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d6c/58e/c4c/d6c58ec4ccbec78f237d58a822f9ab92.jpg" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FIG. 1. Blocos de arquitetura</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
da CPU Na CPU, os elementos de processamento reais - registros, unidade l√≥gica aritm√©tica (ALU) e contextos de execu√ß√£o - s√£o apenas pequenas partes de todo o sistema. Para acelerar pagamentos irregulares em um pedido imprevis√≠vel, existe um cache grande, r√°pido e caro; v√°rios tipos de colecionadores; e preditores de ramifica√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voc√™ n√£o precisa de tudo isso na GPU, porque os dados s√£o recebidos de maneira previs√≠vel e a GPU realiza um conjunto muito limitado de opera√ß√µes nos dados. Assim, √© poss√≠vel torn√°-los muito pequenos e um processador barato com uma arquitetura de blocos semelhante a esta √© mostrado na Fig. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/365/425/84c/36542584c2d34d817c48ca2cd0e8d433.jpg" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 2. Arquitetura de bloco para um n√∫cleo simples de GPU</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como esses processadores s√£o mais baratos e os dados processados ‚Äã‚Äãneles em peda√ßos paralelos, √© simples fazer com que muitos deles funcionem em paralelo. Ele √© projetado com refer√™ncia a v√°rias instru√ß√µes, v√°rios dados ou MIMD (pronunciado "mim-dee"). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A segunda abordagem √© baseada no fato de que frequentemente uma √∫nica instru√ß√£o √© aplicada a v√°rias partes de dados. Isso √© conhecido como uma √∫nica instru√ß√£o, v√°rios dados ou SIMD (pronunciado "sim-dee"). Nesse design, uma √∫nica GPU cont√©m v√°rias ALUs e contextos de execu√ß√£o, pequenas √°reas transferidas para dados de contexto compartilhado, conforme mostrado na Figura 3. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/453/4cb/013/4534cb0135c6c5c3075594787c3266c6.jpg" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 3. Compara√ß√£o da arquitetura no estilo MIMD dos blocos de GPU (√† esquerda) com o design do SIMD (√† direita)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A mistura do processamento SIMD e MIMD fornece a largura de banda m√°xima que eu ignorarei. </font><font style="vertical-align: inherit;">Nesse design, voc√™ tem v√°rios processadores SIMD executando paralelamente, como na Figura </font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d81/fc5/f10/d81fc5f10ab5cf27584669ab846b9836.jpg" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. </font><font style="vertical-align: inherit;">4. Trabalhar v√°rios processadores SIMD em paralelo; </font><font style="vertical-align: inherit;">existem 16 n√∫cleos com 128 ALUs</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como voc√™ possui </font><i><font style="vertical-align: inherit;">v√°rios</font></i><font style="vertical-align: inherit;"> processadores pequenos e simples, √© poss√≠vel program√°-los para obter um efeito especial na sa√≠da.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Executando programas na GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A maioria dos efeitos gr√°ficos iniciais nos jogos eram realmente pequenos programas codificados em execu√ß√£o na GPU e aplicados a fluxos de dados da CPU. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso era √≥bvio, mesmo quando algoritmos codificados eram insuficientes, especialmente no design de jogos, onde os efeitos visuais s√£o uma das principais dire√ß√µes m√°gicas. Em resposta, grandes vendedores abriram o acesso √† GPU e, em seguida, desenvolvedores de terceiros poderiam program√°-los.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma abordagem t√≠pica era escrever um pequeno programa chamado shaders em uma linguagem especial (geralmente uma subesp√©cie de C) e compil√°-los usando compiladores especiais para a arquitetura desejada. </font><font style="vertical-align: inherit;">O termo shaders foi escolhido porque os shaders s√£o frequentemente usados ‚Äã‚Äãpara controlar os efeitos de luz e sombra, mas isso n√£o significa que eles possam controlar outros efeitos especiais. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada fornecedor de GPU tinha sua pr√≥pria linguagem de programa√ß√£o e infraestrutura para criar sombreadores para sua arquitetura. </font><font style="vertical-align: inherit;">Nesta abordagem, muitas plataformas foram criadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os principais s√£o:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectCompute: API / API de shader privado da Microsoft que fazem parte do Direct3D, come√ßando com o DirectX 10.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD FireStream: tecnologias privadas de ATI / Radeon desatualizadas pela AMD.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenACC: Cons√≥rcio de m√∫ltiplos fornecedores, solu√ß√£o de computa√ß√£o paralela</font></font></li>
<li>++ AMP:   Microsoft     C++</li>
<li>CUDA:   Nvidia,     </li>
<li>OpenL:  ,   Apple,      Khronos Group</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na maioria das vezes, trabalhar com a GPU √© de programa√ß√£o de baixo n√≠vel. </font><font style="vertical-align: inherit;">Para tornar isso um pouco mais compreens√≠vel para os desenvolvedores, para codifica√ß√£o, v√°rias abstra√ß√µes foram fornecidas. </font><font style="vertical-align: inherit;">O mais famoso √© o DirectX, da Microsoft, e o OpenGL, do Khronos Group. </font><font style="vertical-align: inherit;">Essas s√£o APIs para escrever c√≥digo de alto n√≠vel, que podem ser simplificadas para a GPU, mais semanticamente, para o programador. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© onde eu sei, n√£o h√° infraestrutura Java para o DirectX, mas h√° uma boa solu√ß√£o para o OpenGL. </font><font style="vertical-align: inherit;">O JSR 231 come√ßou em 2002 e √© dirigido aos programadores de GPU, mas foi abandonado em 2008 e suporta apenas o OpenGL 2.0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O suporte ao OpenGL continua no projeto JOCL independente (que tamb√©m suporta o OpenCL) e est√° dispon√≠vel para o p√∫blico. </font><font style="vertical-align: inherit;">Assim, o famoso jogo Minecraft foi escrito usando JOCL.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPGPU vindo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At√© agora, Java e a GPU n√£o tinham um ponto em comum, embora devessem. </font><font style="vertical-align: inherit;">O Java √© frequentemente usado em empresas, ci√™ncia de dados e no setor financeiro, onde h√° muita computa√ß√£o e onde √© necess√°rio muito poder de computa√ß√£o. </font><font style="vertical-align: inherit;">√â assim que a id√©ia de GPU de uso geral (GPGPU) √©. </font><font style="vertical-align: inherit;">A id√©ia de usar a GPU nesse caminho come√ßou quando os fabricantes de adaptadores de v√≠deo come√ßaram a dar acesso ao buffer de quadro do programa, permitindo que os desenvolvedores leiam o conte√∫do. </font><font style="vertical-align: inherit;">Alguns hackers determinaram que podem usar todo o poder da GPU para computa√ß√£o universal. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A receita foi assim:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codifique dados como uma matriz raster.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Escreva shaders para lidar com eles.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envie os dois para a placa gr√°fica.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obter resultado do buffer de quadros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Decodifique dados de uma matriz raster.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta √© uma explica√ß√£o muito simples. N√£o tenho certeza se isso funcionar√° na produ√ß√£o, mas realmente funciona. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, v√°rios estudos do Stanford Institute come√ßaram a simplificar o uso de GPUs. Em 2005, eles criaram o BrookGPU, que era um pequeno ecossistema que inclu√≠a uma linguagem de programa√ß√£o, compilador e tempo de execu√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O BrookGPU compilou programas escritos na linguagem de programa√ß√£o de encadeamento Brook, que era uma variante do ANSI C. Ele pode segmentar o OpenGL v1.3 +, DirectX v9 + ou AMD Close to Metal para o lado do servidor e √© executado no Microsoft Windows e Linux. Para depura√ß√£o, o BrookGPU tamb√©m pode simular uma placa gr√°fica virtual na CPU.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, isso n√£o decolou, devido ao equipamento dispon√≠vel na √©poca. No mundo da GPGPU, voc√™ precisa copiar dados para o dispositivo (nesse contexto, o dispositivo se refere √† GPU e ao dispositivo em que est√° localizado), aguarde a GPU calcular os dados e copie-os novamente para o programa de controle. Isso cria muitos atrasos. E em meados dos anos 2000, quando o projeto estava em desenvolvimento ativo, esses atrasos tamb√©m exclu√≠ram o uso intensivo da GPU para computa√ß√£o b√°sica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, muitas empresas viram o futuro nessa tecnologia. V√°rios desenvolvedores de adaptadores de v√≠deo come√ßaram a fornecer √†s GPGPUs suas tecnologias propriet√°rias, e outras alian√ßas formadas forneceram modelos de programa√ß√£o menos b√°sicos e vers√°teis que funcionavam em uma grande quantidade de hardware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que j√° contei tudo, vamos verificar as duas tecnologias de computa√ß√£o de GPU mais bem-sucedidas - OpenCL e CUDA - veja tamb√©m como o Java funciona com elas. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL e Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como outros pacotes de infraestrutura, o OpenCL fornece uma implementa√ß√£o b√°sica em C. Isso est√° tecnicamente dispon√≠vel usando a Java Native Interface (JNI) ou Java Native Access (JNA), mas essa abordagem ser√° muito dif√≠cil para a maioria dos desenvolvedores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Felizmente, este trabalho j√° foi realizado por v√°rias bibliotecas: JOCL, JogAmp e JavaCL. Infelizmente, o JavaCL se tornou um projeto morto. Mas o projeto JOCL est√° vivo e muito adaptado. Vou us√°-lo para os seguintes exemplos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas primeiro eu tenho que explicar o que √© OpenCL. Mencionei anteriormente que o OpenCL fornece um modelo muito b√°sico adequado para programar todos os tipos de dispositivos - n√£o apenas GPUs e CPUs, mas tamb√©m processadores DSP e FPGAs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos o exemplo mais simples: dobrar vetores √© provavelmente o exemplo mais brilhante e mais simples. Voc√™ tem duas matrizes de n√∫meros para adi√ß√£o e uma para o resultado. Voc√™ pega um elemento da primeira matriz e um elemento da segunda matriz e, em seguida, coloca a soma na matriz de resultados, conforme mostrado na Fig. 5. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fff/896/f1f/fff896f1feb607506f35dc8dcdce973b.jpg" alt="imagem"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fig. 5. Adicionando os elementos de duas matrizes e armazenando a soma na matriz resultante</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Como voc√™ pode ver, a opera√ß√£o √© muito consistente e, no entanto, distribu√≠da. Voc√™ pode enviar cada opera√ß√£o de adi√ß√£o para diferentes GPUs principais. Isso significa que, se voc√™ tiver 2048 n√∫cleos, como na Nvidia 1080, poder√° executar opera√ß√µes de adi√ß√£o 2048 ao mesmo tempo. Isso significa que aqui os potenciais teraflops de energia do computador est√£o esperando por voc√™. Este c√≥digo para uma matriz de 10 milh√µes de n√∫meros √© obtido no site da JOCL:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayGPU</span> </span>{
    <span class="hljs-comment">/**
     * The source code of the OpenCL program 
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String programSource =
        <span class="hljs-string">"__kernel void "</span>+
        <span class="hljs-string">"sampleKernel(__global const float *a,"</span>+
        <span class="hljs-string">"             __global const float *b,"</span>+
        <span class="hljs-string">"             __global float *c)"</span>+
        <span class="hljs-string">"{"</span>+
        <span class="hljs-string">"    int gid = get_global_id(0);"</span>+
        <span class="hljs-string">"    c[gid] = a[gid] + b[gid];"</span>+
        <span class="hljs-string">"}"</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>
    </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10_000_000</span>;
        <span class="hljs-keyword">float</span> srcArrayA[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> srcArrayB[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> dstArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<font></font>
        {<font></font>
            srcArrayA[i] = i;<font></font>
            srcArrayB[i] = i;<font></font>
        }<font></font>
        Pointer srcA = Pointer.to(srcArrayA);<font></font>
        Pointer srcB = Pointer.to(srcArrayB);<font></font>
        Pointer dst = Pointer.to(dstArray);<font></font>
<font></font>
<font></font>
        <span class="hljs-comment">// The platform, device type and device number</span>
        <span class="hljs-comment">// that will be used</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> platformIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deviceType = CL.CL_DEVICE_TYPE_ALL;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> deviceIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Enable exceptions and subsequently omit error checks in this sample</span>
        CL.setExceptionsEnabled(<span class="hljs-keyword">true</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the number of platforms</span>
        <span class="hljs-keyword">int</span> numPlatformsArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetPlatformIDs(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numPlatformsArray);
        <span class="hljs-keyword">int</span> numPlatforms = numPlatformsArray[<span class="hljs-number">0</span>];<font></font>
<font></font>
        <span class="hljs-comment">// Obtain a platform ID</span>
        cl_platform_id platforms[] = <span class="hljs-keyword">new</span> cl_platform_id[numPlatforms];<font></font>
        CL.clGetPlatformIDs(platforms.length, platforms, <span class="hljs-keyword">null</span>);<font></font>
        cl_platform_id platform = platforms[platformIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Initialize the context properties</span>
        cl_context_properties contextProperties = <span class="hljs-keyword">new</span> cl_context_properties();<font></font>
        contextProperties.addProperty(CL.CL_CONTEXT_PLATFORM, platform);<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain the number of devices for the platform</span>
        <span class="hljs-keyword">int</span> numDevicesArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numDevicesArray);
        <span class="hljs-keyword">int</span> numDevices = numDevicesArray[<span class="hljs-number">0</span>];<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain a device ID </span>
        cl_device_id devices[] = <span class="hljs-keyword">new</span> cl_device_id[numDevices];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, numDevices, devices, <span class="hljs-keyword">null</span>);<font></font>
        cl_device_id device = devices[deviceIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Create a context for the selected device</span><font></font>
        cl_context context = CL.clCreateContext(<font></font>
            contextProperties, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> cl_device_id[]{device}, 
            <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create a command-queue for the selected device</span><font></font>
        cl_command_queue commandQueue = <font></font>
            CL.clCreateCommandQueue(context, device, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Allocate the memory objects for the input and output data</span>
        cl_mem memObjects[] = <span class="hljs-keyword">new</span> cl_mem[<span class="hljs-number">3</span>];<font></font>
        memObjects[<span class="hljs-number">0</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcA, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">1</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcB, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">2</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_WRITE,<font></font>
            Sizeof.cl_float * n, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the program from the source code</span><font></font>
        cl_program program = CL.clCreateProgramWithSource(context,<font></font>
            <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> String[]{ programSource }, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Build the program</span>
        CL.clBuildProgram(program, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the kernel</span>
        cl_kernel kernel = CL.clCreateKernel(program, <span class="hljs-string">"sampleKernel"</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Set the arguments for the kernel</span>
        CL.clSetKernelArg(kernel, <span class="hljs-number">0</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">0</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">1</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">1</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">2</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">2</span>]));<font></font>
        <font></font>
        <span class="hljs-comment">// Set the work-item dimensions</span>
        <span class="hljs-keyword">long</span> global_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{n};
        <span class="hljs-keyword">long</span> local_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{<span class="hljs-number">1</span>};<font></font>
        <font></font>
        <span class="hljs-comment">// Execute the kernel</span>
        CL.clEnqueueNDRangeKernel(commandQueue, kernel, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>,<font></font>
            global_work_size, local_work_size, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Read the output data</span>
        CL.clEnqueueReadBuffer(commandQueue, memObjects[<span class="hljs-number">2</span>], CL.CL_TRUE, <span class="hljs-number">0</span>,<font></font>
            n * Sizeof.cl_float, dst, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Release kernel, program, and memory objects</span>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">0</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">1</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">2</span>]);<font></font>
        CL.clReleaseKernel(kernel);<font></font>
        CL.clReleaseProgram(program);<font></font>
        CL.clReleaseCommandQueue(commandQueue);<font></font>
        CL.clReleaseContext(context);<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">(cl_device_id device, <span class="hljs-keyword">int</span> paramName)</span> </span>{
        <span class="hljs-comment">// Obtain the length of the string that will be queried</span>
        <span class="hljs-keyword">long</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceInfo(device, paramName, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, size);<font></font>
<font></font>
        <span class="hljs-comment">// Create a buffer of the appropriate size and fill it with the info</span>
        <span class="hljs-keyword">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)size[<span class="hljs-number">0</span>]];<font></font>
        CL.clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Create a string from the buffer (excluding the trailing \0 byte)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, buffer.length-<span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este c√≥digo n√£o √© como o c√≥digo Java, mas √©. Vou explicar mais o c√≥digo; n√£o gaste muito tempo com isso agora, porque discutirei brevemente solu√ß√µes complexas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo ser√° documentado, mas vamos fazer uma pequena explica√ß√£o. Como voc√™ pode ver, o c√≥digo √© muito semelhante ao c√≥digo em C. Isso √© normal porque o JOCL √© apenas OpenCL. No come√ßo, aqui est√° um c√≥digo na linha, e esse c√≥digo √© a parte mais importante: √© compilado usando o OpenCL e depois enviado para a placa de v√≠deo, onde √© executada. Este c√≥digo √© chamado Kernel. N√£o confunda este termo com o OC Kernel; Este √© o c√≥digo do dispositivo. Este c√≥digo √© escrito em um subconjunto de C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Depois que o kernel vem o c√≥digo Java para instalar e configurar o dispositivo, dividir os dados e criar os buffers de mem√≥ria apropriados para os dados resultantes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para resumir: aqui est√° o "c√≥digo do host", que geralmente √© uma liga√ß√£o de linguagem (no nosso caso, em Java) e o "c√≥digo do dispositivo". Voc√™ sempre destaca o que funcionar√° no host e o que deve funcionar no dispositivo, porque o host controla o dispositivo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O c√≥digo anterior deve mostrar a GPU equivalente a "Hello World!" Como voc√™ pode ver, a maior parte √© enorme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o vamos esquecer os recursos do SIMD. Se o seu dispositivo suportar extens√£o SIMD, voc√™ poder√° acelerar o c√≥digo aritm√©tico. Por exemplo, vamos dar uma olhada no c√≥digo de multiplica√ß√£o da matriz do kernel. Este c√≥digo est√° em uma linha Java simples no aplicativo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dim,
                  __global <span class="hljs-keyword">float</span> *A,
                  __global <span class="hljs-keyword">float</span> *B,
                  __global <span class="hljs-keyword">float</span> *C)</span></span>{<font></font>
<font></font>
    <span class="hljs-keyword">int</span> iCol = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> iRow = get_global_id(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; dim; ++i)<font></font>
    {<font></font>
          result +=<font></font>
          A[iRow*dim + i]*B[i*dim + iCol];<font></font>
    }<font></font>
    C[iRow*dim + iCol] = result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tecnicamente, esse c√≥digo funcionar√° em partes de dados que foram instaladas para voc√™ pela estrutura OpenCL, com as instru√ß√µes que voc√™ chamou na parte preparat√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se a sua placa de v√≠deo suportar instru√ß√µes SIMD e puder processar um vetor de quatro n√∫meros de ponto flutuante, pequenas otimiza√ß√µes poder√£o transformar o c√≥digo anterior no seguinte:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VECTOR_SIZE 4    </span>
<span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic_vector4</span><span class="hljs-params">(
    <span class="hljs-keyword">size_t</span> dim, <span class="hljs-comment">// dimension is in single floats</span>
    <span class="hljs-keyword">const</span> float4 *A,
    <span class="hljs-keyword">const</span> float4 *B,
    float4 *C)</span>
</span>{
    <span class="hljs-keyword">size_t</span> globalIdx = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">size_t</span> globalIdy = get_global_id(<span class="hljs-number">1</span>);<font></font>
    float4 resultVec = (float4){ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    <span class="hljs-keyword">size_t</span> dimVec = dim / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dimVec; ++i) {<font></font>
        float4 Avector = A[dimVec * globalIdy + i];<font></font>
        float4 Bvector[<span class="hljs-number">4</span>];<font></font>
        Bvector[<span class="hljs-number">0</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">1</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">2</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">3</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>) + globalIdx];<font></font>
        resultVec += Avector[<span class="hljs-number">0</span>] * Bvector[<span class="hljs-number">0</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">1</span>] * Bvector[<span class="hljs-number">1</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">2</span>] * Bvector[<span class="hljs-number">2</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">3</span>] * Bvector[<span class="hljs-number">3</span>];<font></font>
    }<font></font>
<font></font>
    C[dimVec * globalIdy + globalIdx] = resultVec;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com esse c√≥digo, voc√™ pode dobrar o desempenho. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Legal. </font><font style="vertical-align: inherit;">Voc√™ acabou de abrir a GPU para o mundo Java! </font><font style="vertical-align: inherit;">Mas como desenvolvedor Java, voc√™ realmente deseja fazer todo esse trabalho sujo, com c√≥digo C, e trabalhando com detalhes de baixo n√≠vel? </font><font style="vertical-align: inherit;">Eu n√£o quero. </font><font style="vertical-align: inherit;">Mas agora que voc√™ tem algum conhecimento de como a GPU √© usada, vejamos outra solu√ß√£o diferente do c√≥digo JOCL que acabei de apresentar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA e Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA √© a solu√ß√£o da Nvidia para esse problema de programa√ß√£o. </font><font style="vertical-align: inherit;">O CUDA fornece muito mais bibliotecas prontas para uso para opera√ß√µes padr√£o da GPU, como matrizes, histogramas e at√© redes neurais profundas. </font><font style="vertical-align: inherit;">Uma lista de bibliotecas j√° apareceu com v√°rias solu√ß√µes prontas. </font><font style="vertical-align: inherit;">Isso √© tudo do projeto JCuda:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCublas: tudo para matrizes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCufft: Transforma√ß√£o r√°pida de Fourier </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCurand: tudo para n√∫meros aleat√≥rios</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusparse: matrizes raras</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusolver: fatora√ß√£o de n√∫meros</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNvgraph: tudo para gr√°ficos </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudpp: biblioteca CUDA de dados paralelos primitivos e alguns algoritmos de classifica√ß√£o</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNpp: processamento de imagem da GPU</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudnn: biblioteca de rede neural profunda</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estou pensando em usar o JCurand, que gera n√∫meros aleat√≥rios. </font><font style="vertical-align: inherit;">Voc√™ pode usar isso no c√≥digo Java sem outra linguagem especial do Kernel. </font><font style="vertical-align: inherit;">Por exemplo:</font></font><br>
<br>
<pre><code class="java hljs">...
<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<font></font>
curandGenerator generator = <span class="hljs-keyword">new</span> curandGenerator();
<span class="hljs-keyword">float</span> hostData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<font></font>
Pointer deviceData = <span class="hljs-keyword">new</span> Pointer();<font></font>
cudaMalloc(deviceData, n * Sizeof.FLOAT);<font></font>
curandCreateGenerator(generator, CURAND_RNG_PSEUDO_DEFAULT); <font></font>
curandSetPseudoRandomGeneratorSeed(generator, <span class="hljs-number">1234</span>);<font></font>
curandGenerateUniform(generator, deviceData, n);<font></font>
cudaMemcpy(Pointer.to(hostData), deviceData, <font></font>
        n * Sizeof.FLOAT, cudaMemcpyDeviceToHost);<font></font>
System.out.println(Arrays.toString(hostData));<font></font>
curandDestroyGenerator(generator);<font></font>
cudaFree(deviceData);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ele usa uma GPU para criar um grande n√∫mero aleat√≥rio de alta qualidade, com base em uma matem√°tica muito forte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No JCuda, voc√™ tamb√©m pode escrever um c√≥digo CUDA gen√©rico e cham√°-lo de Java chamando algum arquivo JAR em seu caminho de classe. </font><font style="vertical-align: inherit;">Veja a documenta√ß√£o do JCuda para √≥timos exemplos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fique acima do c√≥digo de baixo n√≠vel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo parece √≥timo, mas h√° muito c√≥digo, muita instala√ß√£o, muitos idiomas diferentes para executar tudo. Existe uma maneira de usar a GPU pelo menos parcialmente? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E se voc√™ n√£o quiser pensar em todo esse OpenCL, CUDA e outras coisas desnecess√°rias? E se voc√™ quiser apenas programar em Java e n√£o pensar em tudo que n√£o √© √≥bvio? O projeto Aparapi pode ajudar. Aparapi √© baseado em uma "API paralela". Penso nisso como uma parte do Hibernate para programa√ß√£o de GPU que usa OpenCL sob o cap√¥. Vamos dar uma olhada em um exemplo de adi√ß√£o de vetor.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] _args)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">512</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    <span class="hljs-comment">/* fill the arrays with random values */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
        a[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
        b[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    Kernel kernel = <span class="hljs-keyword">new</span> Kernel(){
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
I           <span class="hljs-keyword">int</span> gid = getGlobalId();<font></font>
            sum[gid] = a[gid] + b[gid];<font></font>
        }<font></font>
    };<font></font>
<font></font>
    kernel.execute(Range.create(size));<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
        System.out.printf(<span class="hljs-string">"%6.2f + %6.2f = %8.2f\n"</span>, a[i], b[i], sum[i])<font></font>
    }<font></font>
    kernel.dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° o c√≥digo Java puro (retirado da documenta√ß√£o do Aparapi), tamb√©m aqui e ali, voc√™ pode ver um determinado termo Kernel e getGlobalId. </font><font style="vertical-align: inherit;">Voc√™ ainda precisa entender como programar a GPU, mas pode usar a abordagem da GPGPU de maneira mais semelhante ao Java. </font><font style="vertical-align: inherit;">Al√©m disso, o Aparapi fornece uma maneira f√°cil de usar o contexto OpenGL para a camada OpenCL - permitindo que os dados permane√ßam completamente na placa gr√°fica - e, assim, evite problemas de lat√™ncia da mem√≥ria. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ precisar fazer muitos c√°lculos independentes, consulte Aparapi. </font><font style="vertical-align: inherit;">Existem muitos exemplos de como usar a computa√ß√£o paralela. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al√©m disso, existe um projeto chamado TornadoVM - ele transfere automaticamente os c√°lculos apropriados da CPU para a GPU, fornecendo otimiza√ß√£o em massa imediata.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">achados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Existem muitas aplica√ß√µes em que as GPUs podem trazer algumas vantagens, mas voc√™ pode dizer que ainda existem alguns obst√°culos. </font><font style="vertical-align: inherit;">No entanto, Java e a GPU podem fazer grandes coisas juntos. </font><font style="vertical-align: inherit;">Neste artigo, apenas toquei neste t√≥pico extenso. </font><font style="vertical-align: inherit;">Pretendia mostrar v√°rias op√ß√µes de alto e baixo n√≠vel para acessar a GPU a partir de Java. </font><font style="vertical-align: inherit;">A explora√ß√£o dessa √°rea trar√° enormes benef√≠cios de desempenho, especialmente para tarefas complexas que exigem v√°rios c√°lculos que podem ser executados em paralelo. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link de origem</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt500076/index.html">Implantando aplicativos Java no OpenShift</a></li>
<li><a href="../pt500086/index.html">Escrevendo uma calculadora javascript</a></li>
<li><a href="../pt500100/index.html">TV primeiro, tipografia responsiva ou como n√£o esquecer todos os tamanhos de dispositivos</a></li>
<li><a href="../pt500102/index.html">Roslyn e EF Core: construindo um DbContext em tempo de execu√ß√£o</a></li>
<li><a href="../pt500104/index.html">Modelagem de processos de neg√≥cios, tradu√ß√£o autom√°tica de diagrama de texto e nota√ß√£o CH-1</a></li>
<li><a href="../pt500108/index.html">Estado (Primavera) na Shell (Primavera): n√£o produ√ß√£o √∫nica</a></li>
<li><a href="../pt500110/index.html">Uma palavra sobre a entrega de mercadorias</a></li>
<li><a href="../pt500114/index.html">Procura de emprego na Alemanha como gerente de produtos e muito mais. Parte 2/5. A estrutura do mercado de trabalho. ATS. Job boards</a></li>
<li><a href="../pt500116/index.html">O trabalho de uma equipe distribu√≠da em condi√ß√µes de auto-isolamento: como quase n√£o percebemos a diferen√ßa</a></li>
<li><a href="../pt500118/index.html">Cinco etapas para tornar o sistema de refer√™ncia inevit√°vel ou de venda cruzada</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>