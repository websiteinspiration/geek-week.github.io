<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😯 🐪 💧 Einfache Hash-Tabelle für GPU ⛹🏽 🌉 🕹️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe auf Github ein neues Projekt namens A Simple GPU Hash Table gepostet . 
 
 Dies ist eine einfache Hash-Tabelle für die GPU, die Hunderte Mill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Einfache Hash-Tabelle für GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auf Github ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neues Projekt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> namens </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> gepostet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine einfache Hash-Tabelle für die GPU, die Hunderte Millionen Einfügungen pro Sekunde verarbeiten kann. </font><font style="vertical-align: inherit;">Auf meinem Laptop mit einer NVIDIA GTX 1060 fügt der Code 64 Millionen zufällig generierte Schlüssel-Wert-Paare in ungefähr 210 ms ein und entfernt 32 Millionen Paare in ungefähr 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt, die Geschwindigkeit auf dem Laptop beträgt ungefähr 300 Millionen Einsätze / Sek. Und 500 Millionen Entfernungen / Sek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tabelle ist in CUDA geschrieben, obwohl dieselbe Technik auf HLSL oder GLSL angewendet werden kann. </font><font style="vertical-align: inherit;">Die Implementierung weist mehrere Einschränkungen auf, die eine hohe Leistung der Grafikkarte gewährleisten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden nur 32-Bit-Schlüssel und dieselben Werte verarbeitet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hash-Tabelle hat eine feste Größe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und diese Größe sollte gleich zwei Grad sein.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Schlüssel und Werte müssen Sie eine einfache Begrenzungsmarkierung reservieren (im obigen Code ist sie 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabelle ohne Sperren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle verwendet eine offene Adressierung mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearer Erfassung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">dh</font></a><font style="vertical-align: inherit;"> es handelt sich nur um ein Array von Schlüssel-Wert-Paaren, die im Speicher gespeichert sind und eine hervorragende Cache-Leistung aufweisen. </font><font style="vertical-align: inherit;">Dies ist bei der Verkettung nicht der Fall, dh es wird nach einem Zeiger in einer verknüpften Liste gesucht. </font><font style="vertical-align: inherit;">Eine Hash-Tabelle ist ein einfaches Array, in dem Elemente gespeichert werden </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Größe der Tabelle entspricht zwei Potenzen und ist keine Primzahl, da für die Verwendung der pow2 / AND-Maske eine kurze Anweisung ausreicht und der Moduloperator viel langsamer ist. Dies ist im Fall der linearen Erfassung wichtig, da bei einer linearen Suche in der Tabelle der Schlitzindex in jeden Schlitz eingeschlossen werden muss. Infolgedessen werden die Kosten der Operation in jedem Steckplatz modulo addiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tabelle werden nur der Schlüssel und der Wert für jedes Element gespeichert, nicht der Schlüssel-Hash. Da in der Tabelle nur 32-Bit-Schlüssel gespeichert sind, wird der Hash sehr schnell berechnet. Der obige Code verwendet den Murmur3-Hash, der nur wenige Verschiebungen, XORs und Multiplikationen ausführt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle verwendet eine Sperrschutztechnik, die nicht von der Speicherplatzierungsreihenfolge abhängt. Selbst wenn einige Schreibvorgänge die Reihenfolge anderer solcher Vorgänge verletzen, behält die Hash-Tabelle den korrekten Status bei. Wir werden weiter unten darüber sprechen. Die Technik funktioniert hervorragend mit Grafikkarten, bei denen Tausende von Threads miteinander konkurrieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schlüssel und Werte in der Hash-Tabelle werden so initialisiert, dass sie leer sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code kann so geändert werden, dass sowohl 64-Bit-Schlüssel als auch Werte verarbeitet werden können. Schlüssel erfordern atomare Lese-, Schreib- und Austauschoperationen (Vergleichen und Austauschen). Und Werte erfordern atomare Lese- und Schreiboperationen. Glücklicherweise sind in CUDA Lese- / Schreibvorgänge für 32- und 64-Bit-Werte atomar, solange sie natürlich ausgerichtet sind (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und moderne Grafikkarten unterstützen 64-Bit-Atomoperationen im Vergleich zum Austausch. </font><font style="vertical-align: inherit;">Wenn Sie auf 64 Bit umschalten, nimmt die Leistung natürlich leicht ab.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabellenstatus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Schlüssel-Wert-Paar in einer Hash-Tabelle kann einen von vier Zuständen haben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schlüssel und die Bedeutung sind leer. </font><font style="vertical-align: inherit;">In diesem Zustand wird die Hash-Tabelle initialisiert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schlüssel wurde aufgezeichnet, aber der Wert ist noch nicht. </font><font style="vertical-align: inherit;">Wenn in diesem Moment ein anderer Ausführungsthread Daten liest, wird ein leerer Wert zurückgegeben. </font><font style="vertical-align: inherit;">Dies ist normal, dasselbe würde passieren, wenn ein anderer Ausführungsthread etwas früher funktioniert und wir über eine wettbewerbsfähige Datenstruktur sprechen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sowohl der Schlüssel als auch der Wert werden aufgezeichnet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert ist für andere Ausführungsthreads verfügbar, der Schlüssel jedoch noch nicht. </font><font style="vertical-align: inherit;">Dies kann passieren, weil das CUDA-Programmiermodell ein schlecht geordnetes Speichermodell impliziert. </font><font style="vertical-align: inherit;">Dies ist normal, auf jeden Fall ist der Schlüssel noch leer, auch wenn der Wert nicht mehr so ​​ist.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine wichtige Nuance ist, dass sich der Schlüssel, sobald er in den Steckplatz geschrieben wurde, nicht mehr bewegt - selbst wenn der Schlüssel gelöscht wird, werden wir weiter unten darauf eingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hash-Tabellencode funktioniert sogar mit schlecht geordneten Speichermodellen, die die Reihenfolge des Lesens und Schreibens in den Speicher nicht kennen. </font><font style="vertical-align: inherit;">Denken Sie beim Analysieren des Einfügens, Suchens und Löschens in der Hash-Tabelle daran, dass sich jedes Schlüssel-Wert-Paar in einem der vier oben beschriebenen Zustände befindet.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In eine Hash-Tabelle einfügen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine CUDA-Funktion, die Schlüssel-Wert-Paare in eine Hash-Tabelle einfügt, sieht folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Schlüssel einzufügen, durchläuft der Code das Hash-Tabellen-Array, beginnend mit dem Hash des eingefügten Schlüssels. In jedem Schlitz des Arrays wird eine Atomvergleichsoperation mit dem Austausch durchgeführt, bei der der Schlüssel in diesem Schlitz mit einem leeren verglichen wird. Wenn eine Nichtübereinstimmung festgestellt wird, wird der Schlüssel im Steckplatz auf den eingefügten Schlüssel aktualisiert, und dann wird der ursprüngliche Schlüssel des Steckplatzes zurückgegeben. Wenn dieser ursprüngliche Schlüssel leer war oder dem eingefügten Schlüssel entsprach, fand der Code einen zum Einfügen geeigneten Steckplatz und brachte den eingefügten Wert in den Steckplatz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in einem Kernel-Aufruf</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt mehrere Elemente mit demselben Schlüssel, dann kann jeder ihrer Werte in den Schlüsselsteckplatz geschrieben werden. </font><font style="vertical-align: inherit;">Dies wird als normal angesehen: Eine der Schlüsselwert-Schreiboperationen während des Aufrufs ist erfolgreich, aber da dies alles parallel innerhalb mehrerer Ausführungsthreads geschieht, können wir nicht vorhersagen, welche Schreiboperation in den Speicher die letzte sein wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabellensuche</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key Finder Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Wert des in der Tabelle gespeicherten Schlüssels zu ermitteln, durchlaufen wir das Array beginnend mit dem Hash des gewünschten Schlüssels. </font><font style="vertical-align: inherit;">In jedem Slot prüfen wir, ob der Schlüssel der gesuchte ist, und geben in diesem Fall seinen Wert zurück. </font><font style="vertical-align: inherit;">Wir prüfen auch, ob der Schlüssel leer ist, und unterbrechen in diesem Fall die Suche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Schlüssel nicht finden können, gibt der Code einen leeren Wert zurück. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Suchvorgänge können beim Einfügen und Löschen wettbewerbsfähig ausgeführt werden. </font><font style="vertical-align: inherit;">Jedes Paar in der Tabelle hat einen der vier oben für den Stream beschriebenen Zustände.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Löschen der Hash-Tabelle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code zum Entfernen von Schlüsseln:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entfernen eines Schlüssels ist ungewöhnlich: Wir lassen den Schlüssel in der Tabelle und markieren seinen Wert (nicht den Schlüssel selbst) leer. </font><font style="vertical-align: inherit;">Dieser Code ist sehr ähnlich </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, außer dass, wenn eine Übereinstimmung für den Schlüssel gefunden wird, sein Wert leer wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erwähnt, bewegt sich der Schlüssel nicht mehr, sobald er in den Steckplatz geschrieben wurde. </font><font style="vertical-align: inherit;">Selbst wenn Sie ein Element aus der Tabelle löschen, bleibt der Schlüssel an Ort und Stelle, nur sein Wert wird leer. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die atomare Operation zum Schreiben des Werts des Slots nicht verwenden müssen, da es keine Rolle spielt, ob der aktuelle Wert leer ist oder nicht - er wird immer noch leer.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ändern Sie die Größe einer Hash-Tabelle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können die Größe der Hash-Tabelle ändern, indem Sie eine größere Tabelle erstellen und nicht leere Elemente aus der alten Tabelle einfügen. </font><font style="vertical-align: inherit;">Ich habe diese Funktionalität nicht implementiert, weil ich den Beispielcode einfach halten wollte. </font><font style="vertical-align: inherit;">Darüber hinaus erfolgt in CUDA-Programmen die Speicherzuweisung häufig im Host-Code und nicht im CUDA-Kern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Lock-Free Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt, wie eine solche sperrengeschützte Datenstruktur geändert wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wettbewerbsfähigkeit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem obigen Code - </font><font style="vertical-align: inherit;">Schnipsel, die Funktionen </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozess eines Schlüssel-Wert - </font><font style="vertical-align: inherit;">Paar zu einem Zeitpunkt. </font><font style="vertical-align: inherit;">Und darunter </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Reihe von paarweise parallel, wobei jedes Paar in einem gesonderten GPU Ausführungs - </font><font style="vertical-align: inherit;">Thread verarbeitet werden </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine abschließbare Hash-Tabelle unterstützt das gleichzeitige Einfügen, Suchen und Löschen. Da sich die Schlüssel-Wert-Paare immer in einem von vier Zuständen befinden und sich die Schlüssel nicht bewegen, garantiert die Tabelle die Richtigkeit, selbst wenn verschiedene Arten von Operationen verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch ein Paket von Einfügungen und Löschungen parallel verarbeiten und das Eingabearray von Paaren doppelte Schlüssel enthält, können wir nicht vorhersagen, welche Paare "gewinnen" werden - sie werden zuletzt in die Hash-Tabelle geschrieben. Angenommen, wir haben einen Einfügecode mit einem Eingabearray von Paaren aufgerufen </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Code fertig ist, sind die Paare </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantiert in der Tabelle vorhanden, aber gleichzeitig wird jedes der Paare darin angezeigt </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies kann ein Problem sein oder auch nicht - alles hängt von der Anwendung ab. Möglicherweise wissen Sie im Voraus, dass das Eingabearray keine doppelten Schlüssel enthält, oder es spielt für Sie keine Rolle, welcher Wert zuletzt geschrieben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies ein Problem für Sie ist, müssen Sie die doppelten Paare in verschiedene System-CUDA-Aufrufe aufteilen. In CUDA endet jede Kernelaufrufoperation immer vor dem nächsten Kernelaufruf (zumindest innerhalb desselben Threads. In verschiedenen Threads wird der Kernel parallel ausgeführt). Wenn Sie im obigen Beispiel einen Kern mit </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den anderen mit </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">erhält </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Schlüssel </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Wert </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun darüber sprechen, ob die Funktion </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein einfacher (einfacher) oder variabler (flüchtiger) Zeiger auf ein Array von Paaren in einer Hash-Tabelle verwendet werden.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der CUDA-Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heißt es:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler kann nach eigenem Ermessen die Lese- und Schreibvorgänge im globalen oder gemeinsam genutzten Speicher optimieren. Diese Optimierungen können mit dem Schlüsselwort deaktiviert werden </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... Jeder Link zu dieser Variablen wird zu einer echten Lese- oder Schreibanweisung im Speicher kompiliert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überlegungen zur Korrektheit erfordern keine Anwendung </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn der Ausführungsthread den zwischengespeicherten Wert einer früheren Leseoperation verwendet, bedeutet dies, dass er etwas veraltete Informationen verwendet. </font><font style="vertical-align: inherit;">Dies sind jedoch Informationen aus dem korrekten Status der Hash-Tabelle an einem bestimmten Punkt im Kernel-Aufruf. </font><font style="vertical-align: inherit;">Wenn Sie die neuesten Informationen verwenden müssen, können Sie den Zeiger verwenden </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber dann nimmt die Leistung leicht ab: Nach meinen Tests verringert sich die Geschwindigkeit beim Löschen von 32 Millionen Elementen von 500 Millionen Löschen / Sek. Auf 450 Millionen Löschen / Sek.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Test zum Einfügen und Löschen von 64 Millionen Elementen gibt es </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praktisch keine </font><font style="vertical-align: inherit;">Konkurrenz zwischen </font><font style="vertical-align: inherit;">und der Hash-Tabelle für die GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 691 ms für das Einfügen und Entfernen von Elementen mit anschließender Freigabe aufgewendet </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die Freigabe von Millionen von Elementen nimmt viel Zeit in Anspruch, da </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Inneren </font><font style="vertical-align: inherit;">zahlreiche Speicherzuweisungen durchgeführt werden). Ehrlich gesagt gibt es </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganz andere Einschränkungen. Dies ist ein einzelner CPU-Thread der Ausführung, er unterstützt Schlüsselwerte jeder Größe, funktioniert gut bei hohen Auslastungsraten und zeigt nach zahlreichen Löschungen eine stabile Leistung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Dauer der Hash-Tabelle für die GPU- und programmübergreifende Kommunikation betrug 984 ms. Dies umfasst die Zeit, die benötigt wird, um die Tabelle im Speicher abzulegen und zu löschen (einmalige Zuweisung von 1 GB Speicher, was in CUDA einige Zeit in Anspruch nimmt), das Einfügen und Löschen von Elementen sowie das Durchlaufen dieser Elemente. Berücksichtigt auch das gesamte Kopieren zum und vom Speicher der Grafikkarte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle selbst dauerte 271 ms. Dies schließt die Zeit ein, die die Grafikkarte zum Einsetzen und Entfernen von Elementen benötigt, und berücksichtigt nicht die Zeit, die zum Kopieren in den Speicher und zum Durchlaufen der resultierenden Tabelle benötigt wird. Wenn die GPU-Tabelle lange lebt oder wenn die Hash-Tabelle vollständig im Speicher der Grafikkarte enthalten ist (z. B. um eine Hash-Tabelle zu erstellen, die von einem anderen GPU-Code und nicht vom Zentralprozessor verwendet wird), ist das Testergebnis relevant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle für die Grafikkarte weist aufgrund ihrer hohen Bandbreite und aktiven Parallelisierung eine hohe Leistung auf.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachteile</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Hash-Tabellenarchitektur sind verschiedene Aspekte zu beachten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clustering stört die lineare Abtastung, weshalb die Schlüssel in der Tabelle alles andere als ideal sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlüssel werden nicht mit der Funktion gelöscht </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">überladen mit der </font><font style="vertical-align: inherit;">Zeit die Tabelle.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen kann die Leistung der Hash-Tabelle allmählich abnehmen, insbesondere wenn sie für eine lange Zeit vorhanden ist und zahlreiche Einfügungen und Löschungen darin durchgeführt werden. </font><font style="vertical-align: inherit;">Eine Möglichkeit, diese Mängel zu beheben, besteht darin, eine neue Tabelle mit einer relativ geringen Auslastungsrate erneut aufzuwärmen und beim Aufwärmen entfernte Schlüssel zu filtern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die beschriebenen Probleme zu veranschaulichen, verwende ich den obigen Code, um eine Tabelle für 128 Millionen Elemente zu erstellen. Ich füge zyklisch 4 Millionen Elemente ein, bis ich 124 Millionen Slots fülle (die Auslastung beträgt ungefähr 0,96). </font><font style="vertical-align: inherit;">Hier ist die Ergebnistabelle. Jede Zeile ist ein Aufruf des CUDA-Kerns mit dem Einfügen von 4 Millionen neuen Elementen in eine Hash-Tabelle:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nutzungsrate </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfügedauer 4 194 304 Elemente</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448 ms (361.314798 Millionen Schlüssel / Sek.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit zunehmender Auslastung nimmt die Produktivität ab. Dies ist in den meisten Fällen unerwünscht. Wenn eine Anwendung Elemente in eine Tabelle einfügt und diese dann verwirft (z. B. beim Zählen von Wörtern in einem Buch), ist dies kein Problem. Wenn die Anwendung jedoch eine langlebige Hash-Tabelle verwendet (z. B. in einem Grafikeditor, um nicht leere Teile von Bildern zu speichern, wenn der Benutzer häufig Informationen einfügt und löscht), kann dieses Verhalten problematisch sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und er maß die Tiefe der Prüfung der Hash-Tabelle nach 64 Millionen Inserts (Auslastungsfaktor 0,5). Die durchschnittliche Tiefe betrug 0,4774, sodass sich die meisten Schlüssel entweder im bestmöglichen Steckplatz oder in einem Steckplatz von der besten Position befanden. Die maximale Sondiertiefe betrug 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann habe ich die Sondiertiefe in der Tabelle mit 124 Millionen Einsätzen gemessen (Nutzungsrate 0,97). Die durchschnittliche Tiefe betrug bereits 10.1757 und das Maximum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Die linear klingende Leistung nimmt bei hohen Auslastungsraten dramatisch ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist am besten, diese Hash-Tabelle niedrig zu halten. Aber dann steigern wir die Produktivität, indem wir Speicher verbrauchen. Glücklicherweise kann dies bei 32-Bit-Schlüsseln und -Werten gerechtfertigt sein. Wenn im obigen Beispiel in der Tabelle für 128 Millionen Elemente der Auslastungskoeffizient von 0,25 gespeichert wird, können wir nicht mehr als 32 Millionen Elemente darin platzieren, und die verbleibenden 96 Millionen Steckplätze gehen verloren - 8 Bytes für jedes Paar, 768 MB verlorener Speicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass es sich um den Verlust des Grafikkartenspeichers handelt, der eine wertvollere Ressource als der Systemspeicher darstellt. </font><font style="vertical-align: inherit;">Obwohl die meisten modernen Desktop-Grafikkarten, die CUDA unterstützen, über mindestens 4 GB Arbeitsspeicher verfügen (zum Zeitpunkt des Schreibens verfügt NVIDIA 2080 Ti über 11 GB), ist der Verlust solcher Volumes nicht die klügste Entscheidung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Später werde ich mehr über das Erstellen von Hash-Tabellen für Grafikkarten schreiben, die keine Probleme mit der Klangtiefe haben, sowie über Möglichkeiten, Remote-Slots wiederzuverwenden.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefenmessung erfassen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Tiefe des Key Sounding zu bestimmen, können wir den Key Hash (seinen idealen Index in der Tabelle) aus seinem tatsächlichen Tabellenindex extrahieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Magie von zwei Binärzahlen im zusätzlichen Code und der Tatsache, dass die Kapazität der Hash-Tabelle gleich zwei ist, funktioniert dieser Ansatz auch dann, wenn der Schlüsselindex an den Anfang der Tabelle verschoben wird. </font><font style="vertical-align: inherit;">Nehmen Sie einen Schlüssel, der bei 1 gehasht, aber in Steckplatz 3 eingefügt wurde. Für eine Tabelle mit Kapazität 4 erhalten wir dann das, </font></font><code>(3 — 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was 2 entspricht.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Fragen oder Kommentare haben, schreiben Sie mir auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder öffnen Sie ein neues Thema im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ist von einigen großartigen Artikeln inspiriert:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einfachste sperrenfreie Hash-Tabelle der Welt</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine sperrfreie wartungsfreie Hash-Tabelle</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zukunft werde ich weiterhin über Hash-Tabellen-Implementierungen für Grafikkarten schreiben und deren Leistung analysieren. </font><font style="vertical-align: inherit;">Ich habe vor, Robin Hood und Kuckuck-Hash mit atomaren Operationen in Datenstrukturen zu verketten, zu hashen, die für Grafikkarten geeignet sind.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492540/index.html">Das Spiel "Warte einen Moment!" auf Arduino</a></li>
<li><a href="../de492546/index.html">Überprüfen der Sicherheitsanfälligkeit einer Website mit Nikto</a></li>
<li><a href="../de492548/index.html">Unity Machine Learning: Unterrichten von MO-Agenten, über Wände zu springen</a></li>
<li><a href="../de492552/index.html">Wie man in Barcelona in Quarantäne lebt und arbeitet</a></li>
<li><a href="../de492558/index.html">Hallo, das ist COVID19: Lebt das Coronavirus auf der Oberfläche eines Smartphones?</a></li>
<li><a href="../de492562/index.html">Drei nützliche Apache Ignite-Webinare in Ihrem Quarantäneprogramm</a></li>
<li><a href="../de492566/index.html">Analyse der Kombination eines Suchalgorithmus für gierige Klicks mit teilweiser Aufzählung von Diagrammscheitelpunkten</a></li>
<li><a href="../de492568/index.html">Holen Sie sich einen Auszug aus Rosreestr über FSIS USRN und Python. Teil 2</a></li>
<li><a href="../de492572/index.html">Der aktuelle Stand der Java-Welt: Trends und Fakten für eine der beliebtesten Programmiersprachen</a></li>
<li><a href="../de492574/index.html">Überlegungen zur Startwahrscheinlichkeit: Apple AirPods mit Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>