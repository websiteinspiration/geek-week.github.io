<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòØ üê™ üíß Einfache Hash-Tabelle f√ºr GPU ‚õπüèΩ üåâ üïπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe auf Github ein neues Projekt namens A Simple GPU Hash Table gepostet . 
 
 Dies ist eine einfache Hash-Tabelle f√ºr die GPU, die Hunderte Mill...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Einfache Hash-Tabelle f√ºr GPU</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/492560/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m2/fd/e_/m2fde_n27bcwfhvj00ovkweqofm.jpeg" width="400"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe auf Github ein </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neues Projekt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> namens </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">A Simple GPU Hash Table</font></a><font style="vertical-align: inherit;"> gepostet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine einfache Hash-Tabelle f√ºr die GPU, die Hunderte Millionen Einf√ºgungen pro Sekunde verarbeiten kann. </font><font style="vertical-align: inherit;">Auf meinem Laptop mit einer NVIDIA GTX 1060 f√ºgt der Code 64 Millionen zuf√§llig generierte Schl√ºssel-Wert-Paare in ungef√§hr 210 ms ein und entfernt 32 Millionen Paare in ungef√§hr 64 ms. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das hei√üt, die Geschwindigkeit auf dem Laptop betr√§gt ungef√§hr 300 Millionen Eins√§tze / Sek. Und 500 Millionen Entfernungen / Sek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tabelle ist in CUDA geschrieben, obwohl dieselbe Technik auf HLSL oder GLSL angewendet werden kann. </font><font style="vertical-align: inherit;">Die Implementierung weist mehrere Einschr√§nkungen auf, die eine hohe Leistung der Grafikkarte gew√§hrleisten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es werden nur 32-Bit-Schl√ºssel und dieselben Werte verarbeitet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hash-Tabelle hat eine feste Gr√∂√üe.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und diese Gr√∂√üe sollte gleich zwei Grad sein.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr Schl√ºssel und Werte m√ºssen Sie eine einfache Begrenzungsmarkierung reservieren (im obigen Code ist sie 0xffffffff).</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabelle ohne Sperren</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle verwendet eine offene Adressierung mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearer Erfassung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;">dh</font></a><font style="vertical-align: inherit;"> es handelt sich nur um ein Array von Schl√ºssel-Wert-Paaren, die im Speicher gespeichert sind und eine hervorragende Cache-Leistung aufweisen. </font><font style="vertical-align: inherit;">Dies ist bei der Verkettung nicht der Fall, dh es wird nach einem Zeiger in einer verkn√ºpften Liste gesucht. </font><font style="vertical-align: inherit;">Eine Hash-Tabelle ist ein einfaches Array, in dem Elemente gespeichert werden </font></font><code>KeyValue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">KeyValue</span>
{</span>
    <span class="hljs-keyword">uint32_t</span> key;
    <span class="hljs-keyword">uint32_t</span> value;<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Gr√∂√üe der Tabelle entspricht zwei Potenzen und ist keine Primzahl, da f√ºr die Verwendung der pow2 / AND-Maske eine kurze Anweisung ausreicht und der Moduloperator viel langsamer ist. Dies ist im Fall der linearen Erfassung wichtig, da bei einer linearen Suche in der Tabelle der Schlitzindex in jeden Schlitz eingeschlossen werden muss. Infolgedessen werden die Kosten der Operation in jedem Steckplatz modulo addiert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Tabelle werden nur der Schl√ºssel und der Wert f√ºr jedes Element gespeichert, nicht der Schl√ºssel-Hash. Da in der Tabelle nur 32-Bit-Schl√ºssel gespeichert sind, wird der Hash sehr schnell berechnet. Der obige Code verwendet den Murmur3-Hash, der nur wenige Verschiebungen, XORs und Multiplikationen ausf√ºhrt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle verwendet eine Sperrschutztechnik, die nicht von der Speicherplatzierungsreihenfolge abh√§ngt. Selbst wenn einige Schreibvorg√§nge die Reihenfolge anderer solcher Vorg√§nge verletzen, beh√§lt die Hash-Tabelle den korrekten Status bei. Wir werden weiter unten dar√ºber sprechen. Die Technik funktioniert hervorragend mit Grafikkarten, bei denen Tausende von Threads miteinander konkurrieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schl√ºssel und Werte in der Hash-Tabelle werden so initialisiert, dass sie leer sind. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code kann so ge√§ndert werden, dass sowohl 64-Bit-Schl√ºssel als auch Werte verarbeitet werden k√∂nnen. Schl√ºssel erfordern atomare Lese-, Schreib- und Austauschoperationen (Vergleichen und Austauschen). Und Werte erfordern atomare Lese- und Schreiboperationen. Gl√ºcklicherweise sind in CUDA Lese- / Schreibvorg√§nge f√ºr 32- und 64-Bit-Werte atomar, solange sie nat√ºrlich ausgerichtet sind (siehe </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und moderne Grafikkarten unterst√ºtzen 64-Bit-Atomoperationen im Vergleich zum Austausch. </font><font style="vertical-align: inherit;">Wenn Sie auf 64 Bit umschalten, nimmt die Leistung nat√ºrlich leicht ab.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabellenstatus</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes Schl√ºssel-Wert-Paar in einer Hash-Tabelle kann einen von vier Zust√§nden haben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schl√ºssel und die Bedeutung sind leer. </font><font style="vertical-align: inherit;">In diesem Zustand wird die Hash-Tabelle initialisiert.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Schl√ºssel wurde aufgezeichnet, aber der Wert ist noch nicht. </font><font style="vertical-align: inherit;">Wenn in diesem Moment ein anderer Ausf√ºhrungsthread Daten liest, wird ein leerer Wert zur√ºckgegeben. </font><font style="vertical-align: inherit;">Dies ist normal, dasselbe w√ºrde passieren, wenn ein anderer Ausf√ºhrungsthread etwas fr√ºher funktioniert und wir √ºber eine wettbewerbsf√§hige Datenstruktur sprechen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sowohl der Schl√ºssel als auch der Wert werden aufgezeichnet.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert ist f√ºr andere Ausf√ºhrungsthreads verf√ºgbar, der Schl√ºssel jedoch noch nicht. </font><font style="vertical-align: inherit;">Dies kann passieren, weil das CUDA-Programmiermodell ein schlecht geordnetes Speichermodell impliziert. </font><font style="vertical-align: inherit;">Dies ist normal, auf jeden Fall ist der Schl√ºssel noch leer, auch wenn der Wert nicht mehr so ‚Äã‚Äãist.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine wichtige Nuance ist, dass sich der Schl√ºssel, sobald er in den Steckplatz geschrieben wurde, nicht mehr bewegt - selbst wenn der Schl√ºssel gel√∂scht wird, werden wir weiter unten darauf eingehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hash-Tabellencode funktioniert sogar mit schlecht geordneten Speichermodellen, die die Reihenfolge des Lesens und Schreibens in den Speicher nicht kennen. </font><font style="vertical-align: inherit;">Denken Sie beim Analysieren des Einf√ºgens, Suchens und L√∂schens in der Hash-Tabelle daran, dass sich jedes Schl√ºssel-Wert-Paar in einem der vier oben beschriebenen Zust√§nde befindet.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In eine Hash-Tabelle einf√ºgen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine CUDA-Funktion, die Schl√ºssel-Wert-Paare in eine Hash-Tabelle einf√ºgt, sieht folgenderma√üen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">uint32_t</span> prev = atomicCAS(&amp;hashtable[slot].key, kEmpty, key);
        <span class="hljs-keyword">if</span> (prev == kEmpty || prev == key)<font></font>
        {<font></font>
            hashtable[slot].value = value;<font></font>
            <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity<span class="hljs-number">-1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um einen Schl√ºssel einzuf√ºgen, durchl√§uft der Code das Hash-Tabellen-Array, beginnend mit dem Hash des eingef√ºgten Schl√ºssels. In jedem Schlitz des Arrays wird eine Atomvergleichsoperation mit dem Austausch durchgef√ºhrt, bei der der Schl√ºssel in diesem Schlitz mit einem leeren verglichen wird. Wenn eine Nicht√ºbereinstimmung festgestellt wird, wird der Schl√ºssel im Steckplatz auf den eingef√ºgten Schl√ºssel aktualisiert, und dann wird der urspr√ºngliche Schl√ºssel des Steckplatzes zur√ºckgegeben. Wenn dieser urspr√ºngliche Schl√ºssel leer war oder dem eingef√ºgten Schl√ºssel entsprach, fand der Code einen zum Einf√ºgen geeigneten Steckplatz und brachte den eingef√ºgten Wert in den Steckplatz. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn in einem Kernel-Aufruf</font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt mehrere Elemente mit demselben Schl√ºssel, dann kann jeder ihrer Werte in den Schl√ºsselsteckplatz geschrieben werden. </font><font style="vertical-align: inherit;">Dies wird als normal angesehen: Eine der Schl√ºsselwert-Schreiboperationen w√§hrend des Aufrufs ist erfolgreich, aber da dies alles parallel innerhalb mehrerer Ausf√ºhrungsthreads geschieht, k√∂nnen wir nicht vorhersagen, welche Schreiboperation in den Speicher die letzte sein wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hash-Tabellensuche</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Key Finder Code:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span> <span class="hljs-title">gpu_hashtable_lookup</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key)</span>
</span>{
        <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
        {<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> hashtable[slot].value;<font></font>
            }<font></font>
            <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
            {<font></font>
                <span class="hljs-keyword">return</span> kEmpty;<font></font>
            }<font></font>
            slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
        }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Wert des in der Tabelle gespeicherten Schl√ºssels zu ermitteln, durchlaufen wir das Array beginnend mit dem Hash des gew√ºnschten Schl√ºssels. </font><font style="vertical-align: inherit;">In jedem Slot pr√ºfen wir, ob der Schl√ºssel der gesuchte ist, und geben in diesem Fall seinen Wert zur√ºck. </font><font style="vertical-align: inherit;">Wir pr√ºfen auch, ob der Schl√ºssel leer ist, und unterbrechen in diesem Fall die Suche. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir den Schl√ºssel nicht finden k√∂nnen, gibt der Code einen leeren Wert zur√ºck. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alle diese Suchvorg√§nge k√∂nnen beim Einf√ºgen und L√∂schen wettbewerbsf√§hig ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Jedes Paar in der Tabelle hat einen der vier oben f√ºr den Stream beschriebenen Zust√§nde.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L√∂schen der Hash-Tabelle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Code zum Entfernen von Schl√ºsseln:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_delete</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">uint32_t</span> key, <span class="hljs-keyword">uint32_t</span> value)</span>
</span>{
    <span class="hljs-keyword">uint32_t</span> slot = hash(key);<font></font>
<font></font>
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == key)<font></font>
        {<font></font>
            hashtable[slot].value = kEmpty;<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">if</span> (hashtable[slot].key == kEmpty)<font></font>
        {<font></font>
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
        slot = (slot + <span class="hljs-number">1</span>) &amp; (kHashTableCapacity - <span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Entfernen eines Schl√ºssels ist ungew√∂hnlich: Wir lassen den Schl√ºssel in der Tabelle und markieren seinen Wert (nicht den Schl√ºssel selbst) leer. </font><font style="vertical-align: inherit;">Dieser Code ist sehr √§hnlich </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, au√üer dass, wenn eine √úbereinstimmung f√ºr den Schl√ºssel gefunden wird, sein Wert leer wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie oben erw√§hnt, bewegt sich der Schl√ºssel nicht mehr, sobald er in den Steckplatz geschrieben wurde. </font><font style="vertical-align: inherit;">Selbst wenn Sie ein Element aus der Tabelle l√∂schen, bleibt der Schl√ºssel an Ort und Stelle, nur sein Wert wird leer. </font><font style="vertical-align: inherit;">Dies bedeutet, dass wir die atomare Operation zum Schreiben des Werts des Slots nicht verwenden m√ºssen, da es keine Rolle spielt, ob der aktuelle Wert leer ist oder nicht - er wird immer noch leer.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√Ñndern Sie die Gr√∂√üe einer Hash-Tabelle</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnen die Gr√∂√üe der Hash-Tabelle √§ndern, indem Sie eine gr√∂√üere Tabelle erstellen und nicht leere Elemente aus der alten Tabelle einf√ºgen. </font><font style="vertical-align: inherit;">Ich habe diese Funktionalit√§t nicht implementiert, weil ich den Beispielcode einfach halten wollte. </font><font style="vertical-align: inherit;">Dar√ºber hinaus erfolgt in CUDA-Programmen die Speicherzuweisung h√§ufig im Host-Code und nicht im CUDA-Kern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Lock-Free Wait-Free Hash Table</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beschreibt, wie eine solche sperrengesch√ºtzte Datenstruktur ge√§ndert wird.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wettbewerbsf√§higkeit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In dem obigen Code - </font><font style="vertical-align: inherit;">Schnipsel, die Funktionen </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozess eines Schl√ºssel-Wert - </font><font style="vertical-align: inherit;">Paar zu einem Zeitpunkt. </font><font style="vertical-align: inherit;">Und darunter </font></font><code>gpu_hashtable_insert()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>_lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sie </font></font><code>_delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine Reihe von paarweise parallel, wobei jedes Paar in einem gesonderten GPU Ausf√ºhrungs - </font><font style="vertical-align: inherit;">Thread verarbeitet werden </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// CPU code to invoke the CUDA kernel on the GPU</span>
<span class="hljs-keyword">uint32_t</span> threadblocksize = <span class="hljs-number">1024</span>;
<span class="hljs-keyword">uint32_t</span> gridsize = (numkvs + threadblocksize - <span class="hljs-number">1</span>) / threadblocksize;<font></font>
gpu_hashtable_insert_kernel&lt;&lt;&lt;gridsize, threadblocksize&gt;&gt;&gt;(hashtable, kvs, numkvs);<font></font>
<font></font>
<span class="hljs-comment">// GPU code to process numkvs key/values in parallel</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gpu_hashtable_insert_kernel</span><span class="hljs-params">(KeyValue* hashtable, <span class="hljs-keyword">const</span> KeyValue* kvs, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> numkvs)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> threadid = blockIdx.x*blockDim.x + threadIdx.x;
    <span class="hljs-keyword">if</span> (threadid &lt; numkvs)<font></font>
    {<font></font>
        gpu_hashtable_insert(hashtable, kvs[threadid].key, kvs[threadid].value);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine abschlie√übare Hash-Tabelle unterst√ºtzt das gleichzeitige Einf√ºgen, Suchen und L√∂schen. Da sich die Schl√ºssel-Wert-Paare immer in einem von vier Zust√§nden befinden und sich die Schl√ºssel nicht bewegen, garantiert die Tabelle die Richtigkeit, selbst wenn verschiedene Arten von Operationen verwendet werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir jedoch ein Paket von Einf√ºgungen und L√∂schungen parallel verarbeiten und das Eingabearray von Paaren doppelte Schl√ºssel enth√§lt, k√∂nnen wir nicht vorhersagen, welche Paare "gewinnen" werden - sie werden zuletzt in die Hash-Tabelle geschrieben. Angenommen, wir haben einen Einf√ºgecode mit einem Eingabearray von Paaren aufgerufen </font></font><code>A/0 B/1 A/2 C/3 A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn der Code fertig ist, sind die Paare </font></font><code>B/1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">garantiert in der Tabelle vorhanden, aber gleichzeitig wird jedes der Paare darin angezeigt </font></font><code>A/0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>A/2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dies kann ein Problem sein oder auch nicht - alles h√§ngt von der Anwendung ab. M√∂glicherweise wissen Sie im Voraus, dass das Eingabearray keine doppelten Schl√ºssel enth√§lt, oder es spielt f√ºr Sie keine Rolle, welcher Wert zuletzt geschrieben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn dies ein Problem f√ºr Sie ist, m√ºssen Sie die doppelten Paare in verschiedene System-CUDA-Aufrufe aufteilen. In CUDA endet jede Kernelaufrufoperation immer vor dem n√§chsten Kernelaufruf (zumindest innerhalb desselben Threads. In verschiedenen Threads wird der Kernel parallel ausgef√ºhrt). Wenn Sie im obigen Beispiel einen Kern mit </font></font><code>A/0 B/1 A/2 C/3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und den anderen mit </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">, </font><font style="vertical-align: inherit;">erh√§lt </font></font><code>A/4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Schl√ºssel </font></font><code>A</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einen Wert </font></font><code>4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns nun dar√ºber sprechen, ob die Funktion </font></font><code>lookup()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ein einfacher (einfacher) oder variabler (fl√ºchtiger) Zeiger auf ein Array von Paaren in einer Hash-Tabelle verwendet werden.</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In der CUDA-Dokumentation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hei√üt es:</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Compiler kann nach eigenem Ermessen die Lese- und Schreibvorg√§nge im globalen oder gemeinsam genutzten Speicher optimieren. Diese Optimierungen k√∂nnen mit dem Schl√ºsselwort deaktiviert werden </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: ... Jeder Link zu dieser Variablen wird zu einer echten Lese- oder Schreibanweisung im Speicher kompiliert.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√úberlegungen zur Korrektheit erfordern keine Anwendung </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn der Ausf√ºhrungsthread den zwischengespeicherten Wert einer fr√ºheren Leseoperation verwendet, bedeutet dies, dass er etwas veraltete Informationen verwendet. </font><font style="vertical-align: inherit;">Dies sind jedoch Informationen aus dem korrekten Status der Hash-Tabelle an einem bestimmten Punkt im Kernel-Aufruf. </font><font style="vertical-align: inherit;">Wenn Sie die neuesten Informationen verwenden m√ºssen, k√∂nnen Sie den Zeiger verwenden </font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, aber dann nimmt die Leistung leicht ab: Nach meinen Tests verringert sich die Geschwindigkeit beim L√∂schen von 32 Millionen Elementen von 500 Millionen L√∂schen / Sek. Auf 450 Millionen L√∂schen / Sek.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performance</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Test zum Einf√ºgen und L√∂schen von 64 Millionen Elementen gibt es </font></font><code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">praktisch keine </font><font style="vertical-align: inherit;">Konkurrenz zwischen </font><font style="vertical-align: inherit;">und der Hash-Tabelle f√ºr die GPU:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f10/342/41f/f1034241fbcf8c6f9ac61e2061aabf4a.png"></div><br>
<code>std::unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70 691 ms f√ºr das Einf√ºgen und Entfernen von Elementen mit anschlie√üender Freigabe aufgewendet </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(die Freigabe von Millionen von Elementen nimmt viel Zeit in Anspruch, da </font></font><code>unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">im </font><font style="vertical-align: inherit;">Inneren </font><font style="vertical-align: inherit;">zahlreiche Speicherzuweisungen durchgef√ºhrt werden). Ehrlich gesagt gibt es </font></font><code>std:unordered_map</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganz andere Einschr√§nkungen. Dies ist ein einzelner CPU-Thread der Ausf√ºhrung, er unterst√ºtzt Schl√ºsselwerte jeder Gr√∂√üe, funktioniert gut bei hohen Auslastungsraten und zeigt nach zahlreichen L√∂schungen eine stabile Leistung.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Dauer der Hash-Tabelle f√ºr die GPU- und programm√ºbergreifende Kommunikation betrug 984 ms. Dies umfasst die Zeit, die ben√∂tigt wird, um die Tabelle im Speicher abzulegen und zu l√∂schen (einmalige Zuweisung von 1 GB Speicher, was in CUDA einige Zeit in Anspruch nimmt), das Einf√ºgen und L√∂schen von Elementen sowie das Durchlaufen dieser Elemente. Ber√ºcksichtigt auch das gesamte Kopieren zum und vom Speicher der Grafikkarte. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle selbst dauerte 271 ms. Dies schlie√üt die Zeit ein, die die Grafikkarte zum Einsetzen und Entfernen von Elementen ben√∂tigt, und ber√ºcksichtigt nicht die Zeit, die zum Kopieren in den Speicher und zum Durchlaufen der resultierenden Tabelle ben√∂tigt wird. Wenn die GPU-Tabelle lange lebt oder wenn die Hash-Tabelle vollst√§ndig im Speicher der Grafikkarte enthalten ist (z. B. um eine Hash-Tabelle zu erstellen, die von einem anderen GPU-Code und nicht vom Zentralprozessor verwendet wird), ist das Testergebnis relevant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hash-Tabelle f√ºr die Grafikkarte weist aufgrund ihrer hohen Bandbreite und aktiven Parallelisierung eine hohe Leistung auf.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nachteile</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Hash-Tabellenarchitektur sind verschiedene Aspekte zu beachten:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clustering st√∂rt die lineare Abtastung, weshalb die Schl√ºssel in der Tabelle alles andere als ideal sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schl√ºssel werden nicht mit der Funktion gel√∂scht </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">√ºberladen mit der </font><font style="vertical-align: inherit;">Zeit die Tabelle.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Infolgedessen kann die Leistung der Hash-Tabelle allm√§hlich abnehmen, insbesondere wenn sie f√ºr eine lange Zeit vorhanden ist und zahlreiche Einf√ºgungen und L√∂schungen darin durchgef√ºhrt werden. </font><font style="vertical-align: inherit;">Eine M√∂glichkeit, diese M√§ngel zu beheben, besteht darin, eine neue Tabelle mit einer relativ geringen Auslastungsrate erneut aufzuw√§rmen und beim Aufw√§rmen entfernte Schl√ºssel zu filtern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die beschriebenen Probleme zu veranschaulichen, verwende ich den obigen Code, um eine Tabelle f√ºr 128 Millionen Elemente zu erstellen. Ich f√ºge zyklisch 4 Millionen Elemente ein, bis ich 124 Millionen Slots f√ºlle (die Auslastung betr√§gt ungef√§hr 0,96). </font><font style="vertical-align: inherit;">Hier ist die Ergebnistabelle. Jede Zeile ist ein Aufruf des CUDA-Kerns mit dem Einf√ºgen von 4 Millionen neuen Elementen in eine Hash-Tabelle:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nutzungsrate </font></font></strong></td>
<td><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einf√ºgedauer 4 194 304 Elemente</font></font></strong></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,00</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11.608448 ms (361.314798 Millionen Schl√ºssel / Sek.)</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,03</font></font></td>
<td>11,751424  (356,918799  /.)</td>
</tr>
<tr>
<td>0,06</td>
<td>11,942592  (351,205515  /.)</td>
</tr>
<tr>
<td>0,09</td>
<td>12,081120  (347,178429  /.)</td>
</tr>
<tr>
<td>0,12</td>
<td>12,242560  (342,600233  /.)</td>
</tr>
<tr>
<td>0,16</td>
<td>12,396448  (338,347235  /.)</td>
</tr>
<tr>
<td>0,19</td>
<td>12,533024  (334,660176  /.)</td>
</tr>
<tr>
<td>0,22</td>
<td>12,703328  (330,173626  /.)</td>
</tr>
<tr>
<td>0,25</td>
<td>12,884512  (325,530693  /.)</td>
</tr>
<tr>
<td>0,28</td>
<td>13,033472  (321,810182  /.)</td>
</tr>
<tr>
<td>0,31</td>
<td>13,239296  (316,807174  /.)</td>
</tr>
<tr>
<td>0,34</td>
<td>13,392448  (313,184256  /.)</td>
</tr>
<tr>
<td>0,37</td>
<td>13,624000  (307,861434  /.)</td>
</tr>
<tr>
<td>0,41</td>
<td>13,875520  (302,280855  /.)</td>
</tr>
<tr>
<td>0,44</td>
<td>14,126528  (296,909756  /.)</td>
</tr>
<tr>
<td>0,47</td>
<td>14,399328  (291,284699  /.)</td>
</tr>
<tr>
<td>0,50</td>
<td>14,690304  (285,515123  /.)</td>
</tr>
<tr>
<td>0,53</td>
<td>15,039136  (278,892623  /.)</td>
</tr>
<tr>
<td>0,56</td>
<td>15,478656  (270,973402  /.)</td>
</tr>
<tr>
<td>0,59</td>
<td>15,985664  (262,379092  /.)</td>
</tr>
<tr>
<td>0,62</td>
<td>16,668673  (251,627968  /.)</td>
</tr>
<tr>
<td>0,66</td>
<td>17,587200  (238,486174  /.)</td>
</tr>
<tr>
<td>0,69</td>
<td>18,690048  (224,413765  /.)</td>
</tr>
<tr>
<td>0,72</td>
<td>20,278816  (206,831789  /.)</td>
</tr>
<tr>
<td>0,75</td>
<td>22,545408  (186,038058  /.)</td>
</tr>
<tr>
<td>0,78</td>
<td>26,053312  (160,989275  /.)</td>
</tr>
<tr>
<td>0,81</td>
<td>31,895008  (131,503463  /.)</td>
</tr>
<tr>
<td>0,84</td>
<td>42,103294  (99,619378  /.)</td>
</tr>
<tr>
<td>0,87</td>
<td>61,849056  (67,815164  /.)</td>
</tr>
<tr>
<td>0,90</td>
<td>105,695999  (39,682713  /.)</td>
</tr>
<tr>
<td>0,94</td>
<td>240,204636  (17,461378  /.)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit zunehmender Auslastung nimmt die Produktivit√§t ab. Dies ist in den meisten F√§llen unerw√ºnscht. Wenn eine Anwendung Elemente in eine Tabelle einf√ºgt und diese dann verwirft (z. B. beim Z√§hlen von W√∂rtern in einem Buch), ist dies kein Problem. Wenn die Anwendung jedoch eine langlebige Hash-Tabelle verwendet (z. B. in einem Grafikeditor, um nicht leere Teile von Bildern zu speichern, wenn der Benutzer h√§ufig Informationen einf√ºgt und l√∂scht), kann dieses Verhalten problematisch sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und er ma√ü die Tiefe der Pr√ºfung der Hash-Tabelle nach 64 Millionen Inserts (Auslastungsfaktor 0,5). Die durchschnittliche Tiefe betrug 0,4774, sodass sich die meisten Schl√ºssel entweder im bestm√∂glichen Steckplatz oder in einem Steckplatz von der besten Position befanden. Die maximale Sondiertiefe betrug 60.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann habe ich die Sondiertiefe in der Tabelle mit 124 Millionen Eins√§tzen gemessen (Nutzungsrate 0,97). Die durchschnittliche Tiefe betrug bereits 10.1757 und das Maximum - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6474</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (!!). Die linear klingende Leistung nimmt bei hohen Auslastungsraten dramatisch ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist am besten, diese Hash-Tabelle niedrig zu halten. Aber dann steigern wir die Produktivit√§t, indem wir Speicher verbrauchen. Gl√ºcklicherweise kann dies bei 32-Bit-Schl√ºsseln und -Werten gerechtfertigt sein. Wenn im obigen Beispiel in der Tabelle f√ºr 128 Millionen Elemente der Auslastungskoeffizient von 0,25 gespeichert wird, k√∂nnen wir nicht mehr als 32 Millionen Elemente darin platzieren, und die verbleibenden 96 Millionen Steckpl√§tze gehen verloren - 8 Bytes f√ºr jedes Paar, 768 MB verlorener Speicher.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bitte beachten Sie, dass es sich um den Verlust des Grafikkartenspeichers handelt, der eine wertvollere Ressource als der Systemspeicher darstellt. </font><font style="vertical-align: inherit;">Obwohl die meisten modernen Desktop-Grafikkarten, die CUDA unterst√ºtzen, √ºber mindestens 4 GB Arbeitsspeicher verf√ºgen (zum Zeitpunkt des Schreibens verf√ºgt NVIDIA 2080 Ti √ºber 11 GB), ist der Verlust solcher Volumes nicht die kl√ºgste Entscheidung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sp√§ter werde ich mehr √ºber das Erstellen von Hash-Tabellen f√ºr Grafikkarten schreiben, die keine Probleme mit der Klangtiefe haben, sowie √ºber M√∂glichkeiten, Remote-Slots wiederzuverwenden.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiefenmessung erfassen</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Tiefe des Key Sounding zu bestimmen, k√∂nnen wir den Key Hash (seinen idealen Index in der Tabelle) aus seinem tats√§chlichen Tabellenindex extrahieren:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// get_key_index() -&gt; index of key in hash table</span>
<span class="hljs-keyword">uint32_t</span> probelength = (get_key_index(key) - hash(key)) &amp; (hashtablecapacity<span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Magie von zwei Bin√§rzahlen im zus√§tzlichen Code und der Tatsache, dass die Kapazit√§t der Hash-Tabelle gleich zwei ist, funktioniert dieser Ansatz auch dann, wenn der Schl√ºsselindex an den Anfang der Tabelle verschoben wird. </font><font style="vertical-align: inherit;">Nehmen Sie einen Schl√ºssel, der bei 1 gehasht, aber in Steckplatz 3 eingef√ºgt wurde. F√ºr eine Tabelle mit Kapazit√§t 4 erhalten wir dann das, </font></font><code>(3 ‚Äî 1) &amp; 3</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">was 2 entspricht.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie Fragen oder Kommentare haben, schreiben Sie mir auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder √∂ffnen Sie ein neues Thema im </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ist von einigen gro√üartigen Artikeln inspiriert:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die einfachste sperrenfreie Hash-Tabelle der Welt</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine sperrfreie wartungsfreie Hash-Tabelle</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Zukunft werde ich weiterhin √ºber Hash-Tabellen-Implementierungen f√ºr Grafikkarten schreiben und deren Leistung analysieren. </font><font style="vertical-align: inherit;">Ich habe vor, Robin Hood und Kuckuck-Hash mit atomaren Operationen in Datenstrukturen zu verketten, zu hashen, die f√ºr Grafikkarten geeignet sind.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492540/index.html">Das Spiel "Warte einen Moment!" auf Arduino</a></li>
<li><a href="../de492546/index.html">√úberpr√ºfen der Sicherheitsanf√§lligkeit einer Website mit Nikto</a></li>
<li><a href="../de492548/index.html">Unity Machine Learning: Unterrichten von MO-Agenten, √ºber W√§nde zu springen</a></li>
<li><a href="../de492552/index.html">Wie man in Barcelona in Quarant√§ne lebt und arbeitet</a></li>
<li><a href="../de492558/index.html">Hallo, das ist COVID19: Lebt das Coronavirus auf der Oberfl√§che eines Smartphones?</a></li>
<li><a href="../de492562/index.html">Drei n√ºtzliche Apache Ignite-Webinare in Ihrem Quarant√§neprogramm</a></li>
<li><a href="../de492566/index.html">Analyse der Kombination eines Suchalgorithmus f√ºr gierige Klicks mit teilweiser Aufz√§hlung von Diagrammscheitelpunkten</a></li>
<li><a href="../de492568/index.html">Holen Sie sich einen Auszug aus Rosreestr √ºber FSIS USRN und Python. Teil 2</a></li>
<li><a href="../de492572/index.html">Der aktuelle Stand der Java-Welt: Trends und Fakten f√ºr eine der beliebtesten Programmiersprachen</a></li>
<li><a href="../de492574/index.html">√úberlegungen zur Startwahrscheinlichkeit: Apple AirPods mit Momentum True Wireless 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>