<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👔 🥃 🚹 ドローン画像から屋根を見つけるためのMASK-RCNN 🙅🏻 💊 ✍🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="白と白の街の白と白の通りに白と白の家がありました...そしてこの写真で家のすべての屋根をどれだけ早く見つけることができますか？
 
 地籍のデータを明確にするために不動産の完全なインベントリを実施するという政府の計画についてますます聞くことができます。この問題の主な解決策として、航空写真からの首都の...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ドローン画像から屋根を見つけるためのMASK-RCNN</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/500752/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad9/eb5/21e/ad9eb521e7c2fcb232116aa876742ee3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
白と白の街の白と白の通りに白と白の家がありました...そしてこの写真で家のすべての屋根をどれだけ早く見つけることができますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
地籍のデータを明確にするために不動産の完全なインベントリを実施するという政府の計画についてますます聞くことができます。この問題の主な解決策として、航空写真からの首都の建物の屋根面積の計算と、地籍データとのさらなる比較に基づいて、簡単な方法を適用できます。残念ながら、手動での検索と計算には時間がかかり、新しい家屋は解体され、継続的に建設されるため、計算を何度も繰り返す必要があります。このプロセスは、機械学習アルゴリズム、特にコンピュータビジョンを使用して自動化できるという仮説がすぐに発生します。この記事では、私たちがどのように</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">NORBIT</font></a><font style="vertical-align: inherit;">にいるのかについて話します</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> この問題と彼らが遭遇した困難を解決しました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スポイラー-私たち</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はそれ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">やった</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">開発されたMLサービスは、畳み込みニューラルネットワークに基づくディープ機械学習モデルに基づいています。</font><font style="vertical-align: inherit;">このサービスは、無人航空機からの画像を入力として受け入れ、出力に地理座標を持つ、見つかった首都建設オブジェクトのレイアウトを含むGeoJSONファイルを生成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ab/892/528/0ab892528db9a5c84fd26d0e30329b5a.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発生した技術的な問題から始めましょう。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">冬と夏の航空写真には大きな違いがあります（夏の写真でのみトレーニングされたモデルでは、冬に屋根を完全に見つけることができません）。</font></font></li>
<li>            ,       ;</li>
<li>  ,          (  ),     (     )      ,           ;</li>
<li>   ,     ,         (     ).        ;</li>
<li>  (,   )     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ドローンは時々これらの写真を持っていきます：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/663/809/821/66380982148bc07c8309f8d106ecfc38.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、発生する可能性があった問題にも注意したいのですが、それらは私たちには関係がありませんでした。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限られた時間内（たとえば、飛行時に直接）に推論を実行するタスクがありませんでした。これにより、パフォーマンスに関するすべての考えられる問題が即座に解決されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">処理の入力時に、私たちの顧客であるShakhty社から高品質の高解像度画像（焦点距離21 mm、高さ250 m、5 cm / pxのレンズを使用）をすぐに受け取り、地図上のオブジェクトの地理位置情報に関する専門知識を利用できました。彼らはまた、将来のUAV飛行のための特定の要件セットを確立する機会を得ました。これにより、トレーニングセットになかった非常にユニークなタイルの可能性が大幅に削減されました。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題の最初の解決策、境界ボックスを使用したスト​​ローク&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソリューションの作成に使用したツールについて少し説明します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anacondaは、PythonおよびRの便利なパッケージ管理システムです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tensorflowは、Googleが開発したオープンソースの機械学習ソフトウェアライブラリです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerasは、Deeplearning4j、TensorFlow、Theanoのフレームワークのアドオンです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCVは、コンピュータービジョン、画像処理、および汎用のオープンソース数値アルゴリズムのアルゴリズムのライブラリーです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flaskは、Pythonプログラミング言語でWebアプリケーションを作成するためのフレームワークです。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OSはUbuntu 18.04を使用したため。</font><font style="vertical-align: inherit;">UbuntuのGPU（NVIDIA）上のドライバーを使用すると、すべてが正常に機能するため、タスクは通常1つのコマンドで解決されます。</font></font><br>
<br>
<code>&gt; sudo apt install nvidia-cuda-toolkit</code><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイルの準備</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが直面した最初のタスクは、フライバイ画像をタイル（2048x2048 px）に分割することでした。</font><font style="vertical-align: inherit;">独自のスクリプトを作成することもできますが、その場合は各タイルの地理的な位置を維持することを考える必要があります。</font><font style="vertical-align: inherit;">たとえば、GeoServerなどの既製のソリューションを使用する方が簡単でした。これは、サーバーにジオデータを公開できるオープンソースソフトウェアです。</font><font style="vertical-align: inherit;">さらに、GeoServerは別の問題を解決しました-自動マーキングの結果を地図上に表示するのに便利です。</font><font style="vertical-align: inherit;">これは、たとえばqGISでローカルに実行できますが、分散されたコマンドとデモの場合、Webリソースの方が便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイリングを実行するには、設定で必要なスケールとサイズを指定する必要があります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/688/b29/4d1/688b294d129f14dddc810ca0defdef44.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
座標系間の変換には、pyprojライブラリを使用しました。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> pyproj <span class="hljs-keyword">import</span> Proj, transform<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Converter</span>:</span>
&nbsp;&nbsp;&nbsp;&nbsp;P3857 = Proj(init=<span class="hljs-string">'epsg:3857'</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;P4326 = Proj(init=<span class="hljs-string">'epsg:4326'</span>)<font></font>
...<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_3857_to_GPS</span>(<span class="hljs-params">self, point</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = point<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> transform(self.P3857, self.P4326, x, y)
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">from_GPS_to_3857</span>(<span class="hljs-params">self, point</span>):</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x, y = point<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">return</span> transform(self.P4326, self.P3857, x, y)<font></font>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、すべてのポリゴンから1つの大きなレイヤーを簡単に形成し、それを基板の上に置くことができました。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b8/9f6/428/2b89f642889bdc551871a35ba43a7c03.png"></div><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeoServerソフトウェアをインストールするには、次の手順を完了する必要があります。</font></font></b>
                        <div class="spoiler_text"><ol>
<li> Java  8.</li>
<li> GeoServer.       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></li>
<li>     , ,&nbsp;<code>/usr/share/geoserver</code></li>
<li>      &nbsp;<br>
<br>
<strong><code>echo «export GEOSERVER_HOME=/usr/share/geoserver» &gt;&gt; ~/.profile</code></strong></li>
<li>   :<br>
<br>
<strong><code>sudo groupadd geoserver</code></strong></li>
<li> ,     ,   :<br>
<br>
<strong><code>sudo usermod -a -G geoserver &lt;user_name&gt;</code></strong></li>
<li> -  :<br>
<br>
<strong><code>sudo chown -R :geoserver /usr/share/geoserver/</code></strong></li>
<li>    :<br>
<br>
<strong><code>sudo chmod -R g+rwx /usr/share/geoserver/</code></strong></li>
<li> GeoServer&nbsp;<br>
<br>
<strong><code>cd geoserver/bin &amp;&amp; sh startup.sh</code></strong></li>
</ol></div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeoServerは、問題を解決できる唯一のアプリケーションではありません。</font><font style="vertical-align: inherit;">たとえば、ArcGIS for Serverを検討することもできますが、この製品は独自仕様であるため、使用しませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、各タイルは目に見える屋根をすべて見つける必要がありました。</font><font style="vertical-align: inherit;">問題を解決する最初のアプローチ</font><font style="vertical-align: inherit;">は、モデル/リサーチTensorflowセットからの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">object_detection</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用することでした</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">このようにして、画像上のクラスを長方形の選択（境界ボックス）で見つけてローカライズできます。&nbsp;</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングデータのマークアップ&nbsp;</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
明らかに、モデルをトレーニングするには、ラベル付きのデータセットが必要です。幸運な偶然により、周回に加えて、ビンでは5万分の1の屋根のデータセットが古き良き時代から保存されていましたが、トレーニング用のすべてのデータセットはまだパブリックドメインにありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
許容可能なモデル精度を得るために必要なトレーニングサンプルの正確なサイズを事前に予測することはかなり困難です。これは、イメージの品質、相互の相違度、およびモデルが本番環境で使用される条件によって異なります。 200個で十分な場合があり、マークされたサンプルも5万個欠けていました。マークされた画像が不足している場合は、通常、拡大方法を追加します：回転、鏡面反射、カラーグレーディングなど。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、画像をマークアップできる多くのサービスが利用可能になりました-コンピューター/サーバーにインストールするためのオープンソースコードと、Yandex.Tolokなどの外部評価者の作業を含む企業ソリューションの両方。</font><font style="vertical-align: inherit;">このプロジェクトでは、最も単純な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGG Image Annotator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を使用しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">または、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">coco-annotator</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">または</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">label-studioを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">試すこともできます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">通常、テキストファイルとオーディオファイルのマークアップには後者を使用します。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/46b/39c/5b146b39c6413ebde30c1a0a6f25421a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなアノテーターのマークアップに関するトレーニングでは、通常、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VGGの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例のように、フィールドの小さなシフトを実行する必要があります</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長方形の割り当ての領域に落ちた屋根の領域を正しく計算するには、いくつかの条件を観察する必要があります：</font></font><br>
<br>
<ul>
<li>     /     .          :</li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b0c/41a/80e/b0c41a80e0ae785794143da7b38dfbbf.png"></div><br>
<ul>
<li>,    ,      :</li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/092/1de/dcb/0921dedcbc4effc0430d11cd8dea8401.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の問題を解決するには、マーキングのタイルの正しい回転角度を決定する別のモデルをトレーニングしてみますが、すべてが少し簡単になります。</font><font style="vertical-align: inherit;">人々自身がエントロピーを減らすように努力しているため、特に密集した建物では、すべての人工構造を相互に関連づけています。</font><font style="vertical-align: inherit;">上から見ると、局所的な領域では、フェンス、歩道、植栽、温室、アーバーは屋根の境界に対して平行または垂直になります。</font><font style="vertical-align: inherit;">すべての明確な線を見つけ、垂直線に対する最も一般的な傾斜角度を計算するだけです。</font><font style="vertical-align: inherit;">このため、OpenCVには優れたHoughLinesPツールがあります。&nbsp;</font></font><br>
<br>
<pre><code class="python hljs">...<font></font>
<font></font>
lines = cv2.HoughLinesP(edges, <span class="hljs-number">1</span>, np.pi/<span class="hljs-number">180</span>, <span class="hljs-number">50</span>, minLineLength=minLineLength, maxLineGap=<span class="hljs-number">5</span>)
<span class="hljs-keyword">if</span> lines <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;length = image.shape[<span class="hljs-number">0</span>]<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;angles = []<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> x1, y1, x2, y2 <span class="hljs-keyword">in</span> lines[<span class="hljs-number">0</span>]:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angle = math.degrees(math.atan2(y2 — y1, x2 - x1))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;angles.append(angle)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;parts_angles.append(angles)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;median_angle = np.median(angles)<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">#    &nbsp;</span><font></font>
<font></font>
<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, image.shape[<span class="hljs-number">0</span>]<span class="hljs-number">-1</span>, image.shape[<span class="hljs-number">0</span>] // count_crops):
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, image.shape[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span>, image.shape[<span class="hljs-number">1</span>] // count_crops):<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get_line(image[x:x+image.shape[<span class="hljs-number">0</span>]//count_crops, y:y+image.shape[<span class="hljs-number">1</span>]//count_crops, :])<font></font>
...<font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
<font></font>
np.median([a <span class="hljs-keyword">if</span> a&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">90</span>+a <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> np.array(parts_angles).flatten()])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
角度を見つけたら、アフィン変換を使用して画像を回転させます。</font></font><br>
<br>
<pre><code class="python hljs">
h, w = image.shape[:<span class="hljs-number">2</span>]<font></font>
image_center = (w/<span class="hljs-number">2</span>, h/<span class="hljs-number">2</span>)<font></font>
<font></font>
<span class="hljs-keyword">if</span> size <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;radians = math.radians(angle)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;sin = math.sin(radians)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;cos = math.cos(radians)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;size = (int((h * abs(sin)) + (w * abs(cos))), int((h * abs(cos)) + (w * abs(sin))))<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix = cv2.getRotationMatrix2D(image_center, angle, <span class="hljs-number">1</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>] += ((size[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span>) — image_center[<span class="hljs-number">0</span>])<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] += ((size[<span class="hljs-number">1</span>] / <span class="hljs-number">2</span>) — image_center[<span class="hljs-number">1</span>])
<span class="hljs-keyword">else</span>:<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;rotation_matrix = cv2.getRotationMatrix2D(image_center, angle, <span class="hljs-number">1</span>)<font></font>
<font></font>
cv2.warpAffine(image, rotation_matrix, size)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
完全なサンプルコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こちら</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">これは次のようになります。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b2/032/15c/2b203215c7a688dc7639e7993643a99e.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/594/423/c1b/594423c1b3e52a8e4fcd383b20a04b05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
タイルを回して長方形でマーキングする方法は、マスクでマーキングするよりも速く機能し、ほとんどすべての屋根が見つかりますが、この方法は、いくつかの欠点があるため、製造では補助的な方法としてのみ使用されます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">長方形ではない屋根が多数ある場合、多くの飛行が必要です。このため、この領域を調整するには手作業が多すぎます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家で同じタイルの向きが違うこともあります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">時々、タイル上に多くの偽りの線があり、最終的に間違った方向につながります。</font><font style="vertical-align: inherit;">次のようになります。</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d4/ba0/30c/6d4ba030c0784c6ee7366486b3a8f03c.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/691/5fd/a10/6915fda10769dc9b5d96522737d6aef6.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mask-RCNNに基づく最終的なソリューション</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目の試みは、ピクセルごとにマスクで屋根を検索して強調表示し、検出されたマスクの輪郭を自動的に概説し、ベクトルポリゴンを作成することでした。&nbsp;&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシア語を含む畳み込みニューラルネットワークの動作原理、タイプ、およびタスクに関する資料はすでに十分にあるため、この記事ではそれらについては触れません。 1つの特定の実装であるMask-RCNNについてのみ説明します。Mask-RCNNは、画像内のオブジェクトの輪郭をローカライズおよび強調表示するためのアーキテクチャです。 UNetなど、長所と短所を持つ他の優れたソリューションがありますが、Mask-RCNNでより高い品質を実現することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その開発の過程で、それはいくつかの段階を経ました。 R-CNNの最初のバージョンは2014年に開発されました。その作業の原則は、画像内の小さな領域を強調表示することです。それぞれの領域について、この領域にターゲットオブジェクトが存在する確率の推定が行われます。 R-CNNはこのタスクで優れた仕事をしましたが、その速度はまだ望まれていませんでした。論理的に開発されたのはFast R-CNNおよびFaster R-CNNネットワークで、イメージクロールアルゴリズムが改善され、速度が大幅に向上しました。 Faster R-CNNの出口では、オブジェクトの境界を示す長方形の選択を含むマーキングが表示されますが、これは必ずしも問題を解決するのに十分ではありません。&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マスクR-CNNは、ピクセル単位のマスクオーバーレイも追加して、オブジェクトの正確な輪郭を取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
境界ボックスとマスクは、モデルの操作の結果ではっきりと見ることができます（最小建築面積によるフィルターがオンになっています）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6e/d0c/756/d6ed0c7567ed2894bbe11161fc91af55.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来、このネットワークの運用には4つの段階があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての畳み込みニューラルネットワークの標準、画像内のライン、ベンド、対照的な境界などの特徴の割り当て。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リージョンプロポーザルネットワーク（RPN）は、アンカー（アンカー）と呼ばれる画像の小さな断片をスキャンし、このアンカーにターゲットクラス（この場合は屋根）に固有の標識が含まれているかどうかを判断します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関心領域の分類と境界ボックス。</font><font style="vertical-align: inherit;">この段階では、ネットワークは、前の段階の結果に基づいて、おそらくターゲットオブジェクトを含む写真の大きな長方形の領域を強調表示しようとしています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セグメンテーションマスク。</font><font style="vertical-align: inherit;">この段階で、境界ボックスを適用して得られた長方形の領域から、目的のオブジェクトのマスクが取得されます。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、ネットワークは非常に柔軟な構成であることがわかり、追加の情報レイヤーを使用して画像を処理するためにネットワークを再構築することができました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RGB画像のみを使用すると、必要な認識精度を達成できませんでした（モデルは建物全体を見落とし、屋根面積の計算で平均15％の誤差がありました）。そのため、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">写真測量</font></a><font style="vertical-align: inherit;">によって得られた高さマップなどの追加の有用なデータをモデルに提供しました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></a>&nbsp;<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cc/801/ac8/7cc801ac8060a3b99a2bb26415d2fe38.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの品質を評価するために使用されるメトリック</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルの品質を決定する際、最も頻繁にユニオン上の交差（IoU）メトリックを使用しました</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cc/486/5be/8cc4865be494cc0bee045c618df9ff59.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
geometry.shapelyライブラリを使用してIoUを計算するためのサンプルコード：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> shapely.geometry <span class="hljs-keyword">import</span> Polygon<font></font>
<font></font>
true_polygon = Polygon([(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>), (<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)])<font></font>
predicted_polygon = Polygon([(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">7</span>), (<span class="hljs-number">6</span>, <span class="hljs-number">3</span>)])<font></font>
print(true_polygon.intersection(predicted_polygon).area / true_polygon.union(predicted_polygon).area)<font></font>
<font></font>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-number">0.3333333333333333</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルのトレーニングプロセスの追跡は、モデルの品質に関するリアルタイムデータを受信して​​他のモデルと比較できる便利なメトリック制御ツールであるTensorboardを使用して便利に制御されます。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/a7a/b20/31ca7ab20d4583360b3058b59277bc10.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tensorboardは、さまざまな指標に関するデータを提供します。</font><font style="vertical-align: inherit;">私たちにとって最も興味深いのは：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">val_mrcnn_bbox_loss-モデルがオブジェクトをどのようにローカライズするかを示します（つまり、境界ボックスを課します）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">val_mrcnn_mask_loss-モデルがオブジェクトを適切にセグメント化する（つまり、マスクを課す）ことを示します。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルのトレーニングと検証</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングでは、データセットをランダムに3つの部分（トレーニング、検証、テスト）に分割する標準的な方法を使用しました。学習プロセスでは、モデルの品質が検証サンプルで評価され、完了時に、学習プロセスでモデルから閉じられたテストデータに対する最終テストに合格します。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のトレーニングは、夏のショットの小さなセットで開始し、モデルが冬にどれだけ優れているかを確認することを決定したところ、期待外れの結果が予想されました。</font><font style="vertical-align: inherit;">もちろん、季節ごとに異なるモデルを使用するという選択肢は、状況を回避する優れた方法ですが、多くの不便を伴うため、モデルをユニバーサルにすることを試みることにしました。</font><font style="vertical-align: inherit;">レイヤーのさまざまな構成を実験し、重みの変化から個々のレイヤーの重みを閉じることで、夏と冬の写真を交互に入力に適用してモデルをトレーニングするための最適な戦略を見つけました。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">認識のためのバックグラウンドサービスの作成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで機能するモデルができたので、認識スクリプトからバックグラウンドAPIサービスを作成できます。これは、画像を入力として受け取り、出力で屋根ポリゴンが見つかるjsonを生成します。</font><font style="vertical-align: inherit;">これは問題の解決には直接影響しませんが、誰かに役立つかもしれません。&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ubuntuはsystemdを使用しており、このシステムの例を示します。</font><font style="vertical-align: inherit;">サービス自体のコードは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で見ることができ</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ユーザーユニットは/ etc / systemd / systemディレクトリにあり、ここでサービスファイルを作成します。</font><font style="vertical-align: inherit;">
ファイルを編集します。</font></font><br>
<br>
<code>cd /etc/systemd/system<br>
<br>
sudo touch my_srv.service</code><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="bash hljs">sudo vim my_srv.service
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
systemdユニットは3つのセクションで構成されています。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[Unit]-開始の順序と状態を説明します（たとえば、特定のサービスの開始を待機し、その後自分で開始するようにプロセスに指示できます）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[サービス]-起動パラメーターについて説明します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[インストール]-サービスをスタートアップに追加するときのサービスの動作について説明します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、ファイルは次のようになります。</font></font><br>
<br>
<pre><code class="bash hljs">[Unit]<font></font>
Description=my_test_unit<font></font>
<font></font>
[Service]<font></font>
WorkingDirectory=/home/user/test_project<font></font>
User=root<font></font>
ExecStart=/home/user/test_project/venv/bin/python3 /home/user/test_project/script.py<font></font>
<font></font>
[Install]<font></font>
WantedBy=multi-user.target<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
systemd設定をリロードしてサービスを実行します：</font></font><br>
<br>
<pre><code class="bash hljs">sudo systemctl daemon-reload<font></font>
sudo systemctl start my_srv.service<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、バックグラウンドプロセスの簡単な例です。systemdは、サービスの動作を柔軟に構成できる多くの異なるパラメーターをサポートしていますが、このタスクにはこれ以上複雑なものは必要ありません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトの主な成果は、実際の開発と地籍データに含まれる情報の不整合を自動的に検出する機能でした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストデータでモデルの精度を評価した結果、見つかった屋根の数-91％、屋根の輪郭ポリゴンの精度-94％の値が得られました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
夏と冬のフライトでモデルの許容品質を達成することは可能でしたが、降雪直後の写真では認識品質が低下する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シドニーオペラハウスでさえ、私たちのモデルの目から外れることはありません。&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zs/c1/yl/zsc1yl0dgkkhjahgjk3vssn8swc.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサービスをトレーニング済みモデルとともにデモスタンドに配置する予定です。</font><font style="vertical-align: inherit;">自分の写真でサービスを試したい場合は、ai @ norbit.ruにアプリケーションを送信してください。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja500732/index.html">人工知能と意識理論の危機</a></li>
<li><a href="../ja500734/index.html">＃AWS Fargateの要件管理と自動CIスケーリングを備えたGitLab 12.10がリリースされました</a></li>
<li><a href="../ja500742/index.html">クラスタリングの品質評価：プロパティ、メトリック、GitHubコード</a></li>
<li><a href="../ja500744/index.html">「あなたの声をもっとよく聞くために、私のスピーカー」：自宅からよりよく放送する方法</a></li>
<li><a href="../ja500746/index.html">SMDおよびその他の小さなもの用のボクシングラック</a></li>
<li><a href="../ja500754/index.html">ソファに横になって、30年でドルの億万長者になる方法</a></li>
<li><a href="../ja500756/index.html">リモートオールパワー。JUG Ru Groupオンライン会議でのストリーミングはどのように機能しますか？</a></li>
<li><a href="../ja500758/index.html">2020-2021年のサイバーセキュリティおよび情報セキュリティ市場の主な傾向と2019-2020年の予測</a></li>
<li><a href="../ja500760/index.html">ZeroTierでゾンビをより効率的に殺す方法</a></li>
<li><a href="../ja500764/index.html">スピーチを描く：ソフトウェア自動口</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>