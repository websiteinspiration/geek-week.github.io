<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👂🏿 👩🏿‍⚖️ 🧙🏼 Cara kerja rendering game 3D: pencahayaan dan bayangan 👈🏾 👧🏿 🐡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Penerapan sebagian besar efek visual dalam game modern bergantung pada penggunaan pencahayaan dan bayangan secara bijaksana. Tanpa mereka, game akan m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Cara kerja rendering game 3D: pencahayaan dan bayangan</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501438/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penerapan sebagian besar efek visual dalam game modern bergantung pada penggunaan pencahayaan dan bayangan secara bijaksana. </font><font style="vertical-align: inherit;">Tanpa mereka, game akan membosankan dan tidak bernyawa. </font><font style="vertical-align: inherit;">Pada bagian keempat dari analisis rendering game 3D, kami akan fokus pada apa yang terjadi di dunia 3D bersama dengan pemrosesan vertex dan pemetaan tekstur. </font><font style="vertical-align: inherit;">Kami lagi akan membutuhkan banyak matematika, serta pemahaman yang kuat tentang dasar-dasar optik. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 1: pemrosesan simpul </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 2: rasterisasi dan penelusuran sinar </font></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 3: tekstur dan penyaringan tekstur</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingat masa lalu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelumnya, kami memeriksa aspek-aspek kunci dari memindahkan dan memproses objek dalam adegan, konversi mereka dari ruang tiga dimensi ke grid datar piksel, serta cara-cara untuk menerapkan tekstur pada objek-objek ini. Selama bertahun-tahun, operasi seperti itu telah menjadi bagian penting dari proses rendering, dan kita dapat melihatnya dengan kembali pada tahun 1993 dan meluncurkan Doom id Software.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2fe/056/d0c/2fe056d0c0f37ac3a2970bdc485b79a5.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan standar modern, penggunaan cahaya dan bayangan dalam game ini sangat primitif: sumber cahaya tidak diperhitungkan, setiap permukaan berdasarkan simpulnya diberi nilai warna umum atau nilai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cahaya sekitar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Semua tanda bayangan diciptakan berkat penggunaan tekstur yang licik dan pilihan warna lingkungan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada bayangan, karena mereka bukan tugas pemrogram: PC pada waktu itu adalah prosesor 66 MHz (yaitu, 0,066 GHz!), Hard drive 40 MB dan kartu grafis 512 kilobyte dengan kemampuan 3D minimal. Maju cepat 23: dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reboot seri yang terkenal,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita melihat cerita yang sama sekali berbeda.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b5/3ca/da0/3b53cada0530afabe788b4a70a0b7319.jpg"></div><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Banyak teknologi yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
digunakan untuk membuat bingkai ini </font><font style="vertical-align: inherit;">, ia menawarkan tahapan seperti oklusi ambient ruang layar, pemetaan kedalaman pra-pass, filter bokeh blur, operator koreksi nada, dan sebagainya. </font><font style="vertical-align: inherit;">Perhitungan pencahayaan dan naungan setiap permukaan dilakukan secara dinamis: mereka terus berubah tergantung pada kondisi lingkungan dan tindakan pemain.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena setiap operasi rendering 3D memerlukan matematika (sejumlah perhitungan!), Lebih baik kita mulai dengan apa yang terjadi di balik layar dari setiap game modern.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencahayaan matematika</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menerapkan semuanya dengan benar, kita perlu secara akurat mensimulasikan perilaku cahaya ketika berinteraksi dengan berbagai permukaan. Sangat mengherankan bahwa untuk pertama kalinya masalah ini mulai dipecahkan pada abad ke-18 oleh seorang pria bernama Johann Heinrich Lambert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada 1760, seorang ilmuwan Swiss merilis sebuah buku berjudul </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Photometria</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Di dalamnya, ia menjabarkan aturan-aturan dasar perilaku cahaya; yang paling luar biasa dari mereka adalah sebagai berikut - permukaan memancarkan cahaya (dengan refleksi atau sebagai sumber cahaya) sedemikian rupa sehingga kecerahan cahaya yang dipancarkan bervariasi tergantung pada kosinus sudut antara permukaan normal dan pengamat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/262/6a2/f0c/2626a2f0c2f80f30bf5208decab2493c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aturan sederhana ini meletakkan dasar untuk apa yang disebut </font><font style="vertical-align: inherit;">pencahayaan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini adalah model matematika yang digunakan untuk menghitung warna permukaan tergantung pada sifat fisiknya (misalnya, warna dan tingkat pantulan cahaya) dan lokasi sumber cahaya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam rendering 3D, ini membutuhkan banyak informasi, yang paling mudah untuk dibayangkan dalam bentuk skema seperti itu:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/918/d57/386/918d573864315b11e91405d8e692c59f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami melihat banyak panah pada gambar, ini </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah vektor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan vektor berikut ini diperlukan untuk menghitung warna:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 vektor untuk posisi titik, sumber cahaya dan kamera melihat pemandangan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 vektor untuk arah sumber cahaya dan kamera dari sudut pandang titik</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 vektor normal</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 setengah vektor (selalu di tengah-tengah antara vektor arah pencahayaan dan kamera)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka dihitung pada tahap pemrosesan simpul dari proses rendering, dan persamaan menyatukan mereka semua (disebut model Lambert) memiliki bentuk:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/267/ba6/279/267ba627905209780406c2148469a7ef.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yaitu, warna titik di bawah pencahayaan difus dihitung dengan mengalikan warna permukaan, warna sumber cahaya dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">produk skalar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari vektor normal titik dan arah cahaya dengan koefisien redaman dan proyeksi pencahayaan. </font><font style="vertical-align: inherit;">Operasi ini dilakukan untuk setiap sumber cahaya di tempat kejadian, karenanya simbol jumlah pada awal persamaan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vektor dalam persamaan ini (dan semua yang kita lihat di bawah) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dinormalisasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (seperti yang ditunjukkan oleh ikon di atas setiap vektor). </font><font style="vertical-align: inherit;">Vektor yang dinormalisasi mempertahankan arah aslinya, dan panjangnya berkurang ke nilai satuan (mis., Sama dengan 1 unit pengukuran).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai warna permukaan dan sumber cahaya adalah angka RGBA standar (merah, hijau, biru, dan transparansi alfa). Mereka bisa bilangan bulat (misalnya, INT8 untuk setiap saluran warna), tetapi hampir selalu merupakan angka floating point (misalnya, FP32). Koefisien atenuasi menentukan bagaimana tingkat iluminasi berkurang ketika menjauh dari sumber, dan dihitung dengan persamaan lain:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/17e/a22/6ac17ea2263bf82f6a2e2571bd88e0b0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Istilah A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan A </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah koefisien yang berbeda (konstan, linier, kuadratik) yang menggambarkan bagaimana jarak mempengaruhi tingkat pencahayaan. Semuanya diatur oleh programmer saat membuat mesin rendering. Di setiap API grafis, ini diterapkan dengan caranya sendiri, tetapi koefisien diperkenalkan ketika mengenkode jenis sumber cahaya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelum kita mempertimbangkan koefisien terakhir (lampu sorot), perlu dicatat bahwa dalam rendering 3D pada dasarnya ada tiga jenis sumber cahaya: titik, terarah dan sorotan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/2be/9ce/3492be9ce1ccf5526a05bb0702f84c35.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sumber titik memancarkan cahaya secara merata ke segala arah, dan sumber arah memancarkan cahaya hanya dalam satu arah (dari sudut pandang matematika, ini hanyalah sumber titik, jauh pada jarak tak terbatas). Lampu sorot adalah sumber arah yang kompleks karena memancarkan cahaya dalam bentuk kerucut. Cara cahaya bervariasi dalam tubuh kerucut menentukan ukuran bagian dalam dan luar kerucut. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan ya, untuk koefisien sorot, ada persamaan lain:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/06a/b47/d9c/06ab47d9c2a0f7d85519d5de77cb299b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nilai koefisien proyektor adalah 1 (mis., Sumbernya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bukan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proyektor), atau 0 (jika titik di luar arah kerucut), atau nilai yang dihitung antara keduanya. Sudut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">φ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (phi) dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">θ</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (theta) menentukan dimensi bagian dalam / luar kerucut lampu sorot. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dua vektor: L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dcs</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan L </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dir</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (terbalik dengan arah kamera dan arah sorotan) digunakan untuk menentukan apakah kerucut dari titik tersebut bersentuhan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita harus ingat bahwa semua ini diperlukan untuk menghitung nilai pencahayaan difus, dan semua operasi ini harus dilakukan untuk </font><em><font style="vertical-align: inherit;">masing</font></em><font style="vertical-align: inherit;"> - </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">masing</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumber pencahayaan di tempat kejadian, atau setidaknya untuk setiap sumber yang ingin dipertimbangkan oleh programmer. Banyak persamaan ini dieksekusi oleh API grafis, tetapi mereka juga dapat dilakukan secara manual jika encoders membutuhkan kontrol lebih besar atas gambar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, di dunia nyata, pada kenyataannya, ada </font><font style="vertical-align: inherit;">sumber cahaya dalam jumlah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tak terbatas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : setiap permukaan memantulkan pencahayaan, sehingga semuanya mempengaruhi pencahayaan keseluruhan dari pemandangan. Bahkan di malam hari ada pencahayaan latar belakang, apakah itu bintang dan planet atau cahaya yang tersebar di atmosfer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mensimulasikan ini, nilai pencahayaan lain dihitung: </font><font style="vertical-align: inherit;">pencahayaan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sekitar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/73b/e8e/94473be8edd6d85ce822d059f021d9a7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persamaan ini lebih sederhana daripada untuk pencahayaan difus karena arah tidak diperlukan. </font><font style="vertical-align: inherit;">Di sini, perkalian sederhana dari berbagai koefisien dilakukan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - warna penerangan permukaan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - sorot warna adegan 3D global</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LA</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - warna penerangan dari semua sumber cahaya di tempat kejadian</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu dicatat bahwa koefisien atenuasi dan proyektor digunakan lagi, serta penjumlahan dari semua sumber cahaya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami memiliki pencahayaan latar belakang dan kami mempertimbangkan pencahayaan difus dari sumber cahaya dari berbagai permukaan dunia 3D. Tetapi model Lambert hanya berfungsi untuk material yang memantulkan cahaya dari permukaannya ke segala arah; benda yang terbuat dari kaca atau logam menciptakan jenis pantulan lain yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; Tentu, ada persamaan untuknya juga!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6b/a60/a49/d6ba60a49dae7eb88da90c7ef26936bf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagian individual dari formula ini seharusnya sudah tidak asing lagi bagi Anda: kami memiliki dua nilai warna cermin (satu untuk permukaan - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">S</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang lain untuk cahaya - C </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LS</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), serta faktor redaman dan banjir yang biasa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena refleksi specular sangat fokus dan terarah, dua vektor digunakan untuk menentukan kecerahan iluminasi specular: vertex normal dan semi-vektor. Koefisien </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kekuatan refleksi specular</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ini adalah angka yang menentukan kecerahan refleksi tergantung pada sifat material permukaan. Dengan meningkatnya p, efek cermin menjadi lebih terang, tetapi lebih fokus dan lebih kecil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemen terakhir yang harus dipertimbangkan adalah yang paling sederhana karena hanya berupa angka. </font><font style="vertical-align: inherit;">Ini disebut </font><font style="vertical-align: inherit;">pencahayaan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memancarkan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan diterapkan pada objek yang merupakan sumber langsung pencahayaan, yaitu, ke api, senter, atau Matahari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini berarti bahwa sekarang kita memiliki satu set dan tiga set persamaan untuk menghitung warna titik permukaan, dengan mempertimbangkan pencahayaan latar belakang (lingkungan), serta interaksi antara sumber cahaya yang berbeda dan sifat-sifat bahan permukaan (difus dan specular). </font><font style="vertical-align: inherit;">Pemrogram dapat memilih hanya satu atau menggabungkan keempat dengan hanya melipatnya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/679/5d4/fc3/6795d4fc38199eed97d7e1fb875556d5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara visual, kombinasi terlihat seperti ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/be2/f53/158be2f5318b5cbb2a142e166d1299ad.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persamaan yang dipertimbangkan oleh kami diterapkan oleh grafik API (misalnya, Direct3D dan OpenGL) menggunakan fungsi standar mereka, tetapi untuk setiap jenis pencahayaan ada algoritma alternatif. </font><font style="vertical-align: inherit;">Sebagai contoh, pencahayaan difus dapat diimplementasikan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model Oren-Nayyar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang lebih cocok untuk permukaan yang sangat kasar daripada model Lambert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persamaan refleksi cermin dapat diganti dengan model yang memperhitungkan fakta bahwa permukaan yang sangat halus seperti kaca atau logam masih kasar, tetapi pada tingkat mikroskopis. </font><font style="vertical-align: inherit;">Model semacam itu, yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma segi mikro</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dengan mengorbankan kompleksitas matematika, memberikan gambar yang lebih realistis.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model apa pun yang digunakan, mereka semua sangat ditingkatkan dengan meningkatkan frekuensi aplikasi mereka ke adegan 3D.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhitungan vertikal atau piksel-demi-piksel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami memeriksa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemrosesan vertex</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rasterisasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , kami melihat bahwa hasil dari semua perhitungan pencahayaan rumit yang dilakukan untuk setiap vertex harus diinterpolasi di atas permukaan antar verteks. </font><font style="vertical-align: inherit;">Ini karena sifat-sifat yang terkait dengan bahan permukaan disimpan di dalam simpul; </font><font style="vertical-align: inherit;">ketika dunia 3D dikompresi menjadi kisi-kisi piksel 2D, piksel tersebut hanya tersisa di tempat simpul itu berada.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/129/bc3/e90/129bc3e90652de62263813f5274dea2c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisa piksel perlu mengirimkan informasi tentang warna simpul sehingga warna tercampur dengan benar di permukaan. Pada tahun 1971, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Henri Gouraud</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seorang mahasiswa pascasarjana di Universitas Utah, mengusulkan metode yang sekarang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gouraud Shading</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metodenya cepat secara komputasi dan selama bertahun-tahun menjadi standar </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de facto</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi ia juga memiliki masalah. Dia tidak bisa menginterpolasi pencahayaan cermin dengan benar, dan jika objek itu terdiri dari sejumlah kecil primitif, maka pencampuran antara primitif tampak salah.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi untuk masalah ini diusulkan pada tahun 1973 oleh Bui Tyong Fong, yang juga bekerja di Universitas Utah. Dalam artikel penelitiannya, Fong menunjukkan teknik untuk menginterpolasi normals dari simpul pada permukaan raster. Ini berarti bahwa model refleksi tersebar dan specular akan bekerja dengan benar untuk setiap piksel, dan kita dapat dengan jelas melihat ini dalam </font><font style="vertical-align: inherit;">grafik komputer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> David Eck dan </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">tutorial</font></a><font style="vertical-align: inherit;"> WebGL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bola karbon yang ditunjukkan di bawah ini diwarnai dengan model pencahayaan yang sama, tetapi untuk perhitungan kidal dilakukan secara vertikal, diikuti oleh Gouraud shading untuk menyisipkannya di seluruh permukaan. Untuk bola di sebelah kanan, perhitungan dilakukan piksel demi piksel, dan perbedaannya jelas.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10a/5b1/329/10a5b13292d99d5250cfbfba7c737a6a.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gambar foto tidak menyampaikan semua peningkatan yang dibawa oleh </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bayangan Phong</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi Anda dapat secara independen menjalankan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo online</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ek dan menonton animasinya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, Fong tidak berhenti di situ, dan beberapa tahun kemudian ia menerbitkan artikel penelitian lain di mana ia menunjukkan bagaimana perhitungan terpisah untuk ambient, diffuse, dan specular reflection dapat dilakukan dengan satu persamaan sederhana:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/cf9/613/0c0cf9613d8d536c4cdb16750bbca092.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini kita harus benar-benar mengerti! Nilai-nilai yang ditunjukkan oleh huruf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah konstanta refleksi untuk refleksi ambient, difus, dan specular. Masing-masing adalah sebagian kecil dari jenis yang sesuai dari cahaya yang dipantulkan dari besarnya cahaya yang datang; Nilai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C yang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kita lihat dalam persamaan di atas (nilai warna material permukaan untuk setiap jenis pencahayaan). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vektor </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah vektor "refleksi sempurna" - arah di mana cahaya yang dipantulkan akan bergerak jika permukaannya sangat halus; itu dihitung menggunakan permukaan normal dan vektor cahaya kejadian. Vektor </font></font><strong><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah vektor arah kamera; dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dinormalisasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Akhirnya, ada konstanta terakhir dalam persamaan: nilai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">α</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menentukan tingkat gloss permukaan. Semakin halus materialnya (mis. Semakin menyerupai kaca atau logam), semakin tinggi angkanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persamaan ini biasanya disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model refleksi Phong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pada saat penelitiannya, proposal seperti itu radikal, karena memerlukan sumber daya komputasi yang serius. Versi model yang disederhanakan dibuat oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jim Blinn</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menggantikan bagian rumus dari </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (vektor setengah-jarak dan permukaan normal). Nilai </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> harus dihitung untuk setiap sumber cahaya dan untuk setiap piksel dalam bingkai, dan</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cukup untuk menghitung satu kali untuk setiap sumber dan untuk seluruh adegan. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model refleksi Blinn-Fong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat ini adalah sistem pencahayaan standar dan digunakan secara default di Direct3D, OpenGL, Vulkan, dll. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada banyak model matematika lainnya, terutama sekarang karena GPU dapat memproses piksel dalam shader yang panjang dan kompleks; bersama-sama, formula seperti itu disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reflektansi dua arah / fungsi distribusi transmisi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (BRDF / BTFD); mereka adalah dasar untuk mewarnai setiap piksel pada monitor ketika kita memainkan game 3D modern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, sejauh ini kami hanya menganggap permukaan yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memantulkan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cahaya: bahan tembus cahaya mentransmisikan, sedangkan sinar cahaya </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibiaskan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dan beberapa permukaan. </font><font style="vertical-align: inherit;">misalnya, air memantulkan dan mengirimkan cahaya ke berbagai tingkat.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membawa pencahayaan ke tingkat yang baru</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat </font><font style="vertical-align: inherit;">permainan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creed: Odyssey dari Assassin's</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2018 </font><font style="vertical-align: inherit;">, di mana pemain sering berlayar di atas air, baik di sungai dangkal dan di laut dalam.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/032/29d/358/03229d3582d6b574b0089a5480cfc08b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kayu dicat, logam, tali, kain, dan air - semua ini memantulkan dan membiaskan cahaya menggunakan banyak perhitungan.Untuk</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
rendering air yang paling realistis dengan tetap mempertahankan kecepatan permainan yang memadai, programmer Ubisoft menggunakan serangkaian trik. Permukaan air diterangi oleh trio akrab cahaya ambient, menyebar, dan specular, tetapi mereka dilengkapi dengan fitur menarik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Yang pertama ini sering digunakan untuk menghasilkan sifat reflektif air - ini adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">refleksi ruang layar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSR). Teknik ini menampilkan adegan, tetapi warna piksel bergantung pada </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedalaman</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> setiap piksel, mis. dari jarak ke kamera. Kedalaman disimpan dalam </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;">buffer yang</font></em></a><font style="vertical-align: inherit;"> disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kedalaman</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kemudian bingkai diberikan lagi dengan semua pencahayaan dan tekstur yang biasa, tetapi adegan disimpan sebagai </font></font><em><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tekstur render</font></font></a></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan bukan sebagai buffer siap yang ditransmisikan ke monitor. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">barisan ray</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dilakukan </font><font style="vertical-align: inherit;">. Untuk melakukan ini, sinar dipancarkan dari kamera dan jarak diatur sepanjang sinar. Kode memeriksa kedalaman balok relatif terhadap piksel dalam buffer kedalaman. Jika mereka memiliki nilai yang sama, kode memeriksa piksel normal untuk melihat apakah diarahkan ke kamera, dan jika demikian, mesin mencari piksel yang sesuai dari tekstur render. Kemudian satu set instruksi lebih lanjut membalikkan posisi piksel sehingga tercermin dengan benar dalam adegan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/645/58b/1d1/64558b1d13b6bc349bd728278ec9686a.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perintah SSR digunakan dalam mesin Frostbite EA.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Selain itu, cahaya tersebar selama pergerakan dalam bahan, dan untuk bahan seperti air atau kulit, trik lain yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hamburan permukaan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SSS) digunakan. Kami tidak akan menjelaskannya secara rinci, tetapi Anda dapat membaca bagaimana ini digunakan untuk membuat hasil yang luar biasa dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">presentasi Nvidia 2014</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/23c/0e1/598/23c0e15983c2cfe6b17ba3d0aab97dc5.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo Nvidia 2013 FaceWorks ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Mari kita kembali ke Assassin's Creed water: Implementasi SSS sulit terlihat di sini, dan karena pertimbangan kecepatan, itu tidak begitu aktif digunakan. Dalam game sebelumnya di seri AC, Ubisoft </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan SSS palsu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi dalam game terakhir penggunaannya lebih rumit, tetapi masih tidak sebesar yang kita lihat di demo Nvidia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengubah nilai pencahayaan pada permukaan air, prosedur tambahan dilakukan yang mensimulasikan efek kedalaman dengan benar karena perubahan transparansi tergantung pada jarak ke pantai. Dan ketika kamera melihat air di dekat pantai, bahkan lebih banyak algoritma yang digunakan untuk memperhitungkan kaustik dan pembiasan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasilnya mengesankan:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb2/486/f56/cb2486f5697db7c578797127371af936.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assassin's Creed: Odyssey - memberikan air dengan segala kemuliaan.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Kami melihat air, tetapi bagaimana dengan pergerakan cahaya di udara? Partikel debu, uap air, dan elemen lainnya juga menyebabkan hamburan cahaya. Akibatnya, sinar cahaya menerima </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volume</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan tidak tetap hanya seperangkat sinar langsung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Topik pencahayaan volumetrik dapat diperluas hingga selusin artikel, jadi kita akan berbicara tentang bagaimana permainan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rise of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berurusan dengannya </font><font style="vertical-align: inherit;">. Dalam video di bawah ini, hanya ada satu sumber utama pencahayaan - matahari bersinar melalui lubang di gedung.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/3w9rHXIYjI4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk membuat volume cahaya, mesin game mengambil piramida visibilitas kamera (lihat di bawah) dan secara eksponensial memecahnya menjadi 64 bagian. Kemudian, setiap irisan dirasterisasi ke dalam kisi-kisi dengan ukuran 160 x 94 elemen, dan semua data ini disimpan dalam tekstur render tiga dimensi dari format FP32. Karena tekstur biasanya dua dimensi, "piksel" volume piramida disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voxel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b1/857/5cf/3b18575cfb0114e1b8ba8c152c4c4bd1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk blok voxel 4 x 4 x 4, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shader komputasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menentukan sumber cahaya aktif mana yang mempengaruhi volume ini, dan kemudian menulis informasi ini ke tekstur render tiga dimensi lainnya. Kemudian, untuk memperkirakan "kepadatan" cahaya total di dalam blok voxel, formula kompleks yang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://web.archive.org/web/20141102063940/" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi hamburan Hengy-Greenstein digunakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian mesin melakukan beberapa shader lebih untuk memperbaiki data, setelah itu dilakukan marching ray sepanjang irisan piramida dengan akumulasi nilai kepadatan cahaya. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eidos-Montréal mengklaim</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bahwa di Xbox One semua operasi ini memakan waktu sekitar 0,8 milidetik!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meskipun teknik ini tidak digunakan di semua gim, pemain berharap untuk melihat cakupan volumetrik di hampir semua gim 3D populer yang dirilis hari ini, terutama di gim tembak-menembak orang pertama dan gim aksi-petualangan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/064/e06/b34/064e06b347c8e5cafe892fbdde2d14de.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pencahayaan volumetrik yang digunakan dalam sekuel Rise of the Tomb Raider tahun 2018.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Awalnya, teknik pencahayaan ini disebut "sinar ilahi", atau, sebagaimana mereka disebut dalam istilah ilmiah, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"sinar senja</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">"</font></em><font style="vertical-align: inherit;"> Salah satu game pertama yang digunakan adalah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Crysis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pertama </font><font style="vertical-align: inherit;">Crytek, dirilis pada 2007. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, ini bukan pencahayaan volumetrik yang benar - prosesnya termasuk rendering awal adegan dalam bentuk buffer kedalaman, yang digunakan sebagai topeng - buffer lain di mana warna piksel menjadi lebih gelap semakin dekat mereka ke kamera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penyangga topeng ini disampel beberapa kali, dan shader mengambil sampel dan mencampurnya dengan mengaburkan. Hasil operasi ini dicampur dengan adegan selesai:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5d9/f9b/891/5d9f9b891a670f005d77704953040215.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemajuan kartu grafis selama 12 tahun terakhir telah luar biasa. </font><font style="vertical-align: inherit;">GPU paling kuat pada saat rilis Crysis adalah Nvidia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce 8800 Ultra</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">GPU modern tercepat - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GeForce RTX 2080 Ti</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memiliki daya komputasi lebih dari 30 kali, memori 14 kali lebih banyak, dan bandwidth 6 kali lebih banyak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan semua kekuatan komputasi ini, game modern dapat memberikan akurasi grafis yang lebih besar dan kecepatan keseluruhan, meskipun kompleksitas rendering semakin meningkat.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d73/9bf/541/d739bf54169f0900929280cee0d4553b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Divine Rays" di Ubisoft's The Division 2</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Tetapi pada kenyataannya, efek ini menunjukkan bahwa meskipun pentingnya pencahayaan yang benar untuk akurasi visual, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ketiadaan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cahaya </font><font style="vertical-align: inherit;">sebenarnya bahkan lebih penting </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Esensi bayangan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai bagian baru artikel dengan game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Pada gambar di bawah, semua opsi grafik yang terkait dengan bayangan dinonaktifkan; </font><font style="vertical-align: inherit;">di sebelah kanan mereka disertakan. </font><font style="vertical-align: inherit;">Perbedaannya sangat besar, bukan?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/399/6db/855/3996db855ea5a727cc8b8c8e565227d8.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena bayangan terbentuk secara alami di dunia nyata, permainan di mana mereka diterapkan secara keliru tidak akan pernah terlihat benar. </font><font style="vertical-align: inherit;">Otak kita terbiasa menggunakan bayangan sebagai dukungan visual untuk menciptakan perasaan kedalaman, lokasi, dan pergerakan relatif. </font><font style="vertical-align: inherit;">Tetapi melakukannya dalam game 3D sangat sulit, atau setidaknya sulit untuk melakukannya dengan benar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan bebek. </font><font style="vertical-align: inherit;">Di sini dia bergerak di sekitar lapangan, dan sinar matahari mencapai dia dan diblokir dengan benar.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3f/2ad/1d8/f3f2ad1d84f865217d5e28cfaab98604.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu cara pertama untuk menerapkan bayangan dalam adegan adalah menambahkan "tempat" bayangan di bawah model. Ini sama sekali tidak realistis, karena bentuk bayangan tidak cocok dengan bentuk benda yang melemparkan bayangan; Namun, pendekatan ini cepat dan mudah dibuat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Game 3D pertama, misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tomb Raider pertama</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tahun 1996, menggunakan metode ini karena perangkat keras pada waktu itu, misalnya, Sega Saturn dan Sony PlayStation, tidak dapat memberikan yang lebih baik. Metode ini melukis satu set primitif sederhana tepat di atas permukaan di mana model bergerak, dan kemudian menaungi mereka; menggambar di bagian bawah tekstur sederhana juga digunakan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ad/1b8/735/3ad1b8735674a430a18559fc87a28baa.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode lain yang pertama adalah </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memproyeksikan bayangan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Dalam hal ini, primitif yang memancarkan bayangan diproyeksikan ke sebuah pesawat yang berisi lantai. </font><font style="vertical-align: inherit;">Bagian dari perhitungan matematika yang diperlukan untuk ini diciptakan oleh Jim Blinn di akhir 80-an. </font><font style="vertical-align: inherit;">Dengan standar modern, ini adalah proses yang sederhana, dan ini berfungsi paling baik untuk objek statis sederhana.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/130/ced/f47/130cedf47748e034cd6c87d98da9e487.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun berkat optimalisasi, proyeksi bayangan memberikan penciptaan contoh-contoh bayangan dinamis pertama yang layak, misalnya, dalam game 1999 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kingpin: Life of Crime</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> by Interplay. </font><font style="vertical-align: inherit;">Seperti yang kita lihat pada gambar di bawah ini, hanya karakter animasi (bahkan tikus!) Memiliki bayangan, tetapi ini lebih baik daripada bintik-bintik sederhana.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ea/dc7/5a1/2eadc75a107ec0eec8a3c0bc37497b64.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah yang paling serius dengan pendekatan ini adalah: (a) opacity bayangan sempurna, dan (b) metode proyeksi memancarkan bayangan pada satu permukaan datar (misalnya, di tanah). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah-masalah ini dapat diselesaikan dengan menerapkan sebagian kecil transparansi ketika mewarnai proyeksi primitif dan melakukan beberapa proyeksi untuk setiap karakter, tetapi kemampuan perangkat keras PC pada akhir 90-an tidak dapat mengatasi render tambahan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teknologi modern untuk menciptakan bayangan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cara yang lebih akurat untuk mengimplementasikan bayangan telah diusulkan jauh sebelumnya, sudah pada tahun 1977. Saat bekerja di University of Austin (Texas), Franklin Crowe menulis sebuah </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel penelitian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di mana ia mengusulkan beberapa teknik menggunakan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">volume</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bayangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara umum, mereka dapat digambarkan sebagai berikut: proses menentukan primitif mana yang diarahkan ke sumber cahaya; tulang rusuk mereka diregangkan ke pesawat. Meskipun ini sangat mirip dengan memproyeksikan bayangan, perbedaan penting adalah bahwa volume bayangan yang dibuat kemudian digunakan untuk memeriksa apakah piksel berada di dalam / di luar volume. Berkat informasi ini, bayangan dapat dipancarkan di semua permukaan, bukan hanya tanah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teknik ini ditingkatkan pada tahun 1991 oleh Tim Heidmann, yang bekerja pada</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grafis Silikon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mark Kilgard</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terlibat dalam pengembangan lebih lanjut pada tahun 1999 </font><font style="vertical-align: inherit;">, dan metode yang akan kami pertimbangkan dibuat pada tahun 2000 oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Carmack</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari id Software (walaupun metode Carmack dibuka secara independen dua tahun sebelumnya oleh Bilodo dan Songa dari Creative Labs; ini menyebabkan bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Carmack terpaksa mengubah kodenya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk menghindari masalah hukum). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan ini membutuhkan rendering beberapa frame (disebut </font><font style="vertical-align: inherit;">rendering </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multipass</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - proses yang </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sangat</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mahal di awal 90-an yang digunakan di mana-mana saat ini) dan konsep yang disebut </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buffer stensil</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak seperti buffer dan kedalaman bingkai, itu tidak dibuat oleh adegan 3D itu sendiri - buffer ini adalah array nilai yang sama di semua dimensi (mis. Resolusi dalam </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dalam bentuk raster. </font><font style="vertical-align: inherit;">Nilai yang tersimpan di dalamnya digunakan untuk memberi tahu mesin rendering apa yang harus dilakukan dengan setiap piksel dalam buffer bingkai. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh paling sederhana untuk menggunakan buffer ini adalah menggunakan sebagai mask:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b99/dfa/f1c/b99dfaf1c876fb4ed736c5947460efbd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode dengan volume bayangan dilakukan seperti ini:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membuat adegan ke frame buffer, tetapi hanya menggunakan pencahayaan sekitar (kami juga menyertakan semua nilai emisi di dalamnya jika pikselnya mengandung sumber cahaya)</font></font></li>
<li>  ,    ,    (  <em>   (back-face culling)</em>).        (,  )         .   <em></em>   (..     «»)    -     .</li>
<li>  ,       (front-face culling)    -,     .</li>
<li>   ,        ,       -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Buffer stensil dan volume bayangan ini (biasanya disebut bayangan stensil) digunakan dalam permainan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Doom 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> id Software 2004 </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/501/015/720/5010157201afaff6066d609748a40eae.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perhatikan bahwa permukaan karakter yang sedang berjalan masih terlihat melalui bayangan? Ini adalah keuntungan pertama dari proyeksi bayangan. Selain itu, pendekatan ini memungkinkan Anda untuk memperhitungkan jarak dari sumber cahaya (sebagai hasilnya, bayangan yang lebih lemah diperoleh) dan melemparkan bayangan pada permukaan apa pun (termasuk karakter itu sendiri). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi teknik ini memiliki kelemahan serius, yang paling terlihat adalah bahwa tepi bayangan sepenuhnya tergantung pada jumlah primitif yang digunakan untuk membuat objek yang melemparkan bayangan. Selain itu, multipassing dikaitkan dengan banyak operasi baca / tulis ke memori lokal, itulah sebabnya penggunaan bayangan stensil cukup mahal dalam hal kinerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, ada batasan jumlah volume bayangan, yang dapat diperiksa menggunakan buffer stensil, karena semua API grafik mengalokasikan sejumlah bit yang cukup kecil di atasnya (biasanya hanya 8). Namun, karena biaya komputasi bayangan stensil, masalah ini biasanya tidak muncul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah lain - bayangan itu sendiri jauh dari realistis. Mengapa? Karena semua sumber cahaya - lampu, api terbuka, lentera, dan Matahari - bukanlah titik tunggal di ruang angkasa, mis. mereka memancarkan cahaya dari beberapa daerah. Bahkan dalam kasus paling sederhana yang ditunjukkan di bawah ini, bayangan nyata jarang memiliki tepi yang tajam.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/6b4/52b/b7c6b452bacb558d508a751c5bdebdb1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wilayah bayangan yang paling gelap disebut bayangan penuh (umbra); </font><font style="vertical-align: inherit;">penumbra selalu merupakan bayangan yang lebih terang, dan batas antara keduanya sering kabur (karena biasanya ada banyak sumber cahaya). </font><font style="vertical-align: inherit;">Sulit untuk memodelkan ini dengan buffer dan volume stensil, karena bayangan yang dibuat disimpan dalam bentuk yang salah sehingga dapat diproses. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pemetaan bayangan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> datang untuk menyelamatkan </font><font style="vertical-align: inherit;">! </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prosedur dasar</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dikembangkan pada tahun 1978 oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lance Williams</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini sangat sederhana:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap sumber cahaya, kami membuat adegan dari sudut pandang sumber ini, menciptakan tekstur kedalaman khusus (yaitu, tanpa warna, pencahayaan, tekstur, dll.). </font><font style="vertical-align: inherit;">Resolusi buffer ini tidak harus sama dengan ukuran bingkai jadi, tetapi semakin tinggi semakin baik.</font></font></li>
<li>      ,        (  x,y  z) ,        .</li>
<li>          :   ,           .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jelas, ini adalah prosedur multi-pass lain, tetapi langkah terakhir dapat dilakukan menggunakan pixel shader sehingga pemeriksaan kedalaman dan perhitungan pencahayaan selanjutnya digabungkan dalam satu pass. Dan karena seluruh proses pembuatan bayangan tidak tergantung pada jumlah primitif yang digunakan, itu jauh lebih cepat daripada menggunakan buffer stensil dan volume bayangan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sayangnya, teknik dasar yang dijelaskan di atas menghasilkan semua jenis artefak visual (misalnya, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perspektif aliasing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"bayangan jerawat"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , "peter panning"), yang sebagian besar terkait dengan resolusi dan ukuran bit dari tekstur kedalaman. Semua GPU dan API grafik memiliki keterbatasan yang mirip dengan tekstur, sehingga seluruh rangkaian teknik tambahan telah dibuat untuk menyelesaikan masalah ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu manfaat menggunakan tekstur untuk informasi mendalam adalah bahwa GPU dapat mengambil sampel dan memfilternya dengan sangat cepat dan dengan berbagai cara. Pada tahun 2005, Nvidia menunjukkan metode pengambilan sampel tekstur yang dapat menyelesaikan beberapa masalah visual yang disebabkan oleh bayangan standar. Selain itu, ia memberikan tingkat kehalusan tepi bayangan tertentu; teknik ini disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penyaringan persentase lebih dekat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4c0/5bf/c31/4c05bfc31232887519a64eb7995e7d7d.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekitar waktu yang sama, Futuremark mendemonstrasikan penggunaan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cascaded shadow maps</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (CSM) di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3DMark06</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ini adalah teknik di mana untuk setiap sumber cahaya beberapa tekstur kedalaman dibuat dengan resolusi yang berbeda. Tekstur resolusi tinggi digunakan di dekat sumber, dan lebih rendah - pada jarak dari sumber. Hasilnya adalah transisi bayangan yang lebih halus dalam adegan tanpa distorsi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Teknik ini ditingkatkan oleh Donnelly dan Loritzen pada 2006 dalam prosedur </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">varians shadow mapping</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (VSM) mereka, serta Intel pada 2010 dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritma distribusi sampel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (SDSM).</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a2f/91a/0d8/a2f91a0d8f6c22ba64ab03aeccf50b00.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan SDSM dalam Shadow of the Tomb Raider</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Untuk meningkatkan kualitas gambar, pengembang game sering menggunakan gudang persenjataan lengkap, tetapi yang utama tetap pemetaan bayangan. Namun, ini dapat diterapkan hanya pada sejumlah kecil sumber cahaya aktif, karena jika Anda mencoba memodelkannya untuk setiap permukaan yang memantulkan atau memancarkan cahaya, laju bingkai akan secara serempak turun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untungnya, ada teknik nyaman yang bekerja dengan objek apa pun. Ini memberi kesan penurunan kecerahan pencahayaan mencapai objek (karena fakta bahwa ia atau benda lain menghalangi cahaya sedikit). Fitur ini disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oklusi ambien.</font></font></em></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan dia memiliki banyak versi. Beberapa dari mereka dirancang khusus oleh produsen perangkat keras, misalnya, AMD menciptakan HDAO ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oklusi ambien definisi tinggi</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), dan Nvidia memiliki </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HBAO +</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oklusi ambient berbasis horizon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versi apa pun yang digunakan, itu diterapkan setelah adegan sepenuhnya diberikan, oleh karena itu diklasifikasikan sebagai efek </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pasca-pemrosesan</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Bahkan, untuk setiap piksel dihitung berapa banyak kita melihatnya di tempat kejadian (lebih lanjut tentang ini di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dengan membandingkan nilai kedalaman piksel dengan piksel yang mengelilinginya pada titik yang sesuai dalam buffer kedalaman (yang, sekali lagi, disimpan sebagai tekstur).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengambil sampel buffer kedalaman dan kemudian menghitung warna piksel akhir memainkan peran penting dalam memastikan kualitas oklusi ambien; </font><font style="vertical-align: inherit;">seperti dalam kasus shadowing, semua versi oklusi ambien untuk operasi yang tepat mengharuskan programmer untuk dengan hati-hati mengkonfigurasi dan menyesuaikan kode tergantung pada situasinya.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f4e/865/e15/f4e865e159dfa5e83286e1245a5b46f9.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Shadow of the Tomb Raider tanpa AO (kiri) dan dengan HBAO + (kanan)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Namun, ketika diterapkan dengan benar, efek visual ini meninggalkan kesan mendalam. </font><font style="vertical-align: inherit;">Pada gambar di atas, perhatikan tangan, nanas, dan pisang orang tersebut, serta rumput dan tumbuh-tumbuhan di sekitarnya. </font><font style="vertical-align: inherit;">Perubahan warna pixel HBAO + cukup kecil, tetapi semua objek sekarang terlihat lebih baik dibangun ke lingkungan (di sebelah kiri tampaknya seseorang tergantung di atas tanah).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda memilih salah satu game terakhir yang dibahas dalam artikel ini, maka daftar teknik render yang digunakan saat memproses pencahayaan dan bayangan akan menjadi panjang dari artikel itu sendiri. Dan meskipun tidak semua gim 3D baru menawarkan semua teknologi ini, mesin gim universal seperti Unreal memungkinkan Anda mengaktifkannya secara opsional, dan toolkit (misalnya, perusahaan Nvidia) menyediakan kode yang siap dimasukkan ke dalam gim. Ini membuktikan bahwa mereka bukan metode ultramodern yang sangat terspesialisasi - yang dulunya milik pemrogram terbaik, sekarang mereka tersedia untuk siapa saja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami tidak dapat menyelesaikan artikel ini tentang pencahayaan dan bayangan tanpa menyebutkan penelusuran sinar. Kita </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sudah membicarakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> proses ini </font><font style="vertical-align: inherit;">dalam seri artikel ini, tetapi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tingkat perkembangan teknologi saat ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membutuhkan memasang dengan frame rate rendah dan pengeluaran uang tunai yang serius. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, teknologi ini didukung oleh konsol generasi mendatang Microsoft dan Sony, yang berarti bahwa selama beberapa tahun ke depan, penggunaannya akan menjadi alat standar lain bagi para pengembang di seluruh dunia yang berupaya meningkatkan kualitas visual permainan. </font><font style="vertical-align: inherit;">Lihat saja apa yang berhasil dicapai Remedy dalam game </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontrol</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> terbarunya </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/gJ7gdBGXODI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami telah menempuh perjalanan jauh dari bayangan palsu dalam tekstur dan pencahayaan ambient yang sederhana!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bukan itu saja</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam artikel tersebut, kami mencoba untuk berbicara tentang perhitungan matematika dasar dan teknik yang digunakan dalam permainan 3D, yang membuatnya se serealistis mungkin. </font><font style="vertical-align: inherit;">Kami juga memeriksa teknologi yang mendasari pemodelan interaksi cahaya dengan benda dan material. </font><font style="vertical-align: inherit;">Tetapi semua ini hanyalah puncak gunung es. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, kami melewatkan topik seperti pencahayaan hemat energi, lensa flare, bloom, render yang sangat dinamis, transfer cahaya, koreksi nada, kabut, aberasi kromatik, pemetaan foton, kaustik, radiositas - daftar ini berlanjut. </font><font style="vertical-align: inherit;">Sebuah studi singkat akan membutuhkan 3-4 artikel lagi.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id501426/index.html">Serentak: mengatur dan mengotomatisasi sinkronisasi dua arah direktori pada dua server</a></li>
<li><a href="../id501430/index.html">Panduan Luar Biasa untuk Desain dan Perencanaan Konten Situs Web</a></li>
<li><a href="../id501432/index.html">Dua alternatif untuk JDBC</a></li>
<li><a href="../id501434/index.html">Security Week 20: meretas komputer melalui Thunderbolt</a></li>
<li><a href="../id501436/index.html">Algoritma pengenalan angka pada gambar dengan probabilitas rendah dari jenis kesalahan kedua</a></li>
<li><a href="../id501440/index.html">Zabbix 5.0 dirilis</a></li>
<li><a href="../id501442/index.html">Perintah linux dasar untuk pemula</a></li>
<li><a href="../id501448/index.html">Bagaimana kami membuat profil kursus Agile yang unik</a></li>
<li><a href="../id501450/index.html">14 hal yang harus diketahui pengembang iOS</a></li>
<li><a href="../id501454/index.html">Enam Tips untuk Menggunakan PostgreSQL dalam Tes Fungsional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>