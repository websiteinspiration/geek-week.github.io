<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👰🏻 ♟️ 🔁 Zufällige Verzweigungen in Python generieren 👩🏼‍✈️ ↕️ 🤟🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Unter Hinweis auf Dawkins kann die Hauptidee wie folgt ausgedrückt werden: Wenn Sie den Tornado lange Zeit über dem Müll halten, kann sich eine Boeing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Zufällige Verzweigungen in Python generieren</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/504296/"><img src="https://habrastorage.org/webt/fy/vd/nr/fyvdnr83rzvq1tow9chyg7e0kry.gif" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter Hinweis auf Dawkins kann die Hauptidee wie folgt ausgedrückt werden: Wenn Sie </font><font style="vertical-align: inherit;">den Tornado </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lange Zeit</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> über dem Müll halten, kann sich eine Boeing 747 zusammenbauen. Das Entstehen einer Struktur aus dem Chaos durch einen Durik: Alles in einer Reihe sortieren und neu kombinieren, aus all den bedeutungslosen und ungeordneten Prozessen kann man ziemlich bedeutungsvolle und geordnete sehen. Wenn solche Prozesse irgendwie fixiert und wiederholt werden, dann sieht das System, das gestern eine Brownsche Bewegung war, heute so aus, als ob sein Verhalten von einer unsichtbaren Hand aufgebaut worden wäre und dass es einige Aktionen ausführt, die aus unserer Sicht sinnvoll sind. Gleichzeitig gibt es überhaupt keine Hand. Sie stellte sich auf.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um dies noch einmal sicherzustellen, bemühe ich mich, eine Art digitales Leben zu schreiben, das aus Chaos und ohne unnötige Anweisungen einer Person in der Lage sein wird, zufällig Logik für sich selbst zu generieren und darauf in seinem natürlichen Lebensraum - dem Betriebssystem - zu existieren. Ja, hier besteht wahrscheinlich ein Unterschied zu vielen Programmen aus der Richtung „Künstliches Leben“, die in Ställen „leben“, „Raubtiere“ und „Pflanzenfresser“ produzieren und auf künstlichen Feldern neben „Nahrung“ und untereinander existieren. Keines dieser Programme interagiert mit Systemobjekten (Prozessen, Dateien usw.), was bedeutet, dass der Code nicht wirklich lebt. Darüber hinaus führt dieser Code auf die eine oder andere Weise immer noch eine Aufgabe aus, die eine Person benötigt, und ist daher in ihrem Umfang sehr begrenzt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um Code mit einem hohen Maß an Handlungsfreiheit im Betriebssystem zu implementieren, der gleichzeitig nicht nur ein chaotischer Satz von Ausführungsanweisungen wäre, erschien ein Modell, das aus 3 Modulen besteht. </font></font><br>
<a name="habracut"></a><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Modul zur zufälligen Generierung des ausführbaren Hauptcodes</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modul für zufällige Bildung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das "Computer Vision" -Modul von Betriebssystemobjekten</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Artikel werden wir über das erste Modul sprechen, bei dem es sich bisher nur um die Erzeugung einer zufälligen Verzweigung handelt, d. H. Konstruktionen wie "if-elif-else". Warum verzweigen? Denn im Großen und Ganzen besteht das Leben eines lebenden Organismus aus konditionierten Reaktionen: Alles, was wir tun, ist eine Reaktion auf wahrgenommene Informationen. Zellen teilen sich, wenn bestimmte Bedingungen eintreten, das Opfer versucht zu fliehen, wenn es ein stärkeres Raubtier sieht, und wenn es schwächer ist, kann es versuchen, ihn anzugreifen, Kakerlaken zerstreuen sich, wenn das Licht an ist, eine Person geht essen, wenn sie hungrig ist usw. usw. - Diese Reihe ist endlos. Es gibt keine unabhängigen, separaten Aktionen, die durch nichts bedingt sind. Folglich wird insbesondere das Verhalten lebender Organismen als Reaktion auf den Zustand beschrieben: WENN [etwas] DANN [etwas]. Wir versuchen, dieses Verhalten zu erzeugen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Warum zufällig? Um dem Code die maximale Möglichkeit zu geben, unabhängig zu handeln und die Person (Programmierer) so weit wie möglich von diesem Prozess wegzubewegen (idealerweise vollständig auszuschließen). Letzteres ist für den Programmierer am schwierigsten, weil Die Standardprogrammierung, an die jeder gewöhnt ist, ähnelt einem harten Training von Tieren, das genau das ausführen muss, was der Programmierer angibt, genau so, wie er es angibt, wenn er angibt. Hier ist die Situation umgekehrt: Der endgültig generierte Code muss so handeln, dass er für den Ersteller seines Generators ebenso unvorhersehbar ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir zu den Diagrammen und dem Code des Generators übergehen, müssen wir uns mit der Entscheidungsfunktion befassen, die als Leiter verwendet wird, damit der eine oder andere Teil des Codes ausgeführt werden kann. Ich habe früher über sie geschrieben</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ich wurde dann aufgefordert, die Idee des Reinforcement Learning und das Spiel von John Conway mit dem Titel "Life" zu beschreiben. Es kann gut sein, dass ich nichts dagegen habe, das zu verwenden, was bereits entwickelt wurde oder offen. Am Ende ist alles Neue eine Synthese des bereits Bekannten, und ich selbst gab zu, dass ich die Idee der Priorisierung von Flows übernommen habe, die in Windows verwendet wird. Hier ist sie sehr gut geeignet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Derzeit wurde die erwähnte Funktion leicht transformiert:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_solution</span>(<span class="hljs-params">p_random, p_deter</span>):</span>                       
    deter_flag = <span class="hljs-number">0</span>
    random_flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">if</span> p_random &gt;= random.random():<font></font>
            p_random-=<span class="hljs-number">0.01</span>                                  <span class="hljs-comment">#  </span>
            p_deter+=<span class="hljs-number">0.01</span>
            random_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> p_deter &gt;= random.random():<font></font>
            p_deter-=<span class="hljs-number">0.01</span>                                   <span class="hljs-comment">#  </span>
            p_random+=<span class="hljs-number">0.01</span>
            deter_flag = <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> random_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> deter_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">1</span>)
    <span class="hljs-keyword">elif</span> deter_flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> random_flag == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span>(p_random, p_deter, <span class="hljs-number">-1</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> (p_random, p_deter,<span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Eingang werden 2 Wahrscheinlichkeiten benötigt (standardmäßig sind sie zu Beginn beide gleich 0,5), wonach die Operation nacheinander überprüft wird. Die ausgelöste Wahrscheinlichkeit verringert sich um 1% und erhöht gleichzeitig die andere um 1%. Daher nimmt die Wahrscheinlichkeit jedes Mal ab, wenn sie funktioniert, und die andere nimmt zu. Infolgedessen erhält keine Wahrscheinlichkeit einen zu großen Vorteil gegenüber einer anderen, und sie gleichen sich selbst aus und bilden eine Normalverteilung, die bei 0,5 zentriert ist und eine Arbeitsumgebung von nicht mehr als + -10% aufweist, was diese Funktion von dem Standard-Zufall unterscheidet, bei dem die Wahrscheinlichkeit in unserem Fall Sie wäre immer gleich 0,5 und würde nicht von früheren Berechnungen abhängen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im übertragenen Sinne handelt es sich um ein Wahrscheinlichkeitspendel mit einer kleinen Amplitude. Wenn die erste Wahrscheinlichkeit funktioniert hat und die zweite nicht funktioniert hat, wird 1 zurückgegeben, andernfalls wird -1 zurückgegeben, und wenn beide funktioniert haben oder nicht funktioniert haben, 0, gibt die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für 2 eingehende Wahrscheinlichkeiten eine von 3 möglichen Aktionen zurück, was einen Ausgleich ergibt Gabellösung mit 3 möglichen Fortsetzungsoptionen. In Zukunft ist diese Funktion wahrscheinlich universell und kann eine unbestimmte Anzahl von Wahrscheinlichkeiten annehmen, weil Die Variation an den Gabeln kann mehr als 3 betragen, aber im Fall des if-elif-else-Generators sind drei Optionen für die Fortsetzung völlig ausreichend.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierbei ist auch zu beachten, dass es im Code sozusagen verschiedene typische Gabeln gibt. Wie weiter unten zu sehen sein wird, gibt es in der Hauptfunktion des Generators eine Gabelung, in der ein Schema zum Erstellen eines Zweigs ausgewählt werden kann, von dem es nur 3 gibt, aber auch andere Fälle im Code vorhanden sind: Einfügen eines Aktionsblocks oder Starten einer Rekursion, Anzahl der zu generierenden Aktionszeilen, wie komplex sie sein sollte Linie mit der Bedingung, setzen oder oder und und, elif oder sonst. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich glaube, dass das probabilistische Pendel, über das wir oben gesprochen haben, für jede Art von Aktion festgelegt werden sollte: Dann wird die Gabel nur auf der Grundlage dessen ausgeglichen, was zuvor auf dieser Gabel passiert ist, und nicht in einigen anderen Teilen des Codes. Jene. Bei der Auswahl der allgemeinen Verzweigungsstruktur haben wir unser eigenes Paar von Wahrscheinlichkeiten und innerhalb, wenn ihre Elemente aufgebaut sind, ein anderes.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Natürlich können Sie alle Aktionen mit einem Paar ausgleichen, aber dann ist die Wahrscheinlichkeit an jeder Gabelung sehr schwierig und hängt von allen vorherigen Aktionen an anderen Kreuzungen ab. Die Zufälligkeit eines solchen Entwurfs wird noch höher sein, aber im Moment neige ich persönlich zum ersten Schema, weil ich den Entwurf mag, bei dem andere kleine im Rahmen eines großen schwingenden Pendels schwingen, d. H. kleinere Guthaben entstehen in einem großen Guthaben. Außerdem ist im zweiten Schema die Zufälligkeit mehr als ausreichend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beim Schreiben des Zweiggenerators musste nicht nur funktionsfähiger Code erstellt werden, der fehlerfreie Generationen erzeugt, sondern auch Code, der dies </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">könnte</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Generieren Sie die maximal möglichen Konstrukte von if-elif-else, aber es gibt nicht zwei oder drei solcher möglichen Optionen. Betrachten Sie beispielsweise die folgenden möglichen Schemata. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qu/oj/i3/quoji3ppc2arksk-xwafu3lfiqm.jpeg" width="350" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit dem Symbol </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[..]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in den Schemata meine ich eine Reihe von Ausdrücken für eine Bedingung oder einen Block zufälliger Aktionen. Das elementarste Schema ist 1, wo die Bedingung einfach geht, und danach der Aktionsblock. 2a und 2b sind Variationen mit einem Elif oder einem anderen. In Option 2c, wenn bereits in Kombination mit mehreren elif ohne sonst kommt. Und schließlich wird in Option 2d das allgemeinste Schema vorgestellt, wobei if mehrere elif und 1 else enthält.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alles wäre einfach, wenn nicht unbegrenzt viele Filialen gebaut werden müssten. Nach jedem if, elif oder else kann eine Rekursion aufgerufen werden, die wiederum weiter rekursiv sein und neue elif-else-Blöcke rechts erzeugen kann. Schauen wir uns das Schema möglicher Optionen an. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/y0/0z/vr/y00zvr1zkcwxuceu28olrpfabpo.jpeg" width="400" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ausführungsformen 2e und 2f zeigen einfache Sonderfälle einer solchen rekursiven Verzweigung, wenn die Rekursion entweder nach einem einzelnen Elif oder nach einem einzelnen anderen aufgerufen wird. Option 2g beschreibt den komplexesten und allgemeinsten Fall einer solchen Rekursion, wenn nach jedem elif ein Aktionsblock + eine Rekursion (oder eine sofortige Rekursion) auftreten kann und dasselbe nach anderen passieren kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt immer noch Variationen, wenn die Rekursion unmittelbar nach if oder after if und einem Aktionsblock erfolgt.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hx/dv/ye/hxdvyem6hl667rv0v-e-mjhpiv8.jpeg" width="400" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist in den Optionen 3a und 3b zu sehen. Option 3c zeigt ein solches Schema in der allgemeinsten Form. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies bedeutet nicht, dass die obigen Schemata alle möglichen Optionen zum Erstellen von Verzweigungen abdecken. Selbst in dieser Form erstellt der endgültige Code problemlos Verzweigungen in 150 Zeilen, wobei 10 bis 15 Schritte „nach rechts“ ausgeführt werden. In jedem Fall ist es nicht schwierig, das System bei Bedarf zu komplizieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können sich ein Beispiel </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">einer</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> solchen Generation </font><font style="vertical-align: inherit;">ansehen </font><font style="vertical-align: inherit;">, um sicherzustellen, dass die Zweige sehr unterschiedlich sein können.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/zs/8j/gd/zs8jgd-5efc6vzg0thgjztgfyq0.jpeg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie müssen nicht auf die Zusammensetzung von bedingten Ausdrücken und Aktionsblöcken achten - der visuellen Einfachheit halber werden sie nur aus Kombinationen von zwei Variablen, 3 Ausdrücken und einer kleinen Anzahl von arithmetischen und logischen Vorzeichen generiert. Eine Diskussion des echten „Fleisches“ für die Rekombination würde den Rahmen dieses Artikels sprengen (dies wird in der Diskussion von 3 Modulen diskutiert). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor Sie mit der direkten Prüfung des Generatorcodes fortfahren, müssen Sie berücksichtigen, dass die generierten Blöcke horizontal nach rechts verschoben werden müssen, wenn es sich um elif handelt, andernfalls wenn es sich um Rekursions- oder Aktionsblöcke handelt, und dass Sie nach Abschluss des Zweigs auch nach links „zurückgehen“ müssen. Da Python in Bezug auf horizontale Einrückungen sehr wählerisch ist, ist es außerdem wünschenswert, den Schritt gleich zu machen (in unserem Fall ist der Schritt 3).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das folgende Diagramm zeigt, wie Verschiebungen verschoben werden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mu/p8/ue/mup8uegwtzj-fydzcdcsswbsutw.jpeg" width="500" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Wichtigste dabei ist, dass die Verschiebungen mit der Vertiefung des Astes immer nach rechts verschoben werden. Wenn wir jedoch zum Beispiel einen elif-else-Block haben, in dem sich mehrere elif oder ein einzelnes elif-else-Paar befinden, muss der nach rechts schwebende Wagen „zurückgegeben“ werden, damit der nächste elif (oder sonst) mit beginnt gleiche Offsets wie der vorherige im Block. Dazu müssen Sie den ursprünglichen Offset ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset) speichern</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und nach dem Ende der Verzweigungsgenerierung (z. B. vollständige Verzweigung eines Elifs) wiederherstellen. Dies stellt sicher, dass die elif, else-Elemente im Block gleichmäßig „übereinander“ liegen. Darüber hinaus hat jeder neue Block seine eigene Verschiebung. Der gleiche Trick sorgt für Harmonie im gesamten if-elif-else-Konstrukt (einschließlich Rekursionen). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir nun zum Code. Der Code mit einem Gesamtvolumen von ca. 200 Zeilen besteht aus 8 Funktionen, von denen eine oben untersucht wurde. Aufgrund der Rekursivität und einer großen Anzahl von Parametern, die an Funktionen übergeben werden, kann es stellenweise schlecht lesbar sein. Zunächst werde ich genau das „Fleisch“ zitieren, mit dem bedingte Ausdrücke und Aktionsblöcke erzeugt werden.</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, werden zwei Variablen verwendet: a und b ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">var_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), die initialisiert werden, 3 arithmetische Ausdrücke ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sowie zwei Blätter mit Vorzeichen ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign, sign2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Wie bereits erwähnt, spielt die Zusammensetzung der resultierenden Ausdrücke jetzt keine Rolle und wird in diesem Artikel nicht berücksichtigt. Sie werden hauptsächlich zur Veranschaulichung des Codes benötigt. Eine weitere Besonderheit sollte beachtet werden: Bei der Generierung des elif-else-Blocks müssen Sie das Erscheinungsbild des else verfolgen und die Generierung stoppen. Andernfalls kann else vor elif erscheinen, was natürlich zu einem Fehler führt. Zu diesem Zweck wird das Flag </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir beginnen unsere Betrachtung mit der Hauptgenerationsfunktion.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_gen</span>(<span class="hljs-params">exp_list, var_list, if_str, offset_koeff, fin_else_flag, prob_list</span>):</span>             <font></font>
    choice_list = [exp_list, var_list]<font></font>
    base_offset = <span class="hljs-string">' '</span>
    <span class="hljs-comment">#   </span>
    prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>],sol = make_solution(prob_list[<span class="hljs-number">0</span>],prob_list[<span class="hljs-number">1</span>])       
    <span class="hljs-comment"># if +   (1   )        </span>
    <span class="hljs-keyword">if</span> sol == <span class="hljs-number">0</span>: 
        <span class="hljs-comment">#     +3                                                                   </span>
        action_str = action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)                 
        <span class="hljs-keyword">return</span>(base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str, offset_koeff, fin_else_flag, prob_list) 
    <span class="hljs-comment"># if + elif/else (2   )           </span>
    <span class="hljs-keyword">elif</span> sol == <span class="hljs-number">-1</span>:                                                                         <font></font>
        if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> + action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list) <span class="hljs-comment"># if [..]:</span>
        <span class="hljs-comment">#  elif/else</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol2=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])             
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
            ee_string=<span class="hljs-string">'elif'</span>
        <span class="hljs-keyword">else</span>:<font></font>
             ee_string=<span class="hljs-string">'else'</span>
        <span class="hljs-comment">#   elif/else</span><font></font>
        if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
        <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment"># if + if() (3   )</span>
    <span class="hljs-keyword">else</span>:                                                                                   <font></font>
            if_str= base_offset*offset_koeff+<span class="hljs-string">'if '</span>+ if_sub(exp_list,var_list, sign, prob_list) +<span class="hljs-string">':\n'</span> <span class="hljs-comment"># if [..]:</span>
            <span class="hljs-comment">#  if/if+ </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol = make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])        
            <span class="hljs-keyword">if</span> sol==<span class="hljs-number">0</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)      
            <span class="hljs-comment">#          </span><font></font>
            wall_offset = offset_koeff                                                      <font></font>
            if_rek, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list) <span class="hljs-comment">#  if+if</span>
            <span class="hljs-comment">#    </span><font></font>
            if_str+=if_rek   <font></font>
            <span class="hljs-comment">#   elif-else/                                                                </span>
            prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>],sol2=make_solution(prob_list[<span class="hljs-number">4</span>],prob_list[<span class="hljs-number">5</span>])         
            <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:<font></font>
                prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol3=make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
                <span class="hljs-keyword">if</span> sol3!=<span class="hljs-number">0</span>:<font></font>
                    ee_string=<span class="hljs-string">'elif'</span>
                <span class="hljs-keyword">else</span>:<font></font>
                    ee_string=<span class="hljs-string">'else'</span><font></font>
                if_str, offset_koeff, fin_else_flag, prob_list = elif_else_block(ee_string, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)  <font></font>
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment">#     +3</span>
                if_str+=action_str_gen(choice_list, offset_koeff+<span class="hljs-number">3</span>, prob_list)              
            <span class="hljs-keyword">return</span>(if_str, offset_koeff,fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu Listen mit "Fleisch" zur Generierung (exp_list, var_list) </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akzeptiert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die Funktion auch </font><b><font style="vertical-align: inherit;">if_str</font></b><font style="vertical-align: inherit;"> - dies ist die Zeile, in der der generierte Code der Reihe nach gesammelt wird. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird hier akzeptiert, da die Funktion </font><b><font style="vertical-align: inherit;">if_gen selbst</font></b><font style="vertical-align: inherit;"> rekursiv aufgerufen werden kann und es ratsam ist, den zuvor generierten Code nicht zu verlieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Parameter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_koeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Versatzkoeffizient, der ein Faktor für eine Linie mit einem Leerzeichen ist ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) und dementsprechend für die horizontalen Verschiebungen der Codeblöcke verantwortlich ist. </font><font style="vertical-align: inherit;">Wir haben oben </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
über </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag gesprochen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , hier wird es einfach an eine Funktion übergeben, die für die Erzeugung von if + elif / else verantwortlich ist (siehe unten). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, es gibt noch einen anderen Parameter -</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ein Blatt mit 10 Wahrscheinlichkeiten (5 Wahrscheinlichkeitspaare)</font></font><pre><code class="python hljs">prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)] </code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und es wird von der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make_solution</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet, </font><font style="vertical-align: inherit;">wie wir oben besprochen haben: Das eine oder andere Paar von Wahrscheinlichkeiten daraus, die dem Typ der Gabel entsprechen, wird an sie übergeben (zum Beispiel verwendet die Hauptstrukturgabel die ersten 2 Wahrscheinlichkeiten im Blatt: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [0]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list [1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Die Ergebnisse der Wahrscheinlichkeitsänderungen in diesem Blatt sind als Beispiel in der folgenden Abbildung dargestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/_o/qc/tw_oqckdotydpm1m5djcmdc3rgw.jpeg" width="550" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Wahrscheinlichkeiten in dieser Liste ändern sich von Generation zu Generation, wenn während der nächsten Generation der entsprechende Code ausgeführt wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Funktion selbst wird die verschachtelte Auswahlliste zu Beginn initialisiert - sie wird für die bequeme zufällige Generierung von Ausdrücken aus "Fleisch" benötigt, und der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Basisoffset base_offset = ''</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in einem Leerzeichen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Danach kommt die Hauptgabel, die über die Funktion make_solution die Lösung in die Variable sol bringt. Sol nimmt einen von drei Werten (0, -1,1) an und bestimmt daher, nach welchem ​​Schema die Struktur aufgebaut wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die erste Option implementiert die einfachste Option, wenn + [..]. Die Antwort besteht aus einer Zeichenfolge mit dem aktuellen Offset (muss nicht unbedingt gleich 0 sein!), Einer "if" </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-String</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , einer zufälligen Bedingung, die von der </font><b><font style="vertical-align: inherit;">if_sub-</font></b><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">(die später erläutert wird), dem Wagenrücklauf und der Generierung eines Aktionsblocks mithilfe der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">action_str-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><b><font style="vertical-align: inherit;">generiert</font></b><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">(siehe unten). . Als Ergebnis erhalten wir so etwas wie:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(b)):<font></font>
   b=b<font></font>
   a=b-a<font></font>
   a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die zweite Option ist für die Generierung dieses Typs verantwortlich: if [..] + elif / else-block (Option 2 in den Schemata). </font><font style="vertical-align: inherit;">Zuerst wird dort die if + [..] -Linie gebildet, dann tritt die elif / else-Gabel auf, die entscheidet, ob der elif-else-Block generiert wird, nur wenn-elif oder if-else (e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lif_else_block-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">- siehe unten). </font><font style="vertical-align: inherit;">Ergebnisse können variieren. </font><font style="vertical-align: inherit;">Zum Beispiel:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a+b)==(a)):<font></font>
   b=a+b<font></font>
<span class="hljs-keyword">elif</span> ((b//a)==(a)):
   <span class="hljs-literal">None</span>
<span class="hljs-keyword">elif</span> ((a+b)&lt;=(a)):<font></font>
   a=b//a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((b)&lt;=(a)):<font></font>
      a=b-a<font></font>
      b=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(b-a)):<font></font>
   b=b-a<font></font>
   b=b<font></font>
   a=b<font></font>
   a=b-a<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;(b-a))<span class="hljs-keyword">and</span>((a)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((b//a)&lt;(a)):<font></font>
      b=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a+b)&lt;(b-a))<span class="hljs-keyword">and</span>((b)&lt;(a+b))<span class="hljs-keyword">or</span>((a+b)==(a+b)):<font></font>
      b=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">elif</span> ((a)&gt;(b-a)):
      <span class="hljs-literal">None</span></code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;=(b-a))<span class="hljs-keyword">or</span>((a+b)&gt;=(b)):<font></font>
   a=a<font></font>
   b=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&lt;=(b)):
   <span class="hljs-keyword">if</span> ((a)&gt;=(b)):<font></font>
      a=a+b<font></font>
      a=b<font></font>
<span class="hljs-keyword">elif</span> ((b)&gt;=(a)):<font></font>
   a=b-a<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;=(b))<span class="hljs-keyword">and</span>((b//a)==(a))<span class="hljs-keyword">and</span>((b//a)!=(b)):<font></font>
      b=b-a<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((b//a)&lt;(b-a)):<font></font>
      a=b<font></font>
      a=b-a<font></font>
   <span class="hljs-keyword">else</span>:
      <span class="hljs-keyword">if</span> ((a)==(b)):<font></font>
         a=a<font></font>
         a=b//a<font></font>
         b=b<font></font>
         b=a+b<font></font>
         b=a<font></font>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die dritte Option implementiert die Rekursion von Anfang an (Option 3 in den Schemata), d. H. </font><font style="vertical-align: inherit;">ergibt einen Zweig der Form:</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)==(a)):
   <span class="hljs-keyword">if</span> ((a+b)&lt;(b)):</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
oder </font></font><pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&lt;=(a)):<font></font>
   a=a<font></font>
   <span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
      a=a<font></font>
      a=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst wird die if-Linie gebildet (ähnlich), dann erscheint eine Gabelung, die entscheidet, ob der Aktionsblock weiter eingefügt werden soll oder nicht, wonach der Versatz gespeichert und die Rekursion aufgerufen wird. Der Versatz muss gespeichert werden, damit nach Abschluss der Rekursion und Rückgabe des Codeteils ein weiterer elif-else-Block mit demselben Versatz wie in der ursprünglichen Zeile mit if hinzugefügt werden kann. Hier können Sie sehen, wie elif und sonst in der Branche im gleichen Versatz wie ihre "native" if stehen.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)==(b)):<font></font>
<font></font>
   <span class="hljs-keyword">if</span> ((a)&gt;(a+b)):
      <span class="hljs-keyword">if</span> ((b)==(b-a)):<font></font>
         b=b<font></font>
         a=a<font></font>
      <span class="hljs-keyword">elif</span> ((b)&gt;(b)):
         <span class="hljs-literal">None</span>
      <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span><font></font>
         b=a<font></font>
         b=b</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als nächstes kommt eine Verzweigung im elif-else-Block / Aktionsblock, die entscheidet, ob nach der Rekursion ein Aktionsblock oder ein elif-else-Block hinzugefügt werden soll. Wenn Sie sich entscheiden, einen elif-else-Block hinzuzufügen, wird dort, ähnlich wie oben in Schema 2, elif oder else ausgewählt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hierbei ist zu beachten, dass die Rekursion mit einem Offset von + 3 aufgerufen wird, um den generierten Code schrittweise nach rechts zu verschieben, und der elif-else-Block mit einem Offset von wall_offset aufgerufen wird, damit dieser Block nach der Rekursion nicht nach rechts geht, sondern beim „nativen“ Block bleibt. der Versatz des Originals wenn. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Ergebnisse können sehr unterschiedlich sein: von einfach bis komplex, aber das Auftreten von Rekursion erzeugt sofort die reich verziertesten Zweige.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b-a)&gt;(a+b))<span class="hljs-keyword">and</span>((b)&lt;(a+b)):
   <span class="hljs-keyword">if</span> ((b-a)&lt;=(a+b)):<font></font>
      b=b//a<font></font>
   <span class="hljs-keyword">elif</span> ((b)!=(a)):<font></font>
      a=b-a<font></font>
<span class="hljs-keyword">else</span>:
   <span class="hljs-keyword">if</span> ((a+b)!=(b-a)):<font></font>
      a=a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((b)&lt;(b-a)):
   <span class="hljs-keyword">if</span> ((a+b)==(b-a))<span class="hljs-keyword">and</span>((b-a)&lt;(a+b))<span class="hljs-keyword">and</span>((b-a)==(a))<span class="hljs-keyword">and</span>((a)&gt;(b//a))<span class="hljs-keyword">or</span>((a+b)&gt;(b//a)):
      <span class="hljs-keyword">if</span> ((b)&gt;=(b-a)):<font></font>
         a=b<font></font>
         b=b<font></font>
         <span class="hljs-keyword">if</span> ((b)&gt;(b)):<font></font>
            a=a+b<font></font>
            b=a+b<font></font>
            a=a<font></font>
            b=a+b<font></font>
            b=b//a<font></font>
            b=a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=a+b<font></font>
         a=b<font></font>
         a=b<font></font>
   <span class="hljs-keyword">elif</span> ((a)&lt;(b-a)):<font></font>
      a=b//a<font></font>
      a=b-a</code></pre><br>
<pre><code class="python hljs"><span class="hljs-keyword">if</span> ((a)&gt;=(b-a))<span class="hljs-keyword">or</span>((a)&gt;=(a))<span class="hljs-keyword">or</span>((b)&lt;=(b)):<font></font>
   a=a<font></font>
   a=a<font></font>
<span class="hljs-keyword">elif</span> ((a)==(a))<span class="hljs-keyword">and</span>((b)&gt;(b-a)):<font></font>
   a=b//a<font></font>
   <span class="hljs-keyword">if</span> ((a)&lt;(b)):
      <span class="hljs-keyword">if</span> ((a+b)==(b-a)):<font></font>
         a=a<font></font>
         <span class="hljs-keyword">if</span> ((a)!=(b//a)):
            <span class="hljs-keyword">if</span> ((b//a)!=(a))<span class="hljs-keyword">and</span>((b-a)&gt;=(b)):<font></font>
               a=b<font></font>
            <span class="hljs-keyword">else</span>:
               <span class="hljs-literal">None</span><font></font>
               a=b//a<font></font>
      <span class="hljs-keyword">else</span>:<font></font>
         b=b<font></font>
         b=a+b<font></font>
         <span class="hljs-keyword">if</span> ((b-a)&lt;=(b//a)):<font></font>
            a=b<font></font>
            a=b<font></font>
            a=a+b<font></font>
<span class="hljs-keyword">else</span>:<font></font>
   a=a+b<font></font>
   <span class="hljs-keyword">if</span> ((b-a)&gt;=(a)):<font></font>
      a=b<font></font>
      <span class="hljs-keyword">if</span> ((b-a)==(a))<span class="hljs-keyword">or</span>((b)!=(b//a)):<font></font>
         a=b-a<font></font>
         a=a<font></font>
         a=a<font></font>
         a=b//a<font></font>
         a=a+b<font></font>
         b=a</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns nun die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block an</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die für die Bildung des Blocks elif-else verantwortlich ist und von der Hauptfunktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen aufgerufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else_block</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list,  fin_else_flag, prob_list</span>):</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        sol3 = <span class="hljs-number">9</span>
        <span class="hljs-comment">#  </span><font></font>
        wall_offset = offset_koeff<font></font>
        <span class="hljs-comment">#  elif  </span>
        <span class="hljs-keyword">while</span> sol3!=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> fin_else_flag!=<span class="hljs-number">1</span>:<font></font>
            temp_str, offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'elif'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
            prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol3 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-comment">#  -   else   elif?</span>
        prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
        <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  else,   </span>
            fin_else_flag=<span class="hljs-number">1</span>
            temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, wall_offset, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
            if_str+=temp_str<font></font>
        <span class="hljs-keyword">return</span>(if_str,offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-comment">#  else</span>
    <span class="hljs-keyword">else</span>: <font></font>
          temp_str,offset_koeff, fin_else_flag, prob_list=elif_else(<span class="hljs-string">'else'</span>, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list)<font></font>
          if_str+=temp_str<font></font>
          <span class="hljs-keyword">return</span>(if_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Funktion entscheidet, ob dem Code ein elif- oder ein elif / else-Block hinzugefügt werden soll. Sie entscheidet nicht, ob sie einfach etwas anderes setzen soll, sondern hängt vom Eingabewert e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e_string ab</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , den sie von der Hauptfunktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> erhält </font><font style="vertical-align: inherit;">. Zuerst wird der elif-Block in der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">while-Schleife</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> generiert, in der </font><font style="vertical-align: inherit;">zwei Bedingungen überprüft werden: probabilistisch - Die Anzahl der elif im Block und das </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Flag </font><b><font style="vertical-align: inherit;">hängen davon ab</font></b><font style="vertical-align: inherit;"> . Wenn es plötzlich eingeschaltet wird, bedeutet dies, dass zuvor eine Verbindung hergestellt wurde, und daher müssen Sie die Schleife verlassen . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entscheidung, ob else und else an den elif-Block angehängt werden soll, wird von einer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verzweigung</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit derselben Funktion </font><b><font style="vertical-align: inherit;">make_solution getroffen.</font></b><font style="vertical-align: inherit;"> Wenn else angehängt wird, wird das Flag </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fin_else_flag sofort aktiviert</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies stoppt die Blockerzeugung. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das direkte Zusammenfügen von elif und else erfolgt über die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (siehe unten). Hierbei ist zu beachten, dass beim Generieren des elif-Blocks (und auch beim Anhängen eines anderen) der Offset </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wall_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet wird, um den Block als Ganzes reibungslos zu erstellen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten Sie nun die Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="python hljs">&lt;b&gt;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">elif_else</span>(<span class="hljs-params">ee_string, offset_koeff, exp_list, var_list, sign, if_str, choice_list, fin_else_flag, prob_list</span>):</span>
    ee_str = <span class="hljs-string">''</span>
    <span class="hljs-comment">#   else:  elif [..]:</span>
    <span class="hljs-keyword">if</span> ee_string==<span class="hljs-string">'else'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string + <span class="hljs-string">':\n'</span>
    <span class="hljs-keyword">elif</span> ee_string==<span class="hljs-string">'elif'</span>:<font></font>
        ee_str += <span class="hljs-string">' '</span>*offset_koeff+ee_string+<span class="hljs-string">' '</span>+if_sub(exp_list, var_list, sign, prob_list) + <span class="hljs-string">':\n'</span>
    <span class="hljs-comment">#   -None /  +</span>
    prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>],sol = make_solution(prob_list[<span class="hljs-number">2</span>],prob_list[<span class="hljs-number">3</span>])
    <span class="hljs-keyword">if</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2!=<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># None</span>
            ee_str+=<span class="hljs-string">' '</span>*(offset_koeff+<span class="hljs-number">3</span>)+<span class="hljs-string">'None\n'</span>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment">#   </span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2==<span class="hljs-number">0</span>:
            <span class="hljs-comment">#  </span>
            ee_str+=action_str_gen(choice_list,offset_koeff+<span class="hljs-number">3</span>, prob_list)
        <span class="hljs-comment">#  if_gen</span>
        if_str, offset_koeff,  fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, offset_koeff+<span class="hljs-number">3</span>, fin_else_flag, prob_list)                 <font></font>
        ee_str+=if_str<font></font>
        <span class="hljs-keyword">return</span>(ee_str, offset_koeff, fin_else_flag, prob_list)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion ist verantwortlich für die Bildung der elif- oder sonst-Linie selbst sowie für die nachfolgende Erzeugung von Aktions- oder Rekursionsblöcken nach diesen Linien. Es nimmt auch eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ee_string-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Variable </font><font style="vertical-align: inherit;">, die entweder elif oder else enthält, und bildet die entsprechende Zeichenfolge. Dann gibt es eine Gabelung, in der festgelegt wird, was als nächstes passieren soll: (Aktionsblock oder Keine) oder (Aktionsblock oder Aktionsblock + Rekursion). Innerhalb dieser Gabel gibt es jeweils eine Unterteilung in zwei </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untergabeln</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , und in jedem Fall wird die Funktion </font><b><font style="vertical-align: inherit;">make_solution</font></b><font style="vertical-align: inherit;"> mit den entsprechenden Parametern </font><b><font style="vertical-align: inherit;">aufgerufen</font></b><font style="vertical-align: inherit;"> , um eine Entscheidung zu treffen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sollte beachtet werden, dass, wenn es im Code auftritt</font></font><code>if sol!=0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dies bedeutet, dass wir einem Teil des Codes absichtlich einen Vorteil gegenüber einem anderen geben, denn wenn sol! = 0 ist, ist er entweder -1 oder 1, und daher wird ein anderer Code weniger häufig ausgeführt (nur wenn sol == 0). Dies wird insbesondere in der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else_block</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">, in der es für uns rentabler ist, mehr </font><b><font style="vertical-align: inherit;">Elifen</font></b><font style="vertical-align: inherit;"> im Block bilden zu lassen, als elif und anderen die gleiche Wahrscheinlichkeit zu geben. Oder zum Beispiel </font><font style="vertical-align: inherit;">geben wir </font><font style="vertical-align: inherit;">in der Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elif_else</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Option einen Vorteil, wenn ein Aktionsblock oder None gebildet wird, anstatt dem, wofür die Rekursion vorgesehen ist - andernfalls können die Zweige zu sehr unanständigen Größen wachsen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir müssen nur die Funktionen berücksichtigen, die für die zufällige Erzeugung von Ausdrücken in Bedingungen und Aktionsblöcken verantwortlich sind. Wie ich oben sagte, spielen sie zu diesem Zeitpunkt keine entscheidende Rolle und werden hier vorgestellt, um allgemein zu zeigen, wie der endgültig generierte Code aussehen wird. Da sie jedoch im Generator verwendet werden, werden wir sie kurz betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion, die für die Generierung des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aktionsblocks action_str</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verantwortlich ist </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action_str_gen</span>(<span class="hljs-params">choice_list, offset_koeff, prob_list</span>):</span>
    sol = <span class="hljs-number">9</span>
    curr_offset = <span class="hljs-string">' '</span>*offset_koeff<font></font>
    act_str = <span class="hljs-string">''</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        act_str+= curr_offset+rand(rand(choice_list[<span class="hljs-number">1</span>]))+<span class="hljs-string">'='</span>+rand(rand(choice_list))+<span class="hljs-string">'\n'</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
    <span class="hljs-keyword">return</span>(act_str)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist alles ganz einfach: Aus der verschachtelten Liste choise_list, die, wie wir uns erinnern, aus v </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ar_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Liste der Variablen) und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exp_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Liste der Ausdrücke) besteht, besteht diese Funktion aus einer oder mehreren Zeilen dieser Form: a = a + b oder b = b . </font><font style="vertical-align: inherit;">Jene. </font><font style="vertical-align: inherit;">Der Variablen wird entweder ein Ausdruck zugewiesen oder eine andere Variable (einschließlich sich selbst). </font><font style="vertical-align: inherit;">Die Rand-Funktion wählt zufällig ein Element aus der Liste aus und wird hier nur benötigt, um keine monströsen Strings zu erzeugen.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rand</span>(<span class="hljs-params">t_list</span>):</span>
    <span class="hljs-keyword">return</span>(t_list[random.randint(<span class="hljs-number">0</span>,len(t_list)<span class="hljs-number">-1</span>)])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Funktion </font><font style="vertical-align: inherit;">zur </font><font style="vertical-align: inherit;">Erzeugung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ausdrücken </font><font style="vertical-align: inherit;">für Bedingungen sieht größer aus.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">if_sub</span>(<span class="hljs-params">exp_list, var_list, sign, prob_list</span>):</span>
    sub_str = <span class="hljs-string">''</span>
    sol = <span class="hljs-number">9</span><font></font>
    choice_list = [exp_list, var_list]<font></font>
    flag = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> sol!=<span class="hljs-number">0</span>:<font></font>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])<font></font>
        sub_str+=<span class="hljs-string">'(('</span>+rand(rand(choice_list))+<span class="hljs-string">')'</span>+rand(sign2)+<span class="hljs-string">'('</span>+rand(rand(choice_list))+<span class="hljs-string">'))'</span>
        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> sol==<span class="hljs-number">1</span>:<font></font>
            sub_str+=<span class="hljs-string">')'</span>
            flag=<span class="hljs-number">0</span><font></font>
        or_and_exp = or_and(prob_list)<font></font>
        <span class="hljs-keyword">if</span> len(or_and_exp):<font></font>
            sub_str+=or_and_exp<font></font>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
        prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>],sol2 = make_solution(prob_list[<span class="hljs-number">6</span>],prob_list[<span class="hljs-number">7</span>])
        <span class="hljs-keyword">if</span> sol2 == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'D'</span> <span class="hljs-keyword">or</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'R'</span>) <span class="hljs-keyword">and</span> flag == <span class="hljs-number">0</span>:<font></font>
            sub_str+=<span class="hljs-string">'('</span>
            flag = <span class="hljs-number">1</span><font></font>
    <font></font>
    <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-1</span>] == <span class="hljs-string">'('</span>:
        <span class="hljs-keyword">if</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'d'</span>:<font></font>
           sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-4</span>]
        <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-2</span>]==<span class="hljs-string">'r'</span>:<font></font>
             sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
        <span class="hljs-keyword">else</span>:<font></font>
            sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-1</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'d'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-3</span>]
    <span class="hljs-keyword">elif</span> sub_str[<span class="hljs-number">-1</span>]==<span class="hljs-string">'r'</span>:<font></font>
         sub_str=sub_str[<span class="hljs-number">0</span>:<span class="hljs-number">-2</span>]
    <span class="hljs-keyword">else</span>:
         <span class="hljs-literal">None</span>
    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<font></font>
        sub_str+=<span class="hljs-string">')'</span>
        <span class="hljs-keyword">return</span>(sub_str)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(sub_str)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden Ausdrücke nach Typ generiert: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">((a)&gt; = (ba)) oder ((a)&gt; = (a)) oder ((b) &lt;= (b))</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gleichzeitig können sowohl die linke als auch die rechte Seite verschiedene Optionen haben und als separate Variablen sowie als Ausdrücke oder deren Gruppen stehen. </font><font style="vertical-align: inherit;">Hier werden auch die logischen Operatoren </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oder</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verwendet </font><font style="vertical-align: inherit;">, die der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfachheit halber</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit der Funktion </font><b><font style="vertical-align: inherit;">or_and_exp ausgewählt</font></b><font style="vertical-align: inherit;"> werden </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">or_and</span>(<span class="hljs-params">prob_list</span>):</span>
    prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>],sol = make_solution(prob_list[<span class="hljs-number">8</span>],prob_list[<span class="hljs-number">9</span>])
    <span class="hljs-keyword">if</span> sol==<span class="hljs-number">-1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'and'</span>)
    <span class="hljs-keyword">elif</span> sol==<span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">'or'</span>)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span>(<span class="hljs-string">''</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Rest der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_sub-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">schneidet die zusätzlichen Schwänze aus den Ausdrücken ab und fügt bei Bedarf schließende Klammern hinzu, um diese Tänze mit Tamburinen hier zu betrachten, was meiner Meinung nach nicht zweckmäßig ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, das ist alles. </font><font style="vertical-align: inherit;">Sie können den Generator beispielsweise folgendermaßen starten:</font></font><br>
<br>
<pre><code class="python hljs">var_list = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>]<font></font>
exp_list = [<span class="hljs-string">'a+b'</span>,<span class="hljs-string">'b-a'</span>, <span class="hljs-string">'b//a'</span>]<font></font>
sign = [<span class="hljs-string">'+'</span>,<span class="hljs-string">'-'</span>,<span class="hljs-string">'/'</span>,<span class="hljs-string">'*'</span>,<span class="hljs-string">'//'</span>]<font></font>
sign2 = [<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'&lt;'</span>,<span class="hljs-string">'=='</span>,<span class="hljs-string">'&gt;='</span>,<span class="hljs-string">'&lt;='</span>,<span class="hljs-string">'!='</span>]<font></font>
a = <span class="hljs-number">3</span>
b = <span class="hljs-number">2</span>       
prob_list = [<span class="hljs-number">0.5</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>)]      
<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<font></font>
     if_str = <span class="hljs-string">''</span>
     if_str, offset_koeff, fin_else_flag, prob_list = if_gen(exp_list, var_list, if_str, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>, prob_list)
     <span class="hljs-keyword">try</span>:<font></font>
         exec(compile(if_str,<span class="hljs-string">'gen'</span>,<span class="hljs-string">'exec'</span>))<font></font>
         print(if_str)<font></font>
         input()<font></font>
         <font></font>
     <span class="hljs-keyword">except</span> ZeroDivisionError:
         <span class="hljs-literal">None</span>
     <span class="hljs-keyword">except</span>:<font></font>
         print(<span class="hljs-string">'error'</span>)<font></font>
         print(if_str)<font></font>
         input()</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst die Eingabe, einschließlich einer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prob_list</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit Wahrscheinlichkeiten </font><font style="vertical-align: inherit;">, dann in einer Endlosschleife, wobei die Hauptfunktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if_gen aufgerufen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und die generierte generierte Zeichenfolge zur Ausführung </font><b><font style="vertical-align: inherit;">gestartet wird</font></b><font style="vertical-align: inherit;"> . Es lohnt sich, ZeroDivisionError separat zu verarbeiten, weil Eine Division durch Null mit einer solchen zufälligen Konstruktion von Ausdrücken ist sehr häufig. Drücken Sie nach dem Start einfach die Eingabetaste, damit die nächste Generation angezeigt wird. Meistens sind sie recht einfach, aber oft verzweigt und sogar sehr verzweigt. Nun, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zufälliger Import</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> am Anfang wäre auch schön einzufügen;) Für diejenigen, die nicht alles von Hand sammeln wollen, können Sie die Datei von </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> herunterladen </font><font style="vertical-align: inherit;">(Datei if_gen.py).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abschließend möchte ich sagen, dass der von mir präsentierte Code an Hunderttausenden von Generationen ohne Fehler getestet wurde, während er die gesamte Palette von If-Elif-else-Schemata demonstrierte, die ich endlich sehen wollte. Einmal habe ich versehentlich in einem Teil des Codes eine zu hohe Rekursionswahrscheinlichkeit angegeben und 52.000 (!) Generierungszeilen erhalten, die gleichzeitig funktionierten (obwohl die Komposition 30 Sekunden lang angehalten wurde). Dies zeigt auch die Zuverlässigkeit des Algorithmus an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wahrscheinlich war es möglich, irgendwo prägnanter zu schreiben, irgendwo zu optimieren, die Hauptfunktion auf andere Weise anzuordnen, aber die Hauptsache ist, dass dieser Code funktioniert und ungefähr 250 Generationen pro Sekunde erzeugt, was meiner Meinung nach durchaus akzeptabel ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe diesen Code nie als autark angesehen - er ist nur ein Modul des zukünftigen digitalen Organismus und wurde zu Forschungszwecken geschrieben, sodass er kaum praktische Anwendungen hat. </font><font style="vertical-align: inherit;">Gleichzeitig bin ich nicht verantwortlich für Konsequenzen für jemanden, der den obigen Code verwendet, und ich fordere jeden auf, Brot mit einem Messer zum Schneiden von Brot zu schneiden und nicht etwas anderes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im nächsten Artikel werden wir das zweite Modul betrachten, das für die zufällige Bildung von Erfahrungen verantwortlich sein wird. </font><font style="vertical-align: inherit;">Dieses Thema verspricht viel interessanter zu sein als der if-Generator, und ich werde die Ergebnisse definitiv veröffentlichen, sobald ich sie habe.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de504270/index.html">Ist Svelte eine gute Wahl für die Widget-Implementierung?</a></li>
<li><a href="../de504276/index.html">Top 10 Entwicklerbücher</a></li>
<li><a href="../de504282/index.html">Erstellung der Enterprise-Architektur in NSPK</a></li>
<li><a href="../de504284/index.html">Das Buch „Pure Agile. Die Grundlagen der Flexibilität</a></li>
<li><a href="../de504290/index.html">Lasttests als CI-Service für Entwickler</a></li>
<li><a href="../de504306/index.html">Wie wird russische Hardware für die Speicherung von Aerodisk Vostok auf Elbrus hergestellt?</a></li>
<li><a href="../de504310/index.html">Dichotomie von Daten: Überdenken der Beziehung zu Daten und Diensten</a></li>
<li><a href="../de504312/index.html">Einheitliches Register der russischen Programme und der GPL. Meine fünf Cent</a></li>
<li><a href="../de504314/index.html">Implementierung von Docker Pull- und Docker Push-Befehlen ohne Docker-Client über HTTP-Anforderungen</a></li>
<li><a href="../de504320/index.html">Einzeiliger Code oder Nethermind-Validierung mit PVS-Studio C # für Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>