<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöñ üõÇ „äóÔ∏è Fen√™tres multicolores: constructeur virtuel, CRTP et mod√®les complexes üàÇÔ∏è üì† ‚è©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Depuis un certain temps, un mod√®le de conception non trivial est connu lorsqu'une classe d√©riv√©e est pass√©e dans le param√®tre de base:
 

template<cla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Fen√™tres multicolores: constructeur virtuel, CRTP et mod√®les complexes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/507146/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depuis un certain temps, un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mod√®le de conception non trivial est</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connu </font><font style="vertical-align: inherit;">lorsqu'une classe d√©riv√©e est pass√©e dans le param√®tre de base:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">Base</span>
{</span><font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> :</span> <span class="hljs-keyword">public</span> Base&lt;Derived&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce mod√®le a son propre nom - CRTP: mod√®le de mod√®le curieusement r√©current, qui se traduit par ¬´mod√®le r√©p√©titif √©trangement¬ª. J'ai ajout√© encore plus de bizarreries √† cette construction d√©j√† √©trange: je l'ai g√©n√©ralis√©e √† toute une cha√Æne d'h√©ritages. Oui, cela peut vraiment √™tre fait, mais pour cela, vous devez </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donner √† l'√¢me</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> un prix √©lev√©. Pour savoir comment je l'ai fait et quel prix je dois payer, je vous invite √† lire cet article pour plus de d√©tails.</font></font><a name="habracut"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici, nous traiterons </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de perversions terribles par</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diverses m√©thodes √©tranges et d'autres mauvaises choses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux vous avertir tout de suite: ne prenez pas le mat√©riel d√©crit ici comme quelque chose de s√©rieux. Je suis s√ªr que dans 95 √† 99% des cas, tout cela ne vous sera jamais utile dans la pratique. C'est une sorte de maths divertissant, une s√©ance d'entra√Ænement pour l'esprit. En pratique, il est peu probable qu'il soit utile, mais il est int√©ressant d'y consacrer du temps. Ce n'est que dans ce cas que le langage C ++ et ses capacit√©s agissent comme des math√©matiques. Je vous pr√©viens √† l'avance, car Si vous cherchez quelque chose de s√©rieux et orient√© vers la pratique ici, vous pourriez √™tre d√©√ßu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Syntonisez imm√©diatement l'exotisme, comme si vous vous trouviez soudainement dans un pays o√π deux lunes, trois soleils, les feuilles des plantes sont bleues ou lilas, et en effet beaucoup de choses habituelles sont un peu ... √©tranges et inhabituelles ... Si vous √™tes embourb√© dans la vie quotidienne grise et il n'y a pas longtemps lire quelque chose comme √ßa, puis vous √™tes venu √† l'adresse ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fen√™tres multicolores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'√©tait il y a longtemps. </font><font style="vertical-align: inherit;">Il y a presque trois ans. </font><font style="vertical-align: inherit;">Je me suis ensuite </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assis sur de l'herbe lourde et</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> j'ai </font><font style="vertical-align: inherit;">seulement compris la </font><font style="vertical-align: inherit;">base </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zen</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du C ++ 11/14 du livre Meyers S. - "C ++ efficace et moderne". </font><font style="vertical-align: inherit;">Il mentionne √©galement ce mod√®le. </font><font style="vertical-align: inherit;">Apr√®s cela, comme je sentais que j'avais </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atteint l'illumination, je</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ma√Ætrisais les bases de la nouvelle norme et </font><s><font style="vertical-align: inherit;">j'√©tais</font></s><font style="vertical-align: inherit;"> pr√™t √† regarder les vieilles choses d'une nouvelle fa√ßon, j'ai commenc√© √† rafra√Æchir un livre sur l'API Windows dans ma m√©moire: Shchupak Yu. - ¬´API Win32. </font><font style="vertical-align: inherit;">D√©veloppement d'application efficace. ‚Äù </font><font style="vertical-align: inherit;">Au tout d√©but, il d√©crit un programme minimal en langage C pour cr√©er et afficher une fen√™tre:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><font></font>
<font></font>
HWND hMainWnd;<font></font>
TCHAR szClassName[] = TEXT(<span class="hljs-string">"MyClass"</span>);<font></font>
MSG msg;<font></font>
WNDCLASSEX *wc;<font></font>
<font></font>
<span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{<font></font>
	HDC hDC;<font></font>
	PAINTSTRUCT ps;<font></font>
	RECT rect;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span>(uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		SetClassLongPtr(hWnd, <span class="hljs-number">-10</span>, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"Hello, world!"</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		DestroyWindow(hWnd);<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		PostQuitMessage(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <span class="hljs-keyword">int</span> nCmdShow)</span>
</span>{	
	<span class="hljs-keyword">if</span>(!(wc = <span class="hljs-keyword">new</span> WNDCLASSEX))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"  !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	wc-&gt;cbSize = <span class="hljs-keyword">sizeof</span>(WNDCLASSEX);<font></font>
	wc-&gt;style = CS_HREDRAW | CS_VREDRAW;<font></font>
	wc-&gt;lpfnWndProc = WndProc;<font></font>
	wc-&gt;cbClsExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;cbWndExtra = <span class="hljs-number">0</span>;<font></font>
	wc-&gt;hInstance = hInstance;<font></font>
	wc-&gt;hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
	wc-&gt;hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<font></font>
	wc-&gt;hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<font></font>
	wc-&gt;lpszMenuName = <span class="hljs-literal">NULL</span>;<font></font>
	wc-&gt;lpszClassName = szClassName;<font></font>
	wc-&gt;hIconSm = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	<span class="hljs-keyword">if</span>(!RegisterClassEx(wc))<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"     !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">delete</span> wc;<font></font>
<font></font>
	<span class="hljs-comment">//  </span>
	hMainWnd = CreateWindow(szClassName, TEXT(<span class="hljs-string">"A Hello1 Application"</span>), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, <span class="hljs-number">0</span>, CW_USEDEFAULT, <span class="hljs-number">0</span>, (HWND)<span class="hljs-literal">NULL</span>, (HMENU)<span class="hljs-literal">NULL</span>, (HINSTANCE)hInstance, <span class="hljs-literal">NULL</span>);<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(!hMainWnd)<font></font>
	{<font></font>
		MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">"   !"</span>), TEXT(<span class="hljs-string">""</span>), MB_OK | MB_ICONERROR);
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//  </span><font></font>
	ShowWindow(hMainWnd, nCmdShow);<font></font>
	<span class="hljs-comment">//UpdateWindow(hMainWnd);</span><font></font>
<font></font>
	<span class="hljs-comment">//      </span>
	<span class="hljs-keyword">while</span>(GetMessage(&amp;msg, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<font></font>
	{<font></font>
		TranslateMessage(&amp;msg);<font></font>
		DispatchMessage(&amp;msg);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">//MessageBox(NULL, TEXT("Application is going to quit."), TEXT("Exit"), MB_OK);</span>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je l'ai d√©j√† fait plusieurs fois, affichant diff√©rentes fen√™tres sur le mod√®le de ce livre. </font><font style="vertical-align: inherit;">Et soudain, j'ai pens√©: je viens de lire sur C ++ hier! </font><font style="vertical-align: inherit;">Je peux √©crire ma propre classe pour afficher cette fen√™tre! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä peine dit que c'√©tait fait:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;					<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;	<span class="hljs-comment">// WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La structure de la classe est triviale: plusieurs constructeurs sont d√©clar√©s (avec le transfert des param√®tres principaux et des liens vers la structure WNDCLASSEX plus d√©taill√©e), la fonction CreateWnd de l'enregistrement de classe de fen√™tre et de la cr√©ation de fen√™tre elle-m√™me, appel√©e depuis les constructeurs, ainsi qu'un ensemble de fonctions membres virtuelles qui effectuent des actions traiter chacun des messages Windows dans la proc√©dure de rappel de fen√™tre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les membres des donn√©es de classe sont √©galement minimes: window handle hWnd; Structure WNDCLASSEX utilis√©e pour cr√©er la classe; et la barre de titre de la fen√™tre.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La proc√©dure de rappel de fen√™tre est d√©clar√©e comme statique afin d'√©viter de passer implicitement le pointeur this √† l'objet classe et donc de violer l'accord sur le type (signature) de la fonction de la proc√©dure fen√™tre accept√©e dans Windows (rappelez-vous que nous n'appellerons pas cette fonction nous-m√™mes, mais Windows, car les param√®tres et le type de retour de cette fonction sont strictement sp√©cifi√©s).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proc√©dure de fen√™tre et ce pointeur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est connu de C ++: si une fonction membre est d√©finie comme statique, un pointeur vers un objet de classe doit lui √™tre transmis explicitement. Cependant, nous ne pouvons pas passer un pointeur vers un objet de classe vers une proc√©dure de fen√™tre statique, car le format de cette fonction ne permet pas ce transfert. √Ä cet √©gard, un probl√®me fondamental se pose: s'il existe plusieurs objets de la classe WindowClass, alors comment une proc√©dure de fen√™tre statique unique sait-elle quel objet de classe particulier a re√ßu un message? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a qu'une seule issue: vous devez √©tablir cette connexion d'une mani√®re ou d'une autre.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows identifie une fen√™tre par son handle HWND hWnd. L'objet classe correspondant √† cette fen√™tre peut √™tre identifi√© par un pointeur sur cet objet. Par cons√©quent, il est n√©cessaire d'√©tablir le pointeur de connexion hWnd &lt;-&gt; vers l'objet WindowClass. Par exemple, une proc√©dure de fen√™tre, √©tant en m√™me temps membre d'une classe, pourrait avoir un lien ou un pointeur vers une structure de donn√©es √©galement statique qui √©tablit une connexion entre hWnd et un pointeur vers un objet pour chaque fen√™tre et est mis √† jour chaque fois qu'un objet de la classe est cr√©√©. La structure de donn√©es doit √™tre statique afin que, d'une part, elle soit accessible √† partir d'une proc√©dure de fen√™tre statique sans pointeur vers un objet de classe, et d'autre part, qu'elle soit unique √† tous les objets de la classe (ce qui d√©coule logiquement de son objectif). ), et troisi√®mement,afin qu'il soit toujours li√© √† une classe avec le niveau d'acc√®s appropri√©, et non √† une variable globale externe.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, apr√®s avoir compris comment d√©crire cette structure et pourquoi elle est n√©cessaire, il reste √† savoir quelle devrait √™tre cette structure. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deux tableaux dynamiques peuvent √™tre d√©clar√©s: un pour les poign√©es de fen√™tre HWND et le second pour les pointeurs vers les objets WindowClass. Cependant, ce n'est pas la meilleure solution: il n'est pas clair comment choisir la taille du tableau, quels seront les sc√©narios d'utilisation de Windows, si les tableaux se r√©v√©leront presque vides si leur taille n'est pas s√©lectionn√©e correctement, ce qui entra√Ænera un d√©passement de m√©moire. Ou, au contraire, lorsque lors de la cr√©ation de fen√™tres leur volume est √©puis√©, il faudra augmenter leur taille, etc. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une meilleure solution (et m√™me je dirais - id√©ale) dans cette situation est une liste ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liste!</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Une liste est une structure de donn√©es dynamique constitu√©e d'un ensemble de n≈ìuds connect√©s par paires. Chaque n≈ìud (dans le cas d'une liste doublement li√©e) a des pointeurs vers les n≈ìuds pr√©c√©dent et suivant de la liste, ainsi que des donn√©es stock√©es suppl√©mentaires. Dans notre situation, chaque n≈ìud de fen√™tre correspond √† chacune des fen√™tres, et les donn√©es utiles sont un descripteur de fen√™tre et un pointeur sur un objet de la classe WindowClass. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, chaque fois qu'une nouvelle fen√™tre est cr√©√©e, un nouveau n≈ìud de liste est cr√©√© et ajout√© √† sa fin (devient le dernier). Lors de la fermeture, le n≈ìud est supprim√© et les pointeurs des n≈ìuds pr√©c√©dent et suivant sont ajust√©s les uns aux autres pour remplacer le n≈ìud distant. En m√™me temps, il n'y a pas de d√©passement de m√©moire - exactement autant de n≈ìuds sont cr√©√©s qu'il y a de fen√™tres cr√©√©es, et ils sont √©galement supprim√©s en m√™me temps que la fen√™tre est ferm√©e.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, un nouveau membre statique doit √©galement √™tre ajout√© √† la classe WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">static</span> List wndList;	<span class="hljs-comment">// ,    </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
et le d√©clarer privil√©gi√© pour lui permettre d'acc√©der aux membres de WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">friend</span> List;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Je ne donnerai pas ici maintenant une d√©finition de la classe list et de la classe node, leurs fonctions, car cela ne s'applique pas directement √† la classe WindowClass, et la logique d'impl√©mentation de cette classe est connue et assez triviale.) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la proc√©dure window lorsqu'un nouveau message arrive au cas o√π il arriverait appartient au nombre qu'il traite, selon le descripteur de fen√™tre hWnd qui lui est transmis par Windows, il acc√®de √† la liste, y recherche un n≈ìud selon le hWnd sp√©cifi√© et, le trouvant, obtient le pointeur requis vers un objet de la classe WindowClass. Puis, par pointeur, il appelle une fonction virtuelle correspondant au message en cours de traitement: pour une classe surcharg√©e, une fonction virtuelle du m√™me nom peut effectuer d'autres actions.</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowClass::WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span>
</span>{
	<span class="hljs-comment">// 	</span>
	ListElement * pListElem = <span class="hljs-literal">nullptr</span>;<font></font>
<font></font>
	<span class="hljs-keyword">switch</span> (uMsg)<font></font>
	{<font></font>
	<span class="hljs-keyword">case</span> WM_CREATE:<font></font>
		{<font></font>
			<span class="hljs-comment">//lParam      CREATESTRUCT,         WindowClass,  </span>
			<span class="hljs-comment">// (.  WindowClass::CreateWnd)</span>
			CREATESTRUCT *cs = <span class="hljs-keyword">reinterpret_cast</span>&lt;CREATESTRUCT *&gt;(lParam);<font></font>
			WindowClass *p_wndClass = <span class="hljs-keyword">reinterpret_cast</span>&lt;WindowClass *&gt;(cs-&gt;lpCreateParams);<font></font>
			p_wndClass-&gt;hWnd = hWnd;		<span class="hljs-comment">// hWnd   ,    </span>
			<span class="hljs-comment">//    </span><font></font>
			pListElem = wndList.add(p_wndClass);<font></font>
			<span class="hljs-keyword">if</span> (pListElem)<font></font>
				pListElem-&gt;p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//  ,   </span><font></font>
		}<font></font>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_PAINT:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)	<font></font>
			pListElem-&gt;p_wndClass-&gt;OnPaint(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_CLOSE:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnClose(hWnd);	<span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">case</span> WM_DESTROY:<font></font>
		pListElem = wndList.search(hWnd);	<span class="hljs-comment">//        </span>
		<span class="hljs-keyword">if</span> (pListElem)<font></font>
			pListElem-&gt;p_wndClass-&gt;OnDestroy(hWnd);  <span class="hljs-comment">//  ,   </span>
		<span class="hljs-keyword">break</span>;
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);<font></font>
	}<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il y a un point subtil ici. Il s'agit de l'initialisation de la classe et du traitement du message WM_CREATE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la cr√©ation d'une fen√™tre avec la fonction CreateWindow, au moment de son appel, le handle de fen√™tre hWnd n'est pas encore connu: la fen√™tre n'a pas encore √©t√© cr√©√©e! Par cons√©quent, pour pouvoir appeler OnCreate virtuel, vous devez conna√Ætre le pointeur sur l'objet classe. Pour ce faire, il est assez risqu√© de passer le pointeur this de la fonction WindowClass :: CreateWnd √† la fonction CreateWindow via le pointeur lParam. Lors du traitement de WM_CREATE, la proc√©dure de fen√™tre re√ßoit ce pointeur du param√®tre, avec son aide initialise le membre hWnd √† l'int√©rieur de l'objet, puis cr√©e un nouveau n≈ìud de liste pour cette fen√™tre √† l'aide du pointeur vers l'objet de classe. Il appelle ensuite OnCreate virtuel par pointeur.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour les messages restants, la logique d√©crite ci-dessus est ex√©cut√©e: recherchez le n≈ìud de liste par le handle de fen√™tre actuel hWnd transf√©r√© de Windows, puis appelez la fonction virtuelle souhait√©e par le pointeur vers l'objet classe √† partir du n≈ìud de liste. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s avoir compil√© le programme et m'√™tre assur√© que tout fonctionne correctement, moi, en me frottant les mains </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au sentiment de ma propre grandeur</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du travail accompli, </font><s><font style="vertical-align: inherit;">j'ai</font></s><font style="vertical-align: inherit;"> commenc√© √† lire plus loin. </font><font style="vertical-align: inherit;">Et l√†, sur la page suivante, la fonction de modification des propri√©t√©s de la fen√™tre est indiqu√©e:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">DWORD <span class="hljs-title">SetClassLong</span><span class="hljs-params">(HWND hWnd, <span class="hljs-keyword">int</span> nIndex, LONG dwNewLong)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai imm√©diatement d√©cid√© sur place de cr√©er une nouvelle fen√™tre bas√©e sur l'ancienne:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass		<span class="hljs-comment">//         </span><font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe d√©riv√©e diff√®re de la classe de base par l'ajout d'un compteur de fen√™tre statique, ainsi que la modification de OnCreate, OnPaint et OnDestroy: la fonction OnCreate change la couleur d'arri√®re-plan de la fen√™tre, OnPaint affiche un message diff√©rent et OnDestroy diminue le compteur de fen√™tre statique. </font><font style="vertical-align: inherit;">Tout est tr√®s simple et clair. </font><font style="vertical-align: inherit;">Assembl√© et lanc√©. </font><font style="vertical-align: inherit;">Le texte du message est devenu diff√©rent ... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... mais la couleur de la fen√™tre n'a pas chang√©.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Constructeur virtuel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai alors r√©alis√© que j'avais d√©j√† mis les pieds sur de la glace mince. </font><font style="vertical-align: inherit;">Toutes les nuances ne sont pas d√©crites dans le mat√©riel de base des livres principaux. </font><font style="vertical-align: inherit;">L'un d'eux est un constructeur virtuel. </font><font style="vertical-align: inherit;">J'ai pens√© que l'appel de la fonction virtuelle de la classe d√©riv√©e √† partir du constructeur est exactement le m√™me que partout ailleurs dans le programme. </font><font style="vertical-align: inherit;">Il s'est av√©r√© que cela ne pouvait pas √™tre fait.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le probl√®me est que la fonction virtuelle qui est appel√©e √† partir du constructeur est appel√©e comme non virtuelle: seul l'objet de classe de base est cr√©√©, puis pas jusqu'√† la fin, et l'objet d√©riv√© n'a pas encore √©t√© cr√©√©, et la table des fonctions virtuelles n'a pas √©t√© g√©n√©r√©e. Dans notre cas, nous obtenons la cha√Æne: constructeur d√©riv√© -&gt; constructeur de base -&gt; CreateWnd -&gt; CreateWindow -&gt; proc√©dure de fen√™tre -&gt; OnCreate, c'est-√†-dire que OnCreate est en fait appel√© √† partir du constructeur. L'objet d√©riv√© n'a pas encore √©t√© cr√©√©, par cons√©quent, OnCreate est appel√© pour la classe de base! Il s'av√®re que sa red√©finition dans le d√©riv√© n'a pas de sens! Que faire?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est connu de C ++ que toute fonction remplac√©e peut √™tre appel√©e par son nom complet: nom_classe :: nom_fonction. Un nom de classe n'est pas seulement un nom: il s'identifie, en fait, le type d'objet. Il est √©galement connu du C ++ qu'une classe (et une fonction) peut √™tre cr√©√©e en tant que mod√®le (mod√®le) en lui passant son type comme param√®tre. Par cons√©quent, si vous cr√©ez le mod√®le de fonction de proc√©dure de fen√™tre et lui passez le type de la classe d√©riv√©e d'une certaine mani√®re, vous pouvez appeler la fonction remplac√©e souhait√©e directement dans le constructeur de la </font><font style="vertical-align: inherit;">classe de </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arr√™te arr√™te arr√™te !!! Vous ne pouvez pas faire de m√™me !!! Une classe d√©riv√©e n'a pas encore √©t√© cr√©√©e, ses donn√©es n'ont pas √©t√© initialis√©es: quelles fonctions allez-vous appeler ici? </font></font><br>
<s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si vous ne le pouvez pas, mais que vous le voulez vraiment, alors vous le pouvez.</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bien s√ªr, je ne visais pas un appel complet √† la classe d√©riv√©e. </font><font style="vertical-align: inherit;">Je voulais appeler une </font><font style="vertical-align: inherit;">fonction WinAPI </font><font style="vertical-align: inherit;">enti√®rement </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tierce</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui n'a rien √† voir avec la classe. </font><font style="vertical-align: inherit;">"Mais cela peut √™tre fait de mani√®res compl√®tement diff√©rentes, et beaucoup plus facile!" </font><font style="vertical-align: inherit;">- vous dites. </font><font style="vertical-align: inherit;">Oui. </font><font style="vertical-align: inherit;">Pouvez. </font><font style="vertical-align: inherit;">Et j'√©crirai √† ce sujet √† la fin de l'article. </font><font style="vertical-align: inherit;">Mais √† ce moment-l√†, j'ai mis tout cela de c√¥t√© et je me suis concentr√© sur le c√¥t√© purement technique de la question: mais est-il encore possible, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en principe,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d'appeler quelque chose de la d√©riv√©e dans le constructeur de la classe de base? </font><font style="vertical-align: inherit;">C'√©tait un int√©r√™t purement sportif, si vous voulez. </font><font style="vertical-align: inherit;">Je n'ai pens√© √† aucun aspect pratique √† ce moment-l√†. </font><font style="vertical-align: inherit;">Ce n'√©tait pas une t√¢che insignifiante, et je me demandais si je pouvais la r√©soudre.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe de mod√®le de fen√™tre - M√©thode 1</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La difficult√© est donc: comment passer le type de la classe d√©riv√©e √† la proc√©dure de fen√™tre? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne voulais pas faire de la classe de base enti√®re de WindowClass une classe mod√®le √† la fois: pour chaque classe d√©riv√©e, sa propre classe de base sera g√©n√©r√©e. De plus, puisque WindowClass deviendra un mod√®le, les n≈ìuds de liste et la liste elle-m√™me devront √©galement √™tre cr√©√©s comme mod√®les: ils ont des pointeurs vers des objets de classe, et pour utiliser ces pointeurs, ils doivent conna√Ætre leur type, c'est-√†-dire WindowClass et avec quoi il sera param√©tr√©. . Au moment de d√©finir la classe de liste et la classe de noeud, cela est inconnu; par cons√©quent, ce type doit √©galement √™tre pass√© en param√®tre (√† partir de WindowClass). Il s'ensuit que pour chaque classe d√©riv√©e va cr√©er sa propre liste correspondant √† </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cette classe d√©riv√©e</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(et seulement lui)! Et maintenant, vous ne pouvez pas placer de pointeurs vers les classes de base correspondant √† diff√©rentes d√©riv√©es dans un seul tableau: ils ont diff√©rents types.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai donc commenc√© √† chercher un moyen de passer le type de la classe d√©riv√©e, sans param√©trer la classe enti√®re. Un type ne peut √™tre transmis √† la classe de base que via le constructeur: c'est la seule fonction accessible lors de la cr√©ation de l'objet. Par cons√©quent, il doit √™tre passe-partout. Cependant, il s'est av√©r√© qu'elle ne pouvait √©videmment pas sp√©cifier les param√®tres du mod√®le: cela ressemblerait √† passer des param√®tres √† la classe de mod√®le elle-m√™me, et non √† son constructeur. Par cons√©quent, le type ne peut √™tre d√©duit que des param√®tres transmis au constructeur. Mais je ne voulais pas ajouter un param√®tre constructeur sp√©cial, qui ne sert qu'√† l'inf√©rence de type: encombrer la liste des arguments avec un param√®tre purement utilitaire. Et si l'utilisateur oublie de le transf√©rer, par exemple,√† travers au moins le trivial (DerivedClass *) nullptr? Ce n'est pas encore effrayant - le compilateur affichera un message d'erreur indiquant que la classe ne peut pas √™tre instanci√©e. Pire, si l'utilisateur cr√©e une hi√©rarchie de classes et passe un pointeur vers la mauvaise classe d√©riv√©e: tout sera correct du point de vue de la compilation, cependant, nous obtiendrons un programme fonctionnant incorrectement avec une erreur incompr√©hensible.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En bref, cette erreur de conception est une telle solution. </font><font style="vertical-align: inherit;">Ainsi, la responsabilit√© de l'instanciation correcte n'est m√™me pas transf√©r√©e au cr√©ateur de la classe d√©riv√©e, mais √† celui qui l'utilisera! </font><font style="vertical-align: inherit;">Et il ne peut √™tre ni un r√™ve, ni un esprit concernant de telles nuances et ne comprend sinc√®rement pas o√π est l'erreur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalement, abandonnant, j'ai tout de m√™me d√©cid√©, sans changer les param√®tres constructeurs, de param√©trer WindowClass lui-m√™me et en m√™me temps la liste associ√©e et les classes de n≈ìuds de liste. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe de mod√®le WindowClass:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">struct</span> <span class="hljs-title">ListElement</span>				// 
{</span>
	<span class="hljs-comment">// </span>
	HWND hWnd;					<span class="hljs-comment">//  Windows</span>
	WindowClass&lt;WndCls&gt; *p_wndClass;	<span class="hljs-comment">//    WindowClass</span><font></font>
<font></font>
	ListElement *pNext;			<span class="hljs-comment">//    </span>
	ListElement *pPrev;			<span class="hljs-comment">//    </span><font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClass</span>				//  <span class="hljs-title">Windows</span>
{</span>
	<span class="hljs-keyword">using</span> WndProcCallback = LRESULT (*)(HWND, UINT, WPARAM, LPARAM);		<span class="hljs-comment">//   </span><font></font>
<font></font>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List&lt;WndCls&gt; wndList;					<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//	</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span>
	<span class="hljs-function"><span class="hljs-keyword">static</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">//  ( )</span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T, <span class="hljs-keyword">typename</span> </span>= T::OnCreate&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//! .  FirstWin32CPP_DerivedTemplate2</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span><font></font>
		T::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd, T *p_wndClass)</span>		<span class="hljs-comment">//  OnCreate         </span>
	</span>{<font></font>
		p_wndClass-&gt;OnCreate(hWnd);			<span class="hljs-comment">//     </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	<span class="hljs-keyword">friend</span> List&lt;WndCls&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WindowClass&amp;);			<span class="hljs-comment">// </span><font></font>
	<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClass();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Classe d√©riv√©e:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClass&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WindowClassDerived(WindowClassDerived&amp;);		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une proc√©dure de fen√™tre, √©tant un membre mod√®le d'une classe mod√®le et ayant acc√®s au type pass√© de la classe d√©riv√©e, appelle OnCreate de la classe d√©riv√©e. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous arrivons donc naturellement au mod√®le CRTP. Ici, il s'est av√©r√© par lui-m√™me. Ce n'est que beaucoup plus tard que j'ai d√©couvert que cette conception est un mod√®le bien connu avec le nom correspondant. Mais alors je ne le savais pas, et il me semblait que je l'ai re√ßu pour la premi√®re fois.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai tout de suite compris que ce n'√©tait que la moiti√© de la solution. </font><font style="vertical-align: inherit;">Je peux facilement vouloir cr√©er une autre classe bas√©e sur ce d√©riv√©. </font><font style="vertical-align: inherit;">Et c'est tout: ce n'est pas un passe-partout et n'accepte plus aucun param√®tre. </font><font style="vertical-align: inherit;">J'ai donc eu l'id√©e de faire passer la deuxi√®me classe d√©riv√©e par la premi√®re d√©riv√©e √† celle de base. </font><font style="vertical-align: inherit;">(La glace mince sous mes pieds a commenc√© √† se fissurer ... J'allais d√©j√† l√† o√π il n'y avait pas de retour.) Mais si je le fais une fois, je peux le faire autant que je veux: m√™me si j'ai dix classes d√©riv√©es, je peux prendre le dixi√®me de suite ( la toute derni√®re) pour passer le long de la cha√Æne √† la base, et il y appellera la fonction de ce dernier d√©riv√© dont j'ai besoin (et, de mani√®re g√©n√©rale, tout interm√©diaire, si d√©sir√©). </font><font style="vertical-align: inherit;">La t√¢che √©tait claire. </font><font style="vertical-align: inherit;">Il ne restait plus qu'√† le faire.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe de fen√™tre param√©tr√©e - M√©thode 2</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la deuxi√®me manche, je me suis fix√© trois t√¢ches:</font></font><br>
<ul>
<li>-     ;</li>
<li>   ;</li>
<li>   ,   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien s√ªr, pour respecter ces exigences, vous devrez toujours cr√©er un mod√®le pour le concepteur et y ajouter un param√®tre sp√©cial. Cependant, cela signifie une violation d'une autre exigence. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Quelle est la solution ici? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez diviser la classe de base d'origine WindowClass en deux composants: la WindowClass elle-m√™me (appelons-la WindowClassBase maintenant), qui est une fondation unique in√©branlable, et compl√©tant sa classe d√©riv√©e (qui peut toujours √™tre appel√©e le m√™me nom d'origine WindowClass). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe compl√©mentaire est responsable de l'impl√©mentation d'OnCreate et, en plus, elle peut √™tre param√©tr√©e dans son ensemble. Et lui dans son constructeur passera le type qui lui est pass√© par un param√®tre sp√©cial au constructeur de la classe WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans tous les cas, dans WindowClassBase par rapport √† la source, vous devez maintenant apporter quelques modifications. Tout d'abord, en plus d'en supprimer OnCreate, vous devrez ajouter un membre de pointeur √† la classe qui la compl√®te (et, √† l'avenir, en d√©river), ainsi qu'une fonction d'appel qui appelle OnCreate par ce pointeur: nous ne pouvons pas appeler le pointeur vers la base car OnCreate n'y est plus, et OnCreate des classes qui sont compl√©mentaires et d√©riv√©es de celui-ci est pr√©f√©rable de l'appeler par le pointeur correct vers la classe souhait√©e, plut√¥t que d'essayer quelque chose avec le pointeur this de la base. En fin de compte, le param√®tre sp√©cial du constructeur WindowClassBase sera n√©cessaire non seulement pour l'inf√©rence de type, mais √©galement pour enregistrer puis appeler la classe n√©cessaire via OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, le type de ce pointeur a d√ª √™tre annul√©:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la classe n'est pas un mod√®le et vous ne pouvez pas dire au compilateur de cr√©er un pointeur avec un type inconnu;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de nombreux d√©riv√©s sont h√©rit√©s de la classe de base, ils ont tous des types diff√©rents - quel type de pointeur dois-je utiliser?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, je viens de le d√©clarer en style C: dans toute situation √©trange, utilisez un pointeur pour annuler. </font><font style="vertical-align: inherit;">Le pointeur est stock√© physiquement comme sans type, mais au moment de l'appel, OnCreate est converti en type de la classe appel√©e. </font><font style="vertical-align: inherit;">Cela se fait dans une fonction d'appel de mod√®le sp√©cial qui appartient √† WindowClassBase et dont le type de param√®tre est connu au moment de l'appel:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
</span>{
	<span class="hljs-comment">//  OnCreate   WndCls,  OnCreate   </span>
	<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
		(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Initialement, std :: true_type ou std :: false_type a √©t√© utilis√© comme deuxi√®me param√®tre pour s√©lectionner l'option souhait√©e pour remplacer la fonction. En utilisant la m√©thode SFINAE, il a √©t√© v√©rifi√© au stade de la compilation si la classe WndCls a une fonction membre OnCreate. Si tel est le cas, la version ci-dessus de la fonction est appel√©e. Si ce n'est pas le cas, l'appel √† OnCreate a √©t√© effectu√© sous la forme:</font></font><br>
<pre><code class="cpp hljs">(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;OnCreate(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par la suite, il s'est av√©r√© que SFINAE n'√©tait pas n√©cessaire: une classe qui compl√®te WindowClassBase, dans tous les cas, a une fonction membre OnCreate, donc, m√™me si la classe de param√®tres WndCls transmise n'a pas OnCreate d√©finie, elle se trouve dans l'une des classes de base par rapport √† elle , et la v√©rification donnera la v√©rit√© dans tous les cas. Si, par miracle, la classe compl√©mentaire est modifi√©e de sorte que OnCreate en soit supprim√©, et dans toutes les classes qui en d√©rivent, ce ne sera pas non plus, alors il n'y a aucun int√©r√™t √† l'appeler selon la deuxi√®me option: un tel code ne sera tout simplement pas compil√©. Par cons√©quent, √† la fin, l'option ci-dessus est donn√©e ici.)</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La logique d'acceptation et d'utilisation du type de classe de base dans WindowClassBase est assez simple: le type est d√©riv√© du pointeur vers l'objet de la classe d√©riv√©e pass√© au constructeur WindowClassBase, ce pointeur est stock√© dans ce constructeur, et le pointeur vers la proc√©dure de fen√™tre de mod√®le est instanci√© par le type pass√©, et le LaunchOnCreate ci-dessus est accessible . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la classe WindowClassBase ressemblera maintenant √† ceci:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassBase</span>				//  <span class="hljs-title">Windows</span>
{</span>
<span class="hljs-keyword">protected</span>:						<span class="hljs-comment">//   !</span>
	<span class="hljs-comment">//</span>
	HWND hWnd = <span class="hljs-literal">NULL</span>;								<span class="hljs-comment">//  	</span>
	WNDCLASSEX wc = { <span class="hljs-number">0</span> };							<span class="hljs-comment">//      Windows</span>
	<span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>;				<span class="hljs-comment">// </span>
	<span class="hljs-keyword">void</span> *p_drvWndCls;								<span class="hljs-comment">//   ,    (..  -  </span>
													<span class="hljs-comment">//,   ( )   , ..   void</span><font></font>
<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> TCHAR *szWndTitleDefault;			<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">static</span> List wndList;							<span class="hljs-comment">// ,    </span><font></font>
<font></font>
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CreateWnd</span><span class="hljs-params">(WNDCLASSEX&amp; wc, <span class="hljs-keyword">bool</span> bSkipClassRegister = <span class="hljs-literal">false</span>, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//    (  )</span><font></font>
	<font></font>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">LaunchOnCreate</span><span class="hljs-params">(HWND hWnd)</span>
	</span>{
		<span class="hljs-comment">//  OnCreate   WndCls</span>
		<span class="hljs-keyword">if</span> (p_drvWndCls)<font></font>
			(<span class="hljs-keyword">static_cast</span>&lt;WndCls *&gt;(p_drvWndCls))-&gt;WndCls::OnCreate(hWnd);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_PAINT   	</span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnClose</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_CLOSE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span></span>;				<span class="hljs-comment">//  WM_DESTROY   </span><font></font>
<font></font>
	<span class="hljs-comment">//   </span>
	<span class="hljs-keyword">friend</span> List;
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-keyword">friend</span> LRESULT CALLBACK <span class="hljs-title">WndProc</span><span class="hljs-params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//</span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;		<span class="hljs-comment">//     </span>
	<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>)</span></span>;	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassBase(WindowClassBase&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassBase();		<span class="hljs-comment">// </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, voici le code du constructeur le plus court:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class WndCls&gt; <span class="hljs-title">WindowClassBase::WindowClassBase</span><span class="hljs-params">(WndCls *p_wndClass, WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle)</span>
</span>{
	<span class="hljs-comment">// ,   ,   wc</span>
	<span class="hljs-comment">// : p_wndClass -    ,        , wc -    </span>
	<span class="hljs-comment">//    Windows, szWndTitle -   </span><font></font>
<font></font>
	WindowClassBase::wc = wc;<font></font>
	WindowClassBase::wc.lpfnWndProc = WndProc&lt;WndCls&gt;;<font></font>
	WindowClassBase::szWndTitle = szWndTitle;<font></font>
<font></font>
	p_drvWndCls = p_wndClass;		<span class="hljs-comment">//    ,   OnCreate()      WM_CREATE</span><font></font>
<font></font>
	<span class="hljs-comment">// </span>
	CreateWnd(WindowClassBase::wc, <span class="hljs-literal">false</span>, szWndTitle);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la proc√©dure de fen√™tre, l'appel √† LaunchOnCreate est le suivant:</font></font><br>
<pre><code class="cpp hljs">p_wndClass-&gt;LaunchOnCreate&lt;WndCls&gt;(hWnd);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il a d√©cid√© de supprimer la proc√©dure window elle-m√™me de la classe √† l'ext√©rieur, la d√©clarant privil√©gi√©e dans la classe WindowClassBase. Peut-√™tre que cela n'avait pas beaucoup de sens: quelle diff√©rence cela fait-il, o√π produire ses instanciations - √† l'ext√©rieur ou √† l'int√©rieur de la classe? Le segment de code en est un! Bien que, je l'admets, du point de vue de la m√™me encapsulation, vous devriez peut-√™tre toujours la laisser statique dans la classe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reste √† d√©finir la classe compl√©mentaire:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase			<span class="hljs-comment">//,  WindowClassBase    </span><font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe a un constructeur qui ressemble √† la WindowClass d'origine avant la s√©paration, c'est-√†-dire sans param√®tre sp√©cial, et ce param√®tre sp√©cial est g√©n√©r√© en interne lors de l'acc√®s au constructeur WindowClassBase en passant le pointeur this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette WindowClass sous cette forme est presque l'√©quivalent de la WindowClass d'origine. </font><font style="vertical-align: inherit;">En tant que tel, il ne prend pas en charge l'h√©ritage avec les remplacements OnCreate. </font><font style="vertical-align: inherit;">Cependant, il s'agit du point de d√©part pour prendre en charge l'h√©ritage (comme indiqu√© ci-dessous). </font><font style="vertical-align: inherit;">Sous cette forme:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la classe de base WindowClassBase n'est pas g√©n√©rique en soi, ce qui signifie qu'elle sera la seule pour toutes les classes d√©riv√©es, quelles qu'elles soient; </font><font style="vertical-align: inherit;">la Liste pour garantir que tous les autres messages Windows sont correctement trait√©s sera √©galement la seule;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le constructeur WindowClass n'a pas de param√®tre sp√©cial suppl√©mentaire.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir, deux des trois conditions sont remplies. </font><font style="vertical-align: inherit;">Reste √† faire face √† ce dernier: √† l'h√©ritage.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cha√Ænage de type de classe d√©riv√© dans WindowClassBase, type de contr√¥le</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour commencer, nous consid√©rerons l'h√©ritage unique, lorsque la logique d'initialisation de WindowClass ne nous convient pas, et nous souhaitons le changer par la cr√©ation d'une classe d√©riv√©e (pour l'instant au moins une). </font><font style="vertical-align: inherit;">Que faut-il changer dans WindowClass pour garantir cela? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une nouvelle variante de la classe compl√©mentaire devient passe-partout. </font><font style="vertical-align: inherit;">Ce n'est pas effrayant, car il ne contient en fait aucune donn√©e, mais uniquement la fonction OnCreate et les constructeurs:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerWndCls *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette classe prend un param√®tre de type DerWndCls et, en lui convertissant le pointeur this, le transmet √† WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faites attention √† static_cast. Ceci est important car ma conversion a √©t√© √©crite √† l'origine en style C comme ceci:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase((DerWndCls *)<span class="hljs-keyword">this</span>, wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apr√®s l'avoir traduit partout en static_cast, la moiti√© du code (voir ci-dessous) n'a pas √©t√© compil√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est √©galement un point d√©licat: la conversion est effectu√©e au stade de la compilation, mais cette classe elle-m√™me a la fonction OnCreate, et apr√®s la conversion, DerWndCls peut √™tre utilis√© pour appeler OnCreate de la classe DerWndCls. </font><font style="vertical-align: inherit;">C'est la diff√©rence avec le cas de conversion d√©crit ci-dessus dans WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, vous pouvez cr√©er une certaine classe WindowClassDerived, y substituer OnCreate et l'instancier avec le WindowClassTemplate d√©crit ci-dessus, impl√©mentant √† nouveau le m√™me mod√®le de r√©p√©tition √©trange original indiqu√© au d√©but de l'article:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WindowClassDerived&gt;<font></font>
{<font></font>
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:<font></font>
	WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);		<span class="hljs-comment">//     </span>
	WindowClassDerived(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerived(WindowClassDerived&amp;);			<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerived() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et OnCreate de ce WindowClassDerived sera appel√© √† l'int√©rieur du WindowClassBase, comme requis!</font></font><br>
<pre><code class="cpp hljs">WindowClassDerived::WindowClassDerived(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle) : WindowClassTemplate(hInstance, szClassName, szWndTitle)<font></font>
{<font></font>
	usiWndNum++;		<span class="hljs-comment">//    </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais c'est un h√©ritage unique. </font><font style="vertical-align: inherit;">Dans le cas de l'h√©ritage multiple, au lieu de WindowClassDerived, vous devez √† son tour d√©clarer un nouveau mod√®le, en prenant potentiellement la classe √† un niveau sup√©rieur dans la hi√©rarchie et en le transmettant √† WindowClassTemplate. </font><font style="vertical-align: inherit;">Je souligne sp√©cifiquement deux points cl√©s:</font></font><br>
<ol>
<li><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe </font><b><font style="vertical-align: inherit;">potentiellement</font></b><font style="vertical-align: inherit;"> h√¥te dans la hi√©rarchie. </font><font style="vertical-align: inherit;">Cela signifie qu'il ne peut accepter aucune classe, c'est-√†-dire √™tre lui-m√™me la toute premi√®re classe de la hi√©rarchie afin qu'un objet puisse √™tre cr√©√© √† partir d'elle.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transmission du</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> param√®tre WindowClassTemplate. </font><font style="vertical-align: inherit;">Cela signifie que l'argument de mod√®le accept√© doit √™tre pass√© de classe en classe √† travers toute la cha√Æne d'h√©ritage tout en bas, dans WindowClassTemplate et de l√† vers WindowClassBase.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Autrement dit, d'une part, la classe doit √™tre un mod√®le et prendre une certaine classe comme param√®tre. D'un autre c√¥t√©, il doit surveiller la situation selon laquelle il s'agit lui-m√™me d'une classe finie (au moment de l'instanciation) et instancier la classe de base par elle-m√™me, et non par le type transf√©r√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec tout cela, je voudrais que cela soit fait automatiquement par le compilateur: d√©finir une nouvelle classe bas√©e sur une classe d√©j√† cr√©√©e ne n√©cessitera aucune modification de cette derni√®re - alors toute l'essence de l'h√©r√©dit√©-polymorphisme est perdue. C'est-√†-dire: je cr√©e une classe qui est actuellement au sommet de la hi√©rarchie, mais alors </font></font><b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut</font></font></i></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><b><i><font style="vertical-align: inherit;">√™tre</font></i></b><font style="vertical-align: inherit;"> qu'une nouvelle classe sera cr√©√©e sur cette base, qui remplacera la classe actuelle sans changer sa d√©finition. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment impl√©menter cette fonctionnalit√©?</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour r√©soudre le probl√®me de l'automatisation et de la prise de d√©cision intelligente, l'argument par d√©faut du mod√®le se sugg√®re: si la classe en cours de cr√©ation est la classe sup√©rieure et que le param√®tre du mod√®le ne lui est pas transmis, alors nous devons lui affecter ce param√®tre. Ceci est accompli en utilisant l'argument par d√©faut. Ensuite, les questions suivantes se posent: comment le choisir et comment le relier √† la situation du param√®tre pass√© explicitement, ainsi que se transf√©rer lui-m√™me si le param√®tre n'est pas pass√©? </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Malheureusement, vous ne pouvez pas √©crire votre propre classe d√©finie comme param√®tre par d√©faut. Le compilateur ne manquera tout simplement pas le code du formulaire:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">WindowClassDerived</span>&lt;&gt;&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il rapporte qu'une d√©pendance de type r√©cursif est trop complexe. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Allons de l‚Äôautre c√¥t√©. </font><font style="vertical-align: inherit;">Introduisons une classe fictive qui ne fait rien de mani√®re fonctionnelle et ne stocke rien, jouant le r√¥le de seules fiches factices et signalant au compilateur qu'en cas d'apparition, rien ne sera transf√©r√© "d'en haut":</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">thisclass</span> {</span>};	<span class="hljs-comment">//-,     </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et dans l'argument par d√©faut, substituez-nous ce gag:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerived</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;DerWndCls&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette option, dans la situation avec l'argument par d√©faut, cette classe est pass√©e au WindowClassTemplate. </font><font style="vertical-align: inherit;">La classe thisclass n'a pas de fonction membre OnCreate, donc cette option ne compile tout simplement pas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons alors d‚Äôintroduire un deuxi√®me param√®tre de contr√¥le auxiliaire, sur la base duquel nous d√©ciderons du type √† transmettre. </font><font style="vertical-align: inherit;">Pour ce faire, bien s√ªr, vous devez modifier le WindowClassTemplate, par exemple, comme ceci:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassControlBaseTemplate</span> :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//  ControlType == thisclass,      DerWndCls,    ,   WindowClassBase</span>
	<span class="hljs-comment">//  ControlType != thisclass,    ControlType,        ( </span>
	<span class="hljs-comment">//    ControlType     )</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = <span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;ControlType, thisclass&gt;::value, DerWndCls, ControlType&gt;;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassControlBaseTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassControlBaseTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}	<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pas un type ne lui est transmis, mais deux. Bas√© sur la combinaison de ces deux types, le type final est d√©termin√© √† l'aide des outils &lt;type_traits&gt;: std :: conditional_t ‚Äã‚Äãet std :: is_same. C'est ce type qui est transmis √† WindowClassBase. La logique de s√©lection est d√©crite dans les commentaires: si cette classe est pass√©e √† ControlType, alors nous s√©lectionnons DerWndCls, sinon ControlType lui-m√™me est s√©lectionn√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, cr√©ez un mod√®le qui l'utilise lors de l'h√©ritage:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsDerivedTemplateClass</span> :</span> <span class="hljs-keyword">public</span> WindowClassControlBaseTemplate&lt;WndClsDerivedTemplateClass&lt;DerWndCls&gt;, ControlType&gt;		<span class="hljs-comment">//      </span><font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WndClsDerivedTemplateClass(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WndClsDerivedTemplateClass(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>);<font></font>
	WndClsDerivedTemplateClass(WndClsDerivedTemplateClass&amp;);	<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WndClsDerivedTemplateClass() <span class="hljs-keyword">override</span>;		<span class="hljs-comment">// </span><font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_CREATE   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;		<span class="hljs-comment">//  WM_PAINT   </span>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span></span>;	<span class="hljs-comment">//  WM_DESTROY   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier param√®tre est initialis√© par d√©faut via thisclass, et ControlType est calcul√© en fonction de DerWndCls lui-m√™me: si DerWndCls = thisclass, alors ControlType: = thisclass, sinon ControlType: = DerWndCls (affectation de style Pascal sp√©cifiquement sp√©cifi√©e pour distinguer de la comparaison). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, la classe WndClsDerivedTemplateClass elle-m√™me, param√©tr√©e par DerWndCls, sera transmise avec le type de contr√¥le calcul√© (au stade de la compilation).</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous cr√©ons un objet de cette classe, c'est-√†-dire que WndClsDerivedTemplateClass lui-m√™me est le haut de la hi√©rarchie, puis DerWndCls = ControlType = thisclass, puis &lt;WndClsDerivedTemplateClass, thisclass&gt; passe. Le fait que WndClsDerivedTemplateClass soit param√©tr√© par un mannequin n'a pas d'importance - ce type, et en effet tout DerWndCls pass√© en place, n'est en aucun cas utilis√© √† l'int√©rieur de la classe: aucun objet n'est cr√©√© √† partir d'elle et aucune fonction n'est appel√©e √† travers elle. Par cons√©quent, WndClsDerivedTemplateClass formellement peut √™tre instanci√© litt√©ralement avec n'importe quoi - le type de param√®tre ne sert qu'√† passer plus loin le long de la ligne d'h√©ritage. Mais ici, au lieu de DerWndCls, WndClsDerivedTemplateClass &lt;cette classe ou tout autre type&gt; a √©t√© transmis, cela importe: WndClsDerivedTemplateClass a une fonction OnCreate,qui sera appel√© dans WindowClassBase.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec cette option, cette classe arrive au WindowClassControlBaseTemplate √† la place du ControlType et le type final est affich√© comme DerWndCls = WndClsDerivedTemplateClass, qui a la fonction OnCreate n√©cessaire. C'est ce dont nous avons besoin. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consid√©rez maintenant l'option lorsqu'une nouvelle classe est construite sur la base de WindowClassControlBaseTemplate (h√©ritage suppl√©mentaire):</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, dans WndClsDerivedTemplateClass, quelque chose d'autre que cette classe prend la place de DerWndCls et ControlType, voyant cette diff√©rence, prend la valeur transmise √† DerWndCls. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, dans WindowClassControlBaseTemplate, l'option de param√©trage suivante va: &lt;WndClsDerivedTemplateClass &lt;WindowClassDerivedTemplateNext&gt;, WindowClassDerivedTemplateNext&gt;. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans WindowClassControlBaseTemplate, √† son tour, puisque ControlType! = Thisclass, il utilise le ControlType lui-m√™me, qui est √©gal √† WindowClassDerivedTemplateNext, qui est la bonne classe pour s√©lectionner OnCreate. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä premi√®re vue, avec un tel sch√©ma, tout semble bien se passer. Mais ce n'est pas le cas. Nous construisons une autre classe bas√©e sur cette derni√®re:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedTemplateNext&lt;WindowClassDerivedTemplateNext2&lt;DerWndCls&gt;&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans WindowClassDerivedTemplateNext, WindowClassDerivedTemplateNext2 remplacera DerWndCls. ControlType est √©galement sorti en tant que WindowClassDerivedTemplateNext2. Ensuite, WindowClassDerivedTemplateNext </font><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt; </font><font style="vertical-align: inherit;">sera transmis √† </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WndClsDerivedTemplateClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et ControlType affichera le m√™me WindowClassDerivedTemplateNext &lt;WindowClassDerivedTemplateNext2&gt;. Ensuite, les m√™mes valeurs seront transmises √† WindowClassControlBaseTemplate, et l√† au lieu de la fen√™tre WindowClassDerivedTemplateNext2 &lt;WindowClassDerivedTemplateNext&gt; </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &lt;WindowClassDerivedTemplateNext2erDerminalDiveTer WindowText sera appel√©e, pas seulement WindowClass, mais la fonction WindowTass WindowText, mais pas seulement WindowClass, mais le WindowText WindowTass WindowText WindowText WindowText, mais pas seulement WindowClass, mais la fen√™tre WindowText.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je vous rappelle qu'avec ce sch√©ma d'h√©ritage et de transmission de param√®tres, le type de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> classe </font><b><font style="vertical-align: inherit;">elle</font></b><font style="vertical-align: inherit;"> - </font><b><font style="vertical-align: inherit;">m√™me</font></b><font style="vertical-align: inherit;"> , qui est arriv√© √† WindowClassControlBaseTemplate en cons√©quence, est important, et non ce avec quoi il est param√©tr√©. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par cons√©quent, pour que le type pour lequel OnCreate sera appel√© s'affiche correctement, vous devez modifier la d√©finition de la classe WindowClassDerivedTemplateNext:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, puis dans WndClsDerivedTemplateClass, la valeur correcte √©gale √† WindowClassDerivedTemplateNext2 sera transmise au ControlType au lieu de s'y afficher dans la mauvaise valeur. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la derni√®re classe que nous construisons ne doit pas passer ControlType, permettant √† la base la plus proche de la produire ind√©pendamment, et cette base et toutes celles sous-jacentes doivent passer explicitement ControlType, interdisant sa sortie automatique √† la mauvaise valeur. Cette approche implique un </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">changement dans la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> d√©finition de la classe de base la plus proche, ce qui n'est possible que si nous avons le code source disponible ou si nous l'avons construit nous-m√™mes auparavant.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si nous avons oubli√© de le faire et avons viol√© cette r√®gle, lorsque nous utilisons static_cast, nous obtenons une erreur de compilation, et si nous convertissons des pointeurs de style C dans WindowClassControlBaseTemplate, nous obtenons un </font><font style="vertical-align: inherit;">programme qui </font><font style="vertical-align: inherit;">ne </font><font style="vertical-align: inherit;">fonctionne </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas correctement</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Par exemple, si nous essayons de cr√©er un objet pour une classe</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>, <span class="hljs-title">class</span> <span class="hljs-title">ControlType</span> = <span class="hljs-title">std</span>:</span>:<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, thisclass, DerWndCls&gt;&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassDerivedTemplateNext</span> :</span> <span class="hljs-keyword">public</span> WndClsDerivedTemplateClass&lt;WindowClassDerivedTemplateNext&lt;DerWndCls&gt;, ControlType&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
alors le compilateur donnera une erreur: il ne pourra pas convertir les types de pointeurs √† l'int√©rieur du WindowClassControlBaseTemplate car le type √©tait incorrect et ne peut pas √™tre converti (puisque nous allons cr√©er un objet de la classe WindowClassDerivedTemplateNext, nous supposons que la classe WindowClassDerivedTemplateNext elle-m√™me est en haut hi√©rarchie, et dans ce cas, comme indiqu√© ci-dessus, ControlType ne doit pas √™tre transmis). Sans static_cast, le code compilera et appellera simplement OnCreate de la mauvaise classe. Toutefois, la suppression de la transmission ControlType rend le programme √† nouveau compil√©.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fin de compte, tout cela est trop compliqu√©, peu fiable et n√©cessite la disponibilit√© de codes sources de toutes les classes. </font><font style="vertical-align: inherit;">De plus, nous ne pouvons cr√©er que des objets de la derni√®re classe d√©riv√©e et une de ses classes de base ne peut pas √™tre cr√©√©e en raison de la transmission ControlType (ou nous pouvons le faire si le pointeur est pass√© dans le style C, mais ces objets seront initialis√©s incorrectement). </font><font style="vertical-align: inherit;">Nous avons besoin d'une solution diff√©rente, plus simple et plus fiable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mod√®le variable</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√©anmoins, la variante ci-dessus d'h√©ritage de mod√®le et de transmission du type de l'objet cr√©√© √† la classe WindowClassBase, o√π la fen√™tre est cr√©√©e et l'appel OnCreate, pr√©sente de s√©rieux inconv√©nients. Nous avons besoin d'une autre option, plus fiable et plus efficace. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 11 introduit un nouveau type de mod√®le: un mod√®le avec un nombre variable d'arguments ou un mod√®le variable. Ses param√®tres sont une s√©quence de types de longueur inconnue auparavant. Au lieu de manipulations risqu√©es avec le type de contr√¥le dans l'exemple pr√©c√©dent, j'ai d√©cid√© d'aller dans l'autre sens: pour √©viter les situations o√π la classe interm√©diaire dans la hi√©rarchie remplace la classe parent dans la hi√©rarchie par un param√©trage incorrect (dans l'exemple ci-dessus c'√©tait </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WindowClassDerivedTemplateNext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;WindowClassDerivedTemplateNext2&gt;), vous pouvez g√©n√©ralement vous d√©barrasser de ce type de param√©trage en mettant simplement ces classes en s√©quence l'une √† c√¥t√© de l'autre. Par exemple, avec trois h√©ritages cons√©cutifs, la liste suivante sera √©ventuellement form√©e dans les param√®tres du mod√®le: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;WndCls3 &lt;&gt;, WndCls2 &lt;&gt;, WndCls1 &lt;&gt;&gt; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Traitement de cette liste, plus pr√©cis√©ment, l'un de ses derniers √©l√©ments (selon la fa√ßon dont vous l'avez compos√©e), Vous pouvez extraire la classe souhait√©e dans la hi√©rarchie et travailler avec elle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce cas, au lieu des mod√®les WindowClassTemplate et WindowClassControlBaseTemplate d√©crits pr√©c√©demment, qui sont les plus proches de la fen√™tre WindowClassBase racine et forment la base de tous les autres h√©ritages, vous devez √©crire une nouvelle classe de mod√®le de variable. Dans sa version la plus simple, ce sera comme ceci:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-comment">//,      </span>
<span class="hljs-keyword">template</span>&lt;class... Classes&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>;</span>		<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-comment">//,          </span>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span>, <span class="hljs-title">class</span>... <span class="hljs-title">OtherWindowClasses</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassVariadicTemplate</span>&lt;DerWndCls, OtherWindowClasses...&gt; :</span> <span class="hljs-keyword">public</span> WindowClassBase<font></font>
{<font></font>
	<span class="hljs-comment">//      :    - DerWndCls</span>
	<span class="hljs-keyword">using</span> DerivedWndClassType = DerWndCls;<font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadicTemplate(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadicTemplate(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassBase(<span class="hljs-keyword">static_cast</span>&lt;DerivedWndClassType *&gt;(<span class="hljs-keyword">this</span>), wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> </span>{}				<span class="hljs-comment">//  WM_CREATE   </span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, une description g√©n√©rale du mod√®le de classe sans le corps est d√©clar√©e. Ensuite, sa sp√©cialisation est d√©termin√©e, dans laquelle le premier type est s√©par√© du reste. C'est lui qui nous int√©resse. Cela est vrai dans le cas o√π chaque classe suivante se place </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√† la fin de la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> liste des param√®tres </font><font style="vertical-align: inherit;">lors du d√©placement vers le bas de la cha√Æne de hi√©rarchie vers WindowClassBase </font><font style="vertical-align: inherit;">. Ensuite, la classe dont nous avons besoin sera au d√©but, et il est tr√®s simple de la s√©parer du reste. Vous pouvez faire diff√©remment: chaque nouvelle classe se mettra </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">au d√©but</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liste des options de mod√®le. Ensuite, la classe au sommet de la hi√©rarchie sera la derni√®re de la liste, et son extraction √† partir de l√† est beaucoup plus difficile. Dans ce cas particulier, ces deux approches sont compl√®tement identiques, mais la premi√®re est beaucoup plus facile √† mettre en ≈ìuvre (y compris lors de la compilation - vous n'aurez pas √† traiter la liste enti√®re en en extrayant le dernier √©l√©ment), et c'est lui qui est donn√© ci-dessus. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier √©l√©ment, qui est la classe la plus √©lev√©e de la hi√©rarchie, est extrait de la liste et transmis √† WindowClassBase. Si OnCreate est d√©fini pour cela, il sera appel√©. Sinon, le OnCreate de la classe de base la plus proche sera appel√© par rapport √† lui. Si la liste des param√®tres variables est vide (nous essayons de cr√©er un objet √† partir de WindowClassVariadicTemplate), la compilation √©chouera, n√©cessitant au moins un type dans la liste des param√®tres.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re classe bas√©e sur WindowClassVariadicTemplate sera comme ceci:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic1</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadicTemplate&lt;PrevWndClasses..., WindowClassVariadic1&lt;&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">protected</span>:
	<span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> usiWndNum;			<span class="hljs-comment">//  </span><font></font>
<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassVariadic1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(hInstance, szClassName, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassVariadic1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassVariadicTemplate(wc, szWndTitle)<font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
	WindowClassVariadic1(WindowClassVariadic1&amp; wcObj) : WindowClassVariadicTemplate(wcObj)			<span class="hljs-comment">// </span><font></font>
	{<font></font>
		usiWndNum++;		<span class="hljs-comment">//    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassVariadic1() <span class="hljs-keyword">override</span>		<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);		<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnDestroy</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>				<span class="hljs-comment">//  WM_DESTROY   </span>
	</span>{<font></font>
		...<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette classe, apr√®s avoir accept√© une liste non d√©finie de param√®tres PrevWndClasses, la transmet √† la classe de base, en s'ins√©rant avant elle comme premier √©l√©ment avec une liste de param√®tres vide. </font><font style="vertical-align: inherit;">√âtant donn√© que cette classe WindowClassVariadic1 elle-m√™me est variable, WindowClassVariadic1 &lt;&gt; sera √©galement variable, bien que sans param√®tres, et toute cette s√©quence de classes est en fait un mod√®le de variable, dont chaque √©l√©ment est √©galement un mod√®le de variable. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe d√©riv√©e suivante est:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic2</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic1&lt;PrevWndClasses..., WindowClassVariadic2&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä l'exception du changement du nom du d√©riv√© et de la base, la classe a exactement la m√™me forme que la pr√©c√©dente. </font><font style="vertical-align: inherit;">La classe suivante est similaire:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;class... PrevWndClasses&gt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassVariadic3</span> :</span> <span class="hljs-keyword">public</span> WindowClassVariadic2&lt;PrevWndClasses..., WindowClassVariadic3&lt;&gt;&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C'est le sens de l'h√©ritage multiple polymorphe: en d√©clarant une classe de cette fa√ßon, nous garantissons non seulement la cr√©ation d'objets de ce type, mais aussi tous les objets de toutes les autres classes qui en d√©rivent, peu importe combien et quoi qu'ils soient √† l'avenir. Dans ce cas, le OnCreate correct sera toujours appel√© dans WindowClassBase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, ce mod√®le de variable est la premi√®re fa√ßon de r√©soudre le probl√®me de l'appel d'OnCreate lors de la cr√©ation d'une fen√™tre qui r√©pond pleinement √† toutes les exigences pr√©c√©demment d√©finies.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'avenir, o√π la meilleure m√©thode dans la situation donn√©e a finalement √©t√© trouv√©e, la mise en ≈ìuvre de l'h√©ritage via un mod√®le de variable vous permet d'impl√©menter une logique de compilation plus complexe dans WindowClassBase: en ayant acc√®s √† tous les types par lesquels l'h√©ritage s'est produit, vous pouvez choisir de mani√®re flexible parmi eux le n√©cessaire ou des crit√®res et appelez la fonction membre qui y est d√©finie. </font><font style="vertical-align: inherit;">Mais c'est toujours un cas l√©g√®rement diff√©rent.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Classe d'initialisation</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ignorant la r√©action de static_cast aux types d√©riv√©s, j'ai continu√© √† chercher d'autres moyens d'impl√©menter le transfert de la classe vertex de la hi√©rarchie vers WindowClassBase. </font><font style="vertical-align: inherit;">√Ä un moment donn√©, j'ai pens√© √† apporter l'impl√©mentation OnCreate √† une classe distincte, sp√©cialement cr√©√©e pour elle:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WindowClassInit1</span>
{</span>
<span class="hljs-keyword">public</span>:
	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span>				<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette classe param√®tre une autre classe qui impl√©mente tous les autres remplacements pour les fonctions virtuelles. </font><font style="vertical-align: inherit;">Il est d√©riv√© du WindowClassTemplate d√©j√† d√©crit:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WndClsInit</span> = <span class="hljs-title">WindowClassInit1</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedI1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;WndClsInit&gt;<font></font>
{<font></font>
	...<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De cette fa√ßon:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l'h√©ritage de classe se produit comme d'habitude pour les fonctions virtuelles;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seule la classe d'initialisation sp√©cialement d√©finie pour l'impl√©mentation d'OnCreate est transf√©r√©e de classe en classe selon la cha√Æne d'h√©ritage.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si cette classe se trouve en haut de la hi√©rarchie, le param√®tre WndClsInit deviendra √©gal √† WindowClassInit1 - la classe d'initialisation d√©finie pour cette classe et sera transf√©r√© plus loin dans la cha√Æne de hi√©rarchie. Si cette classe est interm√©diaire dans la cha√Æne, elle acceptera simplement la classe qui lui est transmise et la transmettra. Ensuite, cette option se compare favorablement aux pr√©c√©dentes en ce que les mod√®les ne se transf√®rent pas eux-m√™mes, mais transf√®rent une classe tierce, qui est impl√©ment√©e (et semble) beaucoup plus facile. Un mod√®le sous cette forme convient √©galement sans modifications pour l'impl√©mentation de la cha√Æne d'h√©ritage enti√®re: seul le changement de nom de classe se produira.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, static_cast, contrairement √† la conversion de style C, √† l'int√©rieur de WindowClassTemplate ne manquera pas cette forme d'h√©ritage: il ne peut tout simplement pas se convertir lors du passage de (WindowClassTemplate *) √† (WindowClassInit1 *). </font><font style="vertical-align: inherit;">Et c'est logique: WindowClassInit1 est en fait une classe √©trang√®re, juste pass√©e en tant que type √† ce point, elle n'est en aucun cas connect√©e √† WindowClassTemplate et √† toute la cha√Æne de d√©riv√©s de celle-ci, donc la conversion du pointeur vers elle est inacceptable.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cha√Ænage de type de classe d√©riv√© dans WindowClassBase, transfert conditionnel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et enfin, le meilleur moyen a √©t√© trouv√© pour cette situation de transf√©rer le type de la classe d√©riv√©e vers la base racine WindowClassBase √† travers toute la cha√Æne d'h√©ritage, sans les inconv√©nients des pr√©c√©dents et en m√™me temps plus simple que le mod√®le de variable. </font><font style="vertical-align: inherit;">D√©finissez la classe de mod√®le suivante en fonction de WindowClassTemplate:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
	<span class="hljs-comment">//     </span>
	WindowClassDerivedAlternative1(HINSTANCE hInstance, <span class="hljs-keyword">const</span> TCHAR *szClassName, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(hInstance, szClassName, szWndTitle) {}
	<span class="hljs-comment">//,      WNDCLASSEX     ,    </span>
	WindowClassDerivedAlternative1(WNDCLASSEX&amp; wc, <span class="hljs-keyword">const</span> TCHAR *szWndTitle = <span class="hljs-literal">nullptr</span>) : WindowClassTemplate(wc, szWndTitle) {}<font></font>
<font></font>
	<span class="hljs-keyword">virtual</span> ~WindowClassDerivedAlternative1() <span class="hljs-keyword">override</span>	<span class="hljs-comment">// </span><font></font>
	{<font></font>
		<span class="hljs-keyword">if</span> (hWnd)
			<span class="hljs-keyword">this</span>-&gt;OnClose(hWnd);	<span class="hljs-comment">// ,    </span><font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnCreate</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>			<span class="hljs-comment">//  WM_CREATE   </span>
	</span>{
		<span class="hljs-comment">//  WM_CREATE   </span>
		SetClassLongPtr(hWnd, GCL_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(<span class="hljs-number">200</span>, <span class="hljs-number">160</span>, <span class="hljs-number">255</span>)));<font></font>
	}<font></font>
	<span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnPaint</span><span class="hljs-params">(HWND hWnd)</span> <span class="hljs-keyword">override</span>	<span class="hljs-comment">//  WM_PAINT   </span>
	</span>{
		<span class="hljs-comment">//  WM_PAINT   </span><font></font>
		HDC hDC;<font></font>
		PAINTSTRUCT ps;<font></font>
		RECT rect;<font></font>
<font></font>
		hDC = BeginPaint(hWnd, &amp;ps);<font></font>
<font></font>
		GetClientRect(hWnd, &amp;rect);<font></font>
		DrawText(hDC, TEXT(<span class="hljs-string">"       ( )."</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<font></font>
<font></font>
		EndPaint(hWnd, &amp;ps);<font></font>
	}<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette classe accepte DerWndCls comme param√®tre, qui par d√©faut est √©gal √† thisclass. </font><font style="vertical-align: inherit;">Lors du transfert, DerWndCls est compar√© √† cette classe: en cas d'√©galit√© (la valeur par d√©faut, c'est-√†-dire que la classe donn√©e est en haut de la hi√©rarchie), elle se passe avec une liste de param√®tres vide. </font><font style="vertical-align: inherit;">Sinon, les DerWndCls re√ßus sont transmis. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je consid√®re que cette solution est la meilleure dans cette situation √† tous √©gards:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une forme unique de d√©finition de classe pour toute la cha√Æne d'h√©ritage;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">logique simple et transparente de transfert de classe tout au long de la cha√Æne d'h√©ritage;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas de surcharge en raison du mod√®le de variable (dans ces cas, comme dans celui-ci, lorsque cela n'est pas requis).</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ch√¢timent terrible</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Qu'est-ce que tout cela signifie? </font><font style="vertical-align: inherit;">Cela signifie que si vous souhaitez utiliser une telle forme d'h√©ritage non conventionnelle, vous devez formaliser toutes vos classes de mani√®re strictement d√©finie afin qu'elles permettent le transfert √† travers vous d'un √©ventuel nouveau d√©riv√©. </font><font style="vertical-align: inherit;">Il s'agit d'une exigence tr√®s simple, et si vous le souhaitez, elle est facile √† suivre. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais il y a une autre question, beaucoup plus banale: la relation entre les types et les pointeurs. </font><font style="vertical-align: inherit;">Les gens intelligents ont √©crit: ne jouez pas avec de telles choses dans le constructeur et allez √† l'encontre des principes du langage et de la logique du compilateur. </font><font style="vertical-align: inherit;">Mais je n'ai pas ob√©i et je l'ai quand m√™me fait. </font><font style="vertical-align: inherit;">Vient maintenant la r√©tribution naturelle. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Donc, nous avons 4 classes:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative1</span> :</span> <span class="hljs-keyword">public</span> WindowClassTemplate&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative1&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative2</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative1&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative2&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative3</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative2&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative3&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};<font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DerWndCls</span> = <span class="hljs-title">thisclass</span>&gt; <span class="hljs-title">class</span> <span class="hljs-title">WindowClassDerivedAlternative4</span> :</span> <span class="hljs-keyword">public</span> WindowClassDerivedAlternative3&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">conditional_t</span>&lt;<span class="hljs-built_in">std</span>::is_same&lt;DerWndCls, thisclass&gt;::value, WindowClassDerivedAlternative4&lt;&gt;, DerWndCls&gt;&gt;<font></font>
{<font></font>
	‚Ä¶<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme je l'ai √©crit ci-dessus, leur contenu sp√©cifique et leur logique de travail sont totalement sans importance. </font><font style="vertical-align: inherit;">La seule chose importante est que dans le titre de la d√©finition de classe. </font><font style="vertical-align: inherit;">Sur la base de ces classes, nous cr√©ons 4 objets:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">WindowClassDerivedAlternative1&lt;&gt; <span class="hljs-title">w1</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative1"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative2&lt;&gt; <span class="hljs-title">w2</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative2"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative3&lt;&gt; <span class="hljs-title">w3</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative3"</span>))</span></span>;
<span class="hljs-function">WindowClassDerivedAlternative4&lt;&gt; <span class="hljs-title">w4</span><span class="hljs-params">(hInstance, TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>), TEXT(<span class="hljs-string">"WindowClassDerivedAlternative4"</span>))</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous d√©veloppons les d√©finitions de leurs types cach√©s derri√®re des crochets vides en utilisant les arguments par d√©faut. Le type w1 est WindowClassDerivedAlternative1. Le type w2 est WindowClassDerivedAlternative2 et sa classe de base est WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative2&gt;. Le type w3 est WindowClassDerivedAlternative3, sa classe de base est WindowClassDerivedAlternative2 &lt;WindowClassDerivedAlternative3&gt; et sa classe de base est WindowClassDerivedAlternative1 &lt;WindowClassDerivedAlternative3&gt;. De m√™me, pour le quatri√®me objet. Jetez un ≈ìil au sch√©ma suivant:</font></font><br>
<img src="https://habrastorage.org/webt/bu/b5/nn/bub5nnsttowpw1lhstypwm-3vfc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En cr√©ant chaque nouvelle classe d√©riv√©e sur la base d'une certaine classe de base d√©finie de cette mani√®re, vous d√©finissez non seulement une nouvelle classe, mais en m√™me temps toute la cha√Æne de ses classes de base. Il sera parall√®le √† la cha√Æne de sa propre classe de base. Votre classe aura ses propres classes de base, et aucune d'entre elles ne pourra mener √† l'une des classes de base d'origine, malgr√© le fait que le code de g√©n√©ration pour toutes ces classes soit le m√™me! Cela semble vraiment fantastique, mais √ßa l'est vraiment! Cela signifie que toutes les fa√ßons habituelles de manipuler les classes h√©rit√©es et les pointeurs ne fonctionneront pas! Dans cette architecture particuli√®re, seul le WindowClassBase de base enregistre la situation, sinon il serait √©galement impossible de cr√©er un tableau √† partir des classes de base (par exemple, bas√© sur le WindowClassTemplate),parce que toutes ces classes ont des types diff√©rents.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la d√©finition bien connue et compr√©hensible de la forme:</font></font><br>
<pre><code class="cpp hljs">WindowClassDerivedAlternative1&lt;&gt; *p2 = &amp;w2;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... arr√™tera de compiler car vous essayez de cr√©er un pointeur de type incompatible avec le type de l'objet w2 malgr√© le fait qu'il y a une demi-heure vous avez vous-m√™me √©crit une classe d√©riv√©e de la classe WindowClassDerivedAlternative1 &lt;&gt; et bas√©e sur laquelle l'objet w2 a √©t√© cr√©√©.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque les lois habituelles cessent de fonctionner, cela peut provoquer un choc. </font><font style="vertical-align: inherit;">Et avec tout cela, il n'y a en fait pas de hacks de compilateur sales, de conversions de types forc√©es et d'autres choses vraiment mauvaises. </font><font style="vertical-align: inherit;">Tout est extr√™mement propre et l√©gal: mod√®les, param√®tres par d√©faut et outils de biblioth√®que de types. </font><font style="vertical-align: inherit;">Seules les m√©thodes d'√©criture de code connues cessent de fonctionner. </font><font style="vertical-align: inherit;">L'utiliser dans un projet r√©el signifie y d√©clarer une zone dangereuse, qui ne peut √™tre saisie que par du personnel sp√©cialis√© qualifi√© avec des mesures de protection appropri√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exp√©riences de code</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faciliter la t√¢che √† tous ceux qui souhaitent exp√©rimenter et gagner du temps sur la saisie, j'ai publi√© sur GitHub tous les projets qui ont servi de base √† cet article: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/SkyCloud555/ECRTP</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Choisissez simplement un projet √† tour de r√¥le comme votre premier, sinon vous vous noierez dans une mer de fen√™tres color√©es.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬´Si tout cela est une telle plaisanterie, alors, √©tant donn√© les efforts d√©ploy√©s, cela semble trop s√©rieux et naturel. </font><font style="vertical-align: inherit;">Et si ce n'est pas une blague, aucun d√©veloppeur normal sens√© n'utilisera vraiment quelque chose comme √ßa. </font><font style="vertical-align: inherit;">Et de toute fa√ßon, mec, ne finirais-tu pas par faire des b√™tises et ne vas-tu pas faire quelque chose </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui rapporte de l'argent, c'est</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utile. " </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous avez raison si vous le pensez. </font><font style="vertical-align: inherit;">Dans cet article, je viens de montrer que C ++ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">peut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. La question de l'application pratique de ces structures reste ouverte. Et en g√©n√©ral, cela est plus susceptible de s'appliquer √† la g√©n√©ralisation et √† la m√©taprogrammation. Vous n'aurez peut-√™tre pas besoin de cr√©er d'objets de ces classes, mais les classes elles-m√™mes peuvent √™tre n√©cessaires pour une raison quelconque. Oui, et vous ne savez jamais quelles solutions utiles vous pouvez trouver sur cette base ... Le CRTP d'origine est utilis√©! Et il n'est m√™me pas utilis√© n'importe o√π, mais directement dans la biblioth√®que standard! Qui ne croit pas ou ne se souvient pas, google std :: en_shared_from_this. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Revenons √† la t√¢che d'origine avec les fen√™tres ... Surtout maintenant, sobrement </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et sans herbe en y</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> repensant trois ans plus tard ... M√™me si nous √©cartons le fait que j'ai abord√© un sujet banal qui a d√©j√† √©t√© parcouru un million de fois, et cela n'a longtemps √©t√© int√©ressant pour personne, car pour de </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vrai gar√ßons</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">les gens normaux ont </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Qt, je voudrais juste m'assurer qu'un objet fonctionnel est pass√© √† la classe window. </font><font style="vertical-align: inherit;">Il n'est pas difficile d'assurer son transfert √† travers la cha√Æne d'h√©ritage, mais il fera tout simplement, clairement et sans distorsion, et vous obtiendrez une classe pr√©visible tout √† fait normale sans aucun effet secondaire, que vous pouvez accompagner et d√©velopper pour absolument n'importe qui. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ce qui s'est pass√© dans cet article n'est qu'une t√¢che non triviale int√©ressante, que j'ai quand m√™me r√©ussi √† r√©soudre. </font><font style="vertical-align: inherit;">J'esp√®re que cela vous a √©galement int√©ress√©.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr507114/index.html">Ode Excel: 34 ans de magie</a></li>
<li><a href="../fr507116/index.html">"Udalenka". Notes du d√©veloppeur de bureau d'hier. Partie 2</a></li>
<li><a href="../fr507124/index.html">PDB n'est pas seulement une fourrure pr√©cieuse</a></li>
<li><a href="../fr507132/index.html">Vladimir Kitov: ¬´Il est impossible de comprendre comment des scientifiques pionniers pr√©voyaient l'informatisation universelle dans les ann√©es 1950!¬ª</a></li>
<li><a href="../fr507138/index.html">La g√©ologie du 21e si√®cle en tant que science des donn√©es de la Terre</a></li>
<li><a href="../fr507148/index.html">Envoyer des liens magiques √† l'aide de Node.js</a></li>
<li><a href="../fr507150/index.html">Nous dessinons une image d'interf√©rence en JavaScript</a></li>
<li><a href="../hi486176/index.html">‡§ï‡•â‡§∞‡•ç‡§™‡•ã‡§∞‡•á‡§ü ‡§à‡§Æ‡•á‡§≤ ‡§™‡§§‡•ç‡§∞‡§æ‡§ö‡§æ‡§∞ ‡§Æ‡•á‡§Æ‡•ã</a></li>
<li><a href="../hi486178/index.html">FOSS News No. 1 - 27 ‡§ú‡§®‡§µ‡§∞‡•Ä - 2 ‡§´‡§∞‡§µ‡§∞‡•Ä, 2020 ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•ç‡§µ‡§§‡§Ç‡§§‡•ç‡§∞ ‡§î‡§∞ ‡§Æ‡•Å‡§ï‡•ç‡§§ ‡§∏‡•ç‡§∞‡•ã‡§§ ‡§∏‡§Æ‡§æ‡§ö‡§æ‡§∞ ‡§ï‡•Ä ‡§∏‡§Æ‡•Ä‡§ï‡•ç‡§∑‡§æ</a></li>
<li><a href="../hi486180/index.html">‡§∏‡§∞‡•ç‡§µ‡§∞ ‡§∞‡§π‡§ø‡§§ ‡§è‡§™‡•ç‡§≤‡§ø‡§ï‡•á‡§∂‡§® ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§∏‡•Å‡§ù‡§æ‡§µ ‡§î‡§∞ ‡§∏‡•ç‡§∞‡•ã‡§§</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>