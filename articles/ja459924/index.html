<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍟 🍳 🤦🏽 Reactアプリケーションのテストの全サイクル。Auto.ruを報告する 👩🏿‍🤝‍👨🏼 🤷🏽 👈🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="手動回帰テストを回避したいという欲求は、自動テストを導入する良い理由です。問題はどれですか？インターフェイス開発者のNatalya StusとAleksey Androsovは、チームがいくつかのイテレーションを行い、JestとPuppeteerに基づいてAuto.ruでフロントエンドテストを作成し...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Reactアプリケーションのテストの全サイクル。Auto.ruを報告する</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/459924/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">手動回帰テストを回避したいという欲求は、自動テストを導入する良い理由です。問題はどれですか？インターフェイス開発者のNatalya StusとAleksey Androsovは、チームがいくつかのイテレーションを行い、JestとPuppeteerに基づいてAuto.ruでフロントエンドテストを作成した方法を思い出しました。ユニットテスト、個々のReactコンポーネントのテスト、統合テストです。この体験で最も興味深いのは、Selenium Grid、Java、およびその他のものを使用せずにブラウザーでReactコンポーネントを分離してテストすることです。</font><font style="vertical-align: inherit;">
アレクセイ：</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/yr/np/zo/yrnpzon4-5momllzoy0bg1zz-ie.jpeg"></a><br>
<br><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-最初に、自動車ニュースとは何かを少し伝える必要があります。自動車販売サイトです。検索、個人アカウント、自動車サービス、スペアパーツ、レビュー、販売店などがあります。 Auto.ruは非常に大規模なプロジェクトであり、多くのコードが含まれています。コードがすべて混同されているため、すべてのコードを大きなモノリピーで記述します。同じ人が、モバイルやデスクトップなど、同様のタスクを実行します。多くのコードが判明し、monorepaは私たちにとって不可欠です。問題はそれをテストする方法ですか？</font></font><br>
<br>
<a name="habracut"></a><img src="https://habrastorage.org/webt/vn/qv/qf/vnqvqfbci0v-wlfceczgd5snhgi.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReactとNode.jsがあります。これらはサーバー側のレンダリングを実行し、バックエンドにデータを要求します。 BEMに残った小さな断片。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xb/1p/_b/xb1p_b-9j8huy-rle317mtp5sjc.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナタリア：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-私たちは自動化に向けて考え始めました。個々のアプリケーションのリリースサイクルには、いくつかのステップが含まれていました。まず、この機能はプログラマーが別のブランチで開発します。その後、同じ別のブランチで機能が手動テスターに​​よってテストされます。すべて問題なければ、タスクはリリース候補に分類されます。そうでない場合は、開発の反復に戻り、もう一度テストします。テスターがこの機能のすべてに問題がないと言うまでは、リリース候補には該当しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リリース候補のアセンブル後、Auto.ruだけでなく、ロールするパッケージのみの手動回帰があります。たとえば、デスクトップWebをロールバックする場合、デスクトップWebの手動回帰があります。これらは多くの手動テストケースです。このような退行は、1人の手動テスターの約1営業日かかりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回帰が完了すると、リリースが発生します。その後、リリースブランチがマスターにマージされます。この時点で、デスクトップWebに対してのみテストしたマスターコードを挿入するだけで済みます。たとえば、このコードはモバイルWebを破壊する可能性があります。これはすぐにはチェックされませんが、次の手動回帰-モバイルWebでのみチェックされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uc/pp/f6/ucppf6mqcfn6rcjayzc7mzgzzwe.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、このプロセスで最も痛みを伴うのは手動回帰でした。これには非常に長い時間がかかりました。もちろん、すべての手動テスターは毎日同じことをするのにうんざりしています。したがって、すべてを自動化することにしました。実行された最初のソリューションは、別のチームによって書かれたSeleniumとJavaのセルフテストでした。これらは、アプリケーション全体をテストするエンドツーエンドのテストe2eでした。彼らはそのようなテストの約5000を書いた。結局何になったの？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然、私達は回帰を加速しました。自動テストは、手動テスターよりもはるかに高速であり、結果として約10倍高速です。したがって、彼らが毎日行う日常的な行動は、手動テスターから削除されました。自動テストで見つかったバグは再現が簡単です。このテストを再起動するか、テストの手順を確認してください。手動テスターとは異なり、「何かをクリックすると、すべてが壊れました」と言うでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コーティングの安定性を提供しました。私たちは常に同じ実行テストを実行します-対照的に、ここでも、手動テストから、テスターがこの場所に触れなかったと見なすことができ、今回はチェックしません。スクリーンショットを比較するためのテストを追加し、UIのテストの精度を改善しました。今度は、テスターが目に見えないいくつかのピクセルの違いをチェックします。スクリーンショットテストに感謝します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、短所がありました。最大のもの-e2eテストでは、製品と完全に一貫したテスト環境が必要です。常に最新の状態に維持し、稼働させる必要があります。これを行うには、安定性をサポートするために販売するのとほぼ同じ強さが必要です。当然のことながら、いつもそれを買う余裕はありません。そのため、最前面のパッケージには問題はありませんでしたが、テスト環境が横になっているか、何かが壊れていて、テストが失敗する状況がよくありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテストも別のチームによって開発されており、独自のタスクとタスクトラッカーの独自のタスクがあり、新機能には多少の遅れが生じています。新しい機能のリリース後すぐに来て、すぐに自動テストを書くことはできません。テストは費用がかかり、作成と保守が難しいため、テストではすべてのシナリオをカバーするのではなく、最も重要なシナリオのみをカバーします。同時に、個別のチームが必要であり、個別のツール、個別のインフラストラクチャ、それぞれ独自のチームが用意されます。また、落下したテストの分析は、手動テスターや開発者にとっても重要な作業です。いくつか例を示します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gn/ix/c6/gnixc6p8h1phrdhcjlosttb0ai8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストを実行しました。 500件のテストに合格しましたが、そのうちのいくつかは落ちました。そのようなことをレポートで見ることができます。ここではテストが開始されなかっただけで、すべてが良好であるかどうかは明確ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/40/70/6p/40706pwn5i1vfzfpl4ekmfhpeom.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例-テストは開始しましたが、そのようなエラーでクラッシュしました。彼はページ上で要素を見つけることができませんでしたが、理由-私たちは知りません。この要素が単に表示されなかったか、間違ったページにあることが判明したか、ロケーターが変更されました。あなたが行くとdebazhの手に必要なすべて。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vh/_f/xd/vh_fxdrktlr3llkbrcloced22ks.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スクリーンショットテストでも、必ずしも正確な結果が得られるとは限りません。ここで、ある種のカードをロードします。少し移動しましたが、テストが失敗しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_r/1y/dm/_r1ydm4pdscdlxgdse5focstyje.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの問題のいくつかを解決しようとしました。私たちは本番でいくつかのテストを実行し始めました-ユーザーデータを傷つけないものはデータベースの何も変更しません。つまり、私たちprodは、製品環境を調べる別のマシンを作成しました。新しいフロントエンドパッケージをインストールして、そこでテストを実行するだけです。製品は少なくとも安定しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のテストをmokeyに転送しましたが、さまざまなバックエンド、さまざまなAPIがあり、特に5000テストの場合、すべてをロックすることは非常に困難な作業です。このため、mockritsaと呼ばれる特別なサービスが作成されました。これは、フロントエンドに必要なmokaを非常に簡単に作成するのに役立ち、それらをプロキシするのはかなり簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、これらのテストを開始するデバイスのセレングリッドが大きくなるように、大量の鉄を購入する必要がありました。これにより、ブラウザーを上げることができず、より速く合格したため、落下しませんでした。これらの問題を解決しようとした後でも、そのようなテストはCIに適していないという結論に達しました。非常に長い時間がかかります。すべてのプールリクエストで実行することはできません。後で、プール要求ごとに生成されるこれらのレポートを分析することは決してありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/od/0z/rl/od0zrladzvsshl04e52vipgtcvo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、CIの場合、ランダムな理由で失敗しない、高速で安定したテストが必要です。複雑なユーザーケースなしで、テストスタンド、バックエンド、データベースなしでプールリクエストのテストを実行したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらのテストはコードと同時に記述される必要があり、テストの結果により、問題が発生したファイルがすぐに明らかになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アレクセイ：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-はい、そして私たちは私たちが望むすべてを試し、同じJestインフラストラクチャの最初から最後まですべてを整えることにしました。なぜジェストを選んだのですか？私たちはすでにJestで単体テストを作成しましたが、気に入っていました。これは人気のあるサポートされているツールであり、すでに用意されている統合機能がたくさんあります：Reactテストレンダリング、Enzyme。すべてがそのまま機能し、何も構築する必要はありません。すべてがシンプルです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/js/bo/sa/jsbosapwtytq_x6a8zkvxl6gdv0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、Jestは個人的に私のために勝ちました、他のmokaとは異なり、私がそれまたは何か他のものをきれいにするのを忘れたなら、あなたの足である種のサードパーティのテストの副作用を撃つことは困難です。 mokaではこれは1回か2回行われますが、Jestではそれを行うのは困難です。これは常に別のスレッドで起動されます。それは可能ですが、難しいです。また、e2eでリリースされたPuppeteerについても、試してみることにしました。それが私たちが得たものです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ab/ph/oa/abphoap_rzksxw_spwh4t_0nfra.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナタリア：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-ユニットテストの例から始めます。一部の関数のテストを作成する場合、特別な問題はありません。この関数を呼び出し、いくつかの引数を渡し、何が起こったかと何が起こったかを比較します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
React-コンポーネントについて話していると、すべてが少し複雑になります。どういうわけかそれらをレンダリングする必要があります。 Reactテストレンダラーはありますが、単体テストではコンポーネントを個別にテストできないため、ユニットテストにはあまり便利ではありません。コンポーネントを最後まで完全にレイアウトします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、Enzymeを使用して、特定のMyComponentがあるコンポーネントの例を使用して、Reactコンポーネントの単体テストを作成する方法を示します。彼はある種の小道具を手に入れ、ある種の論理を持っています。次に、Fooコンポーネントを返します。Fooコンポーネントは、barコンポーネントを返します。これは、すでにbarコンポーネント内にあり、実際にはレイアウトに返されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h2/1e/e6/h21ee6qkeeucwkgnvye6ewsgxog.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浅いレンダリングのような酵素ツールを使用できます。これは、MyComponentコンポーネントを分離してテストするために必要なものです。そして、これらのテストは、コンポーネントfooとbarがそれらの内部に何を含むかに依存しません。コンポーネントMyComponentのロジックをテストするだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jestにはスナップショットなどの機能があり、ここでも私たちを助けることができます。 「何かをtoMatchSnapshotで期待する」は、このような構造を作成します。実際に渡したもの、期待される結果を格納するテキストファイルだけです。このテストを初めて実行すると、このファイルが書き込まれます。テストをさらに実行すると、MyComponent.test.js.snapファイルに含まれている標準と何が行われるかが比較されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、レンダリング全体が表示され、MyComponentのrenderメソッドが返すものを正確に返し、一般にfooは何でもかまいません。 MyComponentコンポーネントの2つのケースに対して、2つのケースに対してこのような2つのテストを作成できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wu/b3/iw/wub3iwlwsatz7ytgzpeim8vsbqs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、必要なスクリプトを確認するだけで、たとえば、どのコンポーネントがfooコンポーネントに渡されるかを確認することで、スナップショットなしで同じことをテストできます。しかし、このアプローチにはマイナスが1つあります。新しいテストであるMyComponentに他の要素を追加しても、これはまったく表示されません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pd/9e/vy/pd9evyrhuh7kfzrqcukvwpbudaq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、結局のところ、スナップショットテストは、コンポーネント内のほとんどすべての変更を示すものです。しかし、両方のテストをスナップショットで作成し、コンポーネントに同じ変更を加えると、両方のテストが失敗することがわかります。原則として、これらの落ちたテストの結果は、同じことについて教えてくれます。そこに、ある種の「こんにちは」を追加しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gv/c1/dc/gvc1dcwq9aw2m3owq6c-esulpsg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これも冗長であるため、同じ構造に対して1つのスナップショットテストを使用することをお勧めします。残りのロジックをスナップショットなしで何らかの方法でチェックします。スナップショットはあまり目立たないためです。スナップショットを見ると、何かがレンダリングされていることがわかりますが、ここでテストしたロジックは明確ではありません。これを使用する場合、これはTDDには完全に不適切です。また、ドキュメントとしては機能しません。つまり、このコンポーネントを見ると、はい、スナップショットは何かに対応していますが、どのようなロジックがあったのかはあまり明確ではありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/yc/ia/wayciagk2zoa51amkq8bb9xcqic.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/zk/mj/sa/zkmjsaoqa-34pqk2flku7_n7nsy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、fooコンポーネント、barコンポーネント、たとえばSnapshotの単体テストを作成します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/eu/lk/bgeulklgkyqg-woog9tkqhkkpco.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これら3つのコンポーネントを100％カバーしています。私たちはすべてをチェックしたと信じています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、barコンポーネントの何かを変更し、それに新しいプロップを追加し、明らかにbarコンポーネントのテストがあったとしましょう。テストを修正し、3つのテストすべてに合格しました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/4i/pe/xc/4ipexciijx7ss998ugl84hr6smi.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、実際には、この全体のストーリーを収集しても、MyComponentがそのようなエラーと一緒にならないため、何も機能しません。実際には、バーコンポーネントに期待するプロップを渡しません。したがって、この場合、子コンポーネントをコンポーネントから正しく呼び出すかどうかなど、チェックする統合テストも必要であるということを話します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8e/aa/zk/8eaazkltwuurjeh7fhef39ovblq.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなコンポーネントがあり、そのうちの1つを変更すると、このコンポーネントの変更がどのような影響を与えたかがすぐにわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enzymeで統合テストを実施する機会はありますか？浅いレンダリング自体は、このような構造を返します。これにはダイビングメソッドが含まれており、Reactコンポーネントで呼び出された場合、失敗します。したがって、それをfooコンポーネントで呼び出すと、fooコンポーネントがレンダリングするものを取得します。これはバーです。もう一度ダイビングすると、実際には、バーコンポーネントが返すレイアウトが取得されます。これは統合テストになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oo/jm/af/oojmafj91rsbbpprnhyqf868qoy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、完全なDOMレンダリングを実装するmountメソッドを使用して、すべてを一度にレンダリングできます。しかし、これは非常に難しいスナップショットになるため、これを行うことはお勧めしません。また、原則として、構造全体を完全にチェックする必要はありません。いずれの場合も、親コンポーネントと子コンポーネントの統合を確認するだけで済みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q9/ud/i-/q9udi-03qar0hjqhxe6th8an6zc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MyComponentには統合テストを追加するため、最初のテストではダイビングだけを追加しました。コンポーネント自体のロジックだけでなく、fooコンポーネントとの統合もテストしたことがわかりました。同様に、fooコンポーネントの統合テストを追加して、barコンポーネントを正しく呼び出します。次に、このチェーン全体を確認します。変更によって、実際にはMyComponentのレンダリングが中断されないことが確認されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/zu/fq/ffzufq_vcw5lmuygnztd0lycvao.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別の例、すでに実際のプロジェクトから。 JestとEnzymeが他に何ができるかについて簡単に説明します。ジェスはモキができる。コンポーネントで外部関数を使用する場合は、ロックすることができます。たとえば、この例では、ある種のAPIを呼び出します。もちろん、単体テストではどのAPIにも入りたくないので、getResource関数をjest.fnオブジェクトでワイプするだけです。実際には、モック機能です。次に、それが呼び出されたかどうか、呼び出された回数、および引数を確認できます。これらすべてにより、ジェストを行うことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z8/lb/ap/z8lbapgq_qzer-1vz3yazx9wo-o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
浅いレンダリングでは、ストアをコンポーネントに渡すことができます。ストアが必要な場合は、そこに転送するだけで機能します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/y2/tl/ih/y2tlihjjqqwogsbftvcirxe_njc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、すでにレンダリングされたコンポーネントでは、状態とプロップを変更できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ew/8g/hc/ew8ghcc6gtv3347yt8ik6o9v6s4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のコンポーネントでSimulateメソッドを呼び出すことができます。ハンドラを呼び出すだけです。たとえば、クリックをシミュレートすると、ここではボタンコンポーネントのonClickが呼び出されます。もちろん、これはすべてEnzymeのドキュメントで読むことができます。これらは実際のプロジェクトからのほんの数例です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tw/kn/9t/twkn9txihstmq5pdpc9yqgc1nnw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アレクセイ：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-最も興味深い質問をします。 Jestをテストし、単体テストを作成し、コンポーネントをチェックし、クリックに対してどの要素が正しく応答しないかをチェックできます。 htmlをチェックすることができます。次に、コンポーネントcssのレイアウトを確認する必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/fw/dj/8p/fwdj8pbfn6ywa4he7ejwjnq6hs4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、テストの原理が先に説明したものとまったく変わらないように、これを行うことをお勧めします。</font><font style="vertical-align: inherit;">htmlを確認すると、浅いレンダリングが呼び出され、htmlが取得されてレンダリングされました。</font><font style="vertical-align: inherit;">私はcssをチェックし、何らかのレンダリングを呼び出してチェックするだけです-何も発生させずに、ツールをセットアップすることなく </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/u-/p2/mzu-p2y3eiblryntol0eelzghtc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はそれを探し始めました、そしてどこでもほぼ同じ答えがPuppeteerまたはSeleniumグリッドと呼ばれるこの全体に与えられました。</font><font style="vertical-align: inherit;">タブをいくつか開き、htmlページに移動してスクリーンショットを撮り、前のオプションと比較します。</font><font style="vertical-align: inherit;">変更されていない場合は、すべて問題ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、1つのコンポーネントを個別にチェックしたい場合、ページHTMLとは何ですか？</font><font style="vertical-align: inherit;">それは望ましいです-異なる状態で。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w2/t0/vn/w2t0vni_fdskrtopftgiigmxows.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態ごとに、コンポーネントごとにこれらのページHTMLの束を書きたくありません。</font><font style="vertical-align: inherit;">Avitoは良い成績を収めています。</font><font style="vertical-align: inherit;">ローマ・ドボルノフがハブレに関する記事を発表し、ところで彼はスピーチをしました。</font><font style="vertical-align: inherit;">彼らは何をしましたか？</font><font style="vertical-align: inherit;">それらはコンポーネントを取り、標準のレンダーを通してhtmlを組み立てます。</font><font style="vertical-align: inherit;">次に、プラグインとあらゆる種類のトリックの助けを借りて、彼らが持っているすべての資産-写真、CSS-を収集します。</font><font style="vertical-align: inherit;">すべてをhtmlに挿入し、適切なhtmlを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0j/yr/zk/0jyrzkzvwzebsx36hos2vvi1uvs.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、特別なサーバーを作成し、そこにhtmlを送信してレンダリングし、結果を返します。非常に興味深い記事ですが、読んで、そこから多くの興味深いアイデアを引き出すことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z5/xp/gb/z5xpgbasgyr6gooqi_dt-p4_mxw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで嫌いなもの。コンポーネントの組み立ては、本番環境への移行とは異なります。たとえば、webpackがあり、ある種のbabelアセットによって収集される場合、そこからは別の方法で引き出されます。シェイクするものをテストしたことを保証できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、スクリーンショット用の個別のサービス。なんとか簡単にやりたい。そして、実際には、私たちが収集するのとまったく同じように収集しようという考えがありました。そして、Dockerのようなものを使用してみてください。それはそのようなものなので、ローカルでコンピューターに置くことができます。シンプルで、隔離され、何にも触れず、すべてが正常です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/9k/nz/hm/9knzhmk3-qivjt6peujxtmjnovw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この問題はページのhtmlに関するもので、実際には同じままです。そしてアイデアが生まれました。このような単純化されたwebpack.confがあり、そこからクライアントjsのある種のEntryPointがあります。モジュールの説明、それらの組み立て方法、出力ファイル、説明したすべてのプラグイン、すべての構成、すべての問題はありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3f/km/ha/3fkmhal86lf6s38oq8rnnhchsdg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私がこれを好きならどうしますか彼は私のコンポーネントに入り、それを単独で収集します。また、コンポーネントは1つだけです。そこにhtml webpackを追加すると、htmlも得られ、これらのアセットはそこで収集されますが、このことはすでに自動的にテストできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、私はこれをすべて書き込もうとしていたが、それから私はこれを見つけた。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hq/ju/0s/hqju0sbemjp1z3ryufas0pk0tfu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jest-puppeteer-React、若いプラグイン。そして私は積極的にそれに貢献し始めました。いきなり試してみたいと思ったら、例えば来てください、なんとかお手伝いできます。実際、このプロジェクトは私のものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のファイルをtest.jsとして書き込みます。プロジェクト全体をコンパイルするのではなく、必要なコンポーネントのみをコンパイルするために、これらのファイルを見つけるために少し個別に書き込む必要があります。実際には、webpack構成を使用します。そして、入力ポイントがこれらのbrowser.jsファイルに変わります。つまり、テストしたいものがHTMLにパッケージ化され、Puppeteerの助けを借りてスクリーンショットを撮ります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3e/jh/fr/3ejhfrfte3ucybs-vvl6ncw28vo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼は何ができますか？彼はスクリーンショットを撮る方法を知っており、別のjest-image-snapshotプラグインを使用してそれらを保存する方法を知っています。そして彼はそれらを比較する方法を知っています。ブラウザで実行できるすべてのことを実行でき、jsを実行できます。たとえば、すぐにmedia-queryをテストできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ヘッドレスモードが気に入らない場合、難しいので、デバッグできません。問題が何なのか理解できず、ヘッドレスモードをオフにすると、通常のデバッガーを備えた通常のChromeが表示されます。普通のウェブコンソールで、そこに座って、気分を害し、何が悪いのかを理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これはDockerで実行できます。このクロムで画像を準備しました。彼は調整されています。 Docker以外をインストールする必要はありません。画像があります。また、Dockerは、MacとLinuxなどで同じスクリーンショットを撮った場合、フォントが少し異なるため、半分のピクセルだけわずかに異なるという問題を解決しています。また、Dockerは常に同じ環境で実行されるため、この問題を解決します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gt/26/zc/gt26zcwy-madcquchbm37l89lwo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがまだできないことは何ですか？彼女は完璧ではありませんが、私は本当にすべてを完成させたいです。簡単です。もうすぐです。前後はありませんが、これらはすべてエミュレートでき、問題はありません。モカはありませんが、作ることもできます。さらに詳しく調べれば、Chromeのどのバージョンでもこれを実行したいと思います。理想的には、Firefoxもそこにドラッグします。これも本当に可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さまざまなスクリーンショットを比較して遊んでみてください。ここでpixelmatchが使用されます。しかし、ハーマイオニーで使用されている私たちのライブラリlookameはより高速に動作する可能性があります。私はこれまでに試しましたが、うまくいくようで、真実はより速く、より優れています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ep/zg/ov/epzgovfoqseh2bj5r7jcr8z0lr0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に例を示します。あなたが思い出すならば、これは私が理想的に欲しかったものです。原則として、その方法が判明しました。ある種のレンダーがあり、ライブラリから別のレンダーを取り出し、そこに通常のコンポーネントを送信します-Enzymeの場合と同じです。つまり、私はReduxを使用して彼に保存することができます。任意のコンポーネント。ビューポートを指定したり、自分で網膜を作成したいことを指定したりできます。次に、比較し、参照スクリーンショットで何が起こったかを確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ln/wh/qu/lnwhqusfy-4mqef59zw0lmnoaus.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがすべての可能性です。基準あり、テスト結果あり彼らは違う？目は全然目立ちませんが、実は違います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ut/l6/xb/utl6xb7objmhjnhozdlamgwzjyk.jpeg"> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のプラス：1つのコンポーネントに対して5〜10のテストを記述し、それらを絶対的な条件でテストできます。セレンはそれを行うことはありません。彼はプロジェクトを収集し、ページをロードし、このページのこのコンポーネントでこの状態をエミュレートする方法を理解する必要があります。実際、すべてをはるかに速く行うことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/md/qr/rf/mdqrrf6ueg73uu25m6wqfihyo3q.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、すでにPuppeteerをドラッグしているので、ボーナスとしてe2eテストを取得しました。つまり、プロジェクトをアセンブルし、テストサーバーに直接移動して、自分の手でe2eテストを作成できます。これは、Seleniumで行ったのとまったく同じです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ナタリア：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-ここでは、私たちが所有していないツールを使用してSelenium Java以外のテストを記述していないことがわかります。ネイティブテストのJSとPuppeteerでテストを作成します。これは、レイアウトテストで使用しているためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは私が個人アカウント用に書いた実際のプロジェクトの例です。初めて両方を試し、2つのテストを書いたときの例もありました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0s/7u/ns/0s7uns7oaxi3dcwuejuhk5kwuoy.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アッパービッグ-SeleniumとJavaで、ロワースモール-JS Puppeteerで。少しすっきりしています。もう18行のインポートがあります。そして、私の意見では、Javaテストよりも非常に美しく、読みやすくなっています。したがって、開発者にJavaとSeleniumでテストを書くように強制するよりも、フロントエンドを記述してそのようなテストをサポートするように教える方が簡単だと思われます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kk/us/pj/kkuspjg5dwwz6h2tuhkwfkssth0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アレクセイ：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-結局何を得たの？開発者は自分ですべてを行うことができます。ロジック、html-layoutをカバーでき、あらゆる状態のcssを素早くカバーできます。さらにe2e。完璧に。さらに、テストはコードの隣にあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sj/wg/58/sjwg58se3lov3vvrskvjjh2pw90.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開発者はすでに、このコンポーネントがテストされ、テストでカバーされていることを知っています。いろいろなことができるので、チェックするだけです。または、テストがない場合は、たとえばテストを追加します。ロジックが多いため、テストはこのコンポーネントのドキュメントとして機能し始めます。どこかに隠されているかもしれませんが、ここではテストがすべてを教えてくれます。このように渡した場合、それはそのようになるはずです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ツールは1つしかなく、同じ条件で作業しているため、開発者がこれをすべて記述すると便利です。</font><font style="vertical-align: inherit;">私たちはgitフック、プールリクエストでテストを実行し、開発者に非常に高速なフィードバックを提供します。</font><font style="vertical-align: inherit;">そして、私たちはグリーンマスターを近づけます-私たちはモノレパを持っています、私たちはあるプロジェクトが別のプロジェクトを壊さないことを確実にするためにそれが必要です。</font><font style="vertical-align: inherit;">感謝。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja459910/index.html">状況：企業は音声アシスタント向けのサービスの開発を急いでいません-リスクは何ですか</a></li>
<li><a href="../ja459914/index.html">SQLインデックスマネージャー-インデックスを最適化および維持するための無料ツール</a></li>
<li><a href="../ja459918/index.html">pwnable.kr 03による問題解決-bof。スタックでのバッファオーバーフロー</a></li>
<li><a href="../ja459920/index.html">「非通信定理」を回避する方法は？時空を超えた情報伝達</a></li>
<li><a href="../ja459922/index.html">ベアリングの振動診断中に振動センサーの信号から高周波ノイズを除去</a></li>
<li><a href="../ja459928/index.html">学生のモバイルアプリ開発への道のり</a></li>
<li><a href="../ja459930/index.html">Pythonインポートの自動化</a></li>
<li><a href="../ja459934/index.html">モバイル＃306開発者向けの興味深い資料のダイジェスト（7月8〜14日）</a></li>
<li><a href="../ja459936/index.html">Visual Studioを操作するための9つのトリック</a></li>
<li><a href="../ja459948/index.html">Horizo​​n Zero Dawnのように物理的に正しい体積雲を実装する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>