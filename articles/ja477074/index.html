<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💸 👴 👩🏿‍🚀 アリアドネのスレッド：JSR-133に恋する方法。Yandexレポート 🌏 🎀 🔣</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="マルチコアプロセッサは一般的です。遅かれ早かれ、実用的なプログラマーはマルチスレッドプログラミングの迷路に入り、そこに生息する「モンスター」と出会う必要があります。この方法をどこから始めればよいか、どのツールやアプローチが勝利を収めるために役立つかについて話しましょう。Yandexの通年のインターン...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>アリアドネのスレッド：JSR-133に恋する方法。Yandexレポート</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/477074/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチコアプロセッサは一般的です。</font><font style="vertical-align: inherit;">遅かれ早かれ、実用的なプログラマーはマルチスレッドプログラミングの迷路に入り、そこに生息する「モンスター」と出会う必要があります。</font><font style="vertical-align: inherit;">この方法をどこから始めればよいか、どのツールやアプローチが勝利を収めるために役立つかについて話しましょう。</font><font style="vertical-align: inherit;">Yandexの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通年のインターンシップ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">将来の参加者にこのレポートを作成し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ました</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/veYXsOlYb2A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-私の名前はセヴァ・ミンコフです。</font><font style="vertical-align: inherit;">私は検索部門のクラウドインフラストラクチャ部門で働いています。</font><font style="vertical-align: inherit;">主にバックエンドを扱います。</font><font style="vertical-align: inherit;">私はさまざまな言語で書いていますが、ほとんどの場合、JavaとJava仮想マシン（JVM）で実行されている言語です。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのチームは、検索、メール、アリスなどの一般に知られているほとんどすべてのYandexサービス、およびすべての種類の内部サービス、仮想マシン、短期のMapReduceタスクと機械学習タスクが起動される内部クラウドを開発しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのクラウドは静的ではありません。会社が成長し、サービスの数と消費するリソースが増えています。そして私たちのチームは、パフォーマンスのスケーリングと改善という課題に直面することがよくあります。これを実現するには、垂直スケーリングを含むすべての利用可能なツールを使用します。つまり、システムの個々のコンポーネントを高速化し、シングルスレッドアルゴリズムを書き換えて、より高速に動作するようにします。私たちは水平スケーリングを行っています。サーバー、プロセッサー、コアなどを追加してパフォーマンスを向上させるために、システムを小さなパーツに粉砕します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、マルチスレッドプログラミングは、この点で私たちに大いに役立ちます。今日は彼について話します-それはどこから来たのですか、なぜそれが関連しているのですか？メモリモデルとは何か、そしてそれは一般的にJavaでどのように表現されるか。アプリケーションをテストし、その正当性を検証する方法のいくつかの実際的な側面に触れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/me/f6/9z/mef69z0p-acv-chewvn7tuhphpk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、この興味深いチャートを見てみましょう。このチャートは、過去40年間のマイクロプロセッサの特性の傾向を示しています。 10-15年ほど前、草がより緑になり、プロセッサがシングルスレッドになったとき、通常のプログラマは正しいシングルスレッドプログラムを書いて、ムーアの経験則に頼ることができました。彼は、プロセッサは2年ごとに2倍高速であると言います。ご覧のとおり、2005年頃のどこかで、さまざまな理由により、マイクロプロセッサのメーカーはマルチコアアーキテクチャに切り替え、論理コアの数を増やし始めました。そして、単一コアのパフォーマンス向上はムーアの法則に従わなくなり、1つのコアの処理能力はよりゆっくりと成長し始めました。これは、通常のプログラマーがこの非常にパフォーマンスの向上を利用する方法に革命をもたらしました並列プログラミングを使わなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
練習しているので、簡単なマルチスレッドプログラムを作成して、それがどのように機能するかを実際に見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rl/tv/gz/rltvgzwhsnhczo7tlpu5otwekuw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例として、レコードを相互読み取りするというかなり単純なタスクを考えてみましょう。最初にデフォルト値（ゼロ）で初期化された2つの共有変数XとYと、2つのストリームがあります。各スレッドは1つの変数に書き込み、別の変数を読み取ります。この場合、Thread1はXに1を書き込み、Yを読み取ります。2番目のスレッドも同じことを行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
単純なJava実装は次のようになります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xz/dw/8g/xzdw8gsz8vr8f2p-0dvtdr1y6qw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ReadWriteTestクラスを作成してみましょう。2つの静的変数XとYがあります。メインメソッドで直接、2つのスレッドThread1とThread2を作成し、スレッドの実行時に実行されるいくつかのラムダ関数をそれぞれに入力します。</font><font style="vertical-align: inherit;">前のスライドのコードをそこに入れて、2つのスレッドを開始します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドが開始する順序は、ある意味では予測できません。</font><font style="vertical-align: inherit;">これは、オペレーティングシステムがスレッドをスレッド化する方法に依存します。</font><font style="vertical-align: inherit;">したがって、異なるバージョンを使用できます。</font><font style="vertical-align: inherit;">これがすべてどのように機能するかを理解しているようです。このプログラムを何度も実行し、出力を集計して、プログラム内でこれまたはその回答が見つかる頻度を確認します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ij/os/e3/ijose3q1hdbyts7brwd31pujhou.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ホイールを再発明しないために、既製のツールを使用できます。これはjcstressと呼ばれ、OpenJDKプロジェクトの一部であるJava Concurrency Stressテストユーティリティです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このユーティリティは、ストレステストを記述するためのフレームワークを提供します。この場合、前のスライドのコードは非常に簡単に書き換えられます。まず、jcstress Testアノテーションをクラスにぶら下げます。これにより、テストスクリプトがユーティリティから見えるようになります。また、Stateクラスを使用してマークを付けます。これは、クラスに変更可能なデータが含まれていることを示しています。つまり、変更されたり、異なるストリームから読み取られたりします。 thread1とthread2の2つのメソッドを宣言し、それらにActorアノテーションを付けます。アクターアノテーションは、メソッドを別のスレッドで実行する必要があることを意味します。 jcstressは、このような各メソッドがStateクラスの1つのインスタンスの別々のスレッドで実行されることを保証します。それらが起動される順序は特に指定されていません。そして、結果はスライドに表示されているII_Resultオブジェクトに書き込まれます。それは考えられます、これは、2つの数値のタプルであり、これは、Cyrilが以前のレポートで説明したDependency Injectionメソッドによってのみ表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストを始める前に、コマンドが与えることができる結論と、r1とr2に追加できる値について考えてみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/na/ik/dn/naikdng1aeysfm7tc0fe7drjbfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、いわゆる交替モデルを使用します。何らかの方法で、読み取りまたは書き込みの各操作は、いくつかの順序で実行されます。これらすべてのオプションを組み合わせて実行し、どのような結果になるかを確認するだけで十分です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/i5/4y/fk/i54yfklqj0mjn1jjhkwhqs8vna0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
イベントの考えられるバリアントの1つが、スレッド2の前にスレッド1が完全に実行されると仮定します。まず、Xに1を追加し、Yからゼロを読み取りました。これは、エントリがないためです。その後、最初のストリームがこれをなんとかやり遂げたので、彼らは1つをYに書き込み、1つをXから読み取りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の答えはゼロ1です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ot/7p/ax/ot7paxx6szikzgwp9xjiusgnfny.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のシナリオは正反対です。ストリーム2がストリーム1より先に実行されました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_r/b5/sg/_rb5sgbawfh8cczgwyz9yzomji8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、1ゼロのミラー結果が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/ft/fi/jaftfi3gbc6cwnliw1nufl66x50.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スレッドとスレッドの実行が完全に混同された場合に同じ結果が得られるオプションが約4つあります。</font><font style="vertical-align: inherit;">たとえば、Xの1つのストリームでユニットを書き留め、2番目のストリームでYのユニットを取得し、1を計算します。</font><font style="vertical-align: inherit;">その後、自宅での練習として、他にどのようなオプションがあるかを確認できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/w2/bf/tr/w2bftrexoxplrdq_v81fuxeoxic.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべての可能なオプションを検討したようですが、それ以上のものはありません。</font><font style="vertical-align: inherit;">ユーティリティを実行して、どのような結論になるか見てみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/8-/2k/p7/8-2kp79h_iv-0il5eo9ftko91ye.jpeg"><br>
<h5><sup><sub><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スライドからリンク</font></font></a></sub></sup></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力はテーブルのようになります。最初の列は、II_Resultで追加した結果（ユーティリティはこのコードを数百万回実行します）と、特定の結果が発生したケースの数を示しています。しかし、おそらくこのレポートは、すべてが非常に単純だったとしたらそうではありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、この結論では、ゼロ-ゼロの結果も確認できます。これは、交替モデルでは説明することが困難です。可能なオプションの1つは、ストリームコードの直接の誰かが行を取得して再配置したことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそれが起こったのか、どうやってそれと共存できるのか考えてみましょう。また、私のマシンでは1対1のオプションが非常にまれにしか見つからなかったことにも注意してください。 1億3千万のパフォーマンスのうち、154のパフォーマンスのみが1対1の結果をもたらしました。逆に、ゼロゼロは非常に一般的で、ほぼ30％のケースで発生します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kw/sb/24/kwsb24gow4nmkjkdtmhzxnnvreo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、皆さんと一緒に見た中間結果をまとめます。まず、メモリを介したフローの相互作用は重要なものであることを理解できました。使用した回転モデルは機能しません。いくつかの再配置が見られました。それは多くの理由で発生する可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、鉄の「相対論的効果」を見ることができます。これは次のように考えることができます。3GHzプロセッサの1クロックサイクルで、光は真空中で約10 cm進みます。プロセッサのメモリへの読み取りと書き込みのプロトコルは複雑で、コア間で値を転送するのに数百クロックサイクルかかる場合があります。したがって、一つのコアは過去を見るように見えることができます。レコードが発生した後の結果ですが、古い値が表示されています。さらに、プロセッサも静止しておらず、場所によって命令を変更できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最新の最適化コンパイラは、同じ順列につながる可能性があります。最大のシングルスレッドパフォーマンスを実現するために、シングルスレッドプログラムの正確性を損なうことがないように、命令をスワップすることもできます。しかし、マルチスレッドプログラムでは、これまでに見てきた興味深い効果が生じる可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして2番目-おそらく主な結論：マルチスレッドプログラムは根本的に決定されないことがわかりました。シングルスレッドのプログラムは、主に入力と出力でいくつかの不変式に依存しており、確定的です。乱数ジェネレーターとユーザー入力が入力パラメーターであると仮定します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは物事を非常に複雑にします：プログラムが何をするかを理解することは困難であり、それをテストすることは困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストの複雑さについては、同じ結果が1億3,000万回の呼び出しのうち154回しか検出されなかったと付け加えることができます。この結果の確率は100万分の1です。本番環境では、これはそのようなバグが数週間後に再現できることを意味します。そして、それはあなたがこれをまったく期待していなかった日曜日の夜のどこかで起こります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/sd/u8/hg/sdu8hgj5xiqhrnnganz3ltxzyp0.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちがどうあるべきか、そして日曜日の夜に舌から平和に眠りたいと思うものについて考えてみましょう。まず、プログラムの動作を予測し、その実行について判断できるツールが必要です。次に、順列と効果に影響を与えることができる言語ツールが必要です。これらは、ハードウェアやコンパイラなどからのものである可能性があります。特定のプロセッサがどのように機能するか、コンパイラが実行できる最適化について、そして略語を使用することについて知りたくありません。それはJavaの世界から来ました。一度書くだけでどこでも実行-すべてのプラットフォームで機能するように、正しいマルチスレッドコードを一度だけ書き込みます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tx/lr/du/txlrdugf3x6nxzxnraij4qn9yzq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちが挙げたこれらの質問と要件は、非常に長い間、開発者と理論家や実務家の心の中で発生してきました。高度な複雑さを伴う複雑なタスクと同様に、抽象的なマシンの概念を導入することで解決されました。私たち全員、高水準プログラミング言語の開発者は、特定のハードウェア用ではなく、そのようなプロセッサーモデル用ではなく、抽象的なマシンを作成します。そして、言語の仕様は、これらの3つの世界を調和させるような方法でその動作を記述するように設計されています。一方では、コンパイラとプロセッサの開発者に最適化を行わせ、すでに特定の言語で記述しているプログラマである私たちに頭脳を軽く吹かせてください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メモリモデルは、この抽象マシンの中心的な位置の1つを占めます。彼女は1つの質問に答える必要があります。あるストリームで変数Xを読み取った場合、最後のレコードのうちどの結果がそこに表示されますか？メモリモデルを形式化する試みは、Java言語で初めて行われ、他のすべてのメモリモデルは後で登場しました。 C ++ 11が、いくつかの変更を加えたJavaメモリモデルのほぼコピーペーストであるとしましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Javaにはいくつかのメモリモデルがありました。当初は、いわゆる「ベル型」のメモリモデルでしたが、Javaで記述し、コンパイラに最適化されたコンパイラの最適化を禁止する両方のプログラマの作業を妨げるため、失敗したと認識されていました。したがって、コミュニティプロセスJSR-133の一部として、最新のメモリモデルが作成されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
仕様の形で聖書があるので、それを調べて、実際に何が起こっているのかを理解してみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3f/w6/qi/3fw6qiwjhoeqgtrdn3jngdqntfs.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何か問題があります。言語の仕様を開いたあなたの手を上げ、そこで何が起こっているかを読んでください。そして、あなたは17.4項の記憶モデルを読みましたか？小さな驚きがあなたを待っています。言語仕様は、基本的にはかなり理解できる言語で記述されています。しかし、メモリモデルは、いくつかの数学的なハードコアでいっぱいです。ギリシャ語のインクルージョン、一連の推移閉包からの多くの数学用語、2つの順序の結合などがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、他に方法はありません。マルチスレッドプログラムを作成するときに信頼できる唯一のことは、仕様です。彼女は読んで理解する必要があります。強くお勧めします。また、仕様書を最初に読んだときは、そういう印象がありました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜそんなに複雑なのですか？私は間違った方法で行ったので、私のように振る舞うようにあなたに非常に警告します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はそれを取って、記憶モデルが何であるかをインターネットで検索しました。 JSR-133 Cookbook for Compiler Writersという本を見つけました。彼女は、コンパイラ開発者がこのメモリモデルを簡単な方法で実装する方法について説明します。問題は、これが1つの特定の実装であり、メモリモデル全体を一般的に判断するために使用できないことです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とにかく、Javaメモリモデルから理解できる主な結論を少し試してみましょう。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ii/tn/by/iitnbypnfohtdb0y3gyxuhv1fea.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチスレッドプログラムが多数実行される可能性があります。私たち自身も前のプログラムの例でこれを見ました。最も単純な例では、すでに4つの結果が得られています。そして、Javaメモリモデルの役割は、これらの実行のどれが正しいか、どれが禁止されるべきかを言うことです。そして、3つのことを仮定します。 1つ目は、1つのスレッドのフレームワーク内で、タスクが疑似順次的に実行されることです。これは、コンパイラーが操作をスワップできること、プロセッサーが命令を並列に実行してスワップできることを意味します。しかし、プログラムの実行による目に見える効果が、直接直接実行された場合と同じになるように、これを行う必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第2に、この言語では、どこからともなく呼ばれる、いわゆる「薄い空気の外」の意味は禁止されています。残念ながら、これを説明する時間はありませんが、コンパイラが実際に変換を実行して、シングルスレッドプログラムではすべてが正しくなり、マルチスレッドプログラムで実行しなかったレコードが存在する場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、メモリモデルでは、変数を読み取ると、デフォルト値が返されるか、別のコマンドによって一度に実行された記録の結果の一部が返されます。そして、残りのアクションは、それらが半順序関係で発生する前に発生する場合、順次として解釈できます。そして今、これが私たちが数学を必要とする唯一の場所です。部分的な関係。これは、変数のすべての読み取り、書き込み操作ではなく、関係によって接続されているためです。反射性、推移性、反対称性の特性があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vq/vp/11/vqvp11dmptcgzyedx4hazndvmeo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでの出来事についてもう少し詳しく話しましょう。最初のルールは、単一のスレッド内のすべての操作をリンクすることです。 Xが1に等しいことを1つのスレッド内に書き込んだ場合、Yは1に等しくなります。 Xでの書き込み操作はYの前に発生することに関連していると主張されています。つまり、XはYの前に発生します。また、いくつかの特別なアクション、いわゆる同期アクションもバインドします。詳しくは、仕様をご覧ください。たとえば、これは揮発性変数の書き込みと読み取り、1つのモニターでのロック/ロック解除、同期ブロックの開始と同期ブロックの終了です。非常に重要な点は、プログラム内のすべての同期アクションが、スレッドが1つずつ実行されているかのように、まったく同じ順序でスレッドを認識することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、発生前にこれらのアクションのいくつかのペアをリンクします。どのスレッド同期アクションが発生するかは関係ありません。たとえば、1つの揮発性変数を渡すことが重要です。仕様によると、たとえば、volatile変数への書き込みは、他の後続のアクションの前に行われます。これは、同期アクションがあった方法を正確に指します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、これらすべての中で最も重要なのは、一貫性の前に発生するルールです。これは、メモリモデルに関する最も重要な質問に答えるだけです。以下のように解釈できます。変数内に読み取り/書き込み操作のチェーンがあり、それらが発生前の関係のチェーンによって接続されている場合、読み取りでは必ずこのチェーンの最後のレコードが表示されます。そこにない場合は、他の値、他のレコード、またはデフォルト値を確認できます。これで、基本的な定義が完了したので、息を吐くことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q6/jv/qq/q6jvqqzesul_tjyflrgcuy8s__4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に理論をテストしてみましょうか？レコードを相互読み取りする例を考えて、変数XとYにvolatile修飾子を追加します。値zero-zeroがもう表示されないという仮説を証明してみましょう。これについては、先に述べたルールをそのまま使用します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
発生前処理を1つのスレッドに配置します。 Xへの書き込みは、Yから読み取る前に、2番目のスレッドで行われます。 Yへの書き込みは、Xからの読み取りの前に発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、Xへの書き込み、Yへの書き込み、Xからの読み取り、Yからの読み取りという4つの同期アクションがあります。これらはいくつかの順序で出現する場合があり、2つの場合でペアが発生する場合があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yz/mu/vr/yzmuvrfkneks1-usipllgsgxanc.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、ストリーム1のXへの書き込みは、ストリーム2のXからの読み取りよりも早く発生します（happens-beforeが発生します）。ここでわかるように、関係はYとは関係ありません。Yからの読み取りの結果は、デフォルト値または2番目のストリームが記録した値のいずれかに戻すことができます。 Xからの読み取り値は常にユニットを参照する必要があります。したがって、私たちの選択肢は、ゼロからワン、ワンからワンです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yc/zi/rm/yczirmhlmh3r0c2whc-g8dpxtvu.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目のケースは、接続が発生した場合です。これは同じことです。Yへの書き込みは、Yから読み取る前に行われます。また、X間に接続はありません。したがって、結果は同じです。1ゼロ、0だけが得られます。理論的には、新しいプログラムの動作を証明できます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ui/zs/7o/uizs7ojlz4smbqktuvisojvjxte.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際に確認できます。テストでvolatileキーワードを取得して追加します。実行して、実際、私たちと一緒にこの値が再現されることはないことを確認してください。したがって、発生前はプログラムの正確さを証明するための非常に優れたツールです。これには、もう1つ興味深い興味深いプロパティがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p8/xp/ao/p8xpaoj1prrfkwto0t3w7unlsli.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まだそのような小さなコードがあるとしましょう。 1つの揮発性変数Xと変数Zは揮発性ではなく、違いはありません。変数XとZにのみ書き込むスレッドが1つあります。 2番目のスレッドは、Xが1の値をとるときに待機し、その後Zを出力します。同様に、同じスレッド内およびスレッド間で発生前の関係を構築できます。レコードが最初のストリームのZで推移的であることがわかります。その値は常にストリーム2で読み取りに到達します。これは、スレッド間でデータを公開するための非常に強力なメカニズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、これらのコードの1つだけがストリームにあると想定しましょう。これは、プットバリューオブジェクトのメソッドの1つです。 2番目のコードは、同じオブジェクトの値を取得するメソッドです。これらのメソッド間の発生前の関係を証明したら、値を発生前に取得する値をドキュメントに書き込むことができます。これは、ブリックからプログラムの大きなブロックを構築するのに役立ちます。これにより、これらのメソッドを使用する場合にのみ、volatileの場合と同じ方法で発生前プロパティを使用できます。それが書かれている標準ライブラリには多くの場所があります-たとえば、gets-before getの値を入れます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/m6/br/hd/m6brhdf3iyak436nje-p-fyrq2a.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、いくつかの結論を導き出しましょう。まず、仕様が複雑です。残念ながら、これは本当にあなたが真実を見つける唯一の場所です。また、メモリモデル自体は、プログラムの正確性を証明するための非常に強力なツールを提供します。マルチスレッドの正確さを検証できるツールはありますが、大きな制限があります。それはフリークにとって本当に贅沢ではないとだけ言ってみましょう。プログラムが紙の上で動作すること、または動作しない可能性が高いこと、および日曜日の夜にだけバグが発生することを証明できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、実際に確認することを恐れないでください。jcstressを使用してください。ユーティリティ自体は別の理由で素晴らしいです。JVM自体がメモリモデルとどのように一致するかをテストするために使用されます。そして、あなたがそれを学ぶのを助けるテストスクリプトのリストがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後に、読んでいただける本をいくつかご紹介します。 1つ目は、モーリスヘルリッチによる「マルチプロセッサプログラミングの芸術」です。それは、以前に何が起こるか、一貫性のある一貫性、線形化可能性などについて多くの理論的基礎を築きます。2番目の本はより実用的です-「Brian GoetzのJava Concurrency in Practice」。これは、ルーチン開発で使用できるマルチスレッド設計パターンのコレクションです。この本は、安全な公開、安全な初期化などについて述べています。私はそれを読むことを強くお勧めします。</font><font style="vertical-align: inherit;">Oracleのパフォーマンスエンジニアで、現在はRed Hatで働いている</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lesha Shipilev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のレポートとブログをご覧ください</font><font style="vertical-align: inherit;">。彼は、Javaマシンが内部でどのように見えるか、どのように機能するかについて多くのことを書いています。そして、JMMに関する一連の講義を行いました。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロマン・エリザロフ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
のブログが読めます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">彼は、私の意見では、ITMOマルチスレッドプログラミングを教えました。</font><font style="vertical-align: inherit;">彼は少し廃れたブログを持っていますが、YouTubeで彼の講義やスピーチを読んだり検索したりできます。</font><font style="vertical-align: inherit;">一般的に、これは非常に適しています。</font><font style="vertical-align: inherit;">ありがとうございます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja477054/index.html">Webastoがモジュール式自動車用バッテリーシステムを発表</a></li>
<li><a href="../ja477058/index.html">Enterprise Agile Russia at Raiffeisenbank 26/11 + Broadcast</a></li>
<li><a href="../ja477060/index.html">DataArtは、サンクトペテルブルク州立大学マトメク校システムプログラミング学部長Andrei Terekhovによる公開講演を主催します。</a></li>
<li><a href="../ja477062/index.html">最適化コンパイラのしくみ</a></li>
<li><a href="../ja477072/index.html">顧客開発、または失敗なく製品を発売する方法？</a></li>
<li><a href="../ja477078/index.html">WebStorm 2019.3：起動の高速化、Vue.jsのサポートの改善、その他の改善</a></li>
<li><a href="../ja477082/index.html">米国議会対ザッカーバーグ：規制当局がFacebookの安定した天秤座に反対している主張</a></li>
<li><a href="../ja477084/index.html">会社の頭脳。パート2</a></li>
<li><a href="../ja477092/index.html">GitHubリポジトリセキュリティツールの概要</a></li>
<li><a href="../ja477096/index.html">5Gは私たちの健康に害を及ぼしますか？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>