<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♈️ 👩🏿‍🤝‍👨🏼 👢 C ++とC＃ 💪🏾 🧢 😙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="誰もが知っているのは、「どちらの言語が優れているか」と主張することほど馬鹿なことはないということです。たとえば、何のために良いですか？さまざまな言語がさまざまなニッチで成功しています-これを考慮せずに決定的な結論を出すことは無意味です。
 
 しかし、これをすべて理解し、C ++対C＃のホリバーを手...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C ++とC＃</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/469467/"><img src="https://habrastorage.org/webt/ud/4s/-_/ud4s-_jhcan8lv7ei9kfabnsszo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰もが知っているのは、「どちらの言語が優れているか」と主張することほど馬鹿なことはないということです。</font><font style="vertical-align: inherit;">たとえば、何のために良いですか？</font><font style="vertical-align: inherit;">さまざまな言語がさまざまなニッチで成功しています-これを考慮せずに決定的な結論を出すことは無意味です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これをすべて理解し、C ++対C＃のホリバーを手配するように依頼した経験豊富なスペシャリストに問い合わせたらどうなるでしょうか。</font><font style="vertical-align: inherit;">多くの興味深い詳細を見つけることができることがわかります。</font><font style="vertical-align: inherit;">「クロスプラットフォーム」という言葉は両方の言語に両方の方法で適用できますが、これは実際にはどういう意味ですか？</font><font style="vertical-align: inherit;">C ++は現在活発に開発されていますか？</font><font style="vertical-align: inherit;">C＃は下位互換性を壊したことがありますか？</font><font style="vertical-align: inherit;">答えは、両方の言語にすでに深く没頭している人には明らかかもしれませんが、そのような人はほとんどいません-そして誰もが新しいことを学びます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++から</font><b><font style="vertical-align: inherit;">セルゲイが</font></b><font style="vertical-align: inherit;">参加</font></font><b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sermp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラトノフ</font></font></b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-C ++ロシア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会議のプログラム委員会委員長</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">C＃側は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリークラコフ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって代表さ</font><font style="vertical-align: inherit;">れました-彼は</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">会議のPCに含まれており、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">DotNetRu</font></a><font style="vertical-align: inherit;">のリーダーの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1人</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">そして、これらの世界の両方が共存しているディスカッションリーダーが</font><b><font style="vertical-align: inherit;">ドミトリー</font></b><font style="vertical-align: inherit;">になりました</font></font><b><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メザステル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesteruk</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<a name="habracut"></a><br>
<img src="https://habrastorage.org/webt/sn/rb/_i/snrb_ie2-dnmplhnbfnl_klnvca.jpeg"><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、同僚。プログラミング言語のトピックに関する非公式の集まりへようこそ。インターネットでは、言語を比較することはできないことを常に思い出しています。そして今日、私たちはあなたができないことを正確に行います：C ++をC＃および.NETと比較し、それらの長所と短所を比較します。自己紹介します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私の名前はアナトリーです。この言語を最初のバージョンから研究してきたので、今日はC＃に溺れます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サーゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">こんにちは、私の名前はサーゲイです。今日はC ++に没頭します。ディマは長所と短所を比較すると正しく述べました。誰もがそれを「プラス」と呼んでいますが、この議論のC＃はマイナスになることがわかっています。そうですか、アナトリー？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃にはさらに2つのプラスがあります！</font><font style="vertical-align: inherit;">したがって、これはすでに時代遅れであり、ほとんどどこでも競争することができない利点の進化的発展だと思います。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/_p/wy/sj/_pwysj2lxe1ncg6lmuzqxfs2dg0.jpeg"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教育</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は私たちの議論の最初のトピックを持っています。</font><font style="vertical-align: inherit;">新しい学生が大学に来ると想像してください、彼らは第一言語を必要とします。</font><font style="vertical-align: inherit;">人々が最初の年に最初に使う言語は何だと思いますか：C ++、C＃、または一般的なアセンブラー？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はしばらく教えていたので、確固たる意見があります。私はここでどの言語がより良いかについて議論するつもりであることを理解しています、そして私はC ++を表します...しかし、C ++を学ぶためには、コンピューターのアーキテクチャーを理解する必要があります。これに伴い、（少なくとも私が教えた大学では）学生を教える際の大きな問題が発生しました。アルゴリズムなどを教えるには、インフラストラクチャに焦点を当てていない、言語自体で何かが必要になるでしょう。ここでエッフェルはこれを試みましたが、魔法もたくさんあります。したがって、私たちの2つの言語はどちらも適切ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングは異なり、教えるのは「プログラミング」ではなく、アルゴリズム、データ構造などです。テーマごとに独自の楽器を選択することは理にかなっている可能性があります。ある種のLispデータ構造を理解してください。そして、C ++はそれぞれ、学生がアーキテクチャについて何かを理解した後に与えられるべきです。そして、なぜこのすべての痛みと苦しみが理解できるかが分かります。プラスが痛みについてであるとさえ主張しません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい、私はオブジェクトを分離する必要があることに完全に同意します。オブジェクトを「プログラミング」に入れず、すべてを1つの言語で処理する必要はありません。しかし、基本、基本、アルゴリズムを学び、ある種の工業用言語を選択し始めるようになれば、もちろん、ここではC＃の方がはるかに優れています。アーキテクチャ、メモリのバイト、およびその他の「手動の日没」のレベルで、これらすべてのかすを学習することを強制するものではないためです。すぐに理解できる言語、簡単な構文を提供し、この言語では1年目または2年目からかなり具体的なお金を稼ぐことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">初心者の生徒にポインターのようなものを与えないことは一種の犠牲であるという議論があります。たとえば、リンクが実際にはメモリ内の変数のアドレスにすぎないことを人が理解していない場合、それらには大きな穴があります。あれについてどう思う？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20年前、これはコンピュータに十分なメモリがない、十分なディスクがないなどの場合に当てはまりました。次に、これらのJavaScriptを見て、500メガバイトのライブラリを各「Hello World」にドラッグします。彼らはどれだけのメモリをとりますか？彼らのパフォーマンスは何ですか？そこでのリンクは何ですか？はい、誰も気にしません。主なことは、製品を素早くロールしてリリースすることです。私はこれが良い方法であるとか正しい方法であるとか言っていません、私はあなたが現実で変える必要があると主張します。多分今あなたのリンクがどれだけかかるかはそれほど重要ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく場所に依存します。私が理解している限り、Dmitryはアルゴリズム取引に興味がありました。彼がJSでライブラリをプルして注文を取引所に送信する方法をはっきりと想像できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええ、もちろん、実際には、このタイプの言語をそこで使用する人はいません。理論的にはこれは可能かもしれませんが、JSインフラストラクチャに弱いお金が投入されていないことを忘れないでください。 JSをあらゆるものにコンパイルするエンジン。多くの人は、この言語をすべての一般的な一流の言語と見なしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然のことながら、アルゴトレーディングは現在、そのような分野から離れた分野ですが、アルゴトレーディングと金融数学は全体として特定の分野です。 C ++を支配しているだけです。そして、それは部分的には慣性によるもので、単に歴史的な理由によるものです。最初は誰もがC ++でしたが、この領域は保守的です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は同意しない。私は今フィンテックで働いており、アルゴリズム取引の最初からここにいる同僚は、最初にJavaで書いた大企業について話します。当初、Javaはアルゴリズム取引に対処していましたが、市場が成長し始め、C ++を使用する競合他社が登場したとき、ある時点で彼らはそれを実行できず、すべてを効率的に実行できませんでした。書いていない人だけが亡くなりました。そのような自然な選択。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、もっと広くすることができます。大規模な銀行でさえ、アルゴリズムをExcelドキュメントに保存する多くの例があります。次に、Excelをサーバーとして使用して、これらすべてを計算します。地味なブレーキがありますが、それはすべて、高頻度の取引（または一般的に高頻度の取引）を行っているかどうかによって異なります。あなたがマーケットメーカーである場合-当然、あなたは高いパフォーマンスを必要とし、そこでビジネスはC ++にさえ限定されていません、そこでハードウェアとHDL言語に行きます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちの議論は、アルゴリズム取引だけでなく、単純なものについてもです。ここで例を挙げます。建設に関連して、さまざまなものを計算するいくつかの小さなアプリケーションを作成する必要がありました。たとえば、家の輪郭の周りにレンガを置く方法などです。そして、UIに関連するすべてのものが弱いため、C ++でそのようなことを行う方法を想像することはほとんどできません。フレームワークはQtだけで、それを書くことさえ非常に困難です。そして、C＃やWinFormsに着席した場合は、すぐにアプリケーションを作成します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、視覚的な部分は常にCの強みでした。マイクロソフトは金型、さらにはクロスプラットフォームの金型、そして一般的には視覚化に多くの投資をしました。したがって、ビジュアルデスクトップアプリケーションの話をしている場合、プラスは一般にはるかにはるかに遅れているように思えます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええと、それはいつものように異なります。</font><font style="vertical-align: inherit;">私は本当にUIは好きではありませんが、プラスの場合は常にそれをしなければなりません。</font><font style="vertical-align: inherit;">それはJSをもたらし、プロと対話するだけのようです。</font><font style="vertical-align: inherit;">しかし、私は組み込みで作業しましたが、それは難しいことです。</font><font style="vertical-align: inherit;">人々はある種の高速で高価なエンジンを購入しましたが、それでもJSで書かれたUIの通常のレンダリングに対応できませんでした。</font><font style="vertical-align: inherit;">そして、これらすべてをQtで書き換えた後、オーバークロックになりました。</font><font style="vertical-align: inherit;">普通の話。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kc/9t/uf/kc9tufwhjjwnla-uga_j8abdwqg.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クロスプラットフォームとクロスプラットフォーム</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで明確にしたかった。 C＃についてはほとんど知りませんが、私は非常に昔、最初のバージョンで自分自身に触れました（当時は下位互換性が失われていました）。だから問題は：それはまだMicrosoftだけによって開発されているのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anatoly：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ、現在はクロスプラットフォームで、オープンで、ISO（ECMA-334およびISO / IEC 23270）の下で検証されています。ちなみに、私の知る限り、C ++にはまだオープンISO仕様がなく、支払い済みです。対照的に、C＃は完全にオープンです。多くの企業（Google、Amazon、Samsungなど）によって開発された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Foundation</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。 C＃とその.NETプラットフォームよりももっとオープンな言語を今でも知りません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええ、ハスケル。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、Haskellの作者はMicrosoft Researchで働いており、C＃にあらゆる種類のクールなものをもたらすために多くの努力をしました-たとえば、静的チェック、ある種のリフレクションなど、プロはおそらく夢にも思いません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らは夢を見ることができ、仕事もこの方向に進んでいます。しかし、すべてに独自の価格があることは明らかです。 C ++では、この価格の支払いを拒否します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どれ？彼らは2時間コンパイルされています、他に何が価格になるでしょうか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C ++では、ゼロコストの抽象化の原則。まあ、つまり、仮想マシンはゼロコストの抽象化ではありませんよね？これには我慢しなければならない。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一方、仮想マシンは、たとえば、特定のアーキテクチャのコードを不明瞭にすることができます。一方、C ++では、AVXのないコンピューターでAVX命令を使用すると、プロセスがシャットダウンします。理論的には-私は強調しますが、理論的には-JITはC ++が利用できないことを実行できるため、この議論は完全に正しいとは言えません。つまり、打ち上げ時の最適化。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、C ++ではコンパイル時に、必要な命令を完全に制御できます。この場合、手で制御するのではなく、計測器（コンパイラ）をあきらめます。見て、このアーキテクチャにはどのような命令があり、どのような命令セットがあるのか​​... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは明らかです。しかし、この方法でそれを定式化することができます。100万のプラットフォームがあるため、異なるコンパイルフラグで100万のバージョンをリリースすることができないため、いかなる理想も得られません。正しく？私たちは通常x86とx64をリリースし、それをすべてのサブグループに分類しません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜできないのですか？ XXIセンチュリー。 Dockerをさまざまなパラメーターで保持するだけです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アプリケーションをダウンロードするエンドクライアントがいるとき、彼は特定のバイナリをダウンロードしたいと考えています。そして、このバイナリでは、私たちができる最善のことはどこにでも固執することです。 「cpuidがまあまあで、avxサポートがまあまあなら、アルゴリズムバージョン25を使用する」のように。その結果、同じアルゴリズムの25の異なるバージョンが必要になります。加速はプラットフォームに依存するため、プラットフォームに依存します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">おそらく同意する。正直なところ、私は社内向け以外の製品を作成したことがありません。私は主に彼ら自身が彼らの製品を使用する会社にいます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろん、最良のオプションは、予想通りにアーキテクチャを知っているときです。この場合、厳密に言うと、x86命令の使用を強制する人は誰もいません。特定のカード（Nvidia Teslaなど）を使用して、好きなことを行うことができます。これも私のアプローチです。私のアーキテクチャを制御しています。しかし、ユーザーのために大衆市場の決定を下すとき...条件付きのReSharperを使用する場合、彼は任意のインデックスに対してGPUアクセラレーションを使用することはできません。 GPUアクセラレーションは移植可能なものではないからです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、アプローチがあります（おそらく、詳細に進む必要はありません）。興味深い人もいます（アプローチの作成者は、Microsoftに移行したようです）。ここ一昨年の会議では、</font><font style="vertical-align: inherit;">そのようなプログラムを書く方法についての</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">報告</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がありました</font><font style="vertical-align: inherit;">。それ自体がどこにあるかを理解します（比較的簡単ですが、ここでも、コストはゼロです）。そのため、オンザフライで選択でき、CUDAスタイルでコードを正しく再構築できます... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、CUDA自体がこの問題を解決しようとしています</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">。CUDAに</font></a><font style="vertical-align: inherit;">は</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">PTXの</font></a><font style="vertical-align: inherit;">中間層があるためです。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">誰がこれをします。しかし、アイアンは進化的に根本的に変化しているため、これは依然として非常に難しく、それに追いつくのは非常に困難です。アドビ製品などでGPUアクセラレーションの使用を見ると、使用可能なテクノロジーの非常に狭いセクションを使用しています。カードが正しい場合-はい、すべてが正しくなります。しかし、それが少しエキゾチックなものである場合、この点に関して何も保証されません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このディスカッションでは、神話というかなり重要なトピックに触れました。C++は何年も前にクロスプラットフォーム言語として宣言されましたが、現時点ではクロスプラットフォームはC＃ではるかに多くなっています。唯一のバイナリは、.NETがサポートされているすべての場所で動作し、これはほとんどすべての場所で動作します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、これも根拠のないことです。私の人生のほとんどを組み込みに費やした人間として、.NETがハードウェアメーカーのツールチェーンによってサポートされることはめったにありませんでした。鉄を生産する企業は、同じG ++またはClangを採用するか、プラットフォームのコードの生成を開始させます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい、しかし問題は彼らがこれをするたびに彼らはC ++から何かを失うということです。たとえば、NokiaはC ++のバリエーションを使用していましたが、C ++には、ひねりの効いたクレイジーなAPIがあり、みんなを激怒させました。つまり、C ++だけでなく、特定のプラットフォーム用のC ++でもあります。そして、問題が始まります。たとえば、同じCUDAを取ります。それはまるでプロがそれ自体を通過させるだけであるかのようであり、それはまったくコンパイラーではなく、単なるドライバーです。しかし、それにもかかわらず、彼女はまだCUDAファイルをGPUとCPUパーツに分割するために何らかのフレームワークを使用しているという事実にギャグを持っています。そして時々彼女は成功しない。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はそれを少しは意味しませんでした。 「.NETがどこでも走る」と聞いたとき、私の伝記のほとんどはリベートです。カスタムプロセッサを搭載したハードウェアを購入すると、G ++デリバリーにバンドルされています。また、通常のC ++があり、ツールチェーンのG ++は、この特定のプロセッサでサポートされるマシンコードに変換できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、これは再び組み立てる必要があります... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もちろんです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、既存のplus codeを取り、それを鉄の部分にドラッグするという考えです。このアイデアも機能しません。通常のx86を突然どこかにドラッグしたため、すべてについてのすべてに8ギガバイトのメモリがあり、向きを変えることができません。たとえば、ディスクとそれにアクセスできないため、ディスクへのスワップはありません。</font><font style="vertical-align: inherit;">これは、移植性について話している場合です。</font><font style="vertical-align: inherit;">当然、目標によって異なります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロはより多くのデバイスで作業します。もちろん、組み込みは最も強力な部品の1つです。</font><font style="vertical-align: inherit;">ただし、通常は、コードを何らかの形でプラットフォームに適合させる必要があります。</font><font style="vertical-align: inherit;">これは悪いです。</font><font style="vertical-align: inherit;">膨大な数のプラットフォーム、アーキテクチャ、モデルを1つのコードでカバーできます。</font><font style="vertical-align: inherit;">プラスに、私は個々のプラットフォームについて考えなければなりませんでした：それがそこからどこから始まり、どのような条件下で。</font><font style="vertical-align: inherit;">そして、それは非常に悪いことです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/f1/wn/1z/f1wn1zxi80gplsj3bpidl9fpr1i.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安定性、互換性、言語開発</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゼロコストの抽象化についても言及されましたが、問題はこれには莫大な価格がかかることです。たとえば、.NETには、列挙型とIEnumerableインターフェイスの概念があります。また、配列などの各タイプについて、イテレータを処理することができます。しかし、C ++ではそのような考えはありません。ゼロコストの抽象化により、コレクションを回避するために、begin（）とend（）のカップルがあり、それらの作業にはルールがあり、これらはすべて非常に複雑です（特にプログラミングを始める人にとって）。これは直接的な問題です：AからZまでの配列を回避する方法。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私があなたが話していることを正しく理解していれば...あるコンテナを最初から最後まで回る必要があるだけなら、今ではPythonのように書くだけです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはすべて素晴らしいです。しかし、たとえば、これにはポリモーフィズムを使用しないでください。ここに私がアプリオリに列挙された特定の値を受け取る関数があるとは言えません。インターフェースを実装する値があるとは言えません。たとえば、このインターフェースにはイテレーターがあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">どのC ++について話しているのですか？ C ++全般、将来のC ++、現在標準として受け入れられているC ++について？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、それが将来のプロになるとしたら… </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ 20では、これはすでに存在しています。あなたはすでに言うことができます、あなた自身を宣言することさえできます。これらはインターフェースではありませんが、どのように正しく言うか...一般に、タイプはそのような条件を満たさなければならないことを宣言できます。たとえば、イテレータを返すbeginとendがあります。イテレータは、標準ライブラリではそのように準備された概念です。彼はそれが何であるかを述べています。イテレータも異なります。一般に、私たちはそれを人々にとってより便利にするために努力しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは、オブジェクトの反復可能という概念なしに生活するのは難しいことを人々が単純に認識したという事実から生じたようです。一般化されたものの書き方がはっきりしないからです。はい、ゼロコストの抽象化とは、検索時にvテーブルを歩き回るコストがかからないことを意味します... .NETには、たとえば特定の方法しかありません。そして、それを見つけるために、当然のことながら、プラスが拒否する努力を費やす必要があります。しかし、使いやすさの観点からは、最終結果はそれほど良くない、と私は言うでしょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然、バランスが必要です。一度にすべてを手に入れることはできません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは何年経ったのか不思議に思います。代替言語は進化し、そのような基本的なものが最初から現れます。今、彼らはより実質的で興味深い何かに追いついています。そして、プラスは10年間同じ理解できない構文、あいまいな抽象化、理解できない松葉杖で開発されていません。あなたはこれをマイナスの一つとして置くことができます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さあさあ！ 「開発が不十分」とはどういう意味ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは委員会について言及しました-C ++にはそれを開発するISO委員会もあります。 Microsoftをはじめ、「私たちがサポートする必要のある多くの遺産があるため、これを行うことはできません」という事実に強く溺れている代表者がいます。ちょうどC ++はすでに保持されている言語です。そしてもちろん、彼女は非常に注意深く歩きます。 （Straustrupで作成時にすでに宣言されている）主なタスクの1つは、Cとの互換性です。しかし、Cはかなり進化しており、互換性のあるCを指定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして私の意見では、C ++は途方もないペースで開発されています。概念などに関して-実際には、反復性からではなく、すべてが成長します。実際、開発はアレクサンダーステパノフ氏の説明にも従います。現在、「一般化プログラミング」と呼んでいるものの著者の1人で、実際にテンプレートやジェネリックなどをC ++にドラッグしました。正直なところ、委員会がこれらのアイデアからどれほど刺激を受けているのかはわかりませんが、それらには間違いなくいくつかの共通点があるようです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これらのすべてのメタクラス、イテレータ-これは本当に何十年も前のインスピレーションです。たとえメタプログラミング、テンプレート、マクロを使ったとしても、これらすべての人々は長い間経験を積んでいて、ずっと単純で、明白で、理解可能な概念があります。他の言語では、これはすべてタイプセーフティ、コンパイル時のチェックなどにより、100万倍高速で実行されます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待ってください、あなたはすでに誰もがお金を払うつもりではない何かについて話しています。私のプログラムが私の知らない間にコンパイル時に何かをチェックしたくありません。わかりますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグ付きのこれらすべてを構成できると思います。最適化レベルを設定すると、チェックされるかどうかが決まります。問題じゃない。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの場合、すべてを手で制御する必要があります。何が起こっているのか正確に把握してください。ツールだから-まあ、それ。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはツールについてでもありません。ここで、DやRustなどの言語は、たとえば、次のように言うという事実：ええ、そうです、配列要素にアクセスすると、それをチェックできますが、チェックできません。そして、それをユーザーに与えるだけです。つまり、「配列チェックをオフにしましょう」、「オンにしましょう」と言うことができます。つまり、この点で何らかの制御が行われます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> RustのようにUnsafeとSafeがあるかどうかは明らかではありません。この場合、たとえばCとの違いはわかりません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いは、安全に書けることと速く書けることです。そしてCでは危険なように書く必要があります。まあ、はい、多分高速です。速度よりも安定性の方が重要な場合があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、このトピックを新しい言語で掘り下げていくと、C ++では一般に人々に伝えるのが非常に困難なことがあります。簡単な質問：intのサイズは？ほとんどの言語で、あなたはこの質問に対する答えを知っています。あなたは言う：intは32ビットです。しかし、あなたは長所を知りません。特定のコンピューターのサイズは覚えているので知っていますが、厳密に言えば、基本的なタイプは決定論的ではないため、使用する必要はありません。そして、intが異なるプラットフォームで異なるように、レガシーアプローチのセットがある場合、そのようなことは私を苛立たせます。そして今、私たちはこれができないことをすでに理解しています。これより先に進んで、なぜかこの問題を解決しないのですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、これは決まっています。ある</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">性感染症</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、固定長の必要な種類が。今委員会でロシアの代表</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可変長</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">の</font></a><font style="vertical-align: inherit;"> intを</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ドラッグし</font></a><font style="vertical-align: inherit;">ます（ここでも、コストの抽象化はゼロです）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドへのポインターのサイズが非決定的であることさえ覚えていますか？つまり、コンパイラやプラットフォームが異なれば、ポインタも異なります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然、これはアーキテクチャです。ハードウェアに近いときに、8ビットで64ビットのポインターのサイズをどのように保証できますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その後、ポインターの演算をどのように行うことができますか？狂ってる。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり？さて、注意してください。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なるほど。アプローチはどこでも明らかで、ハンドルですべてを注意深く制御します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい、そうです。繰り返しになりますが、最近のC ++標準ではアプローチが開発されています...選択について話す場合、実際には、現在のプラスでは、ガベージコレクターを使用するかどうかの選択肢があります。それは、GCが参照カウンターに基づいて構築されているということだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的に、同僚によると、申し訳ありませんが、現代のプラスに関する知識を長い間更新していないと感じています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、プラス神々の神々の一部であるストラストルプのような人々は、現代のC ++を教える方法を理解するために多くの呼びかけを伴っています。問題は、人々が2003 C ++カテゴリで何を考え、同じカテゴリで教えるかです。これに関連して、興味深い新しいプロジェクトやアプローチがあり、モダンなコースがあります-Yandexのメンバーが素晴らしい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を作ったとしましょう</font><font style="vertical-align: inherit;">。そして今プラスで、例えば、純粋な新しいものを使用して削除することは悪いマナーと考え​​られています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知識の更新についてのコメントについて...ニュアンスは、たとえば、私のアプローチは、私にとって確実に機能し、私が「友達」である小さなC ++デルタを使用することです。ご覧のとおり、C ++は広範囲にわたっています。テンプレートのメタプログラミングがあり、すべてがうまくいくでしょう、たくさんの魔法がありますが、残念ながら、この魔法は判読できません。これは、著者以外の人が特別な知識なしに、ある意味でブラックボックスとして理解できないコードです。そして、プラス、暗闇の中で消化できない領域にそのようなブラックボックスがたくさんあります...私は知りたいのですが、あなたのオプションは予想通りにうまく計算され、トリックなしで計算されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も簡単な例は、範囲（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">range-v3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このトピック全体）。一方で、これはすべて素晴らしいことです。たとえば、C＃で数年間使用されてきたものがあるため、たとえば、標準のコレクションの任意の変換によってカレンダーを構築できます。一方、C ++での実装方法は、C＃に比べて単純に不愉快です。重くて読みにくいです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは味付けです。逆に好きです。私が理解しているように、あなたは</font><font style="vertical-align: inherit;">Niblerの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とそのプレゼンテーションを参照</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">してい</font></a><font style="vertical-align: inherit;">ます... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">演算子「または」を使用してコレクションをフィルタリングすると、すぐにこれについて質問があります。 C＃とJavaの両方が、通常のメソッドを介して、ドットを介してすべてを行いました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、これはバッシュに触発されたようです。つまり、単なるパイプです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええ、そうです、それはおそらくこのアプローチの何かを説明しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：それ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はたくさん説明しています！ Bashについて話しているので、PowerShellについて話しましょう。 PowerShellを見たのは誰ですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">優れた言語であるPowerShellで記述します。しかし、繰り返しになりますが、パイプは所定の場所に挿入する必要があり、すべてのアーキテクチャがパイプに浸透します。 1つのアクションを実行する必要がある場所ではなく、ここでは慣用的に悪い構文です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パイプの範囲では非常に... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲では、これらは、私の意見では、次の理由で使用されます...私はこれを言います：C ++で拡張メソッドまたは拡張関数があった場合、もちろんそれらを使用します。コレクションをソートする必要がある場合、最も自然なのは「collection。filter（）」と書くことです。 「コレクション」ではありません。ビュー::フィルター（） "。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20年間脚で撃たれ、顔を殴られ、頭を壁に打ち付けられ、最後に次のように言われたという印象も受けました。「さて、これで20規格ですべてを美しく仕上げました。プロは正しいです。」はい、だれもそれらを正しく教えたいと思わない！つまり、それは長期的な痛みです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">教えないでください。何が問題ですか？ Cで書き込み-トレードして、組み込みで書き込みます。私は反対していません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、プロがまだいる狭いニッチがあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">埋め込みは「狭いニッチ」です...今、私のキッチンを見回すと、たくさんのコンピューターが見えます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">飛行機で飛ぶたびに、「くそー、これらのプラスがすべてをうまく書いてくれるといいな」と思います。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ところで、覚えている限りでは、主にエイダがいます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エイダがそこで支配している、はい。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ところで、最近</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">、素晴らしい記事に</font></a><font style="vertical-align: inherit;">出会いまし</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、さまざまな言語での作者（約10人）が低レベルのドライバー（10ギガビットIntelカード用のネットワークドライバー）を作成しました。 CからSwift、JS、Python、そしてもちろんC＃へ。彼が得たこれらのグラフを見ると、大きなバッチのC＃（起動コストが平準化されている場合）はCおよびRustと同等です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bk/bp/ur/bkbpuriesi98tzgy1eon4cek8vs.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、パフォーマンスについて話している場合、C＃がどこかで非常に劣っているというのは誤解かもしれません。 Federico Luis </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scratched Metal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によるファンキーなレポートもあり</font><font style="vertical-align: inherit;">、プロセッサープロファイラー用にC＃コードを最適化する方法を示しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さて、それは再び始まります。問題は、Java、そのC＃を最適化し始めると、なぜプラスで記述しないのかが不明確になるということです。特定の知識が必要だからです。そして、私には、C＃やJavaなどの言語の利点は平準化されているように見えます-入力しきい値はそれほど高くありません。私が理解している限り、Dmitryが話していたことは、コードの読みやすさ、多くのことの学習、概念の説明が難しいことなどです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">職場では、99％の時間を「通常の」C＃で記述しています-安全で安定していて、常に働いています。そして、時間の1％は、ある種の高速で低レベルのコードを書きたいと思っています。そして、このC＃は私にも許可します。しかし、私の主なツールはまだ安定していて、読みやすく、エラーはありません... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tolya、簡単な例を挙げましょう。ベクトル化です。 .NETでのベクトル化では、System.Numerics.Vectorsがゆっくりと作成されているにもかかわらず、すべてが非常に悪いです。そして、それは例えば私の部分にとって何につながるのでしょうか？市場について調べて.NETの数学ライブラリを購入すると、それはプロで書かれている（完全なラッパー付き）という事実に。 .NETでは、ハードウェアアクセラレーション（AVXなど）へのアクセスが事実上ないため、今は初期段階にあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anatoly：</font></font></b><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">組み込み関数は</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.NET Core 3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">リリースされ</font><font style="vertical-align: inherit;">、</font><font style="vertical-align: inherit;">AVXに直接アクセスできます。彼らはまだ初期の段階にありますが、基本的なものはありますが、残りは非常に感動的です。</font><b><font style="vertical-align: inherit;">ドミトリー：</font></b></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご存知のように、私たちは2019年を庭に持っています。このすべての数学的加速財のユーザーとして、私はこれを待たなかった。その結果、私が何かをすぐに検討したい場合、C＃は候補ではなくなりました。 C ++ライブラリがすでに存在するため。たぶん、これのために時間はすでに失われています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C＃はプラスの方向に動いているように見えます。それは彼らの市場を勝ち取ろうとしています。しかし、プラスはもはやどこにも移動していません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはどこから来たのですか？ 「プラスはどこにも行かない」とはどういう意味ですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2019年に標準にイテレータがあると言われると、ラムダについていくつかの進歩があると思われます... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜイテレータとラムダについて話しているのかわかりませんが、どちらの方法かわかりませんでした石... </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イテレータについてではなく、私はそれを誤解しました。以前に説明した列挙可能なコンテナを意味しました。それまでの間、パターンマッチングを行いました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それはすべて、それが必要かどうかによって異なります。パターンマッチングについて説明します。しかし、これまでのところ、それがプロで必要かどうかについては議論されていません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラスから似たようなコメントがたくさん聞かれます。「他の言語ではすでにこのアプローチやそのアプローチが明らかに存在していますが、すでにうまくいっており、人々はそれを気に入ってソリューションを構築していますが、プラスにしたくはありません。それは慣用的なプラスではないからです。」そして、Javaも同じ穴に落ちたように思えます。 Javaは、「だれもいない。代理人はいない」と述べた。 Javaにはデリゲートの概念はまだありませんが、.NETではこれがすべてうまく機能します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見て、プロはとてもシンプルです。もう一度、委員会に戻ります。ヒントがあります-これらはコンパイラを開発している人々です。そして彼らにとって、「ゼロコストの抽象化」という言葉は、彼らが導くべきものにすぎません。そして「レガシー」という言葉は、残念ながら。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、ゼロコストの抽象化はアセンブラです。一般的にゼロコストの抽象化が必要な場合は、すべてをアセンブラーで記述する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象化はありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラーは、バイナリコードを抽象化したものです。 3世代目ではなく2世代目です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、あらゆる種類の「便利なこと」について、それらを迅速に機能させる方法が明確でないことがわかりました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゆっくりと動作させます。非同期イテレータ、コルーチンなどのすべてのアイデア-Cを使用した.NETでは、yieldキーワードは、いくつのリリースが適切に機能するかを認識しなくなりました。はい、巨大なステートマシンが舞台裏で構築されています。直接的な魔法です。しかしasync / awaitもマジックを構築し、イテレーターで使用します。しかし、誰もがそれを使用し、それは本当に便利です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コルーチン、プラス、こんにちは。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええ、はい、進歩が進んでいます。しかし、コルーチンは10年前ではなく、現在登場しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">もう一度。プラスは古く、私の意見では、コードベースの蓄積により開発速度は低下します。明らかに、それはすべて、レガシーサポートを維持したいかどうかにかかっています。プロにとって、これは原則的な立場です。つまり、80年代に記述したコードは、最新のコンパイラーによってコンパイルされています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい。ただし、最新のコンパイラを使用してC＃1.0で記述したコードをコンパイルします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは真実ではありません。ディスカッションの冒頭で、初期のバージョンの.NETにアップデートが届いたと言いましたが、突然すべてのプログラムが動作しなくなりました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用したAPIが変更された可能性があります。ここでは、ライブラリとプログラミング言語を分離する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は何も持っていませんでした。私は若かった、これらは最初の年でした。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はC＃4で1つの重大な変更のみを覚えています-foreachの動作のわずかな変更。もちろん、バージョン1.xではすべてがより乱暴になる可能性がありますが、今は誰かが突然何かを壊したときの段階ではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、公式には、後方互換性を厳密に監視するという立場を堅持しており、膨大な数のマシンとコードベースで新しいバージョンをテストしています。おそらくあなたはバグかそのようなものを持っていました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般に、.NETは下位互換性も監視しますが、進行速度はC ++とJavaの両方で飛躍的に向上しました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは大きな役割を果たしたように思われます。最初はすべてこれが1つの会社によって推進されていたからです。 C ++はもともと委員会に属していたため、これは政治であり、誰もが決定を押し進めようとしており、これはスターウォーズでの上院会議のようなものです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それで、あなたの主張は、私たち全員がイノベーションによって動かされない委員会の人質であるということですか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は、すべての人を満足させるソリューションを選択しないことです。このツールは非常に広く配布されているため、多くの企業で使用されています。あなたが覚えていたのと同じコルーチン：なぜ彼らは遅れてそれらを受け取ったのですか？ MicrosoftはGoogleに同意できなかったようです。 2つの実装がありました-スタックフルの背後にいる人とスタックレスの背後にいる人を覚えていませんが、同意できませんでした。どちらの会社も大規模であるため、すでにソリューションが含まれている巨大なコードベースがあり、それらを書き換えることを拒否しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読者の観点から、1は企業の利益があるので、それらはinterloversに従事している、そしてすべてこれはあなたの心配していないようだ、彼はスパッツ高い鐘楼から上にあったという感覚を得るだろう-外出先、lackeysは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「ケーキを食べればいいじゃありません」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは正反対です。委員会は、一般の人が苦しむ必要がないように選択しようとしています。そして、それはしばしば困難です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええと、私はゼロコストがどこかにまっすぐ行っても苦にならないと私は言うことができますが、バイナリツリーに沿って歩き、時間変数なしでさまざまな方法で反復する、ある種の柔軟な機会があります。ステートマシンなどをドラッグするyieldキーワードが突然表示された場合は、これからの準備ができています。これにより、数マイクロ秒で失うものよりもゲインが大きくなることがわかっています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はい、選択肢があり、この選択肢を使用できるのは素晴らしいことです。高床式の歩行を強制される人は誰もいませんが、いくつかの機会を仮想的に実現できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">選択が必要な場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブーストがあり</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、言うには。</font><font style="vertical-align: inherit;">Boostを使用していますが、使用するのは良いことですが...まず、ボックスからツールを見ていきます。</font><font style="vertical-align: inherit;">タイプstd ::文字列が私に与えられ、私はそれに何が入っているかを調べます。</font><font style="vertical-align: inherit;">サイズ（）と長さ（）の両方があり、私はすでに認知的不協和音を持っています。なぜ2つなのか、なぜ1つを特定することが不可能であったのですか。</font><font style="vertical-align: inherit;">そして、誰かが現れてレガシーがあると言って、戻ることはできません。</font><font style="vertical-align: inherit;">もちろん、これは少し悲しいことです。</font><font style="vertical-align: inherit;">そして、これは私には思えますが、中立的な立場を決して見つけることができない問題です。</font><font style="vertical-align: inherit;">舌を壊すことができないという事実から始めると、誰かが間違いなく使用するかなりクレイジーなものがたくさんあるからです。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nh/k7/cd/nhk7cdikdhqxbdfj52qibe_pybo.jpeg"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイル</font></font></h2><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このトピックから少し離れて、平凡なコンパイル速度など、他の差し迫った問題について話しましょう。これについて何と言えますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「コンパイル」ボタンをクリックするとすぐにお茶を作ることにプラスした印象がありました。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何かが起こる可能性があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anatoly：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">組み込みデバイスでも、100万個のマクロをそこに含めることができますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあ、それはコンパイルアーキテクチャに依存していません。組み込みでは、通常、クロスコンパイルします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええと、それがなぜなのか私たちは皆理解していますか？何も設定されていないバイナリを作成します。インストールには今どれくらいかかりますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">徐々に減少します。以前は150メガバイトでした。これで何とかしてすべてを細かく切ることができます。これは長い議論です。それは良くなります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はすべてについて良くなっているというプロについて言うことができます！</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Steamで購入するコンピュータゲームの重量は、たとえば64ギガバイトです。教えてください、彼らはここで150メガバイトの天気を作りますか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええ、おそらくそうではありません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">また、毎分コンパイルし、週に1〜2回製品を展開します。なぜ毎分コンパイルレベルで展開時間を最適化するのですか？非常に迅速にコンパイルしたいのですが、特定のプラットフォーム用にビルドしたら、はい-最適化して、最適なゼロコストの抽象化などを挿入します。しかし、なぜ毎秒支払う必要があるのでしょうか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は毎秒本当に理解していません。アプリケーションの使用方法は毎秒支払うだけのようです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり、コンパイルは高速であるべきです。それは可能な限り最適化されるべきではなく、快適に開発するためには高速でなければなりません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さて、ここでも、これがLegacyであると言えるようになりました。プラスは遅いコンパイルです-はい、私はそれについて議論しません。今、より実用的なアプローチがありますが、肯定的なアプローチは道徳的に時代遅れです。しかし、何も壊すことなく今それを行うことは非常に困難です。さて、今はモジュールがあるでしょう、私は願っています。レガシーコードに関する多くの問題。そして、それはすべてCから成長します</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。Dmitry：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは別の問題です。 「モジュール」のようなアプローチがあります。そして、私は私の鐘楼から言うでしょう：みんな、私たちはモジュールに切り替えており、マクロはもはやサポートされなくなります。さらに、次のバージョンからみましょう。モジュールをオンにすると、マクロはどこでもグローバルに無効になります。それが私のアプローチです。残念ながら、そのような劇的なステップについては誰も考えていません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜ、彼らはそれらについて考えます。しかし、それらは委員会によってサポートされていません。おそらく理由があります。しかし、私はあなたに提案をすることを勧めます。これはすべて開いています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これは破滅的な提案だと私たちは理解しています。そして、誰もが突然「書き直す必要がある」と言いたくないという理由で運命づけられています。たとえば、マクロがSTLで使用されている場合、それらを取り除く必要があります。誰かが強い意志を持って決断し、座ってすべてのマクロを取り除くことが必要です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STLはサイズが小さいので問題ありません。 STLは頻繁に書き換えられます。これが良いか悪いかはわかりませんが、最近STLがやり直されました。外部からは見えない多くの変更ですが、内部ロジックが変更されています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さて、あなたは見て、そして残りの部分-残りの部分が炉の中にあるとなぜあなたは言うことができないのですか？モジュールが必要な場合は、グリーンフィールドしかありません。ブラウンフィールド開発は行わず、新しいプロジェクトのみを行います。新しいプロジェクトはモジュールのみを意味します。古いプロジェクト-モジュールなし。できないの？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">委員会はそれは不可能だと考えています。そのような話がありますが、実際には、実験的なバージョンはそのように動作します。完全にシャットダウンするほど急進的ではありません。モジュールでは、問題は正確に言うとマクロにあり、それぞれが独自に溺れています。独自のG ++、独自のClang。代表的な民主主義の価格。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし、ここでは、決定が根本的である可能性を誰もが認めているわけではありません。 「後続のバージョンはAまたはBのいずれかになるように配置されます」と言います。私にとって、彼の時間の一部を.NETで過ごす人として、マクロをモジュールにドラッグするという考えは、本質的に異常なものです。類推して、それらをモジュールにドラッグする代わりに、個別のテキストファイルを作成し、そこにエクスポートされたすべてのマクロを配置して、それがすべて同じだと言ってみませんか？</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際、あなたは新しい言語を作ることを提案しているからです。同意します、それはすでにC ++ 2.0です。または++ C ++。 C. </font><b><font style="vertical-align: inherit;">ドミトリー</font></b><font style="vertical-align: inherit;">に関連するように、彼はプラスに関連します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いいえ、ここでは同意しません。ここでは最終的に言語については説明しないので、コンパイラー、コンパイル技術について説明します。 #includeの代わりに、おそらく手順が適用されるという事実は、＃importまたはそのようなものになります-それはすべて二次的なものです。コンパイラーがこの問題について突然意見を持つようになることを話し合っています。そして、どうやら、たとえば、モジュール内のマクロについて特別な意見を持つコンパイラーを作ろうとは言いたくないでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの時代は終わりました。読者が興味深いと思う場合は、後で別のディスカッションを手配することができます。それまでの間、C＃とC ++での状況の見方、将来の見方、今日の議論の印象について、同僚の皆さんに短い締めくくりをお勧めします。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナトリー：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラスで彼らは今10年前に現れるはずだったものをやっているという印象を受けました。すべてが非常に遅く、非常に困難であり、本来あるべき形になるという事実ではありません。通常、すべてが非常に冗長で、プログラマーにとって不便です。そして、これらはすべてLegacyに「歴史的に」減らすことができますが、エンドプログラマはそれについて気にしません。彼は自分の作品を楽しみたいと思っていますが、今ではプロで楽しむのは非常に困難です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃は、C ++から簡単に移行できるように設計されています。あなたがプロを知っているなら、あなたはC＃に切り替えることはまったく問題ではありません。しかし、ほとんどすべての問題を忘れ、最悪のものを捨て、最高のものを残します。そして、あなたは新しい言語、新しいプラットフォーム、動的に発展する理解可能なプログラム委員会、コンパイラー、新しいJITを持っています-あなたが誇りに思うことができるすべて、毎日ニュースを楽しみ、いくつかの失礼な小さなことを心配しないでください（あなたのintサイズは何ですか） 。特にどの言語を学ぶかを考えているだけの学生にとっては、選択はかなり明白なはずです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セルゲイ：</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ええと、私が聞いたところによると、C＃プログラマーは彼らの仕事に直接誇りに思うことは何もありません。あなたはプログラム委員会の仕事に誇りを持つ必要があります。これは、C ++で書くのが良い理由を説明するだけだと思います。それは難しいことであり、あなたは常に結果を目にします。プラス（私が知っていることから）は通常最先端です。私たちが正しく言ったように、人はC ++でUIアプリケーションを作成しません。今、これは単に必要なニッチではありません。そしてC＃でお願いします。 C ++では、高速に動作するコードを記述します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして私たちも、それを開発している私たちの委員会に従っています。すべてが迅速かつ迅速に開発されていること、および最新のC ++があなたが見たものとどのように異なるかを伝えることができなかったことを後悔しています。問題があることも明らかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、C＃がクロスプラットフォームであり、Microsoftから独立していることを理解できませんでした。</font><font style="vertical-align: inherit;">彼らが.NET Foundationについて言ったことにもかかわらず、常に、誰がMicrosoftについて何をしたのかについての話が常にありました。</font><font style="vertical-align: inherit;">すべての卵を1つのバスケットにどれだけ入れたいかは明確ではなく、1つの会社に依存しています。</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この投稿は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++ロシア</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext会議</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の支援を受けて作成されました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最後に、調査：何をサポートしますか？</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja469457/index.html">エクストラバガンザが導くところ</a></li>
<li><a href="../ja469459/index.html">スマートシティでのIoTデバイスの接続</a></li>
<li><a href="../ja469461/index.html">「星へ」：反宇宙「今日の黙示録」</a></li>
<li><a href="../ja469463/index.html">自然言語処理の傾向と予測</a></li>
<li><a href="../ja469465/index.html">最新のC ++での初期化</a></li>
<li><a href="../ja469471/index.html">ソートについて語る「5セント」</a></li>
<li><a href="../ja469475/index.html">最新のWebを形作った迷惑なプラグイン、Flashの盛衰</a></li>
<li><a href="../ja469477/index.html">AppleがiPadとPCの比較をやめるべき時</a></li>
<li><a href="../ja469479/index.html">量子確率はどこから来るのですか</a></li>
<li><a href="../ja469487/index.html">GNU / Linuxでのトップの構成</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>