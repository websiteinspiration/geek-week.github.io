<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚱 👩🏼‍🚀 👨🏾‍💼 弱堆排序 👸🏾 🐠 🗯️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在整个动物园堆中，这种结构也许是最不寻常的。同时，该算法的优雅简洁性与其惊人的偏心率非常匹配。
 
 使用弱堆进行排序时，总是比使用常规堆进行的比较和交换少。因此，是的，弱桩比普通桩要坚固。
 本文是在EDISON的支持下编写的。
 
 我们从事嵌入式软件的开发以及Web应用程序和站点的开发。
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>弱堆排序</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/499786/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><div style="text-align:center;"><img width="765" height="430" src="https://habrastorage.org/webt/hh/ve/rt/hhvertyrtwsbd99rbboihxxyjjk.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在整个动物园堆中，这种结构也许是最不寻常的。</font><font style="vertical-align: inherit;">同时，该算法的优雅简洁性与其惊人的偏心率非常匹配。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用弱堆进行排序时，总是比使用常规堆进行的比较和交换少。</font><font style="vertical-align: inherit;">因此，是的，弱桩比普通桩要坚固。</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" title="EDISON软件-网络开发"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON软件-网络开发"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本文是在EDISON的支持下编写的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">嵌入式软件</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发以及Web应用程序和站点</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">开发</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们喜欢算法理论！</font><font style="vertical-align: inherit;">;-)</font></font></blockquote><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱桩</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常规堆是一个排序树</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其中任何父项大于（或等于）其任何后代。</font><font style="vertical-align: inherit;">在弱堆中，此要求被削弱了-仅从其右子树开始，任何父项都大于（或等于）任何后代。</font><font style="vertical-align: inherit;">在左侧的子树中，后代可以比父代小一些，也可以更大一些，那真是太幸运了。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="299" src="https://habrastorage.org/webt/by/f6/ef/byf6efzj8swlst2y_2dvb7onduu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种方法可以显着降低将数据集保持在堆状态的成本。</font><font style="vertical-align: inherit;">毕竟，有必要确保“后代只不过是父母”这一原则不适用于整个结构，而只适用于其一半。</font><font style="vertical-align: inherit;">同时，不是100％排序树的弱堆排序不会比普通堆差，并且在某些方面甚至更好。</font><font style="vertical-align: inherit;">完成了一半的比赛-大胆行走！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于堆的根，即使是弱堆，也恰好需要最大的元素，因此左子树的根不需要。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽量减少比较次数</font></font></h2><br>
<img align="left" width="215" height="199" src="https://habrastorage.org/webt/ng/cu/e1/ngcue1zei7olyudhfpge5blkcgu.jpeg"><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
算法和图论专家Ronald D.Dutton在1993年向我们展示了一个薄弱环节。</font><font style="vertical-align: inherit;">概念上较弱的堆比普通堆更难理解（但这种困难很可能不是复杂的，而是奢侈的，您必须通过膝盖来破坏意识模式），因此它没有得到太多实际的分配。</font><font style="vertical-align: inherit;">但是，当达顿（Dutton）发明这种结构时，他不仅想练习抽象，而且还追求一个完全务实的目标。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有一个理论上的下限来估计比较的最小数量（在这些比较被广泛使用的排序中）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">！</font><font style="vertical-align: inherit;">= </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / ln 2 + O（log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其中1 / ln 2 = 1.4426 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在按弱堆进行排序时，比较次数被最小化并且足够接近下限。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您需要安排比较成本很高的对象（例如，涉及对长字符串进行排序），那么这可能具有实际意义。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">杂耍后裔</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
弱堆中的“左”和“右”是一种情况现象。子树可以是其父节点的左后代或右后代-而且，子树的这种“左/右”关系，并且在此过程中父级可以反复从一个值切换为相反的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要为有他的右儿子和他的左女儿的父母做指示并不简单，但是非常简单。为此，对于具有后代的那些节点，您需要一个附加的位图（仅包含0/1值）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
回想一下第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个父元素</font><font style="vertical-align: inherit;">的索引</font><font style="vertical-align: inherit;">，我们定义了它在常规堆中的左后代和右后代的索引（数组的索引从零开始测量）：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左后代2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右后代2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 2</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在弱堆中，我们在蛋糕上有一个樱桃-根只有右子树，因此我们将反向移位添加到1位置，以调整后代索引的这些公式：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左后代：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
右后代：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 1 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后需要额外的位图（称为</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），其中</font><font style="vertical-align: inherit;">第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素是在其左子树和右子树之间是否进行交换。如果元素的值为0，则没有交换。如果值为1，则左，右子级的顺序相反。并且在这种情况下的公式如下：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左后代：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ]</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
右后代：2× </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> +1- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ] </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是它的外观。</font><font style="vertical-align: inherit;">其后代位于“反之亦然”的元素以蓝色突出显示。</font><font style="vertical-align: inherit;">它们</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组中的值为</font><font style="vertical-align: inherit;">1。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="330" src="https://habrastorage.org/webt/h0/by/bm/h0bybmjxpw21mdj1x3uyamtsyk4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以通过在后代公式中</font><font style="vertical-align: inherit;">从</font><b><font style="vertical-align: inherit;">BIT</font></b><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">中替换父值</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和相应的0/1来进行检查</font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">后代</font><font style="vertical-align: inherit;">的索引将根据需要显示。</font><font style="vertical-align: inherit;">
如您所见，对于任何父代来说，在数组本身中交换左右子树，都不需要将元素组移动到任何地方。</font><font style="vertical-align: inherit;">仅</font><b><font style="vertical-align: inherit;">切换BIT</font></b><font style="vertical-align: inherit;">数组中父级的0/1值即可</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">
接下来-一场魔术，其后的曝光。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">建立弱桩</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
左右交换是将数组中的一组数据转换为弱堆的主要工具。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在形成主要的弱堆的过程中，我们需要以相反的顺序（从最后一个开始）对数组的元素进行排序，并为每个元素找到第一个（正确的）父代的分支，对于它来说它将是正确的子树。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果元素是某人的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正确后代</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么您不必走太远。</font><font style="vertical-align: inherit;">它的直接父项是您需要的：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/tg/_4/01/tg_401fvyqumg-j_nbwm1-n_bna.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果该元素是某人的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左后裔</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么您需要先达到多个层次，然后再遇到所需的祖父母，该元素位于右侧的子树中：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="304" src="https://habrastorage.org/webt/lk/ud/-f/lkud-fixce2hbm1d7ejuil3pnh8.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后，您需要比较后代和上方找到的祖先。</font><font style="vertical-align: inherit;">如果后代大于祖代，则必须执行以下操作：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果后代有其后代，则交换其左和右子树（即</font><font style="vertical-align: inherit;">，此元素</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阵列中切换0/1 </font><font style="vertical-align: inherit;">）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换后代节点和祖代节点的值。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
看一个具体的例子。</font><font style="vertical-align: inherit;">假设发生了以下情况：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/8f/-8/kr/8f-8krbczd6kxh2o-cbbe4hdkdc.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于数组</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6] = 87 </font><font style="vertical-align: inherit;">的元素</font><font style="vertical-align: inherit;">，找到了必要的祖先</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1] = 76。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
祖先</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [1]小于元素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]（76 &lt;87）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
元素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]具有左右子树（以绿色阴影标记）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要交换这些子树</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（即，对于</font><b><font style="vertical-align: inherit;">BIT</font></b><font style="vertical-align: inherit;">数组中的</font><font style="vertical-align: inherit;">元素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]，</font><font style="vertical-align: inherit;">将值从0更改为1）。</font><font style="vertical-align: inherit;">
也有必要交换元素</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6]和</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [1]的值。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
完成必要的操作后：</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/zy/fb/vb/zyfbvbqsvoyyidown3ljp5pe8mk.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于元素</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [6]，交换了左和右子树</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（即，在</font><font style="vertical-align: inherit;">元素</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6] </font><font style="vertical-align: inherit;">的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数组</font><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">，值从0更改为1）。</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [6]和</font><b><font style="vertical-align: inherit;">A</font></b><font style="vertical-align: inherit;"> [1] </font><font style="vertical-align: inherit;">
之间也进行了价值交换</font><font style="vertical-align: inherit;">。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您从头到尾遍历整个数组，并一路对所有元素执行此过程，那么最终将得到一个弱堆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么这种奇怪的机制起作用，这是本文结尾处的一个解释。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解析弱堆</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果最大元素位于根，则堆就是堆。利用这个事实，所有堆排序都以相同的方式进行。根（最大值所在的位置）与数组未排序部分的最后一个元素交换值-结果是，数组未排序部分减少，数组的排序部分增加。交换之后，该堆不再是堆，因为当前的最大元素不再在其根中。需要恢复堆，也就是说，将生成的树再次变为堆-找到另一个最大元素并将其移到根。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们知道如何在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">筛子的帮助下</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恢复常规的二进制堆</font><font style="vertical-align: inherit;">。但是如何恢复弱堆呢？为此，请执行以下操作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从根开始，我们沿左后裔下降（从右至上）。</font></font><br>
<br>
<div style="text-align:center;"><img width="609" height="339" src="https://habrastorage.org/webt/ka/d1/t8/kad1t8a7egmsgtgrpuqk6txqajc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
然后我们将左后代上移，然后将每个左后代与堆根中的一个元素进行比较。</font><font style="vertical-align: inherit;">并且如果下一个左后代大于根，则我们与上一阶段相同：在左后代我们交换子树（如果他有一个子树）并更改左后代和根的值。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，我们将还原弱堆-其余树中的最大元素将在其根处弹出。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
再次，我们有这个神秘的轮播，其子树可以互相替换。</font><font style="vertical-align: inherit;">那么成功的秘诀是什么？</font><font style="vertical-align: inherit;">为什么在交换带有值的节点时，下层节点的左后代和右后代互换了，我们最终得到一个排序数组吗？</font><font style="vertical-align: inherit;">尽管答案很简单，但您永远也不会猜到。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱堆排序::弱堆排序</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，最终的算法是：</font></font><br>
<br>
<ul>
<li><b>I.     :</b><ul>
<li><b>I.1.</b>    -.</li>
<li><b>I.2.</b>           «» .</li>
<li><b>I.3.</b>       .</li>
<li><b>I.4.</b>       , :<ul>
<li><b>I.4..</b>   ( ⇔ )     ,     .</li>
<li><b>I.4..</b>    «»      .</li>
</ul></li>
</ul></li>
<li><b>II.            ,     :</b><ul>
<li><b>II.1.</b>           .</li>
<li><b>II.2.</b>             .         .</li>
<li><b>II.3.</b>        ,        .   :<ul>
<li><b>II.3..</b>          .</li>
<li><b>II.3..</b>        ,      .</li>
<li><b>II.3..</b>     ,    , :<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.1。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将子树与子树交换（左⇔右）子树，以替换当前左子孙所在的节点。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.3.c.2。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们使用当前的左子节点更改堆根和节点。</font></font></li>
</ul></li>
</ul></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">II.4。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱堆的根再次是数组其余未排序部分的最大元素。</font><font style="vertical-align: inherit;">我们回到第II.1段，重复该过程，直到所有元素都被排序为止。</font></font></li>
</ul></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
动画（我的动画中的数组索引以1开头）：</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/1l/ay/j-/1layj-xmzm4dl7p5yv7_5iag5pa.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++代码</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在“链接”部分的底部，有兴趣的人可以熟悉C ++中这种排序的实现。</font><font style="vertical-align: inherit;">在这里，我仅给出说明算法本身的部分。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GETFLAG(r, x) ((r[(x) &gt;&gt; 3] &gt;&gt; ((x) &amp; 7)) &amp; 1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TOGGLEFLAG(r, x) (r[(x) &gt;&gt; 3] ^= 1 &lt;&lt; ((x) &amp; 7))</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapMerge</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *r, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>{
  <span class="hljs-keyword">if</span> (wheap[i] &lt; wheap[j]) {<span class="hljs-comment">//""  ?</span>
    <span class="hljs-comment">//  ,   </span>
    <span class="hljs-comment">//( "",   "")</span><font></font>
    TOGGLEFLAG(r, j);<font></font>
    <span class="hljs-comment">//  ""  </span><font></font>
    swap(wheap[i], wheap[j]);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">WeakHeap::WeakHeapSort</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">int</span> n = Size();
  <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">1</span>) {<font></font>
		<font></font>
    <span class="hljs-keyword">int</span> i, j, x, y, Gparent;
    <span class="hljs-keyword">int</span> s = (n + <span class="hljs-number">7</span>) / <span class="hljs-number">8</span>;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> * r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> [s];<font></font>
		<font></font>
    <span class="hljs-comment">//  ,    </span>
    <span class="hljs-comment">// "",   ""</span>
    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">8</span>; ++i) r[i] = <span class="hljs-number">0</span>;<font></font>
		<font></font>
    <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) {<font></font>
      j = i;<font></font>
      <span class="hljs-comment">//    , </span>
      <span class="hljs-comment">//   ""  </span>
      <span class="hljs-keyword">while</span> ((j &amp; <span class="hljs-number">1</span>) == GETFLAG(r, j &gt;&gt; <span class="hljs-number">1</span>)) j &gt;&gt;= <span class="hljs-number">1</span>;
      <span class="hljs-comment">//       ""  </span>
      Gparent = j &gt;&gt; <span class="hljs-number">1</span>;
      <span class="hljs-comment">//  ,   </span>
      <span class="hljs-comment">//   ""</span><font></font>
      WeakHeapMerge(r, Gparent, i);<font></font>
    }<font></font>
		<font></font>
    <span class="hljs-comment">//      --&gt;</span>
    <span class="hljs-comment">//  --&gt;    </span>
    <span class="hljs-keyword">for</span>(i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; --i) {
      <span class="hljs-comment">//      </span>
      <span class="hljs-comment">//       </span>
      swap(wheap[<span class="hljs-number">0</span>], wheap[i]);<font></font>
      x = <span class="hljs-number">1</span>;
      <span class="hljs-comment">//    "" </span>
      <span class="hljs-keyword">while</span>((y = <span class="hljs-number">2</span> * x + GETFLAG(r, x)) &lt; i) x = y;
      <span class="hljs-comment">//  ""     </span>
      <span class="hljs-comment">//        </span>
      <span class="hljs-keyword">while</span>(x &gt; <span class="hljs-number">0</span>) {<font></font>
        WeakHeapMerge(r, <span class="hljs-number">0</span>, x);<font></font>
        x &gt;&gt;= <span class="hljs-number">1</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">//  -   </span>
    <span class="hljs-comment">//    </span>
    swap(wheap[<span class="hljs-number">0</span>], wheap[<span class="hljs-number">1</span>]);
    <span class="hljs-keyword">delete</span>[] r;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我特别喜欢如何使用按位运算轻松自然地遍历二叉树。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">额外的内存复杂性</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
似乎O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）-需要一个附加数组，其中对于具有后代的节点（该数组中大约有一半的节点），左/右子树的顺序是固定的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，有一种观点认为这里的排序复杂度实际上是O（1）！</font><font style="vertical-align: inherit;">对于一个元素，我们仅需要一个附加位（零/一）来指示后代的顺序。</font><font style="vertical-align: inherit;">例如，如果我们对字符串进行排序，那么将这个额外的位附加到元素本身是很可行的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）转换为O（1）的</font><font style="vertical-align: inherit;">另一种方法</font><font style="vertical-align: inherit;">是将标记存储为整数。</font><font style="vertical-align: inherit;">数字的二进制扩展-一组零和一个负责数组所有元素的子树的顺序。</font><font style="vertical-align: inherit;">数组的</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个元素对应于数字的第</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个位。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时间复杂度</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按时间，O（</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）与常规堆相同。</font><font style="vertical-align: inherit;">对行（尤其是长行）进行排序时，弱堆可能比常规堆快。</font><font style="vertical-align: inherit;">但这是我们对长行进行排序的情况。</font><font style="vertical-align: inherit;">如果我们对数字进行排序，那么根据传言，普通堆的管理速度更快。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">充分筛选</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与通常的堆类似，在初始弱堆的形成阶段，相当明显的想法建议将较大的元素提高到尽可能高的水平。</font><font style="vertical-align: inherit;">也就是说，如果我们交换下层节点及其祖先的值，那么立即对祖先重复步骤是合乎逻辑的-为他找到他最近的右祖先并进行比较（并且如果还需要交换值+交换子树）。</font><font style="vertical-align: inherit;">并且，如果可能的话，从根本上提出一个大的要素。</font><font style="vertical-align: inherit;">这是第一阶段的样子（算法第二阶段的操作未更改）：</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/9x/9-/pa/9x9-panzenovigxgpzzal8phtri.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
时间复杂度分数保持不变。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式桩</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至此，所有的一切都是一种欺骗，一种幻想。当然，我们对那里的二叉树进行正式的操作，用值更改节点，重新排列子树等等。但是，该算法有一个双重底，我们现在将对其进行研究。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要理解这种类型，您需要了解什么是弱堆。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们采用一个数组，其中元素数是2的幂，则弱堆和基于其构造的二项式堆是同构的。</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="222" src="https://habrastorage.org/webt/nk/ge/qu/nkgequw_s9eaecxl7h9fiz9v2ua.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不要看弱堆是二进制，而二项式不是。</font><font style="vertical-align: inherit;">在弱堆中，左和右子树本质上是不同的。</font><font style="vertical-align: inherit;">右子树是传统意义上的后代，而左子树则是“兄弟”。</font><font style="vertical-align: inherit;">虽然没有。</font><font style="vertical-align: inherit;">左子树甚至不是“兄弟”，而是具有更少节点的“兄弟”的向量。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，弱堆和二项式堆虽然是最接近的亲戚，但并非100％相同。</font><font style="vertical-align: inherit;">如果采用的数组的元素数不等于2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则区别是显而易见的</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这样的数组的二项式分解将给出几个理想堆的连接列表（每个堆中的节点数是2的一定乘方）：</font></font><br>
<br>
<div style="text-align:center;"><img width="484" height="222" src="https://habrastorage.org/webt/k_/o8/zk/k_o8zk8rbi4n25ojy9ijrwh8jre.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这种情况下，弱堆将是一棵不完善的二叉树：</font></font><br>
<br>
<div style="text-align:center;"><img width="691" height="188" src="https://habrastorage.org/webt/eb/7a/-y/eb7a-yq54lycrpazacxsu6ci0em.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
二项式堆和弱堆是双胞胎兄弟。</font><font style="vertical-align: inherit;">DNA是一样的，尽管从外观上你看不出来。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">秘密算法</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉴于弱堆是密码二叉堆，混排子树突然找到了一个简单的解释。</font></font><br>
<br>
<div style="text-align:center;"><img width="497" height="199" src="https://habrastorage.org/webt/xa/tb/p7/xatbp7kfjag7awytapkrebfwdxk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于较弱的堆，请清除伪二进制金属丝，然后查看二项式堆样式中的节点之间的真实关系。</font><font style="vertical-align: inherit;">一切都变得清晰起来。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实上：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有“弱点”，它是一种成熟的排序（非二进制）树，其中实现并维护了“任​​何父代大于任何后代”的原则。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有阶段，我们都不将后代与其祖先进行比较，而是与其直系父母进行比较。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">看起来像是后代与祖先之间的价值交换+子代中子树位置的交换-事实是比率本身（后代/父代）的交换。</font><font style="vertical-align: inherit;">如果父节点的值小于子节点的值，则父节点本身将成为子节点，而子节点将成为父节点。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个诚实的可视化：</font></font><br>
<br>
<div style="text-align:center;"><img width="608" height="381" src="https://habrastorage.org/webt/s0/zb/m_/s0zbm_vg9ocfnzzgwhldn70v7he.gif"></div><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在下一个系列中</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想谈的下一堆是我最喜欢的-笛卡尔树。</font><font style="vertical-align: inherit;">这不仅是一堆，而且是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二叉搜索树</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是首先，在下一篇文章中，需要澄清一些有关BST树的有趣信息。</font><font style="vertical-align: inherit;">直到那时，通过这篇文章，以及关于笛卡尔的话题。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">参考文献</font></font></h2><br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱堆</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式堆</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">二项式</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/fn/cd/py/fncdpynfktllvkdjtmpif0kd1zc.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆C ++弱堆实现</font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/pt/js/7k/ptjs7kchs12_zg8dfph-ld6yp_4.gif"> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ronald D.Dutton：</font></font></b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">个人页面</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UCF网站配置文件</font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/yv/lm/2t/yvlm2t2kl5affkpm0hzqh7qw5ly.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱堆和朋友：最新动态</font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">弱堆数据结构：</font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WEAK-HEAPSORT </font></font></a><br>
<br>
<img width="84" height="30" src="https://habrastorage.org/webt/92/je/ur/92jeurt6uvk1biknydz0eygm9uy.gif"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自适应</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">性能的</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">变体和应用</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">heapsort：源代码</font></a></font><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/mp/mv/ie/mpmviex2wi0oknklc_zrg5tgfhe.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sergey Kopeliovich-演讲厅-弱堆（从48:32到1:16:06）</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">系列文章：</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Excel应用程序AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">交换排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">插入排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按选择排序</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：N金字塔</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：莱昂纳多数</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：弱堆</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">束排序：笛卡尔树</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他堆排序：镜像堆，迷你堆，自下而上筛选</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆排序：Jung Heap</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合并排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按分布排序</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混合排序</font></font></a></li>
</ul><br>
<img align="right" width="349" height="264" src="https://habrastorage.org/webt/kf/cj/xj/kfcjxjqyku6wcl2spe8hqzgefz0.png"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今天的排序是由一小撮人添加到AlgoLab应用程序中的，他们使用它-用宏更新excel文件。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在带有排序名称的单元格注释中，可以指定一些设置。</font><font style="vertical-align: inherit;">如果将siftup设置为1，则排序将在第一阶段使用完整筛选（默认情况下siftup = 0）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您指定二项式= 1，则树将是“二项式堆”（默认情况下，二项式= 0，即只是一个弱堆）。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN499770/index.html">自我隔离学习</a></li>
<li><a href="../zh-CN499772/index.html">将会非常非常：5G技术将如何改变广告市场</a></li>
<li><a href="../zh-CN499774/index.html">并非没有运动的一天-2：重新编程中国手镯</a></li>
<li><a href="../zh-CN499776/index.html">MSH语言实现的功能</a></li>
<li><a href="../zh-CN499784/index.html">什么接触虚拟墙？</a></li>
<li><a href="../zh-CN499788/index.html">免费在线课程“ IT项目中的技术文档”</a></li>
<li><a href="../zh-CN499792/index.html">负载测试Atlassian Jira，Confluence，Bitbucket第1部分</a></li>
<li><a href="../zh-CN499794/index.html">PostgreSQL和JDBC挤榨了所有果汁。弗拉基米尔·西特尼科夫</a></li>
<li><a href="../zh-CN499796/index.html">美国法院如何通过缩放来举行诉讼，以及为什么这被认为是一个问题</a></li>
<li><a href="../zh-CN499798/index.html">赚钱的两件事：我们如何在阿塞拜疆开发具有即时卡发行功能的金融聊天机器人</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>