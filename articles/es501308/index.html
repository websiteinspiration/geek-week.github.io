<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíê üî≥ ‚ìÇÔ∏è Intentamos entender StateFlow üßü üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üß•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos. 
 
 Hace unos d√≠as, JetBrains lanz√≥ una nueva versi√≥n de Corutin - 1.3.6 y una de las innovaciones fue la nueva subespecie de Flow - Sta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Intentamos entender StateFlow</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501308/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hola a todos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hace unos d√≠as, JetBrains lanz√≥ una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nueva versi√≥n de Corutin - 1.3.6</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y una de las innovaciones fue la nueva subespecie de Flow - StateFlow, que reemplaza a ConflatedBroadcastChannel. </font><font style="vertical-align: inherit;">Decid√≠ probar StateFlow en acci√≥n y estudiar la estructura interna.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Creo que muchos de los que usan Kotlin cuando desarrollan para Android o en MPP est√°n familiarizados con estos t√©rminos, quienes no lo est√°n: estas entidades son an√°logos cercanos de BehaviorProcessor / BehaviorSubject de RxJava y LiveData / MutableLiveData de Jetpack. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
StateFlow en s√≠ es una extensi√≥n simple de la interfaz Flow y viene en dos formas:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StateFlow</span>&lt;<span class="hljs-type">out T</span>&gt; : <span class="hljs-type">Flow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">val</span> value: T<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MutableStateFlow</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">StateFlow</span>&lt;<span class="hljs-type">T</span>&gt; </span>{
    <span class="hljs-comment">/**
     * The current value of this state flow.
     *
     * Setting a value that is [equal][Any.equals] to the previous one does nothing.
     */</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea es la misma que en LiveData / MutableLiveData: a trav√©s de una interfaz solo puede leer el estado actual, y a trav√©s de la otra tambi√©n se puede instalar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øQu√© nos ofrece StateFlow en comparaci√≥n con ConflatedBroadcastChannel:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Una implementaci√≥n interna m√°s simple y libre de basura. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La necesidad de un elemento predeterminado. </font><font style="vertical-align: inherit;">Nulo tambi√©n es posible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Separaci√≥n en interfaces de solo lectura y lectura-escritura. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Comparar elementos a trav√©s de la igualdad en lugar de comparar enlaces. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora intentemos implementar un uso simple de StateFlow. </font><font style="vertical-align: inherit;">Para hacer esto, hice un contenedor b√°sico con la capacidad de establecer cualquier tipo con un elemento nulo de forma predeterminada:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowRepository</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: T? = <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> stateFlow = MutableStateFlow(initialValue)<font></font>
<font></font>
    <span class="hljs-keyword">var</span> value: T?
        <span class="hljs-keyword">get</span>() = stateFlow.value
        <span class="hljs-keyword">set</span>(value) {<font></font>
            stateFlow.value = value<font></font>
        }<font></font>
<font></font>
    <span class="hljs-keyword">val</span> stream: Flow&lt;T?&gt; = stateFlow<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtenemos los datos:</font></font><br>
<br>
<pre><code class="kotlin hljs">lifecycleScope.launch {<font></font>
            simpleRepo.stream.collect {<font></font>
                addData(it.toString())<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y mostramos en la pantalla con la interfaz m√°s simple para las pruebas, no causa ning√∫n problema y todo funciona como un reloj: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/cv/_c/pncv_c41cwncgwkfc3hd3wxzfh0.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ahora veamos el interior y veamos c√≥mo se implementa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para mi sorpresa, la implementaci√≥n es realmente muy simple y actualmente solo toma 316 l√≠neas, el 25% de las cuales son javadoki. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y as√≠, la clase de implementaci√≥n principal es la clase StateFlowImpl:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateFlowImpl</span>&lt;<span class="hljs-type">T</span>&gt;</span>(initialValue: Any) : SynchronizedObject(), MutableStateFlow&lt;T&gt;, FusibleFlow&lt;T&gt; {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic(initialValue) <span class="hljs-comment">// T | NULL</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sequence = <span class="hljs-number">0</span> <span class="hljs-comment">// serializes updates, value update is in process when sequence is odd</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> slots = arrayOfNulls&lt;StateFlowSlot?&gt;(INITIAL_SIZE)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nSlots = <span class="hljs-number">0</span> <span class="hljs-comment">// number of allocated (!free) slots</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> nextIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// oracle for the next free slot index</span><font></font>
<font></font>
. . .<font></font>
}<font></font>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - enlace at√≥mico para almacenar nuestro estado. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">secuencia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : un indicador auxiliar que, seg√∫n la paridad / rareza, informa sobre el proceso actual de actualizaci√≥n de las </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ranuras de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estado </font><font style="vertical-align: inherit;">: matriz / agrupaci√≥n StateFlowSlot. StateFlowSlot: abstracci√≥n auxiliar de cada "conexi√≥n" a StateFlow. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nSlots, nextIndex</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : variables auxiliares para trabajar con las ranuras de matriz extensibles </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Consideremos de antemano StateFlowSlot. √âl representa solo:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> _state = atomic&lt;Any?&gt;(<span class="hljs-literal">null</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
M√°s m√©todos para cambiar los estados de las ranuras. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada ranura puede estar en uno de los estados: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nulo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - se crea, pero no se usa </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NINGUNO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">estado PENDIENTE del</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> colector usado </font><font style="vertical-align: inherit;">- en previsi√≥n de enviar un nuevo valor al colector </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancelableContinuationImpl</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - el estado suspendido cerca del estado PENDIENTE de destino, est√°n suspendiendo el colector no llegar√° hasta un nuevo estado en el flujo de estado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considere lo que sucede cuando establece un nuevo valor:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> value: T
        <span class="hljs-keyword">get</span>() = NULL.unbox(_state.value)
        <span class="hljs-keyword">set</span>(value) {
            <span class="hljs-keyword">var</span> curSequence = <span class="hljs-number">0</span>
            <span class="hljs-keyword">var</span> curSlots: Array&lt;StateFlowSlot?&gt; = <span class="hljs-keyword">this</span>.slots <span class="hljs-comment">// benign race, we will not use it</span>
            <span class="hljs-keyword">val</span> newState = value ?: NULL<font></font>
            synchronized(<span class="hljs-keyword">this</span>) {
                <span class="hljs-keyword">val</span> oldState = _state.value
                <span class="hljs-keyword">if</span> (oldState == newState) <span class="hljs-keyword">return</span> <span class="hljs-comment">// Don't do anything if value is not changing</span><font></font>
                _state.value = newState<font></font>
                curSequence = sequence<font></font>
                <span class="hljs-keyword">if</span> (curSequence and <span class="hljs-number">1</span> == <span class="hljs-number">0</span>) { <span class="hljs-comment">// even sequence means quiescent state flow (no ongoing update)</span>
                    curSequence++ <span class="hljs-comment">// make it odd</span><font></font>
                    sequence = curSequence<font></font>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">// update is already in process, notify it, and return</span>
                    sequence = curSequence + <span class="hljs-number">2</span> <span class="hljs-comment">// change sequence to notify, keep it odd</span>
                    <span class="hljs-keyword">return</span><font></font>
                }<font></font>
                curSlots = slots <span class="hljs-comment">// read current reference to collectors under lock</span><font></font>
            }<font></font>
            <span class="hljs-comment">/*
               Fire value updates outside of the lock to avoid deadlocks with unconfined coroutines
               Loop until we're done firing all the changes. This is sort of simple flat combining that
               ensures sequential firing of concurrent updates and avoids the storm of collector resumes
               when updates happen concurrently from many threads.
             */</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Benign race on element read from array</span>
                <span class="hljs-keyword">for</span> (col <span class="hljs-keyword">in</span> curSlots) {<font></font>
                    col?.makePending()<font></font>
                }<font></font>
                <span class="hljs-comment">// check if the value was updated again while we were updating the old one</span>
                synchronized(<span class="hljs-keyword">this</span>) {
                    <span class="hljs-keyword">if</span> (sequence == curSequence) { <span class="hljs-comment">// nothing changed, we are done</span>
                        sequence = curSequence + <span class="hljs-number">1</span> <span class="hljs-comment">// make sequence even again</span>
                        <span class="hljs-keyword">return</span> <span class="hljs-comment">// done</span><font></font>
                    }<font></font>
                    <span class="hljs-comment">// reread everything for the next loop under the lock</span><font></font>
                    curSequence = sequence<font></font>
                    curSlots = slots<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tarea principal aqu√≠ es corregir los cambios de estado de StateFlow de diferentes flujos para llamadas sucesivas a FlowCollector. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se pueden distinguir varios pasos:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer un nuevo valor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Establecer el marcador de secuencia en un valor impar significa que ya estamos en el proceso de actualizaci√≥n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">makePending (): establece todos los estados de ranura (es decir, todas las conexiones) en PENDIENTE: pronto enviaremos un nuevo valor.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ciclo verifica la secuencia == curSequence de que todas las tareas se completen y establece la secuencia en un n√∫mero par.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo que sucede en el m√©todo de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recopilaci√≥n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-keyword">override</span> <span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">collect</span><span class="hljs-params">(collector: <span class="hljs-type">FlowCollector</span>&lt;<span class="hljs-type">T</span>&gt;)</span></span> {
        <span class="hljs-keyword">val</span> slot = allocateSlot()
        <span class="hljs-keyword">var</span> prevState: Any? = <span class="hljs-literal">null</span> <span class="hljs-comment">// previously emitted T!! | NULL (null -- nothing emitted yet)</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// The loop is arranged so that it starts delivering current value without waiting first</span>
            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
                <span class="hljs-comment">// Here the coroutine could have waited for a while to be dispatched,</span>
                <span class="hljs-comment">// so we use the most recent state here to ensure the best possible conflation of stale values</span>
                <span class="hljs-keyword">val</span> newState = _state.value
                <span class="hljs-comment">// Conflate value emissions using equality</span>
                <span class="hljs-keyword">if</span> (prevState == <span class="hljs-literal">null</span> || newState != prevState) {<font></font>
                    collector.emit(NULL.unbox(newState))<font></font>
                    prevState = newState<font></font>
                }<font></font>
                <span class="hljs-comment">// Note: if awaitPending is cancelled, then it bails out of this loop and calls freeSlot</span>
                <span class="hljs-keyword">if</span> (!slot.takePending()) { <span class="hljs-comment">// try fast-path without suspending first</span>
                    slot.awaitPending() <span class="hljs-comment">// only suspend for new values when needed</span><font></font>
                }<font></font>
            }<font></font>
        } <span class="hljs-keyword">finally</span> {<font></font>
            freeSlot(slot)<font></font>
        }<font></font>
    }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La tarea principal es enviar el valor predeterminado inicial y esperar nuevos valores: </font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Creamos o reutilizamos una ranura para una nueva conexi√≥n.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos el estado por nulo o por cambio de estado. </font><font style="vertical-align: inherit;">Emittim es un nuevo significado.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verificamos si hay ranuras listas para actualizar (estado PENDIENTE) y si no, suspendemos la ranura en anticipaci√≥n de nuevos valores.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, eso es todo. </font><font style="vertical-align: inherit;">No consideramos c√≥mo ocurre la asignaci√≥n de espacios y el cambio de sus estados, pero supuse que esto no es importante para la imagen general de StateFlow. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gracias.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es501292/index.html">Estimaci√≥n del costo de los buques comerciales. Aritm√©tica y sentido com√∫n.</a></li>
<li><a href="../es501296/index.html">C√≥mo hacer una carrera como programador sin resolver un problema de negocios</a></li>
<li><a href="../es501298/index.html">Crear su propio repositorio de complementos QGIS</a></li>
<li><a href="../es501302/index.html">Por favor no hagas ruido</a></li>
<li><a href="../es501306/index.html">Construyendo una tuber√≠a para entregar Graal Native Image a los usuarios finales</a></li>
<li><a href="../es501310/index.html">Sobre el per√≥xido de hidr√≥geno y el insecto cohete</a></li>
<li><a href="../es501312/index.html">Alpine.js: marco ligero con sintaxis conveniente</a></li>
<li><a href="../es501316/index.html">Estudio de Microsoft: la capacitaci√≥n de los empleados es uno de los factores clave para introducir la inteligencia artificial en los negocios</a></li>
<li><a href="../es501318/index.html">C√≥mo usar las hojas js y google para convertirse en vecino del club de golf de Bill Gates</a></li>
<li><a href="../es501320/index.html">Controlador LED con un costo de lista de materiales de menos de $ 1. ¬øEs posible?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>