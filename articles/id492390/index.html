<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üè≥Ô∏è üå∑ üö® Perang rem. Mengoptimalkan jumlah rendering komponen di React Native ü§π üë≤üèø üöÉ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Nama saya Kamo Spertsyan, saya terlibat dalam pengembangan React Native di Profi.ru. Jika Anda memutuskan untuk menggunakan teknologi Reac...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Perang rem. Mengoptimalkan jumlah rendering komponen di React Native</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/492390/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! Nama saya Kamo Spertsyan, saya terlibat dalam pengembangan React Native di Profi.ru. Jika Anda memutuskan untuk </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menggunakan teknologi React Native</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> untuk secara cepat menghadirkan fitur produk dan fokus pada kecepatan pengembangan, maka Anda kemungkinan akan mengalami masalah kinerja. Setidaknya itulah yang terjadi pada kita. Setelah enam bulan pengembangan aktif, kinerja aplikasi kami turun di bawah tingkat kritis - semuanya sangat lambat. Karena itu, kami melakukan optimasi - menghapus semua "rem" saat startup, transisi di antara layar, merender layar, reaksi terhadap tindakan pengguna. Hasilnya, dalam tiga bulan mereka membawa pengalaman pengguna ke tingkat asli. Pada artikel ini saya ingin berbicara tentang bagaimana kami mengoptimalkan aplikasi pada React Native dan menyelesaikan masalah render banyak komponen.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/tv/qy/9b/tvqy9bo_jyqc4cz044_gneepvmw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mengumpulkan rekomendasi yang akan membantu meminimalkan jumlah redraws komponen yang tidak berguna. </font><font style="vertical-align: inherit;">Untuk kejelasan, dalam contoh saya membandingkan implementasi "buruk" dan "baik". </font><font style="vertical-align: inherit;">Artikel ini akan bermanfaat bagi mereka yang sudah dihadapkan dengan kinerja aplikasi yang buruk, dan mereka yang tidak ingin mengizinkan ini di masa depan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menggunakan Bereaksi Asli yang dipasangkan dengan Redux. </font><font style="vertical-align: inherit;">Beberapa tips terkait dengan perpustakaan ini. </font><font style="vertical-align: inherit;">Juga dalam contoh, saya menggunakan pustaka Redux-thunk - untuk mensimulasikan bekerja dengan jaringan.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan memikirkan kinerja?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bahkan, perlu diingat sejak awal bekerja pada aplikasi. Tetapi jika aplikasi Anda sudah melambat - jangan putus asa, semuanya bisa diperbaiki. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua orang tahu, tetapi untuk berjaga-jaga, saya akan menyebutkan: lebih baik untuk memeriksa kinerja pada perangkat yang lemah. Jika Anda mengembangkan pada perangkat yang kuat, Anda mungkin tidak menyadari "rem" dari pengguna akhir. Tentukan sendiri perangkat yang akan Anda pandu. Ukur waktu atau </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FPS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam plot kontrol untuk membandingkan dengan hasil setelah optimasi.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bereaksi Asli di luar kotak menyediakan kemampuan untuk mengukur aplikasi FPS melalui Alat Pengembang ‚Üí Tampilkan monitor perf. </font><font style="vertical-align: inherit;">Nilai referensi adalah 60 frame per detik. </font><font style="vertical-align: inherit;">Semakin rendah indikator ini, semakin kuat aplikasi "melambat" - tidak merespons atau bereaksi dengan penundaan terhadap tindakan pengguna. </font><font style="vertical-align: inherit;">Salah satu efek utama pada FPS adalah jumlah render, "keparahan" yang tergantung pada kompleksitas komponen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deskripsi contoh</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menunjukkan semua rekomendasi pada contoh aplikasi sederhana dengan daftar berita. </font><font style="vertical-align: inherit;">Aplikasi ini memiliki satu layar, yang terletak </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan berita. </font><font style="vertical-align: inherit;">Item berita adalah komponen </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang terdiri dari dua komponen yang lebih kecil - informasi utama ( </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) dan tubuh ( </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Seluruh contoh bisa dilihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Lebih lanjut dalam teks adalah tautan ke berbagai cabang repositori untuk contoh spesifik. </font><font style="vertical-align: inherit;">Repositori digunakan untuk kenyamanan pembaca yang ingin menjelajahi contoh lebih dalam. </font><font style="vertical-align: inherit;">Kode dalam repositori dan contoh di bawah ini tidak mengklaim sebagai sempurna - hanya diperlukan untuk tujuan demonstrasi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah ini, semua komponen ditampilkan secara skematis dengan tautan dan alat peraga.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/ng/z6/d9ngz6hldmphbkjky1a-7-38nlq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam metode render setiap komponen, saya menambahkan output ke konsol informasi unik tentangnya: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_{no}<font></font>
ITEM_TITLE_{no}<font></font>
ITEM_BODY_{no}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
di mana </font></font><code>{no}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah nomor seri berita untuk membedakan antara renderings berita yang berbeda dari beberapa rendering yang sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk pengujian pada setiap </font></font><code>refresh</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daftar berita, berita tambahan ditambahkan ke awal. </font><font style="vertical-align: inherit;">Pada saat yang sama, pesan berikut ini ditampilkan di konsol:</font></font><br>
<br>
<pre><code class="plaintext hljs">--------------[ REFRESHING ]--------------</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan-catatan ini akan membantu untuk memahami jika ada masalah dalam komponen tertentu, dan kemudian untuk menentukan apakah mungkin untuk mengoptimalkannya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika diterapkan dengan benar, log kami setelah peluncuran dan beberapa pembaruan akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_4<font></font>
ITEM_TITLE_4<font></font>
ITEM_BODY_4</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awal pertama, layar itu sendiri dan dua berita awal diambil. </font><font style="vertical-align: inherit;">Saat memperbarui papan, layar ditampilkan lagi, karena datanya telah benar-benar berubah. </font><font style="vertical-align: inherit;">Lebih banyak berita muncul. </font><font style="vertical-align: inherit;">Semua berita sebelumnya tidak digambar ulang, karena tidak ada perubahan dalam data mereka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kapan komponen diberikan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam Bereaksi dan Bereaksi Asli, ada dua kondisi untuk merender komponen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengubah props / kondisinya,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membuat komponen induk.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suatu fungsi dapat didefinisikan ulang dalam suatu komponen </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ia menerima Alat Peraga dan Status baru sebagai input dan memberi tahu apakah komponen tersebut harus dirender. Seringkali, untuk menghindari render yang tidak perlu, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">perbandingan yang dangkal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari Alat Peraga dan objek Negara sudah cukup. Misalnya, ini menghilangkan render yang tidak perlu ketika komponen induk berubah, jika mereka tidak mempengaruhi komponen turunan. Agar tidak menulis perbandingan permukaan secara manual setiap kali, Anda bisa mewarisi komponen dari </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang merangkum pemeriksaan ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika kami menggunakan fungsi tautan hubung, pustaka Redux membuat komponen baru yang "terhubung" ke Negara global. Perubahan pada status ini memicu suatu metode</font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan alat peraga baru. </font><font style="vertical-align: inherit;">Selanjutnya, perbandingan alat peraga lama dan baru dimulai, terlepas dari apakah komponen dinyatakan sebagai </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau tidak. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan nuansa ini dalam contoh kita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membiarkan </font><font style="vertical-align: inherit;">komponen </font><font style="vertical-align: inherit;">melewati </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mewarisi dari </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- dari </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br>
<pre><code class="plaintext hljs">export class NewsItemTitle extends React.Component<font></font>
export class NewsItemBody extends React.PureComponent</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikut ini tampilan log setelah pembaruan satu papan:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda dapat melihat bahwa komponen berita dan informasi utama digambar ulang. </font><font style="vertical-align: inherit;">Kami akan mempertimbangkan mereka pada gilirannya. </font></font><br>
<br>
<code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dideklarasikan menggunakan </font></font><code>connect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Sebagai alat peraga, komponen ini menerima pengidentifikasi, yang kemudian menerima berita di </font></font><code>mapStateToProps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">const mapStateToProps = (state, ownProps) =&gt; ({<font></font>
  item: state.newsMap[ownProps.itemKey],<font></font>
});</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena ketika memperbarui papan semua berita diunduh lagi, objek akan </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memperbarui dan kemudian akan merujuk ke berbagai sel memori. Dengan kata lain, mereka akan menjadi objek yang berbeda, bahkan jika semua bidang yang ada adalah sama. Oleh karena itu, perbandingan pengembalian State'ov komponen sebelumnya dan baru </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Komponen akan dirender ulang, meskipun faktanya data tidak berubah. </font></font><br>
<br>
<code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diwarisi dari </font></font><code>React.Component</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga dirender ulang setiap kali komponen induk dirender. Ini terjadi terlepas dari nilai alat peraga lama dan baru. </font></font><br>
<br>
<code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diwarisi dari </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sehingga membandingkan alat peraga lama dan baru. Dalam berita 1 dan 2, nilainya setara, oleh karena itu komponen ini diberikan hanya untuk berita 3. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengoptimalkan rendering</font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cukup nyatakan sebagai </font></font><code>React.PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda harus </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mendefinisikan kembali fungsi </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return !shallowEqual(this.props.item, nextProps.item);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Berikut </font></font><code>shallowEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah fitur untuk perbandingan permukaan objek yang disediakan Redux. </font><font style="vertical-align: inherit;">Anda dapat menulis seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">shouldComponentUpdate(nextProps) {<font></font>
  return (<font></font>
    this.props.item.title !== nextProps.item.title ||<font></font>
    this.props.item.body !== nextProps.item.body<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beginilah tampilan log kami setelah ini: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan</font></font></b><div class="spoiler_text"> <code>shouldComponentUpdate</code>  <code>NewsItem</code> ,  <code>NewsItemTitle</code>   .        . <code>NewsItemTitle</code>    -         <code>NewsItem</code>,     .<br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo dan komponen fungsional</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mungkin </font><font style="vertical-align: inherit;">menimpa </font><font style="vertical-align: inherit;">komponen fungsional. </font><font style="vertical-align: inherit;">Tetapi ini tidak berarti bahwa untuk mengoptimalkan komponen fungsional, Anda harus menulis ulang menjadi kelas satu. </font><font style="vertical-align: inherit;">Untuk kasus seperti itu, fungsi memoisasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">React.memo disediakan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ini menerima input komponen dan fungsi perbandingan opsional </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saat dipanggil, alat ini </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menjadi tua dan baru dan harus mengembalikan hasil perbandingan. </font><font style="vertical-align: inherit;">Bedanya dengan </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apa yang </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">harus dikembalikan </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jika propsnya sama, dan bukan sebaliknya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, </font></font><code>NewsItemTitle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memoisasi mungkin terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">areEqual(prevProps, nextProps) {<font></font>
  return shallowEqual(prevProps, nextProps);<font></font>
}<font></font>
export OptimizedNewsItemTitle = React.memo(NewsItemTitle, areEqual)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tidak lulus </font></font><code>areEqual</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam </font></font><code>React.memo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka perbandingan dangkal alat peraga akan dibuat, sehingga contoh kita dapat disederhanakan:</font></font><br>
<br>
<pre><code class="plaintext hljs">export OptimizedNewsItemTitle = React.memo(NewsItemTitle)</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi Lambda dalam alat peraga</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memproses peristiwa komponen, fungsi dapat diteruskan ke alat peraga. </font><font style="vertical-align: inherit;">Contoh yang paling mencolok adalah implementasi </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Seringkali fungsi lambda anonim digunakan untuk ini. </font><font style="vertical-align: inherit;">Katakanlah </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kita hanya ingin menampilkan pratinjau, dan jika Anda mengkliknya - seluruh teks. </font><font style="vertical-align: inherit;">Untuk melakukan ini, ketika merender </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kami akan melewati prop berikut:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={() =&gt; this.props.expandBody()}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti inilah tampilan log dengan implementasi ini ketika metode </font></font><code>shouldComponentUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dihapus:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berita badan 1 dan 2 tersebut diberikan, walaupun data mereka tidak berubah, tetapi </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini disebabkan oleh fakta bahwa untuk setiap render </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nilai alat peraga </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dibuat baru. </font><font style="vertical-align: inherit;">Secara teknis, </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan setiap render, ini menunjuk ke area baru dalam memori, jadi perbandingan yang tidak proporsional dari alat peraga dalam </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengembalian salah. </font><font style="vertical-align: inherit;">Masalahnya diperbaiki oleh entri berikut:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  onPress={this.props.expandBody}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Catatan: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Sayangnya, fungsi anonim tidak dapat selalu ditulis ulang sebagai metode atau bidang kelas untuk catatan semacam itu. Kasus yang paling umum adalah ketika di dalam fungsi lambda, variabel ruang lingkup fungsi yang dideklarasikan digunakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan kasus ini dalam contoh kita. Untuk beralih dari daftar umum ke layar satu berita, kami menambahkan proses mengklik pada badan berita. Metode </font></font><code>renderItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komponen </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={() =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fungsi anonim </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak dapat dideklarasikan di kelas, karena variabel </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang diperlukan untuk pergi ke berita tertentu </font><font style="vertical-align: inherit;">akan hilang dari ruang lingkup </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solusi paling sederhana untuk masalah ini adalah dengan mengubah tanda tangan </font></font><code>onBodyPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komponen </font><font style="vertical-align: inherit;">alat peraga </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehingga parameter yang diperlukan diteruskan ke fungsi saat dipanggil. </font><font style="vertical-align: inherit;">Dalam hal ini, ini adalah pengidentifikasi berita.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={item =&gt; this.onItemBodyPress(item)}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, kita sudah dapat menghapus fungsi anonim dalam metode kelas komponen.</font></font><br>
<br>
<pre><code class="plaintext hljs">const renderItem = ({item}) =&gt; (<font></font>
  &lt;NewsItem<font></font>
    itemKey={item}<font></font>
    onBodyPress={this.onItemBodyPress}<font></font>
  /&gt;<font></font>
);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Namun, solusi seperti itu akan mengharuskan kita untuk mengubah komponen </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="plaintext hljs">class NewsItemComponent extends React.Component {<font></font>
render() {<font></font>
  ...<font></font>
  return (<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={() =&gt; this.props.onBodyPress(this.props.item)}<font></font>
        ...<font></font>
      /&gt;<font></font>
      ...<font></font>
  );<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan lagi kita kembali ke masalah yang ditunjukkan - kita melewati fungsi lambda baru ke komponen anak untuk setiap render dari orang tua. </font><font style="vertical-align: inherit;">Baru sekarang kita turun satu tingkat. </font><font style="vertical-align: inherit;">Catatan:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghilangkan masalah ini di root, Anda dapat menggunakan hook </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useCallback</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hal ini memungkinkan Anda untuk mem memanggil panggilan fungsi dengan menyampaikan argumen. </font><font style="vertical-align: inherit;">Jika argumen fungsi tidak berubah, maka hasil panggilan </font></font><code>useCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menunjuk ke area memori yang sama. </font><font style="vertical-align: inherit;">Dalam contoh kami, ini berarti bahwa ketika menggambar ulang berita yang sama, </font></font><code>onPress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komponen </font><font style="vertical-align: inherit;">prop </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan berubah. </font><font style="vertical-align: inherit;">Kait hanya dapat digunakan dalam komponen fungsional, sehingga tampilan akhir komponen </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah sebagai berikut:</font></font><br>
<br>
<pre><code class="plaintext hljs">function NewsItemComponent(props) {<font></font>
  ...<font></font>
  const {itemKey, onBodyPress} = props.item;<font></font>
  const onPressBody = useCallback(() =&gt; onBodyPress(itemKey), [itemKey, onBodyPress]);<font></font>
  return (<font></font>
    &lt;View&gt;<font></font>
      ...<font></font>
      &lt;NewsItemBody<font></font>
        ...<font></font>
        onPress={onPressBody}<font></font>
        ...<font></font>
      /&gt;<font></font>
    &lt;/View&gt;<font></font>
  );<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan log: </font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Array dan objek</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam JavaScript, fungsi direpresentasikan sebagai objek, bersama dengan array. </font><font style="vertical-align: inherit;">Oleh karena itu, contoh dari blok sebelumnya adalah kasus khusus untuk membuat objek baru di alat peraga. </font><font style="vertical-align: inherit;">Ini cukup umum, jadi saya letakkan di paragraf terpisah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap penciptaan fungsi, array, atau objek baru dalam props mengarah ke re-renderer komponen. </font><font style="vertical-align: inherit;">Pertimbangkan aturan ini dalam contoh berikut. </font><font style="vertical-align: inherit;">Mari kita berikan </font></font><code>NewsItemBody</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gaya gabungan dari dua nilai:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;NewsItemBody<font></font>
  ...<font></font>
  style={[styles.body, styles.item]}<font></font>
  ...<font></font>
/&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan lagi, log menunjukkan penyaji komponen tambahan:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1<font></font>
--------------[ REFRESHING ]--------------<font></font>
SCREEN<font></font>
ITEM_3<font></font>
ITEM_TITLE_3<font></font>
ITEM_BODY_3<font></font>
ITEM_2<font></font>
ITEM_TITLE_2<font></font>
ITEM_BODY_2<font></font>
ITEM_1<font></font>
ITEM_TITLE_1<font></font>
ITEM_BODY_1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatasi masalah ini, Anda dapat memilih gaya terpisah yang akan menggabungkan </font></font><code>body</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>item</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, atau, misalnya, memindahkan deklarasi array </font></font><code>[styles.body, styles.item]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke variabel global. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reduksi array</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan sumber "rem" populer lain yang terkait dengan penggunaan </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aplikasi klasik yang berisi daftar panjang item dari server mengimplementasikan pagination. </font><font style="vertical-align: inherit;">Yaitu, ia memuat serangkaian elemen terbatas dalam bentuk halaman pertama, ketika daftar elemen saat ini berakhir, ia memuat halaman berikutnya, dan seterusnya. </font><font style="vertical-align: inherit;">Peredam daftar item mungkin terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika setiap halaman berikutnya memuat gaya aplikasi, array pengidentifikasi baru dibuat. </font><font style="vertical-align: inherit;">Jika kita meneruskan array ini ke alat peraga nanti </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, inilah tampilan komponen render log:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk contoh ini, saya membuat beberapa perubahan pada aplikasi pengujian.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Atur ukuran halaman menjadi 10 berita.</font></font></li>
<li>   <code>item</code>   <code>NewsItem</code>  <code>FlatList</code>-,        connect. <code>NewsItem</code>    <code>React.Component</code>    .</li>
<li>     .</li>
<li>       .       ‚Ññ1     .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh menunjukkan bahwa ketika setiap halaman berikutnya memuat, semua elemen lama dirender lagi, maka elemen lama dan elemen-elemen halaman baru dirender lagi. Untuk pecinta matematika: jika ukuran halaman sama </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka ketika </font></font><code>i</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman ke </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">i </font><font style="vertical-align: inherit;">dimuat, </font><font style="vertical-align: inherit;">alih-alih hanya merender </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen baru, elemen tersebut dirender </font></font><code>(i - 1) * X + i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚ÄúOke,‚Äù Anda berkata, ‚ÄúSaya mengerti mengapa semua elemen digambar setelah menambahkan halaman baru: peredam mengembalikan array baru, area memori baru, semuanya. Tetapi mengapa kita perlu membuat daftar lama sebelum menambahkan elemen baru? " "Pertanyaan bagus," aku akan menjawabmu. Ini adalah konsekuensi dari bekerja dengan keadaan komponen </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atas dasar siapa</font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Saya tidak akan merinci, karena mereka menarik artikel yang terpisah. </font><font style="vertical-align: inherit;">Siapa yang peduli, saya sarankan Anda mempelajari </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dokumentasi</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan sumbernya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara menghilangkan non-optimalitas seperti itu? </font><font style="vertical-align: inherit;">Kami menulis ulang peredam sehingga ia tidak mengembalikan array baru untuk setiap halaman, tetapi menambahkan elemen ke yang sudah ada:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatian! </font><font style="vertical-align: inherit;">Antipattern!</font></font></b><div class="spoiler_text">          .     ,    , ,  <code>PureComponent</code>,          .      ,             .      .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"> Redux</a>.<br>
</div></div><br>
<pre><code class="plaintext hljs">const newsIdList = (state = [], action) =&gt; {<font></font>
  if (action.type === 'GOT_NEWS') {<font></font>
    return action.news.map(item =&gt; item.key);<font></font>
  } else if (action.type === 'GOT_OLDER_NEWS') {<font></font>
    action.news.forEach(item =&gt; state.push(item.key));<font></font>
    return state;<font></font>
    // return [...state, ...action.news.map(item =&gt; item.key)];<font></font>
  }<font></font>
  return state;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, log kita akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;1..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami menyingkirkan rendering elemen lama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sebelum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menambahkan elemen ke halaman baru, tetapi elemen lama masih digambar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">setelah</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> memperbarui daftar. Jumlah rendering untuk halaman berikutnya sekarang sama </font></font><code>i * X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Rumusnya menjadi lebih sederhana, tetapi kami tidak akan berhenti di situ. Kami hanya memiliki </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elemen baru, dan kami hanya ingin </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">render baru. Kami akan menggunakan trik yang sudah biasa untuk menghapus render berita yang belum mengubah alat peraga. Kembali terhubung ke </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="plaintext hljs">SCREEN<font></font>
ITEM_&lt;1..10&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;11..20&gt;<font></font>
--------------[ LOADING NEXT PAGE ]--------------<font></font>
SCREEN<font></font>
ITEM_&lt;21..30&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik! Sekarang kita bisa puas dengan diri kita sendiri. Tidak ada tempat untuk mengoptimalkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
‚Üí </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode contoh lengkap</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Pembaca yang penuh perhatian akan menunjukkan bahwa setelah menerapkan koneksi ke </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">log, akan terlihat seperti pada contoh terakhir, tidak peduli bagaimana Anda mengimplementasikan peredam. Dan itu akan benar - jika komponen berita memeriksa properti sebelum rendering, tidak masalah apakah array lama digunakan oleh reducer atau membuat yang baru. Hanya elemen baru yang digambar dan hanya sekali. Namun, mengubah array lama bukannya membuat yang baru menyelamatkan kita dari rendering komponen yang tidak perlu yang </font></font><code>FlatList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">digunakan di dalamnya </font></font><code>VirtualizedList</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan iterasi yang tidak perlu dari pemeriksaan ekuivalen alat peraga </font></font><code>NewsItem</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan sejumlah besar elemen, ini juga memberikan peningkatan kinerja.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunakan array dan objek yang bisa berubah dalam reduksi harus dengan sangat hati-hati. </font><font style="vertical-align: inherit;">Dalam contoh ini, ini dibenarkan, tetapi jika Anda memiliki, katakanlah, normal </font></font><code>PureComponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka ketika Anda menambahkan elemen ke array yang bisa berubah, komponen tidak akan dirender. </font><font style="vertical-align: inherit;">Alat peraga pada kenyataannya tetap tidak berubah, karena sebelum dan sesudah memperbarui titik-titik array ke area memori yang sama. </font><font style="vertical-align: inherit;">Ini dapat menyebabkan konsekuensi yang tidak terduga. </font><font style="vertical-align: inherit;">Tidak heran contoh yang dijelaskan itu melanggar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prinsip</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">prinsip Redux</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan sesuatu yang lain ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menggunakan perpustakaan tingkat presentasi, saya menyarankan Anda untuk memastikan bahwa Anda memahami secara detail bagaimana mereka diterapkan. </font><font style="vertical-align: inherit;">Dalam aplikasi kami, kami menggunakan komponen </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari perpustakaan </font></font><code>react-native-gesture-handler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk menerapkan blok tindakan tambahan saat menggesek kartu dari daftar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode, tampilannya seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">&lt;Swipeable<font></font>
  ...<font></font>
  renderRightActions={this.renderRightActions}<font></font>
  ...<font></font>
&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Metode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau </font></font><code>renderLeftActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan komponen yang ditampilkan setelah gesek. Kami menentukan dan mengubah ketinggian panel selama pergantian komponen agar sesuai dengan konten yang diperlukan. Ini adalah proses yang intensif sumber daya, tetapi jika itu terjadi selama animasi swipe, pengguna tidak melihat gangguan.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/n1/vg/wzn1vghiy6-wjclqcy8itdy1fns.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya adalah bahwa komponen </font></font><code>Swipeable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memanggil metode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada saat rendering komponen utama. Semua perhitungan dan bahkan rendering pada bilah tindakan, yang tidak terlihat sebelum gesekan, terjadi di muka. Jadi, semua tindakan ini dilakukan untuk semua kartu dalam daftar secara bersamaan. Ini menyebabkan "rem" yang signifikan saat menggulir papan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalahnya dipecahkan dengan cara berikut. Jika panel tindakan ditarik bersama-sama dengan komponen utama, dan bukan sebagai akibat dari gesek, maka metode </font></font><code>renderRightActions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengembalikan yang kosong </font></font><code>View</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ukuran komponen utama. Kalau tidak, kami menggambar panel tindakan tambahan seperti sebelumnya.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya memberikan contoh ini karena perpustakaan pendukung tidak selalu berfungsi seperti yang Anda harapkan. </font><font style="vertical-align: inherit;">Dan jika ini adalah perpustakaan tingkat presentasi, maka lebih baik untuk memastikan bahwa mereka tidak membuang sumber daya yang tidak perlu.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">temuan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah menghilangkan masalah yang dijelaskan dalam artikel, kami secara signifikan mempercepat aplikasi pada React Native. </font><font style="vertical-align: inherit;">Sekarang sulit untuk membedakannya dalam kinerja dari yang serupa, dilaksanakan secara asli. </font><font style="vertical-align: inherit;">Kelebihan render memperlambat pemuatan layar individual dan reaksi terhadap tindakan pengguna. </font><font style="vertical-align: inherit;">Yang paling penting, itu terlihat pada daftar, di mana puluhan komponen diambil sekaligus. </font><font style="vertical-align: inherit;">Kami belum mengoptimalkan semuanya, tetapi layar utama aplikasi tidak lagi melambat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Poin utama dari artikel ini tercantum secara singkat di bawah ini.</font></font><br>
<br>
<ol>
<li> React Native      :  Props/State-     .</li>
<li>,   <code>React.PureComponent</code>,     ,       .</li>
<li>    ,    <code>shouldComponentUpdate</code>      <code>React.Memo</code>   .</li>
<li>-        .      ,         (shallow compare).               ,     .</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mendukung perpustakaan tingkat presentasi dapat menyebabkan pemborosan sumber daya yang tidak terduga. </font><font style="vertical-align: inherit;">Perlu hati-hati dalam aplikasi mereka.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja. </font><font style="vertical-align: inherit;">Saya harap Anda menemukan informasi yang bermanfaat. </font><font style="vertical-align: inherit;">Saya akan dengan senang hati menerima umpan balik!</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber yang bermanfaat</font></font></h2><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memahami Rendering dalam React + Redux</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membandingkan Objek dalam JavaScript</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meningkatkan Kinerja dalam Komponen Fungsional React menggunakan React.memo ()</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana Discord mencapai kinerja iOS asli dengan React Native</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id492374/index.html">Eksperimen: Redux dari dunia OOP</a></li>
<li><a href="../id492376/index.html">Cara membuat artikel atau dokumentasi Anda dipahami dengan cepat dan akurat</a></li>
<li><a href="../id492378/index.html">Reactjs, Material-UI dengan JSS. Panduan singkat</a></li>
<li><a href="../id492384/index.html">Hack The Box - Postman Walkthrough Redis dan WebMin</a></li>
<li><a href="../id492386/index.html">Bagaimana sektor TI membantu dunia membuang lebih sedikit makanan</a></li>
<li><a href="../id492392/index.html">IntelliJ IDEA Tips & Trik: 3. Menyesuaikan gaya kode untuk setiap folder</a></li>
<li><a href="../id492394/index.html">Dark Universe. Bagian 2</a></li>
<li><a href="../id492398/index.html">Kami mengkonfigurasi perangkat kami untuk pekerjaan jarak jauh, podcasting, video dan streaming</a></li>
<li><a href="../id492404/index.html">Flutter + arduino nano 33 BLE sense = sensor BLE yang sangat sederhana</a></li>
<li><a href="../id492406/index.html">Podcast untuk geek: beberapa program yang telah terbukti tentang manajemen proyek, analisis teknologi dan GTD</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>