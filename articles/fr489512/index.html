<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤵🏿 🤳🏿 👩‍🚀 Battement. BlOC, fournisseur, async - Shelf Architecture 🧒 👌 🤚🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="introduction
 Lorsque vous essayez d'écrire une application, la première chose que vous rencontrez est de savoir comment organiser l'architecture de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Battement. BlOC, fournisseur, async - Shelf Architecture</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/489512/"><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque vous essayez d'écrire une application, la première chose que vous rencontrez est de savoir comment organiser l'architecture de l'application. </font><font style="vertical-align: inherit;">Et en ce qui concerne Flutter, la tête peut complètement contourner ce que Google donne - Vanilla, Scoped Model, BLoC, MVP, MVC, MVVM, MVI, etc. </font><font style="vertical-align: inherit;">Supposons que vous décidiez d'aller de la manière la plus à la mode (celle que Google a conseillé en 2018) et d'utiliser BLOC. </font><font style="vertical-align: inherit;">Qu'Est-ce que c'est? </font><font style="vertical-align: inherit;">Comment l'utiliser? </font><font style="vertical-align: inherit;">Ou peut-être Redux ou RxDart? </font><font style="vertical-align: inherit;">- bien que l'arrêt concerne «l'autre» ... Mais quoi de neuf? </font><font style="vertical-align: inherit;">Quelles bibliothèques connecter? </font><font style="vertical-align: inherit;">Bloc, Flutter_bloc, bloc_pattern, etc.? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un tel nombre d'options d'architecture et d'outils pour leur mise en œuvre peut vraiment retarder longtemps la phase de sélection.</font></font><br>
<a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour qui l'article</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'article sera principalement utile à ceux qui commencent tout juste à apprendre Flutter et ne savent pas par où commencer. </font><font style="vertical-align: inherit;">Je vais montrer une des options pour implémenter l'application sur Flutter. </font><font style="vertical-align: inherit;">Cela vous permettra de «sentir» Flutter, puis de décider par vous-même comment et à l'aide de quoi vous allez écrire vos applications.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modèles et outils. </font><font style="vertical-align: inherit;">Bref et simple</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons donc. La première chose à noter est qu'il existe une architecture d'application (modèle, modèle, concept de construction) - c'est exactement la même chose: BLoC, MVP, MVC, MVVM, MVI, etc. Beaucoup de ces architectures sont utilisées non seulement dans Flutter, mais aussi dans d'autres langages de programmation. Question - que choisir? À mon avis, vous devez choisir ce que vous connaissez bien, mais seulement si cela implique une réactivité et une séparation stricte de la logique métier de l'interface (oui, oui - «une voiture peut être de n'importe quelle couleur si elle est noire»). Quant à la séparation de l'interface et de la logique métier, je pense qu'il n'y a pas lieu d'expliquer, mais quant à la réactivité - essayez, si vous n'avez pas essayé - au final c'est vraiment très pratique et «beau». Si vous ne pouvez pas le choisir vous-même, alors laissez-le faire pour nous par les gars les plus stupides de Google - BLOC. Nous avons compris l'architecture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, les outils - il y a des bibliothèques prêtes à l'emploi - Bloc, Flutter_bloc, bloc_pattern - quel est le meilleur? Je ne sais pas - tout le monde est bon. Vous pouvez choisir et comparer pendant longtemps, mais là encore, comme dans l'armée - il vaut mieux prendre une mauvaise décision pour l'instant que de ne pas en prendre. Et pour l'instant, je suggère de revenir dans le sillage du mod et d'utiliser Provider (ce que les mêmes gars recommandent d'utiliser en 2019).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout cela nous permettra de faire à la fois bloc global et bloc local, selon les besoins. </font><font style="vertical-align: inherit;">Beaucoup a été écrit sur l'architecture de BLoC (à savoir un modèle, pas des bibliothèques), je pense que vous ne devriez pas vous y attarder en détail. </font><font style="vertical-align: inherit;">Je note un seul point dans cet article, le BLoC classique ne sera pas utilisé, mais légèrement modifié - dans les actions BLoC (événements) ne seront pas transmises via Sinks, mais les fonctions BLoC seront appelées. </font><font style="vertical-align: inherit;">Simplement, pour le moment, je ne vois pas les avantages d'utiliser des éviers - et comme ils ne sont pas là, alors pourquoi compliquer votre vie?</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Calcul asynchrone et parallèle dans Dart</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela vaut également la peine de clarifier le concept d'asynchronie dans Dart, car nous parlons de réactivité. Très souvent, aux premiers stades de la connaissance de Dart, la signification des fonctions asynchrones (async) n'est pas correctement comprise. Vous devez toujours vous rappeler que «par défaut», le programme s'exécute dans un seul thread, et l'asynchronie vous permet uniquement de modifier la séquence de commandes, plutôt que de les exécuter en parallèle. Autrement dit, si vous exécutez simplement la fonction avec des calculs volumineux simplement en la marquant comme asynchrone, l'interface sera bloquée. Async ne démarre PAS un nouveau thread. Comment asynchroniser et attendre le travail, il y a beaucoup d'informations sur Internet, donc je ne m'attarderai pas là-dessus non plus.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous devez faire de gros calculs et en même temps ne pas bloquer l'interface, vous devez utiliser la fonction de calcul (pour le hardcore spécial, vous pouvez utiliser des isolats). </font><font style="vertical-align: inherit;">Cela va vraiment démarrer un thread d'exécution séparé, qui aura également sa propre zone de mémoire séparée (ce qui est très triste et triste). </font><font style="vertical-align: inherit;">Vous ne pouvez communiquer avec de tels flux que par le biais de messages pouvant contenir des types de données simples, leurs listes.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mettons-nous à la pratique</font></font></h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formulation du problème</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons d'écrire l'application la plus simple - que ce soit une sorte d'annuaire téléphonique. </font><font style="vertical-align: inherit;">Nous utiliserons Firebase comme stockage - cela nous permettra de créer une application "cloud". </font><font style="vertical-align: inherit;">Je vais ignorer comment connecter Firebase au projet (plus d'un article a été écrit sur ce sujet et je ne vois pas l'intérêt de le répéter. Remarque: Cloud Firestore est utilisé dans ce projet.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela devrait être comme ceci:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xy/yj/js/xyyjjsknqbe1owqlc1vnbnec-pu.gif"><br>
<br>
<h1> <br>
</h1><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Description de l'application</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre application contiendra en externe:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenêtre d'autorisation Firebase (la logique de cette fenêtre sera contenue dans MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenêtre d'information - affichera des informations sur l'utilisateur sous lequel le programme est autorisé (la logique de cette fenêtre sera également contenue dans MainBloc).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenêtre de répertoire sous la forme d'une liste de téléphones (la logique de cette fenêtre sera contenue dans un PhonebookBloc séparé).</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu d'application qui changera d'écran.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'application interne sera construite comme suit: chaque écran contiendra un fichier avec des widgets d'écran, un fichier de bloc (avec la classe de bloc correspondante), un fichier d'actions (contient des classes simples décrivant les événements qui affectent l'état du bloc), un fichier d'états (contient des classes simples qui reflètent l'état du bloc ), le fichier data_model contenant la classe de référentiel (responsable de la réception des données) et la classe de données (stocke les données de logique métier de bloc).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'application fonctionnera comme ceci - lorsque l'écran est ouvert, le bloc correspondant est initialisé avec la valeur d'état initiale et, si nécessaire, une action initiale est appelée dans le constructeur de bloc. </font><font style="vertical-align: inherit;">L'écran est construit / reconstruit en fonction de l'état, qui renvoie le bloc. </font><font style="vertical-align: inherit;">L'utilisateur effectue certaines actions dans l'application qui ont des actions correspondantes. </font><font style="vertical-align: inherit;">Les actions sont transmises à la classe de bloc, où elles sont traitées dans la fonction mapEventToState et le bloc renvoie le nouvel état à l'écran, en fonction duquel l'écran est reconstruit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Structure des fichiers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous créons un projet Flutter vide et créons la structure du projet de ce type (je note que dans le projet de démonstration, certains fichiers resteront éventuellement vides):</font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/r5/5j/h8r55j-7shyieywjwqkpkj-lwxi.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenêtre d'autorisation. </font><font style="vertical-align: inherit;">Mainbloc</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez maintenant implémenter l'autorisation dans Firebase. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Commençons par créer des classes d'événements (il est pratique de transférer des données via des événements en bloc) et des états pour le bloc principal: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fichier MainBloc \ actions</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocAction</span></span>{<font></font>
  String get password =&gt; <span class="hljs-keyword">null</span>;<font></font>
  String get email =&gt; <span class="hljs-keyword">null</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fichier MainBloc \ states</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainBlocState</span></span>{<font></font>
  bool busy;<font></font>
  MainBlocState({<span class="hljs-keyword">this</span>.busy = <span class="hljs-keyword">false</span>});<font></font>
  copy(bool busy) {<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'indicateur occupé dans la classe d'état est utilisé pour afficher progress_hud dans l'interface et exclure les lectures de données inutiles de la base de données lors du défilement dans la liste. </font><font style="vertical-align: inherit;">Avant que toutes les opérations du bloc ne commencent, un nouvel état de l'ancien type avec l'indicateur occupé est émis vers le flux de sortie - de cette façon, l'interface reçoit une notification indiquant que l'opération a commencé. </font><font style="vertical-align: inherit;">À la fin de l'opération, un nouvel état est envoyé au flux avec l'indicateur occupé effacé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les héritiers de la classe MainBlocState décrivent l'état du bloc d'application principal. </font><font style="vertical-align: inherit;">Les héritiers de MainBlocAction décrivent les événements qui s'y produisent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe MainBloc contient 4 éléments principaux - la fonction de "conversion" des événements en états (Future mapEventToState), l'état Bloc est _blocState, le référentiel d'état de bloc est le repo et le flux d'état "de sortie" (dont les éléments d'interface suivent) est blocStream. Fondamentalement, ce sont tous des éléments qui fournissent une fonctionnalité bloc-a. Parfois, il est conseillé d'utiliser 2 flux de sortie dans un bloc - un tel exemple sera plus faible. Je ne l'énumérerai pas ici - vous pouvez le voir en téléchargeant le projet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe de référentiel de bloc contient la logique de travail avec Firebase et un objet (données) qui stocke les données nécessaires à la logique métier que ce bloc implémente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fichier MainBloc \ data_model</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainRepo</span></span>{<font></font>
<font></font>
  <span class="hljs-keyword">final</span> MainData data = MainData();<font></font>
<font></font>
  FirebaseAuth get firebaseInst =&gt; MainData.firebaseInst;<font></font>
<font></font>
  FirebaseUser _currentUser;<font></font>
<font></font>
  <span class="hljs-function">Future&lt;bool&gt; <span class="hljs-title">createUserWithEmailAndPassword</span><span class="hljs-params">(
      String email, String password)</span> async </span>{
    <span class="hljs-keyword">var</span> dataUser;
      <span class="hljs-keyword">try</span> {<font></font>
        dataUser =<font></font>
            (await firebaseInst.createUserWithEmailAndPassword(<font></font>
                email: email, password: password))<font></font>
                .user;<font></font>
      } <span class="hljs-keyword">catch</span> (e) {<font></font>
        print(Error.safeToString(e));<font></font>
        print(e.code);<font></font>
        print(e.message);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (dataUser == <span class="hljs-keyword">null</span>){<font></font>
        data.setState(IsNotLogged());<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<font></font>
      }<font></font>
<font></font>
      _currentUser = dataUser;<font></font>
      data.setState(IsLogged(),<font></font>
          uid: _currentUser.uid,<font></font>
          email: _currentUser.email);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<font></font>
  }<font></font>
<font></font>
  ...}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainData</span> </span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> firebaseInst = FirebaseAuth.instance;
  <span class="hljs-keyword">static</span> MainBlocState _authState = IsNotLogged();
  <span class="hljs-keyword">static</span> MainBlocState get authState =&gt; _authState;
  <span class="hljs-keyword">static</span> String _uid;
  <span class="hljs-keyword">static</span> String get uid =&gt; _uid;
  <span class="hljs-keyword">static</span> String _email;
  <span class="hljs-keyword">static</span> String get email =&gt; _email;<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(MainBlocState newState,
      {String uid = <span class="hljs-string">''</span>, String email = <span class="hljs-string">''</span>})</span> </span>{<font></font>
    _authState = newState;<font></font>
    _uid = uid;<font></font>
    _email = email;<font></font>
  }<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La classe MainData stocke également l'état, mais l'état d'autorisation dans Firebase, et non l'état Bloc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons écrit la logique du bloc principal, maintenant nous pouvons commencer à implémenter l'écran d'autorisation / enregistrement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MainBloc est initialisé dans le fichier principal: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier principal</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{
  <span class="hljs-comment">// This widget is the root of your application.</span>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Provider(<font></font>
        create: (context) =&gt; MainBloc(),<font></font>
        dispose: (context, value) =&gt; value.dispose(),<font></font>
        child: MaterialApp(<font></font>
          routes: menuRoutes,<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de faire une petite digression sur StreamBuilder, Provider, StreamProvider, Consumer et Selector.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Retraite sur les fournisseurs</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fournisseur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - transfère uniquement la valeur stockée dans l'arborescence. Et vous ne pouvez y accéder qu'après la génération de l'enfant, c'est-à-dire vous devez créer un sous-widget. Pas responsable de la mise à jour des widgets. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamBuilder</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un widget qui surveille le flux et est complètement reconstruit lorsqu'il </font><b><font style="vertical-align: inherit;">reçoit un</font></b><font style="vertical-align: inherit;"> nouvel objet du flux. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">StreamProvider</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un widget qui surveille le flux et lorsqu'un nouvel objet est reçu, il signale que les widgets enfants (ceux qui sont déclarés en tant que classe distincte avec la méthode de construction) doivent être reconstruits. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consumer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selector</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des «sucres syntaxiques», c'est-à-dire il s'agit en fait d'un «wrapper» qui contient la construction et masque le widget en dessous. Dans Selector-e, vous pouvez effectuer un filtrage supplémentaire des mises à jour.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, lorsque vous devez reconstruire la plupart de l'écran à chaque événement, vous pouvez utiliser l'option avec Provider et StreamBuilder. </font><font style="vertical-align: inherit;">Lorsqu'il est nécessaire de reconstruire des parties de l'arborescence des widgets près des feuilles, il est conseillé d'utiliser StreamProvider en combinaison avec Consumer et Selector pour exclure les reconstructions inutiles de l'arborescence.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Autorisation </font><font style="vertical-align: inherit;">Continuation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la saisie de l'application, l'utilisateur doit accéder à la fenêtre d'autorisation / d'enregistrement, et à ce moment le menu de l'application ne devrait pas encore être disponible pour lui. Le deuxième point - pour rafraîchir partiellement cet écran n'a pas beaucoup de sens, nous pouvons donc utiliser StreamBuilder pour construire l'interface. Et le troisième point du projet utilise Navigator pour naviguer entre les écrans. Lors de la réception d'un événement d'autorisation réussie, il est nécessaire d'appeler la transition vers l'écran d'informations. Mais juste à l'intérieur de Build StreamBuilder, cela ne fonctionnera pas - il y aura une erreur. Pour contourner ce problème, vous pouvez utiliser la classe wrapper auxiliaire StreamBuilderWithListener (Eugene Brusov - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stackoverflow.com</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, la liste de cet écran est auth_screen lui-même (je vais donner ici en partie): </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fichier auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
  <span class="hljs-keyword">var</span> bloc = Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
  <span class="hljs-keyword">return</span> StreamBuilderWithListener&lt;MainBlocState&gt;(<font></font>
      stream: bloc.blocStream.stream,<font></font>
      listener: (value) {<font></font>
        <span class="hljs-comment">//not allowed call navigator push in build</span>
        <span class="hljs-keyword">if</span> (value is IsLogged) {<font></font>
          Navigator.of(context).pushReplacementNamed(InfoScreen.nameMenuItem);<font></font>
        }<font></font>
      },<font></font>
      initialData: bloc.state,<font></font>
      builder: (context, snappShot) {<font></font>
        <span class="hljs-keyword">if</span> (snappShot.data is IsLoggedOnStart) {
          <span class="hljs-keyword">return</span> LoggedWidget();<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsLogged) {
          <span class="hljs-comment">//not allowed call navigator push in build</span>
          <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
              inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
          child: Text(<span class="hljs-string">''</span>),);<font></font>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snappShot.data is IsNotLogged) {
          <span class="hljs-keyword">return</span> SignInAndSignUpWidget();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> Scaffold(body: Text(<span class="hljs-string">"                Unknown event"</span>));<font></font>
      });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, un StreamBuilderWithListener est créé pour écouter le flux depuis le bloc. </font><font style="vertical-align: inherit;">Et en fonction de l'état actuel, le widget LoggedWidget (si l'utilisateur est déjà connecté) ou SignInAndSignUpWidget (si l'utilisateur n'est pas encore connecté) est appelé. </font><font style="vertical-align: inherit;">Si bloc renvoie l'état IsLogged, le basculement vers un nouvel écran à l'aide de Navigator ne se produit pas dans le générateur (ce qui entraînerait une erreur), mais dans l'écouteur. </font><font style="vertical-align: inherit;">Dans les widgets sous-jacents, l'interface est construite sur la base des données renvoyées ici. </font><font style="vertical-align: inherit;">Ici, le bundle Provider + StreamBuilder est réellement utilisé, car </font><font style="vertical-align: inherit;">lorsque l'état du bloc change, pratiquement toute l'interface change. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour transférer des données vers un bloc, TextEditingController et les paramètres d'action sont utilisés: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fichier auth_screen</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_SignUpWidgetWidgetState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span> </span>{<font></font>
  String _email, _password;<font></font>
<font></font>
  <span class="hljs-keyword">final</span> TextEditingController _emailController = TextEditingController();
  <span class="hljs-keyword">final</span> TextEditingController _passwordController = TextEditingController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _emailController.addListener(_onEmailChanged);<font></font>
    _passwordController.addListener(_onPasswordChanged);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">return</span> Column(<font></font>
      children: &lt;Widget&gt;[<font></font>
        TextFormField(<font></font>
          controller: _emailController,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'email'</span>),<font></font>
        ),<font></font>
        TextFormField(<font></font>
          controller: _passwordController,<font></font>
          obscureText: <span class="hljs-keyword">true</span>,<font></font>
          decoration: InputDecoration(<font></font>
              labelText: <span class="hljs-string">'password'</span>),<font></font>
        ),<font></font>
        RaisedButton(<font></font>
            child: Text(<span class="hljs-string">'sign up'</span>),<font></font>
            onPressed: () {<font></font>
              Provider.of&lt;MainBloc&gt;(context, listen: <span class="hljs-keyword">false</span>).mapEventToState(<font></font>
                  Registration(_email, _password));<font></font>
            })<font></font>
      ],<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _emailController.dispose();<font></font>
    _passwordController.dispose();<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onEmailChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _email = _emailController.text;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_onPasswordChanged</span><span class="hljs-params">()</span> </span>{<font></font>
    _password = _passwordController.text;<font></font>
  }<font></font>
}<font></font>
 <font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenêtre PhoneBookScreen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et maintenant, parlons un peu de notre fenêtre PhoneBookScreen. C'est la fenêtre la plus intéressante - ici l'interface est construite sur la base de 2 flux de bloc, et il y a aussi une liste avec défilement et pagination (pagination). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen File</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhonebookTopPart</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StatelessWidget</span> </span>{<font></font>
<font></font>
  <span class="hljs-function">StatefulWidget <span class="hljs-title">caseWidget</span><span class="hljs-params">(PhonebookState state)</span> </span>{
    <span class="hljs-keyword">if</span> (state is PhonebookListOpened) {
      <span class="hljs-keyword">return</span> PhonebookList();
    <span class="hljs-comment">//} else if (data is PhonebookCardToViewOpened) {</span>
    }<span class="hljs-keyword">else</span> ModalProgressHUD(<font></font>
      inAsyncCall: <span class="hljs-keyword">true</span>,<font></font>
      child: Text(<span class="hljs-string">''</span>),);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">return</span> StreamProvider&lt;PhonebookState&gt;(<font></font>
        create: (context) =&gt; bloc.blocStream.stream,<font></font>
        initialData: bloc.state,<font></font>
        child: Selector&lt;PhonebookState,PhonebookState&gt;(<font></font>
            selector: (_,state)=&gt;state,<font></font>
            shouldRebuild: (previous, next){<span class="hljs-keyword">return</span> (previous.runtimeType!=next.runtimeType);},<font></font>
            builder: (_, state, __) { <span class="hljs-keyword">return</span> ModalProgressHUD(<font></font>
                inAsyncCall: state.busy,<font></font>
                child: Scaffold(<font></font>
                  appBar: AppBar(<font></font>
                    title: Text(<span class="hljs-string">"Phones list"</span>),<font></font>
                  ),<font></font>
                  drawer: MenuWidget(),<font></font>
                  body: caseWidget(state),<font></font>
                ));}<font></font>
        ));<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier StreamProvider est nécessaire pour basculer entre les différents écrans du répertoire - liste, carte de contact, carte de contact pour l'édition, etc. Le widget pour l'écran est sélectionné dans la fonction caseWidget (mais dans cet exemple, seule la vue de la liste est implémentée - vous pouvez essayer d'implémenter la vue pour la carte de visite - c'est très simple et ce ne sera pas un mauvais début.). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sur cet écran, un tas de StreamProvider + Selector / Consumer est déjà utilisé, car il y a un défilement de la liste et il n'est pas conseillé de reconstruire l'écran entier avec lui (c'est-à-dire que la reconstruction des widgets provient du sélecteur / consommateur correspondant et plus bas dans l'arborescence). </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et voici l'implémentation de la liste elle-même: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PhonebookScreen \ screen file</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">_PhonebookListState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">PhonebookList</span>&gt; </span>{<font></font>
  ScrollController _scrollController = ScrollController();<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">super</span>.initState();<font></font>
    _scrollController.addListener(_scrollListener);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function">Widget <span class="hljs-title">build</span><span class="hljs-params">(BuildContext context)</span> </span>{
    <span class="hljs-keyword">var</span> bloc = Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>);
    <span class="hljs-keyword">var</span> list = bloc.repo.data.list;
    <span class="hljs-keyword">return</span> Container(<font></font>
        child: StreamProvider&lt;PhonebookState&gt;(<font></font>
            create: (context) =&gt; bloc.scrollStream.stream,<font></font>
            initialData: bloc.scrollState,<font></font>
            child: Consumer&lt;PhonebookState&gt;(<font></font>
              builder: (_, state, __) {<font></font>
                <span class="hljs-keyword">return</span> ListView.builder(<font></font>
                    controller: _scrollController,<font></font>
                    itemCount: list.length,<font></font>
                    itemBuilder: (BuildContext context, <span class="hljs-keyword">int</span> index) {
                      <span class="hljs-keyword">return</span> ListTile(<font></font>
                        title: Text(list[index].data[<span class="hljs-string">'name'</span>]),<font></font>
                        subtitle: Text(list[index].data[<span class="hljs-string">'phone'</span>]),<font></font>
                      );<font></font>
                    });<font></font>
              },<font></font>
            )));<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">_scrollListener</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">double</span> delta = MediaQuery<font></font>
        .of(context)<font></font>
        .size<font></font>
        .height * <span class="hljs-number">3</span>;
    <span class="hljs-keyword">double</span> maxScroll = _scrollController.position.maxScrollExtent;
    <span class="hljs-keyword">double</span> currentScroll = _scrollController.position.pixels;
    <span class="hljs-keyword">if</span> (maxScroll - currentScroll &lt;= delta) {<font></font>
      Provider.of&lt;PhonebookBloc&gt;(context, listen: <span class="hljs-keyword">false</span>)<font></font>
          .mapEventToState(ScrollPhonebook());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@override</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dispose</span><span class="hljs-params">()</span> </span>{<font></font>
    _scrollController.removeListener(_scrollListener);<font></font>
    <span class="hljs-keyword">super</span>.dispose();<font></font>
  }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous voyons le deuxième StreamProvider, qui surveille le deuxième flux de bloc, qui est responsable du défilement. La pagination est organisée en standard via _scrollListener (contrôleur: _scrollController). Bien que la fenêtre soit intéressante, mais étant donné la description détaillée de la première fenêtre, il n'y a rien de plus à dire ici. Par conséquent, c'est tout aujourd'hui.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'objectif de cet article n'était pas de montrer le code parfait, c'est-à-dire que vous pouvez trouver ici de nombreux points pour l'optimisation - correctement «divisé» en fichiers, utilisez une instance, des mixins et similaires quelque part. </font><font style="vertical-align: inherit;">En outre, ce qui "supplie" la prochaine étape - vous pouvez créer une carte de contact. </font><font style="vertical-align: inherit;">La tâche principale était de structurer les connaissances, de définir un certain vecteur pour la construction de l'application, de donner des explications sur certains moments de la conception d'une application sur Flutter qui n'étaient pas très évidents aux premiers stades de la connaissance. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le projet peut être téléchargé à</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (pour l'inscription, vous pouvez utiliser n'importe quel courrier avec un mot de passe d'au moins 6 caractères. Lors de la nouvelle autorisation, le mot de passe doit être le même que celui utilisé lors de l'inscription).</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr489496/index.html">Recherche d'employés et recherche d'emploi: ma vision de l'intérieur et de l'extérieur</a></li>
<li><a href="../fr489500/index.html">Évaluation des tâches aux points d'histoire</a></li>
<li><a href="../fr489502/index.html">Sélénium + AutoIT. Windows Test Automation Windows</a></li>
<li><a href="../fr489504/index.html">Comment commencer à créer une carte dans UE4</a></li>
<li><a href="../fr489510/index.html">Essayer de résoudre le problème du choix des billets avant les vacances # 2</a></li>
<li><a href="../fr489514/index.html">Téléchargez et stockez gratuitement des fichiers de toute taille sur Google Drive. Bug ou fonctionnalité?</a></li>
<li><a href="../fr489516/index.html">Friends React Native et Fastlane</a></li>
<li><a href="../fr489518/index.html">Les membres échangent un échange à faible coût aux États-Unis</a></li>
<li><a href="../fr489526/index.html">Jeux à somme nulle et conditions de Karush-Kun-Takker</a></li>
<li><a href="../fr489528/index.html">Vous ne regardez pas les publicités pendant le développement? Désordre</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>