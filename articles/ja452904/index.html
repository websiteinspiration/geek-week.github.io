<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏼 🥅 🍀 マシンの通信方法-MQTTプロトコル 🌳 🤾🏻 😟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="前回の記事では、M2Mインタラクションの事実上の業界標準であるModbusプロトコルについて説明しました。1979年に開発され、MQTTが解決する多くの重大な欠点があります。 MQTTプロトコルは非常に新しい（2016年にのみ標準化された）が、すでに業界やIoTで広く使用されている。これは、不安定な...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>マシンの通信方法-MQTTプロトコル</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/advantech/blog/452904/"><div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/nb/fv/om/nbfvom_zwqoyqg4e4bcxwl1ax7a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回の記事</font><font style="vertical-align: inherit;">では、</font><abbr title="機械加工"><font style="vertical-align: inherit;">M2M</font></abbr><font style="vertical-align: inherit;">インタラクションの</font><font style="vertical-align: inherit;">事実上の業界標準</font><font style="vertical-align: inherit;">で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あるModbusプロトコル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について説明しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">1979年に開発され、MQTTが解決する多くの重大な欠点があります。</font><font style="vertical-align: inherit;">
MQTTプロトコルは非常に新しい（2016年にのみ標準化された）が、すでに業界やIoTで広く使用されている。</font><font style="vertical-align: inherit;">これは、不安定なインターネットチャネルや低電力デバイス用にできるだけコンパクトになるように特別に設計されており、パケット損失や切断が発生した場合でもメッセージの配信を保証できます。</font><font style="vertical-align: inherit;">
MQTTプロトコルの主な機能：</font></font><abbr title="機械加工"><font style="vertical-align: inherit;"></font></abbr><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパクトで軽量</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -トラフィックを節約するための最小限のデータ転送オーバーヘッド。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">損失への耐性</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -ネットワーク接続が不安定な状態での配信が保証されます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -多数のデバイスにサービスを提供でき、ネットワークの遅延に依存しません。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoSサポート</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -メッセージの優先度を制御し、受信者へのメッセージ配信を保証する機能。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">動的構成</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -フィールドやデータ形式を事前に調整する必要がなく、その場で構成できます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはNATで機能します</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -クライアントはNATの背後にあることができ、サーバー（ブローカー）のみが実際のIPを持っている必要があります。</font><font style="vertical-align: inherit;">VPNおよびポート転送なしで実行できます。</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">便利なアドレス指定</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -データフィールドには、人間が理解できるテキスト名が付けられています。</font><font style="vertical-align: inherit;">デジタルアドレスとビットオフセットを覚える必要はありません。</font></font></li>
</ul><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTとModbusを比較する記事では、プロトコル構造、基本概念を分析し、不安定なインターネット接続でクラウドMQTTブローカーを例として使用してみます。 </font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTTプロトコル履歴</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTはIBMによって1999年に開発され、当初はソリューションの内部で使用されていました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2011年11月、IBMとEurotechはEclipse M2Mワーキンググループへの参加とMQTTコードのEclipse Pahoプロジェクトへの移行を発表しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2013年、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OASIS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（Organization for the Advancement of Structured Information Standards）</font><font style="vertical-align: inherit;">コンソーシアム</font><font style="vertical-align: inherit;">は、MQTTプロトコルの標準化プロセスを開始しました。この時点まで、プロトコル仕様は無料のライセンスの下で公開されており、Eurotech（旧称Arcom）などの企業はすでに製品でプロトコルを使用しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2014年10月、OASISは最初の公式MQTTプロトコル標準を公開しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロトコルは2016年に国際標準化機構ISOによって標準化され、ISO / IEC 20922の番号を受け取りました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2014年以降、プロトコルへの関心が急速に高まり、Google Trendsのスケジュールから判断すると、Modbusへの関心を上回っています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ia/6q/cw/ia6qcwyvn9p6yi_10xrdgkwbcqu.png"><br>
<font color="999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Googleトレンドベンチマーク</font></font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基本概念</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTはクライアント/サーバーアーキテクチャを備えています。メッセージングは​​、ブローカーと呼ばれる中央サーバーを介して行われます。通常の状態では、クライアントは互いに直接通信できず、すべてのデータ交換はブローカーを介して行われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クライアントは、データプロバイダー（パブリッシャー）およびデータの受信者（サブスクライバー）として機能できます。ロシア語の翻訳では、これらの用語はしばしば出版社および購読者として翻訳されますが、混乱を避けるために、元の用語のみを使用します。</font></font><br>
<br>
<div style="text-align:center;"><img width="400" src="https://habrastorage.org/webt/ex/ri/7r/exri7rw8067vln4jiqq5ma9dine.png"></div><br>
<font color="999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MQTTプロトコルでは、クライアントは中央ノードを介して相互に通信します。</font></font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
アプリケーションレベルでは、プロトコルはTCP / IPの上で実行され、VPNトンネルを必要とせずに、リモートオブジェクトをインターネット経由で直接簡単に接続できます。</font><font style="vertical-align: inherit;">ブローカーが実際のIPアドレスを持っているだけで十分であり、すべてのクライアントがそれに接続できます。</font><font style="vertical-align: inherit;">この場合、クライアントはNATの背後に配置されている可能性があります。</font><font style="vertical-align: inherit;">クライアントはMQTTプロトコルで接続を開始するため、接続を確立するためにポート転送は必要ありませんが、Modbus / TCPではサーバーが接続（マスター）を開始するため、直接ネットワークにアクセスできる必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
着信TCP接続用の標準MQTTブローカーポートは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1883</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">安全なSSL接続を使用する場合、ポート</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8883が使用され</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ブローカ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブローカーは、顧客との対話の中心となるMQTTハブです。</font><font style="vertical-align: inherit;">クライアント間のデータ交換はブローカーを介してのみ行われます。</font><font style="vertical-align: inherit;">ブローカーはサーバーソフトウェアまたはコントローラーです。</font><font style="vertical-align: inherit;">彼のタスクには、顧客からのデータの受信、データの処理と保存、顧客へのデータの配信、およびメッセージ配信の監視が含まれます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャー/サブスクライバー</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パブリッシャーとサブスクライバーの違いを理解するために、簡単な例を見てみましょう。湿度センサーが部屋の湿度を測定し、湿度が特定のレベルを下回ると、加湿器がオンになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、湿度センサーは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャー</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として機能</font><font style="vertical-align: inherit;">します。そのタスクは、ブローカーにデータをパブリッシュすることだけです。加湿器は</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライバ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として機能</font><font style="vertical-align: inherit;">します。加湿器は加湿器をオンにするポイントを決定しながら、湿度データの更新をサブスクライブしてブローカから現在のデータを受信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このスキームでは、MQTTクライアント、つまりセンサーと加湿器は、互いの存在を認識せず、直接対話しません。</font><font style="vertical-align: inherit;">ブローカーは、さまざまなソースからデータを受信し、それらを操作して、たとえば、いくつかのセンサーから平均値を計算し、処理されたデータをサブスクライバーに返すことができます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xc/pb/t8/xcpbt8th_jxzdzfglqwxt4wnpwo.png"><br>
<font color="9999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャーがブローカーにデータを送信し、サブスクライバーがこのデータの更新をサブスクライブします。</font></font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
同時に、MQTTプロトコル非同期により、センサーと加湿器が異なる時間にオンラインになり、パケットを失い、アクセスできなくなります。</font><font style="vertical-align: inherit;">ブローカーは、センサーから受信した最新のデータをメモリに保存し、加湿器への配信を保証します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTはトピックを使用してエンティティを識別します。ロシア語の翻訳では、これらはチャネルとも呼ばれます。トピックはUTF8文字で構成され、UNIXファイルシステムと同様のツリー構造を持っています。これは、人間が読める形式でエンティティに名前を付けるための便利なメカニズムです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTのトピックの例</font></font><br>
<br>
<pre><code class="bash hljs"><span class="hljs-comment">#    </span><font></font>
home/kitchen/temperature<font></font>
<font></font>
<span class="hljs-comment">#    </span><font></font>
home/sleeping-room/temperature<font></font>
<font></font>
<span class="hljs-comment">#     </span><font></font>
home/outdoor/light<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチにより、送信されるデータを視覚的に確認でき、Modbusで行われるように、データ配置のデジタルアドレスを記憶する必要なく、コードを開発およびデバッグするのに便利です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トピックには、UNIXファイルシステムで作業したことがある人にはおなじみのワイルドカード構文も含まれます。</font><font style="vertical-align: inherit;">ワイルドカードは、単一レベルと複数レベルにすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シングルレベルのワイルドカードは</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+で</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示され</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、家のすべての部屋の温度センサーからデータを受信するには、サブスクライバーはそのようなトピックにサブスクライブする必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">home/+/temperature
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、彼はそのようなセンサーからデータを受信するようにサブスクライブします。</font></font><br>
<br>
<pre><code class="plaintext hljs">home/kitchen/temperature<font></font>
home/sleeping-room/temperature<font></font>
home/living-room/temperature<font></font>
home/outdoor/temperature<font></font>
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マルチレベルのワイルドカードは、記号「</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">＃</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で</font><font style="vertical-align: inherit;">示され</font><font style="vertical-align: inherit;">ます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
家のすべての部屋にあるすべてのセンサーからデータを取得する例：</font></font><br>
<br>
<pre><code class="plaintext hljs">home/#
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなトピックにサブスクライブすると、そのようなセンサーからデータを受け取ることができます。</font></font><br>
<br>
<pre><code class="plaintext hljs">home/kitchen/temperature<font></font>
home/kitchen/humidity<font></font>
home/kitchen/light<font></font>
home/sleeping-room/temperature<font></font>
home/sleeping-room/humidity<font></font>
home/sleeping-room/light<font></font>
....<font></font>
</code></pre> <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顧客識別</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アクセス制御については、MQTTはModbusプロトコルとは異なり、クライアント認証を提供します。Modbusプロトコルにはそのような機能はありません。</font><font style="vertical-align: inherit;">次のフィールドは、アクセス制御に使用されます</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ClientId-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（必須フィールド）クライアントの一意の識別子。</font><font style="vertical-align: inherit;">各顧客に固有である必要があります。</font><font style="vertical-align: inherit;">MQTT 3.1.1標準の現在のバージョンでは、接続ステータスを保存する必要がない場合は、空のClientIdフィールドを使用できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー名</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -（オプションのフィールド）認証のためのログイン（UTF-8形式）。</font><font style="vertical-align: inherit;">ユニークではないかもしれません。</font><font style="vertical-align: inherit;">たとえば、クライアントのグループは同じユーザー名/パスワードでログインできます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パスワード</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-（オプションのフィールド）はユーザー名フィールドと一緒にのみ送信できますが、ユーザー名はパスワードフィールドなしで送信できます。</font><font style="vertical-align: inherit;">最大65535バイト。</font><font style="vertical-align: inherit;">名前とパスワードは平文で送信されるため、データがパブリックネットワーク経由で送信される場合は、SSLを使用して接続を暗号化する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パッケージ構造</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のように、MQTTプロトコルでは、クライアントはデータの受信者（サブスクライバー）であるかサプライヤー（パブリッシャー）であるかに関係なく、常に接続を開始します。</font><font style="vertical-align: inherit;">Wiresharkプログラムを使用して、接続が遮断されているパケットを分析します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ep/0t/hv/ep0thv6e3zsvyzgizw89gpxgytg.png"><br>
<font color="999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">暗号化されていないチャネルを介して送信されたMQTTオプション付きのパケット</font></font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
TCPヘッダーは、パケットがポート1883で送信されたこと、つまり暗号化が使用されていないことを示します。つまり、ログインやパスワードを含め、すべてのデータがクリア形式で利用できます。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">見出し</font></font></h4><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メッセージタイプ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はConnect（コマンド0x0001）で、ブローカーとの接続を確立します。</font><font style="vertical-align: inherit;">主なチーム：接続、切断、公開、購読、購読解除。</font><font style="vertical-align: inherit;">承認、キープアライブなどのコマンドもあります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フラグ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DUP-メッセージが再送信されることを意味します。これは、ブローカーが前のメッセージの受信の確認を受信しなかった場合に、メッセージタイプPUBLISH、SUBSCRIBE、UNSUBSCRIBE、PUBRELでのみ使用されます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoSレベル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -サービス品質のフラグ。</font><font style="vertical-align: inherit;">このトピックについては、後で詳しく説明します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保持</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -保持フラグで公開されたデータはブローカーに保存されます。</font><font style="vertical-align: inherit;">このトピックへの後続のサブスクリプション時に、ブローカーはすぐにこのフラグを使用してメッセージを送信します。</font><font style="vertical-align: inherit;">タイプがパブリッシュのメッセージでのみ使用されます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実用</font></font></h2><br>
<img width="100" src="https://habrastorage.org/webt/v9/m9/2k/v9m92kvqrkibu8zt9pfsdjkngg8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、理論に慣れたところで、実際にMQTTを操作してみましょう。これを行うには、オープン</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mosquitto</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムを使用します</font><font style="vertical-align: inherit;">。これは、クライアントモードとサーバー（ブローカー）モードの両方で機能します。 Windows、macOS、Linuxで動作します。このプログラムは、MQTTプロトコルのデバッグと調査に非常に便利ですが、産業用操作でも広く使用されています。これをクライアントとして使用して、リモートクラウドブローカーとデータを送受信します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのクラウドプロバイダーは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft Azure IoT Hub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Amazon AWS IoT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などのMQTTブローカーサービスを提供</font><font style="vertical-align: inherit;">しています。この例では、Cloudmqtt.comサービスを使用します。これは、登録が最も単純で、トレーニングには無料の料金で十分であるためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
登録後、ブローカーへの接続の詳細がアカウントに表示されます。パブリックインターネットネットワークを介してサーバーに接続するため、SSLポートを使用してトラフィックを暗号化するのが妥当です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/gh/rq/t5/ghrqt5ady8x8twccmfrtngm-htu.png"><br>
<font color="999999"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラウドプロバイダーの個人アカウントでのMQTTブローカーへのアクセスの詳細</font></font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
MQTTプロトコル</font><font color="999999"><font style="vertical-align: inherit;">の</font></font><font style="vertical-align: inherit;">柔軟性により、クライアントはブローカーで以前に定義されていないデータを転送できます。つまり、パブリッシャーがデータを書き込むために必要なトピックを事前に作成する必要はありません。個人アカウントから受信したデータを使用して、データを</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr / test / random</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックに公開し、</font><i><font style="vertical-align: inherit;">そこ</font></i><font style="vertical-align: inherit;">から読み取る</font><font style="vertical-align: inherit;">リクエストを手動で作成しようとし</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosquitto_sub-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サブスクライバークライアント</font><font style="vertical-align: inherit;">ユーティリティ</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mosquitto_pub-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パブリッシャークライアントユーティリティ</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、サブスクライバーとしてブローカーに接続し、サブスクライブして</font></font><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr / test / random</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピックからデータを受信します</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="plaintext hljs">mosquitto_sub -d --capath /etc/ssl/certs/ --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random<font></font>
Client mosq/zEPZz0glUiR4aEipZA sending CONNECT<font></font>
Client mosq/zEPZz0glUiR4aEipZA received CONNACK (0)<font></font>
Client mosq/zEPZz0glUiR4aEipZA sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00)<font></font>
Client mosq/zEPZz0glUiR4aEipZA received SUBACK<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接続が成功し、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr / test / random</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トピック</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">サブスクライブしたことが</font><b><font style="vertical-align: inherit;">わかり</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。現在、ブローカーからのこのトピックのデータを待機しています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL接続が使用されるため、証明書を検証するには、プログラムがルート暗号化証明書を検索するためのパスを指定する必要があります。</font><font style="vertical-align: inherit;">この例のサービスは信頼できる証明機関によって発行された証明書を使用するため、ルート証明書のシステムストアへのパスを示します</font></font><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。--capath / etc / ssl / certs /</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
自己署名証明書の場合、目的のCAへのパスを指定する必要があります。</font><font style="vertical-align: inherit;">SSL接続-mqtt </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：//と非暗号化接続-mqtt：// </font><font style="vertical-align: inherit;">のURI形式の違いを考慮することも重要</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">証明書の検証エラーが発生した場合、プログラムはエラーメッセージなしで終了します。</font><font style="vertical-align: inherit;">より詳細な出力については、-debugスイッチを使用できます</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> では、最初のプログラムを中断することなく、トピックのデータを公開してみましょう。</font></font><br>
<br>
<pre><code class="plaintext hljs">mosquitto_pub -d --capath /etc/ssl/certs/  --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m " !"<font></font>
Client mosq/sWjh9gf8DRASrRZjk6 sending CONNECT<font></font>
Client mosq/sWjh9gf8DRASrRZjk6 received CONNACK (0)<font></font>
Client mosq/sWjh9gf8DRASrRZjk6 sending PUBLISH (d0, q0, r0, m1, 'habr/test/random', ... (22 bytes))<font></font>
Client mosq/sWjh9gf8DRASrRZjk6 sending DISCONNECT<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データがサーバーによって正常に受信され、目的のトピックで公開されていることがわかります。</font><font style="vertical-align: inherit;">同時に、mosquitto_subプログラムが実行されている最初のウィンドウでは、メッセージがどのように受信されたかを確認できますが、Unicodeでも機能しますが、ロシア語でメッセージを確認できます。</font></font><br>
<br>
<pre><code class="plaintext hljs">Client mosq/zEPZz0glUiR4aEipZA received PUBLISH (d0, q0, r0, m0, 'habr/test/random', ... (22 bytes))<font></font>
 !<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoSと配信の保証</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、メッセージをリアルタイムで転送しても、平凡なユーティリティ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nc</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも同じことができるため、誰も驚かないでしょう</font><font style="vertical-align: inherit;">。したがって、サブスクライバーと送信者の間の不安定な接続をシミュレートしようとします。両方のクライアントがGPRSを介して動作し、大きなパケット損失が発生し、TCP接続が成功することさえまれであり、サブスクライバーが送信者メッセージを確実に受信できるようにする必要があると想像してください。この場合、QoSオプションが役に立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デフォルトでは、メッセージの</font><b><font style="vertical-align: inherit;">QoS</font></b><font style="vertical-align: inherit;">フラグは</font><b><font style="vertical-align: inherit;">0</font></b><font style="vertical-align: inherit;">に設定さ</font><b><font style="vertical-align: inherit;">れ</font></b><font style="vertical-align: inherit;">ています。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、つまり「ファイアアンドフォーゲット」を意味します。パブリッシャーはブローカーでメッセージをパブリッシュしますが、メッセージがサブスクライバーに確実に配信されることを要求しません。これは、湿度や温度の定期的な測定など、損失がそれほど重要ではないデータに適しています。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS 1：少なくとも1回-少なくとも1回</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。このフラグは、パブリッシャーがサブスクライバーへの配信確認を受信するまで、このパブリケーションがブローカーに送信され、次にサブスクライバーに送信されることを意味します。したがって、サブスクライバーはこのメッセージを少なくとも1回受信する必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QoS 2：正確に1回-保証1回</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">QoSフラグ。公開の確認と完了のための追加手順（PUBREC、PUBREL、PUBCOMP）を使用して、メッセージ配信の最高の保証を提供します。</font><font style="vertical-align: inherit;">センサーからのデータの損失と重複を除外する必要がある状況に適用されます。</font><font style="vertical-align: inherit;">たとえば、受信したメッセージからアラームがトリガーされると、緊急コールが発信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不十分な通信をシミュレートするには、両方のクライアントを無効にして、QoS優先度が最も高いメッセージを送信してみてください。また、保持オプションを追加して、送信されたメッセージがブローカーに保存されるようにしてください。</font></font><br>
<br>
<pre><code class="plaintext hljs">mosquitto_pub --retain --qos 2 -d --capath /etc/ssl/certs/  --url mqtt://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random -m "  !" <font></font>
Client mosq/Xwhua3GAyyY9mMd05V sending CONNECT<font></font>
Client mosq/Xwhua3GAyyY9mMd05V received CONNACK (0)<font></font>
Client mosq/Xwhua3GAyyY9mMd05V sending PUBLISH (d0, q2, r1, m1, 'habr/test/random', ... (37 bytes))<font></font>
Client mosq/Xwhua3GAyyY9mMd05V received PUBREC (Mid: 1)<font></font>
Client mosq/Xwhua3GAyyY9mMd05V sending PUBREL (m1)<font></font>
Client mosq/Xwhua3GAyyY9mMd05V received PUBCOMP (Mid: 1, RC:0)<font></font>
Client mosq/Xwhua3GAyyY9mMd05V sending DISCONNECT<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、しばらくして、受信者はようやくインターネットへの接続を確立し、ブローカーに接続できるようになりました。</font></font><br>
<br>
<pre><code class="plaintext hljs">mosquitto_sub  -d --capath /etc/ssl/certs/ -d --url mqtts://hwjspxxt:7oYugN7Fa5Aa@postman.cloudmqtt.com:27529/habr/test/random<font></font>
Client mosq/VAzcLVMB1MiWhYxoJS sending CONNECT<font></font>
Client mosq/VAzcLVMB1MiWhYxoJS received CONNACK (0)<font></font>
Client mosq/VAzcLVMB1MiWhYxoJS sending SUBSCRIBE (Mid: 1, Topic: habr/test/random, QoS: 0, Options: 0x00)<font></font>
Client mosq/VAzcLVMB1MiWhYxoJS received SUBACK<font></font>
Subscribed (mid: 1): 0<font></font>
Client mosq/r6UwPnDvx8aNInpPF6 received PUBLISH (d0, q0, r1, m0, 'habr/test/random', ... (37 bytes))<font></font>
  !<font></font>
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MQTTは、以前のバージョンの多くの欠点がない、最新の高度なプロトコルです。</font><font style="vertical-align: inherit;">その柔軟性により、ブローカーをセットアップせずにクライアントデバイスを追加できるため、時間を大幅に節約できます。</font><font style="vertical-align: inherit;">プロトコルを理解して構成するためのエントリのしきい値は非常に低く、多くのプログラミング言語用のライブラリが存在するため、開発用のテクノロジースタックを選択できます。</font><font style="vertical-align: inherit;">メッセージ配信の保証により、MQTTは以前のものから大幅に区別され、ネットワークレベルで独自の整合性制御メカニズムを不必要に開発して時間を無駄にしないようにすることができます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja452888/index.html">ミュンヘン近郊でフルサイズの5人乗りティルトローターリリウムジェットのテストを開始</a></li>
<li><a href="../ja452890/index.html">5月23日18時30分-QIWIキッチンの生放送</a></li>
<li><a href="../ja452892/index.html">プログラマーではない人がアメリカに移住する方法：ステップバイステップの説明</a></li>
<li><a href="../ja452894/index.html">顔のなりすましまたは技術的に千人の顔から詐欺師を認識する</a></li>
<li><a href="../ja452902/index.html">プログラマーとしての4年間のトレーニングを終了し、プログラマーとはかけ離れていることを理解しています</a></li>
<li><a href="../ja452906/index.html">JavaScriptエンジン：それらはどのように機能しますか？コールスタックからpromiseまで、（ほとんど）知っておくべきすべてのこと</a></li>
<li><a href="../ja452908/index.html">Selenium WebDriver-GrafanaとInfluxDBを使用したリアルタイムテスト指標</a></li>
<li><a href="../ja452910/index.html">こんにちは、ハブル！こんにちはテルコン</a></li>
<li><a href="../ja452914/index.html">実験を恐れない人のための、ScalaでのMLの笑顔</a></li>
<li><a href="../ja452916/index.html">立ち上がって行きます。脊椎手術：いつ行うべきか、何が危険か</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>