<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üïõ üíÖüèæ ‚úåüèΩ Blending et Unity Terrain: comment se d√©barrasser des intersections et arr√™ter de se faire mal aux yeux üî¶ üí™üèº ü§´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Afin d'obtenir un monde r√©aliste √† l'int√©rieur du jeu, il est n√©cessaire de prendre en compte l'interaction de diff√©rentes formes de relief entre elle...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blending et Unity Terrain: comment se d√©barrasser des intersections et arr√™ter de se faire mal aux yeux</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pixonic/blog/490226/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afin d'obtenir un monde r√©aliste √† l'int√©rieur du jeu, il est n√©cessaire de prendre en compte l'interaction de diff√©rentes formes de relief entre elles et avec d'autres mod√®les. </font><font style="vertical-align: inherit;">Et si les lignes d'intersection visibles entre les mod√®les 3D g√¢chent l'int√©grit√© de l'image, il convient de r√©fl√©chir √† la fa√ßon de les √©liminer. </font><font style="vertical-align: inherit;">Le cas le plus courant de ces lignes, qui peut √™tre familier √† beaucoup, est l'intersection de panneaux d'affichage de particules √† g√©om√©trie opaque. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ja/va/g2/javag2i9gc9lhkwohebgbyklsjc.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre exemple est la composition naturelle troublante de l'intersection des roches et de la v√©g√©tation avec la surface du paysage dans les sc√®nes ¬´en plein air¬ª.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/v0/k6/s9/v0k6s98hdon17qotuaryat0vogs.png" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En plus des diverses m√©thodes de lissage (SSAA, MSAA, CSAA, FXAA, NFAA, CMAA, DLAA, TAA, etc.), qui att√©nuent l'apparence provocante de ces lignes d'intersection, mais ne corrigent pas compl√®tement la situation, il existe des techniques plus efficaces. </font><font style="vertical-align: inherit;">Nous les consid√©rerons.</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusion en profondeur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unity a une solution int√©gr√©e pour √©liminer les intersections visibles entre les particules transparentes et la g√©om√©trie opaque appel√©es particules molles. </font><font style="vertical-align: inherit;">Les shaders qui soutiennent cet effet am√©liorent encore la transparence des particules, selon la petite diff√©rence entre la profondeur du fragment de particules et la profondeur de la g√©om√©trie opaque. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mz/wx/9k/mzwx9kecz9hkjps0laijveek-54.png" alt="image"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le principe de fonctionnement des particules molles</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Evidemment, pour le bon fonctionnement des particules molles, un tampon de profondeur est n√©cessaire. </font><font style="vertical-align: inherit;">Dans le cas d'un ombrage diff√©r√©, le tampon de profondeur est form√© au stade du rendu des tampons plein √©cran, et compte tenu des MRT (Multiple Render Targets, et non Magnetic Resonance Tomography), sa pr√©sence ne s'exprime pas en co√ªts de calcul suppl√©mentaires.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas de l'ombrage avant et de l'utilisation du pipeline Unity Legacy, un passage suppl√©mentaire √©tait n√©cessaire pour rendre la g√©om√©trie opaque au tampon de profondeur </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[1]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cette passe est activ√©e en affectant la valeur appropri√©e √† la propri√©t√© Camera.depthTextureMode. </font><font style="vertical-align: inherit;">Cette propri√©t√© n'est pas disponible dans la fen√™tre d'inspection, mais est disponible dans l'API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[2]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez maintenant impl√©menter votre propre version du pipeline de rendu scriptable avec un ombrage direct, qui avec l'aide de MRT peut rendre simultan√©ment le tampon de profondeur et le tampon de couleur. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7z/-b/1l/7z-b1lg9zs8xbsywe6evbmanfiw.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√âlimination des lignes d'intersection dans les shaders qui supportent les particules molles</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
En g√©n√©ral, il n'y a pas d'obstacles techniques √† l'utilisation de la m√©thode de fusion en profondeur pour √©liminer les intersections visibles des mod√®les 3D avec le paysage:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher le code</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">depth</span> <span class="hljs-selector-tag">buffer</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;
<span class="hljs-selector-tag">UNITY_DECLARE_DEPTH_TEXTURE</span>(_<span class="hljs-selector-tag">CameraDepthTexture</span>);<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
    // ...<font></font>
<font></font>
    half4 <span class="hljs-attribute">projPos </span>: TEXCOORD0;<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    o.projPos = ComputeScreenPos(o.pos);<font></font>
    COMPUTE_EYEDEPTH(o.projPos.z);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{     <font></font>
    fixed4 result = 0;<font></font>
      <font></font>
    // ... <font></font>
<font></font>
    float depth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos));<font></font>
    float sceneZ = LinearEyeDepth(depth);<font></font>
    float partZ = i.projPos.z;<font></font>
    float fade = saturate( sceneZ - partZ );<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, fade );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, cette approche pr√©sente plusieurs inconv√©nients. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le premier inconv√©nient est li√© aux performances. Le m√©lange en profondeur fonctionne au stade du m√©lange mat√©riel des tuyaux, c'est-√†-dire imm√©diatement apr√®s la pixellisation et le calcul du fragment shader. √Ä ce stade, le r√©sultat de l'ex√©cution du fragment shader est m√©lang√© au r√©sultat enregistr√© dans le tampon de sortie </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[3] [4] [5]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> selon la formule pr√©d√©finie par les appels √† l'API </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[6] [7] [8] [9]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il s'agit de la partie la moins √©volutive de tout pipeline de mat√©riel en ce sens qu'il fonctionne exactement comme son pr√©d√©cesseur il y a vingt ans. Le GPU lit la valeur de la m√©moire, la m√©lange avec la valeur du fragment shader et la r√©√©crit en m√©moire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe √©galement une diff√©rence entre l'utilisation de la fusion en profondeur pour les mod√®les 3D enti√®rement transparents ou partiellement transparents. Transparent - par exemple, les panneaux d'affichage de particules - m√™me sans se fondre en profondeur, tout le rendu est transparent. Dans le cas des mod√®les 3D opaques, une transparence r√©elle, tangible et visible lors du m√©lange en profondeur ne sera dot√©e que d'un tr√®s petit nombre de fragments, tandis que la grande majorit√© d'entre eux restera opaque. Mais ce dernier ne signifie pas du tout que le m√©lange ne sera pas utilis√© pour leur rendu - il fonctionnera simplement au ralenti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le deuxi√®me inconv√©nient est li√© √† la fa√ßon dont la couleur de m√©lange est s√©lectionn√©e. En bref, alors tous les fragments qui sont m√©lang√©s dans un pixel d'√©cran particulier se trouvent sur un rayon √©manant de la position mondiale de la cam√©ra et passant par la position mondiale de ce pixel d'√©cran. Ceci, √† son tour, signifie qu'avec tout changement de position ou d'orientation de la cam√©ra, la parallaxe sera observ√©e: les fragments du mod√®le 3D situ√©s plus pr√®s de la cam√©ra se d√©placeront plus rapidement que les fragments du paysage situ√©s plus loin de la cam√©ra </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[10] [11]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Cela est particuli√®rement visible lorsqu'on le regarde de pr√®s avec un d√©placement lat√©ral constant de la cam√©ra. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/hz/sc/78/hzsc78n3vvddbvvlgrb3hqkfwxc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallaxe lat√©rale lors du d√©placement de la cam√©ra: les fragments du mod√®le 3D sont d√©cal√©s √† une plus grande distance par rapport aux fragments du paysage</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/5v/zf/wj/5vzfwjmabznaiprchenxb9eqy3q.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallaxe lat√©rale lors du d√©placement de la cam√©ra: lors de la fixation de la cam√©ra sur un fragment du paysage, la vitesse de d√©placement des fragments du mod√®le devient sensible.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lorsque la cam√©ra est tourn√©e, la parallaxe est observ√©e imm√©diatement le long de deux axes des coordonn√©es de l'√©cran. Cependant, en dynamique, cela est moins √©vident que la parallaxe lat√©rale. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qs/ew/jn/qsewjnfucpdriai47zh9032fwcm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallaxe azimutale lorsque la cam√©ra est d√©plac√©e: il est plus difficile pour le cerveau de reconna√Ætre le mod√®le de parallaxe lorsque les fragments sont d√©plac√©s sur deux</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
axes, mais surtout, l'apparence du m√©lange en profondeur change en fonction de l'angle sous lequel l'observateur regarde la surface du paysage. La zone de fusion devient presque invisible lorsque la direction de la vue est perpendiculaire √† la normale √† la surface du paysage, mais la taille de cette zone augmente rapidement si vous inclinez la cam√©ra vers le bas.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hd/r8/gs/hdr8gs_ha63gspkr_eaxowjosna.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Changer la largeur de la zone de fusion lors de l'inclinaison de la cam√©ra</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
en profondeur La fusion peut √™tre une bonne option pour √©liminer les lignes d'intersection des mod√®les 3D avec le paysage, sinon pour l'abondance d'artefacts qui l'accompagnent. </font><font style="vertical-align: inherit;">Cette m√©thode convient mieux aux effets de particules qui ne sont pas statiques et, en r√®gle g√©n√©rale, ne contiennent pas de textures tr√®s d√©taill√©es, par cons√©quent, les effets de parallaxe ne sont pas observ√©s dans leur cas.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange de cartes de hauteur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une autre option pour impl√©menter le m√©lange de paysages consiste √† utiliser une carte de hauteur, √† laquelle Unity donne acc√®s via l'API TerrainData </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[12]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connaissant la position de l'objet Terrain et les dimensions du terrain indiqu√©es dans TerrainData, et ayant une "carte de hauteur" √† port√©e de main, vous pouvez calculer la hauteur du terrain √† tout point sp√©cifi√© en coordonn√©es mondiales. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ga/69/za/ga69zap3c3xnluhjfm68g4_roto.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres de terrain requis pour √©chantillonner la carte des hauteurs</font></font></i><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Setting</span> <span class="hljs-selector-tag">up</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">heightmap</span> <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">uniforms</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">use</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">shaders</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalTexture</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainHeightmap</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapTexture</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.HeightmapScale</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.heightmapScale</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainSize</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.terrainData</span><span class="hljs-selector-class">.size</span>);
<span class="hljs-selector-tag">Shader</span><span class="hljs-selector-class">.SetGlobalVector</span>(<span class="hljs-selector-tag">Uniforms</span><span class="hljs-selector-class">.TerrainPos</span>, <span class="hljs-selector-tag">terrain</span><span class="hljs-selector-class">.transform</span><span class="hljs-selector-class">.position</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eh bien, maintenant, apr√®s avoir calcul√© la hauteur du paysage, vous pouvez √©galement calculer les coordonn√©es uv dans le shader pour √©chantillonner la carte des hauteurs du paysage en coordonn√©es mondiales.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Computes</span> <span class="hljs-selector-tag">UV</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">sampling</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">TerrainUV</span>(<span class="hljs-selector-tag">float3</span> <span class="hljs-selector-tag">worldPos</span>)<font></font>
{<font></font>
    return (worldPos.xz - TerrainPos.xz) / TerrainSize.xz;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de pouvoir utiliser le m√™me code dans les shaders de fragment et de vertex, la fonction tex2Dlod est utilis√©e pour l'√©chantillonnage. </font><font style="vertical-align: inherit;">De plus, la carte de hauteur n'a pas de niveau de mip, donc l'√©chantillonner avec la fonction tex2D, qui calcule automatiquement le niveau de mip, n'a pratiquement aucun sens.</font></font><br>
<br>
<pre><code class="css hljs">// <span class="hljs-selector-tag">Returns</span> <span class="hljs-selector-tag">the</span> <span class="hljs-selector-tag">height</span> <span class="hljs-selector-tag">of</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">given</span> <span class="hljs-selector-tag">position</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">world</span> <span class="hljs-selector-tag">space</span>... <font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">TerrainHeight</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    float heightmapSample = tex2Dlod(TerrainHeightmap, float4(terrainUV,0,0));<font></font>
    return TerrainPos.y + UnpackHeightmap(heightmapSample) * HeightmapScale.y * 2;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez essayer de reproduire l'√©limination des intersections par transparence sans utiliser de tampon de profondeur. </font><font style="vertical-align: inherit;">Cela ne r√©sout pas les autres probl√®mes associ√©s √† cette m√©thode, mais permet de v√©rifier l'op√©rabilit√© du m√©lange √† l'aide d'une carte de hauteur.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher le code</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmap</span>; 
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;        <font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ... <font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    result.a = smoothstep( BlendStart, BlendEnd, deltaHeight );<font></font>
<font></font>
    // ... <font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br>
<br>
<img src="https://habrastorage.org/webt/zl/fl/nz/zlflnzwmh3tl6z_dhlvxowot4he.png"><br>
<img src="https://habrastorage.org/webt/-k/qc/f8/-kqcf8fgcmkjj7kt3gxmfpz31zu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange de profondeur et d'√©l√©vation. </font><font style="vertical-align: inherit;">La largeur de la zone de fusion diff√®re avec les m√™mes param√®tres de shader.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Les illustrations utilisent des param√®tres de fusion identiques pour les deux m√©thodes. </font><font style="vertical-align: inherit;">La largeur des zones de fusion est visuellement diff√©rente, car la fusion avec une carte de hauteur ne d√©pend pas de l'angle entre le regard de l'observateur et la normale au paysage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le m√©lange avec une carte en hauteur est au moins √† un √©gard meilleur que le m√©lange en profondeur: il corrige la d√©pendance du m√©lange qui est visible √† l'≈ìil nu de l'angle sous lequel la cam√©ra regarde le paysage. </font><font style="vertical-align: inherit;">Malheureusement, l'effet de parallaxe sera toujours observ√©.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange de reconstruction d'am√©nagement paysager</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour se d√©barrasser de la parallaxe, vous devez m√©langer un fragment du mod√®le 3D avec un fragment du paysage qui est verticalement en dessous (la s√©lection des couleurs pour le m√©lange dans ce cas ne d√©pend pas de la position et de l'orientation de la cam√©ra). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/h8/en/8t/h8en8tgwnrmjvhnunm0wkgcr3cu.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment corriger la parallaxe: choisir un fragment de paysage √† m√©langer</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bien s√ªr, nous parlons ici plus d'un fragment de paysage virtuel. Selon la position de la cam√©ra, une situation est possible lorsqu'un fragment du paysage, avec lequel il est n√©cessaire de m√©langer un fragment d'un mod√®le 3D, ne tombe m√™me pas dans le champ de vision de la cam√©ra. Un probl√®me similaire existe dans le rendu des r√©flexions locales dans l'espace √©cran (SSLR). Elle consiste dans le fait qu'il est impossible de restituer le reflet d'un fragment qui n'est pas sur l'√©cran </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[13]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas du paysage, la couleur du fragment virtuel peut √™tre reconstruite avec une grande pr√©cision √† l'aide de textures auxiliaires fournies par l'API Unity: carte normale </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[14]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , carte claire </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[15]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , textures pond√©r√©es pour m√©langer les couches </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[16]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et textures incluses dans composition des couches </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[17]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ff/hu/zr/ffhuzriatn-pfjxf-nendtckscm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconstitution d'un fragment du paysage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Toutes les textures qui composent le paysage sont √©chantillonn√©es selon le m√™me UV que la carte des hauteurs. </font><font style="vertical-align: inherit;">Dans le cas des couches, les coordonn√©es d'√©chantillonnage sont ajust√©es par les param√®tres de mosa√Øque sp√©cifi√©s pour une couche particuli√®re </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[18] [19]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher le code</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Blending</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">reconstructed</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">fragments</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendStart</span>;
<span class="hljs-selector-tag">float</span> <span class="hljs-selector-tag">BlendEnd</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainNormalTexture</span>;
<span class="hljs-selector-tag">sampler2D</span> <span class="hljs-selector-tag">TerrainAlphaMap</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;
<span class="hljs-selector-tag">Float4</span> <span class="hljs-selector-tag">TerrainLightmap_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap0</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap0</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap0_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap1</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap1</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap1_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap2</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap2</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap2_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D</span>(<span class="hljs-selector-tag">TerrainSplatMap3</span>);
<span class="hljs-selector-tag">UNITY_DECLARE_TEX2D_NOSAMPLER</span>(<span class="hljs-selector-tag">TerrainNormalMap3</span>);
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap3_ST</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
#if defined(LIGHTMAP_ON)<font></font>
   float2 <span class="hljs-attribute">modelLightMapUV </span>: TEXCOORD2;<font></font>
   float2 <span class="hljs-attribute">terrainLightMapUV </span>: TEXCOORD3;<font></font>
#endif<font></font>
<font></font>
   // ...<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
<font></font>
#if defined(LIGHTMAP_ON)<font></font>
    o.modelLightMapUV = v.texcoord1.xy * unity_LightmapST.xy + unity_LightmapST.zw;<font></font>
    o.terrainLightMapUV = o.heightMapUV * TerrainLightmap_ST.xy + TerrainLightmap_ST.zw;<font></font>
#endif<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormal</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">terrainUV</span>)<font></font>
{<font></font>
    return tex2Dlod( TerrainNormalTexture, float4(terrainUV,0,0) ).xyz * 2.0 - 1.0;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">TerrainSplatMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 splat0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap0, TerrainSplatMap0, uv0);<font></font>
    half4 splat1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap1, TerrainSplatMap1, uv1);<font></font>
    half4 splat2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap2, TerrainSplatMap2, uv2);<font></font>
    half4 splat3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainSplatMap3, TerrainSplatMap3, uv3);         <font></font>
    half4 result = splat0 * control.r + <font></font>
                   splat1 * control.g + <font></font>
                   splat2 * control.b + <font></font>
                   splat3 * control.a;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainNormalMap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv0</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv1</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv2</span>, <span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv3</span>, <span class="hljs-selector-tag">half4</span> <span class="hljs-selector-tag">control</span>)<font></font>
{<font></font>
    half4 n0 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap0, TerrainSplatMap0, uv0);<font></font>
    half4 n1 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap1, TerrainSplatMap1, uv1);<font></font>
    half4 n2 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap2, TerrainSplatMap2, uv2);<font></font>
    half4 n3 = UNITY_SAMPLE_TEX2D_SAMPLER(TerrainNormalMap3, TerrainSplatMap3, uv3);<font></font>
    half3 result = UnpackNormalWithScale(n0, 1.0) * control.r +<font></font>
                   UnpackNormalWithScale(n1, 1.0) * control.g +<font></font>
                   UnpackNormalWithScale(n2, 1.0) * control.b +<font></font>
                   UnpackNormalWithScale(n3, 1.0) * control.a;<font></font>
    result.z += 1e-5;<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">TerrainLightmap</span>(<span class="hljs-selector-tag">float2</span> <span class="hljs-selector-tag">uv</span>, <span class="hljs-selector-tag">half3</span> <span class="hljs-selector-tag">normal</span>)<font></font>
{<font></font>
#if defined(LIGHTMAP_ON)<font></font>
#if defined(DIRLIGHTMAP_COMBINED)<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half4 lmd = UNITY_SAMPLE_TEX2D_SAMPLER(unity_LightmapInd, unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
    result = DecodeDirectionalLightmap(result, lmd, normal);<font></font>
#else<font></font>
    half4 lm = UNITY_SAMPLE_TEX2D(unity_Lightmap, uv);<font></font>
    half3 result = DecodeLightmapRGBM(lm, unity_Lightmap_HDR);<font></font>
#endif                <font></font>
#else<font></font>
    half3 result = UNITY_LIGHTMODEL_AMBIENT.rgb;<font></font>
#endif<font></font>
    return result;<font></font>
}<font></font>
<font></font>
<span class="hljs-selector-tag">fixed4</span> <span class="hljs-selector-tag">frag</span>(<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">i</span>) : <span class="hljs-selector-tag">COLOR</span><font></font>
{<font></font>
    fixed4 result = 0;<font></font>
<font></font>
    // ...<font></font>
<font></font>
    // compute model color and put it to the result<font></font>
<font></font>
    // ... <font></font>
<font></font>
    // reconstruction of terrain fragment<font></font>
<font></font>
    float2 splatUV0 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap0);<font></font>
    float2 splatUV1 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap1);<font></font>
    float2 splatUV2 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap2);<font></font>
    float2 splatUV3 = TRANSFORM_TEX(i.heightMapUV, TerrainSplatMap3);<font></font>
<font></font>
    half4 control = tex2D(_TerrainAlphaMap, i.heightMapUV);<font></font>
    half4 terrainColor = TerrainSplatMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
<font></font>
    half3 terrainSurfaceNormal = TerrainNormal(i.heightMapUV);<font></font>
    half3 terrainSurfaceTangent = cross(terrainSurfaceNormal, float3(0,0,1));<font></font>
    half3 terrainSurfaceBitangent = cross(terrainSurfaceTangent, terrainSurfaceNormal);<font></font>
<font></font>
    half3 terrainNormal = TerrainNormalMap(splatUV0, splatUV1, splatUV2, splatUV3, control);<font></font>
    terrainNormal = terrainNormal.x * terrainSurfaceTangent + <font></font>
                    terrainNormal.y * terrainSurfaceBitangent + <font></font>
                    terrainNormal.z * terrainSurfaceNormal;<font></font>
    <font></font>
    half3 terrainLightmapColor = TerrainLightmap(i.heightMapUV, terrainNormal);<font></font>
    terrainColor *= terrainLightmapColor;<font></font>
<font></font>
    // blend model color &amp; terrain color<font></font>
<font></font>
    half height = TerrainHeight(i.heightMapUV);<font></font>
    half deltaHeight = i.worldPos.y - height;<font></font>
    half blendingWeight = smoothstep(BlendStart, BlendEnd, deltaHeight);<font></font>
<font></font>
    result.rgb = lerp(result.rgb, terrainColor, blendingFactor);<font></font>
       <font></font>
    return result; <font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, le m√©lange avec la reconstruction de fragments de paysage corrige tous les probl√®mes typiques du m√©lange en profondeur et du m√©lange avec une carte de hauteur, y compris la parallaxe. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mf/pb/0s/mfpb0sfkav-hj-i5xhpll305drc.png"><br>
<img src="https://habrastorage.org/webt/ba/-z/x6/ba-zx6icghn-mnbreobdnekbjay.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©lange de reconstruction d'am√©nagement paysager</font></font></i><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performances de reconstruction des fragments de terrain</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√Ä ce stade, il est temps de se demander quelle est la valeur de ce type de compromis? √Ä premi√®re vue, l'intensit√© des ressources de la reconstruction de fragments de paysage d√©passe de loin l'intensit√© des ressources du m√©lange alpha. Pour la reconstruction, il est n√©cessaire d'effectuer une douzaine d'op√©rations de lecture suppl√©mentaires √† partir de la m√©moire. Pour le m√©lange alpha, vous n'avez besoin que d'une op√©ration de lecture de la m√©moire et d'une op√©ration d'√©criture dans la m√©moire. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En r√©alit√©, tout d√©pendra des fonctionnalit√©s de la plateforme mat√©rielle. La reconstruction des fragments est prise en charge par la compression de texture, le mip-mapping, la puissance de traitement du c≈ìur du processeur graphique et des optimisations sp√©cifiques du pipeline mat√©riel (rejet en profondeur pr√©coce). Et contre l'alpha-blending, le fait d√©j√† mentionn√© ci-dessus jouera que c'est la partie la moins progressive de tout GPU.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, il y a toujours place √† l'optimisation. </font><font style="vertical-align: inherit;">Par exemple, dans le cas de la reconstruction de la couleur du paysage, la n√©cessit√© de cette reconstruction n'est que pour une √©troite bande de fragments du mod√®le 3D situ√©e √† une hauteur au-dessus d'une certaine hauteur au-dessus de la surface du paysage. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La ramification dynamique dans les shaders peut donner des r√©sultats de performance peu pr√©visibles, mais il y a deux points √† prendre en compte:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il convient de sauter les calculs inutiles dans le branchement par une condition si cette condition n'est pas satisfaite dans une partie importante des cas.</font></font></li>
<li>       .   ,             ( ,  ),      GPU.    ‚Äï   (branch granularity),  , , ,          ,      .         ,    ,       .  ,   GPU  ,     ,       . ,      GPU,   ,  1 (PowerVR SGX).</li>
</ol><br>
<img src="https://habrastorage.org/webt/i7/8y/x9/i78yx9mn7egjmojcmxl67crz1kc.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualisation de diff√©rents degr√©s de coh√©rence</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dans le cas de la reconstruction de fragments, ces deux points sont pris en compte: la condition de branchement permettra dans la plupart des cas de couper la mise en ≈ìuvre d'op√©rations gourmandes en ressources pour reconstruire la couleur du paysage, et cette condition est coh√©rente, √† l'exception d'un tr√®s petit nombre de fragments (dans l'illustration, ce sont des fragments qui se trouvent) √† la fronti√®re entre les zones ¬´rouge¬ª et ¬´verte¬ª). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k3/do/ic/k3doicnobaqmuv82xbdfvq_kgas.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Coh√©rence de reconstruction des fragments de paysage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Reste √† ajouter quelques commentaires concernant cette m√©thode de fusion:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unity fournit toutes les textures n√©cessaires uniquement si le paysage a le mode Draw Instanced activ√© </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[20]</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sinon la carte normale ne sera pas disponible, ce qui, √† son tour, ne vous permettra pas de reconstruire correctement l'√©clairage du paysage pour le m√©lange.</font></font></li>
<li> Unity API    ,      (base map)         . -          .</li>
<li>         ,   API          (, Metal   16  ). </li>
<li>    3D-  ,     Terrain,     SRP.</li>
<li> 3D-      ,       3D-    . </li>
<li>,   ¬´¬ª ,     ¬´¬ª  .    ,  ¬´¬ª      ,             .  ¬´¬ª          .</li>
</ol><br>
<img src="https://habrastorage.org/webt/9z/yi/y-/9zyiy-6z47y7pxyonhwrl31zyoc.png"><br>
<i>    </i><br>
<br>
<br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la conception de mod√®les 3D, il est impossible de prendre en compte la vari√©t√© des reliefs de terrain avec lesquels ces mod√®les sont cens√©s √™tre utilis√©s. Souvent, les mod√®les 3D doivent √™tre profond√©ment ¬´enfonc√©s¬ª dans le paysage ou pivot√©s afin de cacher les parties saillantes, ou vice versa - pour montrer celles cach√©es qui devraient √™tre visibles. Les mod√®les ¬´chauffants¬ª limitent leur applicabilit√©, et si les mod√®les 3D sont rendus plus t√¥t que le paysage, cela conduit √©galement √† un effet de sur-dessin. Le virage, √† son tour, est √©galement loin d'√™tre adapt√© √† tous les mod√®les 3D (par exemple, pas pour les maisons et les arbres). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ue/tg/8y/uetg8yx5ctdsn80stvnnezplgh4.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour masquer les √©l√©ments saillants du mod√®le 3D, il doit √™tre ¬´noy√©¬ª dans le paysage</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La capture est un terme familier aux utilisateurs des √©diteurs graphiques. Il s'agit d'une fonction qui permet aux points de contr√¥le de ¬´coller¬ª aux n≈ìuds de la grille spatiale et, dans les √©diteurs 3D, aux faces et surfaces d'autres objets. La capture sur la carte des hauteurs du paysage dans le vertex shader peut grandement simplifier la conception des sc√®nes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4w/1t/xw/4w1txwi3vaczzpne7ewajozlymo.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mod√®le 3D sans accrochage. Mod√®le 3D avec accrochage au sommet. Mod√®le 3D avec accrochage et fusion de sommets. Mod√®le 3D avec accrochage au sommet, m√©lange et √©clairage statique</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La principale difficult√© dans l'impl√©mentation de l'accrochage est que vous devez d√©terminer quels sommets du mod√®le 3D vous devez accrocher √† la carte de hauteur et ceux qui n'en valent pas la peine. </font><font style="vertical-align: inherit;">Les sommets ne contiennent que des informations sur la nature locale de la surface (ce qui n'est pas suffisant) et ne contiennent aucune information sur sa topologie (qui est n√©cessaire). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme dans d'autres cas d'application, ce probl√®me est plus facile √† r√©soudre au stade de la mod√©lisation en impl√©mentant directement les param√®tres n√©cessaires dans les sommets. </font><font style="vertical-align: inherit;">En tant que tel param√®tre, vous devez choisir un attribut intuitif - par exemple, le facteur de pond√©ration pour l'accrochage (et non la distance au bord d'une surface ouverte, comme nous le souhaiterions pour la flexibilit√©). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/7b/gq/2b/7bgq2bdhdlr13qgeqpgcocvo0q8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codage de pond√©ration pour la capture</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher le code</font></font></b><div class="spoiler_text"><pre><code class="css hljs">// <span class="hljs-selector-tag">Per-vertex</span> <span class="hljs-selector-tag">snapping</span> <span class="hljs-selector-tag">with</span> <span class="hljs-selector-tag">terrain</span> <span class="hljs-selector-tag">heightmap</span><font></font>
<font></font>
<span class="hljs-selector-id">#include</span> "<span class="hljs-selector-tag">UnityCG</span><span class="hljs-selector-class">.cginc</span>"<font></font>
<font></font>
<span class="hljs-selector-tag">sampler2D_float</span> <span class="hljs-selector-tag">TerrainHeightmapTexture</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">HeightmapScale</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainSize</span>;
<span class="hljs-selector-tag">float4</span> <span class="hljs-selector-tag">TerrainPos</span>;<font></font>
<font></font>
<span class="hljs-selector-tag">struct</span> <span class="hljs-selector-tag">v2f</span><font></font>
{<font></font>
<font></font>
   // ...<font></font>
<font></font>
   float3 <span class="hljs-attribute">worldPos </span>: TEXCOORD0;<font></font>
   float2 <span class="hljs-attribute">heightMapUV </span>: TEXCOORD1;<font></font>
<font></font>
   // ...<font></font>
<font></font>
};<font></font>
<font></font>
<span class="hljs-selector-tag">v2f</span> <span class="hljs-selector-tag">vert</span>(<span class="hljs-selector-tag">appdata</span> <span class="hljs-selector-tag">v</span>)<font></font>
{<font></font>
    v2f o;<font></font>
    UNITY_INITIALIZE_OUTPUT(v2f,o);<font></font>
   <font></font>
    // ...<font></font>
    <font></font>
    o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;<font></font>
    o.heightMapUV = TerrainUV(o.worldPos);<font></font>
    float snappingWeight = v.color.r;                <font></font>
    half height = TerrainHeight( o.heightMapUV );                <font></font>
    o.worldPos.y = lerp( o.worldPos.y, height, snappingWeight );<font></font>
    o.pos = UnityWorldToClipPos( half4( o.worldPos, 1 ) );<font></font>
<font></font>
    // ...<font></font>
<font></font>
    return o;<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'applicabilit√© du vertex snapping est limit√©e par la correspondance g√©n√©rale entre le terrain et la surface du mod√®le 3D. </font><font style="vertical-align: inherit;">Pour compenser leurs diff√©rences importantes, il est n√©cessaire d'utiliser d'autres m√©thodes, plus gourmandes en ressources - par exemple, utiliser des mod√®les 3D avec skinning.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'id√©e principale qui devrait √™tre retir√©e de l'article: tout shader suffisamment complexe et potentiellement √©volutif a besoin de donn√©es de base. </font><font style="vertical-align: inherit;">Et la t√¢che du d√©veloppeur est de comprendre comment le syst√®me graphique peut fonctionner: quelles donn√©es il fournit, comment il peut √™tre combin√© et comment l'utiliser dans les shaders. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le cas g√©n√©ral, nous pouvons conclure que la seule option pour surmonter le cadre par lequel les possibilit√©s d'effets graphiques sont limit√©es est de combiner les r√©sultats de divers shaders.</font></font><br>
<br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√©f√©rences</font></font></h2><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Afficher les liens</font></font></b><div class="spoiler_text"><sup>[1]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/Manual/SL-CameraDepthTexture.html</a><br>
<sup>[2]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/ScriptReference/Camera-depthTextureMode.html</a><br>
<sup>[3]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/ScriptReference/RenderTexture.html</a><br>
<sup>[4]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.khronos.org/opengl/wiki/Framebuffer_Object</a><br>
<sup>[5]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.microsoft.com/en-us/windows/win32/api/d3d11/nf-d3d11-id3d11device-createrendertargetview</a><br>
<sup>[6]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendMode.html</a><br>
<sup>[7]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/ScriptReference/Rendering.BlendOp.html</a><br>
<sup>[8]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.khronos.org/opengl/wiki/Blending</a><br>
<sup>[9]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.microsoft.com/en-us/windows/win32/direct3d11/d3d10-graphics-programming-guide-blend-state</a><br>
<sup>[10]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en.wikipedia.org/wiki/Parallax</a><br>
<sup>[11]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en.wikipedia.org/wiki/Parallax_scrolling</a><br>
<sup>[12]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-heightmapTexture.html</a><br>
<sup>[13]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pdfs.semanticscholar.org/ce6c/fcafe3581a7e4d7184a9727cc504bdc6b295.pdf</a><br>
<sup>[14]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-normalmapTexture.html</a><br>
<sup>[15]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-lightmapIndex.html</a><br>
<sup>[16]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-alphamapTextures.html</a><br>
<sup>[17]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainData-terrainLayers.html</a><br>
<sup>[18]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileSize.html</a><br>
<sup>[19]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/TerrainLayer-tileOffset.html</a><br>
<sup>[20]</sup> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs.unity3d.com/2018.3/Documentation/ScriptReference/Terrain-drawInstanced.html</a><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490204/index.html">Le condens√© des √©v√©nements pour les recruteurs RH et IT en mars 2020</a></li>
<li><a href="../fr490208/index.html">Section backend sur DUMP2020: badinage, ventilateur, √©chec</a></li>
<li><a href="../fr490210/index.html">Acc√©l√©rer le frontend. Quand beaucoup de demandes de serveur sont bonnes</a></li>
<li><a href="../fr490222/index.html">Biblioth√®que standard du jour de la mort</a></li>
<li><a href="../fr490224/index.html">Furtivit√© √† la mode</a></li>
<li><a href="../fr490242/index.html">Service de localisation GSM des modules SIM800x et son travail avec l'API Yandex.Locator</a></li>
<li><a href="../fr490244/index.html">Optimisation de code Python avec ctypes</a></li>
<li><a href="../fr490246/index.html">Kremlin Towers in Hydra's Embrace: Conf√©rence sur l'informatique parall√®le et distribu√©e Hydra 2020</a></li>
<li><a href="../fr490248/index.html">Webinaire ¬´Winnum CNC: une surveillance qui fonctionne¬ª</a></li>
<li><a href="../fr490250/index.html">Horror Set.removeAll</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>