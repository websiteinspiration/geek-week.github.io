<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👦 👂🏼 ❎ 《面向对象的方法》一书。5th int。ed。” 🌱 ✋🏽 🐽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="面向对象编程（OOP）是C ++，Java，C＃，Visual Basic .NET，Ruby，Objective-C甚至Swift语言的核心。他们不能没有网络技术对象，因为它们使用JavaScript，Python和PHP。
 
 这就是为什么Matt Weissfeld建议开发一种面向对象的思维...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>《面向对象的方法》一书。5th int。ed。”</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/486888/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/d7/vu/ym/d7vuymdujarobcypwexhfief-l4.jpeg" align="left" alt="图片"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">面向对象编程（OOP）是C ++，Java，C＃，Visual Basic .NET，Ruby，Objective-C甚至Swift语言的核心。他们不能没有网络技术对象，因为它们使用JavaScript，Python和PHP。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是为什么Matt Weissfeld建议开发一种面向对象的思维方式，然后才使用特定的编程语言进行面向对象的开发的原因。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本书是由开发人员为开发人员编写的，可让您选择解决特定问题的最佳方法。您将学习如何正确应用继承和组合，了解聚合和关联之间的区别，以及避免混淆接口和实现。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
编程技术在不断变化和发展，但是面向对象的概念与平台无关，并且始终有效。</font><font style="vertical-align: inherit;">本出版物重点介绍OOP的基本原理：设计模式，依赖关系和SOLID原理，这些原理将使您的代码易于理解，灵活且易于维护。</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOLID面向对象的设计原则</font></font></h3><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. SRP：唯一责任原则</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
唯一责任原则指出，仅需一个理由即可更改班级。每个类和程序模块必须具有一个优先级的任务。因此，不应出于多种原因引入可导致类更改的方法。如果类描述包含单词“ and”，则可能违反SRP原则。换句话说，每个模块或类都必须负责软件功能的一部分，并且此类责任必须完全封装在类中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
创建图的层次结构是说明继承的经典示例之一，该示例经常在教学中找到，我在本章（以及整本书中）都使用它。</font><font style="vertical-align: inherit;">在此示例中，Circle类从Shape类继承属性。</font><font style="vertical-align: inherit;">Shape类提供抽象的calcArea（）方法作为子类的协定。</font><font style="vertical-align: inherit;">从Shape继承的每个类都必须具有自己的calcArea（）方法的实现：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span>{
     <span class="hljs-keyword">protected</span> String name;
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，从Shape类继承的Circle类在必要时提供其对calcArea（）方法的实现：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>{
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> radius;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>{<font></font>
           radius = r;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
           area = <span class="hljs-number">3.14</span>*(radius*radius) ;
           <span class="hljs-keyword">return</span> (area);<font></font>
     };<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第三类CalculateAreas计算Shape数组中包含的各种形状的面积。</font><font style="vertical-align: inherit;">Shape数组的大小不受限制，可以包含各种形状，例如正方形和三角形。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{<font></font>
     Shape[] shapes;<font></font>
     <span class="hljs-keyword">double</span> sumTotal=<span class="hljs-number">0</span>;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CalculateAreas</span><span class="hljs-params">(Shape[] sh)</span> </span>{
           <span class="hljs-keyword">this</span>.shapes = sh;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sumAreas</span><span class="hljs-params">()</span> </span>{<font></font>
           sumTotal=<span class="hljs-number">0</span>;
           <span class="hljs-keyword">for</span> (inti=<span class="hljs-number">0</span>; i&lt;shapes.length; i++) {<font></font>
           sumTotal = sumTotal + shapes[i].calcArea() ;<font></font>
           }<font></font>
           <span class="hljs-keyword">return</span> sumTotal ;<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">output</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Total of all areas = "</span> + sumTotal);<font></font>
     }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，CalculateAreas类还处理应用程序输出，这可能会导致问题。面积计数行为和输出行为是相关的，因为它们包含在同一类中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们可以使用适当的测试应用程序TestShape验证此代码的功能：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestShape</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Hello World!"</span>);<font></font>
<font></font>
            Circle circle = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">1</span>);<font></font>
<font></font>
            Shape[] shapeArray = <span class="hljs-keyword">new</span> Shape[<span class="hljs-number">1</span>];<font></font>
            shapeArray[<span class="hljs-number">0</span>] = circle;<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas(shapeArray) ;<font></font>
<font></font>
            ca.sumAreas() ;<font></font>
            ca.output();<font></font>
      }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们有一个测试应用程序可供使用，我们可以专注于唯一责任原则的问题。同样，问题出在CalculateAreas类上，该类包含用于将各种形状的区域相加以及输出数据的行为。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
基本的问题（实际上是问题）是，如果您需要更改output（）方法的功能，则无论计算形状面积的方法是否发生变化，都需要对CalculateAreas类进行更改。例如，如果我们突然想要将数据输出到HTML控制台而不是纯文本，则需要重新编译并重新实现代码，这会增加图形的面积。都是因为责任是相关的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
按照唯一责任原则，任务是更改一种方法不会影响另一种方法，并且不必重新编译。 “班级应该只有一个改变的理由，这是唯一需要改变的责任。” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要解决此问题，可以将两个方法放在单独的类中，一个用于原始控制台输出，另一个用于HTML输出：</font></font><br>
<br>
<pre><code class="xml hljs">class CaiculateAreas {;<font></font>
     Shape[] shapes;<font></font>
     double sumTotal=0;<font></font>
<font></font>
     public CalculateAreas(Shape[] sh) {<font></font>
           this.shapes = sh;<font></font>
     }<font></font>
<font></font>
     public double sumAreas() {<font></font>
           sumTotal=0;<font></font>
<font></font>
           for (inti=0; i<span class="hljs-tag">&lt;<span class="hljs-name">shapes.length;</span> <span class="hljs-attr">i</span>++) {

                <span class="hljs-attr">sumTotal</span> = <span class="hljs-string">sumTotal</span> + <span class="hljs-attr">shapes</span>[<span class="hljs-attr">i</span>]<span class="hljs-attr">.calcArea</span>();

           }

                <span class="hljs-attr">return</span> <span class="hljs-attr">sumTotal</span>;
           }
}
<span class="hljs-attr">class</span> <span class="hljs-attr">OutputAreas</span> {
     <span class="hljs-attr">double</span> <span class="hljs-attr">areas</span>=<span class="hljs-string">0;</span>
     <span class="hljs-attr">public</span> <span class="hljs-attr">OutputAreas</span> (<span class="hljs-attr">double</span> <span class="hljs-attr">a</span>) {
           <span class="hljs-attr">this.areas</span> = <span class="hljs-string">a;</span>
     }

           <span class="hljs-attr">public</span> <span class="hljs-attr">void</span> <span class="hljs-attr">console</span>() {
           <span class="hljs-attr">System.out.printin</span>("<span class="hljs-attr">Total</span> <span class="hljs-attr">of</span> <span class="hljs-attr">all</span> <span class="hljs-attr">areas</span> = <span class="hljs-string">" + areas);
     }
     public void HTML() {
           System.out.printIn("</span>&lt;<span class="hljs-attr">HTML</span>&gt;</span>") ;<font></font>
           System.out.printin("Total of all areas = " + areas);<font></font>
           System.out.printin("<span class="hljs-tag">&lt;/<span class="hljs-name">HTML</span>&gt;</span>") ;<font></font>
     }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最重要的是，现在您可以根据需要向不同的方向发送结论。</font><font style="vertical-align: inherit;">如果要添加其他输出方法（例如JSON）的可能性，则可以将其添加到OutputAreas类，而无需对CalculateAreas类进行更改。</font><font style="vertical-align: inherit;">因此，您可以重新分配CalculateAreas类，而不会以任何方式影响其他类。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. OCP：开放/封闭原则</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
开放性/紧密性的原则指出，您可以扩展类的行为而无需进行更改。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们再次关注带有数字的示例。</font><font style="vertical-align: inherit;">在下面的代码中，有一个ShapeCalculator类，它接收一个Rectangle对象，计算该对象的面积并返回值。</font><font style="vertical-align: inherit;">这是一个简单的应用程序，但仅适用于矩形。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span></span>{
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> length;
     <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
           length = <span class="hljs-number">1</span>;<font></font>
           width = w;<font></font>
     };<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{
     <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(Rectangle r)</span> </span>{<font></font>
<font></font>
           area = r.length * r.width;<font></font>
<font></font>
           <span class="hljs-keyword">return</span> area;<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenClosed</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Hello World"</span>);<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas ();<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span>+ ca.calcArea(r));<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该应用程序仅在矩形的情况下起作用的事实导致了一个局限性，该局限性清楚地说明了开放性/闭合性的原理：如果我们想将Circle类添加到CalculateArea类（更改其功能），则需要对模块本身进行更改。显然，这与开放性/封闭性原则相冲突，开放性/封闭性原则指出我们不应更改模块以更改其功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了遵守开放性/封闭性原则，我们可以返回已经测试过的图形实例，其中创建了一个抽象Shape类，并且直接从Shape类继承了图形，该Shape类具有一个抽象getArea（）方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
目前，您可以根据需要添加任意多个不同的类，而无需直接对Shape类（例如Circle类）进行更改。现在我们可以说Shape类已关闭。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下代码为矩形和圆形提供了解决方案的实现，并允许您创建无限数量的形状：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span>
</span>{<font></font>
<font></font>
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      };<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> length*width;<font></font>
      }<font></font>
<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span>
</span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> radius;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Circle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> r)</span> </span>{<font></font>
            radius = r;<font></font>
      };<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getArea</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> radius*radius*<span class="hljs-number">3.14</span>;<font></font>
      }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAreas</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">(Shape s)</span> </span>{<font></font>
            area = s.getArea();<font></font>
            <span class="hljs-keyword">return</span> area;<font></font>
      }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenClosed</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printiIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            CalculateAreas ca = <span class="hljs-keyword">new</span> CalculateAreas() ;<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Area = "</span> + ca.calcArea(r));<font></font>
<font></font>
            Circle c = <span class="hljs-keyword">new</span> Circle(<span class="hljs-number">3</span>);<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Area = "</span> + ca.calcArea(c));<font></font>
}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
值得注意的是，使用此实现，在创建Shape类的新实例时，不应修改CalculateAreas（）方法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以扩展代码而不必担心先前代码的存在。开放性/封闭性的原则是您应该使用子类扩展代码，以使原始类不需要进行编辑。但是，在有关SOLID原理的一些讨论中，“扩展”概念本身存在争议。坦率地说，如果我们更喜欢组合而不是继承，这如何影响开放性/封闭性原则？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
遵循SOLID原则之一时，代码可能满足其他SOLID原则的条件。</font><font style="vertical-align: inherit;">例如，在按照开放性/封闭性原则进行设计时，代码可能符合唯一责任原则的要求。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. LSP：Lisk替代原则</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据Liskov替换原则，设计应提供使用父类之一的实例替换父类的任何实例的可能性。如果父类可以执行任何任务，则子类也必须能够执行。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
乍一看一些正确的代码，但违反了Lisk替换原则。下面的代码包含通用的Shape抽象类。反过来，Rectangle类从Shape类继承属性，并覆盖其抽象的calcArea（）方法。而Square类则继承自Rectangle。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      }<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = length*width;<font></font>
            <span class="hljs-keyword">return</span> (area) ;<font></font>
      };<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span></span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{
            <span class="hljs-keyword">super</span>(s, Ss);<font></font>
      }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span> + r.calcArea());<font></font>
<font></font>
            Square s = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">2</span>) ;<font></font>
<font></font>
            System.out.printin(<span class="hljs-string">"Area = "</span> + s.calcArea());<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
到目前为止，一切都很好：矩形是图形的一个实例，因此不必担心，因为正方形是矩形的一个实例-一切都正确，对吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们问一个哲学问题：正方形还是矩形吗？</font><font style="vertical-align: inherit;">许多人会回答是肯定的。</font><font style="vertical-align: inherit;">尽管可以假定正方形是矩形的特例，但其属性会有所不同。</font><font style="vertical-align: inherit;">矩形是一个平行四边形（相对的边是相同的），就像一个正方形。</font><font style="vertical-align: inherit;">同时，正方形也是菱形（所有边都相同），而矩形不是。</font><font style="vertical-align: inherit;">因此，存在差异。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于面向对象的设计，问题不在于几何。</font><font style="vertical-align: inherit;">问题是我们如何精确地创建矩形和正方形。</font><font style="vertical-align: inherit;">这是Rectangle类的构造函数：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
      length = <span class="hljs-number">1</span>;<font></font>
      width = w;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
显然，构造函数需要两个参数。</font><font style="vertical-align: inherit;">但是，即使父类Rectangle需要两个，Square类的构造函数也只需要一个。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span></span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{
      <span class="hljs-keyword">super</span>(s, Ss);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，在这两类中的每一种的情况下，用于计算面积的功能都略有不同。</font><font style="vertical-align: inherit;">也就是说，Square类确实模仿了Rectangle，将相同的参数两次传递给构造函数。</font><font style="vertical-align: inherit;">这样的解决方法似乎很合适，但是实际上，它可能会误导附带代码的开发人员，而将来在附带代码时，会充满陷阱。</font><font style="vertical-align: inherit;">至少这是一个问题，并且可能是一个可疑的设计决策。</font><font style="vertical-align: inherit;">当一个构造函数调用另一个构造函数时，最好休息一下并重新考虑该构造-子类可能未正确构建。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如何找到摆脱这种情况的出路？</font><font style="vertical-align: inherit;">简而言之，您不能用Square类代替Rectangle。</font><font style="vertical-align: inherit;">因此，Square不应是Rectangle类的子级。</font><font style="vertical-align: inherit;">它们必须是单独的类。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">double</span> area;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{<font></font>
<font></font>
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Rectangle</span><span class="hljs-params">(<span class="hljs-keyword">double</span> <span class="hljs-number">1</span>, <span class="hljs-keyword">double</span> w)</span> </span>{<font></font>
            length = <span class="hljs-number">1</span>;<font></font>
            width = w;<font></font>
      }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = length*width;<font></font>
            <span class="hljs-keyword">return</span> (area);<font></font>
      };<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> side;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Square</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span> </span>{<font></font>
            side = s;<font></font>
      }<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">calcArea</span><span class="hljs-params">()</span> </span>{<font></font>
            area = side*side;<font></font>
            <span class="hljs-keyword">return</span> (area);<font></font>
      };<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiskovSubstitution</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
             Rectangle r = <span class="hljs-keyword">new</span> Rectangle(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Area = "</span> + r.calcArea());<font></font>
<font></font>
             Square s = <span class="hljs-keyword">new</span> Square(<span class="hljs-number">2</span>) ;<font></font>
<font></font>
             System.out.printIn(<span class="hljs-string">"Area = "</span> + s.calcArea());<font></font>
      }<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. ISP：接口共享原则</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
接口分离的原理指出，创建多个小接口比创建多个大接口更好。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，我们创建一个接口，其中包含Mammal类的几种行为，即eat（）和makeNoise（）：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMammal</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMammal</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is eating"</span>);<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is making noise"</span>);<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>);<font></font>
<font></font>
            Dog fido = <span class="hljs-keyword">new</span> Dog();<font></font>
            fido.eat();<font></font>
            fido.makeNoise()<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您需要</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为所有行为</font><font style="vertical-align: inherit;">创建</font><font style="vertical-align: inherit;">单独的接口，</font><font style="vertical-align: inherit;">而不是为Mammal类创建</font><font style="vertical-align: inherit;">单个接口：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IEat</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IMakeNoise</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>;<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IEat</span>, <span class="hljs-title">IMakeNoise</span> </span>{
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is eating"</span>);<font></font>
     }<font></font>
     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeNoise</span><span class="hljs-params">()</span> </span>{<font></font>
           System.out.printIn(<span class="hljs-string">"Dog is making noise"</span>);<font></font>
     }<font></font>
}<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>{<font></font>
<font></font>
            System.out.printIn(<span class="hljs-string">"Hello World"</span>) ;<font></font>
<font></font>
            Dog fido = <span class="hljs-keyword">new</span> Dog();<font></font>
            fido.eat();<font></font>
            fido.makeNoise();<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将行为与哺乳动物班分开。事实证明，与其通过继承（更确切地说，是接口）创建单个Mammal类，我们不如上一章中所使用的策略，而是基于组合进行设计。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
简而言之，通过这种方法，我们可以使用合成来创建哺乳动物类的实例，而不是被迫使用嵌入在单个哺乳动物类中的行为。例如，假设发现哺乳动物不吃东西，而是通过皮肤吸收营养。如果我们从包含eat（）行为的Mammal类继承，则此行为对于新哺乳动物将是多余的。而且，如果将所有行为都布置在单独的单个界面中，那么结果将完全按照预期来构建每种哺乳动物的类别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»这本书的更多信息可以</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在出版商的网站</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上找到</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">目录</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font><font style="vertical-align: inherit;">
Habrozhitelami的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">节录可</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在优惠券上享受25％的折扣-</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOP</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
支付了纸质版本的书后，就会通过电子邮件发送电子书。</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN486874/index.html">冠状病毒2019-nCoV：低死亡率，高死亡率</a></li>
<li><a href="../zh-CN486876/index.html">在Yandex.Cloud中构建Telegram机器人</a></li>
<li><a href="../zh-CN486878/index.html">翅膀，腿和尾巴</a></li>
<li><a href="../zh-CN486880/index.html">错误的翻译人员导致了灾难性的后果</a></li>
<li><a href="../zh-CN486884/index.html">日本制药公司开始测试使用神经网络合成的药物</a></li>
<li><a href="../zh-CN486890/index.html">自我发展：我如何不坐在两把椅子上而发现第三把椅子</a></li>
<li><a href="../zh-CN486892/index.html">联系人选择器API，或如何与浏览器共享联系人</a></li>
<li><a href="../zh-CN486896/index.html">MAG250的UID和Stalker授权</a></li>
<li><a href="../zh-CN486902/index.html">Swift 5.1中面向协议的编程</a></li>
<li><a href="../zh-CN486904/index.html">向开发人员显示SonarQube中源代码质量控制的状态</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>