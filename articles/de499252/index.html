<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏼‍🤝‍👨🏽 🥜 🎿 Erstellen eines pseudo-dreidimensionalen Rennspiels 🔩 🚵🏾 😚</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Als Kind ging ich selten in Arcade-Arcade-Hallen, weil ich sie nicht wirklich brauchte, weil ich zu Hause tolle Spiele für C64 hatte ... aber es gibt ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Erstellen eines pseudo-dreidimensionalen Rennspiels</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499252/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d16/6e3/cff/d166e3cff9c2a3cefeb68f5c1ddc02d1.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Kind ging ich selten in Arcade-Arcade-Hallen, weil ich sie nicht wirklich brauchte, weil ich zu Hause tolle Spiele für C64 hatte ... aber es gibt drei Arcade-Spiele, für die ich immer Geld hatte - Donkey Kong, Dragons Lair und Outrun ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und ich habe Outrun wirklich geliebt - Geschwindigkeit, Hügel, Palmen und Musik, selbst bei der schwachen Version für den C64.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48e/aee/56f/48eaee56f43d8a25e840c6ae13268db4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also beschloss ich, ein pseudo-dreidimensionales Rennspiel der alten Schule im Stil von Outrun, Pitstop oder Pole zu schreiben. </font><font style="vertical-align: inherit;">Ich habe nicht vor, ein vollständiges und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vollständiges</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel zusammenzustellen, aber es scheint mir interessant zu sein, die Mechanik, mit der diese Spiele ihre Tricks verwirklicht haben, erneut zu untersuchen. </font><font style="vertical-align: inherit;">Kurven, Hügel, Sprites und ein Gefühl von Geschwindigkeit ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist mein „Wochenendprojekt“, das am Wochenende letztendlich fünf oder sechs Wochen dauerte</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ec/27b/d28/7ec27bd28630dbbaf7b81c87233c28ac.png"></div><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Spiel zu spielen</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansicht </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quellcode</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die spielbare Version ähnelt eher einer technischen Demo als einem echten Spiel. </font><font style="vertical-align: inherit;">Wenn Sie eine echte pseudo-dreidimensionale Rasse erstellen möchten, ist dies die minimalste Grundlage, die Sie benötigen, um sich allmählich in ein Spiel zu verwandeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist nicht poliert, etwas hässlich, aber voll funktionsfähig. </font><font style="vertical-align: inherit;">Ich werde Ihnen zeigen, wie Sie es in vier einfachen Schritten selbst implementieren können. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können auch spielen</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">direkten Straße Demo</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo mit Kurven</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Demo mit den Hügeln</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fertigen Version</font></font></a></li>
</ul><a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über die Leistung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Leistung dieses Spiels </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hängt stark</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von der Maschine / dem Browser ab. </font><font style="vertical-align: inherit;">In modernen Browsern funktioniert es gut, insbesondere in Browsern mit Canvas-GPU-Beschleunigung, aber ein schlechter Grafiktreiber kann dazu führen, dass es einfriert. </font><font style="vertical-align: inherit;">Im Spiel können Sie die Renderauflösung und den Renderabstand ändern.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Über die Codestruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es kam vor, dass das Projekt in Javascript implementiert wurde (aufgrund der Einfachheit des Prototyping), aber es ist nicht beabsichtigt, die Techniken oder empfohlenen Techniken von Javascript zu demonstrieren. </font><font style="vertical-align: inherit;">Zum besseren Verständnis ist das Javascript jedes Beispiels direkt in die HTML-Seite eingebettet (Horror!). </font><font style="vertical-align: inherit;">Schlimmer noch, es verwendet globale Variablen und Funktionen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich ein echtes Spiel erstellen würde, wäre der Code viel strukturierter und optimierter, aber da dies eine technische Demo eines Rennspiels ist, habe ich mich entschieden, bei </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KISS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu bleiben </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 1. Gerade Straßen.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie fangen wir an, ein pseudo-dreidimensionales Rennspiel zu entwickeln? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun, wir brauchen</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wiederholen Sie die Trigonometrie</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erinnern Sie sich an die Grundlagen der 3D-Projektion</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erstellen Sie eine Spielschleife</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite-Bilder herunterladen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßengeometrie erstellen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund rendern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendern Sie die Straße</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto rendern</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementieren Sie die Tastaturunterstützung für die Maschinensteuerung</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber bevor wir beginnen, lesen wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lou's Pseudo 3d Page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Übersetzung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Habré] - die einzige Informationsquelle (die ich finden konnte) darüber, wie man ein Psevdotrohmernuyu-Rennspiel erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lou's Artikel gelesen? </font><font style="vertical-align: inherit;">Fein! </font><font style="vertical-align: inherit;">Wir werden eine Variation seiner Realistic Hills mithilfe der 3D-projizierten Segmenttechnik erstellen. </font><font style="vertical-align: inherit;">Wir werden dies schrittweise in den nächsten vier Teilen tun. </font><font style="vertical-align: inherit;">Aber wir werden jetzt mit Version v1 beginnen und eine sehr einfache gerade Straßengeometrie erstellen, indem wir sie auf ein HTML5-Canvas-Element projizieren.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Demo zu sehen ist </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Trigonometrie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir mit der Implementierung beginnen, wollen wir uns anhand der Grundlagen der Trigonometrie daran erinnern, wie ein Punkt in der 3D-Welt auf einen 2D-Bildschirm projiziert wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie im einfachsten Fall keine Vektoren und Matrizen berühren, wird das Gesetz </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ähnlicher Dreiecke</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die 3D-Projektion verwendet </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir verwenden die folgende Notation:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Kamerahöhe</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Abstand von Kamera zu Bildschirm</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Abstand von Kamera zu Auto</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = Bildschirm </font><strong><font style="vertical-align: inherit;">y-</font></strong><font style="vertical-align: inherit;"> Koordinate</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann können wir das Gesetz ähnlicher Dreiecke verwenden, um zu berechnen </font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y = h * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
wie im Diagramm gezeigt:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können auch ein ähnliches Diagramm in einer Draufsicht anstelle einer Seitenansicht zeichnen und eine ähnliche Gleichung ableiten, um die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinate des </font><font style="vertical-align: inherit;">Bildschirms </font><font style="vertical-align: inherit;">zu berechnen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x = w * d / z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wobei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = die halbe Breite der Straße (von der Kamera bis zum Straßenrand). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie Sie sehen können, </font><font style="vertical-align: inherit;">skalieren wir </font><font style="vertical-align: inherit;">für </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> um einen Faktor</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d / z</font></font></strong></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Koordinatensystem</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Form eines Diagramms sieht es schön und einfach aus, aber wenn Sie mit dem Codieren beginnen, können Sie ein wenig verwirrt werden, da wir beliebige Namen gewählt haben und nicht klar ist, wie wir die Koordinaten der 3D-Welt angegeben haben und wie die Koordinaten des 2D-Bildschirms lauten. </font><font style="vertical-align: inherit;">Wir gehen auch davon aus, dass sich die Kamera im Zentrum des Ursprungs der Welt befindet, obwohl sie in Wirklichkeit der Maschine folgen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie formeller vorgehen, müssen wir Folgendes tun:</font></font><br>
<br>
<ol>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvertierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von Weltkoordinaten in Bildschirmkoordinaten</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projizieren von</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kamerakoordinaten auf eine normalisierte Projektionsebene</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalieren der</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> projizierten Koordinaten auf die Koordinaten des physischen Bildschirms (in unserem Fall ist dies Leinwand)</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b59/5d2/30f/b595d230f4f45b9b0c9409266d5804d8.png"></div><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Im vorliegenden 3D-System </font><font style="vertical-align: inherit;">wird die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rotationsstufe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zwischen den Stufen 1 und 2 ausgeführt </font><font style="vertical-align: inherit;">. Da wir jedoch die Kurven simulieren, benötigen wir keine Rotation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projektion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die formalen Projektionsgleichungen können wie folgt dargestellt werden:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Umrechnungsgleichungen ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">übersetzen</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) Punkt berechnet relativ zur Kammer</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Projektionsgleichungen ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projekt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) sind Variationen des oben gezeigten „Gesetzes ähnlicher Dreiecke“.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalierungsgleichungen ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skalierung</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) berücksichtigen den Unterschied zwischen:</font></font><br>
<ul>
<li><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mathe</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wobei 0,0 in der Mitte liegt und die y-Achse oben ist, und</font></font></li>
<li><em></em>,  0,0     ,   y  :</li>
</ul></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/11f/050/aad/11f050aadea0d1c537baefcb06f7c2f0.png"></div><br>
<blockquote><em>:   3d-         <code>Vector</code>  <code>Matrix</code>     3d-,      ,      WebGL (  )…       .           Outrun.</em></blockquote><br>
<h2>  </h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/27b/1bd/3b727b1bdb285d874bd659c29db13522.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das letzte Puzzleteil ist eine Möglichkeit, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu berechnen </font><font style="vertical-align: inherit;">- den Abstand von der Kamera zur Projektionsebene. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anstatt nur einen fest eingestellten Wert von </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d zu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schreiben </font><font style="vertical-align: inherit;">, wäre es sinnvoller, ihn aus dem gewünschten vertikalen Sichtfeld zu berechnen. </font><font style="vertical-align: inherit;">Dank dessen können wir die Kamera bei Bedarf "zoomen". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir annehmen, dass wir auf eine normalisierte Projektionsebene projizieren, deren Koordinaten im Bereich von -1 bis +1 liegen, </font><font style="vertical-align: inherit;">kann </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wie folgt berechnet werden:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 1 / tan (fov / 2)</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Indem </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir fov</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als eine (von vielen) Variablen definieren, können wir den Bereich anpassen, um den Rendering-Algorithmus zu </font><strong><font style="vertical-align: inherit;">optimieren</font></strong><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Javascript-Codestruktur</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zu Beginn des Artikels habe ich bereits gesagt, dass der Code nicht ganz den Richtlinien zum Schreiben von Javascript entspricht - es ist eine „schnelle und schmutzige“ Demo mit einfachen globalen Variablen und Funktionen. </font><font style="vertical-align: inherit;">Da ich jedoch vier separate Versionen erstellen werde (gerade, Kurven, Hügel und Sprites), werde ich einige wiederverwendbare Methoden </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den folgenden Modulen </font><font style="vertical-align: inherit;">speichern </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dom</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist ein paar kleinere DOM-Hilfsfunktionen.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Util</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - allgemeine Dienstprogramme, hauptsächlich mathematische Hilfsfunktionen.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spiel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Allgemeine Spielunterstützungsfunktionen wie Bild-Downloader und Spieleschleife.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Helferfunktionen auf Leinwand Rendering.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde Methoden </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nur dann </font><font style="vertical-align: inherit;">im Detail erklären, </font><font style="vertical-align: inherit;">wenn sie sich auf das Spiel selbst beziehen und nicht nur mathematische Hilfs- oder DOM-Funktionen sind. </font><font style="vertical-align: inherit;">Hoffentlich wird aus dem Namen und dem Kontext klar, was die Methoden tun sollten.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode befindet sich wie gewohnt in der endgültigen Dokumentation.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfache Spielschleife</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir etwas rendern, benötigen wir eine Spielschleife. </font><font style="vertical-align: inherit;">Wenn Sie einen meiner vorherigen Artikel über Spiele ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pong</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Breakout</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetris</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlangen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boulderdash</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">gelesen haben</font></a><font style="vertical-align: inherit;"> , haben Sie bereits Beispiele meines Lieblingsspielzyklus mit einem </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">festgelegten Zeitschritt gesehen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde nicht tief in die Details gehen und einfach einen Teil des Codes aus früheren Spielen wiederverwenden, um mit </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requestAnimationFrame</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eine Spielschleife mit einem festen Zeitschritt zu </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">erstellen</font></a><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip ist, dass jedes meiner vier Beispiele </font></font><code>Game.run(...)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">seine eigenen Versionen </font><font style="vertical-align: inherit;">aufrufen </font><font style="vertical-align: inherit;">und verwenden </font><font style="vertical-align: inherit;">kann</font></font><br>
<br>
<ul>
<li><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Aktualisierung der Spielwelt mit einem festgelegten Zeitschritt.</font></font></li>
<li><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Aktualisierung der Spielwelt, wenn der Browser dies zulässt.</font></font></li>
</ul><br>
<pre><code class="javascript hljs">run: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{<font></font>
<font></font>
  Game.loadImages(options.images, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">images</span>) </span>{<font></font>
<font></font>
    <span class="hljs-keyword">var</span> update = options.update,    <span class="hljs-comment">// method to update game logic is provided by caller</span>
        render = options.render,    <span class="hljs-comment">// method to render the game is provided by caller</span>
        step   = options.step,      <span class="hljs-comment">// fixed frame step (1/fps) is specified by caller</span>
        now    = <span class="hljs-literal">null</span>,<font></font>
        last   = Util.timestamp(),<font></font>
        dt     = <span class="hljs-number">0</span>,<font></font>
        gdt    = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">frame</span>(<span class="hljs-params"></span>) </span>{<font></font>
      now = Util.timestamp();<font></font>
      dt  = <span class="hljs-built_in">Math</span>.min(<span class="hljs-number">1</span>, (now - last) / <span class="hljs-number">1000</span>); <span class="hljs-comment">// using requestAnimationFrame have to be able to handle large delta's caused when it 'hibernates' in a background or non-visible tab</span><font></font>
      gdt = gdt + dt;<font></font>
      <span class="hljs-keyword">while</span> (gdt &gt; step) {<font></font>
        gdt = gdt - step;<font></font>
        update(step);<font></font>
      }<font></font>
      render();<font></font>
      last = now;<font></font>
      requestAnimationFrame(frame);<font></font>
    }<font></font>
    frame(); <span class="hljs-comment">// lets get this party started</span><font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auch dies ist ein Remake von Ideen aus meinen vorherigen Canvas-Spielen. Wenn Sie also nicht verstehen, wie die Spieleschleife funktioniert, kehren Sie zu einem der vorherigen Artikel zurück.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bilder und Sprites</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor der Spielzyklus beginnt, laden wir zwei separate Spritesheets (Sprite Sheets):</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - drei Parallaxenschichten für Himmel, Hügel und Bäume</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprites</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Maschinen-Sprites (plus Bäume und Werbetafeln, die der endgültigen Version hinzugefügt werden sollen)</font></font></li>
</ul><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Sprite-Blatt wurde mit einer kleinen Aufgabe Rake und </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ruby Gem Sprite-Factory erstellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Aufgabe generiert die kombinierten Sprite-Blätter sowie die Koordinaten x, y, w, h, die in den Konstanten </font></font><code>BACKGROUND</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font><font style="vertical-align: inherit;">gespeichert werden </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hinweis: Ich habe die Hintergründe mit Inkscape erstellt. Die meisten Sprites sind Grafiken, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus der alten Outrun-Version für Genesis stammen und als Trainingsbeispiele verwendet werden.</font></font></em></blockquote><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielvariablen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu Bildern von Hintergründen und Sprites benötigen wir verschiedene Spielvariablen, nämlich:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> fps           = <span class="hljs-number">60</span>;                      <span class="hljs-comment">// how many 'update' frames per second</span>
<span class="hljs-keyword">var</span> step          = <span class="hljs-number">1</span>/fps;                   <span class="hljs-comment">// how long is each frame (in seconds)</span>
<span class="hljs-keyword">var</span> width         = <span class="hljs-number">1024</span>;                    <span class="hljs-comment">// logical canvas width</span>
<span class="hljs-keyword">var</span> height        = <span class="hljs-number">768</span>;                     <span class="hljs-comment">// logical canvas height</span>
<span class="hljs-keyword">var</span> segments      = [];                      <span class="hljs-comment">// array of road segments</span>
<span class="hljs-keyword">var</span> canvas        = Dom.get(<span class="hljs-string">'canvas'</span>);       <span class="hljs-comment">// our canvas...</span>
<span class="hljs-keyword">var</span> ctx           = canvas.getContext(<span class="hljs-string">'2d'</span>); <span class="hljs-comment">// ...and its drawing context</span>
<span class="hljs-keyword">var</span> background    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our background image (loaded below)</span>
<span class="hljs-keyword">var</span> sprites       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// our spritesheet (loaded below)</span>
<span class="hljs-keyword">var</span> resolution    = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// scaling factor to provide resolution independence (computed)</span>
<span class="hljs-keyword">var</span> roadWidth     = <span class="hljs-number">2000</span>;                    <span class="hljs-comment">// actually half the roads width, easier math if the road spans from -roadWidth to +roadWidth</span>
<span class="hljs-keyword">var</span> segmentLength = <span class="hljs-number">200</span>;                     <span class="hljs-comment">// length of a single segment</span>
<span class="hljs-keyword">var</span> rumbleLength  = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of segments per red/white rumble strip</span>
<span class="hljs-keyword">var</span> trackLength   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z length of entire track (computed)</span>
<span class="hljs-keyword">var</span> lanes         = <span class="hljs-number">3</span>;                       <span class="hljs-comment">// number of lanes</span>
<span class="hljs-keyword">var</span> fieldOfView   = <span class="hljs-number">100</span>;                     <span class="hljs-comment">// angle (degrees) for field of view</span>
<span class="hljs-keyword">var</span> cameraHeight  = <span class="hljs-number">1000</span>;                    <span class="hljs-comment">// z height of camera</span>
<span class="hljs-keyword">var</span> cameraDepth   = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// z distance camera is from screen (computed)</span>
<span class="hljs-keyword">var</span> drawDistance  = <span class="hljs-number">300</span>;                     <span class="hljs-comment">// number of segments to draw</span>
<span class="hljs-keyword">var</span> playerX       = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// player x offset from center of road (-1 to 1 to stay independent of roadWidth)</span>
<span class="hljs-keyword">var</span> playerZ       = <span class="hljs-literal">null</span>;                    <span class="hljs-comment">// player relative z distance from camera (computed)</span>
<span class="hljs-keyword">var</span> fogDensity    = <span class="hljs-number">5</span>;                       <span class="hljs-comment">// exponential fog density</span>
<span class="hljs-keyword">var</span> position      = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current camera Z position (add playerZ to get player's absolute Z position)</span>
<span class="hljs-keyword">var</span> speed         = <span class="hljs-number">0</span>;                       <span class="hljs-comment">// current speed</span>
<span class="hljs-keyword">var</span> maxSpeed      = segmentLength/step;      <span class="hljs-comment">// top speed (ensure we can't move more than 1 segment in a single frame to make collision detection easier)</span>
<span class="hljs-keyword">var</span> accel         =  maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// acceleration rate - tuned until it 'felt' right</span>
<span class="hljs-keyword">var</span> breaking      = -maxSpeed;               <span class="hljs-comment">// deceleration rate when braking</span>
<span class="hljs-keyword">var</span> decel         = -maxSpeed/<span class="hljs-number">5</span>;             <span class="hljs-comment">// 'natural' deceleration rate when neither accelerating, nor braking</span>
<span class="hljs-keyword">var</span> offRoadDecel  = -maxSpeed/<span class="hljs-number">2</span>;             <span class="hljs-comment">// off road deceleration is somewhere in between</span>
<span class="hljs-keyword">var</span> offRoadLimit  =  maxSpeed/<span class="hljs-number">4</span>;             <span class="hljs-comment">// limit when off road deceleration no longer applies (e.g. you can always go at least this speed even when off road)</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige von ihnen können mithilfe von UI-Steuerelementen angepasst werden, um kritische Werte während der Programmausführung zu ändern, sodass Sie sehen können, wie sie sich auf das Rendern der Straße auswirken. </font><font style="vertical-align: inherit;">Andere werden aus benutzerdefinierten UI-Werten in der Methode neu berechnet </font></font><code>reset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir verwalten Ferrari</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir führen Tastenkombinationen für durch </font></font><code>Game.run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die eine einfache Tastatureingabe ermöglichen, mit der Variablen festgelegt oder zurückgesetzt werden, die die aktuellen Aktionen des Spielers melden:</font></font><br>
<br>
<pre><code class="javascript hljs">Game.run({<font></font>
  ...<font></font>
  keys: [<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'down'</span>, <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">true</span>;  } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.LEFT,  KEY.A], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyLeft   = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.RIGHT, KEY.D], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyRight  = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.UP,    KEY.W], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keyFaster = <span class="hljs-literal">false</span>; } },<font></font>
    { <span class="hljs-attr">keys</span>: [KEY.DOWN,  KEY.S], <span class="hljs-attr">mode</span>: <span class="hljs-string">'up'</span>,   <span class="hljs-attr">action</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{ keySlower = <span class="hljs-literal">false</span>; } }<font></font>
  ],<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Status des Spielers wird durch die folgenden Variablen gesteuert:</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - aktuelle Geschwindigkeit.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Position</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Die aktuelle Z-Position auf der Spur. </font><font style="vertical-align: inherit;">Beachten Sie, dass dies eine Kameraposition ist, kein Ferrari.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerX</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die aktuelle Position des Spielers auf X auf der Straße. </font><font style="vertical-align: inherit;">Normalisiert im Bereich von -1 bis +1, um nicht vom tatsächlichen Wert abzuhängen </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Variablen werden in der Methode festgelegt </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die die folgenden Aktionen ausführt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Updates </font></font><code>position</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basierend auf dem aktuellen </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wird aktualisiert, </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn Sie die linke oder rechte Taste drücken.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erhöht sich, </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Aufwärts-Taste gedrückt wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nimmt ab, </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Abwärtstaste gedrückt wird.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduziert sich, </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn die Auf- und Ab-Tasten nicht gedrückt werden.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">reduziert sich, </font></font><code>speed</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wenn es </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sich am Straßenrand und im Gras befindet.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei direkten Straßen ist die Methode </font></font><code>update</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ganz klar und einfach:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span>(<span class="hljs-params">dt</span>) </span>{<font></font>
<font></font>
  position = Util.increase(position, dt * speed, trackLength);<font></font>
<font></font>
  <span class="hljs-keyword">var</span> dx = dt * <span class="hljs-number">2</span> * (speed/maxSpeed); <span class="hljs-comment">// at top speed, should be able to cross from left to right (-1 to 1) in 1 second</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyLeft)<font></font>
    playerX = playerX - dx;<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keyRight)<font></font>
    playerX = playerX + dx;<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (keyFaster)<font></font>
    speed = Util.accelerate(speed, accel, dt);<font></font>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (keySlower)<font></font>
    speed = Util.accelerate(speed, breaking, dt);<font></font>
  <span class="hljs-keyword">else</span><font></font>
    speed = Util.accelerate(speed, decel, dt);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) &amp;&amp; (speed &gt; offRoadLimit))<font></font>
    speed = Util.accelerate(speed, offRoadDecel, dt);<font></font>
<font></font>
  playerX = Util.limit(playerX, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>);     <span class="hljs-comment">// dont ever let player go too far out of bounds</span>
  speed   = Util.limit(speed, <span class="hljs-number">0</span>, maxSpeed); <span class="hljs-comment">// or exceed maxSpeed</span><font></font>
<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keine Sorge, es wird viel schwieriger, wenn wir in der fertigen Version Sprites und Kollisionserkennung hinzufügen.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßengeometrie</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bevor wir die Spielwelt rendern können, müssen wir ein Array von </font></font><code>segments</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In in der Methode </font><font style="vertical-align: inherit;">erstellen </font></font><code>resetRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jedes dieser Straßensegmente wird letztendlich von seinen Weltkoordinaten projiziert, sodass es in Bildschirmkoordinaten zu einem 2D-Polygon wird. </font><font style="vertical-align: inherit;">Für jedes Segment speichern wir zwei Punkte, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Mitte der Kante, die der Kamera am nächsten liegt, und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Mitte der Kante, die am weitesten von der Kamera entfernt ist.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53a/fa4/076/53afa40768a00b49833703b1457a6941.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Genau genommen ist </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Segments identisch mit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1 des</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vorherigen Segments, aber es scheint mir, dass es einfacher ist, sie als separate Punkte zu speichern und jedes Segment separat zu konvertieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir bleiben getrennt, </font></font><code>rumbleLength</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weil wir schöne detaillierte Kurven und Hügel haben können, aber gleichzeitig horizontale Streifen. Wenn jedes nachfolgende Segment eine andere Farbe hat, wird ein schlechter Strobe-Effekt erzeugt. Daher möchten wir viele kleine Segmente haben, diese aber zu separaten horizontalen Streifen zusammenfassen.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetRoad</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments = [];<font></font>
  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; <span class="hljs-number">500</span> ; n++) { <span class="hljs-comment">// arbitrary road length</span><font></font>
    segments.push({<font></font>
       <span class="hljs-attr">index</span>: n,
       <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
       <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
    });<font></font>
  }<font></font>
<font></font>
  trackLength = segments.length * segmentLength;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir initialisieren </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nur mit den Weltkoordinaten </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , weil wir nur gerade Straßen brauchen. Die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">sind immer 0 und die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">hängen immer vom skalierten Wert ab </font></font><code>+/- roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Wenn wir später Kurven und Hügel hinzufügen, ändert sich dieser Teil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden auch leere Objekte festlegen, um Darstellungen dieser Punkte in der Kamera und auf dem Bildschirm zu speichern, um nicht in jedem eine Reihe von temporären Objekten zu erstellen </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Um die Speicherbereinigung zu minimieren, müssen wir vermeiden, Objekte innerhalb der Spielschleife zuzuweisen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Auto das Ende der Straße erreicht, kehren wir einfach zum Anfang des Zyklus zurück. </font><font style="vertical-align: inherit;">Um dies zu vereinfachen, erstellen wir eine Methode, um ein Segment für einen beliebigen Wert von Z zu finden, auch wenn es über die Länge der Straße hinausgeht:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findSegment</span>(<span class="hljs-params">z</span>) </span>{
  <span class="hljs-keyword">return</span> segments[<span class="hljs-built_in">Math</span>.floor(z/segmentLength) % segments.length];<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrund-Rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Methode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beginnt mit dem Rendern des Hintergrundbilds. </font><font style="vertical-align: inherit;">In den folgenden Abschnitten, in denen wir Kurven und Hügel hinzufügen, benötigen wir den Hintergrund, um das Parallaxen-Scrollen durchzuführen. Daher beginnen wir jetzt, uns in diese Richtung zu bewegen und den Hintergrund als drei separate Ebenen zu rendern:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  ctx.clearRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height);<font></font>
<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.SKY);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.HILLS);<font></font>
  Render.background(ctx, background, width, height, BACKGROUND.TREES);<font></font>
<font></font>
  ...</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Straßenrendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anschließend iteriert die Renderfunktion über alle Segmente und Projekte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Segments von Weltkoordinaten zu Bildschirmkoordinaten, schneidet das Segment bei Bedarf ab und rendert es auf andere Weise:</font></font><br>
<br>
<pre><code class="javascript hljs">  <span class="hljs-keyword">var</span> baseSegment = findSegment(position);
  <span class="hljs-keyword">var</span> maxy        = height;
  <span class="hljs-keyword">var</span> n, segment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
    segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
    Util.project(segment.p1, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
    Util.project(segment.p2, (playerX * roadWidth), cameraHeight, position, cameraDepth, width, height, roadWidth);<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
        (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
      <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
    Render.segment(ctx, width, lanes,<font></font>
                   segment.p1.screen.x,<font></font>
                   segment.p1.screen.y,<font></font>
                   segment.p1.screen.w,<font></font>
                   segment.p2.screen.x,<font></font>
                   segment.p2.screen.y,<font></font>
                   segment.p2.screen.w,<font></font>
                   segment.color);<font></font>
<font></font>
    maxy = segment.p2.screen.y;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Oben haben wir bereits die Berechnungen gesehen, die für die Projektion eines Punktes erforderlich sind. Die Javascript-Version kombiniert Transformation, Projektion und Skalierung in einer Methode:</font></font><br>
<br>
<pre><code class="javascript hljs">project: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p, cameraX, cameraY, cameraZ, cameraDepth, width, height, roadWidth</span>) </span>{<font></font>
  p.camera.x     = (p.world.x || <span class="hljs-number">0</span>) - cameraX;<font></font>
  p.camera.y     = (p.world.y || <span class="hljs-number">0</span>) - cameraY;<font></font>
  p.camera.z     = (p.world.z || <span class="hljs-number">0</span>) - cameraZ;<font></font>
  p.screen.scale = cameraDepth/p.camera.z;<font></font>
  p.screen.x     = <span class="hljs-built_in">Math</span>.round((width/<span class="hljs-number">2</span>)  + (p.screen.scale * p.camera.x  * width/<span class="hljs-number">2</span>));<font></font>
  p.screen.y     = <span class="hljs-built_in">Math</span>.round((height/<span class="hljs-number">2</span>) - (p.screen.scale * p.camera.y  * height/<span class="hljs-number">2</span>));<font></font>
  p.screen.w     = <span class="hljs-built_in">Math</span>.round(             (p.screen.scale * roadWidth   * width/<span class="hljs-number">2</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zur Berechnung der Bildschirme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für jeden Punkt </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2 verwenden</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wir dieselben Projektionsberechnungen, um die projizierte Breite ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) des Segments </font><font style="vertical-align: inherit;">zu berechnen </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit den </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten des Bildschirms der </font><font style="vertical-align: inherit;">Punkte </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie der projizierten Straßenbreite </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können wir mit Hilfe einer Hilfsfunktion ganz einfach </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alle Polygone </font><font style="vertical-align: inherit;">berechnen, die </font><font style="vertical-align: inherit;">zum Rendern von Gras, Straße, horizontalen Streifen und Trennlinien erforderlich sind, unter Verwendung der allgemeinen Hilfsfunktion </font></font><code>Render.polygon</code> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(siehe . </font></font><code>common.js</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auto-Rendering</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Letzte, was die Methode benötigt, </font></font><code>render</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist ein Ferrari-Rendering:</font></font><br>
<br>
<pre><code class="javascript hljs">  Render.player(ctx, width, height, resolution, roadWidth, sprites, speed/maxSpeed,<font></font>
                cameraDepth/playerZ,<font></font>
                width/<span class="hljs-number">2</span>,<font></font>
                height);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode wird aufgerufen </font></font><code>player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und nicht </font></font><code>car</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da in der endgültigen Version des Spiels andere Autos unterwegs sein werden und wir den Ferrari des Spielers von anderen Autos trennen möchten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Hilfsfunktion </font></font><code>Render.player</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verwendet die Canvas-Methode, die </font></font><code>drawImage</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Rendern des Sprites </font><font style="vertical-align: inherit;">aufgerufen wird </font><font style="vertical-align: inherit;">, nachdem sie zuvor mit derselben Projektionsskalierung skaliert wurde, die zuvor verwendet wurde:</font></font><br>
<br>
<blockquote><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wobei </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in diesem Fall der relative Abstand von der Maschine zur Kamera ist, der in der Variablen </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">playerZ</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gespeichert ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Darüber hinaus „wackelt“ die Funktion das Auto bei hohen Geschwindigkeiten ein wenig und fügt der Skalierungsgleichung je nach </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit / Höchstgeschwindigkeit</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ein wenig Zufälligkeit </font><strong><font style="vertical-align: inherit;">hinzu</font></strong><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und hier ist was wir haben:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/845/dfd/3e8/845dfd3e88ef0a22b2c9fd021140ff3b.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben ziemlich viel Arbeit geleistet, um ein System mit geraden Straßen zu schaffen. </font><font style="vertical-align: inherit;">Wir fügten hinzu</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">generisches Hilfsmodul </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dom</font></font></strong></li>
<li><font style="vertical-align: inherit;"><strong><font style="vertical-align: inherit;">Verwenden Sie das</font></strong><font style="vertical-align: inherit;"> allgemeine Mathematikmodul</font></font><strong><font style="vertical-align: inherit;"></font></strong></li>
<li><font style="vertical-align: inherit;"></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> allgemeinen Leinwand Helfer Modul </font><font style="vertical-align: inherit;">...</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... einschließlich </font></font><code>Render.segment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Render.polygon</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und</font></font><code>Render.sprite</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Spielzyklus mit fester Tonhöhe</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bild-Downloader</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tastaturhandler</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallaxenhintergrund</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sprite Sheet mit Autos, Bäumen und Werbetafeln</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rudimentäre Geometrie der Straße</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur Steuerung der Maschine</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Methode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zum Rendern von Hintergrund-, Straßen- und Spielerautos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTML5-Tag </font></font><code>&lt;audio&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit Rennmusik (versteckter Bonus!)</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... was uns eine gute Grundlage für die weitere Entwicklung gab.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil 2. Kurven.</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In diesem Teil werden wir detaillierter erklären, wie Kurven funktionieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im vorherigen Teil haben wir die Geometrie der Straße in Form einer Reihe von Segmenten zusammengestellt, von denen jedes Weltkoordinaten aufweist, die relativ zur Kamera transformiert und dann auf den Bildschirm projiziert werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir brauchten nur die Weltkoordinate </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für jeden Punkt, da auf geraden Straßen sowohl </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als auch </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gleich Null waren.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c78/551/359/c78551359ef7c11e4af48b4285d61842.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn wir ein voll funktionsfähiges 3D-System erstellen würden, könnten wir die Kurven implementieren, indem wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streifen der oben gezeigten Polygone </font><font style="vertical-align: inherit;">berechnen </font><font style="vertical-align: inherit;">. Diese Art von Geometrie wird jedoch ziemlich schwierig zu berechnen sein, und dafür wird es notwendig sein, die 3D-Rotationsstufe zu den Projektionsgleichungen hinzuzufügen ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... wenn wir diesen Weg gehen würden, wäre es besser, WebGL oder seine Analoga zu verwenden, aber dieses Projekt hat keine anderen Aufgaben für unser Projekt. Wir wollen nur pseudo-dreidimensionale Tricks der alten Schule verwenden, um Kurven zu simulieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher werden Sie wahrscheinlich überrascht sein zu erfahren, dass wir die </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinaten </font><font style="vertical-align: inherit;">der Straßensegmente überhaupt </font><font style="vertical-align: inherit;">nicht berechnen </font><font style="vertical-align: inherit;">... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stattdessen verwenden wir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lus Rat</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Um die Straße zu krümmen, ändern Sie einfach die Position der Mittellinie der Kurvenform. Ausgehend vom unteren Bildschirmrand nimmt die Verschiebung der Straßenmitte nach links oder rechts allmählich zu</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><em><font style="vertical-align: inherit;">"</font></em></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In unserem Fall ist die Mittellinie der Wert </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, der an die Projektionsberechnungen übergeben wird. </font><font style="vertical-align: inherit;">Dies bedeutet, dass Sie bei </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedem Straßensegment die Kurven simulieren können, indem Sie den Wert </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um einen allmählich ansteigenden Wert verschieben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um zu wissen, wie viel verschoben werden muss, müssen wir in jedem Segment einen Wert speichern </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dieser Wert gibt an, um wie viel das Segment von der Mittellinie der Kamera verschoben werden soll. </font><font style="vertical-align: inherit;">Sie wird sein:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">negativ für linksdrehende Kurven</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">positiv für Kurven nach rechts</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weniger für glatte Kurven</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mehr für scharfe Kurven</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Werte selbst werden ganz willkürlich gewählt; </font><font style="vertical-align: inherit;">Durch Versuch und Irrtum können wir gute Werte finden, bei denen die Kurven „korrekt“ zu sein scheinen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> }, <span class="hljs-comment">// num segments</span>
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zur Auswahl guter Werte für die Kurven müssen Lücken in den Übergängen vermieden werden, wenn sich die Linie in eine Kurve verwandelt (oder umgekehrt). </font><font style="vertical-align: inherit;">Dies kann durch </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erweichen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> beim Betreten und Verlassen der Kurven erreicht werden. </font><font style="vertical-align: inherit;">Dazu erhöhen (oder verringern) wir den Wert </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">für jedes Segment </font><font style="vertical-align: inherit;">schrittweise </font><font style="vertical-align: inherit;">mithilfe herkömmlicher Glättungsfunktionen, bis der gewünschte Wert erreicht ist:</font></font><br>
<br>
<pre><code class="javascript hljs">easeIn:    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*<span class="hljs-built_in">Math</span>.pow(percent,<span class="hljs-number">2</span>);                           },
<span class="hljs-attr">easeOut</span>:   <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*(<span class="hljs-number">1</span>-<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1</span>-percent,<span class="hljs-number">2</span>));                     },
<span class="hljs-attr">easeInOut</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b,percent</span>) </span>{ <span class="hljs-keyword">return</span> a + (b-a)*((-<span class="hljs-built_in">Math</span>.cos(percent*<span class="hljs-built_in">Math</span>.PI)/<span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>);        },</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das heißt nun unter Berücksichtigung der Funktion, der Geometrie ein Segment hinzuzufügen ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir können eine Methode für den reibungslosen Ein- und Ausstieg von einer kurvenreichen Straße erstellen:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve</span>) </span>{
  <span class="hljs-keyword">var</span> n;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve);<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und oben können Sie zusätzliche Geometrie festlegen, z. B. S-förmige Kurven:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSCurves</span>(<span class="hljs-params"></span>) </span>{<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.MEDIUM);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,   ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.EASY);<font></font>
  addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM,  -ROAD.CURVE.MEDIUM);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Änderungen an der update () -Methode</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einzigen Änderungen, die an der Methode vorgenommen </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">werden </font><font style="vertical-align: inherit;">müssen, </font><font style="vertical-align: inherit;">sind das Aufbringen einer Art Zentrifugalkraft, wenn sich die Maschine entlang einer Kurve bewegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir legen einen beliebigen Faktor fest, der nach unseren Wünschen angepasst werden kann.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> centrifugal = <span class="hljs-number">0.3</span>;   <span class="hljs-comment">// centrifugal force multiplier when going around curves</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und dann aktualisieren wir einfach die Position </font></font><code>playerX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">basierend auf der aktuellen Geschwindigkeit, dem Kurvenwert und dem Fliehkraftmultiplikator:</font></font><br>
<br>
<pre><code class="javascript hljs">playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kurvenwiedergabe</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir haben oben gesagt, dass Sie simulierte Kurven rendern können, indem Sie den </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Projektionsberechnungen verwendeten </font><font style="vertical-align: inherit;">Wert </font><font style="vertical-align: inherit;">während der Ausführung </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jedes Straßensegments verschieben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8a/569/19e/c8a56919e67d6f19cc737074ce92fffb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu speichern wir die Antriebsvariable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die für jedes Segment um einen Wert erhöht wird </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sowie die Variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die als Versatz des </font></font><code>cameraX</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in Projektionsberechnungen verwendeten </font><font style="vertical-align: inherit;">Werts </font><font style="vertical-align: inherit;">verwendet wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Kurven zu implementieren, benötigen wir Folgendes:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie die Projektion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Segments um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie die Projektion </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Segments um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Erhöhen Sie </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für das nächste Segment um </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich müssen wir </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem interpolierten Wert der Kurve der aktuellen </font><strong><font style="vertical-align: inherit;">Basissegmente</font></strong><font style="vertical-align: inherit;"> initialisieren </font><font style="vertical-align: inherit;">, um zerrissene Übergänge beim Überschreiten der Segmentgrenzen zu vermeiden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ändern Sie die Methode </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie folgt:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> baseSegment = findSegment(position);
<span class="hljs-keyword">var</span> basePercent = Util.percentRemaining(position, segmentLength);
<span class="hljs-keyword">var</span> dx = - (baseSegment.curve * basePercent);
<span class="hljs-keyword">var</span> x  = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  Util.project(segment.p1, (playerX * roadWidth) - x,      cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
  Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : <span class="hljs-number">0</span>), cameraDepth, width, height, roadWidth);<font></font>
<font></font>
  x  = x + dx;<font></font>
  dx = dx + segment.curve;<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parallax Scrolling Hintergrund</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich müssen wir die Parallaxen-Hintergrundebenen scrollen und den Versatz für jede Ebene speichern ...</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> skySpeed    = <span class="hljs-number">0.001</span>; <span class="hljs-comment">// background sky layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> hillSpeed   = <span class="hljs-number">0.002</span>; <span class="hljs-comment">// background hill layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> treeSpeed   = <span class="hljs-number">0.003</span>; <span class="hljs-comment">// background tree layer scroll speed when going around curve (or up hill)</span>
<span class="hljs-keyword">var</span> skyOffset   = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current sky scroll offset</span>
<span class="hljs-keyword">var</span> hillOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current hill scroll offset</span>
<span class="hljs-keyword">var</span> treeOffset  = <span class="hljs-number">0</span>;     <span class="hljs-comment">// current tree scroll offset</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und im Laufe der Zeit in </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abhängigkeit vom Kurvenwert des aktuellen Spielersegments und seiner Geschwindigkeit erhöhen ...</font></font><br>
<br>
<pre><code class="javascript hljs">skyOffset  = Util.increase(skyOffset,  skySpeed  * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);<font></font>
treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, <span class="hljs-number">1</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... und verwenden Sie dann diesen Offset, wenn Sie </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrundebenen erstellen.</font></font><br>
<br>
<pre><code class="javascript hljs">Render.background(ctx, background, width, height, BACKGROUND.SKY,   skyOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);<font></font>
Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fazit</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier erhalten wir also die gefälschten pseudo-dreidimensionalen Kurven:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98f/c3d/6d1/98fc3d6d13cc16f12847d253e112fcb2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptteil des Codes, den wir hinzugefügt haben, besteht darin, die Geometrie der Straße mit dem entsprechenden Wert zu erstellen </font></font><code>curve</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Das Hinzufügen von Zentrifugalkraft während der Zeit ist </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viel einfacher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Rendern von Kurven wird in nur wenigen Codezeilen ausgeführt, es kann jedoch schwierig sein, zu verstehen (und zu beschreiben), was genau hier passiert. Es gibt viele Möglichkeiten, Kurven zu simulieren, und es ist sehr einfach zu wandern, wenn sie in eine Sackgasse implementiert werden. Es ist noch einfacher, sich von einer externen Aufgabe mitreißen zu lassen und zu versuchen, alles „richtig“ zu machen. Bevor Sie dies erkennen, werden Sie beginnen, ein voll funktionsfähiges 3D-System mit Matrizen, Rotationen und realer 3D-Geometrie zu erstellen ... was, wie gesagt, nicht unsere Aufgabe ist.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich diesen Artikel schrieb, war ich mir sicher, dass es definitiv Probleme bei der Implementierung der Kurven gab. </font><font style="vertical-align: inherit;">Beim Versuch, den Algorithmus zu visualisieren, habe ich nicht verstanden, warum ich zwei Werte der </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dx-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Laufwerke </font><font style="vertical-align: inherit;">anstelle von einem benötigte ... und wenn ich etwas nicht vollständig erklären kann, ist irgendwo etwas schiefgegangen ... </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... aber die Arbeitszeit des Projekts </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"läuft" das Wochenende “ist</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fast abgelaufen, und ehrlich gesagt scheinen mir die Kurven ziemlich schön zu sein, und am Ende ist dies das Wichtigste.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de499240/index.html">Durch Dornen zu den Sternen oder Datenanalyse in den Angelegenheiten des Himmels</a></li>
<li><a href="../de499242/index.html">Die Forscher übertrugen Daten von einem Desktop-PC durch Vibrationen über einen Tisch</a></li>
<li><a href="../de499244/index.html">Synergetische Organisationen. Teil II</a></li>
<li><a href="../de499246/index.html">Untersuchung der logistischen Funktion als Gesetz der Industrieentwicklung</a></li>
<li><a href="../de499248/index.html">Wie wir persönliche Schutzausrüstung erkennen</a></li>
<li><a href="../de499254/index.html">Das Mitglied des PyConRu 2020-Programmkomitees beantwortet Fragen zu Python: ein aktuelles Aussehen und ein bisschen Parseltang</a></li>
<li><a href="../de499262/index.html">Letzter Online-Hackathon für selbstständige SMZhack: Projekte, die die Menschen treffen werden</a></li>
<li><a href="../de499268/index.html">Raumbewusstsein: Was kann eine Hololens-Brille?</a></li>
<li><a href="../de499274/index.html">Wir haben die neue Kapsel zerlegt. Wir wissen, wie viele Mikrofone und wie es funktioniert</a></li>
<li><a href="../de499278/index.html">Brotli Effizienz in der realen Welt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>