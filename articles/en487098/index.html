<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö• üéØ üéª Draw with ants: procedural images using ant colony optimization algorithms üëí üçØ üöú</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Why did I want to draw with ants
 I wanted to create a work of art exploring the complexity of software design. When I present a huge code base, I thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Draw with ants: procedural images using ant colony optimization algorithms</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487098/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why did I want to draw with ants</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I wanted to create a work of art exploring the complexity of software design. When I present a huge code base, I think about its independently arising complexity and its intertwined, interconnected parts. Its general form, so to speak, arises from the actions of many individual personalities. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I was thinking about how to present this graphically, and one of the images that found a response in me was the image of an ant colony. Ants are a great example of emerging (emergent) complexity. No single ant is an architect, but together they build magnificent complex structures.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/4f3/a72/5b14f3a72a15eefbeef534448a51647b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scheme of formicaria. Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia Commons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
I started by looking for information on simulations of ant colonies. Obviously, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">literature exists about this, and it is beautiful</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . But the trick was that the anthills arise in part depending on the physics of the sand and the earth in which they are built - because their creation depends on how the particle will be located when the ant puts it. I wanted to create something in 2D, so I tried to go straight to the simulation without writing sand physics code, that is, I had to abandon the physical simulation of the anthill. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Because of this, I began to search again, and they led me to a completely </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">different</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> class of ant simulations:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ant colony optimization algorithms (ant colony algorithms)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ant colony optimization is an agent algorithm used to solve the problem of finding the shortest path between two points of a graph. ‚ÄúAgent‚Äù means that the algorithm consists of separate procedures (in this case, ‚Äúants‚Äù), the emergent behavior of which solves the problem. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It works very simply. Each ant leaves a trace of ‚Äúpheromones‚Äù in its path. Ants leave one type of pheromone after leaving the anthill and the other when they find food. Food-seeking ants seek to find a trace of a ‚Äúfood‚Äù pheromone, while those seeking anthill seek a trace of a ‚Äúhome‚Äù pheromone.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ants who find themselves on a shorter path are able to faster route from home to food and vice versa. </font><font style="vertical-align: inherit;">This means that they will create a more saturated layer of pheromones. </font><font style="vertical-align: inherit;">Ants moving longer will prefer a richer track and move along a shorter path. </font><font style="vertical-align: inherit;">Each individual ant works according to very simple rules, but over time the ants find a more optimal path between two points.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I wrote my ant simulator on Processing 3. I started my own implementation by simulating the code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from this amazing post by Gregory Brown</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the ants began to move, I began to expand and modify the code so that it works better in larger pixel grids. I wanted to get interesting looking simulations (not necessarily </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">effective</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) and that determined my work on the code. I created a very rudimentary vision for ants so that each ant can see several pixels ahead. I added the death and rebirth of ants so that they do not randomly disperse throughout the space. Finally, I made the ants a little dumber: they leave the pheromone constantly, even if the search was unsuccessful, which is similar to the real behavior of the ants.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can play the simulation port on p5.js right in your browser! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can also take a look at the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ported source code on Github. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Most of all in the simulation, I was fascinated by the beautiful, strange and complex shapes created by ants. </font><font style="vertical-align: inherit;">They do not march in straight lines, but form loops, turns and branches. </font><font style="vertical-align: inherit;">Even more interesting is that you can control the appearance of figures created by ants by changing various variables of their world. </font><font style="vertical-align: inherit;">For example, you can change the pheromone evaporation rate and the range of vision of ants in pixels.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Turn ants into art</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After the simulation began to work, the next step was to study the data it outputs. My goal was to create some kind of two-dimensional image, that is, I needed to capture and draw the figures created by the ants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the end, I wrote different types of output: several types of raster output and one vector. To capture the raster output, I tracked the cells visited by the ants and the frequency of their visits. After playing with the filters of this conclusion, you can get a ghostly trace of those places where the ants visited.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/930/8ca/b029308ca64dee625eccbe87749bfc87.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of raster output. </font><font style="vertical-align: inherit;">The paths are much wider along the popular ant tracks and where the ants randomly roamed around the ant hill. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The raster output was interesting, but I wanted to see the individual paths more clearly, so I explored the possibility of exporting to svg. </font><font style="vertical-align: inherit;">For vector output, I saved the history of each ant, and when they reached food or anthill, I wrote down this story on the list. </font><font style="vertical-align: inherit;">For rendering, I sampled every saved path and rendered it as a series of curves.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/069/397/a81/069397a81dcb254778ab2ce864bab992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An example of vector output. </font><font style="vertical-align: inherit;">Here you can see the individual paths of ants. </font><font style="vertical-align: inherit;">Where there have been many ants, slightly overlapping lines form wider paths.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connect the dots</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I knew that I wanted to draw ants traveling between many points, so the code for linking several simulations into one image was one of the first. But then what should I draw? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At first I decided to create very literal graphs: starting with simple binary trees, then move on to more complex visualizations. This seemed like a natural step, because optimization of the ant colony solves the problem of finding paths in graphs. I also thought that this would be an interesting way to visualize code complexity: why not take a UML diagram or a dependency graph and render them with ants? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I was already familiar with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphviz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , so I decided to use this toolkit and the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOT graph description language</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to specify the nodes and edges of my simulation. </font><font style="vertical-align: inherit;">Graphviz has a mode that outputs a DOT file with annotations of pixel coordinates. </font><font style="vertical-align: inherit;">I wrote a very ugly DOT file parser and used it with an annotated DOT file to simulate anthill and food locations. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The experiments with binary trees seemed promising and gave a very natural, organic appearance.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/971/59e/e53/97159ee533223d92707a989ba83c10c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simple binary tree. </font><font style="vertical-align: inherit;">I was told that it is like an angiogram.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/278/845/f30/278845f30db3fab5dc9085c6261130b7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A slightly more complex tree, already quite deep. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then I began to build more graphs using various code bases as input. </font><font style="vertical-align: inherit;">I wrote some simple Python scripts: one turned the git tree into a DOT file, the other turned C import dependencies into a DOT file.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d41/699/426/d41699426c3cf2e31c97b2ee429dc34b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graph of objects in the git object tree drawn by ants.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/525/30d/81352530da26c9e3cdf334d6909c479e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dependencies between files in the Linux kernel. Nodes and edges were created using the square style of Graphviz graphs. In fact, not much more interesting than random graphs.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Although all these graphs are interesting and definitely complex, I was disappointed that in fact they did not say anything about the general form of the code bases on which they were built. The more I experimented with code visualization, the more I realized that constructing an interesting graph from a code base in itself is a separate, more difficult task. However, I liked the complexity of very large graphs and later I returned to this again. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
My next experiment was games with simple forms. I created graphs from lines, circles, sinusoids, and other shapes that are easy to describe with nodes and edges.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/5f3/287/fab5f32876434586bafc780db2d897d9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The points on the segment, on the right side of the segment, the points are closer to each other.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d5/8e5/ef1/2d58e5ef1de0f74706ee2e47321b94d0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Different sine wave frequencies. </font><font style="vertical-align: inherit;">I suppose a quite good oscilloscope will come out of the ants. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The simplest triangulated spaces seemed to me the most interesting. </font><font style="vertical-align: inherit;">I generated a lot of evenly distributed points ‚Äî either randomly or by drawing shapes ‚Äî and then used the Processing library to turn these points into a Delaunay triangulation or Voronoi diagram. </font><font style="vertical-align: inherit;">Then, the resulting ribs were used to simulate ants, where each rib denoted one ‚Äúant hill‚Äù or ‚Äúfood‚Äù.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Drawn by ants Voronoi diagram.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
This led to the appearance of a beautiful full space of complex ant intricacies, which described the complexity that interests me much better. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finally, I approached the task from another angle. One friend looked at the simulation and asked what would happen when the ants collide with the wall - can they avoid simple obstacles? My code already knew how to handle walls as borderline cases, so I just added internal walls, and then spent a lot of time trying to teach ants how to solve mazes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/803/088/e74803088c3d09ddb1b2b77902004c72.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The paths of ants trying to solve a simple maze. </font><font style="vertical-align: inherit;">You can see the shape of the maze by noticing where the ants cannot go. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I had the idea that if ants can solve simple mazes, then you can combine them together to create a larger work. </font><font style="vertical-align: inherit;">I spent a lot of time setting up the simulation variables so that the ants could solve them, but I still could not get them to solve the mazes stably. </font><font style="vertical-align: inherit;">In the end, all this turned into just curls of ant paths, limited by the shape of the labyrinth itself.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finished work of art</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
At this stage, I decided to take a step back and consider the output of all my experiments. I realized that the most interesting images were obtained from large fields of semi-random points and edges, and decided to make this my final decision by setting up the simulation to draw lines between the Delaunay triangulation of random points.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/09f/a33/3b309fa331b59c059e4b722d4e4c7c10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Completed simulation run. It contains many superimposed paths from which fuzzy spots are obtained.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
The final issue was how to turn SVG bends into finished work. From the experiments, I knew that I wanted to sort the paths in some way to highlight paths with a beautiful shape. But the run of the finished simulation took one to two hours, which is why it was inconvenient to change the variables at each run of the experiment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I decided to write a </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">second</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Processing diagram that will load the simulation output into SVG and then apply the visual effects I need. Moreover, I wanted to make the post-processing script interactive so that I could experiment with different weights and colors of lines, as well as sorting thresholds.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I tried several different ways to evaluate the paths that should be in the foreground and in the background. Several different factors were calculated: the number of self-intersections of the line, the number of intersections by the line of its slope line, and the probability that the line will follow the slope predicted by the previous two points. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I used the post-processing script for experiments with different weights and values ‚Äã‚Äãof these estimates, until I got the look I needed.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/8a0/5e7/6ac8a05e7e250a030461dab605e0770f.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threshold setting for front and background lines.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
At this point, saving the image when changing each variable helped a lot. When I approached the image I needed, it was much easier to compare a number of minor variations than to change several factors at a time. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After a long setup and making small changes, I created the following image from my simulation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/a92/940/781a92940d65d658abfd788b7e0a27db.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I zoomed in on the area that seemed most interesting to me, and cropped it to create a good balance between empty and filled space. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The last step was the choice of how to turn this image into a physical object. I used to print them digitally as a 40 √ó 50 cm poster and attempted (unsuccessfully) to print the screen on color paper. A digitally printed poster looks great, but in the future I want to copy the image as part of the picture. I find complex drawings meditative and I think that I can achieve interesting effects by drawing them manually.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Much more time was spent on this project than I expected, and it turned out to be more complicated than it seemed at the beginning. </font><font style="vertical-align: inherit;">But this is a great way to experiment with all kinds of computational geometry and algorithmic problems. </font><font style="vertical-align: inherit;">I think it's pretty ironic that I wrote several thousand lines of code for work on complexity, but I am pleased that it looks cool and speaks for itself.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en487098/">https://habr.com/ru/post/en487098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487088/index.html">Debug of GSM-scales on Arduino</a></li>
<li><a href="../en487090/index.html">A new level of Windows optimization</a></li>
<li><a href="../en487092/index.html">Modeling business processes as part of an ERP system implementation project</a></li>
<li><a href="../en487094/index.html">Reprocessing events received from Kafka</a></li>
<li><a href="../en487096/index.html">Snippets. How to make the process of working with documentation easier</a></li>
<li><a href="../en487100/index.html">State-of-the-art immutable data structures</a></li>
<li><a href="../en487106/index.html">PVS-Studio analyzer RunUO check</a></li>
<li><a href="../en487108/index.html">Mobile Gamer Profile: MyTracker Research</a></li>
<li><a href="../en487110/index.html">Slurm SRE. A complete experiment with experts from Booking.com and Google.com</a></li>
<li><a href="../en487112/index.html">Edge of Madness: The Basic Circle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>