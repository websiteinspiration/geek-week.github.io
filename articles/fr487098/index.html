<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚼 💘 🧚 Dessiner avec des fourmis: images procédurales utilisant des algorithmes d'optimisation des colonies de fourmis 👨🏼‍🍳 👨🏼‍🎤 🗃️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pourquoi voulais-je dessiner avec des fourmis
 Je voulais créer une œuvre d'art explorant la complexité de la conception de logiciels. Lorsque je prés...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Dessiner avec des fourmis: images procédurales utilisant des algorithmes d'optimisation des colonies de fourmis</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/487098/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi voulais-je dessiner avec des fourmis</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je voulais créer une œuvre d'art explorant la complexité de la conception de logiciels. Lorsque je présente une énorme base de code, je pense à sa complexité indépendante et à ses parties entrelacées et interconnectées. Sa forme générale, pour ainsi dire, résulte des actions de nombreuses personnalités individuelles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je réfléchissais à la façon de présenter cela graphiquement, et l'une des images qui a trouvé une réponse en moi était l'image d'une colonie de fourmis. Les fourmis sont un excellent exemple de complexité émergente (émergente). Aucune fourmi n'est architecte, mais ensemble, ils construisent de magnifiques structures complexes.</font></font><br>
<a name="habracut"></a><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5b1/4f3/a72/5b14f3a72a15eefbeef534448a51647b.jpg"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma de formicaria. Source: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wikimedia Commons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
J'ai commencé par chercher des informations sur les simulations de colonies de fourmis. Évidemment, il y a de la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">littérature à ce sujet, et c'est magnifique</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mais l'astuce était que les fourmilières surgissent en partie en fonction de la physique du sable et de la terre dans laquelle elles sont construites - parce que leur création dépend de la façon dont la particule sera située lorsque la fourmi la déposera. Je voulais créer quelque chose en 2D, j'ai donc essayé d'aller directement à la simulation sans écrire de code de physique du sable, c'est-à-dire que j'ai dû abandonner la simulation physique de la fourmilière. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour cette raison, j'ai recommencé à chercher, et ils m'ont conduit à une </font><font style="vertical-align: inherit;">classe </font><font style="vertical-align: inherit;">complètement </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">différente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de simulations de fourmis:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algorithmes d'optimisation des colonies de fourmis (algorithmes des colonies de fourmis)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'optimisation des colonies de fourmis est un algorithme d'agent utilisé pour résoudre le problème de la recherche du chemin le plus court entre deux points d'un graphique. «Agent» signifie que l'algorithme se compose de procédures distinctes (dans ce cas, «fourmis»), dont le comportement émergent résout le problème. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela fonctionne très simplement. Chaque fourmi laisse une trace de «phéromones» sur son passage. Les fourmis quittent un type de phéromone après avoir quitté la fourmilière et l'autre lorsqu'elles trouvent de la nourriture. Les fourmis à la recherche de nourriture cherchent une trace d'une phéromone «alimentaire», tandis que celles qui recherchent la fourmilière cherchent une trace d'une phéromone «domestique».</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les fourmis qui se trouvent sur un chemin plus court sont en mesure de passer plus rapidement de la maison à la nourriture et vice versa. </font><font style="vertical-align: inherit;">Cela signifie qu'ils créeront une couche de phéromones plus saturée. </font><font style="vertical-align: inherit;">Les fourmis se déplaçant plus longtemps préféreront une piste plus riche et se déplaceront sur un chemin plus court. </font><font style="vertical-align: inherit;">Chaque fourmi individuelle fonctionne selon des règles très simples, mais au fil du temps, les fourmis trouvent un chemin plus optimal entre deux points.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Simulation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai écrit mon simulateur de fourmi sur Processing 3. J'ai commencé ma propre implémentation en simulant le code </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de cet article incroyable de Gregory Brown</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après que les fourmis ont commencé à se déplacer, j'ai commencé à développer et à modifier le code afin qu'il fonctionne mieux dans les grilles de pixels plus grandes. Je voulais obtenir des simulations intéressantes (pas nécessairement </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">efficaces</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et cela a déterminé mon travail sur le code. J'ai créé une vision très rudimentaire pour les fourmis afin que chaque fourmi puisse voir plusieurs pixels devant elle. J'ai ajouté la mort et la renaissance des fourmis afin qu'elles ne se dispersent pas au hasard dans l'espace. Enfin, j'ai rendu les fourmis un peu plus bêtes: elles quittent constamment la phéromone, même si la recherche a échoué, ce qui est similaire au comportement réel des fourmis.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ici,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vous pouvez jouer le port de simulation sur p5.js directement dans votre navigateur! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également jeter un œil au </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code source porté sur Github. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surtout dans la simulation, j'étais fasciné par les formes magnifiques, étranges et complexes créées par les fourmis. </font><font style="vertical-align: inherit;">Ils ne marchent pas en ligne droite, mais forment des boucles, des virages et des branches. </font><font style="vertical-align: inherit;">Encore plus intéressant, vous pouvez contrôler l'apparence des figures créées par les fourmis en modifiant diverses variables de leur monde. </font><font style="vertical-align: inherit;">Par exemple, vous pouvez modifier le taux d'évaporation des phéromones et la portée de vision des fourmis en pixels.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transformez les fourmis en art</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une fois que la simulation a commencé à fonctionner, l'étape suivante a été d'étudier les données qu'elle produit. Mon objectif était de créer une sorte d'image bidimensionnelle, c'est-à-dire que je devais capturer et dessiner les figures créées par les fourmis. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au final, j'ai écrit différents types de sortie: plusieurs types de sortie raster et un vecteur. Pour capturer la sortie raster, j'ai suivi les cellules visitées par les fourmis et la fréquence de leurs visites. Après avoir joué avec les filtres de cette conclusion, vous pouvez obtenir une trace fantomatique des endroits où les fourmis ont visité.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b02/930/8ca/b029308ca64dee625eccbe87749bfc87.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de sortie raster. </font><font style="vertical-align: inherit;">Les sentiers sont beaucoup plus larges le long des pistes de fourmis populaires et où les fourmis ont erré au hasard autour de la colline des fourmis. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La sortie raster était intéressante, mais je voulais voir plus clairement les chemins individuels, j'ai donc exploré la possibilité d'exporter en svg. </font><font style="vertical-align: inherit;">Pour la sortie vectorielle, j'ai sauvegardé l'histoire de chaque fourmi, et quand elles ont atteint la nourriture ou la fourmilière, j'ai écrit cette histoire sur la liste. </font><font style="vertical-align: inherit;">Pour le rendu, j'ai échantillonné chaque chemin enregistré et je l'ai rendu sous la forme d'une série de courbes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/069/397/a81/069397a81dcb254778ab2ce864bab992.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un exemple de sortie vectorielle. </font><font style="vertical-align: inherit;">Ici, vous pouvez voir les chemins individuels des fourmis. </font><font style="vertical-align: inherit;">Là où il y a eu beaucoup de fourmis, les lignes qui se chevauchent légèrement forment des chemins plus larges.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Relier les points</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je savais que je voulais dessiner des fourmis voyageant entre plusieurs points, donc le code pour lier plusieurs simulations en une seule image était l'un des premiers. Mais alors, que dois-je dessiner? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au début, j'ai décidé de créer des graphes très littéraux: en commençant par des arbres binaires simples, puis en passant à des visualisations plus complexes. Cela semblait être une étape naturelle, car l'optimisation de la colonie de fourmis résout le problème de la recherche de chemins dans les graphiques. J'ai aussi pensé que ce serait une façon intéressante de visualiser la complexité du code: pourquoi ne pas prendre un diagramme UML ou un graphe de dépendances et les rendre avec des fourmis? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je connaissais déjà </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Graphviz</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , j'ai donc décidé d'utiliser cette boîte à outils et le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">langage de description des graphiques DOT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour spécifier les nœuds et les bords de ma simulation. </font><font style="vertical-align: inherit;">Graphviz dispose d'un mode qui génère un fichier DOT avec des annotations de coordonnées de pixels. </font><font style="vertical-align: inherit;">J'ai écrit un analyseur de fichiers DOT très laid et je l'ai utilisé avec un fichier DOT annoté pour simuler des emplacements de fourmilière et de nourriture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les expériences avec des arbres binaires semblaient prometteuses et donnaient un aspect organique très naturel.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/971/59e/e53/97159ee533223d92707a989ba83c10c3.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un arbre binaire simple. </font><font style="vertical-align: inherit;">On m'a dit que c'est comme une angiographie.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/278/845/f30/278845f30db3fab5dc9085c6261130b7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un arbre un peu plus complexe, déjà assez profond. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, j'ai commencé à construire plus de graphiques en utilisant différentes bases de code en entrée. </font><font style="vertical-align: inherit;">J'ai écrit quelques scripts Python simples: l'un a transformé l'arbre git en un fichier DOT, l'autre a transformé les dépendances d'importation C en un fichier DOT.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d41/699/426/d41699426c3cf2e31c97b2ee429dc34b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Graphique des objets dans l'arbre d'objets git dessiné par des fourmis.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/813/525/30d/81352530da26c9e3cdf334d6909c479e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dépendances entre les fichiers du noyau Linux. Les nœuds et les bords ont été créés en utilisant le style carré des graphiques Graphviz. En fait, pas beaucoup plus intéressant que les graphiques aléatoires.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Bien que tous ces graphiques soient intéressants et définitivement complexes, j'ai été déçu qu'en fait ils n'aient rien dit sur la forme générale des bases de code sur lesquelles ils ont été construits. Plus j'expérimentais la visualisation de code, plus je réalisais que la construction d'un graphique intéressant à partir d'une base de code en soi était une tâche distincte et plus difficile. Cependant, j'ai aimé la complexité des très grands graphiques et plus tard, j'y suis retourné. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ma prochaine expérience était des jeux avec des formes simples. J'ai créé des graphiques à partir de lignes, de cercles, de sinusoïdes et d'autres formes faciles à décrire avec des nœuds et des bords.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fab/5f3/287/fab5f32876434586bafc780db2d897d9.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les points sur le segment, sur le côté droit du segment, les points sont plus proches les uns des autres.</font></font></i><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d5/8e5/ef1/2d58e5ef1de0f74706ee2e47321b94d0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Différentes fréquences d'onde sinusoïdale. </font><font style="vertical-align: inherit;">Je suppose qu'un assez bon oscilloscope sortira des fourmis. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les espaces triangulés les plus simples me semblaient les plus intéressants. </font><font style="vertical-align: inherit;">J'ai généré de nombreux points uniformément répartis - soit au hasard, soit en dessinant des formes - puis j'ai utilisé la bibliothèque de traitement pour transformer ces points en triangulation de Delaunay ou en diagramme de Voronoi. </font><font style="vertical-align: inherit;">Ensuite, les côtes résultantes ont été utilisées pour simuler des fourmis, chaque côte désignant une «fourmilière» ou «nourriture».</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/59e/d31/366/59ed31366bcf08b906a07e476152a66c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessiné par les fourmis diagramme Voronoi.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Cela a conduit à l'apparition d'un bel espace plein de subtilités complexes de fourmis, qui décrivait la complexité qui m'intéresse beaucoup mieux. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enfin, j'ai abordé la tâche sous un autre angle. Un ami a regardé la simulation et a demandé ce qui se passerait lorsque les fourmis entreraient en collision avec le mur - peuvent-elles éviter de simples obstacles? Mon code savait déjà comment gérer les murs comme des cas limites, alors j'ai simplement ajouté des murs internes, puis j'ai passé beaucoup de temps à essayer d'enseigner aux fourmis comment résoudre les labyrinthes.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e74/803/088/e74803088c3d09ddb1b2b77902004c72.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les chemins des fourmis essayant de résoudre un labyrinthe simple. </font><font style="vertical-align: inherit;">Vous pouvez voir la forme du labyrinthe en remarquant où les fourmis ne peuvent pas aller. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai eu l'idée que si les fourmis peuvent résoudre des labyrinthes simples, alors vous pouvez les combiner ensemble pour créer une œuvre plus grande. </font><font style="vertical-align: inherit;">J'ai passé beaucoup de temps à configurer les variables de simulation afin que les fourmis puissent les résoudre, mais je n'arrivais toujours pas à les faire résoudre les labyrinthes de manière stable. </font><font style="vertical-align: inherit;">En fin de compte, tout cela s'est transformé en de simples boucles de chemins de fourmis, limitées par la forme du labyrinthe lui-même.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oeuvre d'art finie</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À ce stade, j'ai décidé de prendre du recul et de considérer le résultat de toutes mes expériences. J'ai réalisé que les images les plus intéressantes étaient obtenues à partir de grands champs de points et de bords semi-aléatoires, et j'ai décidé d'en faire ma décision finale en configurant la simulation pour tracer des lignes entre la triangulation de Delaunay des points aléatoires.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b3/09f/a33/3b309fa331b59c059e4b722d4e4c7c10.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cycle de simulation terminé. Il contient de nombreux chemins superposés à partir desquels des points flous sont obtenus.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Le dernier problème était de savoir comment transformer les virages SVG en travail fini. D'après les expériences, je savais que je voulais trier les chemins d'une certaine manière pour mettre en évidence les chemins avec une belle forme. Mais l'exécution de la simulation terminée a pris une à deux heures, c'est pourquoi il n'était pas pratique de modifier les variables à chaque exécution de l'expérience. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai décidé d'écrire un </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deuxième</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diagramme de traitement qui chargera la sortie de simulation dans SVG, puis appliquera les effets visuels dont j'ai besoin. De plus, je voulais rendre le script de post-traitement interactif afin de pouvoir expérimenter différents poids et couleurs de lignes, ainsi que des seuils de tri.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai essayé plusieurs façons d'évaluer les chemins qui devraient être au premier plan et en arrière-plan. Plusieurs facteurs différents ont été calculés: le nombre d'auto-intersections de la ligne, le nombre d'intersections par la ligne de sa ligne de pente et la probabilité que la ligne suive la pente prédite par les deux points précédents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai utilisé le script de post-traitement pour des expériences avec différents poids et valeurs de ces estimations, jusqu'à ce que j'obtienne l'apparence dont j'avais besoin.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ac/8a0/5e7/6ac8a05e7e250a030461dab605e0770f.gif"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réglage du seuil pour les lignes avant et arrière-plan.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
À ce stade, l'enregistrement de l'image lors du changement de chaque variable a beaucoup aidé. Lorsque j'ai approché l'image dont j'avais besoin, il était beaucoup plus facile de comparer un certain nombre de variations mineures que de changer plusieurs facteurs à la fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après une longue configuration et de petits changements, j'ai créé l'image suivante à partir de ma simulation:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/a92/940/781a92940d65d658abfd788b7e0a27db.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'ai zoomé sur la zone qui me semblait la plus intéressante et l'ai recadrée pour créer un bon équilibre entre l'espace vide et l'espace rempli. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La dernière étape a été le choix de la manière de transformer cette image en objet physique. Je les imprimais numériquement sous forme d'affiche de 40 × 50 cm et tentais (sans succès) d'imprimer l'écran sur du papier couleur. Une affiche imprimée numériquement a fière allure, mais à l'avenir, je veux copier l'image en tant que partie de l'image. Je trouve les dessins complexes méditatifs et je pense que je peux obtenir des effets intéressants en les dessinant manuellement.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup plus de temps a été consacré à ce projet que ce à quoi je m'attendais, et il s'est avéré plus compliqué qu'il n'y paraissait au début. </font><font style="vertical-align: inherit;">Mais c'est un excellent moyen d'expérimenter toutes sortes de problèmes de géométrie de calcul et d'algorithmes. </font><font style="vertical-align: inherit;">Je pense que c'est assez ironique d'avoir écrit plusieurs milliers de lignes de code pour travailler sur la complexité, mais je suis heureux que cela ait l'air cool et parle de lui-même.</font></font></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr487088/index.html">Débogage des échelles GSM sur Arduino</a></li>
<li><a href="../fr487090/index.html">Un nouveau niveau d'optimisation Windows</a></li>
<li><a href="../fr487092/index.html">Modélisation des processus métiers dans le cadre d'un projet d'implémentation d'un système ERP</a></li>
<li><a href="../fr487094/index.html">Événements de retraitement reçus de Kafka</a></li>
<li><a href="../fr487096/index.html">Extraits. Comment faciliter le processus de travail avec la documentation</a></li>
<li><a href="../fr487100/index.html">Structures de données immuables à la pointe de la technologie</a></li>
<li><a href="../fr487106/index.html">Contrôle RunUO de l'analyseur PVS-Studio</a></li>
<li><a href="../fr487108/index.html">Profil de joueur mobile: recherche MyTracker</a></li>
<li><a href="../fr487110/index.html">Slurm SRE. Une expérience complète avec des experts de Booking.com et de Google.com</a></li>
<li><a href="../fr487112/index.html">Edge of Madness: The Basic Circle</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>