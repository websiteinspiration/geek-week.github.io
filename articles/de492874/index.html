<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧜🏿 🥐 🖋️ Rendering-Optimierung für Mobile 👇🏾 👈🏽 😤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo liebe Leser, Liebhaber und Profis der Programmiergrafik! Wir machen Sie auf eine Reihe von Artikeln aufmerksam, die sich mit der Optimierung des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Rendering-Optimierung für Mobile</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/492874/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo liebe Leser, Liebhaber und Profis der Programmiergrafik! Wir machen Sie auf eine Reihe von Artikeln aufmerksam, die sich mit der Optimierung des Renderings für mobile Geräte befassen: Telefone und Tablets auf Basis von iOS und Android. Der Zyklus besteht aus drei Teilen. Im ersten Teil werden wir die Funktionen der beliebten </font><font style="vertical-align: inherit;">GPU- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kachelarchitektur</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Mobile untersuchen </font><font style="vertical-align: inherit;">. Im zweiten Teil werden wir die Hauptfamilien von GPUs betrachten, die in modernen Geräten vorgestellt werden, und ihre Stärken und Schwächen betrachten. Im dritten Teil werden wir uns mit den Funktionen der Shader-Optimierung vertraut machen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kommen wir also zum ersten Teil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Entwicklung von Grafikkarten auf Desktops und Konsolen erfolgte ohne wesentliche Einschränkungen des Stromverbrauchs. Mit dem Aufkommen von Grafikkarten für mobile Geräte standen die Ingenieure vor der Aufgabe, eine akzeptable Leistung bei vergleichbaren Desktop-Auflösungen sicherzustellen, während der Stromverbrauch solcher Grafikkarten um 2 Größenordnungen niedriger sein sollte.&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/51e/4fa/969/51e4fa969a3e5ede3b31064499c33226.png"></div><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Lösung wurde in einer speziellen Architektur namens </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tile Based Rendering (TBR) gefunden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Für einen Grafikprogrammierer mit Erfahrung in der PC-Entwicklung scheint alles bekannt zu sein, wenn er sich mit der mobilen Entwicklung vertraut macht: Es wird eine ähnliche OpenGL ES-API verwendet, dieselbe Struktur wie die Grafikpipeline. Die Kachelarchitektur mobiler GPUs unterscheidet sich jedoch erheblich von der auf PC / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediate Mode-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konsolen verwendeten </font><font style="vertical-align: inherit;">. Wenn Sie die Stärken und Schwächen von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TBR kennen,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie die richtigen Entscheidungen treffen und mit Mobile eine hervorragende Leistung erzielen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unten sehen Sie ein vereinfachtes Diagramm einer klassischen Grafikpipeline, die im dritten Jahrzehnt auf PCs und Konsolen verwendet wurde.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/281/67b/5e2/28167b5e2eaa4746ebd1ed45f8aa2dfb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In der Geometrieverarbeitungsphase werden die Scheitelpunktattribute aus dem GPU-Videospeicher gelesen. Nach verschiedenen Transformationen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Vertex Shader) werden renderfertige Grundelemente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der ursprünglichen Reihenfolge (FIFO) an den Rasterisierer übergeben, der die Grundelemente in Pixel unterteilt. Danach wird die Fragmentverarbeitungsstufe jedes Pixels </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Fragment Shader)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ausgeführt </font><font style="vertical-align: inherit;">, und die erhaltenen Farbwerte werden in den Bildschirmpuffer geschrieben, der sich ebenfalls im Videospeicher befindet. Ein Merkmal der traditionellen Architektur des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">„Sofortmodus“</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Aufzeichnung des Ergebnisses des Fragment-Shaders in beliebigen Abschnitten des Bildschirmpuffers bei der Verarbeitung eines einzelnen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zeichnungsaufrufs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Daher kann für jeden Ziehungsaufruf der Zugriff auf den gesamten Bildschirmpuffer erforderlich sein. Das Arbeiten mit einem großen Speicherarray erfordert eine geeignete </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Busbandbreite</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><b><font style="vertical-align: inherit;">Bandbreite</font></b><font style="vertical-align: inherit;"> ) und ist mit einem hohen Stromverbrauch verbunden. Daher verfolgten mobile </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPUs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einen anderen Ansatz. Bei der für mobile Grafikkarten typischen Kachelarchitektur erfolgt das Rendern in einem kleinen Speicher, der dem Teil des Bildschirms entspricht - der Kachel. Die geringe Größe der Kachel (z. B. 16 x 16 Pixel für Mali-Grafikkarten, 32 x 32 Pixel für PowerVR) ermöglicht es Ihnen, sie direkt auf dem Grafikkartenchip zu platzieren, wodurch die Zugriffsgeschwindigkeit mit der Zugriffsgeschwindigkeit auf die Shader-Kernregister vergleichbar wird, d. H. sehr schnell.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86d/7bf/c65/86d7bfc65e53739ab9be0d5ea1242c0e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da Grundelemente jedoch in beliebige Abschnitte des Bildschirmpuffers fallen können und eine Kachel nur einen kleinen Teil davon abdeckt, war ein zusätzlicher Schritt in der Grafikpipeline erforderlich. </font><font style="vertical-align: inherit;">Das folgende Diagramm zeigt vereinfacht, wie die Pipeline mit der Kachelarchitektur funktioniert.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/531/ea5/00c/531ea500c507eb47558676582e20c94c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach der Verarbeitung der Eckpunkte und der Konstruktion der Grundelemente fallen letztere, anstatt an die Fragment-Pipeline gesendet zu werden, in den sogenannten </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Hier sind die Grundelemente durch Kacheln verteilt, in deren Pixel sie fallen. </font><font style="vertical-align: inherit;">Nach einer solchen Verteilung, die in der Regel alle Zeichnungsaufrufe abdeckt, die an ein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Frame Buffer Object</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (auch als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Render Target bezeichnet</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) gerichtet sind, werden die Kacheln nacheinander gerendert. </font><font style="vertical-align: inherit;">Für jede Kachel wird die folgende Abfolge von Aktionen ausgeführt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden alter </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalte </font><font style="vertical-align: inherit;">aus dem Systemspeicher ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Laden</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&nbsp;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Darstellung von Primitiven, die in diese Kachel fallen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hochladen neuer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inhalte </font><font style="vertical-align: inherit;">in den Systemspeicher ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Store</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ea/20b/74b/9ea20b74b9fb716af30d5e0fa4ee1b34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist zu beachten, dass die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ladeoperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> als zusätzliche Überlagerung der "Vollbildtextur" ohne Komprimierung betrachtet werden kann. </font><font style="vertical-align: inherit;">Vermeiden Sie nach Möglichkeit diesen Vorgang, d. H. </font><font style="vertical-align: inherit;">Lassen Sie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht </font><font style="vertical-align: inherit;">hin und her </font><font style="vertical-align: inherit;">wechseln </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn </font><font style="vertical-align: inherit;">alle Inhalte </font><font style="vertical-align: inherit;">vor dem Rendern in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gelöscht wurden, wird der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ladevorgang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht ausgeführt. </font><font style="vertical-align: inherit;">Um jedoch das richtige Signal an den Fahrer zu senden, müssen die Parameter einer solchen Reinigung bestimmte Kriterien erfüllen:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Muss deaktiviert sein </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scissor Rect</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Aufnahme in allen Farbkanälen und Alpha sollte erlaubt sein.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ladevorgang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für den Tiefenpuffer und die Schablone zu verhindern, müssen diese vor Beginn des Renderns gereinigt werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es ist auch möglich, den </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speichervorgang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für den Tiefen- / Schablonenpuffer </font><font style="vertical-align: inherit;">zu vermeiden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Schließlich wird der Inhalt dieser Puffer in keiner Weise auf dem Bildschirm angezeigt. </font><font style="vertical-align: inherit;">Vor dem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glSwapBuffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Betrieb, </font><b><font style="vertical-align: inherit;">Sie</font></b><font style="vertical-align: inherit;"> können anrufen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glDiscardFramebufferEXT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glInvalidateFramebuffer</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glDiscardFramebufferEXT (GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> GLenum attachments[] = {GL_DEPTH_ATTACHMENT, GL_STENCIL_ATTACHMENT};<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, attachments);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt Rendering-Szenarien, in denen die Platzierung von Tiefen- / Schablonenpuffern sowie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Puffern im Systemspeicher nicht erforderlich ist. Wenn beispielsweise das Rendern im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem Tiefenpuffer kontinuierlich ist und die Tiefeninformationen aus dem vorherigen Frame nicht verwendet werden, muss der Tiefenpuffer vor dem Beginn des Renderns nicht in den Kachelspeicher geladen oder nach Abschluss des Renderns entladen werden. Daher kann der Systemspeicher nicht unter dem Tiefenpuffer zugeordnet werden. Mit modernen Grafik-APIs wie </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie den Speichermodus für Ihre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Gegenstücke explizit festlegen </font><font style="vertical-align: inherit;"> &nbsp;( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MTLStorageModeMemoryless</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metal, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT +</font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Besonders hervorzuheben ist die Implementierung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auf Kachelarchitekturen. Der hochauflösende Puffer für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verlässt </font><font style="vertical-align: inherit;">den </font><b><font style="vertical-align: inherit;">Kachelspeicher</font></b><font style="vertical-align: inherit;"> nicht, indem der </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in mehrere Kacheln aufgeteilt wird. Beispielsweise werden für </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA 2x2 </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16x16-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kacheln </font><font style="vertical-align: inherit;">während des </font><b><font style="vertical-align: inherit;">Speichervorgangs</font></b><font style="vertical-align: inherit;"> als </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8x8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgelöst </font><font style="vertical-align: inherit;">, d. H. Insgesamt müssen viermal mehr Kacheln verarbeitet werden. Zusätzlicher Speicher für </font><b><font style="vertical-align: inherit;">MSAA ist jedoch</font></b><font style="vertical-align: inherit;"> nicht erforderlich, und aufgrund des Renderns im schnellen Kachelspeicher gibt es keine signifikanten </font><b><font style="vertical-align: inherit;">Bandbreitenbeschränkungen.</font></b><font style="vertical-align: inherit;"> Verwenden Sie jedoch</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MSAA</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die Kachelarchitektur erhöht die Belastung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiler,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> was sich negativ auf die Renderleistung von Szenen mit viel Geometrie auswirken kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend stellen wir das gewünschte Schema für die Arbeit mit FBO an der Kachelarchitektur vor:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// 1.   ,    auxFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);<font></font>
glDepthMask(GL_TRUE);<font></font>
<span class="hljs-comment">// glClear,     </span><font></font>
glClear(GL_COLOR_BUFFER_BIT |&nbsp;GL_DEPTH_BUFFER_BIT |&nbsp;<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GL_STENCIL_BUFFER_BIT);<font></font>
<font></font>
renderAuxFBO();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font></font>
<font></font>
<span class="hljs-comment">//   /      </span>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
<span class="hljs-comment">// 2.   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
glDisable(GL_SCISSOR);<font></font>
<font></font>
glClear(...);<font></font>
<span class="hljs-comment">//   mainFBO    auxFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
<font></font>
glInvalidateFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">2</span>, depth_and_stencil);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie </font><font style="vertical-align: inherit;">mitten in der </font><b><font style="vertical-align: inherit;">MainFBO-</font></b><font style="vertical-align: inherit;"> Formation </font><font style="vertical-align: inherit;">zum </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AuxFBO-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rendering wechseln </font><font style="vertical-align: inherit;">, können unnötige </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lade- </font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und Speicheroperationen auftreten</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die die Frame-Formationszeit erheblich verlängern können. </font><font style="vertical-align: inherit;">In unserer Praxis haben wir eine Verlangsamung beim Rendern festgestellt, selbst im Fall von FBO-Einstellungen im Leerlauf, d. H. </font><font style="vertical-align: inherit;">ohne den tatsächlichen Render in ihnen. </font><font style="vertical-align: inherit;">Aufgrund der Architektur des Motors sah unsere alte Schaltung folgendermaßen aus:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//   mainFBO</span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   </span><font></font>
glBindFramebuffer(GL_FRAMEBUFFER, auxFBO);<font></font>
<span class="hljs-comment">//  auxFBO</span><font></font>
renderAuxFBO();<font></font>
<font></font>
glBindFramebuffer(GL_FRAMEBUFFER, mainFBO);<font></font>
<span class="hljs-comment">//   mainFBO</span><font></font>
renderMainFBO(auxFBO);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Trotz des Fehlens von gl-Aufrufen nach der ersten Installation von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mainFBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben wir auf einigen Geräten zusätzliche </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Load &amp; Store-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vorgänge und eine schlechtere Leistung erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um unser Verständnis des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Overheads</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch die Verwendung von Zwischen- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu verbessern </font><font style="vertical-align: inherit;">, haben wir den Zeitverlust für das Umschalten von Vollbild- </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBOs</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mithilfe eines synthetischen Tests gemessen. Die Tabelle zeigt die Zeit, die für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Speicheroperation</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aufgewendet wurde, </font><font style="vertical-align: inherit;">wenn </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FBO</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mehrmals </font><font style="vertical-align: inherit;">in einem Frame </font><font style="vertical-align: inherit;">gewechselt </font><font style="vertical-align: inherit;">wurde (die Zeit für eine solche Operation ist angegeben). </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lastbetrieb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fehlt aufgrund </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glClear</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d.h. </font><font style="vertical-align: inherit;">ein günstigeres Szenario wurde gemessen. </font><font style="vertical-align: inherit;">Die auf dem Gerät verwendete Berechtigung trug dazu bei. </font><font style="vertical-align: inherit;">Es könnte mehr oder weniger der Leistung der installierten GPU entsprechen. </font><font style="vertical-align: inherit;">Daher geben diese Zahlen nur einen allgemeinen Überblick darüber, wie teuer das Umschalten von Zielen auf mobilen Grafikkarten verschiedener Generationen ist.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Millisekunden</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPU</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Millisekunden</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 320</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5.2</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 512</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,74</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR G6200</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.3</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 615</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,7</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-400</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.2</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adreno 530</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,4</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t720</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.9</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-g51</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,32</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PowerVR SXG 544</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mali-t830</font></font><br>
</td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0,15</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Basierend auf den erhaltenen Daten können wir zu der Empfehlung kommen, nicht mehr als einen oder zwei FBO-Schalter pro Frame zu verwenden, zumindest für ältere Grafikkarten. Wenn das Spiel einen separaten Code-Pass für Low-End-Geräte hat, ist es ratsam, die FBO-Änderung dort nicht zu verwenden. Im Low-End-Bereich wird jedoch häufig das Problem der Verringerung der Auflösung relevant. Unter Android können Sie die </font><b><font style="vertical-align: inherit;">Renderauflösung verringern,</font></b><font style="vertical-align: inherit;"> ohne auf einen Zwischen-FBO zurückgreifen zu müssen, indem Sie </font><b><font style="vertical-align: inherit;">SurfaceHolder.setFixedSize ()</font></b><font style="vertical-align: inherit;"> aufrufen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font></b><br>
<br>
<pre><code class="java hljs">surfaceView.getHolder().setFixedSize(...)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Methode funktioniert nicht, wenn das Spiel über die Hauptanwendung </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Surface</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gerendert wird </font><font style="vertical-align: inherit;">(ein typisches Schema für die Arbeit mit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Wenn Sie die Hauptoberfläche verwenden </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> können Sie eine niedrigere Auflösung festlegen, indem Sie die native Funktion </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ANativeWindow_setBuffersGeometry aufrufen.</font></font></b><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">JNIEXPORT <span class="hljs-keyword">void</span> JNICALL <span class="hljs-title">Java_com_organization_app_AppNativeActivity_setBufferGeometry</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jobject surface, jint width, jint height)</span>
</span>{<font></font>
ANativeWindow* window = ANativeWindow_fromSurface(env, surface);&nbsp;<font></font>
ANativeWindow_setBuffersGeometry(window, width, height, AHARDWAREBUFFER_FORMAT_R8G8B8X8_UNORM);&nbsp;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Java:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBufferGeometry</span><span class="hljs-params">(Surface surface, <span class="hljs-keyword">int</span> width , <span class="hljs-keyword">int</span> height )</span></span>;&nbsp;<font></font>
...<font></font>
<span class="hljs-comment">//   SurfaceHolder.Callback</span>
<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">surfaceChanged</span><span class="hljs-params">(SurfaceHolder holder, <span class="hljs-keyword">int</span> format, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span>
</span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setBufferGeometry(holder.getSurface(), <span class="hljs-number">768</span>, <span class="hljs-number">1366</span>); <span class="hljs-comment">/* ... */</span>
...</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schließlich erwähnen wir den praktischen ADB-Befehl zum Steuern ausgewählter Oberflächenpuffer unter Android:</font></font><br>
<br>
<pre><code class="plaintext hljs">adb shell dumpsys surfaceflinger
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie können eine ähnliche Schlussfolgerung ziehen, mit der Sie den Speicherverbrauch für Oberflächenpuffer abschätzen können:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/524/2fe/ea6/5242feea615abe186c6c3538c9d60565.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Abbildung zeigt das System hervorgehoben 3 Puffer für triple Pufferung des </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GLSurfaceView</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spiel (gelb markiert), sowie 2 - </font><font style="vertical-align: inherit;">Puffer für die </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hauptfläche</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (rot markiert). </font><font style="vertical-align: inherit;">Beim Rendern über die Hauptoberfläche, die bei Verwendung von </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NativeActivity</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> das Standardschema ist </font><font style="vertical-align: inherit;">, kann die Zuweisung zusätzlicher Puffer vermieden werden.&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das ist alles für jetzt. </font><font style="vertical-align: inherit;">In den folgenden Artikeln werden wir mobile GPUs klassifizieren und Methoden zur Optimierung von Shadern für sie analysieren.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de492862/index.html">Die 15 besten Tipps zur Optimierung der Oracle APEX-Leistung für Entwickler</a></li>
<li><a href="../de492864/index.html">Kann ich ein Schiff hacken?</a></li>
<li><a href="../de492866/index.html">Das Buch "Maschinelles Lernen ohne Worte"</a></li>
<li><a href="../de492868/index.html">Zeichenfolgenoptimierung in ClickHouse. Yandex-Bericht</a></li>
<li><a href="../de492872/index.html">So organisieren Sie den Fernzugriff und leiden nicht unter Hackern</a></li>
<li><a href="../de492878/index.html">Geek-Hausschuhe: Auf der Suche nach positiven Ergebnissen bei vorübergehenden Büroschließungen</a></li>
<li><a href="../de492880/index.html">Was sollen wir ein Smart Home bauen?</a></li>
<li><a href="../de492884/index.html">Empfangen von Nachrichten von YouTube-Sendungen + Google-Autorisierung in PHP</a></li>
<li><a href="../de492886/index.html">Rezept für Massenrekrutierungstester</a></li>
<li><a href="../de492888/index.html">Warum sollten Sie WireGuard nicht verwenden?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>