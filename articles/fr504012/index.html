<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🎓 🏦 💪🏿 Inverser le tri 🔌 🚵 🔙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Un programmeur indien montre clairement Zig-Zag, Zig-Zig et Zig utilisés dans l'algorithme SplaySort:
 
 
 Cette saison, nous explorons une variété de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Inverser le tri</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/504012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Un programmeur indien montre clairement Zig-Zag, Zig-Zig et Zig utilisés dans l'algorithme SplaySort:</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img width="780" height="590" src="https://habrastorage.org/webt/0j/qa/l0/0jqal0merugvc0u93nolsk_l0i0.jpeg"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cette saison, nous explorons une </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variété de tas et comment ils peuvent être utilisés pour le tri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cependant, cette fois, nous nous éloignerons du thème principal. </font><font style="vertical-align: inherit;">La structure d'aujourd'hui - l'arbre splay - n'est pas un groupe. </font><font style="vertical-align: inherit;">Mais nous en avons besoin pour préparer mentalement l'étude de la prochaine pile - la semaine prochaine, il y aura une conférence sur le tri par arbre cartésien.</font></font><a name="habracut"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="Logiciel EDISON - développement web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="Logiciel EDISON - développement web"></a><br clear="right"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cet article a été préparé avec le soutien d'EDISON. </font><font style="vertical-align: inherit;">
L'une des directions de notre activité est l' </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;">automatisation des mesures et des systèmes experts</font></a><font style="vertical-align: inherit;"> , grâce à laquelle nous réalisons des projets de haute technologie selon une approche scientifique stricte. </font><font style="vertical-align: inherit;">
Nous aimons l'informatique! </font><font style="vertical-align: inherit;">;-)</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img align="right" width="340" height="228" src="https://habrastorage.org/webt/y8/hs/tt/y8hsttfexnxawirmy1ysw7rg-3q.png"></a><br clear="left"><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"></font><div style="text-align:center;"><img width="770" height="1" src="https://habrastorage.org/webt/mw/wy/cu/mwwycuqpta7m96dxifyx9if7mu8.gif"></div></blockquote><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri d'arbre de recherche binaire</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'arbre Splay est un arbre de recherche binaire amélioré. </font><font style="vertical-align: inherit;">Tout d'abord, rappelons-nous comment trier en utilisant l'arbre binaire «non amélioré» habituel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous le savez bien, dans un arbre binaire, tout enfant gauche est inférieur au parent, tout enfant droit n'est pas moins (c'est-à-dire supérieur ou égal) que le parent.</font></font><br>
<br>
<div style="text-align:center;"><img width="760" height="511" src="https://habrastorage.org/webt/2e/ie/2b/2eie2b53zaztn8ixd0wgqf5hlqu.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tri est généralement simple:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Étape 1. En fonction du tableau, créez un arbre de recherche binaire. </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous plaçons le premier élément du tableau à la racine, comparons d'abord les éléments restants avec la racine, puis, selon la comparaison, descendons les branches gauche ou droite (et en cours de route, nous comparons l'élément du tableau avec les nœuds d'arbre existants). </font><font style="vertical-align: inherit;">En fin de compte, l'élément suivant atteint la fin d'une branche et devient un nœud lui-même.</font></font></li>
<li><b> 2.         .</b>   ,      (    ,       )            .          .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La construction d'un arbre est tout à fait tolérable en termes de complexité algorithmique - en moyenne, l'insertion d'un nouveau nœud coûte </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , donc la complexité temporelle de la première étape est </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais dans la deuxième étape, tout n'est pas si rose. </font><font style="vertical-align: inherit;">Une promenade dans les arbres récursive peut facilement devenir un long voyage à travers un labyrinthe extrêmement sinueux, et la complexité temporelle se dégrade souvent en </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n </font></font></b><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbre Splay</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour résoudre ce problème, il y a seulement 35 à 37 ans, deux scientifiques, Robert Tarjan et Daniel Slitor, ont développé cette structure arborescente. Ils ont suggéré que pour toutes les opérations (insérer, rechercher, supprimer) avec n'importe quel nœud d'arbre, rééquilibrer immédiatement l'arbre, faisant du nœud la racine de la structure entière.</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><div style="text-align:center;"><img width="780" height="313" src="https://habrastorage.org/webt/8s/vj/ac/8svjacb-n4jgxpjbbaxjv-fh-h0.jpeg"></div></a><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sur la photo de gauche, Robert Tarjan (première rangée, deuxième à droite) en compagnie de l'architecte Matrix et inventeur de Pascal. </font><font style="vertical-align: inherit;">Sur la photo de droite, Daniel Slitor. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cliquer sur l'image ouvrira une version plein format. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En russe, le nom infructueux "arbre en expansion" est resté, moins souvent - "arbre oblique". </font><font style="vertical-align: inherit;">Bien que s'il était simplement traduit littéralement, alors «l'arbre développé» (ou, mieux encore, «tourné») sonne bien et reflète plus précisément l'essence de cette structure algorithmique. </font><font style="vertical-align: inherit;">Mais ça l'est. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de pousser le nœud à la racine, des opérations simples spéciales sont utilisées, les soi-disant tours:</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zig Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si l'élément que vous souhaitez créer est situé au deuxième niveau d'imbrication, tout est extrêmement simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On note cet élément comme </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et son parent (qui est aussi la racine de l'arbre) - comme </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des sous-arbres. Combien y at - </font><font style="vertical-align: inherit;">il dans ces nœuds sous - </font><font style="vertical-align: inherit;">arbres n'a pas d' </font><font style="vertical-align: inherit;">importance, seule intéressés par les racines de ces sous - </font><font style="vertical-align: inherit;">arbres qui ont des </font><font style="vertical-align: inherit;">relations « -parents et </font><font style="vertical-align: inherit;">enfants » avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Si l'un des sous-arbres est manquant (c'est-à-dire si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'ont pas de descendants), cela n'affecte pas l'ordre des actions.</font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/v3/kg/i0/v3kgi01dbf_nluirdgnsaylmn6y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour faire de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X la</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> racine de l'arbre, vous devez inverser la relation parent-enfant entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et l'emporter également sur le sous </font><font style="vertical-align: inherit;">- </font><font style="vertical-align: inherit;">arbre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - c'était le descendant droit de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , est devenu le descendant gauche de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font><font style="vertical-align: inherit;">vous n'avez rien à faire </font><font style="vertical-align: inherit;">avec </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Et c'est tout! </font><font style="vertical-align: inherit;">À la suite de ces manipulations simples, la structure, comme c'était un arbre de recherche binaire, est restée ainsi - le principe «l'enfant gauche est inférieur au parent, l'enfant droit est supérieur ou égal au parent» ne sera pas violé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'image précédente </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un descendant gauche de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> était un bon descendant, il suffit de refléter la situation: </font></font><br>
<br>
<div style="text-align:center;"><img width="450" height="208" src="https://habrastorage.org/webt/em/n6/z9/emn6z9kik0em1i03xpc5k7egrkq.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n'a pas le deuxième niveau de difficulté, mais le troisième, alors tout est plus compliqué, mais pas beaucoup. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a un parent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui à son tour a un parent </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , alors nous n'avons que deux situations différentes: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1) si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendant</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P </font></font></b><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">du même côté</font></i><font style="vertical-align: inherit;"> que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2) si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">descendants polyvalents</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour leurs parents. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérons d'abord le premier cas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZigZig Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soit </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> le descendant gauche pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descendant gauche pour </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (l'option lorsque </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont simultanément descendants droits est résolue de la même manière).</font></font><br>
<br>
<div style="text-align:center;"><img width="770" height="251" src="https://habrastorage.org/webt/sh/f3/ev/shf3evyiypukr9y08kvtiidhrvy.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le </font><font style="vertical-align: inherit;">voir, il est nécessaire de changer la relation entre </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ainsi que compenser correctement les </font><font style="vertical-align: inherit;">sous - </font><font style="vertical-align: inherit;">arbres </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et notre arbre de recherche binaire n'en souffrira pas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ZigZag Turn</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X est le</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> descendant droit, et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gauche (ou </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gauche, et </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">P est</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> droit, pas l'essence), alors j'espère que vous avez déjà tout compris de cette image:</font></font><br>
<br>
<div style="text-align:center;"><img width="642" height="251" src="https://habrastorage.org/webt/rz/v1/p2/rzv1p25jwly-sz6lrv_o2alzlyc.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans l'arbre est toujours à un niveau d'imbrication inférieur, alors pour le relever, vous devez appliquer ZigZig ou ZigZag (si nécessaire, faites-le plusieurs fois) à ce parent dans la branche, qui est au troisième niveau d'imbrication.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri inversé :: Tri Splay</font></font></h2><img align="right" width="396" height="590" src="https://habrastorage.org/webt/ig/xb/3c/igxb3c-v8_la--ej_irmsze7dai.gif"><br clear="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, ici, nous effectuons les mêmes points que dans le tri des arbres - nous construisons d'abord un arbre de tri binaire, puis nous le contournons. Mais chaque fois que nous insérons un nouveau nœud dans l'arbre - en utilisant des crêtes et des zags, nous en faisons la racine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À la première étape de la victoire, cela ne donne pas, l'insertion d'un nœud (en tenant compte du fait que vous devez zigzaguer pour en faire une racine) coûte en moyenne </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - et donc la complexité de cette étape est </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, en conséquence, des transformations étonnantes se produisent avec l'arbre - il se redresse et est maintenu dans un tel état redressé tout le temps. Et cela accélère de manière décisive la deuxième étape (traversée de l'arbre), car l'échelle finale résultante est traitée avec une complexité O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, la complexité totale de l'algorithme (pire, moyen, meilleur) dans le temps est </font></font><nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En pratique, ce tri est plus lent que MergeSort, QuickSort et autres HeapSort, mais il montre clairement comment vous pouvez accélérer les opérations avec l'arborescence de recherche binaire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La morale de cette fable est la suivante: si vous devez traiter avec un arbre de recherche binaire - si possible, faites-le auto-équilibré. </font><font style="vertical-align: inherit;">Comme option possible - travaillez avec elle comme avec un arbre splay, c'est-à-dire </font><font style="vertical-align: inherit;">dans n'importe quelle action avec n'importe quel nœud de l'arborescence, faites de ce nœud la racine. </font><font style="vertical-align: inherit;">Bien sûr, il existe d'autres arbres de recherche auto-équilibrés alternatifs (arbre rouge-noir, arbre AVL, etc.), qui peuvent être plus préférables.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code C</font></font></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne pas avoir l'air nerveux</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">/*
 *------------------------------------------------------------
 *
 *      File..........: $RCSfile: splaysort.c,v $
 *      Revision......: $Revision: 1.2 $
 *      Author........: Gary Eddy (gary@cs.mu.OZ.AU)
 *			Alistair Moffat (alistair@cs.mu.OZ.AU)
 *      Date..........: $Date: 1995/09/07 06:19:17 $
 *
 *	Description:
 *		Sorts by repeated insertion into a splay tree.
 *		Insertions are done top down
 *
 *------------------------------------------------------------
 */</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;malloc.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span>	<span class="hljs-meta-string">&lt;alloca.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-keyword">char</span>	*sort_name = <span class="hljs-string">"Splaysort"</span>;
<span class="hljs-keyword">char</span>	*sort_version = <span class="hljs-string">"$Revision: 1.2 $"</span>;<font></font>
<font></font>
<span class="hljs-comment">/*
** Define DATAPTR for the 12 byte per record version of the program.
** Otherwise only 8 extra bytes per record are used and data
** references are done by indexing the data array.
** Different compiler/architecture combinations can cause wild
** variation in the ratio of speeds between these variations.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATAPTR</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) ((p)-&gt;data)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DATA(p) (A+size*(p-T))</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** With the fast copy option enabled a more intelligent copy is used
** depending on the size of the items being copied.
** This approach adopted from the nqsort program of Bentley and McIlroy,
** see Software Practice and Experience, v23, n11, November 1993, 1249-65.
*/</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FASTCOPY</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPYCODE(TYPE, parmi, parmj, n) { \
        long i = (n) / sizeof (TYPE); \
        register TYPE *pi = (TYPE *) (parmi); \
        register TYPE *pj = (TYPE *) (parmj); \
        do { \
                *pi++ = *pj++;                    \
        } while (--i &gt; 0);      \
}</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">copyfunc</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *d, <span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> size, <span class="hljs-keyword">int</span> copytype)</span>
</span>{
        <span class="hljs-keyword">if</span>(copytype &lt;= <span class="hljs-number">1</span>)<font></font>
                COPYCODE(<span class="hljs-keyword">long</span>, d, s, size)
        <span class="hljs-keyword">else</span>
                COPYCODE(<span class="hljs-keyword">char</span>, d, s, size)
	<span class="hljs-keyword">return</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size) \
        <span class="hljs-meta-keyword">if</span> (copytype == 0) { \
                *(long *)(d) = *(long *)(s); \
        } <span class="hljs-meta-keyword">else</span> \
                copyfunc(d, s, size, copytype)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> COPY(d,s,size)	memcpy(d,s,size)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  <span class="hljs-title">node_rec</span> <span class="hljs-title">node</span>;</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span>	<span class="hljs-title">node_rec</span> {</span><font></font>
	node	*left, *rght;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*data;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
};<font></font>
<font></font>
<span class="hljs-comment">/*
 *	sort():
 *		The entire sort code 
 *
 *	Accesses outside variables:	none
 *
 *	Return value...:		none
 */</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *A, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> (*cmp)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *))</span>
</span>{
	<span class="hljs-keyword">register</span> node *next, *curr, *prnt;
	<span class="hljs-keyword">char</span> 	*item;<font></font>
	node	*l, *r, *ch;<font></font>
	node	root, *T, *<span class="hljs-keyword">new</span>, *end, *move;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-keyword">char</span>	*p;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-comment">/*
** Determine which copying method will be used.
*/</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> FASTCOPY</span>
	<span class="hljs-keyword">int</span>	copytype=((<span class="hljs-keyword">char</span> *)A - (<span class="hljs-keyword">char</span> *)<span class="hljs-number">0</span>) % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ||<font></font>
		size % <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">2</span> : size == <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">long</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(n &lt; <span class="hljs-number">2</span>)
		<span class="hljs-keyword">return</span>;
	<span class="hljs-keyword">if</span>((T = <span class="hljs-keyword">new</span> = (node *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(*T)*n)) == <span class="hljs-literal">NULL</span>) {
		<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't allocate space for structure\n"</span>);<font></font>
	}<font></font>
	<span class="hljs-comment">/* 
	** Do the first insertion manually to avoid the empty tree
	** case in the main loop.
	*/</span>
	curr = <span class="hljs-keyword">new</span>++;<font></font>
	item = A;<font></font>
	curr-&gt;left = curr-&gt;rght = <span class="hljs-literal">NULL</span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span><font></font>
	curr-&gt;data = item;<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
	item += size;<font></font>
	end = T+n;<font></font>
	<span class="hljs-comment">/*
	** For each item move down the tree dividing it into
	** two subtrees, one containing items less than the new
	** element and the other those which are greater.
	** The pointers l and r refer to the greatest element in the
	** smaller subtree and the smallest element in the large
	** subtree respectively. During the splitting of the tree
	** l and r retain children that may be incorrect in the final
	** tree but these false links are cut at the end of the
	** insertion.
	*/</span><font></font>
<font></font>
	<span class="hljs-keyword">for</span>( ; <span class="hljs-keyword">new</span>&lt;end; ) {<font></font>
		l = r = &amp;root;<font></font>
		<span class="hljs-keyword">while</span>(curr != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-keyword">if</span>(cmp(item, DATA(curr)) &lt; <span class="hljs-number">0</span>) {
				<span class="hljs-comment">/* Left root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;left) == <span class="hljs-literal">NULL</span>) {<font></font>
					r = r-&gt;left = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zig */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					curr-&gt;left = ch-&gt;rght;<font></font>
					ch-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Left zig-zag */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					r = r-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-keyword">else</span> {
				<span class="hljs-comment">/* Right root case */</span>
				<span class="hljs-keyword">if</span>((ch = curr-&gt;rght) == <span class="hljs-literal">NULL</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					<span class="hljs-keyword">break</span>;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zag */</span>
				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp(item, DATA(ch)) &lt; <span class="hljs-number">0</span>) {<font></font>
					l = l-&gt;rght = curr;<font></font>
					r = r-&gt;left = ch;<font></font>
					curr = ch-&gt;left;<font></font>
				}<font></font>
				<span class="hljs-comment">/* Right zig-zig */</span>
				<span class="hljs-keyword">else</span> {<font></font>
					curr-&gt;rght = ch-&gt;left;<font></font>
					ch-&gt;left = curr;<font></font>
					l = l-&gt;rght = ch;<font></font>
					curr = ch-&gt;rght;<font></font>
				}<font></font>
			}<font></font>
		}<font></font>
		<span class="hljs-comment">/* Cut false links */</span>
		r-&gt;left = l-&gt;rght = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">new</span>-&gt;rght = root.left;
		<span class="hljs-keyword">new</span>-&gt;left = root.rght;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DATAPTR</span>
		<span class="hljs-keyword">new</span>-&gt;data = item;
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
		curr = <span class="hljs-keyword">new</span>++;<font></font>
		item += size;<font></font>
	}<font></font>
	<span class="hljs-comment">/* Now copy all of the data back into the input array.
	** Uses an iterative destructive inorder traversal.
	** Last item inserted is the current root.
	*/</span>
	prnt = <span class="hljs-literal">NULL</span>;<font></font>
	move = T;<font></font>
	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
		<span class="hljs-keyword">if</span> ((next = curr-&gt;left) != <span class="hljs-literal">NULL</span>) {
			<span class="hljs-comment">/* left subtree exists */</span><font></font>
			curr-&gt;left = prnt;<font></font>
			prnt = curr;<font></font>
			curr = next;<font></font>
		}<font></font>
		<span class="hljs-keyword">else</span> {<font></font>
			next = curr-&gt;rght;<font></font>
			curr-&gt;rght = move++;<font></font>
			<span class="hljs-keyword">if</span> (next != <span class="hljs-literal">NULL</span>) {
				<span class="hljs-comment">/* and arrange for a visit */</span>
				<span class="hljs-keyword">if</span>((curr = next-&gt;left) != <span class="hljs-literal">NULL</span>) {<font></font>
					next-&gt;left = prnt;<font></font>
					prnt = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
				<span class="hljs-keyword">else</span> {<font></font>
					curr = next;<font></font>
					<span class="hljs-keyword">continue</span>;<font></font>
				}<font></font>
			}<font></font>
			<span class="hljs-comment">/* no right subtree either, turn around*/</span>
			<span class="hljs-keyword">if</span> (prnt != <span class="hljs-literal">NULL</span>) {<font></font>
				curr = prnt;<font></font>
				prnt = prnt-&gt;left;<font></font>
				curr-&gt;left = <span class="hljs-literal">NULL</span>;
				<span class="hljs-keyword">continue</span>;<font></font>
			}<font></font>
			<span class="hljs-comment">/* nothing left to be done */</span>
			<span class="hljs-keyword">break</span>;<font></font>
		}<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> DATAPTR</span>
	<span class="hljs-comment">/*
	** Change the goes-to array in rght to a comes_from in left.
	** Note the kludge on pointers, where left points into the 
	** character array containing the elements.
	*/</span>
	<span class="hljs-keyword">for</span>(next = T, p = A; next &lt; end; p += size, next++)<font></font>
		next-&gt;rght-&gt;left = (node *)p;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
        <span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
                <span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
                <span class="hljs-keyword">if</span> (next-&gt;left == <span class="hljs-literal">NULL</span>)
                        <span class="hljs-keyword">continue</span>;<font></font>
                curr = next;<font></font>
                <span class="hljs-keyword">final</span> = datacurr = DATA(curr);<font></font>
                COPY(item, datacurr, size);<font></font>
                <span class="hljs-keyword">while</span> ((<span class="hljs-keyword">char</span> *)(curr-&gt;left) != <span class="hljs-keyword">final</span>) {<font></font>
                        dataleftcurr = (<span class="hljs-keyword">char</span> *)(curr-&gt;left);<font></font>
                        COPY(datacurr, dataleftcurr, size);<font></font>
                        prnt = curr;<font></font>
                        curr = T + (((<span class="hljs-keyword">char</span> *)(curr-&gt;left)-A)/size);<font></font>
                        prnt-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
                        datacurr = dataleftcurr;<font></font>
                }<font></font>
                COPY(datacurr, item, size);<font></font>
                curr-&gt;left = <span class="hljs-literal">NULL</span>;<font></font>
        }<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
	<span class="hljs-comment">/* Change the goes-to array in rght to a comes_from in left */</span>
	<span class="hljs-keyword">for</span>(next = T; next &lt; end; next++)<font></font>
		next-&gt;rght-&gt;left = next;<font></font>
	<span class="hljs-comment">/* and use the `comes from' array to unscramble the permutation */</span>
	<span class="hljs-comment">/*
	** This 12 byte version uses the presence of the data pointer
	** by making it the flag for already placed items. This means
	** that left pointers can point to nodes, eliminating the
	** calculation to find the next node.
	*/</span>
	item = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(size);
	<span class="hljs-keyword">for</span> (next=T; next&lt;end; next++) {
		<span class="hljs-keyword">char</span> *datacurr, *dataleftcurr, *<span class="hljs-keyword">final</span>;
		<span class="hljs-comment">/* second condition guarantees at least one iteration
		** of while loop.
		*/</span>
		<span class="hljs-keyword">if</span> (DATA(next) == (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span> || next-&gt;left == next)
			<span class="hljs-keyword">continue</span>;
		<span class="hljs-keyword">final</span> = datacurr = DATA(next);<font></font>
		curr = next-&gt;left;<font></font>
		COPY(item, datacurr, size);<font></font>
		<span class="hljs-keyword">while</span> ((dataleftcurr = DATA(curr)) != <span class="hljs-keyword">final</span>) {<font></font>
			COPY(datacurr, dataleftcurr, size);<font></font>
			prnt = curr;<font></font>
			curr = curr-&gt;left;<font></font>
			DATA(prnt) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
			datacurr = dataleftcurr;<font></font>
		}<font></font>
		COPY(datacurr, item, size);<font></font>
		DATA(curr) = (<span class="hljs-keyword">char</span> *) <span class="hljs-literal">NULL</span>;<font></font>
	}<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
	<span class="hljs-built_in">free</span>(item);
	<span class="hljs-built_in">free</span>(T);<font></font>
} <span class="hljs-comment">/* sort() */</span></code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remorque de la série suivante</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Et nous retournons aux tas. </font><font style="vertical-align: inherit;">La prochaine petite chose sera plus intéressante que celle que nous avons examinée aujourd'hui. </font><font style="vertical-align: inherit;">Cet hybride est une structure de données arborescente qui est à la fois un tas et un arbre de recherche binaire.</font></font><br>
<br>
<img height="498" src="https://habrastorage.org/webt/gf/96/5w/gf965wv0ih9ugz1ur98ywqe4oaq.gif"><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h2><br>
 <img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbre de recherche binaire</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arbre </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/jw/w-/qu/jww-queszzqnwmoa2hm-kfwu-9o.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Splay Arbres Splay</font></font></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Articles de série:</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Application Excel AlgoLab.xlsm</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exchange Sorts</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri d'insertion</font></font></a><ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri bibliothécaire</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri solitaire</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trier "Tour de Hanoi"</font></font></a></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inverser le tri</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri des jeunes tables</font></font></li>
</ul></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trier par sélection</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fusionner les tris</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trier par distribution</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tri hybride</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tri ajouté à AlgoLab. </font><font style="vertical-align: inherit;">Donc, si vous mettez à jour le fichier Excel avec des macros, vous pouvez personnellement perturber l'arborescence de recherche binaire.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr503998/index.html">Les données de tous les pays ne s'unissent pas</a></li>
<li><a href="../fr504000/index.html">Mikrosha. Chapitre deux ROM et BSVV</a></li>
<li><a href="../fr504002/index.html">Comment utiliser Yandex.Wordstat pour la publicité contextuelle [guide détaillé]</a></li>
<li><a href="../fr504006/index.html">6 façons d'accélérer considérablement les pandas avec quelques lignes de code. Partie 2</a></li>
<li><a href="../fr504008/index.html">Qu'est-ce qu'un algorithme?! Partie un</a></li>
<li><a href="../fr504014/index.html">Les anglicismes capturent la langue russe: pourquoi cela se produit</a></li>
<li><a href="../fr504016/index.html">L'appel du stoïcisme aux riches et aux influents</a></li>
<li><a href="../fr504022/index.html">Spécialiste de la sécurité de l'information. Ce qui fait et combien ça fait</a></li>
<li><a href="../fr504026/index.html">Pourquoi la Silicon Valley est-elle si obsédée par la vertu de la souffrance?</a></li>
<li><a href="../fr504030/index.html">L'histoire de la façon dont j'ai configuré Azure AD B2C sur React et React Native, partie 2 (didacticiel)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>