<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòø ü§õüèø ü§ûüèΩ Das Buch "Java Concurrency in Practice" üö∂üèø üôåüèæ ‚ûø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Streams sind ein wesentlicher Bestandteil der Java-Plattform. Multi-Core-Prozessoren sind an der Tagesordnung, und die effektive N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Java Concurrency in Practice"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! Streams sind ein wesentlicher Bestandteil der Java-Plattform. Multi-Core-Prozessoren sind an der Tagesordnung, und die effektive Nutzung der Parallelit√§t ist erforderlich geworden, um eine Hochleistungsanwendung zu erstellen. Eine verbesserte virtuelle Java-Maschine, die Unterst√ºtzung von Hochleistungsklassen und eine Vielzahl von Bausteinen f√ºr Parallelisierungsaufgaben waren einst ein Durchbruch bei der Entwicklung paralleler Anwendungen. In Java Concurrency in Practice erkl√§ren die Entwickler der bahnbrechenden Technologie selbst nicht nur, wie sie funktionieren, sondern sprechen auch √ºber Entwurfsmuster. Es ist einfach, ein wettbewerbsf√§higes Programm zu erstellen, das zu funktionieren scheint. Das Entwickeln, Testen und Debuggen von Multithread-Programmen wirft jedoch viele Probleme auf. Der Code funktioniert nicht mehr, wenn es am wichtigsten ist: unter starker Last.In ‚ÄûJava Concurrency in Practice‚Äú finden Sie sowohl theoretische als auch spezifische Methoden zum Erstellen zuverl√§ssiger, skalierbarer und unterst√ºtzter paralleler Anwendungen. Die Autoren bieten keine Liste von APIs und Parallelit√§tsmechanismen an, sondern f√ºhren Entwurfsregeln, Muster und Modelle ein, die von der Java-Version unabh√§ngig sind und √ºber viele Jahre hinweg relevant und effektiv bleiben.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug. </font><font style="vertical-align: inherit;">Gewindesicherheit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden √ºberrascht sein, dass wettbewerbsf√§hige Programmierung mit Gewinden oder Schl√∂ssern </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr verbunden ist als Tiefbau mit Nieten und I-Tr√§gern. </font><font style="vertical-align: inherit;">Nat√ºrlich erfordert der Bau von Br√ºcken die korrekte Verwendung einer gro√üen Anzahl von Nieten und I-Tr√§gern, und das Gleiche gilt f√ºr den Bau von Wettbewerbsprogrammen, bei denen Gewinde und Schl√∂sser korrekt verwendet werden m√ºssen. </font><font style="vertical-align: inherit;">Dies sind jedoch nur Mechanismen - Mittel zur Erreichung des Ziels. </font><font style="vertical-align: inherit;">Das Schreiben von thread-sicherem Code steuert im Wesentlichen den Zugriff auf einen Status und insbesondere auf einen ver√§nderlichen Status.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind der Status eines Objekts seine Daten, die in Statusvariablen wie Instanz- und statischen Feldern oder Feldern von anderen abh√§ngigen Objekten gespeichert sind. Der Status des HashMap-Hashs wird teilweise in der HashMap selbst, aber auch in vielen Map.Entry-Objekten gespeichert. Der Status eines Objekts enth√§lt alle Daten, die sein Verhalten beeinflussen k√∂nnen. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      ¬´¬ª,     ,  .            blocking.   lock    ¬´¬ª, ¬´  ¬ª.     lock ,  ,   ,    ¬´¬ª.  ‚Äî          .       ,          , ,         . ‚Äî . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehrere Threads k√∂nnen mutiert auf eine gemeinsam genutzte Variable zugreifen - √§ndert ihren Wert. Tats√§chlich versuchen wir, Daten und nicht Code vor unkontrolliertem Wettbewerbszugriff zu sch√ºtzen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines thread-sicheren Objekts erfordert eine Synchronisierung, um den Zugriff auf einen mutierten Zustand zu koordinieren. Eine Nichterf√ºllung kann zu Datenkorruption und anderen unerw√ºnschten Folgen f√ºhren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immer wenn mehr als ein Thread auf eine Statusvariable zugreift und einer der Threads m√∂glicherweise darauf schreibt, m√ºssen alle Threads ihren Zugriff mithilfe der Synchronisation koordinieren. Die Synchronisation in Java wird durch das synchronisierte Schl√ºsselwort bereitgestellt, das exklusive Sperren sowie fl√ºchtige und atomare Variablen und explizite Sperren bietet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Widerstehen Sie der Versuchung zu glauben, dass es Situationen gibt, die keine Synchronisation erfordern. </font><font style="vertical-align: inherit;">Das Programm kann arbeiten und seine Tests bestehen, bleibt jedoch fehlerhaft und st√ºrzt jederzeit ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn mehrere Threads ohne ordnungsgem√§√üe Synchronisierung mit einem mutierten Status auf dieselbe Variable zugreifen, funktioniert Ihr Programm nicht richtig. </font><font style="vertical-align: inherit;">Es gibt drei M√∂glichkeiten, dies zu beheben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilen Sie die Statusvariable nicht in allen Threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Zustandsvariable nicht ver√§nderbar machen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Statussynchronisation jedes Mal, wenn Sie auf die Statusvariable zugreifen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korrekturen erfordern m√∂glicherweise erhebliche Design√§nderungen. Daher ist es viel einfacher, eine Klasse sofort threadsicher zu entwerfen, als sie sp√§ter zu aktualisieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ob mehrere Threads auf diese oder jene Variable zugreifen, ist schwer herauszufinden. Gl√ºcklicherweise helfen objektorientierte technische L√∂sungen, die beim Erstellen gut organisierter und einfach zu pflegender Klassen helfen, z. B. das Einkapseln und Ausblenden von Daten, auch beim Erstellen threadsicherer Klassen. Je weniger Threads Zugriff auf eine bestimmte Variable haben, desto einfacher ist es, die Synchronisierung sicherzustellen und die Bedingungen festzulegen, unter denen auf diese Variable zugegriffen werden kann. Die Java-Sprache zwingt Sie nicht dazu, den Status zu kapseln. Es ist durchaus akzeptabel, den Status in √∂ffentlichen Feldern (auch in √∂ffentlichen statischen Feldern) zu speichern oder einen Link zu einem Objekt zu ver√∂ffentlichen, das ansonsten intern ist. Je besser der Status Ihres Programms gekapselt ist, desto besser.Je einfacher es ist, Ihren Programm-Thread sicher zu machen und den Betreuern dabei zu helfen, dies auch so zu halten.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Entwerfen threadsicherer Klassen sind gute objektorientierte technische L√∂sungen: Kapselung, Ver√§nderlichkeit und eine klare Spezifikation von Invarianten Ihre Assistenten.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn gute objektorientierte technische Designl√∂sungen von den Anforderungen des Entwicklers abweichen, sollten Sie die Regeln f√ºr gutes Design aus Gr√ºnden der Leistung oder der Abw√§rtskompatibilit√§t mit Legacy-Code opfern. </font><font style="vertical-align: inherit;">Manchmal stehen Abstraktion und Kapselung im Widerspruch zur Leistung - obwohl nicht so oft, wie viele Entwickler denken -, aber die beste Vorgehensweise besteht darin, den Code zuerst richtig und dann schnell zu machen. </font><font style="vertical-align: inherit;">Versuchen Sie, die Optimierung nur dann zu verwenden, wenn Messungen der Produktivit√§t und der Anforderungen ergeben, dass Sie dies tun m√ºssen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Wettbewerbscode sollten Sie diese Praxis noch mehr als √ºblich einhalten. Da Wettbewerbsfehler √§u√üerst schwer zu reproduzieren und nicht einfach zu debuggen sind, kann der Vorteil eines geringen Leistungsgewinns bei einigen selten verwendeten Codezweigen im Vergleich zu dem Risiko, dass das Programm unter Betriebsbedingungen abst√ºrzt, vernachl√§ssigbar sein.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie entscheiden, dass Sie die Kapselung aufheben m√ºssen, geht nicht alles verloren. Ihr Programm kann immer noch threadsicher gemacht werden, aber der Prozess wird komplizierter und teurer und das Ergebnis ist unzuverl√§ssig. Kapitel 4 beschreibt die Bedingungen, unter denen die Kapselung von Zustandsvariablen sicher verringert werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir die Begriffe "thread safe class" und "thread safe program" fast austauschbar verwendet. Ist ein thread-sicheres Programm vollst√§ndig aus thread-sicheren Klassen aufgebaut? Optional: Ein Programm, das vollst√§ndig aus threadsicheren Klassen besteht, ist m√∂glicherweise nicht threadsicher, und ein threadsicheres Programm enth√§lt m√∂glicherweise Klassen, die nicht threadsicher sind. Probleme im Zusammenhang mit dem Layout threadsicherer Klassen werden auch in Kapitel 4 behandelt. In jedem Fall ist das Konzept einer threadsicheren Klasse nur dann sinnvoll, wenn die Klasse ihren eigenen Status kapselt. Der Begriff "Thread-Sicherheit" kann auf den Code angewendet werden, spricht jedoch vom Status und kann nur auf das Code-Array angewendet werden, das seinen Status kapselt (es kann sich um ein Objekt oder das gesamte Programm handeln).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Was ist Gewindesicherheit?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Definieren der Gewindesicherheit ist nicht einfach. </font><font style="vertical-align: inherit;">Eine schnelle Google-Suche bietet Ihnen zahlreiche Optionen wie diese: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... kann von mehreren Programm-Threads ohne unerw√ºnschte Interaktionen zwischen Threads aufgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... kann von zwei oder mehr Threads gleichzeitig aufgerufen werden, ohne dass der Aufrufer eine andere Aktion ausf√ºhren muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts solcher Definitionen ist es nicht verwunderlich, dass wir die Thread-Sicherheit verwirrend finden! </font><font style="vertical-align: inherit;">Wie kann man eine thread-sichere Klasse von einer unsicheren Klasse unterscheiden? </font><font style="vertical-align: inherit;">Was meinen wir mit dem Wort "sicher"? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Zentrum jeder vern√ºnftigen Definition der Gewindesicherheit steht der Begriff der Korrektheit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korrektheit bedeutet, dass die Klasse ihrer Spezifikation entspricht. </font><font style="vertical-align: inherit;">Die Spezifikation definiert Invarianten, die den Zustand eines Objekts begrenzen, und Nachbedingungen, die die Auswirkungen von Operationen beschreiben. </font><font style="vertical-align: inherit;">Woher wissen Sie, dass die Spezifikationen f√ºr Klassen korrekt sind? </font><font style="vertical-align: inherit;">Auf keinen Fall, aber dies hindert uns nicht daran, sie zu verwenden, nachdem wir uns davon √ºberzeugt haben, dass der Code funktioniert. </font><font style="vertical-align: inherit;">Nehmen wir also an, dass Single-Threaded-Korrektheit sichtbar ist. </font><font style="vertical-align: inherit;">Jetzt k√∂nnen wir davon ausgehen, dass sich die thread-sichere Klasse beim Zugriff von mehreren Threads korrekt verh√§lt.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse ist threadsicher, wenn sie sich beim Zugriff von mehreren Threads korrekt verh√§lt, unabh√§ngig davon, wie diese Threads von der Arbeitsumgebung geplant oder verschachtelt werden, und ohne zus√§tzliche Synchronisation oder andere Koordination seitens des aufrufenden Codes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Multithread-Programm kann nicht threadsicher sein, wenn es selbst in einer Single-Thread-Umgebung nicht korrekt ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn das Objekt korrekt implementiert ist, sollte keine Abfolge von Operationen - Zugriff auf √∂ffentliche Methoden und Lesen oder Schreiben in √∂ffentliche Felder - seine Invarianten oder Nachbedingungen verletzen. </font><font style="vertical-align: inherit;">Keine Reihe von Operationen, die sequentiell oder wettbewerbsf√§hig f√ºr Instanzen einer thread-sicheren Klasse ausgef√ºhrt werden, kann dazu f√ºhren, dass sich eine Instanz in einem ung√ºltigen Zustand befindet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie hier die lose Verwendung des Begriffs Korrektheit st√∂rt, k√∂nnen Sie sich eine thread-sichere Klasse als eine Klasse vorstellen, die sowohl in einer Wettbewerbsumgebung als auch in einer Single-Thread-Umgebung fehlerhaft ist.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-sichere Klassen kapseln alle erforderlichen Synchronisierungen selbst und ben√∂tigen nicht die Hilfe eines Clients.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1. </font><font style="vertical-align: inherit;">Beispiel: Servlet ohne interne Statusunterst√ºtzung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Kapitel 1 haben wir die Strukturen aufgelistet, die Threads erstellen und daraus Komponenten aufrufen, f√ºr deren Thread-Sicherheit Sie verantwortlich sind. </font><font style="vertical-align: inherit;">Jetzt beabsichtigen wir, einen Servlet-Faktorisierungsdienst zu entwickeln und dessen Funktionalit√§t schrittweise zu erweitern, w√§hrend die Thread-Sicherheit erhalten bleibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1 zeigt ein einfaches Servlet, das eine Zahl aus einer Abfrage dekomprimiert, faktorisiert und die Ergebnisse als Antwort umschlie√üt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1. </font><font style="vertical-align: inherit;">Servlet ohne interne Zustandsunterst√ºtzung</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die StatelessFactorizer-Klasse hat wie die meisten Servlets keinen internen Status: Sie enth√§lt keine Felder und verweist nicht auf Felder aus anderen Klassen. </font><font style="vertical-align: inherit;">Der Status f√ºr eine bestimmte Berechnung ist nur in lokalen Variablen vorhanden, die im Stream-Stack gespeichert sind und nur dem ausf√ºhrenden Stream zur Verf√ºgung stehen. </font><font style="vertical-align: inherit;">Ein Thread, der auf StatelessFactorizer zugreift, kann das Ergebnis eines anderen Threads nicht beeinflussen, da diese Threads keinen gemeinsamen Status haben.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte ohne interne Statusunterst√ºtzung sind immer threadsicher.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass die meisten Servlets ohne interne Statusunterst√ºtzung implementiert werden k√∂nnen, reduziert die Belastung durch Threading der Servlets selbst erheblich. </font><font style="vertical-align: inherit;">Und nur wenn Servlets sich an etwas erinnern m√ºssen, steigen die Anforderungen an ihre Gewindesicherheit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Atomizit√§t</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn ein Statuselement ohne interne Statusunterst√ºtzung zu einem Objekt hinzugef√ºgt wird? Angenommen, wir m√∂chten einen Trefferz√§hler hinzuf√ºgen, der die Anzahl der verarbeiteten Anforderungen misst. Sie k√∂nnen dem Servlet ein Feld vom Typ long hinzuf√ºgen und es bei jeder Anforderung erh√∂hen, wie in UnsafeCountingFactorizer in Listing 2.2 gezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.2. Ein Servlet, das Anforderungen ohne die erforderliche Synchronisierung z√§hlt. Dies sollte nicht getan werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="Bild"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist die UnsafeCountingFactorizer-Klasse nicht threadsicher, selbst wenn sie in einer Single-Thread-Umgebung einwandfrei funktioniert. Wie UnsafeSequence ist es anf√§llig f√ºr verlorene Updates. Obwohl die Anzahl der Inkrementoperationen ++ eine kompakte Syntax hat, ist sie nicht atomar, dh unteilbar, sondern eine Folge von drei Operationen: Liefern des aktuellen Werts, Hinzuf√ºgen eines Werts und Zur√ºckschreiben des neuen Werts. Bei den Operationen "Lesen, √Ñndern, Schreiben" wird der resultierende Zustand vom vorherigen abgeleitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. </font><font style="vertical-align: inherit;">1.1 Es wird gezeigt, was passieren kann, wenn zwei Threads gleichzeitig versuchen, den Z√§hler ohne Synchronisation zu erh√∂hen. </font><font style="vertical-align: inherit;">Wenn der Z√§hler 9 ist, sehen beide Threads aufgrund einer erfolglosen Zeitkoordination den Wert 9, addieren einen und setzen den Wert auf 10. Der Trefferz√§hler beginnt also um eins zu verz√∂gern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie k√∂nnten denken, dass ein leicht ungenauer Trefferz√§hler in einem Webdienst ein akzeptabler Verlust ist, und manchmal auch. </font><font style="vertical-align: inherit;">Wenn der Z√§hler jedoch zum Erstellen von Sequenzen oder eindeutigen Kennungen von Objekten verwendet wird, kann die R√ºckgabe des gleichen Werts aus mehreren Aktivierungen zu schwerwiegenden Datenintegrit√§tsproblemen f√ºhren. </font><font style="vertical-align: inherit;">Die M√∂glichkeit des Auftretens falscher Ergebnisse aufgrund einer erfolglosen zeitlichen Koordination ergibt sich unter Rennbedingungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Rennbedingungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die UnsafeCountingFactorizer-Klasse hat mehrere Rennbedingungen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die h√§ufigste Art von Rennbedingung ist die Situation ‚ÄûPr√ºfen und dann handeln‚Äú, in der anhand einer m√∂glicherweise veralteten Beobachtung entschieden wird, was als n√§chstes zu tun ist. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im wirklichen Leben begegnen wir oft einer Rennbedingung. Angenommen, Sie planen, mittags einen Freund im Starbucks Caf√© am Universitetskiy Prospekt zu treffen. Aber Sie werden feststellen, dass es zwei Starbucks auf der University Avenue gibt. Um 12:10 Uhr sehen Sie Ihren Freund nicht in Caf√© A und gehen in Caf√© B, aber er ist auch nicht da. Entweder ist Ihr Freund zu sp√§t oder er ist unmittelbar nach Ihrer Abreise im Caf√© A angekommen, oder er war im Caf√© B, hat Sie aber gesucht und ist jetzt auf dem Weg zum Caf√© A. Wir werden das letztere akzeptieren, das hei√üt, den schlimmsten Fall. Jetzt, 12:15 Uhr, und Sie fragen sich beide, ob Ihr Freund sein Versprechen gehalten hat. Wirst du in ein anderes Caf√© zur√ºckkehren? Wie oft wirst du hin und her gehen? Wenn Sie sich nicht auf ein Protokoll geeinigt haben, k√∂nnen Sie den ganzen Tag in koffeinhaltiger Euphorie die University Avenue entlang spazieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem beim Ansatz ‚ÄûGehen Sie spazieren und sehen Sie, ob er da ist‚Äú besteht darin, dass ein Spaziergang entlang der Stra√üe zwischen zwei Caf√©s mehrere Minuten dauert und sich w√§hrend dieser Zeit der Zustand des Systems √§ndern kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel mit Starbucks zeigt die Abh√§ngigkeit des Ergebnisses von der relativen zeitlichen Koordination der Ereignisse (davon, wie lange Sie in einem Caf√© auf einen Freund warten usw.). </font><font style="vertical-align: inherit;">Die Beobachtung, dass er nicht in Caf√© A ist, wird m√∂glicherweise ung√ºltig: Sobald Sie die Vordert√ºr verlassen, kann er durch die Hintert√ºr eintreten. </font><font style="vertical-align: inherit;">Die meisten Rennbedingungen verursachen Probleme wie eine unerwartete Ausnahme, √ºberschriebene Daten und Dateibesch√§digung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Beispiel: Rennbedingungen bei verz√∂gerter Initialisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein h√§ufiger Trick bei der Verwendung des Ansatzes ‚ÄûPr√ºfen und dann handeln‚Äú ist die verz√∂gerte Initialisierung (LazyInitRace). Ziel ist es, die Initialisierung des Objekts zu verschieben, bis es ben√∂tigt wird, und sicherzustellen, dass es nur einmal initialisiert wird. In Listing 2.3 stellt die Methode getInstance sicher, dass das ExpensiveObject initialisiert wird und eine vorhandene Instanz zur√ºckgibt, oder erstellt auf andere Weise eine neue Instanz und gibt sie zur√ºck, nachdem ein Verweis darauf beibehalten wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.3. Die Rennbedingung ist in einer tr√§gen Initialisierung. Dies sollte nicht getan werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="Bild"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die LazyInitRace-Klasse enth√§lt Rennbedingungen. Angenommen, die Threads A und B f√ºhren gleichzeitig die Methode getInstance aus. A erkennt, dass das Instanzfeld null ist, und erstellt ein neues ExpensiveObject. Thread B pr√ºft auch, ob das Instanzfeld dieselbe Null ist. Das Vorhandensein von Null im Feld zu diesem Zeitpunkt h√§ngt von der Zeitkoordination ab, einschlie√ülich der Planungsschwankungen und der Zeit, die erforderlich ist, um eine Instanz des ExpensiveObject zu erstellen und den Wert im Instanzfeld festzulegen. Wenn das Instanzfeld bei der √úberpr√ºfung durch B null ist, k√∂nnen zwei Codeelemente, die die Methode getInstance aufrufen, zwei unterschiedliche Ergebnisse erzielen, selbst wenn die Methode getInstance immer dieselbe Instanz zur√ºckgeben soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Trefferz√§hler in UnsafeCountingFactorizer enth√§lt auch die Rennbedingungen. Der Ansatz "Lesen, √Ñndern, Schreiben" impliziert, dass der Stream zum Erh√∂hen des Z√§hlers seinen vorherigen Wert kennen und sicherstellen muss, dass niemand diesen Wert w√§hrend des Aktualisierungsprozesses √§ndert oder verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie die meisten Wettbewerbsfehler f√ºhren die Rennbedingungen nicht immer zum Scheitern: Die vor√ºbergehende Koordination ist erfolgreich. </font><font style="vertical-align: inherit;">Wenn die LazyInitRace-Klasse jedoch zum Instanziieren der Registrierung der gesamten Anwendung verwendet wird, gehen Registrierungen verloren, wenn verschiedene Instanzen aus mehreren Aktivierungen zur√ºckgegeben werden, oder Aktionen erhalten widerspr√ºchliche Darstellungen der Gruppe registrierter Objekte. </font><font style="vertical-align: inherit;">Wenn die UnsafeSequence-Klasse zum Generieren von Entit√§tskennungen in einer Datenerhaltungsstruktur verwendet wird, k√∂nnen zwei verschiedene Objekte dieselbe Kennung haben, wodurch Identit√§tsbeschr√§nkungen verletzt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Zusammengesetzte Aktionen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sowohl LazyInitRace als auch UnsafeCountingFactorizer enthalten eine Folge von Operationen, die atomar sein m√ºssen. </font><font style="vertical-align: inherit;">Um jedoch eine Race-Bedingung zu verhindern, muss es f√ºr andere Threads ein Hindernis geben, die Variable zu verwenden, w√§hrend ein Thread sie √§ndert.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operationen A und B sind atomar, wenn aus Sicht des Threads, der Operation A ausf√ºhrt, Operation B entweder vollst√§ndig von einem anderen Thread ausgef√ºhrt oder nicht einmal teilweise ausgef√ºhrt wurde.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Atomizit√§t der Inkrementoperation in UnsafeSequence w√ºrde die in Abb. 1 gezeigte Racebedingung vermeiden. 1.1. Die Operationen "pr√ºfen und dann handeln" und "lesen, √§ndern, schreiben" sollten immer atomar sein. Sie werden zusammengesetzte Aktionen genannt - Abfolgen von Operationen, die atomar ausgef√ºhrt werden m√ºssen, um threadsicher zu bleiben. Im n√§chsten Abschnitt werden wir uns mit dem Sperren befassen - einem in Java integrierten Mechanismus, der Atomizit√§t bietet. In der Zwischenzeit werden wir das Problem auf andere Weise beheben, indem wir die vorhandene thread-sichere Klasse anwenden, wie im Countingfactorizer in Listing 2.4 gezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.4. Servlet-Z√§hlanforderungen mit AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Paket java.util.concurrent.atomic enth√§lt atomare Variablen zum Verwalten von Klassenzust√§nden. Durch Ersetzen des Z√§hlertyps von long auf AtomicLong garantieren wir, dass alle Aktionen, die sich auf den Status des Z√§hlers beziehen, atomar1 sind. Da der Status des Servlets der Status des Z√§hlers ist und der Z√§hler threadsicher ist, wird unser Servlet threadsicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein einzelnes Statuselement zu einer Klasse hinzugef√ºgt wird, die den internen Status nicht unterst√ºtzt, ist die resultierende Klasse threadsicher, wenn der Status vollst√§ndig vom threadsicheren Objekt gesteuert wird. Wie wir im n√§chsten Abschnitt sehen werden, ist der √úbergang von einer Zustandsvariablen zur n√§chsten nicht so einfach wie der √úbergang von Null zu Eins.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie gegebenenfalls vorhandene thread-sichere Objekte wie AtomicLong, um den Status Ihrer Klasse zu steuern. </font><font style="vertical-align: inherit;">M√∂gliche Zust√§nde vorhandener thread-sicherer Objekte und deren √úberg√§nge in andere Zust√§nde sind einfacher zu pflegen und auf Thread-Sicherheit zu pr√ºfen als beliebige Zustandsvariablen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬ªWeitere Informationen zum Buch finden Sie auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
¬ª </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
f√ºr Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489022/index.html">Verwenden von RabbitMQ mit MonsterMQ Teil 2</a></li>
<li><a href="../de489024/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anf√§ngers. Teil 5. Arbeiten Sie mit Daten auf der Benutzerseite</a></li>
<li><a href="../de489026/index.html">Das √Ñndern der Google AdSense-Algorithmen kann zu Website-Eigent√ºmern und Webmastern f√ºhren</a></li>
<li><a href="../de489028/index.html">√úber Fernarbeit</a></li>
<li><a href="../de489034/index.html">Die neue mobile UIS-App oder -Rettung f√ºr diejenigen, die ein √∂ffentliches Beschaffungswesen suchen?</a></li>
<li><a href="../de489040/index.html">Contact Center AI: Dritte im Gespr√§ch sind in Ordnung</a></li>
<li><a href="../de489042/index.html">Gro√üe Wiederer√∂ffnung des Stores: Laden von Daten mit Coroutine in Android</a></li>
<li><a href="../de489044/index.html">Physik des Textes. Teil 1. Symbole</a></li>
<li><a href="../de489046/index.html">Selbstfahrender GAZ66 Monster Truck 1/16</a></li>
<li><a href="../de489048/index.html">Protokollierung und Abfrageverfolgung sind bew√§hrte Methoden. Yandex-Bericht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>