<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😿 🤛🏿 🤞🏽 Das Buch "Java Concurrency in Practice" 🚶🏿 🙌🏾 ➿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Streams sind ein wesentlicher Bestandteil der Java-Plattform. Multi-Core-Prozessoren sind an der Tagesordnung, und die effektive N...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Das Buch "Java Concurrency in Practice"</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/489038/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/1r/ku/4r/1rku4rb0w0tevxfiae9gxkkkzse.jpeg" align="left" alt="Bild"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hallo habrozhiteli! Streams sind ein wesentlicher Bestandteil der Java-Plattform. Multi-Core-Prozessoren sind an der Tagesordnung, und die effektive Nutzung der Parallelität ist erforderlich geworden, um eine Hochleistungsanwendung zu erstellen. Eine verbesserte virtuelle Java-Maschine, die Unterstützung von Hochleistungsklassen und eine Vielzahl von Bausteinen für Parallelisierungsaufgaben waren einst ein Durchbruch bei der Entwicklung paralleler Anwendungen. In Java Concurrency in Practice erklären die Entwickler der bahnbrechenden Technologie selbst nicht nur, wie sie funktionieren, sondern sprechen auch über Entwurfsmuster. Es ist einfach, ein wettbewerbsfähiges Programm zu erstellen, das zu funktionieren scheint. Das Entwickeln, Testen und Debuggen von Multithread-Programmen wirft jedoch viele Probleme auf. Der Code funktioniert nicht mehr, wenn es am wichtigsten ist: unter starker Last.In „Java Concurrency in Practice“ finden Sie sowohl theoretische als auch spezifische Methoden zum Erstellen zuverlässiger, skalierbarer und unterstützter paralleler Anwendungen. Die Autoren bieten keine Liste von APIs und Parallelitätsmechanismen an, sondern führen Entwurfsregeln, Muster und Modelle ein, die von der Java-Version unabhängig sind und über viele Jahre hinweg relevant und effektiv bleiben.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug. </font><font style="vertical-align: inherit;">Gewindesicherheit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie werden überrascht sein, dass wettbewerbsfähige Programmierung mit Gewinden oder Schlössern </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nicht mehr verbunden ist als Tiefbau mit Nieten und I-Trägern. </font><font style="vertical-align: inherit;">Natürlich erfordert der Bau von Brücken die korrekte Verwendung einer großen Anzahl von Nieten und I-Trägern, und das Gleiche gilt für den Bau von Wettbewerbsprogrammen, bei denen Gewinde und Schlösser korrekt verwendet werden müssen. </font><font style="vertical-align: inherit;">Dies sind jedoch nur Mechanismen - Mittel zur Erreichung des Ziels. </font><font style="vertical-align: inherit;">Das Schreiben von thread-sicherem Code steuert im Wesentlichen den Zugriff auf einen Status und insbesondere auf einen veränderlichen Status.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Allgemeinen sind der Status eines Objekts seine Daten, die in Statusvariablen wie Instanz- und statischen Feldern oder Feldern von anderen abhängigen Objekten gespeichert sind. Der Status des HashMap-Hashs wird teilweise in der HashMap selbst, aber auch in vielen Map.Entry-Objekten gespeichert. Der Status eines Objekts enthält alle Daten, die sein Verhalten beeinflussen können. </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(1)</font></font></b>     lock  block,      «»,     ,  .            blocking.   lock    «», «  ».     lock ,  ,   ,    «».  —          .       ,          , ,         . — . . .</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mehrere Threads können mutiert auf eine gemeinsam genutzte Variable zugreifen - ändert ihren Wert. Tatsächlich versuchen wir, Daten und nicht Code vor unkontrolliertem Wettbewerbszugriff zu schützen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Erstellen eines thread-sicheren Objekts erfordert eine Synchronisierung, um den Zugriff auf einen mutierten Zustand zu koordinieren. Eine Nichterfüllung kann zu Datenkorruption und anderen unerwünschten Folgen führen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Immer wenn mehr als ein Thread auf eine Statusvariable zugreift und einer der Threads möglicherweise darauf schreibt, müssen alle Threads ihren Zugriff mithilfe der Synchronisation koordinieren. Die Synchronisation in Java wird durch das synchronisierte Schlüsselwort bereitgestellt, das exklusive Sperren sowie flüchtige und atomare Variablen und explizite Sperren bietet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Widerstehen Sie der Versuchung zu glauben, dass es Situationen gibt, die keine Synchronisation erfordern. </font><font style="vertical-align: inherit;">Das Programm kann arbeiten und seine Tests bestehen, bleibt jedoch fehlerhaft und stürzt jederzeit ab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn mehrere Threads ohne ordnungsgemäße Synchronisierung mit einem mutierten Status auf dieselbe Variable zugreifen, funktioniert Ihr Programm nicht richtig. </font><font style="vertical-align: inherit;">Es gibt drei Möglichkeiten, dies zu beheben:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teilen Sie die Statusvariable nicht in allen Threads</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Zustandsvariable nicht veränderbar machen;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie die Statussynchronisation jedes Mal, wenn Sie auf die Statusvariable zugreifen.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korrekturen erfordern möglicherweise erhebliche Designänderungen. Daher ist es viel einfacher, eine Klasse sofort threadsicher zu entwerfen, als sie später zu aktualisieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ob mehrere Threads auf diese oder jene Variable zugreifen, ist schwer herauszufinden. Glücklicherweise helfen objektorientierte technische Lösungen, die beim Erstellen gut organisierter und einfach zu pflegender Klassen helfen, z. B. das Einkapseln und Ausblenden von Daten, auch beim Erstellen threadsicherer Klassen. Je weniger Threads Zugriff auf eine bestimmte Variable haben, desto einfacher ist es, die Synchronisierung sicherzustellen und die Bedingungen festzulegen, unter denen auf diese Variable zugegriffen werden kann. Die Java-Sprache zwingt Sie nicht dazu, den Status zu kapseln. Es ist durchaus akzeptabel, den Status in öffentlichen Feldern (auch in öffentlichen statischen Feldern) zu speichern oder einen Link zu einem Objekt zu veröffentlichen, das ansonsten intern ist. Je besser der Status Ihres Programms gekapselt ist, desto besser.Je einfacher es ist, Ihren Programm-Thread sicher zu machen und den Betreuern dabei zu helfen, dies auch so zu halten.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beim Entwerfen threadsicherer Klassen sind gute objektorientierte technische Lösungen: Kapselung, Veränderlichkeit und eine klare Spezifikation von Invarianten Ihre Assistenten.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn gute objektorientierte technische Designlösungen von den Anforderungen des Entwicklers abweichen, sollten Sie die Regeln für gutes Design aus Gründen der Leistung oder der Abwärtskompatibilität mit Legacy-Code opfern. </font><font style="vertical-align: inherit;">Manchmal stehen Abstraktion und Kapselung im Widerspruch zur Leistung - obwohl nicht so oft, wie viele Entwickler denken -, aber die beste Vorgehensweise besteht darin, den Code zuerst richtig und dann schnell zu machen. </font><font style="vertical-align: inherit;">Versuchen Sie, die Optimierung nur dann zu verwenden, wenn Messungen der Produktivität und der Anforderungen ergeben, dass Sie dies tun müssen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(2)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Wettbewerbscode sollten Sie diese Praxis noch mehr als üblich einhalten. Da Wettbewerbsfehler äußerst schwer zu reproduzieren und nicht einfach zu debuggen sind, kann der Vorteil eines geringen Leistungsgewinns bei einigen selten verwendeten Codezweigen im Vergleich zu dem Risiko, dass das Programm unter Betriebsbedingungen abstürzt, vernachlässigbar sein.</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie entscheiden, dass Sie die Kapselung aufheben müssen, geht nicht alles verloren. Ihr Programm kann immer noch threadsicher gemacht werden, aber der Prozess wird komplizierter und teurer und das Ergebnis ist unzuverlässig. Kapitel 4 beschreibt die Bedingungen, unter denen die Kapselung von Zustandsvariablen sicher verringert werden kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher haben wir die Begriffe "thread safe class" und "thread safe program" fast austauschbar verwendet. Ist ein thread-sicheres Programm vollständig aus thread-sicheren Klassen aufgebaut? Optional: Ein Programm, das vollständig aus threadsicheren Klassen besteht, ist möglicherweise nicht threadsicher, und ein threadsicheres Programm enthält möglicherweise Klassen, die nicht threadsicher sind. Probleme im Zusammenhang mit dem Layout threadsicherer Klassen werden auch in Kapitel 4 behandelt. In jedem Fall ist das Konzept einer threadsicheren Klasse nur dann sinnvoll, wenn die Klasse ihren eigenen Status kapselt. Der Begriff "Thread-Sicherheit" kann auf den Code angewendet werden, spricht jedoch vom Status und kann nur auf das Code-Array angewendet werden, das seinen Status kapselt (es kann sich um ein Objekt oder das gesamte Programm handeln).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Was ist Gewindesicherheit?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Definieren der Gewindesicherheit ist nicht einfach. </font><font style="vertical-align: inherit;">Eine schnelle Google-Suche bietet Ihnen zahlreiche Optionen wie diese: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... kann von mehreren Programm-Threads ohne unerwünschte Interaktionen zwischen Threads aufgerufen werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... kann von zwei oder mehr Threads gleichzeitig aufgerufen werden, ohne dass der Aufrufer eine andere Aktion ausführen muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Angesichts solcher Definitionen ist es nicht verwunderlich, dass wir die Thread-Sicherheit verwirrend finden! </font><font style="vertical-align: inherit;">Wie kann man eine thread-sichere Klasse von einer unsicheren Klasse unterscheiden? </font><font style="vertical-align: inherit;">Was meinen wir mit dem Wort "sicher"? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im Zentrum jeder vernünftigen Definition der Gewindesicherheit steht der Begriff der Korrektheit.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Korrektheit bedeutet, dass die Klasse ihrer Spezifikation entspricht. </font><font style="vertical-align: inherit;">Die Spezifikation definiert Invarianten, die den Zustand eines Objekts begrenzen, und Nachbedingungen, die die Auswirkungen von Operationen beschreiben. </font><font style="vertical-align: inherit;">Woher wissen Sie, dass die Spezifikationen für Klassen korrekt sind? </font><font style="vertical-align: inherit;">Auf keinen Fall, aber dies hindert uns nicht daran, sie zu verwenden, nachdem wir uns davon überzeugt haben, dass der Code funktioniert. </font><font style="vertical-align: inherit;">Nehmen wir also an, dass Single-Threaded-Korrektheit sichtbar ist. </font><font style="vertical-align: inherit;">Jetzt können wir davon ausgehen, dass sich die thread-sichere Klasse beim Zugriff von mehreren Threads korrekt verhält.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Klasse ist threadsicher, wenn sie sich beim Zugriff von mehreren Threads korrekt verhält, unabhängig davon, wie diese Threads von der Arbeitsumgebung geplant oder verschachtelt werden, und ohne zusätzliche Synchronisation oder andere Koordination seitens des aufrufenden Codes.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Multithread-Programm kann nicht threadsicher sein, wenn es selbst in einer Single-Thread-Umgebung nicht korrekt ist </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Wenn das Objekt korrekt implementiert ist, sollte keine Abfolge von Operationen - Zugriff auf öffentliche Methoden und Lesen oder Schreiben in öffentliche Felder - seine Invarianten oder Nachbedingungen verletzen. </font><font style="vertical-align: inherit;">Keine Reihe von Operationen, die sequentiell oder wettbewerbsfähig für Instanzen einer thread-sicheren Klasse ausgeführt werden, kann dazu führen, dass sich eine Instanz in einem ungültigen Zustand befindet. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(3) </font></font></b> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie hier die lose Verwendung des Begriffs Korrektheit stört, können Sie sich eine thread-sichere Klasse als eine Klasse vorstellen, die sowohl in einer Wettbewerbsumgebung als auch in einer Single-Thread-Umgebung fehlerhaft ist.</font></font></i><br>
 <br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-sichere Klassen kapseln alle erforderlichen Synchronisierungen selbst und benötigen nicht die Hilfe eines Clients.</font></font></blockquote><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1.1. </font><font style="vertical-align: inherit;">Beispiel: Servlet ohne interne Statusunterstützung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Kapitel 1 haben wir die Strukturen aufgelistet, die Threads erstellen und daraus Komponenten aufrufen, für deren Thread-Sicherheit Sie verantwortlich sind. </font><font style="vertical-align: inherit;">Jetzt beabsichtigen wir, einen Servlet-Faktorisierungsdienst zu entwickeln und dessen Funktionalität schrittweise zu erweitern, während die Thread-Sicherheit erhalten bleibt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1 zeigt ein einfaches Servlet, das eine Zahl aus einer Abfrage dekomprimiert, faktorisiert und die Ergebnisse als Antwort umschließt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.1. </font><font style="vertical-align: inherit;">Servlet ohne interne Zustandsunterstützung</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatelessFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die StatelessFactorizer-Klasse hat wie die meisten Servlets keinen internen Status: Sie enthält keine Felder und verweist nicht auf Felder aus anderen Klassen. </font><font style="vertical-align: inherit;">Der Status für eine bestimmte Berechnung ist nur in lokalen Variablen vorhanden, die im Stream-Stack gespeichert sind und nur dem ausführenden Stream zur Verfügung stehen. </font><font style="vertical-align: inherit;">Ein Thread, der auf StatelessFactorizer zugreift, kann das Ergebnis eines anderen Threads nicht beeinflussen, da diese Threads keinen gemeinsamen Status haben.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objekte ohne interne Statusunterstützung sind immer threadsicher.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass die meisten Servlets ohne interne Statusunterstützung implementiert werden können, reduziert die Belastung durch Threading der Servlets selbst erheblich. </font><font style="vertical-align: inherit;">Und nur wenn Servlets sich an etwas erinnern müssen, steigen die Anforderungen an ihre Gewindesicherheit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Atomizität</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was passiert, wenn ein Statuselement ohne interne Statusunterstützung zu einem Objekt hinzugefügt wird? Angenommen, wir möchten einen Trefferzähler hinzufügen, der die Anzahl der verarbeiteten Anforderungen misst. Sie können dem Servlet ein Feld vom Typ long hinzufügen und es bei jeder Anforderung erhöhen, wie in UnsafeCountingFactorizer in Listing 2.2 gezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.2. Ein Servlet, das Anforderungen ohne die erforderliche Synchronisierung zählt. Dies sollte nicht getan werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="Bild"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeCountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> count = <span class="hljs-number">0</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count; }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            ++count;<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist die UnsafeCountingFactorizer-Klasse nicht threadsicher, selbst wenn sie in einer Single-Thread-Umgebung einwandfrei funktioniert. Wie UnsafeSequence ist es anfällig für verlorene Updates. Obwohl die Anzahl der Inkrementoperationen ++ eine kompakte Syntax hat, ist sie nicht atomar, dh unteilbar, sondern eine Folge von drei Operationen: Liefern des aktuellen Werts, Hinzufügen eines Werts und Zurückschreiben des neuen Werts. Bei den Operationen "Lesen, Ändern, Schreiben" wird der resultierende Zustand vom vorherigen abgeleitet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In Abb. </font><font style="vertical-align: inherit;">1.1 Es wird gezeigt, was passieren kann, wenn zwei Threads gleichzeitig versuchen, den Zähler ohne Synchronisation zu erhöhen. </font><font style="vertical-align: inherit;">Wenn der Zähler 9 ist, sehen beide Threads aufgrund einer erfolglosen Zeitkoordination den Wert 9, addieren einen und setzen den Wert auf 10. Der Trefferzähler beginnt also um eins zu verzögern. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie könnten denken, dass ein leicht ungenauer Trefferzähler in einem Webdienst ein akzeptabler Verlust ist, und manchmal auch. </font><font style="vertical-align: inherit;">Wenn der Zähler jedoch zum Erstellen von Sequenzen oder eindeutigen Kennungen von Objekten verwendet wird, kann die Rückgabe des gleichen Werts aus mehreren Aktivierungen zu schwerwiegenden Datenintegritätsproblemen führen. </font><font style="vertical-align: inherit;">Die Möglichkeit des Auftretens falscher Ergebnisse aufgrund einer erfolglosen zeitlichen Koordination ergibt sich unter Rennbedingungen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Rennbedingungen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die UnsafeCountingFactorizer-Klasse hat mehrere Rennbedingungen </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Die häufigste Art von Rennbedingung ist die Situation „Prüfen und dann handeln“, in der anhand einer möglicherweise veralteten Beobachtung entschieden wird, was als nächstes zu tun ist. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(4)</font></font></b> <i>          (data race).   ,            .        ,    ,       ,   ,         ,      .               Java.       ,        ,             . UnsafeCountingFactorizer   .       16.</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Im wirklichen Leben begegnen wir oft einer Rennbedingung. Angenommen, Sie planen, mittags einen Freund im Starbucks Café am Universitetskiy Prospekt zu treffen. Aber Sie werden feststellen, dass es zwei Starbucks auf der University Avenue gibt. Um 12:10 Uhr sehen Sie Ihren Freund nicht in Café A und gehen in Café B, aber er ist auch nicht da. Entweder ist Ihr Freund zu spät oder er ist unmittelbar nach Ihrer Abreise im Café A angekommen, oder er war im Café B, hat Sie aber gesucht und ist jetzt auf dem Weg zum Café A. Wir werden das letztere akzeptieren, das heißt, den schlimmsten Fall. Jetzt, 12:15 Uhr, und Sie fragen sich beide, ob Ihr Freund sein Versprechen gehalten hat. Wirst du in ein anderes Café zurückkehren? Wie oft wirst du hin und her gehen? Wenn Sie sich nicht auf ein Protokoll geeinigt haben, können Sie den ganzen Tag in koffeinhaltiger Euphorie die University Avenue entlang spazieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Problem beim Ansatz „Gehen Sie spazieren und sehen Sie, ob er da ist“ besteht darin, dass ein Spaziergang entlang der Straße zwischen zwei Cafés mehrere Minuten dauert und sich während dieser Zeit der Zustand des Systems ändern kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Beispiel mit Starbucks zeigt die Abhängigkeit des Ergebnisses von der relativen zeitlichen Koordination der Ereignisse (davon, wie lange Sie in einem Café auf einen Freund warten usw.). </font><font style="vertical-align: inherit;">Die Beobachtung, dass er nicht in Café A ist, wird möglicherweise ungültig: Sobald Sie die Vordertür verlassen, kann er durch die Hintertür eintreten. </font><font style="vertical-align: inherit;">Die meisten Rennbedingungen verursachen Probleme wie eine unerwartete Ausnahme, überschriebene Daten und Dateibeschädigung.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Beispiel: Rennbedingungen bei verzögerter Initialisierung</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein häufiger Trick bei der Verwendung des Ansatzes „Prüfen und dann handeln“ ist die verzögerte Initialisierung (LazyInitRace). Ziel ist es, die Initialisierung des Objekts zu verschieben, bis es benötigt wird, und sicherzustellen, dass es nur einmal initialisiert wird. In Listing 2.3 stellt die Methode getInstance sicher, dass das ExpensiveObject initialisiert wird und eine vorhandene Instanz zurückgibt, oder erstellt auf andere Weise eine neue Instanz und gibt sie zurück, nachdem ein Verweis darauf beibehalten wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.3. Die Rennbedingung ist in einer trägen Initialisierung. Dies sollte nicht getan werden.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ge/lj/hg/geljhgzyo9aogxu-ttztrzuawqo.jpeg" alt="Bild"></div><br>
<pre><code class="java hljs"><span class="hljs-meta">@NotThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyInitRace</span> </span>{
      <span class="hljs-keyword">private</span> ExpensiveObject instance = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> ExpensiveObject <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>)<font></font>
                instance = <span class="hljs-keyword">new</span> ExpensiveObject();
            <span class="hljs-keyword">return</span> instance;<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die LazyInitRace-Klasse enthält Rennbedingungen. Angenommen, die Threads A und B führen gleichzeitig die Methode getInstance aus. A erkennt, dass das Instanzfeld null ist, und erstellt ein neues ExpensiveObject. Thread B prüft auch, ob das Instanzfeld dieselbe Null ist. Das Vorhandensein von Null im Feld zu diesem Zeitpunkt hängt von der Zeitkoordination ab, einschließlich der Planungsschwankungen und der Zeit, die erforderlich ist, um eine Instanz des ExpensiveObject zu erstellen und den Wert im Instanzfeld festzulegen. Wenn das Instanzfeld bei der Überprüfung durch B null ist, können zwei Codeelemente, die die Methode getInstance aufrufen, zwei unterschiedliche Ergebnisse erzielen, selbst wenn die Methode getInstance immer dieselbe Instanz zurückgeben soll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Trefferzähler in UnsafeCountingFactorizer enthält auch die Rennbedingungen. Der Ansatz "Lesen, Ändern, Schreiben" impliziert, dass der Stream zum Erhöhen des Zählers seinen vorherigen Wert kennen und sicherstellen muss, dass niemand diesen Wert während des Aktualisierungsprozesses ändert oder verwendet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie die meisten Wettbewerbsfehler führen die Rennbedingungen nicht immer zum Scheitern: Die vorübergehende Koordination ist erfolgreich. </font><font style="vertical-align: inherit;">Wenn die LazyInitRace-Klasse jedoch zum Instanziieren der Registrierung der gesamten Anwendung verwendet wird, gehen Registrierungen verloren, wenn verschiedene Instanzen aus mehreren Aktivierungen zurückgegeben werden, oder Aktionen erhalten widersprüchliche Darstellungen der Gruppe registrierter Objekte. </font><font style="vertical-align: inherit;">Wenn die UnsafeSequence-Klasse zum Generieren von Entitätskennungen in einer Datenerhaltungsstruktur verwendet wird, können zwei verschiedene Objekte dieselbe Kennung haben, wodurch Identitätsbeschränkungen verletzt werden.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Zusammengesetzte Aktionen</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sowohl LazyInitRace als auch UnsafeCountingFactorizer enthalten eine Folge von Operationen, die atomar sein müssen. </font><font style="vertical-align: inherit;">Um jedoch eine Race-Bedingung zu verhindern, muss es für andere Threads ein Hindernis geben, die Variable zu verwenden, während ein Thread sie ändert.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Operationen A und B sind atomar, wenn aus Sicht des Threads, der Operation A ausführt, Operation B entweder vollständig von einem anderen Thread ausgeführt oder nicht einmal teilweise ausgeführt wurde.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Atomizität der Inkrementoperation in UnsafeSequence würde die in Abb. 1 gezeigte Racebedingung vermeiden. 1.1. Die Operationen "prüfen und dann handeln" und "lesen, ändern, schreiben" sollten immer atomar sein. Sie werden zusammengesetzte Aktionen genannt - Abfolgen von Operationen, die atomar ausgeführt werden müssen, um threadsicher zu bleiben. Im nächsten Abschnitt werden wir uns mit dem Sperren befassen - einem in Java integrierten Mechanismus, der Atomizität bietet. In der Zwischenzeit werden wir das Problem auf andere Weise beheben, indem wir die vorhandene thread-sichere Klasse anwenden, wie im Countingfactorizer in Listing 2.4 gezeigt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Listing 2.4. Servlet-Zählanforderungen mit AtomicLong</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@ThreadSafe</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountingFactorizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Servlet</span> </span>{
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicLong count = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> count.get(); }<font></font>
<font></font>
      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(ServletRequest req, ServletResponse resp)</span> </span>{<font></font>
            BigInteger i = extractFromRequest(req);<font></font>
            BigInteger[] factors = factor(i);<font></font>
            count.incrementAndGet();<font></font>
            encodeIntoResponse(resp, factors);<font></font>
      }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Paket java.util.concurrent.atomic enthält atomare Variablen zum Verwalten von Klassenzuständen. Durch Ersetzen des Zählertyps von long auf AtomicLong garantieren wir, dass alle Aktionen, die sich auf den Status des Zählers beziehen, atomar1 sind. Da der Status des Servlets der Status des Zählers ist und der Zähler threadsicher ist, wird unser Servlet threadsicher. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein einzelnes Statuselement zu einer Klasse hinzugefügt wird, die den internen Status nicht unterstützt, ist die resultierende Klasse threadsicher, wenn der Status vollständig vom threadsicheren Objekt gesteuert wird. Wie wir im nächsten Abschnitt sehen werden, ist der Übergang von einer Zustandsvariablen zur nächsten nicht so einfach wie der Übergang von Null zu Eins.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden Sie gegebenenfalls vorhandene thread-sichere Objekte wie AtomicLong, um den Status Ihrer Klasse zu steuern. </font><font style="vertical-align: inherit;">Mögliche Zustände vorhandener thread-sicherer Objekte und deren Übergänge in andere Zustände sind einfacher zu pflegen und auf Thread-Sicherheit zu prüfen als beliebige Zustandsvariablen.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
»Weitere Informationen zum Buch finden Sie auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Website des Herausgebers.</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Inhalt</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
» </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Auszug</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
für Khabrozhiteley 25% Rabatt auf den Gutschein - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Java</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Nach Zahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de489022/index.html">Verwenden von RabbitMQ mit MonsterMQ Teil 2</a></li>
<li><a href="../de489024/index.html">Webix JavaScript-Bibliothek mit den Augen eines Anfängers. Teil 5. Arbeiten Sie mit Daten auf der Benutzerseite</a></li>
<li><a href="../de489026/index.html">Das Ändern der Google AdSense-Algorithmen kann zu Website-Eigentümern und Webmastern führen</a></li>
<li><a href="../de489028/index.html">Über Fernarbeit</a></li>
<li><a href="../de489034/index.html">Die neue mobile UIS-App oder -Rettung für diejenigen, die ein öffentliches Beschaffungswesen suchen?</a></li>
<li><a href="../de489040/index.html">Contact Center AI: Dritte im Gespräch sind in Ordnung</a></li>
<li><a href="../de489042/index.html">Große Wiedereröffnung des Stores: Laden von Daten mit Coroutine in Android</a></li>
<li><a href="../de489044/index.html">Physik des Textes. Teil 1. Symbole</a></li>
<li><a href="../de489046/index.html">Selbstfahrender GAZ66 Monster Truck 1/16</a></li>
<li><a href="../de489048/index.html">Protokollierung und Abfrageverfolgung sind bewährte Methoden. Yandex-Bericht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>