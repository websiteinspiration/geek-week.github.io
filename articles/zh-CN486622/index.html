<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚁 🕳️ 👨🏼‍🤝‍👨🏻 并行计算模型 🏚️ 👨🏾‍⚖️ 👨🏼‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.简介。竞争性的白痴症
 以前有关自动编程的文章只是“花”。自动编程的“浆果”，即对于您需要做的是基于状态机模型的并行计算模型。因此，让我们开始吧…… 
 
 C ++标准包括了人们期待已久的对多线程的支持[1]。但是我们既不会赞美它，也不会批评这个事实，因为在如此多的条件，注意事项和功能的共同作...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>并行计算模型</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486622/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.简介。</font><font style="vertical-align: inherit;">竞争性的白痴症</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前有关自动编程的文章只是“花”。自动编程的“浆果”，即对于您需要做的是基于状态机模型的并行计算模型。因此，让我们开始吧…… </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++标准包括了人们期待已久的对多线程的支持[1]。但是我们既不会赞美它，也不会批评这个事实，因为在如此多的条件，注意事项和功能的共同作用下，使用线程的工作受到很大的影响，如果没有现实生活中的例子揭示多线程问题，那么对多线程编程的讨论将不仅草率，而且也带有偏见。因此，在下文中，主要不是自动流动，而是自动机，当然首先要牢记。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++语言与并行语言结构相辅相成。早在上世纪60年代，N。Wirth提出了ALGOL语言的并行扩展[2]。但是，未来60年仍未弄清应将什么视为并行算法以及应将什么作为并行计算模型。显然，C ++语言的这种迟来的扩展也与此相关。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ALGOL语言的长期结构及其在C ++语言中更现代的类似物，都仅表示不引入并行算法模型的结构并行化方法。为了证明这一点，可以说，过去一段时间来创建这种正式的计算模型的尝试都失败了。可以说，同样的陪替氏网络并不能证明人们寄予厚望。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
结果，并行性发展的“螺旋”似乎已经回到其源头，仅经历了“术语发展”。</font><font style="vertical-align: inherit;">前琐碎的协程突然变成了高级的“协程”（英语协程的描图纸），并且在并行编程的英语部分中对并行和并发的概念的混淆有时会导致自相矛盾的事情。</font><font style="vertical-align: inherit;">例如，本书[1]的第一版与第二版的不同之处在于，将“并行”替换为“竞争性”，将“多线程”替换为“并行”。</font><font style="vertical-align: inherit;">因此，在“谁是谁”的情况下弄清楚这一点。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.并行自动机计算模型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可能没有人会怀疑编程开发中的下一个定性步骤与向并行计算模型的转换有关。但是，这是否会因现有计算模型的进化发展而发生，或者是否将是根本不同的模型，仍在讨论中。而且如果理论家仍在争论，那么程序员的实际动力已经在使用结构化方法来并行化程序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
职责分离和提高生产率被认为是使用并发的唯一原因。至少，它们或它们的组合最终会减少或尝试减少所有其他[1]。但是有一个很少被谈论的原因，但是由于这个原因，通常值得进行并行编程。确实，可以通过纯粹的硬件方法来提高速度，并且通过并行执行职责分离与银行雇员的日常工作以列出其正式职责的方式相同。而且只有并行算法才能使我们克服任务的复杂性并提高程序的可靠性。所有这些都与关于多线程编程的普遍观点相反，后者将任何并行程序变成了复杂且不可靠的软件产品。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并行系统由许多具有并行功能且主动交互的组件，对象，代理等组成，它实现的算法的确定方式并非由各个组件的算法确定（尽管它们当然是），而是由组件的数量，数量和他们之间的联系。为了控制这种复杂性并理解并行系统操作算法，您不仅需要并行计算模型，还需要具有（尤其是）适当理论的模型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
轻率地说，“并行程序常常更难理解……因此错误的数量在增加”这一论点值得商bat。</font><font style="vertical-align: inherit;">是的，并行程序算法可能很难理解，但是如果有一个理论，可以使用组件算法对其进行“计算”。</font><font style="vertical-align: inherit;">从设计的角度来看，组件算法的实现和维护要比整个系统的算法简单得多。</font><font style="vertical-align: inherit;">当设计更简单的组件时，显然，与设计一个系统相比，我们犯的错误更少。</font><font style="vertical-align: inherit;">此外，调试后的组件可以成为其他系统的一部分，从而降低了复杂性，提高了可靠性并最小化了其设计成本。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3.串行并发</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
文章[3]描述了一个有限状态机模型的并行性。它在转换执行级别的通道指定与其关联的功能/方法（谓词和动作）的并行执行。同时，对谓词并行性没有任何限制。在工作时，它们不会相互冲突，因为不会影响内存的内容。并行操作的动作可以具有共同的输入和输出数据，也可以彼此独立地进行更改。所有这些都可能成为输出数据值不确定性的来源。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在上述情况下正确执行操作可提供影子存储。</font><font style="vertical-align: inherit;">通过在其中存储新值，甚至可以在一个动作中使用相同的数据作为输入和输出。</font><font style="vertical-align: inherit;">一个例子是矩形脉冲发生器的模型，描述为y =！Y，其中y是发生器的输出。</font><font style="vertical-align: inherit;">清单1中显示了它在VKPa环境中的C ++代码，该程序的结果如图1所示。</font><font style="vertical-align: inherit;">1。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单1.矩形脉冲发生器</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenerator</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FSWGenerator(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FSWGenerator(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenerator.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_SWGenerator[] = {<font></font>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"y1"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FSWGenerator::FSWGenerator(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenerator, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{<font></font>
    pTAppCore = pInfo;<font></font>
}<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FSWGenerator::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<span class="hljs-comment">// setting output signals</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FSWGenerator::y1</span><span class="hljs-params">()</span> </span>{<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, !<span class="hljs-keyword">bool</span>(pVarY-&gt;GetDataSrc()));<font></font>
}<font></font>
</code></pre><br>
</div></div><br>
 <img src="https://habrastorage.org/webt/3f/ue/ni/3fueni68ys5fwldckqdbodllckm.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 1.在VKPA中模拟矩形脉冲发生器的操作</font></font><br>
</i><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
在这种情况下，电机具有一种状态，该状态具有以条件y1标记的循环形式的无条件过渡（以破折号代替输入条件的过渡），该状态实现了输出变量的反转，从而在动力学中形成了矩形脉冲。在自动机模型的框架内，可以通过设置自动机加载到其中的自动机空间的离散时间的间歇值来控制脉冲信号的频率。</font></font><br>
<br>
<i> 1.          ,   .              .        .         .<br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
控制自动机离散时间和存在许多自动机空间的能力不是VKPa环境的唯一但重要的独特属性。</font><font style="vertical-align: inherit;">使用它们，您可以优化并行程序的性能。</font><font style="vertical-align: inherit;">例如，应将实现数据可视化和用户对话的机器放置在缓慢的自动机空间中，并应根据优先级及其所需的速度等在自动机空间中分配应用程序进程。</font><font style="vertical-align: inherit;">等等 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在自动机模型的框架内，发生器输出的值很容易与模型的当前状态相关。</font><font style="vertical-align: inherit;">清单2显示了生成器模型的代码，该代码已经具有两个状态，每个状态都反映了生成器输出的状态。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单2.状态上的方波发生器</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-keyword">extern</span> LArc TBL_SWGenState[];
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FSWGenState</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:<font></font>
    FSWGenState(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_SWGenState, strNam, <span class="hljs-literal">nullptr</span>, pCVFL) {};<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FSWGenState.h"</span></span>
<span class="hljs-comment">// state machine transition table</span><font></font>
LArc TBL_SWGenState[] = {<font></font>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"--"</span>,	<span class="hljs-string">"--"</span>),			<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在新模型中，状态替换了输出变量，可以看出，这大大简化了生成器模型。</font><font style="vertical-align: inherit;">结果，我们得到了一台“裸机”，仅由转换表表示。</font><font style="vertical-align: inherit;">为了在VKPa中监视其当前状态“ s1”，为名称为SWGenState的计算机创建了fsa（状态）类型的变量，名称为SWGenState（S1）。</font><font style="vertical-align: inherit;">在状态s1中，它的值为true；在机器处于其他状态时，其值为false。</font><font style="vertical-align: inherit;">此外，该变量已经通过显示VKPA环境的数据使用（请参见图2中的信号趋势）。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xv/it/jp/xvitjpkfffsmaodeyax2cmeotkq.jpeg" alt="图片"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。</font><font style="vertical-align: inherit;">2.对状态生成器建模</font></font><br>
</i><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4.并行计算控制模型</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，朝着建立并行过程模型的方向发展，使用许多同时起作用并相互作用的有限状态机是合乎逻辑的。自动机网络。在这种情况下，会出现选择网络时间模型的问题，该问题对于所有机器可能都是相同的，或者在限制范围内，每个机器都可能是单个的。在VKPa中，选择时倾向于一次（有关自动机同步网络的更多详细信息，请参见[5]）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一次的选择允许您创建具有自动机的合成和分解操作的自动机代数。使用第一个，您可以找到生成的自动机，它给出了并行系统操作的准确概念。这里值得回顾一下关于并行程序的“理解的复杂性”的论文。合成操作的存在使我们能够解决并行程序的“理解问题”。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，由大量组件组成的网络所产生的自动机可能非常庞大。但是，幸运的是，更经常需要了解少量组件的子系统或网络的操作，为此，找到最终的自动机不会引起大问题。下面的RS触发器模型示例对此进行了演示。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RS触发模型是简单并行系统的一个示例。在存在交叉反馈的情况下，这尤其有趣。反馈或循环链，循环，代数循环等。对于并行系统的结构模型，当前是一个严重的问题。在一般情况下，可以通过引入存储元件的间隙环来实现。这是自动机理论提出的标准解决方案[4]。建议在MATLAB方面使用相同的输出。 VKPa环境的不同之处在于，它不需要引入此类其他元素即可实现循环。请注意，这非常重要，实际电路也不需要它们（请参阅RS触发器电路）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图。</font><font style="vertical-align: inherit;">图3给出了AND-NOT元素的最简单模型，它由RS触发电路组成。</font><font style="vertical-align: inherit;">它不考虑元素延迟及其类型（运输或惯性延迟）。</font><font style="vertical-align: inherit;">但是，它仍然包含至少一个延迟节拍。</font><font style="vertical-align: inherit;">这是从一种状态过渡到另一种状态的时间。</font><font style="vertical-align: inherit;">清单3显示了模型代码</font></font><br>
<br>
<img src="https://habrastorage.org/webt/os/8b/am/os8bam0skdc-jwtctewqmbwupci.jpeg" alt="图片"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">3.元素的模型AND NOT</font></font></i><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单3.元素模型AND NOT</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FIne</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FIne(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FIne(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y2</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FIne.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_Ine[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x1"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12^x2"</span>,	<span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x12x1x2"</span>,	<span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s0"</span>,<span class="hljs-string">"x1x2"</span>,   <span class="hljs-string">"y2"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x1"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s0"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"^x2"</span>,    <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FIne::FIne(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_Ine, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FIne::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>){pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x1</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x2</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc()); }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FIne::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y1</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">1</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y2</span><span class="hljs-params">()</span> </span>{ pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0.0</span>); }
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FIne::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在图。图4以有限状态机的形式示出了RS触发器及其模型的图。模型上的箭头指示网络自动机之间的连接。在这里，一方面，模型的状态反映了元素输出的状态，另一方面，它们也用作组织并行过程之间信息链接的信号。正是这种形式的模型（通过状态进行同步）使得找到网络的自动机变得非常容易。如图所示。 5（有关查找结果自动机的过程，请参见[6]以获取更多详细信息）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比较并行RS触发器程序的[结果]算法和单独的AND-NOT元素的运算算法。区别是惊人的。在这种情况下，组件算法是由“句柄”创建的，而并行系统算法是由网络的“人工智能”隐式创建的。这是并行程序和顺序程序之间的质的区别：仅更改通信（至少一个），我们将获得完全不同的工作算法。而且，它将绝对不再是RS触发器。顺便说一下，还有另一个自动机。</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/kb/zi/fc/kbzifcjk_ycehmabwwtsuh_gyfc.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 4.方案的RS-FF和网络模型的</font></font><br>
</i><br>
<img src="https://habrastorage.org/webt/_v/ht/2n/_vht2nka0gtsreim8qhjplh_njq.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 5.生成的机器网络模型RS触发</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图中生成的自动机的分析。图5给出了并行程序的以下“理解”（当然还有真正的触发器）。首先，当从一种状态切换到另一种状态时，触发器必然会经过输出的“禁止”状态（教科书对此有何评论？）。其次，如果将触发器驱动到单个输出状态（状态为“ s1w1”），然后将两个单元馈入输入，则它将进入生成模式，即状态“ s1w1”和“ s0w0”之间的循环切换（您是否听说过触发器的产生？）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在真实触发中也会发生通过禁止状态的转换，但是由于真实元素的延迟差异，生成模式是不可能的。图。图6显示了触发触发模型的生成模式，只要存储输入中的单位就存在。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">备注2.在绝大多数情况下，以真值表的形式给出了RS触发操作的典型描述。但是，这样做是要理解触发器是一个顺序方案，实际上，这是故意误导那些研究此主题的人。好吧，没有触发器不能有“禁止状态”！但是出于某种原因，只有少数人决定发现这个真理，尤其是讨论其产生的问题（例如，参见[7]）。</font></font><br>
</i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
图。图7示出了触发模型在其稳定状态之间的切换。此处，触发器输入的单个状态保留了触发器输出的当前状态，并且当该输入或那个输入设置为零时，它将切换到相反的状态。同时，当触发器被切换时，它的输出等于一个离散量，此刻同时处于单个（被谁禁止？）状态。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cs/fl/a0/csfla0xnbcpz0ngewn6izuj_cps.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 6. RS-触发生成模式</font></font></i><br>
<br>
<img src="https://habrastorage.org/webt/nc/w5/74/ncw574s_lxpj2qq4oh1krswiclk.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图。 7.在状态之间切换RS触发</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑另一种由一个状态和一个动作组成的RS触发模型，即 </font><font style="vertical-align: inherit;">类似于清单1中的模型。清单4中显示了其代码。该模型与生成器模型一样，没有谓词，并且没有任何中间转换的信号值被输入到动作y1。</font><font style="vertical-align: inherit;">这是好事还是坏事？</font><font style="vertical-align: inherit;">一方面，这似乎很好，因为 </font><font style="vertical-align: inherit;">代码变得更简单了，但是另一方面...并非如此。</font><font style="vertical-align: inherit;">我们现在将了解其原因。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">清单4.一个动作的NAND元素模型</font></font></b><div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"lfsaappl.h"</span></span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FTwoOperators</span> :</span>
    <span class="hljs-keyword">public</span> LFsaAppl<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">LFsaAppl* <span class="hljs-title">Create</span><span class="hljs-params">(CVarFSA *pCVF)</span> </span>{ Q_UNUSED(pCVF)<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FTwoOperators(pTAppCore, nameFsa, pCVarFsaLibrary); }
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FCreationOfLinksForVariables</span><span class="hljs-params">()</span></span>;<font></font>
    FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL);
    <span class="hljs-keyword">virtual</span> ~FTwoOperators(<span class="hljs-keyword">void</span>) {};<font></font>
    CVar *pVarX1;				<span class="hljs-comment">//  </span>
    CVar *pVarX2;				<span class="hljs-comment">//  </span>
    CVar *pVarY;				<span class="hljs-comment">//  </span>
    CVar *pVarStrNameX1;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameX2;		<span class="hljs-comment">//    </span>
    CVar *pVarStrNameY;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">x12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y1</span><span class="hljs-params">()</span></span>; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">y12</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">bool</span> bX1, bX2, bY;<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"FTwoOperators.h"</span></span>
<span class="hljs-comment">// state machine transition table</span>
<span class="hljs-keyword">static</span> LArc TBL_TwoOperators[] = {<font></font>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"st"</span>,<span class="hljs-string">"^x12"</span>,<span class="hljs-string">"y12"</span>), 		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"st"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"x12"</span>, <span class="hljs-string">"--"</span>),		<span class="hljs-comment">//</span>
    LArc(<span class="hljs-string">"s1"</span>,		<span class="hljs-string">"s1"</span>,<span class="hljs-string">"--"</span>,  <span class="hljs-string">"y1"</span>),		<span class="hljs-comment">//</span><font></font>
    LArc()<font></font>
};<font></font>
<font></font>
FTwoOperators::FTwoOperators(TAppCore *pInfo, <span class="hljs-built_in">string</span> strNam, CVarFsaLibrary *pCVFL):<font></font>
    LFsaAppl(TBL_TwoOperators, strNam, <span class="hljs-literal">nullptr</span>, pCVFL)<font></font>
{ }<font></font>
<span class="hljs-comment">// creating local variables and initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">FTwoOperators::FCreationOfLinksForVariables</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// creating local variables</span>
    pVarX1 = CreateLocVar(<span class="hljs-string">"x1"</span>, CLocVar::vtBool, <span class="hljs-string">" 1- "</span>);<font></font>
    pVarX2 = CreateLocVar(<span class="hljs-string">"x2"</span>, CLocVar::vtBool, <span class="hljs-string">" 2- "</span>);<font></font>
    pVarY = CreateLocVar(<span class="hljs-string">"y"</span>, CLocVar::vtBool, <span class="hljs-string">" "</span>);<font></font>
    pVarStrNameX1 = CreateLocVar(<span class="hljs-string">"strNameX1"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x1)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameX2 = CreateLocVar(<span class="hljs-string">"strNameX2"</span>, CLocVar::vtString, <span class="hljs-string">"name of external input variable(x2)"</span>);			<span class="hljs-comment">//   </span>
    pVarStrNameY = CreateLocVar(<span class="hljs-string">"strNameY"</span>, CLocVar::vtString, <span class="hljs-string">"name of external output variable(y)"</span>);		<span class="hljs-comment">//   </span>
<span class="hljs-comment">// initialization of pointers</span>
    <span class="hljs-built_in">string</span> str;
    <span class="hljs-keyword">if</span> (pVarStrNameX1) {<font></font>
        str = pVarStrNameX1-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX1 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameX2) {<font></font>
        str = pVarStrNameX2-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarX2 = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>); }<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span> (pVarStrNameY) {<font></font>
        str = pVarStrNameY-&gt;strGetDataSrc();<font></font>
        <span class="hljs-keyword">if</span> (str != <span class="hljs-string">""</span>) { pVarY = pTAppCore-&gt;GetAddressVar(str.c_str(), <span class="hljs-keyword">this</span>);	}<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FTwoOperators::x12</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> pVarX1 != <span class="hljs-literal">nullptr</span> &amp;&amp; pVarX2 &amp;&amp; pVarY; }<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y1</span><span class="hljs-params">()</span> </span>{
<span class="hljs-comment">// reading input signals</span>
    bX1 = <span class="hljs-keyword">bool</span>(pVarX1-&gt;GetDataSrc());<font></font>
    bX2 = <span class="hljs-keyword">bool</span>(pVarX2-&gt;GetDataSrc());
<span class="hljs-comment">// setting output signals</span><font></font>
    bY = !(bX1&amp;&amp;bX2);<font></font>
    pVarY-&gt;SetDataSrc(<span class="hljs-literal">nullptr</span>, bY);<font></font>
}<font></font>
<span class="hljs-comment">// initialization of pointers</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FTwoOperators::y12</span><span class="hljs-params">()</span> </span>{ FInit(); }
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果我们在“影子内存”模式下测试新模型，那么我们将不会发现它与前一个模型的操作有任何不同，即，切换后，它将进入禁止状态并定期进入发电模式。如果我们以通常的方式设置数据的工作，我们将得到如图10所示的结果。 8和图。 9. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/to/mc/ib/tomcibxvaq2mae2kxxqc5clwits.jpeg" alt="图片"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图8. RS触发模型的生成模式失败</font></font></i><br>
 <br>
<img src="https://habrastorage.org/webt/pu/qt/5y/puqt5yws1udobr_volkpcm7r4dm.jpeg" alt="图片"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 9.通过RS触发</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
模型</font><i><font style="vertical-align: inherit;">跳过禁止状态</font></i><font style="vertical-align: inherit;">为什么第一个模型，无论使用内存的工作方式如何，都会显示稳定的结果，而第二个模型会改变行为？原因是谓词。第二个模型没有谓词，这对其行为至关重要。但是谓词的存在/不存在如何以及为什么影响并行程序操作算法？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
像自动机程序一样，AND-NOT元素的程序模型具有两个输入通道和一个输出通道。它们必须匹配两个谓词和一个动作。第一个程序与此完全一致。解释自动机描述的VKPa内核不仅执行特定自动机的所有谓词，还执行整个自动机空间的所有谓词，然后才执行所有操作。在这种情况下，以何种顺序执行动作，模拟并行性，以及它们在内存中使用的任何模式下，自动机当前时钟周期的谓词结果均不取决于它们（动作）。因此，第一个程序产生相同的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个程序尽管直接与机器的输入通道一起使用，但作为操作的一部分，读取输入信号。</font><font style="vertical-align: inherit;">动作在影子存储器模式下使用输入数据，将新值写入影子存储器，从而使用在离散时钟周期开始时有效的数据。</font><font style="vertical-align: inherit;">在通常模式下，它们会``抓住''更改时建立的瞬时值，因此算法变得依赖于内存更改的时刻。</font><font style="vertical-align: inherit;">第二个程序证明了类似的依赖性。</font><font style="vertical-align: inherit;">即使将谓词方法引入第二个模型，也不会对其工作结果产生任何影响。</font><font style="vertical-align: inherit;">这里重要的不是谓词方法的存在，而是它们在自动机编程模型框架中的工作特征。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5。结论</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以并行RS触发程序为例，我们检查了任何并行程序固有的一些属性。</font><font style="vertical-align: inherit;">我们将继续考虑并行程序功能的某些一般方面，作为逻辑（数字）电路的示例。</font><font style="vertical-align: inherit;">在此处选择数字电路建模的主题并非偶然。</font><font style="vertical-align: inherit;">实际上，它们以“改进的形式”表示并行过程的工作。</font><font style="vertical-align: inherit;">这将分析并发，竞争，同步，死胡同等细微差别。</font><font style="vertical-align: inherit;">等透明，清晰，简单。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，无论您如何称呼编程（“竞争”或并行），无论您使用“协程”，协程，线程还是机器进行编程，在所有实现中，[并行]程序的结果都必须相同。</font><font style="vertical-align: inherit;">在CPSU框架内的并行程序自动模型追求的是这个目标，也只有这个目标。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无论对VKPa环境的自动机解释的核心实现方式做出何种假设，所有这些都是“推测”，因为自动程序的工作结果不应与计算模型的实现相关联。它可以是软件（如现在）或硬件（如我希望的那样），可以在一个内核或它们的集合上实现，可以是单线程或多线程版本等。等等所有这些都不会影响并行自动程序的结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且，似乎已经实现了目标。</font><font style="vertical-align: inherit;">作为并行系统可能的测试之一[8]，RS-trigger模型使我们相信了这一点...正如生活所示，所有其他并行程序，只要环境已成功通过RS-trigger测试并行性实现，就可以正确，可靠且稳定地工作。 。</font><font style="vertical-align: inherit;">顺便说一句，没有通过相同的MATLAB“ RS触发测试”，这已经说明了很多……</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献</font></font></b><div class="spoiler_text">1.  .    ++  .    . .  .  .. – .:  , 2012. – 672 . <br>
2.  .    : .  . – .: , 1981. – 360 .<br>
3.    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">habr.com/ru/post/484588</a> . . . (  07.01.2020).<br>
4.  ..   . .: , 1962.<br>
5.  .., - ..    . – 2- ., .  . – .:  , 1988. – 480 .<br>
6.  ..    . [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">cloud.mail.ru/public/HwsK/T95PMM8Ed</a> . . . (  01.02.2020).<br>
7.  .    . 2-  . – .: , 2004. – 432.<br>
8.  ..   ? “ ”, №10/97, .116-119. [ ],  : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">www.osp.ru/pcworld/1997/10/158015</a> . . . (  01.02.2020).<br>
</div></div></div>
      
    </div><p class="reference-to-source js-reference-to-source">Source: https://habr.com/ru/post/undefined/</p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN486598/index.html">Jupyter Notebook中的微控制器实验</a></li>
<li><a href="../zh-CN486602/index.html">Svelte社区资料摘要（1月16日至2月1日）</a></li>
<li><a href="../zh-CN486604/index.html">不，动态类型系统基本上不再开放</a></li>
<li><a href="../zh-CN486608/index.html">世界上最有效的情报服务情报中的基本助手（第2部分）</a></li>
<li><a href="../zh-CN486614/index.html">为什么需要eSIM。它是如何工作的，为什么他们这么多谈论它</a></li>
<li><a href="../zh-CN486626/index.html">苗条：认识动作</a></li>
<li><a href="../zh-CN486628/index.html">gnuplot中轴上的刻度线之间的固定距离</a></li>
<li><a href="../zh-CN486630/index.html">“不要眨眼”：电子阅读器的屏幕照明技术是如何安排的</a></li>
<li><a href="../zh-CN486632/index.html">主管的心理反应性编程模型</a></li>
<li><a href="../zh-CN486634/index.html">Visual Studio 2019版本16.3和16.4中的MSVC后端更新</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>