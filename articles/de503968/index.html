<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💃🏻 💰 🌦️ Wie kann man den Roboter genau bewegen? Übersicht und Funktionen der Studuino Platform Robotics 👨🏾 🎺 🏂🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Die Organisation, in der ich arbeite, wurde gebeten, ein kleines Robotik-Webinar für den Moskauer Internationalen Bildungssalon 2020 abzuhalten, das i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Wie kann man den Roboter genau bewegen? Übersicht und Funktionen der Studuino Platform Robotics</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/503968/"><img src="https://habrastorage.org/webt/tv/1x/rr/tv1xrr8dyui1j9kgp12ampq04z4.jpeg" alt="Bild"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Organisation, in der ich arbeite, wurde gebeten, ein kleines Robotik-Webinar für den Moskauer Internationalen Bildungssalon 2020 abzuhalten, das in einem Online-Format abgehalten wurde. Das Thema der Präsentation wurde mir offen gelassen und mit einem Lehrgang über Robotik versehen. Also habe ich Produkte des japanischen Unternehmens </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArTeC kennengelernt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (dies ist keine Werbung und ich bin kein Mitarbeiter von ArTeC - es ist nur meine persönliche Erfahrung aus der Kommunikation mit ihren Produkten). Nach dem Webinar habe ich beschlossen, diesen Artikel zu schreiben, da in Russland Kits von Lego Education sehr beliebt waren und ich zum ersten Mal auf diesen japanischen Designer stieß.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Artikel ist in zwei Teile gegliedert. </font><font style="vertical-align: inherit;">Der erste Teil ist nützlich für diejenigen, die ein Kit für pädagogische Robotik wählen. </font><font style="vertical-align: inherit;">Im zweiten Teil untersuchte ich die Verwendung eines Kits zur Lösung eines angewandten Problems, das im Leben auftreten kann. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn sich jemand dafür interessiert, was für ein Roboter-Kit es ist und was damit gemacht werden kann, bitte ich um eine Katze. </font><font style="vertical-align: inherit;">So lass uns gehen!</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Gebäudebasis verwendet der Designer nur wenige grundlegende Teile, aus denen Sie recht komplexe Strukturen zusammensetzen können. </font><i><b><font style="vertical-align: inherit;">Beispielmodelle von </font></b></i></font><br>
<br>
<img src="https://habrastorage.org/webt/-f/wo/fc/-fwofcl47qvnsp3yktrthob23fk.jpeg" alt="ArTeC Designer-Basisblöcke"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArTeC Designer-Basisblöcken </font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/88/y5/x_/88y5x_wap5y9pfk89w0s2d_kclm.jpeg" alt="Bild"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aus Designer-Teilen</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aufgrund der Besonderheiten der Teile - der versetzten Reihenfolge der Löcher und Spitzen für die Verbindung - ist es nicht immer schnell, die richtige Kombination von Teilen zu finden, um das Ergebnis zu erzielen. Von den Vorteilen im Gegensatz zu Lego: Alle Teile sind groß genug, was den Verlust erheblich erschwert. Das zweite Plus ist, dass Sie nicht lange auf der Suche nach dem erforderlichen Teil herumwühlen müssen, da es nur 5-6 Teile der Basisteile gibt (der Unterschied in der Farbe der Teile zählt nicht). Es gibt ein Minus - solange die Teile völlig neu sind, wird ihre Trennung manchmal zu Qualen -, so dass sie fest aneinander haften. Um sie zu lösen, ist ein spezielles Werkzeug im Kit enthalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusätzlich zu den Grundblöcken im Set gibt es verschiedene Arten von Rädern und Zahnrädern sowie eine Zahnstange.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nun zu dem, was im elektronischen Teil dieses Roboterkits enthalten ist. Die japanische Website enthält eine relativ große Anzahl verschiedener Sensoren und Module. Natürlich hatte ich viel weniger davon, aber diejenigen, denen bereits ein gewisser Spielraum für Kreativität gegeben wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für die Befüllung der Hauptsteuereinheit stellten die Japaner ihre Version des Arduino-Boards her, finalisierten es und nannten es Studuino. Sie fügten einen DC-Motorsteuerungstreiber hinzu und brachten eine Leitung für 3-polige Steckverbinder (Standard BLS-3, diese sind auf Servos platziert). An jedem dieser Anschlüsse befindet sich Strom: Plus und Minus sowie einer der Pins der Arduino-Platine. Alle Anschlüsse sind signiert, daher ist es schwierig, beim Anschließen einen Fehler zu machen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ti/ls/g5/tilsg5zc0fbgyoeusvabr0xeti0.png" alt="Studuino-Plattform"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Studuino-Plattform</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aus Gründen der Kompatibilität mit Standard-Arduino-Abschirmungen an Standardplätzen gibt es ähnliche Anschlüsse wie Arduino. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptunterschied zur Arduino-Karte besteht darin, dass die Spannung des Controllers 3,3 V beträgt. Dies erklärt sich aus der Tatsache, dass das zentrale Steuermodul über das mitgelieferte Batteriefach für 3 AA-Batterien (insgesamt 4,5 V) mit Strom versorgt wird. Der Akku wird leider nicht mitgeliefert, kann aber nicht einmal auf der Website des Herstellers als zusätzliche Option gekauft werden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Platine befindet sich in einem Kunststoffgehäuse, an dem Sie die Basisteile des Designers und andere Elemente befestigen können. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/4s/db/tv/4sdbtvlbdgyvbyrtjohswx8w4zq.jpeg" alt="ArTeC-Zentraleinheit"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ArTeC-Zentraleinheit</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als Stellantriebe bietet der Hersteller zwei Gleichstrommotoren mit Getriebe und bis zu 8 Servoantrieben eigener Bauart an (deren Anzahl je nach Kit-Konfiguration variieren kann). Die Motoren werden über spezielle Anschlüsse auf der Platine angeschlossen. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xr/ig/ti/xrigtithv8bt_ypcxqceow8mze0.jpeg" alt="Gleichstrommotoren mit Zahnrädern und deren Anschluss"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gleichstrommotoren mit Getrieben und deren Anschluss</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es </font><i><b><font style="vertical-align: inherit;">ist</font></b></i><font style="vertical-align: inherit;"> möglich, die einfachste Konstruktion, die mir in den Sinn kommt, ganz einfach und schnell zusammenzubauen: eine Robotermaschine mit zwei Motoren, die steuert, welche Bewegung Sie in die richtige Richtung bewegen können. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cw/k8/pb/cwk8pb5whc2yhdqudkn_igjmw04.jpeg" alt="Einfache Robotermaschine mit zwei Gleichstrommotoren"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Einfache Robotermaschine mit zwei Gleichstrommotoren</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Motoren werden gesteuert, indem die logischen Zustände der Klemmen D2, D4, D3 für den Motor eingestellt werden, der an die Anschlüsse M1 und D7, D8, D5 für den Motor angeschlossen ist, der an den Anschluss M2 auf der Studuino-Platine angeschlossen ist. Zu diesen Schlussfolgerungen haben die Entwickler des Studuino-Boards parallel einen Motortreiber-Treiberchip angeschlossen. Wenn Sie diese Schlussfolgerungen verwenden, indem Sie Ihren Stromkreis dort anschließen und gleichzeitig die Motoren gleichzeitig verwenden, schlägt dies fehl.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Überlegen Sie, wie Sie einen Motor steuern, der an den M1-Stecker angeschlossen ist. Durch Einstellen eines anderen logischen Zustands der Klemmen D2 und D4 ist es möglich, eine Drehung des Motors in die gewünschte Richtung zu erreichen. Zum Beispiel: Bei D2 - 1 und D4 - 0 dreht sich der Motor im Uhrzeigersinn, und wenn D2 - 0 und D4 - 1, dreht sich der Motor gegen den Uhrzeigersinn. Es ist auch erforderlich, die Motordrehzahl durch Einstellen des PWM-Werts an Pin D3 einzustellen - er kann im Bereich von 0 bis 255 liegen. Wenn der Wert 0 ist, dreht sich der Motor nicht, und wenn der Wert 255 ist, erhalten wir die maximale Drehzahl. Der Motortreiber ermöglicht auch eine sofortige Änderung der Drehrichtung des Motors und unterstützt den Motorbremsmodus. Um den Motor abzubremsen, muss an den Klemmen D2 und D4 der gleiche logische Zustand gleich 1 eingestellt werden.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Übrigens gibt es keine D3- und D5-Pins in den Anschlüssen mit 3 Pins (GND, VCC, SIG) auf der Studuino-Platine, aber sie befinden sich auf dem Standard-Arduino-Anschluss, den die Entwickler zur Wahrung der Plattformkompatibilität verlassen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ebenso wird der Motor gesteuert, der an den M2-Stecker angeschlossen ist. Für ihn wird die Drehrichtung durch den Zustand der Klemmen D7 und D8 und die Drehzahl durch die Klemme D5 festgelegt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das einfachste Programm, das ich geschrieben habe, hat die Robotermaschine so bewegt:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/vQ3rZuYrAfM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Servos können an die rot hervorgehobenen Anschlüsse auf der Platine angeschlossen werden: D2, D4, D7, D8, D9, D10, D11, D12. </font><font style="vertical-align: inherit;">
Anschließen von </font></font><br>
<br>
<img src="https://habrastorage.org/webt/0w/dj/ai/0wdjaiemegvopfxyopehiaw3kk4.jpeg" alt="Servoverbindung"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Servoantrieben</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An diesen Pins verfügt der AtMega168-Mikrocontroller über eine PWM, die zur Steuerung der Servoantriebe benötigt wird. Wenn Sie die maximale Anzahl von Servos anschließen, erhalten Sie ein interessantes Design. Zur Demonstration habe ich ein einfaches Analogon eines Laufroboters zusammengestellt und versucht, es ein wenig zu programmieren. Das Ergebnis ist im Video zu sehen:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/7wUzKdMxz2o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie vorhaben, sowohl Gleichstrommotoren als auch Servos gleichzeitig zu verwenden, können Sie nicht zwei Gleichstrommotoren und 8 Servos gleichzeitig verwenden, da diese über gemeinsame Ausgänge verfügen, die vom Mikrocontroller gesteuert werden. Sie können folgende Konfigurationen vornehmen: 2 Gleichstrommotoren + 4 Servos, 1 Gleichstrommotor + 6 Servos oder nur 8 Servos verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In jedem Roboterkit müssen zusätzlich zu den Aktuatoren Sensoren vorhanden sein, die die "Augen" und "Ohren" eines Roboters sind. Sie sind auch hier. In meinem Set befanden sich folgende Sensoren: ein Lichtsensor, ein Schallsensor, ein Beschleunigungssensor, zwei IR-Sensoren, ein Berührungssensor sowie LEDs (grün, rot, blau, weiß) und eine piezodynamische. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/37/od/_9/37od_926t58t-bpda408gn8t3r0.jpeg" alt="Sensoren im Set"><br>
<i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sensoren im Set</font></font></b></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Sensoren werden über die mit dem Kit gelieferten Kabel an die Zentraleinheit angeschlossen. </font><font style="vertical-align: inherit;">Um die Sensoren im Robotermodell an den Gehäusen zu befestigen, haben sie Spikes, mit denen sie an der Struktur befestigt werden können. </font><font style="vertical-align: inherit;">Ich habe ein paar einfache Designs zusammengestellt und programmiert, um die Funktionsweise der Sensoren zu untersuchen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So funktioniert der Berührungssensor:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/1xNKl1vxEEM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und so funktioniert der Lichtsensor:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/IporhRPSjf4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn das Set nicht genügend Standardsensoren enthält und Sie seine Funktionalität erweitern möchten, können Sie das lötfreie Steckbrett problemlos verwenden und dort Schaltkreise anschließen, genau wie bei einem Standard-Arduino-Board. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_b/c6/vg/_bc6vgpysz7ujiuqezh3v69hgfy.jpeg" alt="Erweiterte Rekrutierungsfunktionen"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbessertes Wählen</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der nächste wichtige Punkt für jedes Roboterkit ist die Verfügbarkeit einer praktischen Programmierumgebung. Hier bietet der Hersteller drei verschiedene Programmiermöglichkeiten an. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einstiegsmodell - für die kleinsten Benutzer, die noch nicht wirklich lesen können, aber bereits ihre ersten Schritte in die Erwachsenenwelt der Robotik unternehmen. Für sie wird die einfachste Programmierumgebung angeboten - das Piktogramm. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/my/pe/o-/mypeo-odgpb_o6ewezjvyd2haxy.jpeg" alt="Symbolprogrammierung"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Symbolprogrammierung</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier können Sie Piktogramme mit grundlegenden Aktionen in das Programm ziehen (vorwärts gehen, drehen, LED einschalten usw.) und deren grundlegende Parameter konfigurieren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn diese Stufe beherrscht wird oder ihre Fähigkeiten nicht mehr ausreichen, um die Aufgaben zu lösen, können Sie mit dem nächsten Schritt fortfahren und die Scratch-Programmierumgebung für die Studuino-Plattform verwenden. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ms/cx/ze/mscxzeyahq9fake71sur4f9ncuq.jpeg" alt="Scratch-Programmierung für Studuino"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scratch-Programmierung für Studuino</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Es gibt bereits weitere Programmieroptionen: Sie können Variablen und Arrays, logische und arithmetische Ausdrücke, Unterprogramme verwenden und verschiedene Blöcke flexibler für die Ausführung konfigurieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn diese Funktionen nicht ausreichen, können Sie mit der Programmierung in der Arduino IDE fortfahren und die vollständige Kontrolle über alle Hardwarefunktionen der Studuino-Plattform erhalten. Um die Studuino-Karte in der Arduino IDE zu verwenden, müssen Sie die Umgebung gemäß den Anweisungen auf der Website des Herstellers konfigurieren (damit die Umgebung die Studuino-Plattform in der Liste der unterstützten Karten sieht). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammen mit der Programmiersoftware gibt der Hersteller eine Reihe von Anweisungen zum Zusammenbauen und Programmieren verschiedener Modelle. Die Software selbst ist kostenlos auf der Website des Herstellers verfügbar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Versuchen wir nun, mit diesem Set ein kleines praktisches Problem zu lösen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Stellen Sie sich vor, wir haben einen Roboter, der sich im Lager vorwärts und rückwärts bewegen muss, und wir müssen ihn an den angegebenen Stellen anhalten lassen. </font><font style="vertical-align: inherit;">Wenn der Roboter nicht gesteuert wird, kommt es zu einem Unfall. </font><font style="vertical-align: inherit;">Ein Beispiel für einen solchen Unfall ist hier dargestellt:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/a-q58XA4iKs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Vor- und Zurückbewegen des Roboters kann mit Gleichstrommotoren oder Servos erfolgen. </font><font style="vertical-align: inherit;">Servoantriebe lösen das Problem, wie der Roboter an der richtigen Stelle angehalten werden kann (Sie können den Drehwinkel des Servos genau einstellen). </font><font style="vertical-align: inherit;">Diese Lösung hat eine Einschränkung (wir verwenden ein Servo aus einem Satz mit einem daran befestigten Rad) - Servos können sich nicht um einen Winkel von mehr als 180 Grad drehen, und daher ist die Bewegung unseres Roboters auf die Hälfte der Radumdrehung des Servos begrenzt, aber normalerweise möchten Sie mehr.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir werden einen Gleichstrommotor mit einem Reduzierstück aus dem Satz verwenden, um vorwärts und rückwärts zu fahren. Diese Motoren haben keine Rückmeldung. Nach dem Starten des Motors können wir nicht sagen, wie weit der Roboter gefahren ist. Sie können die Zeit erfassen, während der der Roboter während des Motorbetriebs die erforderliche Strecke zurücklegt, und diese Verzögerungen im Programm verwenden, um den Roboter an der richtigen Stelle anzuhalten. Diese Methode hat einen wesentlichen Nachteil: Die Motordrehzahl hängt von der Spannung ab, die an sie geliefert wird, und von der erforderlichen Anstrengung. Da im Roboter Batterien verwendet werden, die nach einer Weile leicht entladen werden und deren Spannung abnimmt, beginnt der Roboter gleichzeitig, eine kürzere Strecke zurückzulegen, und es ist erforderlich, die Zeit erneut auszuwählen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die einfachste Option, die Sie verwenden können, ist ein Roboter, der den gewünschten Punkt passiert und den Berührungssensor berührt. Dies ist ein Stoppsignal an der richtigen Stelle. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe Änderungen an meinem Design vorgenommen, indem ich Berührungssensoren am Roboter hinzugefügt und Elemente entlang des Roboterpfads platziert habe, sodass der Roboter sie beim Bewegen mit Berührungssensoren berührt hat.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/HA3jLus8px8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Video zeigt, dass der Roboter das Ende des „Lagers“ erreicht und die „Wand“ mit dem Sensor berührt, dann zur gegenüberliegenden „Wand“ des Lagers zurückkehrt und dort auch berührt. Danach wird der Vorgang wiederholt. Es gibt also zwei Punkte, die der Roboter mit Sicherheit „kennt“ - dies sind die Punkte, an denen der Berührungssensor ausgelöst wird. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/da/b1/t9/dab1t9huyd38v6ayifpulmebjnq.jpeg" alt="Scratch-Touch-Programm für Studuino"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein Programm mit Berührungssensoren in der Scratch-Sprache für Studuino</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Manchmal reicht dies aus, um die Aufgabe zu lösen. Aber wir wollen mehr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe das Design und das Programm des Roboters geändert und Folgendes erhalten:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/VFrxd_LQzo0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lassen Sie uns genauer betrachten, was ich so viel mehr vom Roboter verlangt habe. Ich entschied, dass zwei Haltepunkte für mich nicht ausreichen und ich mehr möchte. Dafür habe ich einen IR-Sensor verwendet, der im Kit enthalten ist. Ich befestigte es auf einer beweglichen Plattform und arrangierte darunter einen Papierstreifen mit schwarzen Linien, die von der Markierung vorgezeichnet wurden und auf denen der Roboter anhalten musste. Ich habe auch einen der Berührungssensoren vom Roboter entfernt (auf der rechten Seite). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/al/kn/1x/alkn1xf57oqajjs1jfb_k7n3e3q.jpeg" alt="IR-Roboter"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roboter mit IR-Sensor</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Als Ergebnis erhielt ich ein klassisches Diagramm des Geräts einer der Achsen eines 3D-Druckers oder einer CNC-Maschine. Im eingeschalteten Zustand weiß der Drucker nicht, wo er sich befindet, und bewegt sich ganz zur Seite (bis er vom Endschalter berührt wird). Danach betrachtet er diesen Punkt auf Null und beginnt, seine Position auf dieser Achse von dort aus zu zählen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei diesem Design erfolgt der Countdown auf schwarzen Streifen auf Papier. Die Anzahl dieser Bänder ist im Voraus bekannt. Wenn Sie also das letzte Band erreichen, können Sie zum Nullreferenzpunkt zurückkehren. Das Scratch-Programm für Studuino wird unten vorgestellt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/b9/tv/so/b9tvsopxgjuhgvbiga4dj22_kck.jpeg" alt="Scratch IR Robot Program für Studuino"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Scratch IR Robot Program für Studuino</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie sich das Programm genau ansehen, sehen Sie unverständliche Werte von 40 und 50, mit denen der Wert des IR-Sensors verglichen wird. Um diese Zahlen zu verstehen, müssen Sie sich ein wenig daran erinnern, welche Signale von verschiedenen Sensoren gelesen werden können. Es gibt digitale und analoge Sensoren. Digitale Sensoren haben eine feste Anzahl von Positionen und bewegen sich scharf und ohne Zwischenwerte von einer Position zur anderen. Meist verwendete Sensoren mit zwei Positionen. Berührungssensoren sind das auffälligste Beispiel für einen digitalen Sensor: Bis der Sensor gedrückt wird, gibt er einen logischen Wert von 1 und beim Drücken einen logischen Wert von 0 (in diesem Konstruktor und bei diesen Sensoren ist dies das Schema, aber es gibt Schemata, bei denen es umgekehrt gemacht wird: gedrückt - 1, nicht gedrückt - 0).Analoge Sensoren beschreiben eine untrennbare Beziehung zwischen dem Signal und der Spannung oder dem Strom am Ausgang und haben keine festen Werte. Der IR-Sensor sendet ein analoges Lichtsignal aus, das von verschiedenen Faktoren wie Umgebungslicht, Batteriespannung und sogar Umgebungstemperatur abhängen kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das analoge Signal wird für Scratch for Studuino linear in eine Zahl umgewandelt - im Bereich von 0 bis 100. Dies dient dazu, die Arbeit mit ihnen für Endbenutzer zu vereinfachen (diese Programmierumgebung wurde zuerst für das Unterrichten von Kindern entwickelt). In der Arduino IDE wird ein „ehrlicher“ Wertebereich von 0 bis 1023 ausgegeben, der dem 10-Bit-ADC-Wandler entspricht, der im Atmega168-Controller vorhanden ist. Wenn Sie sich die Unterschiede in den Diagrammen zwischen dem digitalen und dem analogen Signal ansehen, wird klar, warum das analoge Signal ein Wertebereich ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ur/3x/et/ur3xety3bijaa_dks5k0_evptss.jpeg" alt="Analoges (links) und digitales (rechts) Signal"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analoges (links) und digitales (rechts) Signal Der</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Infrarotsensor, mit dem die schwarze Markierungslinie bestimmt wird, arbeitet nach dem Prinzip der Erfassung des reflektierten Signals. In der Abbildung sind zwei Elemente deutlich zu erkennen: IR-LED und IR-Fotodetektor.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/on/3c/6x/on3c6xotvu7c0kki7or2ldclw9k.png" alt="IR-Sensor"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IR-Sensor</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wenn Sie ein Hindernis vor den Sensor stellen, von dem IR-Strahlen reflektiert werden, werden sie vom IR-Fotodetektor umso mehr aufgenommen, je besser sie vom Hindernis reflektiert werden (abhängig von der Entfernung zum Hindernis oder der Art des Hindernisses) Wert für den Benutzer während seiner Umfrage.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Zahlen 40 und 50 werden empirisch ausgewählt. In meinem Fall zeigte der Sensor über einer weißen Oberfläche Werte von etwa 65-75. Über der schwarzen Oberfläche gab der Sensor Werte im Bereich von 18 bis 25 zurück. Die Zahl 40 ist der Moment, in dem der Sensor beginnt, von einer weißen zu einer schwarzen Oberfläche zu wechseln, und die Zahl 50 ist der Moment des Übergangs von einer schwarzen zu einer weißen Oberfläche. Diese Zahlen werden mit einem kleinen Rand aufgenommen, um den Fehler bei der Messung des Sensors zu blockieren. Bei der Entwicklung eines realen Designs müssen die Bedingungen berücksichtigt werden, unter denen der Sensor Messwerte erfasst (externe Beleuchtung, Position des Sensors usw.), da alle diese Faktoren die Sensorwerte beeinflussen. Möglicherweise müssen Sie einen Algorithmus entwickeln, um diese Werte abhängig von den äußeren Bedingungen ständig anzupassen.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich werde ein kleines Ergebnis zusammenfassen. Es wurden zwei mögliche Lösungen für das Problem des Bewegens des Roboters im Lager in Betracht gezogen. Beide Optionen erforderten zusätzliche externe "Tags", die den Roboter leiteten. Gibt es eine Möglichkeit, ohne sie auszukommen? Damit der Roboter beispielsweise weiß, in welchem ​​Winkel sich die Motorwelle gedreht hat und je nach Winkelwert beschlossen hat, anzuhalten oder weiterzufahren. Für dieses Problem gibt es eine einfache Lösung - die Verwendung eines Motors mit einem Encoder (Winkelsensor). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Set verfügt über Gleichstrommotoren mit Getriebe, die jedoch keinen Encoder haben. Mir kam die Idee: Vielleicht könnte ich versuchen, aus den Teilen des Designers einen einfachen Encoder zu machen, zumal die Zahnräder aus dem Set ein ziemlich großes Modul (Zahngröße) haben? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/3f/pw/m7/3fpwm7n1mk6bd9rcxqx4lbu3vly.jpeg" alt="Die Hauptelemente des Encoders"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Hauptelemente des Encoders</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptproblem bestand darin, den Ort zu wählen und den IR-Sensor so zu befestigen, dass er den Zahnradzahn schneidet, wenn er sich dreht. Als Ergebnis habe ich ein Testdesign erhalten, das in der folgenden Abbildung dargestellt ist. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tq/xl/e-/tqxle-maffh26bftiaj1knmhuvc.jpeg" alt="Encoder-Testmodell"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encoder-Testmodell</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie Sie in der Abbildung oben sehen können, ist der IR-Sensor so fixiert, dass das Zahnrad während der Drehung seinen Arbeitsmessbereich mit den Zähnen kreuzt. Gegenüber (auf der anderen Seite des Zahnrads) des IR-Sensors habe ich zusätzlich ein Hindernis für die Reflexion von Infrarotstrahlen angebracht, um korrektere Daten vom Sensor zu erhalten. Wenn sich das Zahnrad dreht und der IR-Sensor die Signalreflexion misst, gibt es große Werte, wenn sich ein Zahn vor dem Sensor befindet, und kleinere, wenn sich zwischen den Zahnradzähnen ein „Loch“ befindet.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programm für die Arbeit mit dem Encoder wird in der Arduino IDE entwickelt. </font><font style="vertical-align: inherit;">Um die Effizienz meiner Idee zu testen, habe ich ein einfaches Programm geschrieben, mit dem der Motor mit konstanter Geschwindigkeit gedreht und kontinuierlich Werte vom IR-Sensor an die Debug-Konsole ausgegeben wurden.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmtext</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_A        2       <span class="hljs-comment">//   1   1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_B        4       <span class="hljs-comment">//   2   1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_PWM      3       <span class="hljs-comment">//       1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SENSOR_PIN  A4      <span class="hljs-comment">//     IR-sensor</span></span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{<font></font>
  Serial.begin(<span class="hljs-number">9600</span>);       <span class="hljs-comment">//      </span>
  pinMode(M1_A, OUTPUT);    <span class="hljs-comment">//       " "</span><font></font>
  pinMode(M1_B, OUTPUT);    <font></font>
  analogWrite(M1_PWM, <span class="hljs-number">100</span>); <span class="hljs-comment">//    </span>
  digitalWrite(M1_A, HIGH); <span class="hljs-comment">//    </span>
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2000</span>; i++) {    <span class="hljs-comment">//   2000    -</span>
    Serial.println(analogRead(SENSOR_PIN));   <span class="hljs-comment">//      </span><font></font>
  }<font></font>
  digitalWrite(M1_A, LOW);  <span class="hljs-comment">//   </span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entsprechend den Daten, die das Programm auf der Konsole angezeigt hat, habe ich das folgende Diagramm erhalten: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/at/kf/tc/atkftc0d8gxexmeimdiirwuyfbw.png" alt="Diagramm der IR-Sensorwerte während der Gangdrehung"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diagramm der Änderungen der Werte des IR-Sensors während der Drehung des Zahnrads</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Art des Diagramms ähnelt der Form der Zähne eines Zahnrads, was darauf hindeutet, dass solche Daten tatsächlich verwendet werden können, um die Drehung des Motors unter Verwendung des Zahnrads aus dem Konstruktionssatz als Encoderscheibe zu steuern. Um die "Bounce" -Hysterese zu eliminieren, wird diese wie folgt implementiert (Symbole in der Grafik): MIDDLE ist der Durchschnittswert zwischen den Maximal- und Minimalwerten der IR-Sensorwerte, WIDTH ist die Abweichung von MIDDLE zu einem größeren oder kleineren Wert, um ein bestimmtes "Fehlerband" zu erzeugen. »Signalmessungen (die Gesamtbreite dieses Bandes beträgt 2 * BREITE). MIDDLE und WIDTH werden im Algorithmus zur Steuerung der Motordrehung verwendet. Der Algorithmus zum Zählen der Zähne im Zahnrad während der Motordrehung kann wie folgt dargestellt werden:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rs/cp/2a/rscp2atjd50elx___64gsjrvpra.png" alt="Algorithmus zum Zählen der Zähne im Zahnrad während der Motordrehung"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus zum Zählen der Zähne im Zahnrad während der Motordrehung.</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Der Algorithmus verwendet die folgende Notation:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">prev_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - vorheriger </font><b><font style="vertical-align: inherit;">Gangzustand</font></b><font style="vertical-align: inherit;"> ;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cur_state</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - aktueller Zustand des Zahnrads;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - die Anzahl der gezählten Zahnradzähne;</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - IR-Sensorwerte.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Prinzip des Zählens der Zahnradzähne in diesem Algorithmus basiert auf einem konstanten Ablesen der Ablesungen vom IR-Sensor und einer Änderung des Werts der Variablen cur_state, wenn der Signalpegel über die obere oder untere Zeile des „Fehlerbandes“ geht. </font><font style="vertical-align: inherit;">Wenn der Wert die Obergrenze überschreitet, wird die Variable cur_state gleich 1, was einen Zahnradzahn bedeutet, und wenn die untere Grenze überschritten wird, wird die Variable cur_state gleich 0, was einen Spalt zwischen den Zahnradzähnen bedeutet. </font><font style="vertical-align: inherit;">Das Hinzufügen der Zählvariablen erfolgt nur, wenn sich der Status der Variablen cur_state ändert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein Programm, das diesen Algorithmus verwendet, wird unten vorgestellt. </font><font style="vertical-align: inherit;">Darin habe ich ein Unterprogramm beschrieben, das wartet, bis der Motor das Zahnrad um eine vorgegebene Anzahl von Zähnen dreht, und danach die Steuerung an das Hauptprogramm überträgt.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programmtext</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_A        2       <span class="hljs-comment">//   1   1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_B        4       <span class="hljs-comment">//   2   1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M1_PWM      3       <span class="hljs-comment">//       1</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SENSOR_PIN  A4      <span class="hljs-comment">//     IR-sensor</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIDDLE      550     <span class="hljs-comment">//         </span></span>
                            <span class="hljs-comment">// ""</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WIDTH       50      <span class="hljs-comment">//      ,   </span></span>
      <span class="hljs-comment">//    -     </span>
      <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-keyword">int</span> enc_tooth = <span class="hljs-number">0</span>;          <span class="hljs-comment">// ,    </span>
<span class="hljs-keyword">int</span> cur_state = <span class="hljs-number">0</span>;          <span class="hljs-comment">//   :  (1)  "" (0)</span>
<span class="hljs-keyword">int</span> prev_state = <span class="hljs-number">0</span>;         <span class="hljs-comment">//   </span>
<span class="hljs-keyword">int</span> tmp;                    <span class="hljs-comment">//      </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init_enc</span><span class="hljs-params">()</span> </span>{<font></font>
  enc_tooth = <span class="hljs-number">0</span>;<font></font>
  cur_state = <span class="hljs-number">0</span>;<font></font>
  prev_state = <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-comment">//         cur_state</span>
  <span class="hljs-comment">//    ,   = 1,    ""      </span>
  <span class="hljs-comment">//   0      </span>
  <span class="hljs-keyword">if</span> (analogRead(SENSOR_PIN)&gt;MIDDLE) {<font></font>
    prev_state = <span class="hljs-number">1</span>;<font></font>
    cur_state = <span class="hljs-number">1</span>;<font></font>
    enc_tooth++;<font></font>
  }  <font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_by_count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>{
  <span class="hljs-comment">//       count,       IR </span>
  <span class="hljs-comment">//           ""</span>
  <span class="hljs-keyword">while</span> (enc_tooth &lt;= count) {
    <span class="hljs-comment">//    IR-    </span><font></font>
    tmp = analogRead(SENSOR_PIN);<font></font>
<font></font>
    <span class="hljs-comment">//       +  ,    </span>
    <span class="hljs-keyword">if</span> ((tmp + WIDTH) &gt; MIDDLE) {<font></font>
      cur_state = <span class="hljs-number">1</span>;<font></font>
    } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//       -  ,    ""</span>
      <span class="hljs-keyword">if</span> ((tmp - WIDTH) &lt; MIDDLE) {<font></font>
        cur_state = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    <span class="hljs-comment">//       ,      </span>
    <span class="hljs-comment">// ,     ""   -  ""  </span>
    <span class="hljs-keyword">if</span> (cur_state != prev_state) {
    <span class="hljs-comment">//   ,   0  - ,     </span>
    <span class="hljs-comment">// </span><font></font>
      enc_tooth += cur_state;<font></font>
    <font></font>
    <span class="hljs-comment">//        </span><font></font>
      prev_state = cur_state;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">//        </span>
  Serial.begin(<span class="hljs-number">115200</span>);<font></font>
<font></font>
  <span class="hljs-comment">//        ""</span><font></font>
  pinMode(M1_A, OUTPUT);<font></font>
  pinMode(M1_B, OUTPUT);<font></font>
<font></font>
  <span class="hljs-comment">//   </span><font></font>
  init_enc();<font></font>
<font></font>
  <span class="hljs-comment">//    </span>
  analogWrite(M1_PWM, <span class="hljs-number">100</span>);<font></font>
 <font></font>
  <span class="hljs-comment">//    ,      1 (    </span>
  <span class="hljs-comment">//  0)</span>
  digitalWrite(M1_A, <span class="hljs-number">1</span>);<font></font>
<font></font>
  <span class="hljs-comment">// ,    30  </span>
  wait_by_count(<span class="hljs-number">30</span>);<font></font>
  <font></font>
  <span class="hljs-comment">//   </span>
  digitalWrite(M1_B, <span class="hljs-number">1</span>);<font></font>
<font></font>
  Serial.print(<span class="hljs-string">"  = "</span>);<font></font>
  Serial.println(enc_tooth);<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span> </span>{<font></font>
}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Programm startet den Motor und wartet, bis sich das Zahnrad um 30 Zähne dreht - genau so viele Zähne im Zahnrad, und danach stoppt es den Motor. </font><font style="vertical-align: inherit;">Unten sehen Sie ein Video, das die Funktionsweise des Programms demonstriert:</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wS0eODG7zzc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Auf einem weißen Stück Papier, das auf das Zahnrad geklebt ist, können Sie dessen Drehung um 360 Grad verfolgen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dazu möchte ich diesen Artikel beenden. </font><font style="vertical-align: inherit;">Abschließend kann ich sagen, dass ich nicht nur beim Encoder-Modell stehen geblieben bin. </font><font style="vertical-align: inherit;">Eine vollwertige Roboterplattform wurde mit zwei Motoren und zwei Encodern (einer für jedes Rad) zusammengebaut und ein Programm zur Synchronisierung der Raddrehung nach Encodern erstellt. Dies ist jedoch ein Thema für einen anderen Artikel ... Eine </font></font><br>
<br>
<img src="https://habrastorage.org/webt/st/zy/b3/stzyb3ery-ssclsmbwlzghisq24.jpeg" alt="Roboterplattform mit Encodern basierend auf IR-Sensoren"><br>
<b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Roboterplattform mit Encodern, die auf IR-Sensoren basieren</font></font></i></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als pädagogischer Designer in der Robotik ist dies eine gute Option für Kinder (also Erwachsene), die an solchen Kursen teilnehmen möchten, zumal der Hersteller alles getan hat, um die Altersspanne derjenigen zu maximieren, die dieses Produkt verwenden können (das Vorhandensein unterschiedlicher Programmierumgebungen) ) </font><font style="vertical-align: inherit;">Sie können mit den einfachsten und elementarsten Elementen beginnen und nach dem Erwerb von Grundkenntnissen zu einer anderen Entwicklungsstufe für Robotik und Elektronik übergehen.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de503958/index.html">Offenes API-Spiel: Swagger Play</a></li>
<li><a href="../de503960/index.html">Wie Linux Zeichenfolgen sortiert</a></li>
<li><a href="../de503962/index.html">Autonomes Fahren - Hype in Autos, aber die Notwendigkeit von Netzwerkdiensten für Rechenzentren</a></li>
<li><a href="../de503964/index.html">DataStore - CRUD (Create Read Update Delete)</a></li>
<li><a href="../de503966/index.html">Die Social Monitoring App wurde aus einem Müllwagen-Tracker erstellt</a></li>
<li><a href="../de503970/index.html">PuppetConf 2016. Kubernetes für Systemadministratoren. Teil 1</a></li>
<li><a href="../de503972/index.html">Streaming-Test in 4 sozialen Netzwerken und Auswahl der besten Option</a></li>
<li><a href="../de503980/index.html">Überwachung der Temperatur an einem entfernten Ort durch „improvisierte“ Mittel</a></li>
<li><a href="../de503982/index.html">Über Orks und Frameworks</a></li>
<li><a href="../de503988/index.html">Wie "wirbelndes Licht" in optische Netzwerke gelangte</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>