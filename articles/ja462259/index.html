<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏼 👸🏾 🧟 スマートホーム用のコントローラーを作る 📔 🌓 🕵🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="スマートホーム用のコントローラーを作るだけではありません。
 
 前回の記事では、システム全体の開発について説明しました。ここでは、センサーとI / Oモジュールのポーリングを担当するコントローラーの開発について説明します。 「なぜ車輪を再発明するのですか？」 - あなたが尋ねる。第一に、それは興味...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>スマートホーム用のコントローラーを作る</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462259/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スマートホーム用のコントローラーを作るだけではありません。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">前回の記事で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、システム全体の開発について説明しました。ここでは、センサーとI / Oモジュールのポーリングを担当するコントローラーの開発について説明します。 「なぜ車輪を再発明するのですか？」 - あなたが尋ねる。第一に、それは興味深いものであり、第二に、奇妙なことに、ソフトウェアとハ​​ードウェアの両方をカバーするそのようなコントローラーのためのオープンソースのソリューションはありません。この記事は、エレクトロニクスと組み込みLinux開発に少し精通している人を対象としています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントローラーの作成は非常に複雑です。ボードを作成し、ソフトウェアを作成し、ケースを印刷する必要があります。しかし、実際には、すべてが少し複雑です。それが私に注がれたものですが、あなたは原則的に正しいです：</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.コントローラーのハードウェア</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">コントローラー</font><font style="vertical-align: inherit;">のCPUボードの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 選択-IOコントローラーの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 選択-電源の選択- </font><font style="vertical-align: inherit;">コントローラーの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 ブロック図</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">コントローラー</font><font style="vertical-align: inherit;">のクロスボードの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 開発-RS-485モジュールのボードの開発</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ボードの作成</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2.コントローラーのソフトウェア</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -アセンブリシステムの選択linuxおよびrootfsカーネル</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -SDカードパーティション構造</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -ブートローダーの選択と目的のrootfsのロード</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -デバイスツリーの変更</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -デバッグトレースを収集</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 するためのシステムの選択</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">ビルドシステムの</font><font style="vertical-align: inherit;">書き込み</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">通信カーネルの</font><font style="vertical-align: inherit;">書き込み-ゲートウェイmqttの書き込み（個別/アナログコントローラーポイント-&gt; mqttトピック）</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -Googleテーブルパーサーの作成とゲートウェイ用のjson構成ファイルの</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 作成</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 - </font><font style="vertical-align: inherit;">コントローラーポイントにアクセスするためのポイントモニターの作成</font><font style="vertical-align: inherit;">-読み取り専用ファイルシステムのマウント</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.コントローラーケース</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -コネクタ</font><font style="vertical-align: inherit;">ケース</font><font style="vertical-align: inherit;">、冷却、ボードフットプリント、Dinrakeのクリップ用埋め込みクリップ。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -設計と印刷</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ハードウェアに関する一言。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく最も必死なものだけが、個別のプロセッサ、メモリ、フラッシュ、電源コントローラ、数百のコンポーネントを受け取り、それらすべてを一緒に彫刻し始めるでしょう。残りは他の人の労力の成果を利用しており、より速くて簡単です。ブラウザーを開いて「シングルボードコンピューター」を作成し、残りの時間を費やして適切なコンピューターを選択するだけです。たくさんのシリアルポートが必要で、ボードが-40°C〜+ 85°Cをサポートすることが望ましいため、BeagleBone Black（BBB）を選択しました。また、BBBでは、すべての周辺機器がピッチ2.54の46ピンの2つのPBDコネクタに接続されており、クロスボードのプロトタイピングと開発に便利です。 1つのボード上のすべてのコンポーネントを組み合わせるにはクロスボードが必要です。私にとっては、それはCPUボード、電源、IOコントローラー、およびRS485チャネルボードです。また、ケースに固定する必要があるのはクロスボードであり、電源とRS485ケーブル用のコネクタがあります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oy/jo/6j/oyjo6jzy2qtidg-9ehm5zmtnqtg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、CPUボードを見つけました。次に決定するのは、クロスボードに入力/出力（IO）コントローラーを配置する必要があるかどうかです。私はそれをボードに置いたが、まだうまく使っていない。彼が行う唯一のことは、電源を入れてリセットボタンを提供した後、BBBの開始を1秒間延期することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
既製のMeanWell NSD10-12S5を使用したコントローラーの電源は、1つのデバイス用に開発するのは意味のない仕事です。消費するためにそれを拾っただけです。 LCDはボード上にありますが、サポートは実装していません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uu/ub/hx/uuubhxrvgg7imxkdmtk6rjsojtu.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/hd/wn/l2/hdwnl2uo05wm6isu1pudumcx8zk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RS485チャネルカードについて一言。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クロスボードには4つのシリアルBBBインターフェイスがあります。そのため、RS485、CAN、Zigbeeモジュールなど、必要なあらゆるタイプのチャネルを配置できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RS485チャネルが必要だったので、RS485チャネルのみを作成しました。自動受信/送信制御とガルバニック絶縁を備えています。 TIがシリアルデバイスドライバーでRS485のストローブのサポートを公式に停止したため、BBBでトランシーバー制御を使用しないのはなぜですか。ドライバーのパッチを見つけて、自分で追加できますが、なぜですか？チャネルをセルフロックにした後は、RaspberyPiなど、そのようなサポートがなかったボードに配置できます。 rs485ドライバーのストロボはattiny10で構成されており、安くて陽気です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソフトウェアに戻ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Linuxカーネルとrootfsのビルドシステムの選択。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この種のシステムはいくつかありますが、最も一般的なのはYoctoとBuildRootです。</font><font style="vertical-align: inherit;">大規模なプロジェクトを開発する必要がある場合、時間があり、レシピを作成したい場合は、Yoctoが最適です。</font><font style="vertical-align: inherit;">BuildRootの助けを借りて、ボードの単純な起動に必要なすべてのものを収集できます。</font><font style="vertical-align: inherit;">私はビーグルボーンブラック（以降BBB）でシステムを作成しています：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここに書かれていることを読む</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/448638</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">きれいにする</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beaglebone_defconfigを作成</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作る</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それで全部です。</font><font style="vertical-align: inherit;">ボードを実行するために必要なものはすべて、/ buildroot / output / imagesフォルダーにあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが非常にシンプルで面白くないので、もう少し複雑にすることができます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buildrootをビルドシステムに統合し、スクリプトでダウンロードし、安定したタグを使用することを忘れないでください。最後の開発は行わないでください。</font></font></li>
<li>  defconfig    buildroot      /buildroot/configs,         *_defconfig,  buildroot   </li>
<li>  post-build.sh  board/beaglebone/post-build.sh</li>
<li> prepare ,    1, 2  3  </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その結果、buildrootはzImageとrootfs.tarを生成</font><font style="vertical-align: inherit;">
します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDカードのパーティション構造の選択：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これにあまり重点を置くべきではないと思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BOOT / ROOT_1 / ROOT_2 / DATAの4つのセクションを作りました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BOOTセクションには、ブートストラップに必要なすべてのものが格納されています：MLO、barebox.bin、barebox.env、am335x-boneblack.dtb、zImage、boot.txt。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ROOT_1とROOT_2にはrootfsが含まれており、その選択はboot.txtファイルに書き込まれます（以下を参照）。これらのパーティションはすべて、電源をオフにしたときにファイルシステムがクラッシュしないように、読み取り専用としてマウントされます。 DATAには、コードを再構築する必要がない変更時の設計構成が含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなパーティション構造は、将来的にソフトウェア更新コンポーネントを簡単に作成できるようになります。このコンポーネントは、現在使用されていないセクションROOT_1 / ROOT_2の1つを上書きし、カーネルを変更する必要がない場合は、boot.txtファイルを変更します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ブートローダーの選択。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BBBのブートローダーを使ってたくさんの実験をしました。最初は、他の皆と同じように、BuildRootが生成するU-Bootを使用しました。しかし、私はそれが好きではなかったかもしれませんが、おそらく、これは習慣の問題ですが、これは多すぎるため、構成するのが非常に困難で難しいように思えました。次に、システムを2〜3秒ですばやく起動し、X-Loaderをファイリングしてカーネルが読み込まれるようにするのは悪くないと思いましたが、成功しましたが、やはり構成の問題があり、起動時間がかかりました。重要ではありません（systemd上のシステムは、不要なものをすべて削除しても、それ自体がゆっくりと起動します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局、私はベアボックスに落ち着きました、私は本当にそのシンプルさが好きでした、それにサイトにはすべてのドキュメントがあります（www.barebox.org）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、最初または2番目のパーティションからrootfsをロードするには、次の手順を実行するだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1.「export BOOT_NUM = X」タイプの変数をエクスポートするブートセクションにboot.txtファイルを作成します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。2。ブートパラメータを記述する2つのスクリプト/ env / boot / sdb1 / env / boot / sdb2を作成します。次に例を示します。</font></font><br>
 <br>
<pre><code class="plaintext hljs">echo "botting with mmcblk0p2 as rootfs..."<font></font>
	global.bootm.image=/boot/zImage<font></font>
	global.bootm.oftree=/boot/am335x-boneblack.dtb<font></font>
	global.linux.bootargs.console="console=ttyO0,115200"<font></font>
	global.linux.bootargs.debug="earlyprintk ignore_loglevel"<font></font>
	global.linux.bootargs.base="root=/dev/mmcblk0p2 ro rootfstype=ext4 rootwait"</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.スクリプト/ env / boot / sdを作成します。BOOT_NUMに応じて、sdb1またはsdb2スクリプトを開始します</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。4. boot.default変数を設定します</font></font><br>
 <br>
 <pre><code class="plaintext hljs">nv boot.default=sd<font></font>
	saveenv</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
5. boot.txtのBOOT_NUMをさらに変更して、最初または2番目のパーティションからrootfsをロードします。これは、将来ソフトウェアの更新に使用できるようになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバイスツリーの変更。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RS485経由でMODBUS RTUを使用してモジュールと通信するため、BBBに存在するほとんどすべてのシリアルポートを有効にする必要がありました。これを行うには、デバイスツリーでそれらを再度有効にする必要があります。デフォルトでは、それらのほとんどはオフになっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルドパッケージからam335x-bone-common.dtsiファイルのパッチを作成し、それをアセンブルする前に毎回適用するのが正しいでしょうが、遅延が発生し、必要なすべてのファイルを取り出し、必要なすべてを変更し、手でビルドしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜならこれは1回だけ実行され</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ます。</font><font style="vertical-align: inherit;">次の方法で実行できます</font><font style="vertical-align: inherit;">。1.アセンブリに必要なファイルを含むフォルダを作成します。</font></font><br>
 <br>
<pre><code class="plaintext hljs">am335x-bone-common.dtsi<font></font>
	am335x-boneblack-common.dtsi<font></font>
	am335x-boneblack.dts<font></font>
	am33xx-clocks.dtsi<font></font>
	am33xx.dtsi<font></font>
	am33xx.h<font></font>
	gpio.h<font></font>
	omap.h<font></font>
	tps65217.dtsi</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2. am335x-bone-common.dtsiファイルで、ピンを正しく構成し、ポートドライバーを無効にする必要があります。</font></font><br>
<br>
<pre><code class="plaintext hljs">uart1_pins: pinmux_uart1_pins {<font></font>
		pinctrl-single,pins = &lt;<font></font>
			AM33XX_IOPAD(0x980, PIN_INPUT_PULLUP | MUX_MODE0)<font></font>
			AM33XX_IOPAD(0x984, PIN_OUTPUT_PULLDOWN | MUX_MODE0)<font></font>
		&gt;;<font></font>
	};<font></font>
	uart2_pins: pinmux_uart2_pins {<font></font>
		pinctrl-single,pins = &lt;<font></font>
			AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE1)<font></font>
			AM33XX_IOPAD(0x954, PIN_OUTPUT_PULLDOWN | MUX_MODE1)<font></font>
		&gt;;<font></font>
	};<font></font>
	uart4_pins: pinmux_uart4_pins {<font></font>
		pinctrl-single,pins = &lt;<font></font>
			AM33XX_IOPAD(0x870, PIN_INPUT_PULLUP | MUX_MODE6)<font></font>
			AM33XX_IOPAD(0x874, PIN_OUTPUT_PULLDOWN | MUX_MODE6)<font></font>
		&gt;;<font></font>
	};<font></font>
	uart5_pins: pinmux_uart5_pins {<font></font>
		pinctrl-single,pins = &lt;<font></font>
			AM33XX_IOPAD(0x8C4, PIN_INPUT_PULLUP | MUX_MODE4)<font></font>
			AM33XX_IOPAD(0x8C0, PIN_OUTPUT_PULLDOWN | MUX_MODE4)<font></font>
		&gt;;<font></font>
	};<font></font>
	&amp;uart1 {<font></font>
		pinctrl-names = "default";<font></font>
		pinctrl-0 = &lt;&amp;uart1_pins&gt;;<font></font>
		status = "okay";<font></font>
	};<font></font>
	&amp;uart2 {<font></font>
		pinctrl-names = "default";<font></font>
		pinctrl-0 = &lt;&amp;uart2_pins&gt;;<font></font>
		status = "okay";<font></font>
	};<font></font>
	&amp;uart4 {<font></font>
		pinctrl-names = "default";<font></font>
		pinctrl-0 = &lt;&amp;uart4_pins&gt;;<font></font>
		status = "okay";<font></font>
	};<font></font>
	&amp;uart5 {<font></font>
		pinctrl-names = "default";<font></font>
		pinctrl-0 = &lt;&amp;uart5_pins&gt;;<font></font>
		status = "okay";<font></font>
	};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3.次に、ちょっとした魔法と、完成したファイルam335x-boneblack.dtbが同じディレクトリにあります。</font></font><br>
<br>
<pre><code class="plaintext hljs">a. sudo apt-get install device-tree-compiler</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 b。</font><font style="vertical-align: inherit;">プリプロセッサを実行します。</font></font><br>
 <br>
<pre><code class="plaintext hljs">cpp -Wp,-MD,am335x-boneblack.dtb.d.pre.tmp -nostdinc -Iinclude -Isrc -Itestcase-data -undef -D__DTS__ -x assembler-with-cpp -o am335x-boneblack.dtb.dts.tmp am335x-boneblack.dts</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 c。</font><font style="vertical-align: inherit;">コンパイラー自体を実行します。</font></font><br>
 <br>
<pre><code class="plaintext hljs">dtc -O dtb -o am335x-boneblack.dtb -b 0 -i src -d am335x-boneblack.dtb.d.dtc.tmp am335x-boneblack.dtb.dts.tmp</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
4. am335x-boneblack.dtbをカーネルの隣のブートセクションに配置し、ベアボックスの起動スクリプトに次の行を追加します-" </font></font><code>global.bootm.oftree=/boot/am335x-boneblack.dtb</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">" </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太字のトレースを収集するためのシステムの選択。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご存じのとおり、バグのないシステムは存在せず、トレースのないマルチスレッドシステムの分析も存在しません。これらのトレースがコンソールに単に表示されるのではなく、このために特別に作成されたものを使用して収集されると非常に便利です。これにより、プロセスごとにトレースをソートしたり、フィルターを適用したりできるようになります。そして私は、ホストとターゲットの両方で簡単に構築できる1つの優れたシステムを知っています。これはDLTです。これについて聞いたことがない場合は問題ではありません。すべての知識のギャップは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">at.projects.genivi.org/wiki/display/PROJ/Diagnostic+Log+and+Trace</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を読むことで簡単にカバーできます</font><font style="vertical-align: inherit;">。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムは、dlt-daemonとdlt-viewerで構成されています。名前が示すように、dlt-daemonはターゲットで実行され、dlt-viewerはホストで実行されます。これに加えて、トレースを収集するバイナリに、dlt libをリンクする必要があります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oi/go/b-/oigob-peuxj5pdvmkdr0vzu5wkc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、すべてが便利です。トレースを収集して分析する方法をお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルドシステムの作成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ビルドシステムを作成する理由は、リポジトリからすべてをダウンロードし、手でビルドし、このrootfsとベールに基づいてビルドできるため、コントローラーが機能するためです。しかし、そのようなトリックを1か月に繰り返すのはより難しく、2か月に2回です-これは一般的に不可能です。繰り返しますが、何を、どこに、何を構築し、どのように開始するかを覚えておく必要があります。したがって、最初は多くの時間を費やしていたので、後で保存するだけでなく、ホストとターゲットの下で簡単にビルドできるようになります。ビルドシステムは、ビルドのホストを最初に準備し、buildroot、mosquitto、DLTデーモンなどのサードパーティコンポーネントをリポジトリからダウンロードしてビルドし、それらを所定の場所に配置する一連のスクリプトで構成されています。その後、プロジェクトのビルドを起動できます。ホストでのビルドが難しくない場合は、常にターゲットでのビルドをいじくり回す必要があり、スクリプトがそれを行うとより良いでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
buildrootは、rootfsを形成した後にビルド後のスクリプトを呼び出すように構成できます。これは、buildroot / output / targetにあります。</font><font style="vertical-align: inherit;">これにより、必要なものをすべて配置する絶好の機会が得られます。</font><font style="vertical-align: inherit;">そして、ファイルシステムイメージには、システムを起動するために必要なものがすべて含まれています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レシピは次のようなものです：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バイナリをbuildroot / output / targetのどこかにコピーする必要があります（例：/ opt / bin）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">構成がある場合は、/ opt / etcのみで、構成を同じにしてください</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サードパーティのバイナリをコピーします。私にとっては、蚊、DLTデーモン、それらのライブラリと構成です</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントローラーをロードするときにシステム自体を起動するには、systemdサービスをコピーする必要があります。それらをターゲットに結合し、マルチユーザーでシンボリックリンクを作成して再度有効にすることをお勧めします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">変更されたfstabをコピーします（理由は後で説明します）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、buildroot / output / images / rootfs.tarをSDカードの目的のセクションに解凍し、電源を入れるだけです。 </font></font><br>
<br>
<pre><code class="plaintext hljs">build git repo: https://github.com/azhigaylo/build</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コミュニケーションコアの作成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この概念はmodbus自体と同じくらい古いものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
modbusネットワーク内の各I / Oデバイスには、読み取り、読み取り/書き込みに使用できるレジスタ（16ビット）があり、そこにデータが格納され、これらのデバイスが制御されます。</font><font style="vertical-align: inherit;">次に、コントローラーには、離散（ステータスとバイト値）とアナログポイント（ステータスと浮動小数点値）の配列があり、すべてのパラメーターの状態を格納します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、通信コアのタスクは簡単です。modbusプロトコルを使用してI / Oデバイスからデータを収集し、それらをコントローラーポイントにマップして、上位レベルのこれらのポイントへのアクセスを提供します。そして、何かを管理する必要がある場合、すべては逆方向にあります-論理デバイス（後で詳しく説明します）はコントローラーポイントにサブスクライブする必要があり、このポイントへの書き込みにより、このパラメーターの物理的な水出力デバイスへの変換が開始されます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/1v/zb/x4/1vzbx4smmroaleak2dy4jol9gno.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何らかの形でデータを構造化してデバイスを操作するために、ソフトウェアで物理デバイスの状態を表示する論理デバイスの概念を導入できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、論理デバイスを2つのグループに分けることにしました。</font></font><br>
<br>
<ol>
<li> (   /),      modbus   ,          .</li>
<li> ,       modbus    .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
上記のすべてから、それが単なるjson構成であっても、バイナリ構成を生成する自己作成ツールであっても、何でも適切なコントローラー用の何らかの構成プログラムを用意することが論理的です。 Linuxボードだけでなく、FreeRtosを使用してArduinでも簡単に実行できるように通信コアを作成して、ソフトウェアのPALレベルを変更するというアイデアがあったため、2番目のオプションがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各デバイスのコンフィギュレーターで、コントローラーポート番号rs485、デバイスアドレス、およびデバイスとの通信のステータスが表示されるコントローラーポイントを設定する必要があります。さらに、各標準デバイスについて、そのチャネルが説明され、ユーザーデバイスについては、そのレジスターがポイントにマップされます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p7/gh/cu/p7ghcubristizrus5hzq_zlfo5i.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/xr/go/nk/xrgonkcogvsn-6j2vjktiiryrlw.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
modbusネットワークの構築に必要なすべてのデータを含むこのような構成ファイルを使用すると、入力/出力デバイスを追加/削除/変更する必要がある場合、プロジェクトのソースコードを変更できません。コンフィギュレーターのパラメーターを変更して構成ファイルに保存するだけで十分です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起動時に、通信コアは構成を解析し、それに基づいてコントローラーの各rs485ポートの論理デバイスのリストを作成します。その後、各ポートでスレッドが作成され、物理デバイスの周期的なポーリングが開始されます。</font></font><br>
<br>
<pre><code class="plaintext hljs">core git repo: https://github.com/azhigaylo/homebrain_core</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
mqttゲートウェイを作成しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、コントローラポイントは、ディスクリートとアナログの両方にあり、それらにアクセスするための独自のインターフェースを備えているため、誰にとってもほとんど関心がありません。したがって、1つの方法しかありません-mqtt。これは現在、小さなメッセージを交換するための最も一般的なプロトコルであり、使用方法も非常にシンプルで理解しやすいと言っても過言ではないと思います。したがって、コントローラからデータをブロードキャストする必要があるとき-何を使用するかについてはあまり考えませんでした。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/o_/sf/w0/o_sfw0yj5i-ptu7ohxdqdvnmw68.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
なぜならパラメータがたくさんあるので、ゲートウェイ設定ファイルに絶えず混乱があり、mqttゲートウェイトピックへのコントローラポイントのマッピングが登録されていました。 Googleがこのテーブルを支援し、このテーブルのcsvパーサーをゲートウェイのjson構成ファイルに書き込みました。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/b-/wt/zm/b-wtzmutugygf-_8mj5odnnrguw.jpeg"><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゲートウェイgit repo </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パーサーgit repo</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライティングポイントモニター。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントローラーポイントで何が起こっているかを確認することが非常に役立つ場合があります。これは、通信コアに直接接続し、離散ポイントとアナログポイントのステータスを読み取る小さなアプリケーションを作成したためです。 UIはかなりタイトなので、なんとかしてアプリケーションをQMLに投げ込むことができました。きしみで動作し、ポイントを数えることができ、記録できますが、それ以上は必要ありません。</font></font><br>
<br>
<pre><code class="plaintext hljs">pointmonitor git repo: https://github.com/azhigaylo/pointmonitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取り専用ファイルシステムをマウントします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常、これに注意を払う人はほとんどいません。本番プロジェクトでも、rootfsを含むパーティションが書き込み可能なデバイスを見つけることができます。これは遅かれ早かれ、最も安定したファイルシステムでさえもクラッシュします。なぜならコントローラーはいつでもオフにできるので、これが発生するのは時間の問題です。この確率を最小限に抑えるには、上記のように、fstabを少しいじって、rootfsイメージを配置する前に、イメージを配置する必要があります。 fstabでは、最初にファイルシステムを読み取り専用としてマウントする必要があります。次に、変更可能なすべてのものをtmpfsにマップできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私のfstabはこれです、あなたのために異なる場合があります：</font></font><br>
<br>
<pre><code class="plaintext hljs">/dev/root / auto ro 0 1<font></font>
tmpfs /tmp tmpfs nodev,nosuid,size=50M 0 0<font></font>
tmpfs /srv tmpfs nodev,size=50M 0 0<font></font>
tmpfs /var/log tmpfs defaults,noatime,size=50M 0 0<font></font>
tmpfs /var/tmp tmpfs defaults,noatime,size=50M 0 0<font></font>
tmpfs /var/run tmpfs defaults,noatime,size=50M 0 0<font></font>
tmpfs /var/lib tmpfs defaults,noatime,size=10M 0 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コントローラー本体 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3Dプリンターは各農家エンジニアのマストヘッドセクションに長い間含まれていましたが、残念ながら私にはありませんが、現在は稼働しています。</font><font style="vertical-align: inherit;">最近、彼のための他の従業員の興奮が消えました、私が必要なものと必要でないものすべてを印刷するときにこれを使用します、あなたは私の以前の投稿を読んでこれを確信することができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはFreeCADで描画し、Curaでgcodeを生成し、ボードのシート、コネクターのカットアウト、DINレール上のクリップの冷却と住宅ローンを作成することを忘れずにケースを取得します。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7m/yc/y6/7mycy6gz9axqfvspdk_cmyz5oc8.jpeg"><br>
<br>
<img src="https://habrastorage.org/webt/j5/i3/dv/j5i3dvtfcb8wkpn1t0uphq7d9lg.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、ボード、SDカード上のソフトウェア、およびケースが完成しました。</font><font style="vertical-align: inherit;">ファイルを取り出し（冗談ではありません）、すべてを一緒に接続し、電源、RS485ケーブルを接続すると、すべてが機能し始めます。</font><font style="vertical-align: inherit;">そして、あなたは難しい、難しいと言いました...</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja462227/index.html">8月9日、モスクワ-バックエンドストーリー4.0</a></li>
<li><a href="../ja462245/index.html">Linuxカーネルの例としての自動git bisect</a></li>
<li><a href="../ja462251/index.html">ブラウザのシークレットモードはフィクションですか？</a></li>
<li><a href="../ja462253/index.html">ReddコンプレックスのFPGAでのCPUおよびプロセッサ通信の例でストリーミングプロトコルを使用した最初の実験</a></li>
<li><a href="../ja462257/index.html">KubernetesのKafka-それは良いですか？</a></li>
<li><a href="../ja462263/index.html">床へのペダル：PC用の別の足のマニピュレーターを作成する</a></li>
<li><a href="../ja462265/index.html">Pythonとキューブ</a></li>
<li><a href="../ja462269/index.html">ジョン・ロメロからドゥーム：80年代のゲーム開発</a></li>
<li><a href="../ja462271/index.html">iOSでコードをロックする：Appleが防御から防御へと切り替わった方法</a></li>
<li><a href="../ja462273/index.html">digisparkでラップトップスタンドを管理する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>