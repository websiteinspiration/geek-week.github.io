<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙆🏾 🏂🏻 👨🏼‍🚒 プログラムのソースコードの静的分析における機械学習の使用 🐔 🤵🏾 ↔️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="機械学習は、音声認識から医療診断まで、人間の活動のさまざまな分野に深く根ざしています。このアプローチの人気は非常に高いため、可能な限り使用しようとしています。古典的なアプローチをニューラルネットワークに置き換えるいくつかの試みはそれほど成功していません。バグや潜在的な脆弱性を見つけるための効果的な静...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>プログラムのソースコードの静的分析における機械学習の使用</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/484208/"><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/0e0/738/38e0e0738ea8b928bdecb77040a207c1.png" alt="プログラムのソースコードの静的分析における機械学習の使用"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習は、音声認識から医療診断まで、人間の活動のさまざまな分野に深く根ざしています。</font><font style="vertical-align: inherit;">このアプローチの人気は非常に高いため、可能な限り使用しようとしています。</font><font style="vertical-align: inherit;">古典的なアプローチをニューラルネットワークに置き換えるいくつかの試みはそれほど成功していません。</font><font style="vertical-align: inherit;">バグや潜在的な脆弱性を見つけるための効果的な静的コードアナライザーを作成するという観点から、機械学習を見てみましょう。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioチームは、プログラムのソースコードのエラーを見つけるために機械学習の使用を開始するかどうかをよく尋ねられます。</font><font style="vertical-align: inherit;">短い答え：はい、ただし非常に限られています。</font><font style="vertical-align: inherit;">コード分​​析の問題で機械学習を使用すると、多くの落とし穴があると私たちは信じています。</font><font style="vertical-align: inherit;">記事の後半では、それらについて説明します。</font><font style="vertical-align: inherit;">新しいソリューションとアイデアのレビューから始めましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">新しいアプローチ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
現在、ディープラーニングやエラー検出用のNLPなど、機械学習に基づいた、またはそれを使用した静的アナライザーの実装がすでに多数あります。</font><font style="vertical-align: inherit;">愛好家だけでなく、Facebook、Amazon、Mozillaなどの大企業も、エラーを検索するときに機械学習の可能性に注目を集めました。</font><font style="vertical-align: inherit;">一部のプロジェクトは本格的な静的アナライザーではありませんが、その間にのみ、コミット中に特定のエラーが見つかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、ほとんどすべてが、人工知能の助けを借りて開発プロセスを変えるゲームチェンジャー製品として位置付けられています。</font></font><p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/28c/cde/532/28ccde53241d54d5b927234ff729a19d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
よく知られている例をいくつか考えてみましょう。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディープコード</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推測、Sapienz、SapFix</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embold</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース{d}</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">賢いコミット、コミットアシスタント</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CodeGuru</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ディープコード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Deep Codeは、Java、JavaScript、TypeScript、Pythonで記述されたプログラムのコードに含まれる脆弱性検索ツールで、機械学習がコンポーネントとして存在します。ボリス・パスカレフによれば、すでに25万以上のルールが機能しています。このツールは、開発者がオープンプロジェクトのソースコード（100万レポジトリ）に加えた変更に基づいてトレーニングされます。会社自体は彼らのプロジェクトが開発者にとって文法的であると言います。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/f09/8df/0c0f098dfabd07a95df228b434ab3bfb.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本質的に、このアナライザーはソリューションをプロジェクトのデータベースと比較し、他の開発者の経験から推定された最良のソリューションを提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2018年5月、開発者はC ++言語のサポートが準備されていると書いていますが、この言語はまだサポートされていません。</font><font style="vertical-align: inherit;">サイト自体は、新しい言語の追加はほんの数週間で行えることを示していますが、言語に依存するステップは1つだけなので、解析します。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a38/68e/7e5/a3868e7e5efa50016e7a7858054da47a.png"></div><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/111/984/4f5/1119844f5406645778271c64f12d0df9.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーのベースとなっているメソッドに関する一連の出版物もサイトに公開されています。 </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">推測する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Facebookはその製品に新しいアプローチを導入するためにかなり広く試みています。彼らは注意と機械学習をバイパスしませんでした。 2013年、彼らはマシンベースのスタティックアナライザーを開発するスタートアップを購入しました。そして2015年に、プロジェクトのソースコード</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がオープンになりました</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inferは、Java、C、C ++、およびObjective-Cで記述されたプロジェクト用の静的アナライザーであり、Facebookによって開発されました。サイトによると、それはアマゾンウェブサービス、Oculus、Uber、および他の人気のあるプロジェクトでも使用されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inferは現在、ヌルポインターの逆参照に関連するエラー、メモリリークを見つけることができます。</font><font style="vertical-align: inherit;">推論は、抽象的な解釈の理論だけでなく、Hoarの論理、分離論理、双拉致にも基づいています。</font><font style="vertical-align: inherit;">これらのアプローチを使用すると、アナライザーはプログラムを小さなブロック（チャンク）に分割し、それらを互いに独立して分析できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プロジェクトでInferを使用することもできますが、開発者はFacebookプロジェクトでは有用な応答が結果の80％を占めているが、他のプロジェクトでは低い誤検知が保証されないことを警告しています。</font><font style="vertical-align: inherit;">Inferがまだ見つけられないエラーの一部ですが、開発者はそのようなトリガーの導入に取り組んでいます。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">配列から出る;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例外のキャスト;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">未検証のデータの漏洩;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レースレース状態。</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サフィックス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SapFixは自動編集ツールです。</font><font style="vertical-align: inherit;">テスト自動化ツールであるSapienzとInfer静的アナライザーから情報を受け取り、最新の変更とメッセージに基づいて、Inferはエラーを修正するためのいくつかの戦略の1つを選択します。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/547/de6/baa/547de6baa2d74f4e3be984a78c704d45.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
場合によっては、SapFixは変更のすべてまたは一部をロールバックします。</font><font style="vertical-align: inherit;">他の場合では、彼は修正パターンのセットからパッチを生成することによって問題を解決しようとします。</font><font style="vertical-align: inherit;">このセットは、すでに一度行われた編集のセットからプログラマー自身によってコンパイルされた編集テンプレートから形成されます。</font><font style="vertical-align: inherit;">そのようなテンプレートでエラーが修正されない場合、SapFixはテンプレートを状況に合わせて調整し、解決策が見つかるまで抽象構文ツリーに小さな変更を加えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、1つの解決策では不十分な場合があるため、SapFixは3つの質問に基づいて選択されたいくつかの解決策を収集します。コンパイルエラー、クラッシュ、編集によって新しいクラッシュが発生するかどうか。</font><font style="vertical-align: inherit;">編集が完全にテストされた後、パッチはレビューのためにプログラマに送られ、どの編集が問題を最も解決するかを決定します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Embold</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Emboldは、プログラムのソースコードを静的に分析するためのスタートアッププラットフォームで、名前を変更する前はGammaと呼ばれていました。</font><font style="vertical-align: inherit;">静的分析は、Cppheck、SpotBugs、SQL Checkなどの組み込みアナライザーに加えて、独自の診断に基づいて実行されます。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f40/406/bd8/f40406bd824b5eeb1815de357d95565b.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
診断自体に加えて、コードベースのロードによってインフォグラフィックを視覚的に表示し、検出されたエラーを簡単に表示し、リファクタリングの可能性を検索する機能に重点が置かれています。</font><font style="vertical-align: inherit;">さらに、このアナライザーには、クラスとメソッドのレベルでコードの構造の問題を検出できる一連のアンチパターンと、システムの品質を計算するためのさまざまなメトリックがあります。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/220/74f/abb/22074fabb8b67de2ce5d5427729387f7.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
主な利点の1つは、通常の診断に加えて、以前の変更に関する情報に基づいて改訂をチェックするソリューションと改訂を提案するインテリジェントシステムです。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e5/122/c46/6e5122c462cd33320eafecd4deac2a49.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
EmboldはNLPを使用してコードを細かく分割し、関数とメソッド間の相互接続と依存関係を探します。これにより、リファクタリングの時間を節約できます。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/94e/129/3fe/94e1293fe9e031d4065beb9ea1b21932.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Emboldは主に、さまざまなアナライザーによるソースコードの分析結果の便利な視覚化と、機械学習に基づく独自の診断機能を提供します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース{d}</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソース{d}は、調査したアナライザーからそれを実装する方法の点で最もオープンです。</font><font style="vertical-align: inherit;">また、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オープンソースのソリューション</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">彼らのウェブサイトで（あなたのメールアドレスと引き換えに）彼らが使っている技術の説明が書かれた小冊子を手に入れることができます。</font><font style="vertical-align: inherit;">また、</font><font style="vertical-align: inherit;">コード分​​析のための機械学習の使用に関連して収集した出版物データベースへの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">リポジトリが</font></a><font style="vertical-align: inherit;">含まれてい</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードのトレーニング用のデータセット。製品自体は、ソースコードとソフトウェア製品を分析するための完全なプラットフォームであり、開発者ではなくマネージャーのリンクに重点を置いています。その機能の中には、技術的負債の量、開発プロセスのボトルネック、およびプロジェクトに関するその他のグローバル統計を特定する機能があります。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/af2/b8c/425/af2b8c42537b1a2628c95773165ed190.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らは、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェアの自然さ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">について」の記事で定式化された自然仮説に基づいて、機械支援コード分析へのアプローチを基にしてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「プログラミング言語は理論的には複雑で柔軟性があり強力ですが、実際の人が実際に作成するプログラムは大部分が単純でかなり反復的であるため、統計的に表現できる有用で予測可能な統計特性があります言語モデルとソフトウェア開発タスクでの使用。」</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この仮説に基づいて、アナライザーをトレーニングするためのコードベースが大きいほど、統計的プロパティが目立ち、トレーニングによって達成されるメトリックがより正確になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードを分析するために、ソース{d}はBabelfishサービスを使用します。このサービスは、使用可能な任意の言語のコードを含むファイルを解析し、抽象構文ツリーを取得して、汎用構文ツリーに変換できます。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39e/bbd/c4d/39ebbdc4d561895c1f7b9e251d44e17c.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ソース{d}はコード内のエラーを検索しません。</font><font style="vertical-align: inherit;">ツリー全体に基づいて、プロジェクト全体に基づく機械学習を使用して、ソース{d}はコードのフォーマット方法、プロジェクトで使用されているコーディングスタイル、およびコミット時に明らかにし、新しいコードがプロジェクトのコードスタイルと一致しない場合は、適切な変更を行います。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e7f/196/c0a/e7f196c0a742ba8f68436b157708c109.png"></div><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/deb/f51/7bd/debf517bd5d74c2553a9b7fbd112a1b2.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニングは、スペース、タブ、改行など、いくつかの基本的な要素によって導かれます。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/39a/ade/8c5/39aade8c5ea77cb3bf89d4a0e999c5f7.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これについて詳しくは、「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スタイルアナライザー：解釈可能な教師なしアルゴリズムによるコードスタイルの不整合の修正</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を参照してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、ソース{d}は、開発者の有効性の計算からコードレビューに費やされた時間の特定まで、ソースコードとプロジェクト開発プロセスに関するさまざまな統計を収集するための幅広いプラットフォームです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">賢いコミット</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Clever-Commitは、Ubisoftと共同でMozillaによって作成されたアナライザーです。</font><font style="vertical-align: inherit;">これは</font><font style="vertical-align: inherit;">、Ubisoftによる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CLEVER</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（バグ防止と解決技術の組み合わせレベル）の調査とそれに基づくコミットアシスタントに基づいており、エラーを含む可能性のある疑わしいコミットを特定します。</font><font style="vertical-align: inherit;">CLEVERはコード比較に基づいているため、危険なコードを示すだけでなく、可能な修正に関する提案も行います。</font><font style="vertical-align: inherit;">説明によれば、60〜70％のケースでClever-Commitは問題のある領域を検出し、同じ頻度でそれらを正しく修正します。</font><font style="vertical-align: inherit;">一般に、このプロジェクトとそれが検出できるエラーに関する情報はほとんどありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CodeGuru</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに最近では、機械学習を使用するアナライザーのリストに、AmazonのCodeGuruと呼ばれる製品が補充されています。このサービスは機械学習に基づいており、コード内のエラーを見つけたり、コード内のコストのかかるセクションを特定したりできます。これまでのところ、分析はJa​​vaコードのみを対象としていますが、将来的には他の言語のサポートについても書いています。最近発表されましたが、AWS（Amazon Web Services）のCEOであるAndy Jassiは、Amazon自体で長い間使用されてきたと語っています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このサイトによると、トレーニングはAmazon自体のコードベースと、10,000を超えるオープンソースプロジェクトで行われたという。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実際、サービスは2つの部分に分かれています。関連性のあるルールを検索してコードのエラーを探すことでトレーニングされたCodeGuru Reviewerと、アプリケーションのパフォーマンスを監視するCodeGuru Profilerです。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee0/662/3a6/ee06623a61ab3f1345d05f169f3325ac.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、このプロジェクトについて公開されている情報はあまりありません。</font><font style="vertical-align: inherit;">このサイトによると、「ベストプラクティス」からの逸脱を見つける方法を学ぶために、レビュー担当者はAmazonコードベースを分析し、AWS API呼び出しを含むプルリクエストを探します。</font><font style="vertical-align: inherit;">次に、加えられた変更を確認し、並行して分析されるドキュメントのデータと比較します。</font><font style="vertical-align: inherit;">その結果が「ベストプラクティス」のモデルです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カスタムコードの推奨事項は、推奨事項に関するフィードバックを受け取った後に改善されるとも言われています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定のエラードキュメントが公開されていないため、Reviewerが応答するエラーのリストはかなり不明瞭です。</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AWSのベストプラクティス </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">並列処理</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リソースリーク</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">機密情報漏洩</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コーディングの一般的な「ベストプラクティス」</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちの懐疑論</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、長年にわたって静的アナライザーを開発してきたチームの目を通してエラーを見つける問題を見てみましょう。</font><font style="vertical-align: inherit;">トレーニングの適用には多くの高レベルの問題があります。それについてお話ししたいと思います。</font><font style="vertical-align: inherit;">ただし、最初は、すべてのMLアプローチをおおまかに2つのタイプに分けます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">合成アナライザーと実際のコード例を使用して、静的アナライザーを手動でトレーニングし、さまざまな問題を探します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多数のオープンソースコード（GitHub）と変更履歴でアルゴリズムをトレーニングすると、アナライザー自体がエラーを検出し、修正を提案し始めます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
方向性にはさまざまな欠点があるため、各方向について個別に説明します。</font><font style="vertical-align: inherit;">その後、なぜ私たちが機械学習の可能性を否定しないだけでなく、熱意を共有しないのかが読者に明らかになると思います。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルな汎用スタティックアナライザーの開発という視点から見ていきます。</font><font style="vertical-align: inherit;">私たちは特定のコードベースではなく、どのチームでもどのプロジェクトでも使用できるアナライザーの開発に焦点を当てています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">静的アナライザーの手動トレーニング</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーがコード内の次の形式の異常を探し始めるようにMLを使用するとします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span> (A == A)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
変数をそれ自体と比較するのは奇妙です。正しいコードと正しくないコードの多くの例を記述して、そのようなエラーを探すようにアナライザーをトレーニングできます。さらに、テストですでに見つかったエラーの実際の例を追加できます。もちろん問題は、これらの例をどこで入手できるかです。しかし、それは可能であると考えます。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V501</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V3001</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6001の</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ようなエラーの例がいくつか蓄積されてい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、機械学習アルゴリズムを使用してコード内のそのような欠陥を検索することは可能ですか？できる。しかし、これを行う理由は明らかではありません！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザをトレーニングするには、トレーニング用のサンプルの準備に多くの労力を費やす必要があります。</font><font style="vertical-align: inherit;">または、実際のアプリケーションのコードをマークアップして、誓う場所としない場所を示します。</font><font style="vertical-align: inherit;">いずれの場合も、トレーニングには何千もの例があるはずなので、多くの作業を行う必要があります。</font><font style="vertical-align: inherit;">または数万人。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、ケース（A == A）だけでなく、次のものも検索したいのです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（X &amp;&amp; A == A）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（A + 1 == A + 1）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（A [i] == A [i]）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if（（A）==（A））</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等 </font></font></li>
</ul><br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19e/a51/95d/19ea5195d9075802dbdcd3feda3c4aad.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、このような単純な診断がPVS-Studioでどのように実装されるかを見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RulePrototype_V501</span><span class="hljs-params">(VivaWalker &amp;walker,
  <span class="hljs-keyword">const</span> Ptree *left, <span class="hljs-keyword">const</span> Ptree *right, <span class="hljs-keyword">const</span> Ptree *operation)</span>
</span>{
  <span class="hljs-keyword">if</span> (SafeEq(operation, <span class="hljs-string">"=="</span>) &amp;&amp; SafeEqual(left, right))<font></font>
  {<font></font>
    walker.AddError(<span class="hljs-string">" , !"</span>, left, <span class="hljs-number">501</span>, Level_1, <span class="hljs-string">"CWE-571"</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以上です。</font><font style="vertical-align: inherit;">サンプルのトレーニングベースは必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
将来的には、診断は多くの例外を考慮に入れて、（A [0] == A [1-1]）を宣誓する必要があることを理解するように教えられるべきです。</font><font style="vertical-align: inherit;">ただし、これはすべてプログラミングが非常に簡単です。</font><font style="vertical-align: inherit;">しかし、トレーニングの例のベースだけで、すべてが悪くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらの場合も、テストシステム、ドキュメントの作成などが引き続き必要です。</font><font style="vertical-align: inherit;">ただし、新しい診断を作成する努力は明らかに、ルールがコードにハードコードされている従来のアプローチの片側にあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、他のルールを見てみましょう。</font><font style="vertical-align: inherit;">たとえば、一部の関数の結果を使用する必要があるということです。</font><font style="vertical-align: inherit;">結果を使用せずに呼び出しても意味がありません。</font><font style="vertical-align: inherit;">これらの機能の一部を以下に示します。</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memcmp</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列::空</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、これはPVS-Studioに実装された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V530</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">の診断で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">行わ</font></a><font style="vertical-align: inherit;">れる</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ことです</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、作業の結果が使用されないような関数の呼び出しを探します。これを行うには、多くのテストを生成できます。そして、すべてがうまくいくと思います。しかし、これがなぜ必要なのかは明らかではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioアナライザーでのすべての例外を除くV530診断の実装は、258行のコードで、そのうち64行がコメントです。さらに、関数の注釈付きの表があり、その結果を使用する必要があることに注意してください。この表の補充は、合成例を作成するよりもはるかに簡単です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに悪いのは、データフロー分析を使用する診断の場合です。</font><font style="vertical-align: inherit;">たとえば、PVS-Studioアナライザーはポインターの値を追跡できるため、このようなメモリリークを見つけることができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">uint32_t</span>* <span class="hljs-title">BnNew</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">uint32_t</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint32_t</span>[kBigIntSize];
  <span class="hljs-built_in">memset</span>(result, <span class="hljs-number">0</span>, kBigIntSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">uint32_t</span>));
  <span class="hljs-keyword">return</span> result;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> <span class="hljs-title">AndroidRSAPublicKey</span><span class="hljs-params">(crypto::RSAPrivateKey* key)</span> </span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">uint32_t</span>* n = BnNew();<font></font>
  ....<font></font>
  RSAPublicKey pkey;<font></font>
  pkey.len = kRSANumWords;<font></font>
  pkey.exponent = <span class="hljs-number">65537</span>; <span class="hljs-comment">// Fixed public exponent</span>
  pkey.n0inv = <span class="hljs-number">0</span> - ModInverse(n0, <span class="hljs-number">0x100000000</span>LL);
  <span class="hljs-keyword">if</span> (pkey.n0inv == <span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> kDummyRSAPublicKey;   <span class="hljs-comment">// &lt;=</span><font></font>
  ....<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chromium：メモリリーク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」という記事の例を取り上げ</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">条件</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（pkey.n0inv == 0）が満たされた</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合、関数は、変数</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nに</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">格納されているポインタを含むバッファを解放せずに終了します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioの観点からは、複雑なものは何もありません。</font><font style="vertical-align: inherit;">アナライザーは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BnNew</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">関数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">調べ、</font><font style="vertical-align: inherit;">割り当てられたメモリのブロックへのポインターを返すことを思い出しました。</font><font style="vertical-align: inherit;">別の関数では、バッファが解放されず、関数が終了するとバッファへのポインタが失われる可能性があることに気付きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
値を追跡するための一般的なアルゴリズムは機能します。コードの記述方法は問題ではありません。ポインタの操作に関係のない関数の他の部分は問題ではありません。アルゴリズムは汎用的であり、V773診断はさまざまなプロジェクトで多くのエラーを検出します。</font><font style="vertical-align: inherit;">エラーが検出され</font><font style="vertical-align: inherit;">た</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードフラグメントの</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いを確認してください</font><font style="vertical-align: inherit;">！</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは機械学習の専門家ではありませんが、大きな問題があるようです。メモリリークのあるコードを書く方法は信じられないほどたくさんあります。マシンが変数の値を追跡するようにトレーニングされている場合でも、関数呼び出しがあることを理解するためにトレーニングする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
訓練には非常に多くの例が必要になるため、タスクが困難になるという疑いがあります。実現不可能とは言いません。アナライザーの作成コストが報われるとは思えません。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">類推。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナロジーは計算機で思い浮かびますが、診断の代わりに算術演算をプログラムする必要があります。 1 + 1 = 2、1 + 2 = 3、2 + 1 = 3、100 + 200 = 300などの演算の結果に関する知識ベースを導入することにより、MLベースの計算機に数値を適切に追加するように教えることができると確信しています。ご存知のように、このような計算機を開発することの妥当性は大きな問題です（助成金が割り当てられていない場合:)。コード内の通常の「+」演算を使用して、はるかに単純で、高速で、より正確で信頼性の高い計算機を作成できます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">メソッドが機能します。</font><font style="vertical-align: inherit;">しかし、私たちの意見では、それを使用することは実用的ではありません。</font><font style="vertical-align: inherit;">特にデータストリームの分析に基づく複雑な診断の実装に関しては、開発に時間がかかり、結果の信頼性と精度が低下します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのオープンソースから学ぶ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、私たちは手動の合成例を考え出しましたが、GitHubがあります。</font><font style="vertical-align: inherit;">コミットの履歴を追跡し、コード変更/修正のパターンを導出できます。</font><font style="vertical-align: inherit;">次に、疑わしいコードのセクションを指摘するだけでなく、それを修正する方法を提案することもできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この詳細レベルで停止すると、すべてが問題なく見えます。</font><font style="vertical-align: inherit;">悪魔は、いつものように、詳細にあります。</font><font style="vertical-align: inherit;">これらの詳細について話しましょう。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最初のニュアンス。</font><font style="vertical-align: inherit;">情報源。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHubでの編集は非常に無秩序で多様です。人々は、アトミックなコミットを行ったり、一度にコードにいくつかの変更を加えたりするのが面倒なことがよくあります。あなたは自分でこれがどのように起こるかを知っています：彼らはエラーを修正し、同時に少しリファクタリングしました（「そしてここで私はそのようなケースの処理を同時に追加します...」）。それでも、これらの変化が互いに関連しているかどうかは、人にははっきりしないかもしれません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題は、実際のエラーを新しい機能や他の何かを追加することからどのように区別するかです。もちろん、コミットをマークするために手動で1,000人を植えることもできます。ここでエラーを修正したこと、ここでのリファクタリング、ここでの新機能、ここでの要件の変更などを示す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このマークアップは可能ですか？可能。しかし、変化がどれほど速く発生するかに注意してください。 「GitHubに基づいてアルゴリズム自体を学習する」のではなく、すでに何百人もの人々を長い間困惑させる方法について話し合っています。人件費とツールを作成するコストは大幅に増加します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エラーが正確に修正された場所を自動的に特定することができます。これを行うには、コミットに関するコメントを分析し、ローカルでの小さな編集に注意を払う必要があります。これは、ほとんどの場合、まさにエラー修正です。バグ修正を自動的に検索できるかどうかは言いがたいです。いずれにせよ、これは別の研究とプログラミングを必要とする大きな仕事です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、まだトレーニングに到達していませんが、すでにニュアンスがあります:)。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第二のニュアンス。開発の遅れ。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GitHubなどのデータベースに基づいてトレーニングされるアナライザーは、常に「精神遅滞」などの症候群の影響を受けます。これは、プログラミング言語が時間とともに変化するためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃8.0 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Null参照例外（NRE）の処理に役立つNullable参照型が</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">導入されました</font></a><font style="vertical-align: inherit;">。 JDK 12では、新しいswitchステートメント（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JEP 325</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）が</font><font style="vertical-align: inherit;">導入されてい</font><font style="vertical-align: inherit;">ます。 C ++ 17では、コンパイル段階で条件付き構文を実行できるようになりました（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constexpr if</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。等。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミング言語は進化しています。</font><font style="vertical-align: inherit;">さらに、C ++などは非常に高速でアクティブです。</font><font style="vertical-align: inherit;">新しいデザインが登場し、新しい標準機能が追加されます。</font><font style="vertical-align: inherit;">新しい機能に加えて、静的コード分析を使用して特定したい新しいエラーパターンも表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで検討中の教育方法には問題があります。エラーパターンはすでにわかっている可能性があり、それを特定したいのですが、そこから学ぶことは何もありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題を具体的な例で見てみましょう。</font><font style="vertical-align: inherit;">範囲ベースのforループはC ++ 11で登場しました。</font><font style="vertical-align: inherit;">また、次のコードを記述して、コンテナ内のすべての要素を反復できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers;<font></font>
....<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : numbers)<font></font>
  foo(num);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいサイクルでは、新しいエラーパターンが発生しました。</font><font style="vertical-align: inherit;">コンテナがループ内で変更されると、「シャドウ」イテレータが無効になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の誤ったコードを考えてみます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : numbers)<font></font>
{<font></font>
  numbers.push_back(num * <span class="hljs-number">2</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイラはそれを次のようなものに変えます：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> __begin = begin(numbers), __end = end(numbers); <font></font>
     __begin != __end; ++__begin) { <font></font>
  <span class="hljs-keyword">int</span> num = *__begin; <font></font>
  numbers.push_back(num * <span class="hljs-number">2</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">push_back</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
操作</font><font style="vertical-align: inherit;">中に、ベクター内のメモリ割り当て</font><font style="vertical-align: inherit;">が発生した</font><font style="vertical-align: inherit;">場合</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、__ begin</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__end</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イテレータの</font><i><font style="vertical-align: inherit;">無効化</font></i><font style="vertical-align: inherit;">が発生する可能性があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">結果は、未定義のプログラム動作になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのため、エラーパターンは古くから知られており、文献にも記載されています。</font><font style="vertical-align: inherit;">PVS-Studioアナライザーは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V789</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">診断を使用して診断</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">、開いているプロジェクトで</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実際のエラー</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">すでに検出してい</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパターンに気付くのに十分な時間、GitHubに新しいコードが追加されるのはいつですか良い質問...範囲ベースのforループが出現しても、すべてのプログラマーがすぐにそれを大量に使用し始めたことを意味するわけではありません。新しいループを使用して多くのコードが表示されるまでには数年かかる場合があります。さらに、多くのエラーはコミットする必要があり、その後、アルゴリズムが変更のパターンを認識できるようにエラーを修正する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何年経るべきですか？五？十？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
十は多すぎる、そして我々は悲観論者なのか？どういたしまして。 C ++ 11で範囲ベースのforループが登場したため、この記事が書かれた時点で8年が経過しました。しかし、これまでのところ、データベースに</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">は3つのケース</font></a><font style="vertical-align: inherit;">しか書き出され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">てい</font></a><font style="vertical-align: inherit;">ません。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そのような間違い。 3つの間違いは多くはなく、少なからずです。彼らの数から、1つはいかなる結論も引き出す​​べきではない。最も重要なのは、そのようなエラーパターンが本物であり、それを検出することが理にかなっていることを確認できることです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、この数値を、たとえば次のエラーパターンと比較し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ポインタは検証前に逆参照され</font></a><font style="vertical-align: inherit;">ます。全体として、オープンソースプロジェクトをチェックしたところ、すでに1716のケースが確認されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、範囲ベースのforループエラーを探すべきではありませんか？番号。プログラマーだけが慣性であり、この演算子の人気は非常にゆっくりと高まっています。徐々に、彼の参加により多くのコードが存在するようになり、それに応じてより多くのエラーも発生します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ほとんどの場合、これはC ++ 11が登場してから10〜15年後にのみ発生します。そして今、哲学的な質問です。すでにエラーパターンを知っているので、オープンプロジェクトで多くのエラーが蓄積されるまで、何年も待ちますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えが「はい」の場合、MLに基づいてすべての分析者に対して「精神遅滞」という診断を合理的に診断することが可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
答えが「いいえ」の場合、どうすればよいですか？例はありません。それらを手動で書くには？しかし、それから前の章に戻ります。そこでは、人にトレーニングの多くの例を書くことを検討しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは可能ですが、ここでも便宜の問題が生じます。 PVS-Studioアナライザーでのすべての例外を含むV789診断の実装は、コードがわずか118行で、そのうち13行がコメントです。それら。これは非常に単純な診断であり、簡単に取得して、古典的な方法でプログラムすることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様の状況は、他の言語で表示される他のイノベーションにも当てはまります。彼らが言うように、考えるべきことがある。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第三のニュアンス。ドキュメンテーション。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
静的アナライザーの重要なコンポーネントは、各診断を説明するドキュメントです。それがなければ、アナライザーの使用は非常に困難または不可能ですらあります。では</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studioの場合、各診断の説明があり、エラーコードの例とその修正方法が示されています。</font><font style="vertical-align: inherit;">問題の代替説明を読むことができる</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CWE</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">への</font><font style="vertical-align: inherit;">リンクも</font><font style="vertical-align: inherit;">あります。それと同じですが、時にはユーザーには理解できないことがあり、明確な質問をしてくれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機械学習アルゴリズムに基づくスタティックアナライザーの場合、ドキュメントの問題は何らかの形で抑制されます。アナライザーは、疑わしいと思われる場所を単に示し、おそらくそれを修正する方法を提案することさえ想定されています。補正を行うかどうかの決定は、その人に委ねられます。そして、ここで... ahem ...アナライザーがコード内のどこかで疑わしいと思われる根拠に基づいて、読み取ることができないという決定を下すことは容易ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、場合によってはすべてが明白になります。</font><font style="vertical-align: inherit;">アナライザーが次のコードを指しているとします。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(src + <span class="hljs-number">1</span>));
<span class="hljs-built_in">strcpy</span>(p, src);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そしてそれを次のものに置き換えることを提案します：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(src) + <span class="hljs-number">1</span>);
<span class="hljs-built_in">strcpy</span>(p, src);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラマーが封印し、間違った場所に1を追加したことがすぐにわかります。</font><font style="vertical-align: inherit;">その結果、割り当てられるメモリが少なくなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、ドキュメントがなければ、すべてが明確です。</font><font style="vertical-align: inherit;">ただし、常にそうであるとは限りません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
アナライザーが静かにこのコードを指すと想像してください：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uint8 *hash_stage2)</span> </span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、戻り値の型をcharからintに変更することを提案します：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">const</span> uint8 *hash_stage2)</span> </span>{<font></font>
  ....<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">memcmp</span>(hash_stage2, hash_stage2_reassured, SHA1_HASH_SIZE);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
警告に関するドキュメントはありません。そして、明らかに、完全に独立したアナライザーについて話している場合、警告のテキスト自体も、私たちが理解しているように、そうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何をすべきか？違いはなんですか？私はそのような交換をするべきですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、ここではチャンスを利用してコードを修正することに同意できます。編集を理解せずに受け入れますが、これは</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まあまあの</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">習慣です... :) </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;">memcmp</font></i></a><font style="vertical-align: inherit;">関数の説明を見</font><font style="vertical-align: inherit;">て、関数が</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：0の</font><font style="vertical-align: inherit;">値</font><font style="vertical-align: inherit;">より大きく、0より小さい</font><font style="vertical-align: inherit;">ことを返すことが</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;">わかり</font></i></a><font style="vertical-align: inherit;">ます。しかし、それでも、コードがなくてもコードが既に正常に機能しているのに、なぜ変更を加えるのかが明確でない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、そのような編集の要点がわからない場合は、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">V642</font></a><font style="vertical-align: inherit;">診断の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">説明を</font></a><font style="vertical-align: inherit;">確認してください。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これが本当の間違いであることはすぐに明らかになります。</font><font style="vertical-align: inherit;">さらに、それは脆弱性を引き起こす可能性があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たぶん、この例は説得力がないように見えました。</font><font style="vertical-align: inherit;">結局、アナライザーはより良いと思われるコードを提案しました。</font><font style="vertical-align: inherit;">OK </font><font style="vertical-align: inherit;">今回は変更のために、Javaの別の疑似コードの例を見てみましょう。</font></font><br>
<br>
<pre><code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(....);<font></font>
SerializedObject obj = <span class="hljs-keyword">new</span> SerializedObject();<font></font>
obj.state = <span class="hljs-number">100</span>;<font></font>
out.writeObject(obj);<font></font>
obj.state = <span class="hljs-number">200</span>;<font></font>
out.writeObject(obj);<font></font>
out.close();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ある種のオブジェクトがあります。</font><font style="vertical-align: inherit;">連載中です。</font><font style="vertical-align: inherit;">次に、オブジェクトの状態が変化し、再度シリアル化されます。</font><font style="vertical-align: inherit;">すべて問題ないようです。</font><font style="vertical-align: inherit;">今度は、アナライザーが突然このコードを気に入らなくなったと想像してください。</font></font><br>
<br>
<pre><code class="java hljs">ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(....);<font></font>
SerializedObject obj = <span class="hljs-keyword">new</span> SerializedObject();<font></font>
obj.state = <span class="hljs-number">100</span>;<font></font>
out.writeObject(obj);<font></font>
obj = <span class="hljs-keyword">new</span> SerializedObject();  <span class="hljs-comment">//   </span>
obj.state = <span class="hljs-number">200</span>;<font></font>
out.writeObject(obj);<font></font>
out.close();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを変更して再記録する代わりに、新しいオブジェクトが作成され、すでにシリアル化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
問題の説明はありません。ドキュメントはありません。コードが長くなりました。何らかの理由で、新しいオブジェクトの作成が追加されました。コードでそのような編集を行う準備ができていますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はっきりしないと言うでしょう。確かに、それは明確ではありません。そして、それは常に理解できないでしょう。そのような「サイレント」アナライザーを使用することは、アナライザーが何かを好きではない理由を理解しようとする試みにおいて無限の研究になるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントがあれば、すべてが透過的になります。クラス</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">java.io.ObjectOuputStream</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">シリアル化に使用され、書き込み可能なオブジェクトをキャッシュします。つまり、同じオブジェクトが2回シリアル化されることはありません。クラスがオブジェクトをシリアル化すると、2回目は同じ最初のオブジェクトへのリンクがストリームに書き込まれます。続きを読む：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">V6076-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反復的なシリアル化では、最初のシリアル化からのキャッシュされたオブジェクトの状態が使用されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメンテーションを持つことの重要性を説明できたことを願っています。そして今、質問です。 MLに基づくアナライザーのドキュメントはどのように表示されますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
古典的なコードアナライザーが開発されると、すべてがシンプルで明確になります。エラーのパターンがあります。ドキュメントで説明し、診断を実装します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MLの場合は、その逆になります。はい、アナライザーはコードの異常に気づき、それを指摘することができます。しかし、彼は欠陥の本質について何も知りません。彼はコードをそのように書くことができない理由を理解しておらず、教えません。これらは高すぎる抽象化です。次に、アナライザーは</font><font style="vertical-align: inherit;">、関数のドキュメント</font><font style="vertical-align: inherit;">を読んで</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">理解</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">することも学ぶ必要があり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すでに述べたように、ドキュメントのトピックは機械学習に関する記事でカバーされているため、これ以上説明する準備ができていません。私たちがレビューのために出したもう1つの大きなニュアンス。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ドキュメントはオプションであると主張できます。アナライザーはGitHubの修正の多くの例につながる可能性があり、そのコミットとコメントを見ると、何が何であるかがわかります。はい、そうです。しかし、アイデアは魅力的に見えません。アナライザーはアシスタントではなく、プログラマーをさらに混乱させるツールとして機能します。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4番目のニュアンス。高度に専門化された言語。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
説明されているアプローチは、静的分析も非常に役立つ非常に専門的な言語には適用できません。その理由は、GitHubやその他のソースには、効果的なトレーニングを提供するのに十分なだけの十分なソースコードベースがないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特定の例でこれを検討してください。はじめに、GitHubにアクセスして、人気のあるJava言語のリポジトリを検索します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：言語：「Java」：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3,128,884の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用可能なリポジトリーの結果</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ロシアの会社</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1Cが</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">発行した会計アプリケーションで使用される特殊言語「1C Enterprise」を使用します</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果：言語：「1C Enterprise」：</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">551の</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用可能なリポジトリーの結果</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、この言語のアナライザーは不要ですか？必要です。そのようなプログラムの分析に対する実用的なニーズがあり、対応するアナライザーはすでに存在しています。たとえば、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Silver Bullet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">によって製造されたSonarQube 1C（BSL）プラグインがあり</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特殊な言語では機械学習のアプローチが難しい理由は、特別な説明は必要ないと思います。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5番目のニュアンス。 C、C ++、#include</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MLベースのコードの静的分析の分野の研究に特化した記事は、Java、JavaScript、Pythonなどの言語に引き寄せられます。これは彼らの極端な人気によって説明されます。しかし、CとC ++言語はどうやら迂回しますが、人気がないとは言えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは人気や約束の問題ではなく、CおよびC ++言語に問題があるという仮説があります。そして今度は、レビューのために1つの不快な問題を「引き出し」ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
抽象c / cppファイルは、コンパイルが非常に困難な場合があります。少なくとも、GitHubからプロジェクトをダウンロードし、cppファイルを選択してコンパイルするだけでは機能しません。次に、これがすべてMLにどのように関係するかを説明します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、アナライザーをトレーニングします。 GitHubからプロジェクトをダウンロードしました。私たちはパッチを知っており、それがエラーを修正すると仮定します。この編集をトレーニングの1つの例にしたいと思います。つまり、編集の前後に.cppファイルがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが問題の始まりです。修正を研究するだけでは十分ではありません。完全なコンテキストが必要です。使用するクラスの説明、使用する関数のプロトタイプ、マクロを開く方法などを理解する必要があります。そのために</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ファイルの</font><font style="vertical-align: inherit;">完全な</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">前処理</font></a><font style="vertical-align: inherit;">を実行する必要</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">があり</font></a><font style="vertical-align: inherit;">ます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を考えてみましょう。</font><font style="vertical-align: inherit;">最初、コードは次のようになりました。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Class::IsMagicWord</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> m_name == <span class="hljs-string">"ML"</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それはこのように修正されました：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">Class::IsMagicWord</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(m_name, <span class="hljs-string">"ML"</span>) == <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このケースに基づいて勉強を始めるべきですか、将来的には</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（x == "y"）</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">をstrcmp（x、 "y"）で</font><font style="vertical-align: inherit;">置き換えることをお勧めし</font><font style="vertical-align: inherit;">ますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問は、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m_name</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンバーが</font><font style="vertical-align: inherit;">クラスで</font><font style="vertical-align: inherit;">どのように</font><i><font style="vertical-align: inherit;">宣言さ</font></i><font style="vertical-align: inherit;">れて</font><font style="vertical-align: inherit;">いるかを知らなければ答えられません</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">たとえば、次のようなオプションがあります。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> {</span><font></font>
  ....<font></font>
  <span class="hljs-keyword">char</span> *m_name;<font></font>
};<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Class</span> {</span><font></font>
  ....<font></font>
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> m_name;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常のインデックスについて話している場合、編集が行われます。変数のタイプを無視する場合、有害な警告と有用な警告（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">std :: stringの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合</font><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を与えることを学ぶことができます</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラス宣言は通常、.hヘッダーファイルにあります。したがって、必要なすべての情報を得るために、前処理を実行する必要があります。これは、CおよびC ++にとって非常に重要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前処理なしで実行できると誰かが言った場合、その人はシャーラタンであるか、単にCまたはC ++言語に十分に精通していないかのどちらかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なすべての情報を収集するには、適切に前処理する必要があります。これを行うには、ビルドプロセス中に設定されるマクロが設定されているヘッダーファイルの場所と場所を知る必要があります。これを行うには、特定のcppファイルがどのように構築されるかを知る必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これが問題です。ファイルを取得してコンパイルするだけではありません（または、前処理されたファイルを生成するようにコンパイラーにキーを指定します）。このファイルがどのようにコンパイルされるかを理解する必要があります。この情報はビルドスクリプトに含まれていますが、そこから取得する方法は次のとおりです。一般的な場合、タスクは非常に困難です。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/be0/9dd/e95be09ddb94d84555c134d961ce9566.png"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、GitHub上の多くのプロジェクトには混乱があります。そこから抽象プロジェクトを取得する場合、コンパイルするためにそれをいじくり回さなければならないことがよくあります。一部のライブラリが欠落しており、手動で見つけてダウンロードする必要があります。それは、対処しなければならない、ある種のサモピスニーアセンブリシステムを使用します。多分何でも。時には、ダウンロードされたプロジェクトは、原則として、アセンブルを拒否し、「ファイルで変更」する必要があります。単にプロジェクトを取り、.cppファイルの前処理済み（.i）表現を自動的に取得する必要はありません。これは手動で行うことさえ難しい場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、アセンブルされていないプロジェクトの問題は理解できますが、怖いものではありません。アセンブルできるプロジェクトでのみ作業しましょう。とにかく、特定のファイルを前処理するタスクは残ります。また、組み込みシステムなど、一部の専用コンパイラを使用する場合については、触れません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、説明されている問題は克服できません。しかし、これはいずれにしても非常に困難で時間のかかる作業です。 CおよびC ++の場合、GitHub上のソースコードだけでは何も生成されません。コンパイラを自動的に起動する方法を学ぶには、膨大な作業を行う必要があります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。それでも読者が問題を理解できない場合は、次の実験を行うことをお勧めします。 GitHubから10の中規模C ++プロジェクトを取得してコンパイルし、.cppファイル用に前処理されたバージョンを取得します。その後、このタスクの複雑さに関する質問は消えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他の言語でも同様の問題が発生する可能性がありますが、CおよびC ++では特に顕著です。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">6番目の警告。誤検知を排除する代償。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
静的アナライザーは誤検知を生成する傾向があり、その数を減らすために診断を常に改善する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前述の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">V789の</font></a><font style="vertical-align: inherit;">診断に戻りましょう</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">範囲ベースのforループ内でコンテナーの変更を検出します。その開発に十分な注意が払われておらず、クライアントが誤検知を報告したとします。彼は、アナライザーがコンテナーを変更した後、サイクルが終了し、したがって問題がない場合のシナリオを考慮に入れないと書いています。そして、アナライザーが誤検知を生成する次のコード例を示します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; numbers;<font></font>
....<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : numbers)<font></font>
{<font></font>
  <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">5</span>)<font></font>
  {<font></font>
    numbers.push_back(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;                <span class="hljs-comment">// , , return</span><font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、これは欠陥です。従来のアナライザーでは、その除去は非常に高速で安価です。 PVS-Studioでは、この例外の実装は26行のコードで構成されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この欠陥は、アナライザーが学習アルゴリズムに基づいて構築されている場合に解消できます。確かに、正しいと見なされるべきコードの数十または数百の例を作成することによって、それを終えることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでも、問題は実現可能性ではなく、実用性です。 MLの場合、顧客を悩ませている特定の誤検知との戦いははるかにコストがかかるという疑いがあります。それら。誤検知を排除するという観点からのカスタマーサポートは、より多くの費用がかかります。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7番目のニュアンス。めったに使われない機能とロングテール。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以前は、高度に専門化された言語の問題が考慮されていましたが、学習に十分なソースコードがない可能性があります。</font><font style="vertical-align: inherit;">まれに使用される関数（システム、WinAPI、一般的なライブラリなど）に関する同様の問題。</font><i><font style="vertical-align: inherit;">strcmpの</font></i></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ようなC言語の関数について話している場合</font><font style="vertical-align: inherit;">、学習の基礎があります。</font><font style="vertical-align: inherit;">GitHub、利用可能なコード結果：</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcmp-40,462,158</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">厳格-1,256,053</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
はい、多くの使用例があります。</font><font style="vertical-align: inherit;">おそらく、アナライザーは、例えば、以下のパターンに気づくことを学習します。</font></font><ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文字列を単独で比較すると奇妙です。</font><font style="vertical-align: inherit;">これは修正されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポインタの1つがNULLの場合は奇妙です。</font><font style="vertical-align: inherit;">これは修正されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この関数の結果が使用されないのは奇妙です。</font><font style="vertical-align: inherit;">これは修正されました。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが素晴らしいですか？</font><font style="vertical-align: inherit;">番号。</font><font style="vertical-align: inherit;">ここで「ロングテール」に出くわします。</font><font style="vertical-align: inherit;">簡単に言えば、「ロングテール」の本質は次のとおりです。</font><font style="vertical-align: inherit;">書店で最も人気があり、現在読んでいる本のトップ50だけを販売することは現実的ではありません。</font><font style="vertical-align: inherit;">はい、そのような本はそれぞれ、たとえばこのリストにない本よりも100倍の頻度で入手されます。</font><font style="vertical-align: inherit;">ただし、収益のほとんどは他の書籍から発生します。</font><font style="vertical-align: inherit;">たとえば、オンラインストアのAmazon.comは、13万を超える「最も人気のあるアイテム」から半分以上の利益を上げています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人気の機能があり、そのうちのいくつか。</font><font style="vertical-align: inherit;">人気のないものもありますが、たくさんあります。</font><font style="vertical-align: inherit;">たとえば、文字列比較関数には次のような種類があります。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g_ascii_strncasecmp-35,695</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lstrcmpiA-27,512</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_wcsicmp_l-5,737</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_strnicmp_l-5,848</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_mbscmp_l-2,458</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、これらの使用頻度ははるかに低くなっていますが、それらを使用しても同じ過ちを犯す可能性があります。</font><font style="vertical-align: inherit;">パターンを特定するには例が少なすぎます。</font><font style="vertical-align: inherit;">ただし、これらの機能は無視できません。</font><font style="vertical-align: inherit;">それらが個別に使用されることはめったにありませんが、それらの使用と合わせて、チェックに役立つ多くのコードが書かれています。</font><font style="vertical-align: inherit;">これが「ロングテール」が現れる場所です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioでは、関数に手動で注釈を付けます。</font><font style="vertical-align: inherit;">たとえば、CおよびC ++の場合、現在約7200個の関数がラベル付けされています。</font><font style="vertical-align: inherit;">マーキングは以下の対象となります：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winapi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C標準ライブラリ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準テンプレートライブラリ（STL）、</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glibc（GNU Cライブラリ）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qt</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MFC</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zlib</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libpng</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">openssl</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方で、これは行き止まりのようです。すべてに注釈を付けることは不可能です。一方、それは動作します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に質問です。 MLの利点は何ですか？重要な利点は見えませんが、困難は見えます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ML自体に基づいて構築されたアルゴリズムは、頻繁に使用される関数のパターンを明らかにし、マークアウトする必要がないと言えます。はい、それは本当だ。ただし、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">strcmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">や</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">malloc</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">などの一般的な関数を個別にマークアップしても問題はありません</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
長い尾を持つと、問題が始まります。合成例を作成してトレーニングできます。ただし、ここでは、記事のセクションに戻ります。ここでは、多くの例を生成するよりも、従来の診断を書く方が簡単かつ高速であると考えました。</font></font><br>
<br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_fread_nolockの</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ような関数を例に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;">とり</font></i></a><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">もちろん、これは</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fread</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">よりも使用頻度が低い</font><font style="vertical-align: inherit;">です。</font><font style="vertical-align: inherit;">しかし、それを使用すると、同じ過ちを犯す可能性があります。</font><font style="vertical-align: inherit;">たとえば、バッファは十分に大きい必要があります。</font><font style="vertical-align: inherit;">このサイズは、2番目と3番目の引数を乗算した結果以上でなければなりません。</font><font style="vertical-align: inherit;">つまり、そのような不正なコードを検出したいのです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> buffer[<span class="hljs-number">10</span>];
<span class="hljs-keyword">size_t</span> n = _fread_nolock(buffer, size_of(<span class="hljs-keyword">int</span>), <span class="hljs-number">100</span>, stream);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PVS-Studioでのこの関数の注釈は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs">C_<span class="hljs-string">"size_t _fread_nolock"</span>
  <span class="hljs-string">"(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File);"</span><font></font>
ADD(HAVE_STATE | RET_SKIP | F_MODIFY_PTR_1,<font></font>
    <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-string">"_fread_nolock"</span>, POINTER_1, BYTE_COUNT, COUNT,<font></font>
    POINTER_2).<font></font>
    Add_Read(from_2_3, to_return, buf_1).<font></font>
    Add_DataSafetyStatusRelations(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、このような注釈は複雑に見えるかもしれませんが、実際には、それらを書き始めると簡単になります。</font><font style="vertical-align: inherit;">さらに、これは書き込み専用のコードであることに注意してください。</font><font style="vertical-align: inherit;">書いて忘れた。</font><font style="vertical-align: inherit;">注釈はほとんど変更されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、MLの観点からこの関数について説明します。</font><font style="vertical-align: inherit;">GitHubは役に立ちません。</font><font style="vertical-align: inherit;">この関数への参照は約15,000あります。</font><font style="vertical-align: inherit;">さらに賢明なコードはありません。</font><font style="vertical-align: inherit;">検索結果の重要な部分は似ています：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> fread_unlocked _fread_nolock</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプションは何ですか？</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何もする必要はありません。</font><font style="vertical-align: inherit;">これはどこにも行かない道です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アナライザーがバッファーサイズと他の引数の関係を理解できるように、この関数だけで数百の例を書いてアナライザーをトレーニングします。</font><font style="vertical-align: inherit;">はい、できますが、経済的に不合理です。</font><font style="vertical-align: inherit;">これはどこにも行かない道です。</font></font></li>
<li>  ,  ,       . ,  .   ML       :).        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、MLとめったに使用されない関数のロングテールは結合されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、MLトピックに関連する人々は私たちに異議を唱え、アナライザーが関数を研究し、彼らが何をしていたかについて結論を出すときは、オプションを考慮に入れなかったと述べました。ここでは、どうやら、私たちは専門家を理解していないか、彼らは私たちを理解していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数本体が不明である可能性があります。たとえば、WinAPIに関連する関数である可能性があります。これがめったに使用されない関数である場合、アナライザーはそれがどのように機能するかをどのように理解しますか？トレーニング中にアナライザーがGoogle自体を使用し、関数の説明を見つけ、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それを</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">読んで</font><b><font style="vertical-align: inherit;">理解すること</font></b><font style="vertical-align: inherit;">を</font><b><font style="vertical-align: inherit;">想定できます</font></b><font style="vertical-align: inherit;">。さらに、ドキュメントから高レベルの結論を引き出す必要があります。説明で</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">_fread_nolock</font></font></i></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バッファサイズ、2番目と3番目の引数の関係についてはどこにも述べられていません。この比較は、プログラミングの一般原則とC ++言語のしくみの理解に基づいて、人工知能によって個別に推定する必要があります。これを真剣に考えれば、20年後にはそう考えることができると考えられており</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、機能の本体は</font><font style="vertical-align: inherit;">揃っているの</font><font style="vertical-align: inherit;">かもしれませんが、何の意味もないのかもしれません。</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memmoveの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ような関数を考え</font><font style="vertical-align: inherit;">ます。多くの場合、次のように実装されます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memmove</span> <span class="hljs-params">(<span class="hljs-keyword">void</span> *dest, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *src, <span class="hljs-keyword">size_t</span> len)</span> </span>{
 <span class="hljs-keyword">return</span> __builtin___memmove_chk(dest, src, len, __builtin_object_size(dest, <span class="hljs-number">0</span>));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">__builtin___memmove_chk</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">とは何</font><font style="vertical-align: inherit;">ですか？これはコンパイラ自体が実装する組み込み関数です。この関数にはソースコードがありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
または、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memmove</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は次のようになります</font><font style="vertical-align: inherit;">。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アセンブラーで出会っ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">最初のバージョン</font></a><font style="vertical-align: inherit;">。アナライザーにさまざまなアセンブラーの変形を理解するように教えることができますが、何かが正しくありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、時々関数本体は本当に有名です。さらに、ユーザーコード内の関数の本体も知られています。この場合、MLはこれらのすべての関数が何をするかを読んで理解することによって途方もない利点を得るように思われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、今回も悲観に満ちています。このタスクは複雑すぎます。それは人にとって複雑です。自分で作成しなかったコードを処理するのがいかに難しいか覚えておいてください。これが人間にとって難しい場合、なぜAIにとってこのタスクは簡単なのでしょうか？実際、AIは高レベルの概念を理解する上で大きな問題を抱えています。コードを理解することについて話している場合、実装の詳細から抽象化し、アルゴリズムを高レベルで検討する能力がなければ、それは不可能です。ここでも20年は議論を延期できるようです。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">他のニュアンス。</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
考慮すべき他のポイントがありますが、慎重に検討していません。そして、記事はすでに引きずられています。したがって、いくつかの微妙なニュアンスを簡単にリストし、それらを読者に振り返ってもらいます。</font></font><ul>
<li><b> </b>.   ,  ,      .           ,    -     . .  C++         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><i>auto_ptr</i></a>.          <i>unique_ptr</i>.</li>
<li><b> </b>.  ,   C  C++   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a>.  ,         .    ,     . ,  <i>long</i>  Windows 32/64    32 .    Linux       32/64      .    ,           .       -.  , ,  .       ,      (   ).     ,       . </li>
<li><b> </b>.     ML,   ,  ,    . ..     ,   — ,    ,   .     ,       .    ,     ,   — ,  .          .      ,    /  , ,   ,       .        .   : "<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   PVS-Studio:    </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「トレーニングに基づいてアナライザーで説明されている問題を解決する方法は明確ではありません。</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">調査結果</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的コード分析のタスクを含め、機械学習の可能性を否定しません。</font><font style="vertical-align: inherit;">タイプミス検索の問題、誤ったメッセージのフィルタリング、新しい（まだどこにも記述されていない）エラーパターンの検索などでMLを使用する可能性があります。</font><font style="vertical-align: inherit;">ただし、コード分析の問題でMLに特化した記事が飽和する楽観性は絶対に共有しません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、MLを基礎とする場合に取り組む必要があるいくつかの問題について説明しました。</font><font style="vertical-align: inherit;">説明されているニュアンスは、新しいアプローチの利点を大幅に無効にします。さらに、アナライザーの実装に対する古い古典的なアプローチは、より有利で、より経済的に実現可能です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味深いことに、ML手法の支持者の記事では、これらの落とし穴について触れていません。</font><font style="vertical-align: inherit;">ただし、これは当然のことです。</font><font style="vertical-align: inherit;">MLテーマは「誇大広告」になりすぎており、静的コード分析の問題におけるその適用性のバランスの取れた評価をその謝罪担当者から待つのは奇妙です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちの観点から見ると、機械学習は、制御フローや記号計算などの分析とともに、静的アナライザーで使用されているテクノロジーのニッチを占めます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
静的分析の方法論はMLの実装から利益を得るかもしれませんが、このテクノロジーの機能を誇張しないでください。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
記事は一般的に重要なので、</font><font style="vertical-align: inherit;">静的分析ツールの市場を失うことを恐れて</font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Luddites</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がML </font><font style="vertical-align: inherit;">とどのように</font><font style="vertical-align: inherit;">戦った</font><font style="vertical-align: inherit;">かを</font><font style="vertical-align: inherit;">恐れ</font><font style="vertical-align: inherit;">ていると思う人もいるかもしれません</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<p></p><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/659/1f4/7fa/6591f47faa384c2ac9472bc1f5eeacb9.png" alt="ラダイトユニコーン"></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いいえ、恐れていません。 PVS-Studioコードアナライザーの開発において、非効率的なアプローチにお金を費やす理由はありません。何らかの形で、MLを採用します。さらに、一部の診断にはすでに自己学習アルゴリズムの要素が含まれています。しかし、私たちは間違いなく非常に保守的であり、ループとif-ah :)に基づく従来のアプローチよりも明らかに効果が大きいものだけを採用します。結局のところ、私たちは効果的なツールを作成する必要があり、助成金を考え出す必要はありません:)。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、議論されているトピックに関してますます多くの質問が行われるという理由で書かれたものであり、私はすべてをその場に置く回答記事を用意したかったのです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご清聴ありがとうございました。また、記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PVS-Studio静的コードアナライザーを開発プロセスに導入する理由</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」を理解することをお</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">勧めします</font></a><font style="vertical-align: inherit;">。</font></font><br>
<br>
<p><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/898/3b6/5a7/8983b65a74adb29a2113eba12fbec3f1.png" align="left"></a></p><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事を英語を話す視聴者と共有したい場合は、翻訳へのリンクを使用してください：Andrey Karpov、Victoria Khanieva。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムのソースコードの静的解析における機械学習</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja484196/index.html">マイクからのJSサウンドまたは音声コメントの録音</a></li>
<li><a href="../ja484198/index.html">コインの裏側：テスラ株の成長で誰が勝って負けたのか</a></li>
<li><a href="../ja484200/index.html">それらを達成するための目標を設定する方法</a></li>
<li><a href="../ja484204/index.html">FTCODEファイルレスランサムウェアがアカウントを盗む</a></li>
<li><a href="../ja484206/index.html">Dartでのミックスインの使用</a></li>
<li><a href="../ja484212/index.html">カルマのための無料のもの-消費の原理を変えるベラルーシのスタートアップの物語</a></li>
<li><a href="../ja484214/index.html">TensorFlowのテンソル</a></li>
<li><a href="../ja484216/index.html">ロシアでの2番目のZabbix会議：登録と重要な日付</a></li>
<li><a href="../ja484218/index.html">自動化を最適化：自動テストを3〜4倍高速化し、古い開発を維持する方法</a></li>
<li><a href="../ja484220/index.html">配達を注文しましたか？Crossroadsが1日あたり6000注文を配送する方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>