<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏾‍🤝‍👨🏿 🙅🏾 ♍️ Blitz.Engine：资产系统 👈🏽 🏳️‍🌈 🏟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在我们了解Blitz.Engine引擎的资产系统如何工作之前，我们需要确定资产是什么，以及资产系统究竟意味着什么。根据维基百科，游戏资产是一种数字对象，主要由相同的数据组成，它是代表游戏内容一部分并具有某些属性的不可分割的实体。从程序模型的角度来看，资产可以显示为在某些数据集上创建的对象。资产可以存...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Blitz.Engine：资产系统</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498300/"><img src="https://habrastorage.org/webt/yk/rv/sv/ykrvsv2-nadxe5rvvs7gj8iw-9w.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在我们了解</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blitz.Engine</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">引擎的资产系统如何</font><b><font style="vertical-align: inherit;">工作之前</font></b><font style="vertical-align: inherit;">，我们需要确定资产是什么，以及资产系统究竟意味着什么。根据维基百科，游戏资产是一种数字对象，主要由相同的数据组成，它是代表游戏内容一部分并具有某些属性的不可分割的实体。从程序模型的角度来看，资产可以显示为在某些数据集上创建的对象。资产可以存储为单独的文件。反过来，资产系统是许多程序代码，负责加载和操作各种类型的资产。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，资产系统是游戏引擎的重要组成部分，可以成为游戏开发人员的忠实助手或将他们的生活变成地狱。</font><font style="vertical-align: inherit;">我认为，合乎逻辑的决定是将这个“地狱”集中在一个地方，并谨慎地保护其他团队开发人员免受其害。</font><font style="vertical-align: inherit;">我们将告诉您我们在本系列文章中所做的事情-走吧！</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有关该主题的计划文章：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需求说明和架构概述</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资产生命周期</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">详细的AssetManager类概述</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集成到ECS中</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GlobalAssetCache</font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求和原因</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
资产加载系统的要求源于艰辛和艰辛。</font><font style="vertical-align: inherit;">砧座是希望自己做一些封闭的事情，这样它就可以在不编写外部代码的情况下工作。</font><font style="vertical-align: inherit;">好吧，或者几乎不需要编写外部代码。</font><font style="vertical-align: inherit;">锤子变成了现实。</font><font style="vertical-align: inherit;">这就是我们最终得到的结果：</font></font><br>
<br>
<ol>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自动内存管理</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这意味着无需调用资产的释放功能。</font><font style="vertical-align: inherit;">即，一旦破坏了使用该资产的所有外部对象，该资产便被破坏。</font><font style="vertical-align: inherit;">这里的动机很简单-编写更少的代码。</font><font style="vertical-align: inherit;">更少的代码意味着更少的错误。</font></font></li>
<li><i> <b></b>  </i>,           (    AssetManager’a).   ,      .   —      .       ,     «»    .<br>
    ,      ,       ().       —    ,  . ,     ,              .         ,      ,    .        ,   ,    .</li>
<li><i>   </i>      .  :        .         ,         .</li>
<li><i> (shared)  </i>. ,         .  ,    .           «» ,               .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">优先考虑资产装载</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">只有3个优先级：高，中，低。</font><font style="vertical-align: inherit;">在相同的优先级内，按请求的顺序加载资产。</font><font style="vertical-align: inherit;">想象一个情况：玩家单击“战斗”，然后开始加载关卡。</font><font style="vertical-align: inherit;">与此相关的是，准备加载屏幕的精灵的任务将落入下载队列中。</font><font style="vertical-align: inherit;">但是由于某些关卡资产在Sprite之前进入队列，因此播放器在黑屏上看了相当长时间。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此外，我们为自己制定了一条简单的规则：“必须在AssetManager线程上完成的所有工作都必须在AssetManager线程上完成。” </font><font style="vertical-align: inherit;">例如，根据高度图准备法线的风景和纹理的分区，链接GPU程序等。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一些实施细节</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在开始了解资产加载系统的工作方式之前，我们需要熟悉Blitz.Engine引擎中广泛使用的两个类：</font></font><br>
<br>
<ul>
<li><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：有关某种类型的运行时信息。</font><font style="vertical-align: inherit;">此类型与</font></font><code>Type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C＃语言中</font><font style="vertical-align: inherit;">的类型相似，不同之</font><font style="vertical-align: inherit;">处在于它不提供对类型的字段和方法的访问。</font><font style="vertical-align: inherit;">包含：类型名称，许多符号，例如</font></font><code>is_floating, is_pointer, is_const</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，等等。</font><font style="vertical-align: inherit;">该方法</font></font><code>Type::instance&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在一个应用程序启动时返回一个常量</font></font><code>const Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，使您可以检查表单</font></font><code>if (type == Type::instance&lt;T&gt;())</code></li>
<li><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：允许您打包任何可移动或可复制类型的值。</font><font style="vertical-align: inherit;">打包哪种类型的知识</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储为const </font></font><code>Type*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道如何根据哈希的内容计算哈希，还知道如何比较内容是否相等。</font><font style="vertical-align: inherit;">在此过程中，它允许您将当前类型转换为另一种类型。</font><font style="vertical-align: inherit;">这是对标准库或boost库中任何类的重新思考。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有资产清单加载系统基于以下三个类别：</font></font><code>AssetManager, AssetBase, IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">但是，在进行这些类的描述之前，必须说外部代码使用</font></font><code>Asset&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样声明</font><font style="vertical-align: inherit;">的别名</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="cpp hljs">Asset = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其中T是AssetBase或特定类型的资产。随处使用shared_ptr，我们可以满足要求1（自动内存管理）的要求。</font></font><br>
<br>
<code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是没有继承人的有限类。此类定义资产的生命周期，并发出有关资产状态变化的消息。它还</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在资产和资产绑定到磁盘上的文件之间存储依赖关系树，侦听</font></font><code>FileWatcher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并实现资产重新加载。最重要的是，它</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">启动了一个单独的线程，实现了用于准备资产的任务队列，并封装了与其他应用程序线程的所有同步（可以从任何应用程序线程（包括下载流）执行资产请求）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用抽象资产</font></font><code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将创建和加载特定类型资产的任务委派给继承人</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在后续文章中，我将详细介绍这种情况。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为要求4（资产共享）的一部分，最热门的问题之一是“用什么作为资产标识符？” </font><font style="vertical-align: inherit;">最简单，看似显而易见的解决方案是使用要下载文件的路径。</font><font style="vertical-align: inherit;">但是，此决定施加了许多严重限制：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要创建资产，后者必须以磁盘上的文件形式表示，这消除了基于其他资产创建运行时资产的能力。</font></font></li>
<li>    . ,    GPUProgram     (defines).      ,       .</li>
<li>         ,   .</li>
<li>        .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们从一开始就没有将第3和第4款作为论据，因为甚至没有人认为这可能会派上用场。但是，这些功能随后极大地促进了编辑器的开发。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们决定使用资产密钥作为标识符，其级别</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由type表示</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继承人</font><font style="vertical-align: inherit;">会解释</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。自己</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只知道密钥类型和继承人之间的关系</font></font><code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。请求资产的代码通常知道其所需的资产类型，并使用特定类型的键进行操作。一切都是这样的：</font></font><br>
<br>
<pre><code class="cpp hljs">
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Texture</span>:</span> <span class="hljs-keyword">public</span> AssetBase<font></font>
{<font></font>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PathKey</span>
    {</span><font></font>
        FilePath path;<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> PathKey&amp; other);<font></font>
    };<font></font>
<font></font>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MemoryKey</span>
    {</span>
        u32 width = <span class="hljs-number">1</span>;<font></font>
        u32 height = <span class="hljs-number">1</span>;<font></font>
        u32 level_count = <span class="hljs-number">1</span>;<font></font>
        TextureFormat format = RBGA8;<font></font>
        TextureType type = TEX_2D;<font></font>
        <span class="hljs-function">Vector&lt;Vector&lt;u8*&gt;&gt; data</span>; <span class="hljs-comment">// Face&lt;MipLevels&lt;Image&gt;&gt;</span><font></font>
<font></font>
        <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">hash</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> MemoryKey&amp; other);<font></font>
    };<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextureSerializer</span>:</span> <span class="hljs-keyword">public</span> IAssetSerializer<font></font>
{<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssetManager</span> <span class="hljs-title">final</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
    Asset&lt;T&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;
    <span class="hljs-function">Asset&lt;AssetBase&gt; <span class="hljs-title">get_asset</span><span class="hljs-params">(<span class="hljs-keyword">const</span> Any&amp; key, ...)</span></span>;<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
   ...<font></font>
   <span class="hljs-function">Texture::PathKey <span class="hljs-title">key</span><span class="hljs-params">(<span class="hljs-string">"/path_to_asset"</span>)</span></span>;<font></font>
   Asset&lt;Texture&gt; asset = asset_manager-&gt;get_asset&lt;Texture&gt;(key);<font></font>
   ...<font></font>
<font></font>
   Texture::MemoryKey mem_key;<font></font>
   mem_key.width = <span class="hljs-number">128</span>;<font></font>
   mem_key.format = <span class="hljs-number">128</span>;<font></font>
   mem_key.level_count = <span class="hljs-number">1</span>;<font></font>
   mem_key.format = A8;<font></font>
   mem_key.type = TEX_2D;<font></font>
   Vector&lt;u8*&gt;&amp; mip_chain = mem_key.data.emplace_back();<font></font>
   mip_chain.push_back(generage_sdf_font());<font></font>
   <font></font>
   Asset&lt;Texture&gt; sdf_font_texture = asset_manager-&gt;get_asset&lt;Texture&gt;(mem_key);<font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"></font><code>hash</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font><font style="vertical-align: inherit;">
的方法</font><font style="vertical-align: inherit;">和比较运算符</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是实现相应的类操作所必需的</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但我们将不对其进行详细介绍。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，上面的代码中发生了什么：在调用时，</font></font><code>get_asset(key)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">键将被复制到该类型的临时对象中，该对象</font></font><code>Any</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随后将被传递给method </font></font><code>get_asset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。接下来，</font></font><code>AssetManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从参数中获取键的类型。在我们的情况下，它将是：</font></font><br>
<br>
<pre><code class="cpp hljs">Type::instance&lt;MyAsset::PathKey&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过这种类型，他将找到序列化器对象，并将所有后续操作（创建和加载）委托给序列化器。</font></font><br>
<br>
<code>AssetBase</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是引擎中所有资产类型的基类。</font><font style="vertical-align: inherit;">此类存储资产密钥，资产的当前状态（已加载，已排队等）以及资产加载失败时的错误文本。</font><font style="vertical-align: inherit;">实际上，内部结构要复杂一些，但是我们将与资产生命周期一起考虑。</font></font><br>
<br>
<code>IAssetSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">顾名思义，它是准备资产的实体的基类。</font><font style="vertical-align: inherit;">实际上，此类的继承人不仅在加载资产：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">特定类型资产对象的分配和解除分配。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">加载特定类型的资产。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据构建资产的文件路径列表进行编译。</font><font style="vertical-align: inherit;">文件更改时，资产重新加载机制需要此列表。</font><font style="vertical-align: inherit;">出现了一个问题：为什么要列出路径而不是一个路径？</font><font style="vertical-align: inherit;">诸如纹理之类的简单资源实际上可以在单个文件的基础上构建。</font><font style="vertical-align: inherit;">但是，如果我们查看着色器，则不仅会看到着色器文本发生更改，而且通过include指令更改了连接到着色器的文件时，也会重新启动。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将资产保存到磁盘。</font><font style="vertical-align: inherit;">在编辑资产和为游戏准备资产时，都会积极使用它。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">报告它支持的密钥类型。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文的框架中，我想强调的最后一个问题是：为什么在一个序列化器/资产上可能需要几种类型的密钥？</font><font style="vertical-align: inherit;">让我们依次解决。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个串行器-几种类型的密钥</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们以资产</font></font><code>GPUProgram</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（即着色器）</font><font style="vertical-align: inherit;">为例</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了在我们的引擎中加载着色器，需要以下信息：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器文件的路径。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">预处理程序定义列表。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">着色器的组装和编译阶段（顶点，片段，计算）。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">入口点的名称。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一起收集这些信息，我们获得了着色器键，该键在游戏中使用。但是，在开发游戏或引擎时，通常需要在屏幕上显示某些调试信息，有时需要使用特定的着色器。在这种情况下，直接在代码中编写着色器的文本会很方便。为此，我们可以获取第二种键，它代替文件的路径，而预处理程序定义的列表将包含着色器的文本。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑另一个示例：纹理。创建纹理的最简单方法是从磁盘加载纹理。为此，我们需要文件（</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的路径</font><font style="vertical-align: inherit;">。但是我们还可以通过算法生成纹理的内容，并从字节数组（</font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">创建纹理</font><font style="vertical-align: inherit;">。第三种类型的键可以是用于创建</font></font><code>RenderTarget</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">纹理（</font></font><code>RTKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">的键</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
根据密钥的类型，可以使用各种字形栅格化引擎：stb（StbFontKey），FreeType（FTFontKet）或自签名的距离场字体生成器（SDFFontKey）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关键帧动画可以加载（</font></font><code>PathKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或由代码（</font></font><code>MemoryKey</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">生成</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一种资产-几种类型的密钥</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
想象一下，我们拥有</font></font><code>ParticleEffect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">描述粒子生成规则</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">资产。此外，我们为该资产提供了一个方便的编辑器。同时，关卡编辑器和粒子编辑器是一个多窗口应用程序。这很方便，因为您可以在编辑效果本身的同时打开一个关卡，在其中放置粒子源，并在关卡环境中查看效果。如果我们只有一种类型的键，那么在效果编辑世界和关卡世界中使用的效果对象是相同的。在效果编辑器中所做的所有更改都将立即在关卡中可见。乍一看，这似乎是一个不错的主意，但让我们看一下以下情况：</font></font><br>
<br>
<ol>
<li>    ,   ,    ,    .   ,            . </li>
<li>-       ,    .        ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，有一种情况，我们可能会使用两种不同类型的密钥从磁盘上的一个文件中创建两种不同类型的资产。</font><font style="vertical-align: inherit;">使用“游戏”类型的键，我们创建了针对游戏中的快速工作而优化的数据结构。</font><font style="vertical-align: inherit;">使用“编辑”类型的键，我们创建了一个便于编辑的数据结构。</font><font style="vertical-align: inherit;">大约以这种方式，我们的编辑器实现</font></font><code>BlendTree</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了骨骼动画的</font><font style="vertical-align: inherit;">编辑</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">根据一种类型的键，资产系统使用内部的诚实树和一堆有关更改拓扑的信号来构建我们的资产，这在编辑时非常方便，但在游戏中却很慢。</font><font style="vertical-align: inherit;">根据不同类型的密钥，序列化程序将创建另一种资产：该资产没有更改树的方法，并且树本身变成了一个节点数组，其中到该节点的链接是该数组中的索引。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结语</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
总结一下，我想将您的注意力集中在影响引擎进一步发展的解决方案上：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用自定义结构作为资产键，而不是文件路径。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅在异步模式下加载资产。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">用于管理资产共享（一种资产-几种类型的密钥）的灵活方案。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">能够使用不同的数据源接收相同类型的资产（在一个串行器中支持几种类型的密钥）。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一个系列中，您将了解这些决定如何精确地影响内部代码和外部代码的实施。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作者：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">混音</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN498290/index.html">程序水文学：河流和湖泊的动态模拟</a></li>
<li><a href="../zh-CN498292/index.html">在PostgreSQL中节省大量资金</a></li>
<li><a href="../zh-CN498294/index.html">物体检测 认识和统治。第1部分</a></li>
<li><a href="../zh-CN498296/index.html">在系统级别进行设计。第1部分。从概念到系统</a></li>
<li><a href="../zh-CN498298/index.html">公司利用漏洞赏金来购买黑客的沉默</a></li>
<li><a href="../zh-CN498302/index.html">国际劳工组织高级许可证。为什么现在需要它？</a></li>
<li><a href="../zh-CN498304/index.html">使用Ansible自动化VMware vSphere API管理任务</a></li>
<li><a href="../zh-CN498308/index.html">寻找全局极值的Python遗传算法</a></li>
<li><a href="../zh-CN498310/index.html">机器学习的三个陷阱以及如何避免它们</a></li>
<li><a href="../zh-CN498312/index.html">使用面向模型的设计开发飞机电网</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>