<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🚒 🎇 🍗 排序数据科学备忘单 🔑 Ⓜ️ ⬜️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="数据排序是数据科学家和工程师最关心的问题。 Python用户可以从带有内置的优化排序选项的许多库中选择最方便的方法。有些甚至可以与GPU并行工作。令人惊讶的是，某些排序方法没有使用这些类型的算法，而另一些排序方法却无法按预期工作。
 
 选择一个库和排序算法的类型并不总是那么容易，并且创新也在快速变...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>排序数据科学备忘单</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/skillfactory/blog/506888/"><img src="https://habrastorage.org/getpro/habr/post_images/4be/b00/dfb/4beb00dfb3cdb4f8665747189fa8910a.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据排序是数据科学家和工程师最关心的问题。 Python用户可以从带有内置的优化排序选项的许多库中选择最方便的方法。有些甚至可以与GPU并行工作。令人惊讶的是，某些排序方法没有使用这些类型的算法，而另一些排序方法却无法按预期工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择一个库和排序算法的类型并不总是那么容易，并且创新也在快速变化。目前，Pandas文档与代码不匹配（尽管我个人对分类选项的PR更新是最新的）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，我将向您解释什么是什么，我将为您提供一些提示，以帮助您找出方法，并分享速度测试的结果。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD 2019年7月17日</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：现在，评估速度测试的结果包括PyTorch和TensorFlow GPU实施。</font><font style="vertical-align: inherit;">TensorFlow还包括何时</font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和何时的</font><font style="vertical-align: inherit;">CPU结果</font></font><code>tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有趣的观察：PyTorch GPU实际上运行良好，而TensorFlow GPU比TensorFlow CPU慢。</font></font><br>
 <br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语境</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
有许多基本的排序算法。</font><font style="vertical-align: inherit;">其中一些具有高性能，占用的空间更少，另一些则可以处理大量数据。</font><font style="vertical-align: inherit;">对于某些算法，数据元素的相对位置很重要。</font><font style="vertical-align: inherit;">在本文开头的图中，您可以在时间和数量上看到最常见算法的情况。</font></font><br>
 <a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，您无需成为基本部署专家即可解决大多数排序问题。</font><font style="vertical-align: inherit;">实际上，过早的优化有时被认为是邪恶的根源。</font><font style="vertical-align: inherit;">但是，如果您需要多次对大量数据进行排序，那么事先了解最适合使用哪个库和哪些关键字可能非常有用。</font><font style="vertical-align: inherit;">我给你</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我的备忘单</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
 <br>
<img src="https://habrastorage.org/getpro/habr/post_images/67a/568/caa/67a568caa0670b09aaccb1efb4653bb1.png" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多年来，大多数库中的排序算法已经发生了变化。</font><font style="vertical-align: inherit;">为了进行本文的分析，我采用了以下软件版本。</font></font><br>
 <br>
<pre><code class="plaintext hljs">python 3.6.8<font></font>
numpy 1.16.4<font></font>
pandas 0.24.2<font></font>
tensorflow==2.0.0-beta1  #tensorflow-gpu==2.0.0-beta1 slows sorting<font></font>
pytorch 1.1</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
让我们从基础开始。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Python（香草）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Python有两种内置的排序方法。</font></font><br>
<br>
<ul>
<li><code>my_list.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对列表进行排序，将原始列表替换为排序后的列表。</font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回无。</font></font></li>
<li>sorted(my_list)      . <code> sorted()</code>   . <code>sort()</code>   .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从理论上讲，它</font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该更快，因为排序是在现场进行的。令人惊讶的是，它们之间并没有太大区别。此外，</font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值得谨慎使用，因为它无需保存即可更改原始数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将在本文中介绍的Vanilla Python的所有实现都具有从最小到最大的升序默认排序顺序。但是，大多数其他排序方法使用自顶向下方法。对于您和您的头部来说，不是很方便，但是此选项因每个库而异。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于我们的情况，要在Vanilla Python中将排序顺序更改为降序，您需要指定</font></font><code>reverse=True</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>key</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以被声明为您唯一条件的关键字。例如，</font></font><code>sort(key=len)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按列表项的长度对其排序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
香草Python中使用的唯一排序算法是Timsort。使用此算法，可以根据数据的主要标准对数据进行排序。例如，如果要对短列表进行排序，则使用插入排序。有关Timsort的更多信息，请参见Brandon Skerritt的精彩文章。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Timsort和相应的Vanilla Python是不变的。也就是说，如果初始值相同，则处理后的值将相似并且以相同的顺序排列。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了提醒sort（）和sorted（）之间的区别，我只注意到sort（）比更为复杂</font></font><code>sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><code> sorted()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从客观上讲，这将花费更多时间，因为同时会保存初始数据和副本。</font><font style="vertical-align: inherit;">即使测试结果模棱两可，助记符也是我们的全部。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我建议考虑使用Numpy。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脾气暴躁的</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy是用于科学计算的基本Python库。</font><font style="vertical-align: inherit;">与Vanilla Python一样，它有两个实现选项：复制或更改源数据数组：</font></font><br>
<br>
<ul>
<li><code>my_array.sort ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 更改数组并返回已排序的数组；</font></font></li>
<li><code>np.sort (my_array)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 返回已排序数组的副本，而不更改原始数据。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可选使用的参数：</font></font><br>
<br>
<ul>
<li><code>axis</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int，可选</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -进行排序的轴。</font><font style="vertical-align: inherit;">默认情况下为-1-按最后一个轴排序。</font></font></li>
<li><code>kind</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{'quicksort'，'mergesort'，'heapsort'，'stable'}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -排序算法。</font><font style="vertical-align: inherit;">默认情况下，使用“快速排序”。</font><font style="vertical-align: inherit;">接下来，我将更详细地讨论这一点。</font></font></li>
<li><code>order</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">str或str的列表</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -当a是具有定义边界的数组时，此参数指示比较这些边界的顺序。</font><font style="vertical-align: inherit;">可以将一个字段指定为字符串；可以不指定其他字段。</font><font style="vertical-align: inherit;">无论如何，它们都将以dtype用于中断。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
坦率地说，目前，排序算法实际上与它们的名称匹配。</font></font><code> kind=quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从字面上看，</font><font style="vertical-align: inherit;">该命令</font><font style="vertical-align: inherit;">意味着排序从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自省排序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">更多细节</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<blockquote> ,    ,     heapsort.         O(n* log (n)).<br>
<br>
stable      .  ,    ,       timsort  radix,     .   API       ,        .<br>
<br>
Timsort          .    timsort   mergesort.        ,       -   ,     … «mergesort»  «stable»      .<br>
 —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> Numpy</a> — (   )</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最重要的结论之一：Numpy使您可以比Vanilla Python更自由地管理排序选项。</font><font style="vertical-align: inherit;">第二个结论同样重要：关键字kind不一定与所使用的排序类型相对应。</font><font style="vertical-align: inherit;">最后，最后的结果，如果我可以这样说，是</font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>stable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一定的排序，</font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><code>heapsort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-没有。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpy是我们列表中唯一没有用于更改排序顺序的关键字的方法。</font><font style="vertical-align: inherit;">幸运的是，它可以是翻转数组的一种：</font></font><code>my_arr[::-1]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所有Numpy功能都可在更加用户友好的Pandas中使用。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大熊猫</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您可以在Pandas DataFrame c中排序</font></font><code>df.sort_values (by=my_column)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了方便起见，有几个关键字。</font></font><br>
<br>
<ul>
<li><code>by</code>: <i>str  list of str</i> —       .   = 0   ,      / .    1  ,       /  .</li>
<li><code>axis</code>: <i>{0  , 1  }</i>,   0 —   .</li>
<li><code>ascending</code>: <i>bool   bool</i>,    True —      .      .    ,     by.</li>
<li><code>inplace</code>: <i>bool,   False</i> —   True,    .</li>
<li><code>kind</code>: <i>{quicksort, mergesort, heapsort  stable}</i>,   quicksort —   .       <code>ndarray.np.sort</code>.  DataFrames           .</li>
<li><code>na_position</code>: <i>{«first», «last»}</i>,   «last» — first  NaNs  , last  NaNs  .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pandas系列使用相同的语法实现。在Series中，不需要关键字</font></font><code>by</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为没有多列数据。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于Pandas是“内幕”-Numpy，因此您可以轻松获得相同的优化排序选项。但是，使用Pandas比较麻烦。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Numpy中按一列排序时，默认情况下使用</font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。您还记得，</font></font><code>quicksort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果分拣过程很慢</font><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">它现在实际上是介绍性的，进入金字塔式的。熊猫声称跨多个列排序使用</font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy。</font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy实际上使用Timsort或Radix排序算法。这些是稳定的排序算法，在跨多个列进行排序时必不可少。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
熊猫要记住几个要点：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">函数名称：</font></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须声明</font></font><code>by=column_name</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或列出列名。</font></font></li>
<li><code>ascending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 是反向关键字。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了稳定的分类使用</font></font><code>mergesort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在分析处理数据时，我经常会在Pandas DataFrame中遇到对值求和和排序的问题</font></font><code>Series.value_counts()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这是一个代码片段，用于总结和排序每列的最常用值。</font></font><br>
 <br>
<pre><code class="python hljs"><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> df.columns:<font></font>
    print(<span class="hljs-string">f"---- <span class="hljs-subst">{c}</span> ---"</span>)<font></font>
    print(df[c].value_counts().head())</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pandas为处理大数据而提供的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Dask</font></a><font style="vertical-align: inherit;">还没有并行的排序实现，但是这个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">问题正在讨论中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
熊猫分类是对少量数据进行预分类的不错选择。</font><font style="vertical-align: inherit;">如果您有大量数据并希望与GPU并行工作，则应注意TensorFlow或PyTorch。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">张量流</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是最流行的深度学习媒体。</font><font style="vertical-align: inherit;">您可以在链接学习在我的文章了解深层学习</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下信息与TensorFlow 2.0 GPU相关。</font></font><br>
<br>
<code>tf.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回张量的排序副本。</font><font style="vertical-align: inherit;">可选参数：</font></font><br>
<br>
<ul>
<li><code>axis</code>: <i>{int}</i> ,    .    -1    .</li>
<li><code>direction</code>:<i> {ascending  descending}</i> —   .</li>
<li><code>name</code>: <i>{str}</i> —   .</li>
</ul><br>
<code>tf.sort</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本质上使用</font></font><code> top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。对于</font></font><code>top_k()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了CUDA GPU </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">的CUB库</font></a><font style="vertical-align: inherit;">，从而简化了并行实现。该文档说：“ CUB为​​CUDA编程模型的每个级别提供了现代且可重复的软件组件。” TensorFlow通过CUB使用基本的GPU排序（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">讨论</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于TensorFlow GPU的信息可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">找到</font><font style="vertical-align: inherit;">。要使用TensorFlow 2.0激活GPU，您需要注册</font></font><code>!pip3 install tensorflow-gpu==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。从下面可以看出，</font></font><code>tensorflow==2.0.0-beta1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果仅对数据进行排序（不太可能），则</font><font style="vertical-align: inherit;">可以遵循该路径</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要检查CPU和GPU上的代码，请使用以下行：</font></font><br>
<br>
<pre><code class="plaintext hljs">tf.debugging.set_log_device_placement(True)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为了表明您要使用GPU，您需要使用以下代码块：</font></font><br>
<br>
<pre><code class="plaintext hljs">with tf.device('/GPU:0'):<font></font>
 %time tf.sort(my_tf_tensor)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要使用CPU： </font></font><code>with tf.device('/CPU:0')</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>tf.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在TensorFlow中工作时，这是一种直观的方法。</font><font style="vertical-align: inherit;">只要记住您</font></font><code>direction=descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要更改排序顺序的内容即可。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">火炬</font></font></h3><br>
<code>torch.sort(my_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回张量的排序副本。</font><font style="vertical-align: inherit;">可选参数：</font></font><br>
<br>
<ul>
<li><code>dim</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{int}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -排序量。</font></font></li>
<li><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{bool}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -控制排序顺序（升序或降序）。</font></font></li>
<li><code>out</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{tuple}</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -输出跟踪（Tensor，LongTensor），可用作输出缓冲区。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果要使用GPU进行排序，请附加</font></font><code>.cuda ()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到张量的末端。</font></font><br>
<br>
<pre><code class="plaintext hljs">gpu_tensor=my_pytorch_tensor.cuda()<font></font>
%time torch.sort(gpu_tensor)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
研究表明，如果PyTorch </font><font style="vertical-align: inherit;">对大于100,000列的100万行的数据集进行</font><font style="vertical-align: inherit;">排序，则通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用分段并行排序</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，当我尝试通过Google Colab中的Numpy创建每10万个大小的110万个任意数据时，我没有足够的内存。</font><font style="vertical-align: inherit;">之后，我尝试使用416 MB RAM的GCP，然后再次用尽内存。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分段排序和按位置排序是适用于异构随机数据的高性能合并排序选项。</font><font style="vertical-align: inherit;">分段排序使您可以并行地对可变长度的多个数组进行排序。</font><font style="vertical-align: inherit;">- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://moderngpu.github.io/segsort.html</font></font></a></blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thrust</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个并行算法库，可在GPU性能和多核CPU之间提供兼容性。它提供了一个排序框架，可以自动选择最有效的实现方法。 TensorFlow使用的CUB库减轻了负载。无论您使用哪种方法，PyTorch和TensorFlow都使用类似的算法对GPU进行排序。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为TensorFlow，PyTorch中的排序方法非常容易记住：</font></font><code>torch.sort()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。唯一要记住的是排序值的方向：TensorFlow使用</font></font><code>direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，而PyTorch使用</font></font><code>descending</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。并且，</font></font><code>.cuda()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当处理大量数据时</font><font style="vertical-align: inherit;">，请不要忘记使用</font><font style="vertical-align: inherit;">它来最大化速度。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尽管GPU排序对于非常大的数据集可能是一个不错的选择，但直接在SQL中对数据进行排序也很有意义。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的SQL</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL中的排序通常非常快，尤其是如果排序直接在内存中进行时。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SQL是不强制您使用特定算法的规范。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postgres根据情况使用</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">磁盘合并排序，金字塔式或快速排序。如果您有足够的内存，则可以在其中进行排序，并且速度更快。您可以使用来增加可用存储空间进行排序</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> work_mem</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
其他SQL选项使用不同的排序算法。例如，Google BigQuery使用内部排序和一些技巧，例如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stack Overflow答案中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供的技巧</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在SQL中排序是通过命令完成的</font></font><code>ORDER BY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">这种语法不同于Python，在Python中，他们更喜欢使用某种形式的单词sort。</font><font style="vertical-align: inherit;">我个人记得SQL语法中使用ORDER BY，因为这很不常见。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
要按降序对数据进行排序，请使用DESC关键字。</font><font style="vertical-align: inherit;">因此，从最后到第一个按字母顺序返回数据的请求将如下所示：</font></font><br>
<br>
<pre><code class="sql hljs"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">FROM</span> Customers
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-keyword">Names</span> <span class="hljs-keyword">DESC</span>;
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">比较方式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于上述每个Python库，我通过在单个列，数组或列表中排序1,000,000个数据点来进行分析。</font><font style="vertical-align: inherit;">我使用了</font><font style="vertical-align: inherit;">带有K80 GPU和2.30 GHz Intel Xeon CPU </font><font style="vertical-align: inherit;">的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Google Colab Jupyter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">笔记本电脑。</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/64c/2ea/636/64c2ea636ec6e3148fda501eb431729e.gif" alt="图片"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">观察结果</font></font></h3><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">带有GPU的PyTorch尽可能快。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于Numpy和Pandas，就地排序通常比复制数据快。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，Pandas quicksort非常快。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">熊猫的大多数功能都比Numpy的功能慢。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorFlow处理器非常快。</font><font style="vertical-align: inherit;">即使使用CPU，安装GPU也会降低TensorFlow的速度。</font><font style="vertical-align: inherit;">GPU排序非常慢。</font><font style="vertical-align: inherit;">此选项不是很有效。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Vanilla Python中，就地排序速度出乎意料地慢-比支持PyTorch GPU的速度慢近100倍。</font><font style="vertical-align: inherit;">我多次（使用不同的数据）构建了该实验，以仔细检查这是否是异常现象。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同样，这只是一个小测试。</font><font style="vertical-align: inherit;">这绝对不是最终结果。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">总结一下</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，您不需要自己开发排序选项。现成的选项非常令人满意，并且经常使用不止一种分类方法。相反，他们首先评估数据，然后使用经过验证的排序算法。如果排序变慢，某些版本甚至会修改算法。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在本文中，您了解了如何在Python和SQL中对每个数据进行排序。希望以后对您有所帮助。如果有机会，请在您喜欢的社交网络上分享文章，以帮助其他人找到它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您只需要记住选择和调用哪个选项即可。使用我的备忘单可以节省时间。我的一般建议如下：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"></font><code>sort_values()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下</font><font style="vertical-align: inherit;">使用熊猫</font><font style="vertical-align: inherit;">来浏览相对较小的数据集。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对于大型数据集，或者当速度足够高时，请尝试使用内置的Numpy排序，PyTorch或TensorFlow或SQL GPU的并行实现。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于GPU排序，我还没有写太多。</font><font style="vertical-align: inherit;">这个领域已经成熟，需要新的研究和学习指南。</font><font style="vertical-align: inherit;">这是一篇2017年的研究文章，旨在让您对最新</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有所了解</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">有关GPU排序算法的更多信息，请参见</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/rd/kl/lr/rdkllrbtrth_kdpceb-vxzrxl1o.jpeg" alt="图片"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过参加有偿的SkillFactory在线课程，了解如何从头开始获得抢手职业或技能和薪资水平提高的详细信息：</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">机器学习课程（12周）</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数据科学家专业课程（24个月） </font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">  « Data Analyst» (18 )</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> «Python  -» (9 )</a></li>
</ul> <br>
<br clear="left">
<h3> </h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">450     </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">   Data Science  Harvard University</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">65    Machine Learning    </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">30    -  </a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">     Data Science : Cambridge Analytica</a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN506870/index.html">如何禁用有关长时间收听音频的危险的警告（Android）</a></li>
<li><a href="../zh-CN506872/index.html">预定Spring Boot 2：专业人士最佳实践</a></li>
<li><a href="../zh-CN506874/index.html">从程序员的生活：商人</a></li>
<li><a href="../zh-CN506880/index.html">Joel Spolsky：堆栈溢出时代是如何开始的</a></li>
<li><a href="../zh-CN506886/index.html">一点点生活</a></li>
<li><a href="../zh-CN506890/index.html">ionCube中的复活节彩蛋-开发人员试图在地毯下扫垃圾吗？</a></li>
<li><a href="../zh-CN506896/index.html">量子力学的最现实的解释</a></li>
<li><a href="../zh-CN506902/index.html">智能城市中的智能家居</a></li>
<li><a href="../zh-CN506906/index.html">黑洞悖论揭示了能量与秩序之间的根本联系</a></li>
<li><a href="../zh-CN506908/index.html">顶尖科学。可能媒体十：绝望的水族馆鱼，精神障碍的声音和许多次COVID</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>