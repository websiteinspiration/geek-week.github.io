<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀🏿 🗽 🕑 QSerializer: solusi untuk serialisasi JSON / XML sederhana 👈🏻 👋🏾 🌊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! 
 
 Saya pikir entah bagaimana hasilnya tidak adil - di Jawa, C #, Go, Python, dll. Ada perpustakaan untuk serialisasi data objek yang nya...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>QSerializer: solusi untuk serialisasi JSON / XML sederhana</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496836/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Halo, Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya pikir entah bagaimana hasilnya tidak adil - di Jawa, C #, Go, Python, dll. </font><font style="vertical-align: inherit;">Ada perpustakaan untuk serialisasi data objek yang nyaman ke dalam JSON dan XML yang sekarang modis, tetapi di C ++ mereka lupa, atau tidak mau, atau tidak benar-benar membutuhkannya, atau semuanya rumit, atau mungkin semuanya bersamaan. </font><font style="vertical-align: inherit;">Jadi saya memutuskan untuk memperbaiki hal ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semua detail, seperti biasa, di bawah potongan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/cp/vw/j9cpvwvjh9gfvhqxigysyx7m78c.png" alt="gambar"><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Latar Belakang</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekali lagi, saya memutuskan untuk mengambil proyek hewan peliharaan berikutnya, yang intinya adalah pertukaran klien-server, sementara server favorit banyak orang adalah RaspberryPi. Antara lain, saya tertarik pada masalah menciptakan "save points" - jadi saya bisa sesederhana mungkin, sebagai bagian dari prototipe, menyelamatkan keadaan objek sebelum keluar dan memulihkan pada awal berikutnya. Karena permusuhan saya yang tidak masuk akal terhadap Python dan sikap saya yang sangat hangat terhadap Qt, saya memilih Qt &amp; C ++. Menulis kelas dan fungsi spageti untuk mem-parsing JSON masih menyenangkan, saya membutuhkan solusi universal dan sekaligus mudah untuk masalah saya. "Kita harus mencari tahu," kataku pada diri sendiri. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, sedikit tentang ketentuan:</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Serialisasi adalah proses menerjemahkan struktur data ke dalam urutan bit. </font><font style="vertical-align: inherit;">Kebalikan dari operasi serialisasi adalah operasi deserialisasi (penataan) - pemulihan keadaan awal struktur data dari urutan bit.</font></font><br>
</blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Go memiliki paket </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">enkode / json</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "asli" yang sangat berguna </font><font style="vertical-align: inherit;">yang memungkinkan untuk serialisasi objek secara lengkap menggunakan metode Marshal dan membalikkan struktur menggunakan Unmarshal (karena perpustakaan ini, saya pertama kali memiliki gagasan yang salah tentang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengurutan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">Desine sperare qui hic intras</font></a><font style="vertical-align: inherit;"> ) . </font><font style="vertical-align: inherit;">Mengikuti konsep paket ini, saya menemukan perpustakaan lain untuk Java - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GSON</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang ternyata merupakan produk yang sangat menyenangkan, sangat menyenangkan untuk menggunakannya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya merenungkan apa yang saya sukai dari perpustakaan ini dan sampai pada kesimpulan bahwa itu adalah kemudahan penggunaannya. Fungsionalitas yang fleksibel dan semuanya dalam satu panggilan, untuk serialisasi di JSON cukup untuk memanggil metode toJson dan meneruskan objek serial ke dalamnya. Namun, C + + itu sendiri, secara default, tidak memiliki kemampuan metaobject yang tepat untuk memberikan informasi yang cukup tentang bidang kelas, seperti yang dilakukan, misalnya, di Jawa (ClassName.class). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya hanya menyukai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QJson untuk</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> platform Qt </font><font style="vertical-align: inherit;">, tapi tetap saja itu tidak sesuai dengan pemahaman saya tentang kemudahan penggunaan yang dihasilkan oleh perpustakaan yang disebutkan di atas. Maka proyek muncul, yang akan dibahas di sini. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penafian kecil:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mekanisme seperti itu tidak akan menyelesaikan masalah interpretasi data untuk Anda. </font><font style="vertical-align: inherit;">Yang bisa Anda dapatkan dari mereka adalah konversi data menjadi bentuk yang lebih nyaman bagi Anda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur Proyek QSerializer</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proyek dan contoh-contohnya dapat dilihat di GitHub ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tautan ke repositori</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Petunjuk pemasangan terperinci juga diberikan di sana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengantisipasi bunuh diri arsitektural, saya akan membuat reservasi bahwa ini bukan versi final. </font><font style="vertical-align: inherit;">Pekerjaan akan terus berlanjut terlepas dari batu-batu yang terbengkalai, tetapi telah mengijinkan keinginan.</font></font><br>
<img src="https://habrastorage.org/webt/lg/rp/op/lgrpopckj4waexmewif_u2zngf4.png" alt="Ketergantungan struktural umum dari perpustakaan QSerializer"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tujuan utama dari proyek ini adalah membuat serialisasi menggunakan format data yang mudah digunakan pengguna dalam C ++ yang dapat diakses dan dasar. </font><font style="vertical-align: inherit;">Kunci dari pengembangan kualitas dan pemeliharaan produk adalah arsitekturnya. </font><font style="vertical-align: inherit;">Saya tidak mengesampingkan bahwa cara implementasi lain mungkin muncul dalam komentar di artikel ini, jadi saya meninggalkan sedikit “ruang untuk kreativitas”. </font><font style="vertical-align: inherit;">Jika Anda mengubah implementasi, Anda bisa menambahkan implementasi baru dari antarmuka PropertyKeeper atau mengubah metode pabrik sehingga Anda tidak perlu mengubah apa pun dalam fungsi QSerializer.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Deklarasi lapangan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Salah satu cara untuk mengumpulkan informasi meta-objek di Qt adalah dengan menggambarkannya dalam sistem meta-objek Qt itu sendiri. </font><font style="vertical-align: inherit;">Mungkin ini cara termudah. </font></font><abbr title="Kompiler meta-objek"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOC akan</font></font></abbr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menghasilkan semua metadata yang diperlukan pada waktu kompilasi. </font><font style="vertical-align: inherit;">Anda dapat memanggil metode metaObject pada objek yang dideskripsikan, yang akan mengembalikan turunan dari kelas QMetaObject, yang harus kita kerjakan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendeklarasikan bidang yang akan diserialkan, Anda perlu mewarisi kelas dari QObject dan menyertakan makro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_OBJECT</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di dalamnya </font><font style="vertical-align: inherit;">, untuk memperjelas kepada MOC tentang kualifikasi jenis kelas sebagai dasar dari kelas QObject. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya, makro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> menjelaskan anggota kelas. </font><font style="vertical-align: inherit;">Kami akan memanggil </font><font style="vertical-align: inherit;">properti properti yang </font><font style="vertical-align: inherit;">dijelaskan dalam </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Q_PROPERTY</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">QSerializer akan mengabaikan properti tanpa flag USER disetel ke true.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa bendera USER</font></font></b>
                        <div class="spoiler_text">     , ,  QML.        . ,   <font color="#FF1493">Q_PROPERTY</font>  QML   QSerializer     .<br>
</div>
                    </div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> :</span> <span class="hljs-keyword">public</span> QObject<font></font>
{<font></font>
Q_OBJECT<font></font>
<span class="hljs-comment">// Define data members to be serialized</span>
Q_PROPERTY(QString name MEMBER name USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">int</span> age MEMBER age USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(QString email MEMBER email USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone MEMBER phone USER <span class="hljs-literal">true</span>)<font></font>
Q_PROPERTY(<span class="hljs-keyword">bool</span> vacation MEMBER vacation USER <span class="hljs-literal">true</span>)
<span class="hljs-keyword">public</span>:
  <span class="hljs-comment">// Make base constructor</span><font></font>
  User() { }<font></font>
 <font></font>
  QString name;<font></font>
  <span class="hljs-keyword">int</span> age{<span class="hljs-number">0</span>};<font></font>
  QString email;<font></font>
  <span class="hljs-keyword">bool</span> vacation{<span class="hljs-literal">false</span>};
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt; phone; <font></font>
};<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mendeklarasikan tipe pengguna non-standar dalam sistem meta-objek Qt, saya sarankan menggunakan makro </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang didefinisikan dalam qserializer.h. </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QS_REGISTER</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mengotomatiskan proses mendaftarkan variasi jenis. </font><font style="vertical-align: inherit;">Namun, Anda dapat menggunakan metode klasik untuk mendaftarkan tipe dengan qRegisterMetaType &lt; </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; (). </font><font style="vertical-align: inherit;">Untuk sistem objek-meta, tipe kelas ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) dan pointer kelas ( </font></font><font color="#FF1493"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> *) adalah tipe yang sama sekali berbeda, mereka akan memiliki pengidentifikasi yang berbeda dalam daftar tipe umum.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_METATYPE(Type) qRegisterMetaType<span class="hljs-meta-string">&lt;Type&gt;(#Type) ;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> QS_REGISTER(Type)       \
QS_METATYPE(Type)               \
QS_METATYPE(Type*)              \
QS_METATYPE(std::vector<span class="hljs-meta-string">&lt;Type*&gt;) \</span></span>
QS_METATYPE(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Type&gt;)  \
</code></pre><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
<span class="hljs-comment">// define user-type in Qt meta-object system</span><font></font>
QS_REGISTER(User)<font></font>
...<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSerializer Namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti yang Anda lihat dari diagram UML, QSerializer berisi sejumlah fungsi untuk serialisasi dan penataan. </font><font style="vertical-align: inherit;">Namespace secara konseptual mencerminkan esensi deklaratif dari QSerializer. </font><font style="vertical-align: inherit;">Fungsionalitas yang disematkan dapat diakses melalui nama QSerializer, tanpa perlu membuat objek di mana pun dalam kode. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan contoh membangun JSON berdasarkan objek kelas Pengguna yang dijelaskan di atas, Anda hanya perlu memanggil metode QSerializer :: toJson:</font></font><br>
<br>
<pre><code class="cpp hljs">User u;<font></font>
u.name = <span class="hljs-string">"Mike"</span>;<font></font>
u.age = <span class="hljs-number">25</span>;<font></font>
u.email = <span class="hljs-string">"example@exmail.com"</span>;<font></font>
u.phone.push_back(<span class="hljs-string">"+12345678989"</span>);<font></font>
u.phone.push_back(<span class="hljs-string">"+98765432121"</span>);<font></font>
u.vacation = <span class="hljs-literal">true</span>;<font></font>
QJsonObject json = QSerializer::toJson(&amp;u);<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah JSON yang dihasilkan:</font></font><br>
<br>
<pre><code class="json hljs">{
    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Mike"</span>,
    <span class="hljs-attr">"age"</span>: <span class="hljs-number">25</span>,
    <span class="hljs-attr">"email"</span>: <span class="hljs-string">"example@exmail.com"</span>,
    <span class="hljs-attr">"phone"</span>: [
        <span class="hljs-string">"+12345678989"</span>,
        <span class="hljs-string">"+98765432121"</span><font></font>
    ],<font></font>
    <span class="hljs-attr">"vacation"</span>: <span class="hljs-literal">true</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada dua cara untuk menyusun objek:</font></font><br>
<br>
<ul>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda perlu memodifikasi objek</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">User u;<font></font>
QJsonObject userJson;<font></font>
QSerializer::fromJson(&amp;u, userJson);</code></pre></div>
                    </div></li>
<li><div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda perlu mendapatkan objek baru</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">QJsonObject userJson;<font></font>
User * u = QSerializer::fromJson&lt;User&gt;(userJson);</code></pre></div>
                    </div></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lebih banyak contoh dan output dapat dilihat di folder </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contoh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penjaga</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mengatur penulisan dan pembacaan properti yang dideklarasikan dengan nyaman, QSerializer menggunakan kelas </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keepers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang masing-masing menyimpan pointer ke objek (QObject descendant) dan salah satu dari QMetaProperty-nya. </font><font style="vertical-align: inherit;">QMetaProperty sendiri tidak memiliki nilai tertentu, bahkan hanya objek dengan deskripsi kelas properti yang dideklarasikan untuk MOC. </font><font style="vertical-align: inherit;">Untuk membaca dan menulis, Anda memerlukan objek spesifik dari kelas di mana properti ini dijelaskan - ini adalah hal utama yang perlu diingat. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setiap bidang serializable selama serialisasi diteruskan ke penjaga dari jenis yang sesuai. </font><font style="vertical-align: inherit;">Penjaga diperlukan untuk merangkum fungsi serialisasi dan penataan untuk implementasi spesifik untuk tipe spesifik dari data yang diuraikan. </font><font style="vertical-align: inherit;">Saya menyoroti 4 jenis:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaSimpleKeeper - penjaga properti dengan tipe data primitif</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaArrayKeeper - penjaga properti dengan array data primitif</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectKeeper - penjaga objek bersarang</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QMetaObjectArrayKeeper - penjaga array objek bersarang </font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/dw/ao/0d/dwao0de8yeaqdcdb5zfkbuoof-k.png" alt="Aliran data"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inti dari pemelihara data primitif adalah konversi informasi dari JSON / XML ke QVariant dan sebaliknya, karena QMetaProperty bekerja dengan QVariant secara default.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaSimpleKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonValue result = QJsonValue::fromVariant(prop.read(linkedObj));<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(QString(prop.name()), result);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaSimpleKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;val)</span>
</span>{<font></font>
    prop.write(linkedObj, QVariant(val));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penjaga objek didasarkan pada transfer informasi dari JSON / XML ke serangkaian penjaga lain dan sebaliknya. </font><font style="vertical-align: inherit;">Penjaga tersebut bekerja dengan properti mereka sebagai objek yang terpisah, yang juga dapat memiliki penjaga sendiri, tugas mereka adalah mengumpulkan data bersambung dari objek properti dan menyusun objek objek sesuai dengan data yang tersedia.</font></font><br>
<br>
<pre><code class="cpp hljs">QMetaProperty prop;<font></font>
QObject * linkedObj;<font></font>
...<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">QMetaObjectKeeper::fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue &amp;json)</span>
</span>{<font></font>
    ...<font></font>
    QSerializer::fromJson(linkedObj, json.toObject());<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">QMetaObjectKeeper::toJson</span><span class="hljs-params">()</span>
</span>{<font></font>
    QJsonObject result = QSerializer::toJson(linkedObj);;<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">std</span>::make_pair(prop.name(),QJsonValue(result));<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Penjaga mengimplementasikan antarmuka PropertyKeeper, dari mana kelas abstrak dasar dari penjaga diwarisi. </font><font style="vertical-align: inherit;">Ini memungkinkan Anda untuk mem-parsing dan menyusun dokumen dalam format XML atau JSON secara berurutan dari atas ke bawah, cukup turun ke properti tersimpan yang dijelaskan dan pergi lebih dalam saat Anda turun ke objek tertanam, jika ada, di properti yang dijelaskan, tanpa masuk ke rincian implementasi.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antarmuka PropertyKeeper</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyKeeper</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span> ~PropertyKeeper() = <span class="hljs-keyword">default</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QJsonValue&gt; <span class="hljs-title">toJson</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromJson</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QJsonValue&amp;)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">std</span>::pair&lt;QString, QDomNode&gt; <span class="hljs-title">toXml</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fromXml</span><span class="hljs-params">(<span class="hljs-keyword">const</span> QDomNode &amp;)</span> </span>= <span class="hljs-number">0</span>;<font></font>
};<font></font>
</code></pre></div>
                    </div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pabrik Pelindung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena semua penjaga menerapkan satu antarmuka, semua implementasi disembunyikan di balik layar yang nyaman, dan satu set implementasi ini disediakan oleh pabrik KeepersFactory. </font><font style="vertical-align: inherit;">Dari objek yang ditransfer ke pabrik, Anda bisa mendapatkan daftar semua properti yang dideklarasikan melalui QMetaObject, berdasarkan tipe kustodian yang ditentukan.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi Pabrik KeepersFactory</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs">    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">int</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">bool</span>&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-keyword">double</span>&gt;(),<font></font>
        qMetaTypeId&lt;QString&gt;(),<font></font>
    };<font></font>
<font></font>
    <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-keyword">array_of_simple_t</span> =<font></font>
    {<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;(),<font></font>
        qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;(),<font></font>
    };<font></font>
...<font></font>
<span class="hljs-function">PropertyKeeper *<span class="hljs-title">KeepersFactory::getMetaKeeper</span><span class="hljs-params">(QObject *obj, QMetaProperty prop)</span>
</span>{
    <span class="hljs-keyword">int</span> t_id = QMetaType::type(prop.typeName());
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">simple_t</span>.begin(), <span class="hljs-keyword">simple_t</span>.end(), t_id) != <span class="hljs-keyword">simple_t</span>.end())
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaSimpleKeeper(obj,prop);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::find(<span class="hljs-keyword">array_of_simple_t</span>.begin(),<span class="hljs-keyword">array_of_simple_t</span>.end(), t_id) != <span class="hljs-keyword">array_of_simple_t</span>.end())<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>( t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">int</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;QString&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;QString&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">double</span>&gt;(obj, prop);<font></font>
<font></font>
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t_id == qMetaTypeId&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt;())
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaArrayKeeper&lt;<span class="hljs-keyword">bool</span>&gt;(obj, prop);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span><font></font>
    {<font></font>
        QObject * castobj = qvariant_cast&lt;QObject *&gt;(prop.read(obj));<font></font>
        <span class="hljs-keyword">if</span>(castobj)
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectKeeper(castobj,prop);
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (QString(prop.typeName()).contains(<span class="hljs-string">"std::vector&lt;"</span>))<font></font>
        {<font></font>
            QString t = QString(prop.typeName()).remove(<span class="hljs-string">"std::vector&lt;"</span>).remove(<span class="hljs-string">"&gt;"</span>);
            <span class="hljs-keyword">int</span> idOfElement = QMetaType::type(t.toStdString().c_str());
            <span class="hljs-keyword">if</span>(QMetaType::typeFlags(idOfElement).testFlag(QMetaType::PointerToQObject))
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> QMetaObjectArrayKeeper(obj, prop);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">throw</span> QSException(UnsupportedPropertyType);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper *&gt; <span class="hljs-title">KeepersFactory::getMetaKeepers</span><span class="hljs-params">(QObject *obj)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;PropertyKeeper*&gt; keepers;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; obj-&gt;metaObject()-&gt;propertyCount(); i++)<font></font>
    {<font></font>
        <span class="hljs-keyword">if</span>(obj-&gt;metaObject()-&gt;property(i).isUser(obj))<font></font>
            keepers.push_back(getMetaKeeper(obj, obj-&gt;metaObject()-&gt;property(i)));<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> keepers;<font></font>
}<font></font>
...<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur utama dari pabrik pelindung adalah kemampuan untuk menyediakan serangkaian pelindung yang lengkap untuk suatu objek, dan Anda dapat memperluas daftar tipe primitif yang didukung dengan mengedit koleksi konstan dengan pengidentifikasi tipe. </font><font style="vertical-align: inherit;">Setiap rangkaian penjaga adalah semacam peta untuk properti untuk objek. </font><font style="vertical-align: inherit;">Ketika objek KeepersFactory dihancurkan, memori yang dialokasikan untuk serangkaian penjaga yang disediakan olehnya dibebaskan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keterbatasan dan Perilaku</font></font></h2><div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Situasi</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tingkah laku</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mencoba membuat serial objek yang tipenya tidak diwarisi dari QObject</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesalahan kompilasi</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jenis tidak dideklarasikan ketika mencoba serialisasi / struturisasi</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">QSException :: Pengecualian UnsupportedPropertyType</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Upaya untuk membuat cerita bersambung / struktur objek dengan tipe primitif berbeda dari yang dijelaskan dalam koleksi simple_t dan array_of_simple_t.</font></font></td>
<td> QSException::UnsupportedPropertyType.    ,     —     ,   </td>
</tr>
<tr>
<td> JSON/XML   </td>
<td>  </td>
</tr>
<tr>
<td>   propertyes,    JSON/XML</td>
<td> propertyes .       —  propertyes          </td>
</tr>
<tr>
<td>      JSON  property </td>
<td> QSException</td>
</tr>
</tbody></table></div><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menurut saya, proyek itu ternyata bermanfaat, karena artikel ini ditulis. </font><font style="vertical-align: inherit;">Bagi saya sendiri, saya menyimpulkan bahwa tidak ada solusi universal, Anda selalu harus mengorbankan sesuatu. </font><font style="vertical-align: inherit;">Dengan mengembangkan fleksibilitas, dalam hal penggunaan, fungsionalitas, Anda membunuh kesederhanaan, dan sebaliknya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya tidak mendesak Anda untuk menggunakan QSerializer, tujuan saya adalah pengembangan saya sendiri sebagai seorang programmer. </font><font style="vertical-align: inherit;">Tentu saja, saya juga mengejar tujuan membantu seseorang, tetapi pada awalnya - hanya mendapatkan kesenangan. </font><font style="vertical-align: inherit;">Menjadi positif)</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id496824/index.html">Lingkungan kerja Nordik Anda</a></li>
<li><a href="../id496826/index.html">Juta sprite di 120+ fps</a></li>
<li><a href="../id496828/index.html">Di mana menemukan freelance yang menyenangkan? (Spoiler: tidak Upwork)</a></li>
<li><a href="../id496830/index.html">Apa itu Emergent Communication dan mengapa Anda perlu tahu</a></li>
<li><a href="../id496832/index.html">Tur foto: apa yang mereka lakukan di laboratorium nanofotonik hibrida dan optoelektronika dari Institut Fisika Baru ITMO</a></li>
<li><a href="../id496838/index.html">Metodologi penyebaran proyek yang digunakan oleh Slack</a></li>
<li><a href="../id496840/index.html">Musk percaya bahwa 12 ribu satelit tidak akan mengganggu para astronom. Pendapatnya tidak konsisten dengan model</a></li>
<li><a href="../id496842/index.html">Model epidemi sederhana dengan alat Python dasar</a></li>
<li><a href="../id496846/index.html">Mekanika bahasa tumpukan dan pointer</a></li>
<li><a href="../id496848/index.html">Intisari materi menarik untuk pengembang seluler # 340 (pada 6 - 12 April)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>