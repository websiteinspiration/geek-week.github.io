<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👌🏽 🕧 🥙 Creando un juego de carreras pseudo-3D: implementando las colinas y terminando el juego 📣 🧑🏿‍🤝‍🧑🏾 🏭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 3. Colinas
 
 En la parte anterior, creamos un juego de carreras pseudo-tridimensional simple , realizando caminos rectos y curvas en él. 
 
 Es...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Creando un juego de carreras pseudo-3D: implementando las colinas y terminando el juego</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499442/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 3. Colinas</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte anterior, creamos un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juego de carreras</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pseudo-tridimensional simple </font><font style="vertical-align: inherit;">, realizando caminos rectos y curvas en él. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta vez cuidaremos de las colinas; </font><font style="vertical-align: inherit;">Afortunadamente, será mucho más fácil que crear caminos curvos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la primera parte, usamos la ley de triángulos similares para crear una proyección de perspectiva tridimensional:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/0ab/47b/9490ab47bb570b61218e46e5913c18bb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... lo que nos llevó a obtener las ecuaciones para proyectar las coordenadas del mundo 3d en la coordenada de la pantalla 2D.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/edb/246/e18/edb246e187e7fe0eb027b53c58790c34.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... pero desde entonces trabajamos solo con carreteras rectas, las coordenadas mundiales solo necesitaban el componente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">z</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , porque tanto </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eran iguales a cero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto se adapta a nosotros también, porque para agregar colinas Es suficiente para nosotros para dar los segmentos de carretera correspondiente distinto de cero de coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , después de lo cual la función existente </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mágicamente trabajo.</font></font><a name="habracut"></a><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ede/dc6/295/ededc629516e6f0d2c7f1ca6b111e17d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sí, eso es suficiente para llegar a las colinas. </font><font style="vertical-align: inherit;">Simplemente agregue el componente </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a las coordenadas mundiales de cada segmento de carretera </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambios en la geometría de la carretera.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Modificaremos el método existente </font></font><code>addSegment</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que la función que lo llama pueda pasar </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p1.world.y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondería a </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p2.world.y del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmento anterior:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params">curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> n = segments.length;<font></font>
  segments.push({<font></font>
     <span class="hljs-attr">index</span>: n,
        <span class="hljs-attr">p1</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: lastY(), <span class="hljs-attr">z</span>:  n   *segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
        <span class="hljs-attr">p2</span>: { <span class="hljs-attr">world</span>: { <span class="hljs-attr">y</span>: y,       <span class="hljs-attr">z</span>: (n+<span class="hljs-number">1</span>)*segmentLength }, <span class="hljs-attr">camera</span>: {}, <span class="hljs-attr">screen</span>: {} },
     <span class="hljs-attr">curve</span>: curve,
     <span class="hljs-attr">color</span>: <span class="hljs-built_in">Math</span>.floor(n/rumbleLength)%<span class="hljs-number">2</span> ? COLORS.DARK : COLORS.LIGHT<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lastY</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> (segments.length == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : segments[segments.length<span class="hljs-number">-1</span>].p2.world.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue constantes para denotar </font><font style="vertical-align: inherit;">colinas </font><font style="vertical-align: inherit;">bajas ( </font></font><code>LOW</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), medias ( </font></font><code>MEDIUM</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) y altas ( </font></font><code>HIGH</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> ROAD = {
  <span class="hljs-attr">LENGTH</span>: { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">SHORT</span>:  <span class="hljs-number">25</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">50</span>, <span class="hljs-attr">LONG</span>:  <span class="hljs-number">100</span> },
  <span class="hljs-attr">HILL</span>:   { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">LOW</span>:    <span class="hljs-number">20</span>, <span class="hljs-attr">MEDIUM</span>:  <span class="hljs-number">40</span>, <span class="hljs-attr">HIGH</span>:   <span class="hljs-number">60</span> },
  <span class="hljs-attr">CURVE</span>:  { <span class="hljs-attr">NONE</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">EASY</span>:    <span class="hljs-number">2</span>, <span class="hljs-attr">MEDIUM</span>:   <span class="hljs-number">4</span>, <span class="hljs-attr">HARD</span>:    <span class="hljs-number">6</span> }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cambie el método existente </font></font><code>addRoad()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para que reciba el argumento </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que se usará junto con las funciones de suavidad para el ascenso y descenso gradual de la colina:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addRoad</span>(<span class="hljs-params">enter, hold, leave, curve, y</span>) </span>{
  <span class="hljs-keyword">var</span> startY   = lastY();
  <span class="hljs-keyword">var</span> endY     = startY + (Util.toInt(y, <span class="hljs-number">0</span>) * segmentLength);
  <span class="hljs-keyword">var</span> n, total = enter + hold + leave;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; enter ; n++)<font></font>
    addSegment(Util.easeIn(<span class="hljs-number">0</span>, curve, n/enter), Util.easeInOut(startY, endY, n/total));
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; hold  ; n++)<font></font>
    addSegment(curve, Util.easeInOut(startY, endY, (enter+n)/total));<font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; leave ; n++)<font></font>
    addSegment(Util.easeInOut(curve, <span class="hljs-number">0</span>, n/leave), Util.easeInOut(startY, endY, (enter+hold+n)/total));<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, de manera similar a lo que hicimos en la parte 2 s </font></font><code>addSCurves()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, podemos imponer cualquier método que necesitemos para construir la geometría, por ejemplo:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addLowRollingHills</span>(<span class="hljs-params">num, height</span>) </span>{<font></font>
  num    = num    || ROAD.LENGTH.SHORT;<font></font>
  height = height || ROAD.HILL.LOW;<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>, -height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  height/<span class="hljs-number">2</span>);<font></font>
  addRoad(num, num, num,  <span class="hljs-number">0</span>,  <span class="hljs-number">0</span>);<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cambios en el método de actualización.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el juego arcade que estamos creando, no intentaremos simular la realidad, por lo que las colinas no afectan al jugador ni al mundo del juego de ninguna manera, lo que significa que </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">no se requieren cambios </font><font style="vertical-align: inherit;">en el método </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación de la colina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tampoco requiere ningún cambio, porque las ecuaciones de proyección se escribieron originalmente para proyectar correctamente los segmentos de carretera con coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y que</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no son cero </font><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fondo de desplazamiento de paralaje</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de agregar coordenadas </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> a todos los segmentos de la carretera </font><font style="vertical-align: inherit;">, el único cambio será la implementación del desplazamiento vertical de las capas de fondo junto con las colinas (tal como se mueven horizontalmente junto con las curvas). </font><font style="vertical-align: inherit;">Implementamos esto con otro argumento para la función auxiliar </font></font><code>Render.background</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El mecanismo más simple será el desplazamiento de fondo habitual en relación con la posición </font></font><code>playerY</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(que debe interpolarse desde las posiciones mundiales </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y del</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segmento de jugador actual). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este no es el comportamiento más realista, porque probablemente valga la pena considerar la pendiente del segmento actual del camino del jugador, pero este efecto es simple y funciona bastante bien para una demostración simple.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eso es todo, ahora podemos complementar las curvas falsas con colinas reales:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/892/231/4e8/8922314e8acebdd3ae14fba511d17294.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El trabajo realizado por nosotros en la primera parte, incluida la infraestructura para agregar colinas 3D proyectadas reales, simplemente no te lo dije antes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la última parte del artículo agregaremos sprites, así como árboles y vallas publicitarias a lo largo de los bordes de la carretera. </font><font style="vertical-align: inherit;">También agregaremos otros autos contra los cuales será posible competir, el reconocimiento de colisiones y la fijación del "registro de círculo" del jugador.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 4. Versión lista</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En esta parte agregaremos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vallas publicitarias y árboles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Otros coches</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reconocimiento de colisión</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IA rudimentaria de automóviles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaz con temporizador de vueltas y registro de vueltas</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y esto nos proporcionará un nivel suficiente de interactividad para finalmente llamar a nuestro proyecto un "juego".</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota sobre la estructura del código</font></font></h2><br>
<blockquote><em>     ,            /,         Javascript.</em></blockquote><br>
<blockquote><em>                .     () ,             ...</em></blockquote><br>
<blockquote><em>…      ,       ,           ,  ,         .</em></blockquote><br>
<h2></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6f/111/acc/f6f111accbba448459e25c6fe761ff05.png"></div> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la parte 1, antes del inicio del ciclo del juego, subimos una hoja de sprites que contiene todos los autos, árboles y vallas publicitarias. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede crear manualmente una hoja de sprites en cualquier editor de imágenes, pero es mejor confiar el almacenamiento de imágenes y el cálculo de coordenadas a una herramienta automatizada. </font><font style="vertical-align: inherit;">En mi caso, la hoja de sprites fue generada por una pequeña tarea de rastrillo usando la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fábrica de sprites Ruby Gem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta tarea genera hojas de sprites combinadas a partir de archivos de imagen separados y también calcula las coordenadas x, y, w, h, que se almacenarán en una constante </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> SPRITES = {
  <span class="hljs-attr">PALM_TREE</span>:   { <span class="hljs-attr">x</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">215</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">540</span> },
  <span class="hljs-attr">BILLBOARD08</span>: { <span class="hljs-attr">x</span>:  <span class="hljs-number">230</span>, <span class="hljs-attr">y</span>:    <span class="hljs-number">5</span>, <span class="hljs-attr">w</span>:  <span class="hljs-number">385</span>, <span class="hljs-attr">h</span>:  <span class="hljs-number">265</span> },<font></font>
<font></font>
  <span class="hljs-comment">// ... etc</span><font></font>
<font></font>
  <span class="hljs-attr">CAR04</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1383</span>, <span class="hljs-attr">y</span>:  <span class="hljs-number">894</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">57</span> },
  <span class="hljs-attr">CAR01</span>:       { <span class="hljs-attr">x</span>: <span class="hljs-number">1205</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1018</span>, <span class="hljs-attr">w</span>:   <span class="hljs-number">80</span>, <span class="hljs-attr">h</span>:   <span class="hljs-number">56</span> },<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregar vallas publicitarias y árboles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agregue a cada segmento de la carretera una matriz que contendrá sprites de objetos a lo largo de los bordes de la carretera. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada sprite consiste en el </font></font><code>source</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tomado de la colección </font></font><code>SPRITES</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, junto con un desplazamiento horizontal </font></font><code>offset</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que se normaliza de modo que -1 indica el borde izquierdo de la carretera, y +1 significa el borde derecho, lo que nos permite no depender del valor </font></font><code>roadWidth</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algunos sprites se colocan intencionalmente, otros se asignan al azar.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    sprites: [],<font></font>
    ...<font></font>
  });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSprite</span>(<span class="hljs-params">n, sprite, offset</span>) </span>{<font></font>
  segments[n].sprites.push({ <span class="hljs-attr">source</span>: sprite, <span class="hljs-attr">offset</span>: offset });<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetSprites</span>(<span class="hljs-params"></span>) </span>{<font></font>
<font></font>
  addSprite(<span class="hljs-number">20</span>,  SPRITES.BILLBOARD07, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">40</span>,  SPRITES.BILLBOARD06, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">60</span>,  SPRITES.BILLBOARD08, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">80</span>,  SPRITES.BILLBOARD09, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">100</span>, SPRITES.BILLBOARD01, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">120</span>, SPRITES.BILLBOARD02, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">140</span>, SPRITES.BILLBOARD03, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">160</span>, SPRITES.BILLBOARD04, <span class="hljs-number">-1</span>);<font></font>
  addSprite(<span class="hljs-number">180</span>, SPRITES.BILLBOARD05, <span class="hljs-number">-1</span>);<font></font>
<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD07, <span class="hljs-number">-1.2</span>);<font></font>
  addSprite(<span class="hljs-number">240</span>, SPRITES.BILLBOARD06,  <span class="hljs-number">1.2</span>);<font></font>
<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">250</span> ; n &lt; <span class="hljs-number">1000</span> ; n += <span class="hljs-number">5</span>) {<font></font>
    addSprite(n, SPRITES.COLUMN, <span class="hljs-number">1.1</span>);<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE1, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
    addSprite(n + Util.randomInt(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>), SPRITES.TREE2, <span class="hljs-number">-1</span> - (<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">2</span>));<font></font>
  }<font></font>
<font></font>
  ...<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: si estuviéramos creando un juego real, podríamos escribir un editor de carreteras para crear visualmente un mapa con colinas y curvas, así como agregar un mecanismo para organizar sprites a lo largo de la carretera ... pero para nuestras tareas podemos hacerlo programáticamente </font></font><code>addSprite()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Máquinas de sumar</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de sprites de objetos en los bordes de la carretera, agregaremos una colección de autos que ocuparán cada segmento junto con una colección separada de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todos los</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> autos en la carretera.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">var</span> cars      = [];  <span class="hljs-comment">// array of cars on the road</span>
<span class="hljs-keyword">var</span> totalCars = <span class="hljs-number">200</span>; <span class="hljs-comment">// total number of cars on the road</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSegment</span>(<span class="hljs-params"></span>) </span>{<font></font>
  segments.push({<font></font>
    ...<font></font>
    cars: [], <span class="hljs-comment">// array of cars within this segment</span><font></font>
    ...<font></font>
  });<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El almacenamiento de dos estructuras de datos de automóviles nos permite recorrer fácilmente todos los automóviles en un método </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, moviéndolos de un segmento a otro si es necesario; </font><font style="vertical-align: inherit;">Al mismo tiempo, esto nos permite ejecutar </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo máquinas en segmentos visibles. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada máquina recibe un desplazamiento horizontal aleatorio, posición z, fuente de sprites y velocidad:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resetCars</span>(<span class="hljs-params"></span>) </span>{<font></font>
  cars = [];<font></font>
  <span class="hljs-keyword">var</span> n, car, segment, offset, z, sprite, speed;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span> ; n &lt; totalCars ; n++) {<font></font>
    offset = <span class="hljs-built_in">Math</span>.random() * Util.randomChoice([<span class="hljs-number">-0.8</span>, <span class="hljs-number">0.8</span>]);<font></font>
    z      = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * segments.length) * segmentLength;<font></font>
    sprite = Util.randomChoice(SPRITES.CARS);<font></font>
    speed  = maxSpeed/<span class="hljs-number">4</span> + <span class="hljs-built_in">Math</span>.random() * maxSpeed/(sprite == SPRITES.SEMI ? <span class="hljs-number">4</span> : <span class="hljs-number">2</span>);<font></font>
    car = { <span class="hljs-attr">offset</span>: offset, <span class="hljs-attr">z</span>: z, <span class="hljs-attr">sprite</span>: sprite, <span class="hljs-attr">speed</span>: speed };<font></font>
    segment = findSegment(car.z);<font></font>
    segment.cars.push(car);<font></font>
    cars.push(car);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Representación de colina (regreso)</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En las partes anteriores, hablé sobre la representación de segmentos de la carretera, incluidas curvas y colinas, pero había algunas líneas de código en ellas que no consideré. Se referían a una variable que </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comenzaba desde la parte inferior de la pantalla, pero que disminuía al renderizar cada segmento para determinar qué parte de la pantalla ya habíamos renderizado:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; drawDistance ; n++) {<font></font>
<font></font>
  ...<font></font>
<font></font>
  if ((segment.p1.camera.z &lt;= cameraDepth) || <span class="hljs-comment">// behind us</span>
      (segment.p2.screen.y &gt;= maxy))          <span class="hljs-comment">// clip by (already rendered) segment</span>
    <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
  ...<font></font>
<font></font>
  maxy = segment.p2.screen.y;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto nos permitirá recortar segmentos que estarán cubiertos por colinas ya renderizadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el algoritmo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tradicional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">del artista, el</font></a><font style="vertical-align: inherit;"> renderizado generalmente ocurre de atrás hacia adelante, mientras que los segmentos más cercanos se superponen a los lejanos. </font><font style="vertical-align: inherit;">Sin embargo, no podemos pasar tiempo renderizando polígonos, que eventualmente se sobrescribirán, por lo que se hace más fácil renderizar de adelante hacia atrás y recortar segmentos distantes cubiertos por segmentos ya renderizados cerca si sus coordenadas proyectadas son más pequeñas </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Renderizado de vallas publicitarias, árboles y automóviles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, el recorrido iterativo de los segmentos de carretera de adelante hacia atrás no funcionará al renderizar sprites, ya que a menudo se superponen entre sí y, por lo tanto, deben representarse utilizando el algoritmo del artista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto complica nuestro método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y nos obliga a evitar los tramos de carretera en dos etapas:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de adelante hacia atrás para renderizar en carretera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atrás adelante para renderizar sprites</font></font></li>
</ol><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8db/7d3/347/8db7d3347ac49621e67b7bbe2028fc6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de los sprites parcialmente superpuestos, tenemos que lidiar con sprites que "sobresalen levemente" debido al horizonte en la cima de la colina. Si el sprite es lo suficientemente alto, entonces deberíamos ver su parte superior, incluso si el segmento del camino en el que se encuentra está en la parte posterior de la colina, y por lo tanto no se representa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Podemos resolver el último problema guardando el valor de </font></font><code>maxy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cada segmento como una línea </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el paso 1. Luego podemos recortar los sprites de este segmento a lo largo de la línea </font></font><code>clip</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el paso 2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El resto de la lógica de renderizado determina cómo escalar y colocar el sprite en función del coeficiente </font></font><code>scale</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y las coordenadas </font></font><code>screen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de los segmentos de la carretera (calculado en etapa 1), debido a que en la segunda etapa del método </font></font><code>render()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenemos sobre lo siguiente:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">// back to front painters algorithm</span>
<span class="hljs-keyword">for</span>(n = (drawDistance<span class="hljs-number">-1</span>) ; n &gt; <span class="hljs-number">0</span> ; n--) {<font></font>
  segment = segments[(baseSegment.index + n) % segments.length];<font></font>
<font></font>
  <span class="hljs-comment">// render roadside sprites</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.sprites.length ; i++) {<font></font>
    sprite      = segment.sprites[i];<font></font>
    spriteScale = segment.p1.screen.scale;<font></font>
    spriteX     = segment.p1.screen.x + (spriteScale * sprite.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = segment.p1.screen.y;<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, sprite.source, spriteScale, spriteX, spriteY, (sprite.offset &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>), <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// render other cars</span>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ; i &lt; segment.cars.length ; i++) {<font></font>
    car         = segment.cars[i];<font></font>
    sprite      = car.sprite;<font></font>
    spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);<font></font>
    spriteX     = Util.interpolate(segment.p1.screen.x,     segment.p2.screen.x,     car.percent) + (spriteScale * car.offset * roadWidth * width/<span class="hljs-number">2</span>);<font></font>
    spriteY     = Util.interpolate(segment.p1.screen.y,     segment.p2.screen.y,     car.percent);<font></font>
    Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, <span class="hljs-number">-0.5</span>, <span class="hljs-number">-1</span>, segment.clip);<font></font>
  }<font></font>
<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colisiones con vallas publicitarias y árboles.</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora que podemos agregar y renderizar sprites de objetos a lo largo de los bordes de la carretera, necesitamos cambiar el método </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para determinar si el jugador ha encontrado uno de estos sprites en su segmento actual: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
utilizamos un método auxiliar </font></font><code>Util.overlap()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para implementar el reconocimiento generalizado de la intersección de rectángulos. </font><font style="vertical-align: inherit;">Si se detecta una intersección, detenemos el automóvil:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> ((playerX &lt; <span class="hljs-number">-1</span>) || (playerX &gt; <span class="hljs-number">1</span>)) {
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.sprites.length ; n++) {<font></font>
    sprite  = playerSegment.sprites[n];<font></font>
    spriteW = sprite.source.w * SPRITES.SCALE;<font></font>
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, sprite.offset + spriteW/<span class="hljs-number">2</span> * (sprite.offset &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>), spriteW)) {
      <span class="hljs-comment">// stop the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: si estudia el código real, verá que, de hecho, no detendremos el automóvil, porque no podrá moverse lateralmente para evitar obstáculos; </font><font style="vertical-align: inherit;">como un simple truco, arreglamos su posición y permitimos que el auto se "deslice" hacia los lados alrededor del sprite.</font></font></em><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Colisiones con automóviles</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además de las colisiones con sprites a lo largo de los bordes de la carretera, debemos reconocer las colisiones con otros automóviles, y si se detecta una intersección, reducimos la velocidad del jugador al "empujarlo" detrás de la máquina con la que chocó:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; playerSegment.cars.length ; n++) {<font></font>
  car  = playerSegment.cars[n];<font></font>
  carW = car.sprite.w * SPRITES.SCALE;<font></font>
  <span class="hljs-keyword">if</span> (speed &gt; car.speed) {
    <span class="hljs-keyword">if</span> (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">0.8</span>)) {
      <span class="hljs-comment">// slow the car</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actualización de máquina</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que otros autos se muevan por el camino, les daremos la IA más simple:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conducir a una velocidad constante</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rodear automáticamente al jugador al adelantar</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dar la vuelta automáticamente a otros coches al adelantar</font></font></li>
</ul><br>
<blockquote><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota: no necesitamos preocuparnos por girar otros autos a lo largo de una curva en la carretera, porque las curvas no son reales. </font><font style="vertical-align: inherit;">Si hacemos que los autos simplemente se muevan a lo largo de los segmentos de la carretera, pasarán automáticamente a lo largo de las curvas.</font></font></em></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todo esto sucede durante el ciclo del juego </font></font><code>update()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">durante una llamada </font></font><code>updateCars()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la que movemos cada automóvil hacia adelante a una velocidad constante y cambiamos de un segmento al siguiente si se han movido una distancia suficiente durante este marco.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCars</span>(<span class="hljs-params">dt, playerSegment, playerW</span>) </span>{
  <span class="hljs-keyword">var</span> n, car, oldSegment, newSegment;
  <span class="hljs-keyword">for</span>(n = <span class="hljs-number">0</span> ; n &lt; cars.length ; n++) {<font></font>
    car         = cars[n];<font></font>
    oldSegment  = findSegment(car.z);<font></font>
    car.offset  = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);<font></font>
    car.z       = Util.increase(car.z, dt * car.speed, trackLength);<font></font>
    car.percent = Util.percentRemaining(car.z, segmentLength); <span class="hljs-comment">// useful for interpolation during rendering phase</span><font></font>
    newSegment  = findSegment(car.z);<font></font>
    <span class="hljs-keyword">if</span> (oldSegment != newSegment) {<font></font>
      index = oldSegment.cars.indexOf(car);<font></font>
      oldSegment.cars.splice(index, <span class="hljs-number">1</span>);<font></font>
      newSegment.cars.push(car);<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método </font></font><code>updateCarOffset()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proporciona la implementación de </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"inteligencia artificial"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , lo que permite que la máquina rodee al jugador u otras máquinas. </font><font style="vertical-align: inherit;">Este es uno de los métodos más complejos en la base del código, y en un juego real debería ser mucho más complejo para que las máquinas parezcan mucho más realistas que en una demostración simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En nuestro proyecto, usamos una ingenua fuerza bruta de IA, forzando a cada máquina:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esperamos 20 segmentos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si encuentra un auto más lento frente a ella que se cruza en su camino, entonces dale la vuelta</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire a la derecha desde los obstáculos en el lado izquierdo de la carretera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire a la izquierda de los obstáculos en el lado derecho de la carretera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gire lo suficiente para evitar obstáculos en la distancia restante</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
También podemos hacer trampa con esos autos que son invisibles para el jugador, lo que les permite simplemente no rodearse y pasar. </font><font style="vertical-align: inherit;">Deben parecer "inteligentes" solo dentro de la visibilidad del jugador.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateCarOffset</span>(<span class="hljs-params">car, carSegment, playerSegment, playerW</span>) </span>{<font></font>
<font></font>
  <span class="hljs-keyword">var</span> i, j, dir, segment, otherCar, otherCarW, lookahead = <span class="hljs-number">20</span>, carW = car.sprite.w * SPRITES.SCALE;<font></font>
<font></font>
  <span class="hljs-comment">// optimization, dont bother steering around other cars when 'out of sight' of the player</span>
  <span class="hljs-keyword">if</span> ((carSegment.index - playerSegment.index) &gt; drawDistance)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span> ; i &lt; lookahead ; i++) {<font></font>
    segment = segments[(carSegment.index+i)%segments.length];<font></font>
<font></font>
    <span class="hljs-keyword">if</span> ((segment === playerSegment) &amp;&amp; (car.speed &gt; speed) &amp;&amp; (Util.overlap(playerX, playerW, car.offset, carW, <span class="hljs-number">1.2</span>))) {
      <span class="hljs-keyword">if</span> (playerX &gt; <span class="hljs-number">0.5</span>)<font></font>
        dir = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (playerX &lt; <span class="hljs-number">-0.5</span>)<font></font>
        dir = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">else</span>
        dir = (car.offset &gt; playerX) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-speed)/maxSpeed; <span class="hljs-comment">// the closer the cars (smaller i) and the greater the speed ratio, the larger the offset</span><font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span> ; j &lt; segment.cars.length ; j++) {<font></font>
      otherCar  = segment.cars[j];<font></font>
      otherCarW = otherCar.sprite.w * SPRITES.SCALE;<font></font>
      <span class="hljs-keyword">if</span> ((car.speed &gt; otherCar.speed) &amp;&amp; Util.overlap(car.offset, carW, otherCar.offset, otherCarW, <span class="hljs-number">1.2</span>)) {
        <span class="hljs-keyword">if</span> (otherCar.offset &gt; <span class="hljs-number">0.5</span>)<font></font>
          dir = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (otherCar.offset &lt; <span class="hljs-number">-0.5</span>)<font></font>
          dir = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
          dir = (car.offset &gt; otherCar.offset) ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> dir * <span class="hljs-number">1</span>/i * (car.speed-otherCar.speed)/maxSpeed;<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la mayoría de los casos, este algoritmo funciona bastante bien, pero con una gran multitud de autos al frente, podemos notar que los autos se mueven de izquierda a derecha y hacia atrás, tratando de exprimir la brecha entre las otras dos máquinas. </font><font style="vertical-align: inherit;">Hay muchas formas de mejorar la confiabilidad de la IA, por ejemplo, puede permitir que los autos disminuyan la velocidad si ven que no hay suficiente espacio para evitar obstáculos.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interfaz</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Finalmente, crearemos una interfaz HTML rudimentaria:</font></font><br>
<br>
<pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&lt;div id = "hud"&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "speed" class = "hud"&gt; &lt;span id = "speed_value" class = "value"&gt; 0 &lt;/span&gt; mph &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "current_lap_time" class = "hud"&gt; Hora: &lt;span id = "current_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt; </font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "last_lap_time" class = "hud"&gt; Última vuelta: &lt;span id = "last_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
  &lt;span id = "fast_lap_time" class = "hud"&gt; Vuelta más rápida: &lt;span id = "fast_lap_time_value" class = "value"&gt; 0.0 &lt;/span&gt; &lt;/span&gt;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
&lt;/div&gt;</font></font></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y agregarle estilo CSS</font></font><br>
<br>
<pre><code class="css hljs"><span class="hljs-selector-id">#hud</span>                   { <span class="hljs-attribute">position</span>: absolute; <span class="hljs-attribute">z-index</span>: <span class="hljs-number">1</span>; <span class="hljs-attribute">width</span>: <span class="hljs-number">640px</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span> <span class="hljs-number">0</span>; <span class="hljs-attribute">font-family</span>: Verdana, Geneva, sans-serif; <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0.8em</span>; <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.4</span>); <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">2px</span> solid black; <span class="hljs-attribute">box-sizing</span>: border-box; <span class="hljs-attribute">-moz-box-sizing</span>: border-box; <span class="hljs-attribute">-webkit-box-sizing</span>: border-box; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.hud</span>              { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0.6</span>); <span class="hljs-attribute">padding</span>: <span class="hljs-number">5px</span>; <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">5px</span>; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#speed</span>            { <span class="hljs-attribute">float</span>: right; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#current_lap_time</span> { <span class="hljs-attribute">float</span>: left;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#last_lap_time</span>    { <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">display</span>: none;  }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-id">#fast_lap_time</span>    { <span class="hljs-attribute">display</span>: block; <span class="hljs-attribute">width</span>: <span class="hljs-number">12em</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto; <span class="hljs-attribute">text-align</span>: center; <span class="hljs-attribute">transition-property</span>: background-color; <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">2s</span>; <span class="hljs-attribute">-webkit-transition-property</span>: background-color; <span class="hljs-attribute">-webkit-transition-duration</span>: <span class="hljs-number">2s</span>; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.value</span>            { <span class="hljs-attribute">color</span>: black; <span class="hljs-attribute">font-weight</span>: bold; }
<span class="hljs-selector-id">#hud</span> <span class="hljs-selector-class">.fastest</span>          { <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>,<span class="hljs-number">215</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.5</span>); }</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... y ejecutaremos su actualización () durante el ciclo del juego:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">if</span> (position &gt; playerZ) {
  <span class="hljs-keyword">if</span> (currentLapTime &amp;&amp; (startPosition &lt; playerZ)) {<font></font>
    lastLapTime    = currentLapTime;<font></font>
    currentLapTime = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (lastLapTime &lt;= Util.toFloat(Dom.storage.fast_lap_time)) {<font></font>
      Dom.storage.fast_lap_time = lastLapTime;<font></font>
      updateHud(<span class="hljs-string">'fast_lap_time'</span>, formatTime(lastLapTime));<font></font>
      Dom.addClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.addClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">else</span> {<font></font>
      Dom.removeClassName(<span class="hljs-string">'fast_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
      Dom.removeClassName(<span class="hljs-string">'last_lap_time'</span>, <span class="hljs-string">'fastest'</span>);<font></font>
    }<font></font>
    updateHud(<span class="hljs-string">'last_lap_time'</span>, formatTime(lastLapTime));<font></font>
    Dom.show(<span class="hljs-string">'last_lap_time'</span>);<font></font>
  }<font></font>
  <span class="hljs-keyword">else</span> {<font></font>
    currentLapTime += dt;<font></font>
  }<font></font>
}<font></font>
<font></font>
updateHud(<span class="hljs-string">'speed'</span>,            <span class="hljs-number">5</span> * <span class="hljs-built_in">Math</span>.round(speed/<span class="hljs-number">500</span>));<font></font>
updateHud(<span class="hljs-string">'current_lap_time'</span>, formatTime(currentLapTime));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El método auxiliar </font></font><code>updateHud()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos permite actualizar elementos DOM solo cuando cambian los valores, porque dicha actualización puede ser un proceso lento y no deberíamos realizarlo a 60 fps si los valores en sí mismos no cambian.</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateHud</span>(<span class="hljs-params">key, value</span>) </span>{ <span class="hljs-comment">// accessing DOM can be slow, so only do it if value has changed</span>
  <span class="hljs-keyword">if</span> (hud[key].value !== value) {<font></font>
    hud[key].value = value;<font></font>
    Dom.set(hud[key].dom, value);<font></font>
  }<font></font>
}</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusión</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/103/563/0d1/1035630d19106de2f85edebb24d0421f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fuh! </font><font style="vertical-align: inherit;">La última parte fue larga, pero aún así terminamos, y la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión terminada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> llegó a la etapa en que se puede llamar un juego. </font><font style="vertical-align: inherit;">Ella todavía está lejos del </font><font style="vertical-align: inherit;">juego </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terminado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero sigue siendo un juego. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sorprendente que realmente hayamos logrado crear un juego, aunque sea tan simple. </font><font style="vertical-align: inherit;">No planeo llevar este proyecto a un estado completo. </font><font style="vertical-align: inherit;">Debe considerarse simplemente como una </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introducción</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> al tema de los juegos de carreras pseudo-tridimensionales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El código </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">es publicado por github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y puedes intentar convertirlo en un juego de carreras más avanzado. </font><font style="vertical-align: inherit;">También puedes probar:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">agregar efectos de sonido a los automóviles</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mejorar la sincronización musical</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementar pantalla completa</font></font></li>
<li>   (   , ,    ,  ..)</li>
<li>    </li>
<li>   (,   ..)</li>
<li>       </li>
<li> ,     </li>
<li> ,          -</li>
<li> ,     </li>
<li>   (   ,     ..)</li>
<li>    drawDistance</li>
<li>         x,y</li>
<li>     </li>
<li>      (   ,  )</li>
<li> </li>
<li> </li>
<li>     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tenedor y conexiones por carretera</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el cambio de noche y día</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">las condiciones climáticas</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">túneles, puentes, nubes, muros, edificios</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciudad, desierto, océano</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agregue Seattle y Space Needle a los fondos</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Villanos" - agregue competidores para competir con</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">modos de juego: la vuelta más rápida, carrera uno a uno (¿recoger monedas ?, ¿disparar a villanos?)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toneladas de opciones de personalización de juego</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etc.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">...</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces hemos terminado. </font><font style="vertical-align: inherit;">Otro "proyecto de fin de semana" que tardó mucho más de lo esperado, pero al final el resultado fue bastante bueno.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencias</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comienzo de una serie de artículos, carreteras rectas y curvas.</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Página pseudo 3d de Lou</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fuente</font></font></a></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enlaces a demos jugables:</font></font><br>
<br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo de camino recto</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demo con curvas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">demostración de colinas</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">versión terminada</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es499432/index.html">Autonomía de pruebas unitarias en PHPUnit</a></li>
<li><a href="../es499434/index.html">Cómo implementar la gestión del conocimiento: beneficios "bolsas", "multas de loro" y pensamiento de clip</a></li>
<li><a href="../es499436/index.html">La enzima controlada a distancia acelerará el tratamiento de accidentes cerebrovasculares y lesiones de la columna</a></li>
<li><a href="../es499438/index.html">Stream para probadores y no solo</a></li>
<li><a href="../es499440/index.html">Mientras escribíamos el piloto automático más genial del mundo para una locomotora de maniobras</a></li>
<li><a href="../es499444/index.html">Postgres: hinchazón, pg_repack y restricciones diferidas</a></li>
<li><a href="../es499446/index.html">Prueba de cargadores de arranque en formato STEP para VR</a></li>
<li><a href="../es499448/index.html">Implementación de arquitectura SOLID y en capas en Node.js con TypeScript e InversifyJS</a></li>
<li><a href="../es499450/index.html">Elegir el equipo para un juego persa usando genética / evolución en Python</a></li>
<li><a href="../es499452/index.html">La vida cotidiana de un oftalmólogo en la clínica: cuando los médicos no son suficientes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>