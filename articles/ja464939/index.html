<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏿‍⚖️ 🦉 🤜🏾 @ NonNull / @ Nullableアノテーションのテスト 👨🏿‍🌾 👨🏾‍🔬 🙉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「専用」の代わりに
 以下に説明するタスクは革新的でも実用的でもありませんでした。私が働いている会社はそれのために利益を受け取りませんが、私はボーナスになります。
 
 しかし、この問題があったため、解決する必要がありました。
 
 はじめに
 あなたがロンボクという言葉にしばしば出会う記事では、嫌...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>@ NonNull / @ Nullableアノテーションのテスト</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464939/"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「専用」の代わりに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に説明するタスクは革新的でも実用的でもありませんでした。私が働いている会社はそれのために利益を受け取りませんが、私はボーナスになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、この問題があったため、解決する必要がありました。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はじめに</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがロンボクという言葉にしばしば出会う記事では、嫌悪者に結論に急がれないようにお願いします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はロンボクやその不在のために「溺れる」つもりはありません。ジェラルトサプコウスキーのように、中立になるように心がけます。ロンボクの有無にかかわらず、世紀中に震えずにコードを読むことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、現在のプロジェクトでは、前述のライブラリーが存在し、何かが私たちのプロジェクトだけではないことを教えてくれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからここに。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前回のJavaでは確かにannotashkiに向かう傾向があります。</font><font style="vertical-align: inherit;">ファストフェイルコンセプトの栄光は、多くの場合、メソッド注釈付きアノテーション@NonNullのパラメーターです（そのため、それがなくなった場合- </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">左</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下がり）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これ（またはイデオロギーで同様の注釈）には多くのインポートオプションがありますが、すでに明らかになっているため、バージョンに焦点を当てます</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">import</span> lombok.NonNull;</code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この（または同様の）注釈を使用する場合、テストで確認する必要がある契約があり、静的コードアナライザーが親切に通知します（Sonarが正確に通知します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニットテストを使用してこのアノテーションをテストすることは非常に簡単です。問題は、そのようなテストがプロジェクト内で春のウサギの速度で増加し、ウサギがご存知のようにDRYの原則に違反することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、@ NonNullアノテーションのコントラクトをテストするための小さなテストフレームワークを記述します（これにより、Sonarが厄介な赤いライトで目に映らないようになります）。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲の名前は、PowerWolfバンドの曲からインスピレーションを得たもので、私が名前を書いたときに（gollyで）再生されました（オリジナルでは、名前はよりポジティブに聞こえます）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主要部分</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初は、次のような注釈をテストしました。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@Test</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodNameWithNullArgumentThrowException</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">try</span> {<font></font>
      instance.getAnyType(<span class="hljs-keyword">null</span>);<font></font>
      fail(<span class="hljs-string">"Exception not thrown"</span>);<font></font>
    } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> NullPointerException e) {<font></font>
      assertNotNull(e);<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはメソッドを呼び出し、@ NonNullアノテーションが付けられたパラメーターとしてnullを渡しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはNPEを得て、満足しました（ソナーも幸せでした）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後、彼らは同じことを始めましたが、サプライヤーを介して機能するよりおしゃれなassertThrowを使用しています（ラムダが大好きです）。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@TestUnitRepeatOnce</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">methodNameWithNullArgumentThrowException</span><span class="hljs-params">()</span> </span>{<font></font>
    assertThrows(NullPointerException.class, () -&gt; instance.getAnyType(<span class="hljs-keyword">null</span>));<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタイリッシュ。ファッショナブル。青年</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
終了する可能性があるように見えますが、注釈はテストされています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このテストメソッドの問題（問題ではありませんが、それでも）は、ある日メソッドのテストを作成したときに "ポップアップ"し、正常に機能しました。その後、パラメーターに@NonNullアノテーションがないことに気付きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは理解できます：when（）/ then（）を通じて、moqueクラスの動作を記述せずにテストメソッドを呼び出します。実行中のスレッドは、ロックされていない（またはロックされているが、when（）/ then（））オブジェクトなしでNPEをキャッチするメソッド内のどこかに安全にメソッドに入り、警告どおりNPEでクラッシュします。つまり、テストは緑色です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、アノテーションではなくテストしていることがわかりましたが、何が明確ではありません。</font><font style="vertical-align: inherit;">テストが正しく機能しているので、メソッドにさらに深く入り込む必要はありません（しきい値に落ちる）。</font></font><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lombokの@NonNullアノテーションには1つの機能があります。NPEからアノテーションに移行すると、パラメーター名がエラーに書き込まれます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはこれに関与し、NPEから落ちた後、次のようにスタックトレースのテキストをさらにチェックします。</font></font><br>
<br>
<pre><code class="java hljs">exception.getCause().getMessage().equals(parameter.getName())</code></pre> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そしていきなり...</font></font></b><div class="spoiler_text">    Lombok      stacktrace    null,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">JVM TI</a>     JVM,    -   .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてが何もないようですが、今何が必要かを実際に確認していますが、「ウサギ」の問題は解決されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のようなツールが欲しいのですが。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-meta">@TestUnitRepeatOnce</span>
  <span class="hljs-meta">@SneakyThrows</span>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nonNullAnnotationTest</span><span class="hljs-params">()</span> </span>{<font></font>
    assertNonNullAnnotation(YourPerfectClass.class);<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして彼自身が、指定されたクラスのすべてのパブリックメソッドをスキャンして、それらのすべての@NonNullパラメータをテストでチェックしました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは言って、リフレクションを取得し、@ NonNullがメソッドにあるかどうか、それにヌルがあるかどうかをチェックします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべては何もありませんが、RetentionPolicyはそうではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてのアノテーションにはRetentionPolicyパラメーターがあり、SOURCE、CLASS、およびRUNTIMEの3つのタイプにすることができるため、LombokにはデフォルトでRetentionPolicy.SOURCEがあります。これは、このアノテーションがランタイムに表示されず、リフレクションで見つけられないことを意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのプロジェクトでは、パブリックメソッドのすべてのパラメーターに注釈が付けられ（プリミティブはカウントされません）、パラメーターがnullにできないことが理解されている場合、反対が示唆されている場合、パラメーターはSpring @Nullableによって注釈が付けられます。</font><font style="vertical-align: inherit;">これに関与することができます。@ Nullableとマークされておらず、プリミティブではないすべてのパブリックメソッドと、その中のすべてのパラメーターを探します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
他のすべてのケースでは、@ NonNullアノテーションをパラメーターに付ける必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便宜上、可能な限り、プライベートメソッドによってロジックを分散します。最初に、すべてのパブリックメソッドを取得します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Method&gt; <span class="hljs-title">getPublicMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz)</span> </span>{
    <span class="hljs-keyword">return</span> Arrays.stream(clazz.getDeclaredMethods())<font></font>
        .filter(METHOD_FILTER)<font></font>
        .collect(toList());<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、METHOD_FILTERは、次のように言う通常の述語です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドはパブリックである必要があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それは合成的であってはなりません（そしてこれは生のパラメータを持つメソッドがあるときに起こります） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">抽象であってはなりません（抽象クラ​​スについては、以下で個別に） </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッド名は等号であってはなりません（ある悪意のある人がPOJOフレームワークの入力でオーバーライドされた等号（）をクラスに設定することを決定した場合）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
必要なすべてのメソッドを取得し</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たら、</font><font style="vertical-align: inherit;">ループ内でそれらの並べ替えを開始します。</font><font style="vertical-align: inherit;">メソッドにパラメーターがない場合、これは候補ではありません。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (method.getParameterCount() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;<font></font>
      }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメータがある場合は、@ NonNullアノテーションが付けられているかどうかを理解する必要があります（または、 </font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">論理</font></font></b><div class="spoiler_text"><ul>
<li>public method </li>
<li> @Nullable </li>
<li>  </li>
</ul><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行うには、マップを作成し、メソッドのシーケンスに従ってパラメーターをその中に配置します。その反対に、アノテーション@NonNullを上にするかどうかを示すフラグを配置します。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">int</span> nonNullAnnotationCount = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
      val parameterCurrentMethodArray = method.getParameters();<font></font>
      val notNullAnnotationParameterMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Boolean&gt;();
      <span class="hljs-keyword">for</span> (val parameter : parameterCurrentMethodArray) {
        <span class="hljs-keyword">if</span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) {<font></font>
          notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword">true</span>);<font></font>
          nonNullAnnotationCount++;<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
          notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword">false</span>);<font></font>
        }<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (nonNullAnnotationCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;<font></font>
      }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このマップは、最初のメソッドだけでなく、メソッドを呼び出して、アノテーション@NonNullを持つすべてのパラメーターにnullを順番に渡すのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
nonNullAnnotationCountパラメーターは、メソッド内の@NonNullアノテーションが付けられるパラメーターの数をカウントします。これにより、各メソッドの呼び出し統合対話の数が決まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、@ NonNullアノテーションがない場合（パラメータはありますが、すべてプリミティブまたは@Nullableです）、次に説明することは何もありません。</font></font><br>
<br>
<pre><code class="java hljs">
<span class="hljs-keyword">if</span> (nonNullAnnotationCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;<font></font>
      }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
手元にパラメーターのマップがあります。メソッドを呼び出す回数とnullの位置はわかっているので、問題は小さいです（私は単純に理解していなかったので）、クラスのインスタンスを作成してメソッドを呼び出す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インスタンスがどのように異なるかを理解すると問題が始まります：インスタンスはプライベートクラス、デフォルトコンストラクターが1つのクラス、パラメーターが1つあるコンストラクター、そのようなコンストラクター、抽象クラス、インターフェース（デフォルトメソッドもあり、これらもパブリックです）また、テストも必要です）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、フックまたはクルックによってインスタンスを構築したとき、パラメーターをinvokeメソッドに渡す必要があり、ここでも拡張します。最終的なクラスのインスタンスを作成する方法は？と列挙型？そして原始？プリミティブの配列（これもオブジェクトであり、注釈を付けることもできます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、順番にやってみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初のケースは、1つのプライベートコンストラクターを持つクラスです。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) {<font></font>
            notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
            method.invoke(clazz, invokeMethodParameterArray);<font></font>
            makeErrorMessage(method);<font></font>
          }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、invokeメソッドを呼び出して、外部から来たclazzをテストに渡し、アノテーション@NonNullのフラグを使用して最初の位置にnullがすでにチャージされているパラメーターの配列を渡します（上で、マップ@ NonNullsを作成したことを思い出してください）。ループで実行してパラメーターの配列を作成し、nullパラメーターの位置を交互に変更し、メソッドを呼び出す前にフラグをゼロにして、次の統合で他のパラメーターがnullになるようにします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードでは、次のようになります。</font></font><br>
<br>
<pre><code class="java hljs">val invokeMethodParameterArray = <span class="hljs-keyword">new</span> Object[parameterCurrentMethodArray.length];
        <span class="hljs-keyword">boolean</span> hasNullParameter = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> currentNullableIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; invokeMethodParameterArray.length; i++) {
          <span class="hljs-keyword">if</span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) {<font></font>
            currentNullableIndex = i;<font></font>
            invokeMethodParameterArray[i] = <span class="hljs-keyword">null</span>;<font></font>
            hasNullParameter = <span class="hljs-keyword">true</span>;<font></font>
          } <span class="hljs-keyword">else</span> {<font></font>
            mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i);<font></font>
          }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
インスタンス化の最初のオプションは整理されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その他のインターフェイスでは、インターフェイスのインスタンスを取得して作成することはできません（コンストラクタさえありません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、インターフェースを使用すると、次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (INTERFACE_FILTER.test(clazz)) {<font></font>
            notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
            method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray);<font></font>
            makeErrorMessage(method);<font></font>
          }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
createInstanceByDynamicProxyを使用すると、少なくとも1つのインターフェースを実装している場合、またはインターフェース自体である場合に、クラスにインスタンスを作成できます。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ニュアンス</font></font></b><div class="spoiler_text"> ,        ,   (  - Comparable),    ,        instance    <br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
中はこんな感じです：</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createInstanceByDynamicProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz, <span class="hljs-keyword">final</span> Object[] invokeMethodParameterArray)</span> </span>{
    <span class="hljs-keyword">return</span> newProxyInstance(<font></font>
        currentThread().getContextClassLoader(),<font></font>
        <span class="hljs-keyword">new</span> Class[]{clazz},<font></font>
        (proxy, method1, args) -&gt; {<font></font>
          Constructor&lt;Lookup&gt; constructor = Lookup.class<font></font>
              .getDeclaredConstructor(Class.class);<font></font>
          constructor.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
          constructor.newInstance(clazz)<font></font>
              .in(clazz)<font></font>
              .unreflectSpecial(method1, clazz)<font></font>
              .bindTo(proxy)<font></font>
              .invokeWithArguments(invokeMethodParameterArray);<font></font>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
        }<font></font>
    );<font></font>
  }</code></pre><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レーキ</font></font></b><div class="spoiler_text">      ,     ,   ,       Lookup.class<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のインスタンス（私のお気に入り）は抽象クラスです。</font><font style="vertical-align: inherit;">そして、ここで動的プロキシは私たちを助けません。なぜなら、抽象クラスがある種のインターフェースを実装する場合、これは明らかに私たちが望むタイプではないからです。</font><font style="vertical-align: inherit;">そして、そのように、抽象クラスからnewInstance（）を取得して作成することはできません。</font><font style="vertical-align: inherit;">ここでCGLIBが役立ちます。継承に基づいてプロキシを作成するスプリングライブラリですが、問題は、ターゲットクラスにデフォルト（パラメーターなし）コンストラクターが必要であるということです。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ゴシップ</font></font></b><div class="spoiler_text">        Spring 4 CGLIB     ,  : <b> !</b><br>
</div></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 抽象クラスをインスタンス化するオプションは次のとおりです。</font></font><br>
<pre><code class="java hljs"><span class="hljs-keyword">if</span> (isAbstract(clazz.getModifiers())) {<font></font>
            createInstanceByCGLIB(clazz, method, invokeMethodParameterArray);<font></font>
            makeErrorMessage();<font></font>
          }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
makeErrorMessage（）はすでにコード例で確認されていますが、テストを削除します。アノテーション付きの@NonNullパラメータを使用してメソッドを呼び出し、nullを渡し、それが失敗しなかった場合、テストは機能せず、削除する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パラメーターマッピングの場合、コンストラクターとメソッドパラメーターの両方をマップしてロックできる共通のメソッドが1つあります。次のようになります。</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mappingParameter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Parameter parameter, <span class="hljs-keyword">final</span> Object[] methodParam, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index)</span>
      <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{
    <span class="hljs-keyword">if</span> (isFinal(parameter.getType().getModifiers())) {
      <span class="hljs-keyword">if</span> (parameter.getType().isEnum()) {<font></font>
        methodParam[index] = Enum.valueOf(<font></font>
            (Class&lt;Enum&gt;) (parameter.getType()),<font></font>
            parameter.getType().getEnumConstants()[<span class="hljs-number">0</span>].toString()<font></font>
        );<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameter.getType().isPrimitive()) {<font></font>
        mappingPrimitiveName(parameter, methodParam, index);<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameter.getType().getTypeName().equals(<span class="hljs-string">"byte[]"</span>)) {<font></font>
        methodParam[index] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
        methodParam[index] = parameter.getType().newInstance();<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      methodParam[index] = mock(parameter.getType());<font></font>
    }<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Enum（チェリーオンザケーキ）の作成に注意してください。一般的に、Enumを取得して作成することはできません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、最終的なパラメータは独自のマッピング、最終的なパラメータは独自のマッピング、そして単純にテキスト（コード）です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンストラクタとメソッドのパラメータを作成した後、インスタンスを作成します。</font></font><br>
<br>
<pre><code class="java hljs">val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number">0</span>];<font></font>
          val constructorParameterArray = <span class="hljs-keyword">new</span> Object[firstFindConstructor.getParameters().length];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructorParameterArray.length; i++) {<font></font>
            mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i);<font></font>
          }<font></font>
          notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
          createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray);<font></font>
          makeErrorMessage(method);</code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コードのこの段階に達しているため、少なくとも1つのコンストラクターがあり、任意のインスタンスを作成できることを確認しています。最初に取得したインスタンスを取得し、コンストラクターにパラメーターがあるかどうかを確認し、ない場合は、呼び出しますそう：</font></font><br>
<br>
<pre><code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number">0</span>].newInstance()), invokeMethodParameterArray);</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、このようなものがある場合：</font></font><br>
<pre><code class="java hljs">method.invoke(spy(clazz.getConstructors()[<span class="hljs-number">0</span>].newInstance()), invokeMethodParameterArray);</code></pre><cut></cut><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、少し上で見たcreateAndInvoke（）メソッドで発生するロジックです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スポイラーの下のテストクラスの完全版で、ワーキングドラフトに書いたようにgitにアップロードしませんでしたが、実際には、これはテストで継承して使用できるクラスの1つにすぎません。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソース</font></font></b><div class="spoiler_text"><pre><code class="java hljs">
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestUtil</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Method&gt; METHOD_FILTER = method -&gt;<font></font>
      isPublic(method.getModifiers())<font></font>
          &amp;&amp; isFalse(method.isSynthetic())<font></font>
          &amp;&amp; isFalse(isAbstract(method.getModifiers()))<font></font>
          &amp;&amp; isFalse(method.getName().equals(<span class="hljs-string">"equals"</span>));<font></font>
<font></font>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Class&gt; ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER = clazz -&gt;<font></font>
      clazz.getConstructors().length == <span class="hljs-number">0</span> &amp;&amp; isFalse(clazz.isInterface());<font></font>
<font></font>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Predicate&lt;Class&gt; INTERFACE_FILTER = clazz -&gt;<font></font>
      clazz.getConstructors().length == <span class="hljs-number">0</span>;<font></font>
<font></font>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BiPredicate&lt;Exception, Parameter&gt; LOMBOK_ERROR_FILTER =<font></font>
      (exception, parameter) -&gt; isNull(exception.getCause().getMessage())<font></font>
          || isFalse(exception.getCause().getMessage().equals(parameter.getName()));<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertNonNullAnnotation</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    <span class="hljs-keyword">for</span> (val method : getPublicMethods(clazz)) {
      <span class="hljs-keyword">if</span> (method.getParameterCount() == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">int</span> nonNullAnnotationCount = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<font></font>
      val parameterCurrentMethodArray = method.getParameters();<font></font>
      val notNullAnnotationParameterMap = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Boolean&gt;();
      <span class="hljs-keyword">for</span> (val parameter : parameterCurrentMethodArray) {
        <span class="hljs-keyword">if</span> (isNull(parameter.getAnnotation(Nullable.class)) &amp;&amp; isFalse(parameter.getType().isPrimitive())) {<font></font>
          notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword">true</span>);<font></font>
          nonNullAnnotationCount++;<font></font>
        } <span class="hljs-keyword">else</span> {<font></font>
          notNullAnnotationParameterMap.put(index++, <span class="hljs-keyword">false</span>);<font></font>
        }<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span> (nonNullAnnotationCount == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nonNullAnnotationCount; j++) {<font></font>
        val invokeMethodParameterArray = <span class="hljs-keyword">new</span> Object[parameterCurrentMethodArray.length];
        <span class="hljs-keyword">boolean</span> hasNullParameter = <span class="hljs-keyword">false</span>;
        <span class="hljs-keyword">int</span> currentNullableIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; invokeMethodParameterArray.length; i++) {
          <span class="hljs-keyword">if</span> (notNullAnnotationParameterMap.get(i) &amp;&amp; isFalse(hasNullParameter)) {<font></font>
            currentNullableIndex = i;<font></font>
            invokeMethodParameterArray[i] = <span class="hljs-keyword">null</span>;<font></font>
            hasNullParameter = <span class="hljs-keyword">true</span>;<font></font>
          } <span class="hljs-keyword">else</span> {<font></font>
            mappingParameter(parameterCurrentMethodArray[i], invokeMethodParameterArray, i);<font></font>
          }<font></font>
        }<font></font>
        <span class="hljs-keyword">try</span> {
          <span class="hljs-keyword">if</span> (ONLY_ONE_PRIVATE_CONSTRUCTOR_FILTER.test(clazz)) {<font></font>
            notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
            method.invoke(clazz, invokeMethodParameterArray);<font></font>
            makeErrorMessage(method);<font></font>
          }<font></font>
          <span class="hljs-keyword">if</span> (INTERFACE_FILTER.test(clazz)) {<font></font>
            notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
            method.invoke(createInstanceByDynamicProxy(clazz, invokeMethodParameterArray), invokeMethodParameterArray);<font></font>
            makeErrorMessage(method);<font></font>
          }<font></font>
          <span class="hljs-keyword">if</span> (isAbstract(clazz.getModifiers())) {<font></font>
            createInstanceByCGLIB(clazz, method, invokeMethodParameterArray);<font></font>
            makeErrorMessage();<font></font>
          }<font></font>
          val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number">0</span>];<font></font>
          val constructorParameterArray = <span class="hljs-keyword">new</span> Object[firstFindConstructor.getParameters().length];
          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructorParameterArray.length; i++) {<font></font>
            mappingParameter(firstFindConstructor.getParameters()[i], constructorParameterArray, i);<font></font>
          }<font></font>
          notNullAnnotationParameterMap.put(currentNullableIndex, <span class="hljs-keyword">false</span>);<font></font>
          createAndInvoke(clazz, method, invokeMethodParameterArray, firstFindConstructor, constructorParameterArray);<font></font>
          makeErrorMessage(method);<font></font>
        } <span class="hljs-keyword">catch</span> (<span class="hljs-keyword">final</span> Exception e) {
          <span class="hljs-keyword">if</span> (LOMBOK_ERROR_FILTER.test(e, parameterCurrentMethodArray[currentNullableIndex])) {<font></font>
            makeErrorMessage(method);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-meta">@SneakyThrows</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAndInvoke</span><span class="hljs-params">(
      <span class="hljs-keyword">final</span> Class clazz,
      <span class="hljs-keyword">final</span> Method method,
      <span class="hljs-keyword">final</span> Object[] invokeMethodParameterArray,
      <span class="hljs-keyword">final</span> Constructor firstFindConstructor,
      <span class="hljs-keyword">final</span> Object[] constructorParameterArray
  )</span> </span>{
    <span class="hljs-keyword">if</span> (firstFindConstructor.getParameters().length == <span class="hljs-number">0</span>) {<font></font>
      method.invoke(spy(clazz.getConstructors()[<span class="hljs-number">0</span>].newInstance()), invokeMethodParameterArray);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      method.invoke(spy(clazz.getConstructors()[<span class="hljs-number">0</span>].newInstance(constructorParameterArray)), invokeMethodParameterArray);<font></font>
    }<font></font>
  }<font></font>
<font></font>
<span class="hljs-meta">@SneakyThrows</span>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createInstanceByCGLIB</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz, <span class="hljs-keyword">final</span> Method method, <span class="hljs-keyword">final</span> Object[] invokeMethodParameterArray)</span> </span>{<font></font>
    MethodInterceptor handler =<font></font>
        (obj, method1, args, proxy) -&gt; proxy.invoke(clazz, args);<font></font>
    <span class="hljs-keyword">if</span> (clazz.getConstructors().length &gt; <span class="hljs-number">0</span>) {<font></font>
      val firstFindConstructor = clazz.getConstructors()[<span class="hljs-number">0</span>];<font></font>
      val constructorParam = <span class="hljs-keyword">new</span> Object[firstFindConstructor.getParameters().length];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; constructorParam.length; i++) {<font></font>
        mappingParameter(firstFindConstructor.getParameters()[i], constructorParam, i);<font></font>
      }<font></font>
      <span class="hljs-keyword">for</span> (val constructor : clazz.getConstructors()) {
        <span class="hljs-keyword">if</span> (constructor.getParameters().length == <span class="hljs-number">0</span>) {<font></font>
          val proxy = Enhancer.create(clazz, handler);<font></font>
          method.invoke(proxy.getClass().newInstance(), invokeMethodParameterArray);<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">createInstanceByDynamicProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz, <span class="hljs-keyword">final</span> Object[] invokeMethodParameterArray)</span> </span>{
    <span class="hljs-keyword">return</span> newProxyInstance(<font></font>
        currentThread().getContextClassLoader(),<font></font>
        <span class="hljs-keyword">new</span> Class[]{clazz},<font></font>
        (proxy, method1, args) -&gt; {<font></font>
          Constructor&lt;Lookup&gt; constructor = Lookup.class<font></font>
              .getDeclaredConstructor(Class.class);<font></font>
          constructor.setAccessible(<span class="hljs-keyword">true</span>);<font></font>
          constructor.newInstance(clazz)<font></font>
              .in(clazz)<font></font>
              .unreflectSpecial(method1, clazz)<font></font>
              .bindTo(proxy)<font></font>
              .invokeWithArguments(invokeMethodParameterArray);<font></font>
          <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<font></font>
        }<font></font>
    );<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeErrorMessage</span><span class="hljs-params">()</span> </span>{<font></font>
    fail(<span class="hljs-string">"  @NonNull     DefaultConstructor  "</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeErrorMessage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Method method)</span> </span>{<font></font>
    fail(<span class="hljs-string">"    "</span> + method.getName() + <span class="hljs-string">"   @NonNull"</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Method&gt; <span class="hljs-title">getPublicMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Class clazz)</span> </span>{
    <span class="hljs-keyword">return</span> Arrays.stream(clazz.getDeclaredMethods())<font></font>
        .filter(METHOD_FILTER)<font></font>
        .collect(toList());<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mappingParameter</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Parameter parameter, <span class="hljs-keyword">final</span> Object[] methodParam, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index)</span>
      <span class="hljs-keyword">throws</span> InstantiationException, IllegalAccessException </span>{
    <span class="hljs-keyword">if</span> (isFinal(parameter.getType().getModifiers())) {
      <span class="hljs-keyword">if</span> (parameter.getType().isEnum()) {<font></font>
        methodParam[index] = Enum.valueOf(<font></font>
            (Class&lt;Enum&gt;) (parameter.getType()),<font></font>
            parameter.getType().getEnumConstants()[<span class="hljs-number">0</span>].toString()<font></font>
        );<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameter.getType().isPrimitive()) {<font></font>
        mappingPrimitiveName(parameter, methodParam, index);<font></font>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameter.getType().getTypeName().equals(<span class="hljs-string">"byte[]"</span>)) {<font></font>
        methodParam[index] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">0</span>];<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
        methodParam[index] = parameter.getType().newInstance();<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      methodParam[index] = mock(parameter.getType());<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mappingPrimitiveName</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Parameter parameter, <span class="hljs-keyword">final</span> Object[] methodParam, <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> index)</span> </span>{<font></font>
    val name = parameter.getType().getName();<font></font>
    <span class="hljs-keyword">if</span> (<span class="hljs-string">"long"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-number">0L</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"int"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"byte"</span>.equals(name)) {<font></font>
      methodParam[index] = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"short"</span>.equals(name)) {<font></font>
      methodParam[index] = (<span class="hljs-keyword">short</span>) <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"double"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-number">0.0</span>d;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"float"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-number">0.0f</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"boolean"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-keyword">false</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"char"</span>.equals(name)) {<font></font>
      methodParam[index] = <span class="hljs-string">'A'</span>;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br>
</div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">結論</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは実際のプロジェクトで機能し、注釈をテストします。現時点では、可能なすべてのオプションを折りたたむことができるため、選択肢は1つしかありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスでLombockセッターを宣言し（Pojoクラスでセッターを設定しないスペシャリストがいる場合、それは発生しませんが）、セッターが宣言されるフィールドは最終ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、フレームワークは、パブリックメソッドがあり、@ NonNullアノテーションがないパラメーターがあると親切に言います。解決策は簡単です。ロジック@ NonNull / @ Nullableのコンテキストに基づいて、セッターを明示的に宣言し、そのパラメーターに注釈を付けます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
テストでメソッドパラメーターの名前（またはその他）に関連付けたい場合、ランタイムでは、デフォルトでは、メソッドの変数名は使用できません。arg[0]やarg [1]などが見つかります。 。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ランタイムでメソッド名の表示を有効にするには、Mavenプラグインを使用します。</font></font><br>
<br>
<pre><code class="java hljs"><font></font>
&lt;plugin&gt;<font></font>
          &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<font></font>
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<font></font>
          &lt;version&gt;${maven.compiler.plugin.version}&lt;/version&gt;<font></font>
          &lt;configuration&gt;<font></font>
            &lt;source&gt;${compile.target.source}&lt;/source/&gt;<font></font>
            &lt;target&gt;${compile.target.source}&lt;/target&gt;<font></font>
            &lt;encoding&gt;${project.build.sourceEncoding}&lt;/encoding&gt;<font></font>
            &lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt;<font></font>
          &lt;/configuration&gt;<font></font>
        &lt;/plugin&gt;<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特にこのキー：</font></font><br>
<br>
<pre><code class="java hljs">&lt;compilerArgs&gt;&lt;arg&gt;-parameters&lt;/arg&gt;&lt;/compilerArgs&gt;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
興味を持っていただければ幸いです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja464929/index.html">ブラウザの遅延画像読み込み（読み込み属性）</a></li>
<li><a href="../ja464931/index.html">アセンブラ挿入... Cで？</a></li>
<li><a href="../ja464933/index.html">Androidオペレーティングシステム上の電子書籍のアプリケーション。パート4.ゲーム</a></li>
<li><a href="../ja464935/index.html">快適なDevOpsSec：APIと個人アカウントを備えたNGINX用のNemesida WAF Free</a></li>
<li><a href="../ja464937/index.html">モバイル＃312開発者向けの興味深い資料のダイジェスト（8月19〜25日）</a></li>
<li><a href="../ja464943/index.html">Great Attractorとは何ですか？それは私たちを破壊しますか？</a></li>
<li><a href="../ja464947/index.html">8月25日から9月1日までのモスクワでのデジタルイベント</a></li>
<li><a href="../ja464949/index.html">もう一度、GCD、ユークリッドアルゴリズム、および一般的なアルゴリズムの歴史について少し説明します。もちろんSwiftの例では</a></li>
<li><a href="../ja464951/index.html">タスクが単純であるほど、私は誤解されることが多い</a></li>
<li><a href="../ja464955/index.html">Iron Mike TysonとブロックチェーンプロジェクトFight to Fame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>