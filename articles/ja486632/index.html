<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>☂️ 💅🏽 👓 スーパーバイザ向けのメンタルリアクティブプログラミングモデル ✊ 🌓 🚶🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="この記事は、リアクティブプログラミングとは何かを知りたい幅広い読者を対象としています。この記事の目的は、技術的な詳細に踏み込むことなく、リアクティブプログラミングの基本的なメンタルモデル（MM RP）を作成することです。
 
 免責事項 ( ) — , . , .
 , : , . , , .
 ....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>スーパーバイザ向けのメンタルリアクティブプログラミングモデル</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486632/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> <img src="https://habrastorage.org/webt/ez/hr/x0/ezhrx0ymj-ak_tdpfqhioagb3su.jpeg"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事は、リアクティブプログラミングとは何かを知りたい幅広い読者を対象としています。</font><font style="vertical-align: inherit;">この記事の目的は、技術的な詳細に踏み込むことなく、リアクティブプログラミングの基本的なメンタルモデル（MM RP）を作成することです。</font></font><br>
<a name="habracut"></a><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">免責事項</font></font></b><div class="spoiler_text"> ( ) —    ,   .     ,                     .<br>
   ,      :            ,          . ,      ,     .<br>
          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、最初に、記事の見出しで言及されているメンタルモデルと上司がそれとどう関係しているかを説明しましょう...</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンタルモデルについて</font></font></b><div class="spoiler_text">  ,  ,         ,       .     ,       .<br>
            ,         ,    (. [1], [2])<br>
    ?  ,    ,                   .      (),   ,      ,   .      ,    ,    «», «»     « »    .<br>
    ,   ,       (),     ,      -  ().</div></div> <br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして、これがボスです...</font></font></b><div class="spoiler_text">        .            «»  «»     ,            :   . (  ,  «»    ,      ).<br>
  ,   «»  ,     ,      ,  ,    , . ,          .   «»        «».      ,  ,    ,         .<br>
    ,    ,           ,   ..,       () — ,   ,            .<br>
 ,              .</div></div> <br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜリアクティブプログラミングにプロジェクトが必要なのですか？</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPに不慣れな多くの人々は、最初は彼に懐疑的であり、これはいくつかの美しい言葉でカバーされた単なる別の空のファッションであると疑っています。</font><font style="vertical-align: inherit;">特に、RPを試してみるだけでRPを評価できることがわかったとき。</font><font style="vertical-align: inherit;">エントリーのしきい値が高いため、試してみると費用がかかります。</font><font style="vertical-align: inherit;">私たちはOOPと一緒に住んでいましたが、そこに何が欠けていますか？</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この点について私の見解を紹介させてください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラミングの黎明期、ほとんどのプログラムがアセンブリ言語で直接記述されたとき、プログラマーの主な作業概念（メンタルモデルの要素）は、命令または言語コマンドでした。一部の（プリミティブ）データは、コマンドまたは命令の入力に送られます。命令は、いくつかの出力データを処理して発行します。 Fortranなどの最初の手続き型プログラミング言語が登場しても、問題の本質は変わりませんでした。 （一連の基本コマンドとして）実行されるデータと操作だけがより複雑になっています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時間が経つにつれて、この概念は世界の現実とあまり一致しないことが明らかになりました。大量のデータが存在する可能性があり、それらを構造化するのは難しい場合があります。データとその周辺の機能の両方を分割して、個別に開発して保守し、一緒に使用すると便利です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPはこれらの問題をさまざまな方法で解決しました。典型的なOOPプログラマーのメンタルモデルの単位は、データが非表示（カプセル化）されたオブジェクトであり、関数のセットとしてこのデータへのアクセスインターフェイスです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OOPは、多くの製造およびその他のプロセスの自動化とコンピュータ化において大きな役割を果たしてきました。これとともに、彼の弱点が露呈しました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、OOPにはそのようなプロセスの概念はありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼らはさまざまな側面に集中して、さまざまな方法で状況を改善しようとしました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、イベント駆動型プログラミング[3]、データフロープログラミング[4]、ストリーム処理[5]、およびその他のいくつかのパラダイムが生まれました。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれらのパラダイムに関する支持者と専門家の批判の流れを刺激し、簡単な言葉で彼らの一般的な本質を伝えようと試みます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いずれにせよ、これらのパラダイムは情報の流れを操作します。同時に、イベント駆動型プログラミングは、その名前が示すように、情報フロー要素の出現のプロセス、データフロープログラミング-フロー制御（分割、マージ、フローの変換）とストリーム処理を、フローの処理におけるリソースの最適な使用に焦点を当てています。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リアクティブプログラミングもほぼ同じですが、スレッドの作成、管理、使用といった特定の基本的な操作に重点を置いています。それら。 RPは、情報フローの要素に対するシステムの反応（英語の反応）を記述します。この意味で、ロシア語では、「試薬プログラミング」（「反応」という言葉から）または「反応プログラミング」（「何かへの反応」という言葉）を、耳を切ることが目的ではない場合に使用する方が適切です。 2番目は、誤った関連付けを引き起こしませんでした。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は別の思慮深い考えを表現するために冒険します。今日私たちが英語で呼んでいるものは、Reactive Programming（Reactive Programming）です。歴史的な理由からそう呼ばれ、今期の賛成多数意見。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このパラダイムは別様に呼ばれたかもしれない。</font><font style="vertical-align: inherit;">したがって、現在の名前に焦点を合わせるのではなく、その本質を理解するようにしてください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、RPについてはかなり抽象的なレベルで説明しますが、具体的な例としてRxJSライブラリAPIを挙げます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭字語RxJSは、Reactive Extension for JavaScriptの略で、Reactive Programming機能のJavaScript拡張機能です。</font><font style="vertical-align: inherit;">他の多くのプログラミング言語にも同様の拡張機能が存在します。以下の図に示すように、[6]から引用しています。</font></font><br>
<img src="https://habrastorage.org/webt/ii/gb/ji/iigbjinggcawbioey0iz7ztarzs.png" alt="リアクティブプログラミング拡張機能"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPのメンタルモデルにプロジェクトが必要な理由</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大きなプロジェクトは一人で行われるのではありません。プロジェクトの参加者が同じ言語を話さなければならないことをよく読んだり聞いたりできます。私の経験では、これはほとんど必要なく、可能でもありません。しかし、必要なのは、プロジェクトの最も基本的な概念を、プロジェクト参加者ができるだけ等しく述べ、理解することです。メンタルモデル（MM）に関しては、上位レベルのMMは可能な限り類似している必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、アナリストがワークフローとユースケース、パターンのアーキテクト、関数とデータ構造の開発者、テストシナリオのテスターの観点から考える場合、それらはどのように似ているのでしょうか。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれらすべての専門家にリアクティブプログラミングのカテゴリと同時に考え始めることを勧めませんが、これらのカテゴリに精通することで、同僚との専門的なコミュニケーションの効率が向上し、向上することを約束できます。</font><font style="vertical-align: inherit;">これは、一方ではMM RPが複雑なワークフローを記述するために必要なパワーを備えている一方で、他方では、多くのプログラミング言語でMM RPを直接コードに変換できるためです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">意外なこと、危険なこと、RPのそれは、私たちが慣れている方法ではありません </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私たちの経験に基づいて、リアクティブプログラミングのメンタルモデルが何で構成されているかを説明する前に、それらにないものについて読者に警告したいと思います。</font><font style="vertical-align: inherit;">さらに、それだけでなく、世界でのシンプルで理解可能なOOP動作への期待が、悲しい結果をもたらします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこれを威圧するためではなく、読者を興味をそそるためにしています。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違い1：カーソルモデルではなく、計算グラフ</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの読者が、実現する次のタスクについて考えるときに、頭の中にメンタルモデルを持っていることをお勧めします。これをカーソルモデルと呼びます。</font><font style="vertical-align: inherit;">問題を解決するために、命令の線形リスト形式の段階的なアルゴリズムが発明されると想定しています。</font><font style="vertical-align: inherit;">アルゴリズムの実行は、命令を次々に実行するステップごとに削減されます。</font><font style="vertical-align: inherit;">現在実行中の命令へのポインタのようなものを想像できます。</font><font style="vertical-align: inherit;">命令が実行されると、ポインタ（カーソル）がリスト内の次の命令に移動し、実行を開始します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデル内では、条件付きオブジェクト指向プログラミング言語で記述された一連のコマンド</font></font><br>
<pre><code class="xml hljs">1. 1 = 2<font></font>
2. 2 = 3 <font></font>
3. 3 = 1 + 2<font></font>
4.  1, 2, 3<font></font>
5. 1 = 4<font></font>
6.  1, 2, 3</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果が出ます</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 5</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのカーソルメンタルモデルは、そのような結果を完全に予測して説明します。</font><font style="vertical-align: inherit;">3行目を処理した後、値X3が設定され、5行目で指定されたX1の新しい値はそれを変更できません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPの世界では、「+」演算の解釈に応じて、結果はおそらくこれになります</font></font><br>
<pre><code class="xml hljs">2 3 5<font></font>
4 3 7</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この世界では、ほとんどの操作が入力パラメーターを相互に接続し、1つ以上のパラメーターが変更されたときに計算が「プッシュ」される計算グラフを作成します。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違い2：非同期操作</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
カーソルのメンタル計算モデルのフレームワークでは、次の操作を前の操作より早く開始することはできません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例を考えてみましょう。</font><font style="vertical-align: inherit;">関数f1がユーザーID userIdの値によって基本給を計算し、関数f2がuserIdと給与の値に基づいてボーナスを計算するとします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その場合、給与総額の計算は次のようになります。</font></font><br>
<pre><code class="xml hljs">1. X = f1(userId)<font></font>
2. Y = f2(userId, X)<font></font>
 X, Y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スタッフの基本給が10,000であるとします。</font><font style="vertical-align: inherit;">1000ユニットのボーナス。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちのカーソルメンタルモデルは、何を印刷するかを教えてくれます。</font></font><br>
<pre><code class="xml hljs">10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
悲しいかな、非同期RPの世界では、操作の期間によっては、結果が</font></font><br>
<pre><code class="xml hljs">0 0 <font></font>
10000 0 <font></font>
0 1000 <font></font>
10000 1000 </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（私はまだ例外を考慮していません）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事は、非同期反応の世界では、次の操作が前の操作である場合、それが非同期である場合、前の操作の終了を待たないということです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを説明するために、下の図に示す現実的な例を使用して、いくつかの重要な詳細を見てみましょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
図は、同期（画像の上部）および非同期（画像の下部）モードでの互いに独立している4つの命令L1、L2、L3、およびL4（スペルではなく番号は重要です）の実行時間を示しています。</font></font><br>
<img src="https://habrastorage.org/webt/vb/s5/rb/vbs5rbmbwmrmmhqtw7gtx9tivzc.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のように、最初のケースでは、後続の各命令が前の命令の終了を「待機」します。</font><font style="vertical-align: inherit;">非同期の場合、すべての命令が同時に実行され始めます。</font><font style="vertical-align: inherit;">並列実行とリソースの使用により、ほとんどの命令は同期モードよりも非同期モードで実行されます。</font><font style="vertical-align: inherit;">しかし、彼らは一緒に彼らの仕事をもっと早く遺棄するでしょう。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
両方のモードでの命令の完了順序も非常に異なります。</font><font style="vertical-align: inherit;">同期的に：</font></font><pre><code class="javascript hljs">L1, L2, L3, l4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> しかし非同期では： </font></font><pre><code class="javascript hljs">L3, L2, L1, L4</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。 </font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相違点3：不完全なチェーン（消費者なし）がまったく機能しない</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの従来のプログラミング言語では、関数呼び出しまたはオブジェクトプロパティをドットに関連付けるのが一般的です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、次のJavaScript関数呼び出しチェーンは、「good」という単語を「dog」に変換します。</font></font><br>
<pre><code class="javascript hljs">„good“.split(„“).reverse().join(„“).replace(„oo“, „o“);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
シーケンス（チェーン）は長くなる場合があります。</font><font style="vertical-align: inherit;">再利用や利便性の理由から、それらを細かく切って部分的に実行することができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPのチェーンを2つの部分に分割し、そのうちの1つだけを呼び出すと、完全なチェーン（最後にコンシューマーを含む）のみが実行されるため、通常は結果が得られません。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">なぜこれなのか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらく、多くの読者はすでに自分たちに疑問を投げかけています。なぜ、そのようなプログラミングが必要なのですか？」</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はポーランド共和国の作成者や専門家がこの質問に何を答えるかを予測することを想定していませんが、私の答えはこれです。現実の世界の多くのオブジェクトがそのように動作するため、このようなプログラミングが必要です。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">グラフの計算</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -これはExcelの基盤であり、会計士だけでなくプロジェクトマネージャーも喜んでいます。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非同期操作</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。キッチンでコーヒーやお茶を作るとき、いつもキッチンに立ってコーヒーポットやティーポットを見ていますか。番号。あなたが今のところ何か他のことをしている間、装置は水を沸騰させてその仕事をします。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作の完全なチェーン。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">壁のコンセントから電気スタンドを外し、スイッチを押してみてください。</font><font style="vertical-align: inherit;">これでランプが点灯しない。</font><font style="vertical-align: inherit;">このオブジェクトは、電力の供給源から消費者までの完全なチェーンがある場合にのみ機能します。</font><font style="vertical-align: inherit;">そして、現実世界には、そのようなオブジェクトの大部分ではないにしても多くのオブジェクトがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPの登場により、従来のプログラミングとカーソルMMに関する知識をゴミ箱に捨てないでください。</font><font style="vertical-align: inherit;">リアクティブプログラミングはそれらをそのままにし、新しいタイプのオブジェクトに対する新しい操作でそれらを拡張しました。</font><font style="vertical-align: inherit;">方法-これについては後で説明します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メンタルモデルプログラミングの空間とその中のMM RPの場所</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般的なプログラミングランドスケープでのRPの場所について述べると、著者は2つの側面、処理されたオブジェクトの複雑さと、操作の同期/非同期について言及することがよくあります。</font><font style="vertical-align: inherit;">このような分類の例は、「RxJS in Action」[7]の「RxJSをいつ、どこで使用するか」の章にあります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この分類では、オブジェクトの次元は、単一オブジェクトとマルチオブジェクト（配列、リストなど）に分けられます。</font><font style="vertical-align: inherit;">操作は同期と非同期に分けられます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、この分類はプログラミングの世界を4つの領域に分割します。</font><font style="vertical-align: inherit;">RPは、非同期操作でマルチオブジェクトを処理するこれらの領域の1つです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この分類はとても興味深いと思いますが、メンタルモデルの観点から見ていきたいと思います。</font><font style="vertical-align: inherit;">次の表にそれらを示します。</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一の値とオブジェクト</font></font></th>
<th>, ,    </th>
</tr>
<tr>
<td> </td>
<td>  </td>
<td>,  (Stream)</td>
</tr>
<tr>
<td> </td>
<td>,  (Promise)</td>
<td> (Workflow)</td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指示とカーソルのメンタルモデルについては、これ以上の説明は不要であると想定しています。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サイクル</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、MM命令とカーソルの拡張であり、サイクルの追加の命令またはある時点に戻ります。これにより、単一のオブジェクトの一連の処理命令がループに「ラップ」され、それによってそのようなオブジェクトの多くを処理できます。この場合、カーソルは前のモデルと同様にサイクル内で移動し、遷移点に到達すると、最初にジャンプするか、すべてのオブジェクトが処理されるとサイクルの処理が停止します。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェット。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このメンタルモデルと前のモデルとの違いは</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
、処理されたオブジェクトを指す</font><font style="vertical-align: inherit;">カーソル</font><font style="vertical-align: inherit;">がそのまま残り、オブジェクト自体がそれを「実行する」ことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを2つの例で見てみましょう。木製のフェンスをペイントする場合、カーソルモデルと同様に、ボード間を移動します。しかし、コンベヤーの作業員は定位置にとどまり、ジェットモデルと同様に、処理される部品自体がそれに近づきます。このようなオブジェクトは、Java言語などでは、英語ストリームという用語で呼ばれることがよくあります。</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セマフォ。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このMMは、交差点の信号機と関連付けるのが最も簡単です。非同期オブジェクトは定期的にパブリック変数の状態をポーリングし、その状態の変更後に特定のアクションを実行します。 （信号機の前のドライバーのように）</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">待っています。</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この精神的期待モデルに適したメタファーは、最後に仕事を得たときに予想した紙またはEmallの手紙です。肯定的または否定的な答えがあるかもしれません。手紙を受け取った後のあなたの行動は、その内容に大きく依存します。これらの種類のオブジェクトを表すために、英語のPromiseがよく使用されます。それは、ユーザーの観点からは期待であり、サービスを提供する請負業者にとっては、それはむしろ約束です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
説明からわかるように、各次元に沿った移動（表の上から下、または右から左へ）は、メンタルモデルの質的な変化を意味します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表からわかるように、ジェットと期待値は、私たちが関心のある南東のセルの左側と上部に隣接しています。</font><font style="vertical-align: inherit;">対象の細胞に生息するフローのメンタルモデルと比較して、フローと比較して何が新しいのですか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拡張機能とは何ですか？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Expectationsと比較したStreamsの拡張は、期待される情報が1回ではなく、多くの部分で到着する可能性があることです。この場合、プロセスは終了せずに終了することがあります。それら。一連の配信が成功すると、エラー通知が届きます。さらに、別のバージョンの情報が追加されます-プロセスの終了の通知。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、たとえば、予期される情報の一部（すべてではない）と（エラーメッセージなしで）処理の終了に関するメッセージを受け取ることが可能であることを意味します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もう一度思い出してください。Waitingを使用すると、結果の情報に対して2つの選択肢しかありません。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mental Jetモデルは、同じタイプのオブジェクトのシーケンスを変換するプロセスを理解、議論、および実装するのに適しています。 MM Streamは、MMストリームを次のように拡張します。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くのジェットがあり、それらを一緒にマージできます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジェットは不均一である可能性があります</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな基準に従ってジェットを新しいジェットに分割できます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1つのストリームのフレームワーク内で、それらを「閉じる」および/または新しいものに変換できます。 </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、プログラミングのオブジェクトの空間または風景の中のMM RP（ストリーム）の場所を決定しました。</font><font style="vertical-align: inherit;">次に、鳥瞰図を下げて、ストリームとそのメンタルモデルを詳しく見てみましょう。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ライフサイクルのストリームとフェーズ</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の近似として、RPフローは、水道管内の水流または電気の流れとして想像できます。</font><font style="vertical-align: inherit;">他の類推と同様に、この類推にも限界があり、常に適用できるわけではないことを覚えておいてください。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フローについて言えば、次の重要な側面を区別できます。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各スレッドがどういうわけか発生します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼はどういうわけか消費者に向かって動いています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼との途中で何かが起こります（彼は変身します）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数のストリームに分割したり、他のストリームとマージしたりできます</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者はどういうわけかフローを使用し、存在しなくなります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リストされている側面は、フローの個々の要素のライフサイクルのフェーズです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RxJS関数の例を使用して、これらをより詳細に検討してみましょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スレッドの作成</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームは、プログラム内の配列またはオブジェクトのリスト、バイト、ファイル行などのパッシブ要素から作成できます。この種のストリームソースはコールドと呼ばれます（技術的には、コールドストリームソースの定義はより正確です）。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆる温泉は「自分らしく生きる」ため、間に合わないと情報が失われてしまいます。このカテゴリには、コンピューター、タブレット、スマートフォンでのユーザーアクションに関する情報（キーストローク、マウスの動き、画面へのタッチなど）が含まれます。このカテゴリには、HTTPなどのさまざまなプロトコルによって要求されたデータ、さまざまなセンサーからのデータも含まれます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いわゆる「温かい」スプリングがあることに注意してください。</font><font style="vertical-align: inherit;">また、一部の「温泉」は「冷やす」ことができ、「冷たい」は「温める」ことができます。</font><font style="vertical-align: inherit;">しかし、これについては、本[7]などの特別な文献で読む必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フローを作成するすべての操作で同じタイプのオブジェクトが作成され、内容に関係なく、同じ操作でさらに処理できることを知っておくことは重要です。</font><font style="vertical-align: inherit;">この記事では、これらのオブジェクトをストリームと呼びます。</font><font style="vertical-align: inherit;">対応する英語名はObservableです。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">消費者の動きと流れの変化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流れ変換操作は、消費者への途中と自分で実行できます。</font><font style="vertical-align: inherit;">どちらの場合も、フロー要素の処理操作は厳密にシーケンシャルです。</font><font style="vertical-align: inherit;">次の操作は、前の操作が完了して結果が渡された後にのみ厳密に開始されます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部のプログラミング言語では独自の構文とセマンティクスを持つ言語構成要素であるStreamとは異なり、JavaScriptのRxJSのようなリアクティブ拡張は、拡張可能な言語の構文と基本セマンティクスを使用する必要があります。</font><font style="vertical-align: inherit;">したがって、RxJはpipe（）関数を実装します。この関数の内部で、関数自体（ストリーム自体とその個々の要素の両方のハンドラー）を呼び出すことができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
特別なパイプ可能な関数のみがフローハンドラーになることができることに注意することが重要です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「三相流」</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
電気についての類推を続けると、私たちが検討している流れは三相と呼ぶことができます。基本情報を送信する「通常のワイヤー」に加えて、「エラーワイヤー」と「ストリーム終端ワイヤー」もあります。変換操作では、オブジェクトを変更できるだけでなく、オブジェクトを別の「ワイヤー」にリダイレクトすることもできます。この手法は、たとえば、HTTPプロトコルを使用してサーバーを操作する際に発生したとされるエラーを処理する場合に使用されます。たとえば、あるサーバーが応答しない場合、最初のサーバーの要求が失敗したことをユーザーに通知せずに、別のサーバーを要求することができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、メンタルフローモデルのもう1つの非常に重要な要素です。</font><font style="vertical-align: inherit;">従来のプログラミングパラダイムでは、エラーがエラーコードとして処理関数から返されたり、割り込み（例外）としてインターセプトされる必要がある場合、フローでは、エラーはメインチャネルとは無関係に「フロー」します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで処理することができます。</font><font style="vertical-align: inherit;">たとえば、ユーザーが誤ったパスワードを入力した場合、そのパスワードを1回以上入力する追加の機会が与えられる可能性があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">フローの分割とマージ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フローの分割は2段階で実行されます。最初の段階で、空のスレッドが開始されます。次に、2番目のステージ（ストリーム処理ステージ）のいずれかの処理機能で、要素が分析され、目的のストリームにリダイレクトされます。技術的には、これを行う方法には多くのオプションがあります。たとえば、現在のスレッドから削除するか、新しいスレッドで開始する前に複製します。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
驚くほど多くの方法で、複数のストリームを1つにマージできます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
頭に浮かぶ最も簡単な方法は、それらを受信順にマージするか、最初にすべてを最初のストリームからマージし、次にすべてを2番目のストリームからマージすることです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
下の図に示す方法では、2つのストリームのうちの1つが、1番目と2番目のフローからのオブジェクトの順序付けられたペアを含む1つのストリームを形成できます。</font><font style="vertical-align: inherit;">この場合、フローの1つに新しい要素が出現すると、新しいペアが形成されます。</font><font style="vertical-align: inherit;">Aには、各ストリームの厳密に最後の要素のペアが含まれています。</font><font style="vertical-align: inherit;">これにより、同じ要素を複数のペアに含めることができます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この例で使用されているグラフィカル表記は大理石図と呼ばれ、フローの分割とマージのセマンティクスを説明するのに非常に効果的です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックに興味がある場合は、リソースの操作と大理石の図を調べることをお勧めします[8]。</font></font><br>
<img src="https://habrastorage.org/webt/cw/q7/a1/cwq7a1t6omorptqk33hgm93yetw.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームの要素を使用するには、ユーザーまたはクライアントが最初にそれをサブスクライブする必要があります。ガベージコレクターがサブスクライバーを利用しようとしたときにサブスクリプションが自動的に非アクティブになるとは限らないため、原則として、処理の最後にサブスクライブを解除する必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くのクライアントが1つのスレッドをサブスクライブできます。 RxJでは、サブスクリプション関数はsubscribe（）と呼ばれます。その中で、ほとんどの場合、ストリームの「通常の」要素の処理呼び出し、エラーハンドラー、および（比較的まれに）ストリーム終了ハンドラーを配置することをお勧めします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームの各サブスクライバーは、要素のコピーまたは元の要素のクローンを受け取ります。</font><font style="vertical-align: inherit;">問題を引き起こさないように、ストリームは、処理のために受信された要素が不変になるように実装されます。</font><font style="vertical-align: inherit;">場合によっては、この制限を回避することもできますが、回避しない方がよいでしょう。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームの危険な魅力</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームは非常に複雑なオブジェクトで、数学の積分にいくらか似ています。それらが存在することを知っていること、それが何であるかを大まかに想像すること、そしてそれらを使用できることはまったく別のことです。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらを実際にうまく適用するために必要な機能の内部ロジックを理解するには、かなりの知的努力が必要です。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームは本質的に関数型プログラミングに密接に関連しています。スレッドを適切に使用するには、2次関数（他の関数を引数として持つ関数）を作成して適用する方法を理解することが役立ちます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
流れの美しさと優雅さがあなたに完全に明らかにされます。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ストリームは伝染性です。彼らの美しさを理解した後は、もちろん必要ないすべての仕事に使っていきたいと思います。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
フローを使用することが推奨されるタスク、および従来の方法を使用する必要がある場所では、誰もが自分で決定します。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">まとめる</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この記事では、リアクティブプログラミングのメンタルモデル（MM RP）について説明し、部分的には意識の中に入れてみました。</font><font style="vertical-align: inherit;">要点をもう一度繰り返します。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MM RPは特別であり、従来のプログラミングのメンタルモデルとは異なります。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リアクティブプログラミングに着手するときは、カーソル、コールチェーン、ループなど、MMの他の領域で確立されている一部が機能しない、または機能しないことを覚えておく必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RPのメインのメンタルモデルは、「通常の」要素、エラー、およびストリームの終了に関する情報用のチャネルを持つ「3チャネルストリーム」です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ストリームには有限と無限があります。</font></font></li>
<li>    «», «»  «» .   «»  «». </li>
<li>      .        (,       ).             .</li>
<li>     ,    .</li>
<li>       ,   .</li>
<li>       .        . </li>
<li>      ,  «».</li>
</ol><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このトピックに興味がある場合は、サイトで利用可能なシミュレーターを使用してストリームを「再生」することができます[8]。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
RPの概念をよりよく理解したい場合は、本[7]に目を通し、もちろん、The Reactive Manifesto [11]に慣れることをお勧めします。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リアクティブシステムの設計とモデリングに関する書籍[9]と[10]を読むことで、独自のMM RPの形成における次のレベルに到達します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文献と参考文献</font></font></h3><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラミングはアイデアの具体化です。</font><font style="vertical-align: inherit;">（Habr。上の記事</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr.com/ru/post/425321</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sirotin V. RPSE：ソフトウェアエンジニアリングのパラダイムとしての具体化。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arxiv.org/abs/1810.01904</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント駆動型プログラミング。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en.m.wikipedia.org/wiki/Event-driven_programming</font></font></a></li>
<li>Dataflow-programming. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Dataflow_programming</a></li>
<li>Stream-processing. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">en.m.wikipedia.org/wiki/Stream_processing</a></li>
<li>Rx-Extensions: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">reactivex.io/languages.html</a></li>
<li>RxJS in Action. – 4. August 2017. Paul P. Daniels (Autor), Luis Atencio. Manning Publications. ISBN-13: 978-1617293412</li>
<li>RxJS online Documentstion. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">xgrommx.github.io/rx-book/index.html</a></li>
<li>Reactive Design Patterns. 2017. Roland Kuhn Dr., Brian Hanafee, Jamie Allen. Manning Publications. ISBN-13: 978-1617291807</li>
<li>Functional and Reactive Domain Modeling. 2016. Debasish Ghosh.Manning Publications. ISBN-13: 978-1617292248</li>
<li>The Reactive Manifesto <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">www.reactivemanifesto.org</a></li>
</ol><br>
<br>
<em> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" rel="nofollow">geralt</a></em></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja486614/index.html">eSIMが必要な理由 それがどのように機能し、なぜ彼らがそれについてそんなに多く話すのか</a></li>
<li><a href="../ja486622/index.html">並列計算モデル</a></li>
<li><a href="../ja486626/index.html">Svelte：アクションについて知る</a></li>
<li><a href="../ja486628/index.html">gnuplotの軸上のティック間の固定距離</a></li>
<li><a href="../ja486630/index.html">「目にちらつくことはありません」：電子リーダーの画面照明のテクノロジーの配置方法</a></li>
<li><a href="../ja486634/index.html">Visual Studio 2019バージョン16.3および16.4でのMSVCバックエンドの更新</a></li>
<li><a href="../ja486638/index.html">Blazor WebAssembly 3.2.0 Preview 1が利用可能になりました</a></li>
<li><a href="../ja486640/index.html">モバイル開発者向けの興味深い資料の要約＃331（1月27日-2月2日）</a></li>
<li><a href="../ja486644/index.html">5分でDIYアンテナ</a></li>
<li><a href="../ja486646/index.html">jQueryからSvelteに移行する</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>