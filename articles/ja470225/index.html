<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏭 🚵 🌁 Telegramの自己破壊写真/ビデオが安全でない理由 🐺 📣 🐆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最近、WhatsAppメッセンジャーでの自己破壊メッセージの導入について述べた記事を見ました。 Telegramと同様の機能を備えていますが、Durovのメッセンジャーで削​​除が通常のメッセージ（秘密のチャット）に適用される場合は、通常のチャットの写真にも使用できます。つまり、写真を送信した後、対...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Telegramの自己破壊写真/ビデオが安全でない理由</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470225/"><img src="https://habrastorage.org/webt/pb/vz/ur/pbvzuriwtjebtwfbawzykgzjnek.png" alt="画像"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最近、</font><b><font style="vertical-align: inherit;">WhatsApp</font></b><font style="vertical-align: inherit;">メッセンジャー</font><font style="vertical-align: inherit;">での</font><b><font style="vertical-align: inherit;">自己破壊メッセージの</font></b><font style="vertical-align: inherit;">導入について述べ</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">た記事</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を見まし</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">た</font></a><font style="vertical-align: inherit;">。 Telegramと同様の機能を備えていますが、Durovのメッセンジャーで削​​除が通常のメッセージ（秘密のチャット）に適用される場合は、通常のチャットの写真にも使用できます。つまり、写真を送信した後、対話者は限られた時間だけ写真を見ることができ、理論的には両方の対話者から（できればサーバーからも）削除された後、WhatsAppは通常のメッセージの削除を導入する予定です（これまでに行われています）。 。</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、今日はWhatsApp（私はまったく使用しないため）についてではなく、Telegramについて話しています。自己破壊的なメッセージというアイデア自体はそれほど大きな需要があるわけではありませんが、たとえば、一度しか見ることができないドキュメントや写真を送信する場合（エヘン）にそれらを使用するユーザーがいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読むのが面倒な人にとって</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、Telegramの自己破壊的なメッセージは安全</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも機密でもありません。重要なドキュメントをこの方法で話している人に送信した場合、そのドキュメントを保存できないとは思わないでください（簡単なスクリーンショットや電話スクリーンの写真について話しているのではありません）。これには秘密のチャットを使用してください。そして、これらのメッセージの実装そのものに興味がある人は、読み続けることができます。</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私もそれらを使用しましたが、それは頻繁ではなく、単に「娯楽」であり、特にそれらを見ていませんでした。今年の6月に、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UserAPI Telegram</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を調査しながら</font><font style="vertical-align: inherit;">、写真の送信と受信をテストしました。もう楽しかった。また、メッセージ送信の「ビュー」を表示すること、およびメッセージが応答で一般的にどのように表示されるかに関心がありました。この機能が「内部から」どのように実装されるのか、ファイルがテレグラムサーバーから削除されるのか、それとも何らかの方法で暗号化されるのかと思いました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして驚いたことに、これらのメッセージは通常のメッセージとほとんど変わりません。まったくまっすぐ。</font><font style="vertical-align: inherit;">通常の写真</font><font style="vertical-align: inherit;">と同じ</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">file_id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があり、ファイル自体を取得できます。そして、あなたがメッセージを見て、それがチャットに消えたとしても、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">安全に保存/送信/転送して</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、通常の写真/ビデオで実行できるのと同じことを実行できます。つまり、テレグラムサーバー自体からは削除されません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
繰り返しますが、そのようなメッセージは2つのデバイス上で通信が行われる秘密のチャットには適用されず、別のクライアントからはアクセスできません。この機能は通常のチャット用に設計されており、「安全」と見なされているようです。しかし、ここでは興味深いのですが、これらの自己破壊的なメッセージの詳細な説明はどこにも見つかりませんでした。つまり、Telegramはこれらのメッセージが、たとえば同じ秘密のチャットのように（アカウント自体にアクセスできる場合）アクセスの点で非常に安全であることを教えてくれないようです。私が見た唯一のことは、Telegram自体が、秘密のチャットでさえメッセージが100％のセキュリティを備えておらず、誰もが彼が送信するメッセージに対して責任があると言っていることです...</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は認めます、それはいくつかのWhatsApp / Viber / VKに実装されます、私はそれに注意を払うことすらしませんが、Telegramは非常に便利なメッセンジャーですが、私は非常に大好きですが、私が嫌いなのはボランティアで満たされたサポートです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6月の同じ月に、私はsupport@telegram.orgに手紙を書きました。そこで、私は2つの言語で手紙全体を書きました。自己破壊的なメッセージだけでなく、通常のメッセージについても、テレグラムは転送に制限を設けていませんが、それについては後で詳しく説明しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2か月後、彼らは私に答えなかったので、この種の「脆弱性」を見つけるときに何をすべきか、どこに書くべきかを説明するために、その非常に「サポート」テレグラムに手紙を書かなければなりませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そこで、彼らは驚いたことに3時間後に私に答えました。そこで、プロトコルの深刻な脆弱性についてsecurity@telegram.orgに書き込むか、ここで詳細を共有する必要があると私に伝えました。</font><font style="vertical-align: inherit;">サポートからの元の応答テキストを同封します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">7月5日、サポート応答</font></font></b><div class="spoiler_text"><i>.         security@telegram.org,      -      .</i><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は脆弱性の「詳細」、ビデオ、スクリプト自体、および問題の解決策（以下のメッセージがあります）を適用してサポート自体に書き込むことを決定しましたが、これまでメールまたはサポート自体で返答がありませんでした。明らかにこれまでのところ、これはそれらを気にしません。</font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一つの絵文字のアニメーションを作ってみましょう。</font></font></s><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
自己破壊的なメッセージのオプションに加えて、プライベートチャット、グループ、チャネルなどで削除されたメッセージも簡単に傍受されてしまうことに気づきました。これは</font><font style="vertical-align: inherit;">、たとえば、別のグループ内</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">のすべてのメッセージの通常の転送を</font></font></b><font style="vertical-align: inherit;"></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用して、削除されたメッセージのIDを使用し</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">てそれら</font><b><font style="vertical-align: inherit;">を</font></b><font style="vertical-align: inherit;">取得した後に実行</font><b><font style="vertical-align: inherit;">されます</font></b><font style="vertical-align: inherit;">（現在、ライブラリにはハンドラーがあります）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メッセージ自体の転送を制限するという形で問題を解決しながら、プロセス全体を手紙で説明しました（実際は簡単ですが）。また、完全に制限しない場合は、すべてのメッセージの一定の転送を禁止します。開発チームは前方から何らかの洪水を防ぐことができると思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自己破壊型の場合は、サーバーから削除してください。これで問題が解決することはありません。メッセージは受信時に正確に傍受される可能性があります。完全に排除するには、それらを読み取るためのアルゴリズム全体を作り直す必要があります。たとえば、各メッセージへのアクセスキーを作成し、このキーを使用する場合、画像/ビデオは特定の時間のみ使用できます。開発チームのアルゴリズム全体を思い付くのは難しいと私は認めます。私自身、すべての側面を考えることができず、いずれにせよ、それらを傍受する方法があります。しかし、現時点では、それらは非常にひどく実装されています。この機能に従事していた開発者は、この種の機能の開発により責任があるはずです。さて、または最後の手段として、赤い太字で直接書いてください、自己破壊的なメッセージは簡単に傍受され、おもちゃにすぎません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
15歳の学生で、最近Pythonでの開発が好きで、ユーザーAPIに手を出して、この種の「欠陥/脆弱性」を発見したことについてお話します。</font><font style="vertical-align: inherit;">さらに激怒し、ここにすべて書くことを余儀なくされました-テレグラムサポートのひどい実装で、4か月で3回無視されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の人にとって、この関数は役に立たないかもしれません、そのようなメッセージの貧弱な実装で何も悪いことを見つけませんが、Telegram自体は現在の関数の改善に興味がないので、他の人がこれを考慮するだけで役立つと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は初めて記事を書いているので、どこかに間違いを残す可能性がありますが、コメントで指摘されているように修正してくれることを願っています。</font><font style="vertical-align: inherit;">または、一般的に、彼らはすべてが間違っていることを教えてくれ、サポートを無視することは良い解決策であり、私はようやく落ち着きます。</font><font style="vertical-align: inherit;">メッセージも添付します。</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返信がなかったサポートメッセージ</font></font></b><div class="spoiler_text"><i>Hello, my name is Khamidov Amal.<br>
<br>
Recently, I wrote a user experience for my project. At some point, I noticed how my friend sent me a self-removing photo. I looked at it on my Android client and it was removed as it should be after 10 seconds.<br>
<br>
But I wondered how such messages are encrypted and how they are stored on the go. After all, it turns out that the telegram client first uploads the photo to the phone, and after reading it must remove it.<br>
<br>
I wrote a small python script using the Pyrogram library and wanted to see how they came to the client.<br>
<br>
I was surprised when I saw that these «self-deleting photos» look just like regular ones (what?).<br>
That is, if I sent a regular photo, it was no different from the “self-deprecating”.<br>
After that, I wrote a script that sends this photo on the file, and at that moment, the photo went to my test channel like a normal photo. And on the phone from which I sent this most «self-extracting» photo, it was not even read.<br>
<br>
It also allowed me to view the photo on my desktop client. That is, this script bypasses the most important essence of the «Self-extracting» photo.<br>
<br>
I consider it a vulnerability, and I consider it a solution to reconsider the method of sending «self-deleting» messages and process them on the server and not on the device.<br>
<br>
Also, I found the second one (almost a vulnerability), which was created using the API's telegram itself and is not prohibited at all.<br>
<br>
So, we are talking about ordinary messages.<br>
<br>
I also wrote a regular script that sends (forward) all messages from the chat to my group and marks them by their ID.<br>
<br>
I added a handler to this script that responds to all deleted messages and gives the ID of these deleted messages (hello pyrogram).<br>
<br>
After that, I added a script and now, when the handler responds to all deleted messages, it checks them with the messages from the group (which contains all the messages) and looks for this message by ID.<br>
<br>
On the one hand, this does not violate anything, because telegrams have an open code, everyone can write their userbots. but on the other hand (russian is good), in the last update you added the function of deleting your own and others' messages for the sake of security, but such simple scripts written by a 15-year-old schoolboy seem to bypass this very security.<br>
<br>
I understand that everyone responds in response that he sends, but a person can send important files to an unnecessary person by mistake and at this moment he will delete the message (While the interlocutor has not read) without knowing that all these messages can be compromised and most importantly, that messages are not marked read.<br>
<br>
The decision, I think, is to add limits on forward messages and review the way of “reading” messages.<br>
<br>
In the second video I attached how can I save all deleted messages without reading them.<br>
I attach the video and script that I wrote to clearly show how it works.</i><br>
</div></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、それがコードでどのように見えるか（Telethonライブラリーを使用、パイログラムではほとんど同じです）：</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードの最も重要な部分。</font><font style="vertical-align: inherit;">残りは、アカウント、電話番号などの単なる表示です。</font></font></b><div class="spoiler_text"><pre><code class="python hljs"><span class="hljs-meta">@client.on(events.NewMessage(func=lambda e: e.is_private and getattr(e, 'photo')))</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">handler</span>(<span class="hljs-params">event: message.Message</span>):</span>
    <span class="hljs-comment"># event.input_chat may be None, use event.get_input_chat()</span>
    chat: InputPeerUser = <span class="hljs-keyword">await</span> event.get_input_chat()<font></font>
    sender: User = <span class="hljs-keyword">await</span> event.get_sender()<font></font>
    photo: Photo = event.photo<font></font>
<font></font>
    <span class="hljs-keyword">await</span> client.send_message(img_channel, file=MessageMediaPhoto(photo),<font></font>
                              message=<span class="hljs-string">f'&lt;code&gt;<span class="hljs-subst">{chat.user_id}</span>&lt;/code&gt;\n'</span>
                                      <span class="hljs-string">f'&lt;code&gt;<span class="hljs-subst">{sender.first_name}</span>&lt;/code&gt;\n'</span>, parse_mode=<span class="hljs-string">'HTML'</span>)</code></pre><br>
</div></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja470215/index.html">専門家の呪い、または指数関数プロセスの予測のエラーとしてのCAGR</a></li>
<li><a href="../ja470217/index.html">偽のDS18B20防水：何をすべきか？</a></li>
<li><a href="../ja470219/index.html">F＃5：演算子</a></li>
<li><a href="../ja470221/index.html">ホリバー。ルネットの歴史。パート3.検索エンジン：Yandex対Rambler。投資しない方法</a></li>
<li><a href="../ja470223/index.html">UXモバイルゲームのデザインガイドライン</a></li>
<li><a href="../ja470227/index.html">雇用主に面接するには？</a></li>
<li><a href="../ja470229/index.html">UIのサウンド：テーマ別リソースの編集</a></li>
<li><a href="../ja470233/index.html">取引ロボットの書き方：初心者向けのツール</a></li>
<li><a href="../ja470235/index.html">CTORECORDSチャンネルの作成者であるDmitry Simonovへのインタビュー：「techdirの主な品質は、成功する習慣です」</a></li>
<li><a href="../ja470237/index.html">週末の文学：技術者のための簡単な読書</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>