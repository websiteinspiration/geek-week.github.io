<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚óΩÔ∏è ü•¶ üìü [Parte 2/2] Guia para FFmpeg e SDL ou Como gravar um player de v√≠deo em menos de 1000 linhas üßíüèΩ üë®üèª‚Äç‚úàÔ∏è üç±</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Publicamos o restante da tradu√ß√£o para o russo do manual, que est√° um pouco desatualizado, mas n√£o perdeu sua relev√¢ncia, pois este tutorial ajuda a a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>[Parte 2/2] Guia para FFmpeg e SDL ou Como gravar um player de v√≠deo em menos de 1000 linhas</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/edison/blog/502844/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><div style="text-align:center;"><img width="780" height="325" src="https://habrastorage.org/webt/yx/qh/nq/yxqhnqwvdlvzfw22erhmpfzpfba.png"></div></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Publicamos o restante da tradu√ß√£o para o russo do manual, que est√° um pouco desatualizado, mas n√£o perdeu sua relev√¢ncia, pois este tutorial ajuda a aprofundar a ‚Äúcozinha‚Äù da cria√ß√£o de aplicativos de v√≠deo usando as bibliotecas FFmpeg e SDL. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E, embora tenhamos tentado, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dificuldades de tradu√ß√£o s√£o</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> inevit√°veis ‚Äã‚Äãem um texto t√£o volumoso </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Relatar bugs (de prefer√™ncia em mensagens privadas) - juntos faremos melhor.</font></font><a name="menu"></a><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√çndice</font></font></h3><div class="scrollable-table"><table>
<tbody><tr>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 1</font></font></th>
<th align="center"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parte 2</font></font></th>
</tr>
<tr>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pref√°cio </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 1: Criando screencaps </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 2: Exibindo a </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">li√ß√£o 3: Reproduzindo som </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 4: V√°rios segmentos </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 5: Sincronizando v√≠deo</font></font></a><br>
</td>
<td align="left"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 6: Sincroniza√ß√£o de √°udio </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 7: </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posf√°cio de </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">pesquisa </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√™ndice 1. Lista de fun√ß√µes </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√™ndice 2. Estruturas de dados </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links</font></font></a></td>
</tr>
</tbody></table></div><a name="habracut"></a><br>
<a name="audio"></a><blockquote><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="EDISON Software - desenvolvimento web"><img align="left" width="153" height="75" src="https://habrastorage.org/webt/w0/zl/to/w0zltoxvysbr0yeinstkfvw1wbg.png" alt="EDISON Software - desenvolvimento web"></a><br clear="right">
     EDISON.<br>
<br>
    ,      .<br>
<br>
,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   Axxon Next  SureView Immix</a>.<br>
<br>
      ! ;-)</blockquote><br>
<h2> 6:   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Li√ß√£o 5: Sincroniza√ß√£o de V√≠deo">‚Üê</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice">‚áë</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Li√ß√£o 7: Pesquisa">‚Üí</a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">  tutorial06.c</b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre></div>
                    </div><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que temos um reprodutor mais ou menos decente, no qual voc√™ pode assistir a um filme, agora vamos sobreviver. </font><font style="vertical-align: inherit;">Na √∫ltima vez, tocamos um pouco na sincroniza√ß√£o, ou seja, sincroniza√ß√£o do som com o v√≠deo, nessa ordem, e n√£o vice-versa. </font><font style="vertical-align: inherit;">Vamos criar o mesmo layout do v√≠deo: crie um rel√≥gio de v√≠deo interno para rastrear a dist√¢ncia do fluxo de v√≠deo e sincronizar o √°udio com ele. </font><font style="vertical-align: inherit;">Mais tarde generalizaremos ainda mais - sincronizamos √°udio e v√≠deo com um rel√≥gio externo.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementa√ß√£o de rel√≥gio de v√≠deo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, queremos criar um rel√≥gio de v√≠deo semelhante ao rel√≥gio de √°udio da √∫ltima vez: um valor interno que retorna o deslocamento de tempo atual do v√≠deo atualmente sendo reproduzido. Voc√™ pode pensar que ser√° t√£o simples quanto atualizar o cron√¥metro com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atual </font><b><font style="vertical-align: inherit;">do</font></b><font style="vertical-align: inherit;"> √∫ltimo quadro exibido. No entanto, n√£o esque√ßa que o tempo entre os quadros de v√≠deo pode ser muito longo se cairmos no n√≠vel de milissegundos. Portanto, a solu√ß√£o √© rastrear outro valor, o hor√°rio em que configuramos o rel√≥gio de v√≠deo no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PTS do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √∫ltimo quadro. Portanto, o valor atual do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">rel√≥gio de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> v√≠deo ser√° </font><b><font style="vertical-align: inherit;">PTS_of_last_frame</font></b><font style="vertical-align: inherit;"> + ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">current_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_elapsed_since_PTS_value_was_set</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) </font><font style="vertical-align: inherit;">Esta solu√ß√£o √© muito semelhante √† que fizemos com o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, em nossa estrutura completa, colocaremos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">double video_current_pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t video_current_pts_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">O rel√≥gio ser√° atualizado na fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video_refresh_timer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  <span class="hljs-comment">/* ... */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
<font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o esque√ßa de inicializ√°-lo em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_component_open</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">is-&gt;video_current_pts_time = av_gettime();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E agora tudo o que precisamos √© de alguma maneira de obter as informa√ß√µes:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abstraindo do rel√≥gio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas por que se for√ßar a usar um rel√≥gio de v√≠deo? </font><font style="vertical-align: inherit;">Voc√™ pode ir al√©m e alterar nosso c√≥digo de sincroniza√ß√£o de v√≠deo para que √°udio e v√≠deo n√£o tentem sincronizar um ao outro. </font><font style="vertical-align: inherit;">Imagine como ser√° uma bagun√ßa se tentarmos fazer isso com uma op√ß√£o de linha de comando, como no FFplay. </font><font style="vertical-align: inherit;">Ent√£o, vamos abstrato </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : vamos criar uma nova fun√ß√£o de inv√≥lucro, </font><b><font style="vertical-align: inherit;">get_master_clock</font></b><font style="vertical-align: inherit;"> , que verifica a vari√°vel </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_sync_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e em seguida, chama </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_audio_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_video_clock,</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou qualquer outro rel√≥gio que poderia us√°-lo. </font><font style="vertical-align: inherit;">Podemos at√© usar um rel√≥gio de computador, que chamamos de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_external_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
main() {<font></font>
...<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
...<font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sincroniza√ß√£o de √°udio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora a parte mais dif√≠cil: sincronizar o √°udio com o rel√≥gio de v√≠deo. Nossa estrat√©gia √© medir onde est√° o √°udio, compar√°-lo com o rel√≥gio de v√≠deo e descobrir quantas amostras precisamos ajustar, ou seja, precisamos acelerar deixando cair as amostras ou diminuir a velocidade adicionando? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Executamos a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> toda vez que processamos cada conjunto de amostras de √°udio que obtemos para reduzir ou aumentar adequadamente esse conjunto. No entanto, n√£o queremos sincronizar o tempo todo, porque o processamento de √°udio ocorre com muito mais frequ√™ncia do que o processamento de pacotes de v√≠deo. Ent√£o, vamos definir o n√∫mero m√≠nimo de chamadas consecutivas para a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que s√£o considerados n√£o sincronizados antes de nos preocuparmos em fazer qualquer coisa. Obviamente, como da √∫ltima vez, ‚Äúdessincroniza√ß√£o‚Äù significa que o rel√≥gio de √°udio e o rel√≥gio de v√≠deo diferem em uma quantidade maior que o limite de sincroniza√ß√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, vamos usar um coeficiente fracion√°rio, digamos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e agora, digamos que temos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">conjuntos de amostras de √°udio que estavam fora de sincronia. O n√∫mero de amostras que n√£o sincronizamos tamb√©m pode variar bastante; portanto, assumimos o valor m√©dio de quanto cada uma delas n√£o est√° sincronizada. Por exemplo, a primeira chamada pode mostrar que n√£o estamos sincronizados por 40 ms, a pr√≥xima por 50 ms e assim por diante. Mas n√£o vamos ter uma m√©dia simples, porque os valores mais recentes s√£o mais importantes do que aqueles que v√™m antes deles. Ent√£o, vamos usar um coeficiente fracion√°rio, digamos, </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , e resumir as diferen√ßas da seguinte forma: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">new_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Quando estamos prontos para encontrar a diferen√ßa m√©dia, simplesmente calculamos </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avg_diff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> =</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diff_sum</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * (1 - </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Que diabos est√° acontecendo aqui? </font><font style="vertical-align: inherit;">A equa√ß√£o parece algum tipo de m√°gica. </font><font style="vertical-align: inherit;">Bem, essa √© basicamente uma m√©dia ponderada usando uma s√©rie geom√©trica como pesos. </font><font style="vertical-align: inherit;">N√£o sei se existe um nome para isso (chequei at√© na Wikipedia!). Mas, para mais informa√ß√µes, aqui est√° uma </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">explica√ß√£o</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (ou aqui: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">weightedmean.txt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° a apar√™ncia da nossa fun√ß√£o:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
  <font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_st-&gt;codec-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size, nb_samples;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);<font></font>
<font></font>
       <span class="hljs-comment">/* Shrinking/expanding buffer code.... */</span><font></font>
<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o est√° tudo bem conosco; </font><font style="vertical-align: inherit;">sabemos aproximadamente o quanto o som n√£o √© consistente com o v√≠deo ou com o que usamos como um rel√≥gio. </font><font style="vertical-align: inherit;">Ent√£o, agora vamos calcular quantas amostras precisamos adicionar ou descartar colocando esse c√≥digo na se√ß√£o "Reduzindo / expandindo o c√≥digo do buffer":</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
  wanted_size = samples_size + <font></font>
  ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate) * n);<font></font>
  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX)<font></font>
                             / <span class="hljs-number">100</span>);<font></font>
  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) <font></font>
                             / <span class="hljs-number">100</span>);
  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
    wanted_size = min_size;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
    wanted_size = max_size;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lembre-se de que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_length</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * # </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do canal</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 2) √© o n√∫mero de amostras em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">audio_length</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> segundos de √°udio. </font><font style="vertical-align: inherit;">Portanto, o n√∫mero de amostras que queremos ser√° igual ao n√∫mero de amostras que j√° temos, mais ou menos o n√∫mero de amostras que correspondem √† quantidade de tempo durante o qual o som foi reproduzido. </font><font style="vertical-align: inherit;">Tamb√©m definiremos um limite de qu√£o grande ou pequena nossa corre√ß√£o pode ser, porque se alterarmos muito nosso buffer, ser√° muito chato para o usu√°rio.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Corre√ß√£o do n√∫mero de amostras</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos corrigir o som. </font><font style="vertical-align: inherit;">Voc√™ deve ter notado que nossa fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> retorna um tamanho de amostra, que nos informa quantos bytes enviar para o fluxo. </font><font style="vertical-align: inherit;">Ent√£o, precisamos apenas ajustar o tamanho da amostra para o valor desejado. </font><font style="vertical-align: inherit;">Isso funciona para reduzir o tamanho da amostra. </font><font style="vertical-align: inherit;">Mas se voc√™ precisar aument√°-lo, n√£o podemos apenas aumentar o tamanho da amostra, porque n√£o h√° mais dados no buffer! </font><font style="vertical-align: inherit;">Portanto, devemos adicionar um pouco. </font><font style="vertical-align: inherit;">Mas o que exatamente adicionar? </font><font style="vertical-align: inherit;">Seria tolice tentar extrapolar o √°udio, ent√£o vamos apenas usar o √°udio que j√° temos, adicionando o valor da √∫ltima amostra ao buffer.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
  <span class="hljs-comment">/* remove samples */</span><font></font>
  samples_size = wanted_size;<font></font>
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
  <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
  <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
  <span class="hljs-comment">/* add samples by copying final samples */</span><font></font>
  nb = (samples_size - wanted_size);<font></font>
  samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
  q = samples_end + n;<font></font>
  <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
    q += n;<font></font>
    nb -= n;<font></font>
  }<font></font>
  samples_size = wanted_size;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora estamos retornando o tamanho da amostra e terminamos com essa fun√ß√£o. </font><font style="vertical-align: inherit;">Tudo o que precisamos fazer agora √© usar isso:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tudo o que fizemos foi inserir uma chamada </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">synchronize_audio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">(Al√©m disso, verifique o c√≥digo-fonte, no qual inicializamos as vari√°veis ‚Äã‚Äãque eu n√£o me incomodei em definir.) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E a √∫ltima, antes de terminar: precisamos adicionar a condi√ß√£o "if" para garantir que n√£o sincronizamos o v√≠deo se for o rel√≥gio principal:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
  ref_clock = get_master_clock(is);<font></font>
  diff = vp-&gt;pts - ref_clock;<font></font>
<font></font>
  <span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
     FFPlay still doesn't "know if this is the best guess." */</span><font></font>
  sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay :<font></font>
                    AV_SYNC_THRESHOLD;<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
    <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
      delay = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
      delay = <span class="hljs-number">2</span> * delay;<font></font>
    }<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E funciona! </font><font style="vertical-align: inherit;">Verifique o arquivo de origem para inicializar todas as vari√°veis ‚Äã‚Äãque eu n√£o me incomodei em definir ou inicializar. </font><font style="vertical-align: inherit;">Em seguida, compile:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial06 tutorial06.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e o v√¥o ser√° normal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Na √∫ltima li√ß√£o, retrocederemos.</font></font><a name="seeking"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Li√ß√£o 7: pesquisa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Li√ß√£o 6: Sincroniza√ß√£o de √°udio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üê </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚áë </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Posf√°cio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí</font></font></a></h2><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lista completa tutorial07.c</font></font></b>
                        <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment">// tutorial05.c</span>
<span class="hljs-comment">// A pedagogical video player that really works!</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Code based on FFplay, Copyright (c) 2003 Fabrice Bellard, </span>
<span class="hljs-comment">// and a tutorial by Martin Bohme (boehme@inb.uni-luebeckREMOVETHIS.de)</span>
<span class="hljs-comment">// Tested on Gentoo, CVS version 5/01/07 compiled with GCC 4.1.1</span>
<span class="hljs-comment">// With updates from https://github.com/chelyaev/ffmpeg-tutorial</span>
<span class="hljs-comment">// Updates tested on:</span>
<span class="hljs-comment">// LAVC 54.59.100, LAVF 54.29.104, LSWS 2.1.101, SDL 1.2.15</span>
<span class="hljs-comment">// on GCC 4.7.2 in Debian February 2015</span>
<span class="hljs-comment">// Use</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// gcc -o tutorial05 tutorial05.c -lavformat -lavcodec -lswscale -lz -lm `sdl-config --cflags --libs`</span>
<span class="hljs-comment">// to build (assuming libavformat and libavcodec are correctly installed, </span>
<span class="hljs-comment">// and assuming you have sdl-config. Please refer to SDL docs for your installation.)</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// Run using</span>
<span class="hljs-comment">// tutorial04 myvideofile.mpg</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// to play the video stream on your screen.</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavcodec/avcodec.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libavformat/avformat.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;libswscale/swscale.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;SDL_thread.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> __MINGW32__</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> main <span class="hljs-comment">/* Prevents SDL from overriding main() */</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span><font></font>
<font></font>
<span class="hljs-comment">// compatibility with newer API</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_alloc avcodec_alloc_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> av_frame_free avcodec_free_frame</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SDL_AUDIO_BUFFER_SIZE 1024</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 192000</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SAMPLE_CORRECTION_PERCENT_MAX 10</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> AUDIO_DIFF_AVG_NB 20</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_REFRESH_EVENT (SDL_USEREVENT)</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FF_QUIT_EVENT (SDL_USEREVENT + 1)</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VIDEO_PICTURE_QUEUE_SIZE 1</span><font></font>
<font></font>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEFAULT_AV_SYNC_TYPE AV_SYNC_VIDEO_MASTER</span><font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PacketQueue</span> {</span><font></font>
  AVPacketList *first_pkt, *last_pkt;<font></font>
  <span class="hljs-keyword">int</span> nb_packets;
  <span class="hljs-keyword">int</span> size;<font></font>
  SDL_mutex *mutex;<font></font>
  SDL_cond *cond;<font></font>
} PacketQueue;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoPicture</span> {</span><font></font>
  SDL_Overlay *bmp;<font></font>
  <span class="hljs-keyword">int</span> width, height; <span class="hljs-comment">/* source height &amp; width */</span>
  <span class="hljs-keyword">int</span> allocated;
  <span class="hljs-keyword">double</span> pts;<font></font>
} VideoPicture;<font></font>
<font></font>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">VideoState</span> {</span><font></font>
<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  <span class="hljs-keyword">int</span>             videoStream, audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">int</span>             av_sync_type;
  <span class="hljs-keyword">double</span>          external_clock; <span class="hljs-comment">/* external clock base */</span>
  <span class="hljs-keyword">int64_t</span>         external_clock_time;
  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">double</span>          audio_clock;<font></font>
  AVStream        *audio_st;<font></font>
  AVCodecContext  *audio_ctx;<font></font>
  PacketQueue     audioq;<font></font>
  <span class="hljs-keyword">uint8_t</span>         audio_buf[(AVCODEC_MAX_AUDIO_FRAME_SIZE * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span>];
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_size;
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>    audio_buf_index;<font></font>
  AVFrame         audio_frame;<font></font>
  AVPacket        audio_pkt;<font></font>
  <span class="hljs-keyword">uint8_t</span>         *audio_pkt_data;
  <span class="hljs-keyword">int</span>             audio_pkt_size;
  <span class="hljs-keyword">int</span>             audio_hw_buf_size;
  <span class="hljs-keyword">double</span>          audio_diff_cum; <span class="hljs-comment">/* used for AV difference average computation */</span>
  <span class="hljs-keyword">double</span>          audio_diff_avg_coef;
  <span class="hljs-keyword">double</span>          audio_diff_threshold;
  <span class="hljs-keyword">int</span>             audio_diff_avg_count;
  <span class="hljs-keyword">double</span>          frame_timer;
  <span class="hljs-keyword">double</span>          frame_last_pts;
  <span class="hljs-keyword">double</span>          frame_last_delay;
  <span class="hljs-keyword">double</span>          video_clock; <span class="hljs-comment">///&lt;pts of last decoded frame / predicted pts of next decoded frame</span>
  <span class="hljs-keyword">double</span>          video_current_pts; <span class="hljs-comment">///&lt;current displayed pts (different from video_clock if frame fifos are used)</span>
  <span class="hljs-keyword">int64_t</span>         video_current_pts_time;  <span class="hljs-comment">///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><font></font>
  AVStream        *video_st;<font></font>
  AVCodecContext  *video_ctx;<font></font>
  PacketQueue     videoq;<font></font>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwsContext</span> *<span class="hljs-title">sws_ctx</span>;</span><font></font>
<font></font>
  VideoPicture    pictq[VIDEO_PICTURE_QUEUE_SIZE];<font></font>
  <span class="hljs-keyword">int</span>             pictq_size, pictq_rindex, pictq_windex;<font></font>
  SDL_mutex       *pictq_mutex;<font></font>
  SDL_cond        *pictq_cond;<font></font>
  <font></font>
  SDL_Thread      *parse_tid;<font></font>
  SDL_Thread      *video_tid;<font></font>
<font></font>
  <span class="hljs-keyword">char</span>            filename[<span class="hljs-number">1024</span>];
  <span class="hljs-keyword">int</span>             quit;<font></font>
} VideoState;<font></font>
<font></font>
<span class="hljs-keyword">enum</span> {<font></font>
  AV_SYNC_AUDIO_MASTER,<font></font>
  AV_SYNC_VIDEO_MASTER,<font></font>
  AV_SYNC_EXTERNAL_MASTER,<font></font>
};<font></font>
<font></font>
SDL_Surface     *screen;<font></font>
SDL_mutex       *screen_mutex;<font></font>
<font></font>
<span class="hljs-comment">/* Since we only have one decoding thread, the Big Struct
   can be global in case we need it. */</span><font></font>
VideoState *global_video_state;<font></font>
AVPacket flush_pkt;<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_init</span><span class="hljs-params">(PacketQueue *q)</span> </span>{
  <span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(PacketQueue));<font></font>
  q-&gt;mutex = SDL_CreateMutex();<font></font>
  q-&gt;cond = SDL_CreateCond();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
  pkt1 = av_malloc(<span class="hljs-keyword">sizeof</span>(AVPacketList));
  <span class="hljs-keyword">if</span> (!pkt1)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  pkt1-&gt;pkt = *pkt;<font></font>
  pkt1-&gt;next = <span class="hljs-literal">NULL</span>;<font></font>
  <font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span> (!q-&gt;last_pkt)<font></font>
    q-&gt;first_pkt = pkt1;<font></font>
  <span class="hljs-keyword">else</span><font></font>
    q-&gt;last_pkt-&gt;next = pkt1;<font></font>
  q-&gt;last_pkt = pkt1;<font></font>
  q-&gt;nb_packets++;<font></font>
  q-&gt;size += pkt1-&gt;pkt.size;<font></font>
  SDL_CondSignal(q-&gt;cond);<font></font>
  <font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_get</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt, <span class="hljs-keyword">int</span> block)</span>
</span>{<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">int</span> ret;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <font></font>
  <span class="hljs-keyword">for</span>(;;) {<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(global_video_state-&gt;quit) {<font></font>
      ret = <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
<font></font>
    pkt1 = q-&gt;first_pkt;<font></font>
    <span class="hljs-keyword">if</span> (pkt1) {<font></font>
      q-&gt;first_pkt = pkt1-&gt;next;<font></font>
      <span class="hljs-keyword">if</span> (!q-&gt;first_pkt)<font></font>
	q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
      q-&gt;nb_packets--;<font></font>
      q-&gt;size -= pkt1-&gt;pkt.size;<font></font>
      *pkt = pkt1-&gt;pkt;<font></font>
      av_free(pkt1);<font></font>
      ret = <span class="hljs-number">1</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!block) {<font></font>
      ret = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      SDL_CondWait(q-&gt;cond, q-&gt;mutex);<font></font>
    }<font></font>
  }<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">return</span> ret;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_audio_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> hw_buf_size, bytes_per_sec, n;<font></font>
  <font></font>
  pts = is-&gt;audio_clock; <span class="hljs-comment">/* maintained in the audio thread */</span><font></font>
  hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
  bytes_per_sec = <span class="hljs-number">0</span>;<font></font>
  n = is-&gt;audio_ctx-&gt;channels * <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(is-&gt;audio_st) {<font></font>
    bytes_per_sec = is-&gt;audio_ctx-&gt;sample_rate * n;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(bytes_per_sec) {<font></font>
    pts -= (<span class="hljs-keyword">double</span>)hw_buf_size / bytes_per_sec;<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_video_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">double</span> delta;<font></font>
<font></font>
  delta = (av_gettime() - is-&gt;video_current_pts_time) / <span class="hljs-number">1000000.0</span>;
  <span class="hljs-keyword">return</span> is-&gt;video_current_pts + delta;<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_external_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">return</span> av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">get_master_clock</span><span class="hljs-params">(VideoState *is)</span> </span>{
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {
    <span class="hljs-keyword">return</span> get_video_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">return</span> get_audio_clock(is);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> get_external_clock(is);<font></font>
  }<font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-comment">/* Add or subtract samples to get a better sync, return new
   audio buffer size */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">synchronize_audio</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">short</span> *samples,
		      <span class="hljs-keyword">int</span> samples_size, <span class="hljs-keyword">double</span> pts)</span> </span>{
  <span class="hljs-keyword">int</span> n;
  <span class="hljs-keyword">double</span> ref_clock;<font></font>
<font></font>
  n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER) {
    <span class="hljs-keyword">double</span> diff, avg_diff;
    <span class="hljs-keyword">int</span> wanted_size, min_size, max_size <span class="hljs-comment">/*, nb_samples */</span>;<font></font>
    <font></font>
    ref_clock = get_master_clock(is);<font></font>
    diff = get_audio_clock(is) - ref_clock;<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(diff &lt; AV_NOSYNC_THRESHOLD) {
      <span class="hljs-comment">// accumulate the diffs</span><font></font>
      is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef<font></font>
	* is-&gt;audio_diff_cum;<font></font>
      <span class="hljs-keyword">if</span>(is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB) {<font></font>
	is-&gt;audio_diff_avg_count++;<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	avg_diff = is-&gt;audio_diff_cum * (<span class="hljs-number">1.0</span> - is-&gt;audio_diff_avg_coef);
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(avg_diff) &gt;= is-&gt;audio_diff_threshold) {<font></font>
	  wanted_size = samples_size + ((<span class="hljs-keyword">int</span>)(diff * is-&gt;audio_ctx-&gt;sample_rate) * n);<font></font>
	  min_size = samples_size * ((<span class="hljs-number">100</span> - SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);<font></font>
	  max_size = samples_size * ((<span class="hljs-number">100</span> + SAMPLE_CORRECTION_PERCENT_MAX) / <span class="hljs-number">100</span>);
	  <span class="hljs-keyword">if</span>(wanted_size &lt; min_size) {<font></font>
	    wanted_size = min_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (wanted_size &gt; max_size) {<font></font>
	    wanted_size = max_size;<font></font>
	  }<font></font>
	  <span class="hljs-keyword">if</span>(wanted_size &lt; samples_size) {
	    <span class="hljs-comment">/* remove samples */</span><font></font>
	    samples_size = wanted_size;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wanted_size &gt; samples_size) {
	    <span class="hljs-keyword">uint8_t</span> *samples_end, *q;
	    <span class="hljs-keyword">int</span> nb;<font></font>
<font></font>
	    <span class="hljs-comment">/* add samples by copying final sample*/</span><font></font>
	    nb = (samples_size - wanted_size);<font></font>
	    samples_end = (<span class="hljs-keyword">uint8_t</span> *)samples + samples_size - n;<font></font>
	    q = samples_end + n;<font></font>
	    <span class="hljs-keyword">while</span>(nb &gt; <span class="hljs-number">0</span>) {
	      <span class="hljs-built_in">memcpy</span>(q, samples_end, n);<font></font>
	      q += n;<font></font>
	      nb -= n;<font></font>
	    }<font></font>
	    samples_size = wanted_size;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">/* difference is TOO big; reset diff stuff */</span>
      is-&gt;audio_diff_avg_count = <span class="hljs-number">0</span>;<font></font>
      is-&gt;audio_diff_cum = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> samples_size;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">audio_decode_frame</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">uint8_t</span> *audio_buf, <span class="hljs-keyword">int</span> buf_size, <span class="hljs-keyword">double</span> *pts_ptr)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">int</span> len1, data_size = <span class="hljs-number">0</span>;<font></font>
  AVPacket *pkt = &amp;is-&gt;audio_pkt;<font></font>
  <span class="hljs-keyword">double</span> pts;
  <span class="hljs-keyword">int</span> n;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">while</span>(is-&gt;audio_pkt_size &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">int</span> got_frame = <span class="hljs-number">0</span>;<font></font>
      len1 = avcodec_decode_audio4(is-&gt;audio_ctx, &amp;is-&gt;audio_frame, &amp;got_frame, pkt);<font></font>
      <span class="hljs-keyword">if</span>(len1 &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* if error, skip frame */</span>
	is-&gt;audio_pkt_size = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      data_size = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">if</span>(got_frame) {<font></font>
	data_size = av_samples_get_buffer_size(<span class="hljs-literal">NULL</span>, <font></font>
					       is-&gt;audio_ctx-&gt;channels,<font></font>
					       is-&gt;audio_frame.nb_samples,<font></font>
					       is-&gt;audio_ctx-&gt;sample_fmt,<font></font>
					       <span class="hljs-number">1</span>);<font></font>
	assert(data_size &lt;= buf_size);<font></font>
	<span class="hljs-built_in">memcpy</span>(audio_buf, is-&gt;audio_frame.data[<span class="hljs-number">0</span>], data_size);<font></font>
      }<font></font>
      is-&gt;audio_pkt_data += len1;<font></font>
      is-&gt;audio_pkt_size -= len1;<font></font>
      <span class="hljs-keyword">if</span>(data_size &lt;= <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* No data yet, get more frames */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      }<font></font>
      pts = is-&gt;audio_clock;<font></font>
      *pts_ptr = pts;<font></font>
      n = <span class="hljs-number">2</span> * is-&gt;audio_ctx-&gt;channels;<font></font>
      is-&gt;audio_clock += (<span class="hljs-keyword">double</span>)data_size /<font></font>
	(<span class="hljs-keyword">double</span>)(n * is-&gt;audio_ctx-&gt;sample_rate);
      <span class="hljs-comment">/* We have data, return it and come back for more later */</span>
      <span class="hljs-keyword">return</span> data_size;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data)<font></font>
      av_free_packet(pkt);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">/* next packet */</span>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_ctx);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    is-&gt;audio_pkt_data = pkt-&gt;data;<font></font>
    is-&gt;audio_pkt_size = pkt-&gt;size;<font></font>
    <span class="hljs-comment">/* if update, update the audio clock w/pts */</span>
    <span class="hljs-keyword">if</span>(pkt-&gt;pts != AV_NOPTS_VALUE) {<font></font>
      is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base)*pkt-&gt;pts;<font></font>
    }<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">audio_callback</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata, Uint8 *stream, <span class="hljs-keyword">int</span> len)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  <span class="hljs-keyword">int</span> len1, audio_size;
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  <span class="hljs-keyword">while</span>(len &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">if</span>(is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) {
      <span class="hljs-comment">/* We have already sent all our data; get more */</span>
      audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);
      <span class="hljs-keyword">if</span>(audio_size &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-comment">/* If error, output silence */</span>
	is-&gt;audio_buf_size = <span class="hljs-number">1024</span>;
	<span class="hljs-built_in">memset</span>(is-&gt;audio_buf, <span class="hljs-number">0</span>, is-&gt;audio_buf_size);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
	audio_size = synchronize_audio(is, (<span class="hljs-keyword">int16_t</span> *)is-&gt;audio_buf,<font></font>
				       audio_size, pts);<font></font>
	is-&gt;audio_buf_size = audio_size;<font></font>
      }<font></font>
      is-&gt;audio_buf_index = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;<font></font>
    <span class="hljs-keyword">if</span>(len1 &gt; len)<font></font>
      len1 = len;<font></font>
    <span class="hljs-built_in">memcpy</span>(stream, (<span class="hljs-keyword">uint8_t</span> *)is-&gt;audio_buf + is-&gt;audio_buf_index, len1);<font></font>
    len -= len1;<font></font>
    stream += len1;<font></font>
    is-&gt;audio_buf_index += len1;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">static</span> Uint32 <span class="hljs-title">sdl_refresh_timer_cb</span><span class="hljs-params">(Uint32 interval, <span class="hljs-keyword">void</span> *opaque)</span> </span>{<font></font>
  SDL_Event event;<font></font>
  event.type = FF_REFRESH_EVENT;<font></font>
  event.user.data1 = opaque;<font></font>
  SDL_PushEvent(&amp;event);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 0 means stop timer */</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">/* schedule a video refresh in 'delay' ms */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">schedule_refresh</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> delay)</span> </span>{<font></font>
  SDL_AddTimer(delay, sdl_refresh_timer_cb, is);<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_display</span><span class="hljs-params">(VideoState *is)</span> </span>{<font></font>
<font></font>
  SDL_Rect rect;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">float</span> aspect_ratio;
  <span class="hljs-keyword">int</span> w, h, x, y;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-keyword">if</span>(is-&gt;video_ctx-&gt;sample_aspect_ratio.num == <span class="hljs-number">0</span>) {<font></font>
      aspect_ratio = <span class="hljs-number">0</span>;<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      aspect_ratio = av_q2d(is-&gt;video_ctx-&gt;sample_aspect_ratio) *<font></font>
	is-&gt;video_ctx-&gt;width / is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(aspect_ratio &lt;= <span class="hljs-number">0.0</span>) {<font></font>
      aspect_ratio = (<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;width /<font></font>
	(<span class="hljs-keyword">float</span>)is-&gt;video_ctx-&gt;height;<font></font>
    }<font></font>
    h = screen-&gt;h;<font></font>
    w = ((<span class="hljs-keyword">int</span>)rint(h * aspect_ratio)) &amp; <span class="hljs-number">-3</span>;
    <span class="hljs-keyword">if</span>(w &gt; screen-&gt;w) {<font></font>
      w = screen-&gt;w;<font></font>
      h = ((<span class="hljs-keyword">int</span>)rint(w / aspect_ratio)) &amp; <span class="hljs-number">-3</span>;<font></font>
    }<font></font>
    x = (screen-&gt;w - w) / <span class="hljs-number">2</span>;<font></font>
    y = (screen-&gt;h - h) / <span class="hljs-number">2</span>;<font></font>
    <font></font>
    rect.x = x;<font></font>
    rect.y = y;<font></font>
    rect.w = w;<font></font>
    rect.h = h;<font></font>
    SDL_LockMutex(screen_mutex);<font></font>
    SDL_DisplayYUVOverlay(vp-&gt;bmp, &amp;rect);<font></font>
    SDL_UnlockMutex(screen_mutex);<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">video_refresh_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(is-&gt;video_st) {
    <span class="hljs-keyword">if</span>(is-&gt;pictq_size == <span class="hljs-number">0</span>) {<font></font>
      schedule_refresh(is, <span class="hljs-number">1</span>);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];<font></font>
      <font></font>
      is-&gt;video_current_pts = vp-&gt;pts;<font></font>
      is-&gt;video_current_pts_time = av_gettime();<font></font>
      delay = vp-&gt;pts - is-&gt;frame_last_pts; <span class="hljs-comment">/* the pts from last time */</span>
      <span class="hljs-keyword">if</span>(delay &lt;= <span class="hljs-number">0</span> || delay &gt;= <span class="hljs-number">1.0</span>) {
	<span class="hljs-comment">/* if incorrect delay, use previous one */</span><font></font>
	delay = is-&gt;frame_last_delay;<font></font>
      }<font></font>
      <span class="hljs-comment">/* save for next time */</span><font></font>
      is-&gt;frame_last_delay = delay;<font></font>
      is-&gt;frame_last_pts = vp-&gt;pts;<font></font>
<font></font>
<font></font>
<font></font>
      <span class="hljs-comment">/* update delay to sync to audio if not master source */</span>
      <span class="hljs-keyword">if</span>(is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER) {<font></font>
	ref_clock = get_master_clock(is);<font></font>
	diff = vp-&gt;pts - ref_clock;<font></font>
	<font></font>
	<span class="hljs-comment">/* Skip or repeat the frame. Take delay into account
	   FFPlay still doesn't "know if this is the best guess." */</span><font></font>
	sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;<font></font>
	<span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) {
	  <span class="hljs-keyword">if</span>(diff &lt;= -sync_threshold) {<font></font>
	    delay = <span class="hljs-number">0</span>;<font></font>
	  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(diff &gt;= sync_threshold) {<font></font>
	    delay = <span class="hljs-number">2</span> * delay;<font></font>
	  }<font></font>
	}<font></font>
      }<font></font>
      is-&gt;frame_timer += delay;<font></font>
      <span class="hljs-comment">/* computer the REAL delay */</span>
      actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="hljs-number">1000000.0</span>);
      <span class="hljs-keyword">if</span>(actual_delay &lt; <span class="hljs-number">0.010</span>) {
	<span class="hljs-comment">/* Really it should skip the picture instead */</span>
	actual_delay = <span class="hljs-number">0.010</span>;<font></font>
      }<font></font>
      schedule_refresh(is, (<span class="hljs-keyword">int</span>)(actual_delay * <span class="hljs-number">1000</span> + <span class="hljs-number">0.5</span>));<font></font>
      <font></font>
      <span class="hljs-comment">/* show the picture! */</span><font></font>
      video_display(is);<font></font>
      <font></font>
      <span class="hljs-comment">/* update queue for next picture! */</span>
      <span class="hljs-keyword">if</span>(++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
	is-&gt;pictq_rindex = <span class="hljs-number">0</span>;<font></font>
      }<font></font>
      SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
      is-&gt;pictq_size--;<font></font>
      SDL_CondSignal(is-&gt;pictq_cond);<font></font>
      SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
    }<font></font>
  } <span class="hljs-keyword">else</span> {<font></font>
    schedule_refresh(is, <span class="hljs-number">100</span>);<font></font>
  }<font></font>
}<font></font>
      <font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">alloc_picture</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *userdata)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)userdata;<font></font>
  VideoPicture *vp;<font></font>
<font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {
    <span class="hljs-comment">// we already have one make another, bigger/smaller</span><font></font>
    SDL_FreeYUVOverlay(vp-&gt;bmp);<font></font>
  }<font></font>
  <span class="hljs-comment">// Allocate a place to put our YUV image on that screen</span><font></font>
  SDL_LockMutex(screen_mutex);<font></font>
  vp-&gt;bmp = SDL_CreateYUVOverlay(is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height,<font></font>
				 SDL_YV12_OVERLAY,<font></font>
				 screen);<font></font>
  SDL_UnlockMutex(screen_mutex);<font></font>
<font></font>
  vp-&gt;width = is-&gt;video_ctx-&gt;width;<font></font>
  vp-&gt;height = is-&gt;video_ctx-&gt;height;<font></font>
  vp-&gt;allocated = <span class="hljs-number">1</span>;<font></font>
<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">queue_picture</span><span class="hljs-params">(VideoState *is, AVFrame *pFrame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  VideoPicture *vp;<font></font>
  <span class="hljs-keyword">int</span> dst_pix_fmt;<font></font>
  AVPicture pict;<font></font>
<font></font>
  <span class="hljs-comment">/* wait until we have space for a new pic */</span><font></font>
  SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
  <span class="hljs-keyword">while</span>(is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp;<font></font>
	!is-&gt;quit) {<font></font>
    SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);<font></font>
  }<font></font>
  SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;quit)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
<font></font>
  <span class="hljs-comment">// windex is set to 0 initially</span><font></font>
  vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];<font></font>
<font></font>
  <span class="hljs-comment">/* allocate or resize the buffer! */</span>
  <span class="hljs-keyword">if</span>(!vp-&gt;bmp ||<font></font>
     vp-&gt;width != is-&gt;video_ctx-&gt;width ||<font></font>
     vp-&gt;height != is-&gt;video_ctx-&gt;height) {<font></font>
    SDL_Event event;<font></font>
<font></font>
    vp-&gt;allocated = <span class="hljs-number">0</span>;<font></font>
    alloc_picture(is);<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* We have a place to put our picture on the queue */</span><font></font>
<font></font>
  <span class="hljs-keyword">if</span>(vp-&gt;bmp) {<font></font>
<font></font>
    SDL_LockYUVOverlay(vp-&gt;bmp);<font></font>
    vp-&gt;pts = pts;<font></font>
    <font></font>
    dst_pix_fmt = PIX_FMT_YUV420P;<font></font>
    <span class="hljs-comment">/* point pict at the queue */</span><font></font>
<font></font>
    pict.data[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">0</span>];<font></font>
    pict.data[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">2</span>];<font></font>
    pict.data[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pixels[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    pict.linesize[<span class="hljs-number">0</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">0</span>];<font></font>
    pict.linesize[<span class="hljs-number">1</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">2</span>];<font></font>
    pict.linesize[<span class="hljs-number">2</span>] = vp-&gt;bmp-&gt;pitches[<span class="hljs-number">1</span>];<font></font>
    <font></font>
    <span class="hljs-comment">// Convert the image into YUV format that SDL uses</span>
    sws_scale(is-&gt;sws_ctx, (<span class="hljs-keyword">uint8_t</span> <span class="hljs-keyword">const</span> * <span class="hljs-keyword">const</span> *)pFrame-&gt;data,<font></font>
	      pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_ctx-&gt;height,<font></font>
	      pict.data, pict.linesize);<font></font>
    <font></font>
    SDL_UnlockYUVOverlay(vp-&gt;bmp);<font></font>
    <span class="hljs-comment">/* now we inform our display thread that we have a pic ready */</span>
    <span class="hljs-keyword">if</span>(++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE) {<font></font>
      is-&gt;pictq_windex = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    SDL_LockMutex(is-&gt;pictq_mutex);<font></font>
    is-&gt;pictq_size++;<font></font>
    SDL_UnlockMutex(is-&gt;pictq_mutex);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">synchronize_video</span><span class="hljs-params">(VideoState *is, AVFrame *src_frame, <span class="hljs-keyword">double</span> pts)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">double</span> frame_delay;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(pts != <span class="hljs-number">0</span>) {
    <span class="hljs-comment">/* if we have pts, set video clock to it */</span><font></font>
    is-&gt;video_clock = pts;<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* if we aren't given a pts, set it to the clock */</span><font></font>
    pts = is-&gt;video_clock;<font></font>
  }<font></font>
  <span class="hljs-comment">/* update the video clock */</span><font></font>
  frame_delay = av_q2d(is-&gt;video_ctx-&gt;time_base);<font></font>
  <span class="hljs-comment">/* if we are repeating a frame, adjust clock accordingly */</span>
  frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="hljs-number">0.5</span>);<font></font>
  is-&gt;video_clock += frame_delay;<font></font>
  <span class="hljs-keyword">return</span> pts;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">video_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
  <span class="hljs-keyword">int</span> frameFinished;<font></font>
  AVFrame *pFrame;<font></font>
  <span class="hljs-keyword">double</span> pts;<font></font>
<font></font>
  pFrame = av_frame_alloc();<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;videoq, packet, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// means we quit getting packets</span>
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    pts = <span class="hljs-number">0</span>;<font></font>
<font></font>
    <span class="hljs-comment">// Decode video frame</span><font></font>
    avcodec_decode_video2(is-&gt;video_ctx, pFrame, &amp;frameFinished, packet);<font></font>
<font></font>
    <span class="hljs-keyword">if</span>((pts = av_frame_get_best_effort_timestamp(pFrame)) == AV_NOPTS_VALUE) {<font></font>
      pts = av_frame_get_best_effort_timestamp(pFrame);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      pts = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
    pts *= av_q2d(is-&gt;video_st-&gt;time_base);<font></font>
<font></font>
    <span class="hljs-comment">// Did we get a video frame?</span>
    <span class="hljs-keyword">if</span>(frameFinished) {<font></font>
      pts = synchronize_video(is, pFrame, pts);<font></font>
      <span class="hljs-keyword">if</span>(queue_picture(is, pFrame, pts) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    av_free_packet(packet);<font></font>
  }<font></font>
  av_frame_free(&amp;pFrame);<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stream_component_open</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int</span> stream_index)</span> </span>{<font></font>
<font></font>
  AVFormatContext *pFormatCtx = is-&gt;pFormatCtx;<font></font>
  AVCodecContext *codecCtx = <span class="hljs-literal">NULL</span>;<font></font>
  AVCodec *codec = <span class="hljs-literal">NULL</span>;<font></font>
  SDL_AudioSpec wanted_spec, spec;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index &lt; <span class="hljs-number">0</span> || stream_index &gt;= pFormatCtx-&gt;nb_streams) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codec = avcodec_find_decoder(pFormatCtx-&gt;streams[stream_index]-&gt;codec-&gt;codec_id);<font></font>
  <span class="hljs-keyword">if</span>(!codec) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  codecCtx = avcodec_alloc_context3(codec);<font></font>
  <span class="hljs-keyword">if</span>(avcodec_copy_context(codecCtx, pFormatCtx-&gt;streams[stream_index]-&gt;codec) != <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Couldn't copy codec context"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Error copying codec context</span><font></font>
  }<font></font>
<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(codecCtx-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
    <span class="hljs-comment">// Set audio settings from codec info</span><font></font>
    wanted_spec.freq = codecCtx-&gt;sample_rate;<font></font>
    wanted_spec.format = AUDIO_S16SYS;<font></font>
    wanted_spec.channels = codecCtx-&gt;channels;<font></font>
    wanted_spec.silence = <span class="hljs-number">0</span>;<font></font>
    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;<font></font>
    wanted_spec.callback = audio_callback;<font></font>
    wanted_spec.userdata = is;<font></font>
    <font></font>
    <span class="hljs-keyword">if</span>(SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL_OpenAudio: %s\n"</span>, SDL_GetError());
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    is-&gt;audio_hw_buf_size = spec.size;<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(avcodec_open2(codecCtx, codec, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Unsupported codec!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-keyword">switch</span>(codecCtx-&gt;codec_type) {
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_AUDIO:<font></font>
    is-&gt;audioStream = stream_index;<font></font>
    is-&gt;audio_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;audio_ctx = codecCtx;<font></font>
    is-&gt;audio_buf_size = <span class="hljs-number">0</span>;<font></font>
    is-&gt;audio_buf_index = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(&amp;is-&gt;audio_pkt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(is-&gt;audio_pkt));<font></font>
    packet_queue_init(&amp;is-&gt;audioq);<font></font>
    SDL_PauseAudio(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">case</span> AVMEDIA_TYPE_VIDEO:<font></font>
    is-&gt;videoStream = stream_index;<font></font>
    is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];<font></font>
    is-&gt;video_ctx = codecCtx;<font></font>
<font></font>
    is-&gt;frame_timer = (<span class="hljs-keyword">double</span>)av_gettime() / <span class="hljs-number">1000000.0</span>;<font></font>
    is-&gt;frame_last_delay = <span class="hljs-number">40e-3</span>;<font></font>
    is-&gt;video_current_pts_time = av_gettime();<font></font>
<font></font>
    packet_queue_init(&amp;is-&gt;videoq);<font></font>
    is-&gt;video_tid = SDL_CreateThread(video_thread, is);<font></font>
    is-&gt;sws_ctx = sws_getContext(is-&gt;video_ctx-&gt;width, is-&gt;video_ctx-&gt;height,<font></font>
				 is-&gt;video_ctx-&gt;pix_fmt, is-&gt;video_ctx-&gt;width,<font></font>
				 is-&gt;video_ctx-&gt;height, PIX_FMT_YUV420P,<font></font>
				 SWS_BILINEAR, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span><font></font>
				 );<font></font>
    <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span>:
    <span class="hljs-keyword">break</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">decode_thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span> </span>{<font></font>
<font></font>
  VideoState *is = (VideoState *)arg;<font></font>
  AVFormatContext *pFormatCtx;<font></font>
  AVPacket pkt1, *packet = &amp;pkt1;<font></font>
<font></font>
  <span class="hljs-keyword">int</span> video_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> audio_index = <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int</span> i;<font></font>
<font></font>
  is-&gt;videoStream=<span class="hljs-number">-1</span>;<font></font>
  is-&gt;audioStream=<span class="hljs-number">-1</span>;<font></font>
<font></font>
  global_video_state = is;<font></font>
<font></font>
  <span class="hljs-comment">// Open video file</span>
  <span class="hljs-keyword">if</span>(avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't open file</span><font></font>
<font></font>
  is-&gt;pFormatCtx = pFormatCtx;<font></font>
  <font></font>
  <span class="hljs-comment">// Retrieve stream information</span>
  <span class="hljs-keyword">if</span>(avformat_find_stream_info(pFormatCtx, <span class="hljs-literal">NULL</span>)&lt;<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Couldn't find stream information</span><font></font>
  <font></font>
  <span class="hljs-comment">// Dump information about file onto standard error</span>
  av_dump_format(pFormatCtx, <span class="hljs-number">0</span>, is-&gt;filename, <span class="hljs-number">0</span>);<font></font>
  <font></font>
  <span class="hljs-comment">// Find the first video stream</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;pFormatCtx-&gt;nb_streams; i++) {
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO &amp;&amp;<font></font>
       video_index &lt; <span class="hljs-number">0</span>) {<font></font>
      video_index=i;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_AUDIO &amp;&amp;<font></font>
       audio_index &lt; <span class="hljs-number">0</span>) {<font></font>
      audio_index=i;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(audio_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, audio_index);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(video_index &gt;= <span class="hljs-number">0</span>) {<font></font>
    stream_component_open(is, video_index);<font></font>
  }   <font></font>
<font></font>
  <span class="hljs-keyword">if</span>(is-&gt;videoStream &lt; <span class="hljs-number">0</span> || is-&gt;audioStream &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: could not open codecs\n"</span>, is-&gt;filename);
    <span class="hljs-keyword">goto</span> fail;<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// main decode loop</span><font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">if</span>(is-&gt;quit) {
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
    <span class="hljs-comment">// seek stuff goes here</span>
    <span class="hljs-keyword">if</span>(is-&gt;seek_req) {
      <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
      <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
      <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
	seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
				  pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
      }<font></font>
      <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
		       seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
	<span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
		is-&gt;pFormatCtx-&gt;filename);<font></font>
      } <span class="hljs-keyword">else</span> {<font></font>
<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;audioq);<font></font>
	  packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
	}<font></font>
	<span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
	  packet_queue_flush(&amp;is-&gt;videoq);<font></font>
	  packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
	}<font></font>
      }<font></font>
      is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE ||<font></font>
       is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE) {<font></font>
      SDL_Delay(<span class="hljs-number">10</span>);
      <span class="hljs-keyword">continue</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">if</span>(is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="hljs-number">0</span>) {<font></font>
	SDL_Delay(<span class="hljs-number">100</span>); <span class="hljs-comment">/* no error; wait for user input */</span>
	<span class="hljs-keyword">continue</span>;<font></font>
      } <span class="hljs-keyword">else</span> {
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
    }<font></font>
    <span class="hljs-comment">// Is this a packet from the video stream?</span>
    <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;videoStream) {<font></font>
      packet_queue_put(&amp;is-&gt;videoq, packet);<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(packet-&gt;stream_index == is-&gt;audioStream) {<font></font>
      packet_queue_put(&amp;is-&gt;audioq, packet);<font></font>
    } <span class="hljs-keyword">else</span> {<font></font>
      av_free_packet(packet);<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-comment">/* all done - wait for it */</span>
  <span class="hljs-keyword">while</span>(!is-&gt;quit) {<font></font>
    SDL_Delay(<span class="hljs-number">100</span>);<font></font>
  }<font></font>
<font></font>
 fail:<font></font>
  <span class="hljs-keyword">if</span>(<span class="hljs-number">1</span>){<font></font>
    SDL_Event event;<font></font>
    event.type = FF_QUIT_EVENT;<font></font>
    event.user.data1 = is;<font></font>
    SDL_PushEvent(&amp;event);<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>{<font></font>
<font></font>
  SDL_Event       event;<font></font>
<font></font>
  VideoState      *is;<font></font>
<font></font>
  is = av_mallocz(<span class="hljs-keyword">sizeof</span>(VideoState));<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Usage: test &lt;file&gt;\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
  <span class="hljs-comment">// Register all formats and codecs</span><font></font>
  av_register_all();<font></font>
  <font></font>
  <span class="hljs-keyword">if</span>(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  <span class="hljs-comment">// Make a screen to put our video</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> __DARWIN__</span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>
        screen = SDL_SetVideoMode(<span class="hljs-number">640</span>, <span class="hljs-number">480</span>, <span class="hljs-number">24</span>, <span class="hljs-number">0</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
  <span class="hljs-keyword">if</span>(!screen) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"SDL: could not set video mode - exiting\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<font></font>
  }<font></font>
<font></font>
  screen_mutex = SDL_CreateMutex();<font></font>
<font></font>
  av_strlcpy(is-&gt;filename, argv[<span class="hljs-number">1</span>], <span class="hljs-keyword">sizeof</span>(is-&gt;filename));<font></font>
<font></font>
  is-&gt;pictq_mutex = SDL_CreateMutex();<font></font>
  is-&gt;pictq_cond = SDL_CreateCond();<font></font>
<font></font>
  schedule_refresh(is, <span class="hljs-number">40</span>);<font></font>
<font></font>
  is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;<font></font>
  is-&gt;parse_tid = SDL_CreateThread(decode_thread, is);<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;parse_tid) {<font></font>
    av_free(is);<font></font>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }<font></font>
<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
<font></font>
  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_QUIT_EVENT:
    <span class="hljs-keyword">case</span> SDL_QUIT:<font></font>
      is-&gt;quit = <span class="hljs-number">1</span>;
      <span class="hljs-comment">/*
       * If the video has finished playing, then both the picture and
       * audio queues are waiting for more data.  Make them stop
       * waiting and terminate normally.
       */</span><font></font>
      SDL_CondSignal(is-&gt;audioq.cond);<font></font>
      SDL_CondSignal(is-&gt;videoq.cond);<font></font>
      SDL_Quit();<font></font>
      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> FF_REFRESH_EVENT:<font></font>
      video_refresh_timer(event.user.data1);<font></font>
      <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
      <span class="hljs-keyword">break</span>;<font></font>
    }<font></font>
  }<font></font>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
<font></font>
}<font></font>
</code></pre></div>
                    </div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processamento de comandos de pesquisa</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos adicionar alguns recursos de pesquisa ao nosso player, porque √© realmente irritante quando voc√™ n√£o pode retroceder o filme. Al√©m disso, veremos como √© f√°cil usar a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos fazer as setas do teclado "esquerda" e "direita" rolar um pouco o filme para frente e para tr√°s, e as setas "para cima" e "para baixo" j√° s√£o mais significativas. "Um pouco" - ser√£o 10 segundos e "muito" - todos os 60. Portanto, precisamos configurar nosso loop principal para que ele intercepte eventos de pressionamento de tecla. Mas o fato √© que, quando pressionamos uma tecla, n√£o podemos chamar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diretamente. Isso deve ser feito em nosso loop de decodifica√ß√£o principal, </font><b><font style="vertical-align: inherit;">decode_thread</font></b><font style="vertical-align: inherit;"> loop</font></font><b><font style="vertical-align: inherit;"></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, em vez disso, adicionaremos alguns valores √† estrutura principal, que conter√£o uma nova posi√ß√£o para a pesquisa e alguns sinalizadores de pesquisa:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">int</span>             seek_req;
  <span class="hljs-keyword">int</span>             seek_flags;
  <span class="hljs-keyword">int64_t</span>         seek_pos;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora precisamos configurar nosso loop principal que captura as teclas:</font></font><br>
<br>
<pre><code class="cpp hljs">  <span class="hljs-keyword">for</span>(;;) {
    <span class="hljs-keyword">double</span> incr, pos;<font></font>
<font></font>
    SDL_WaitEvent(&amp;event);<font></font>
    <span class="hljs-keyword">switch</span>(event.type) {
    <span class="hljs-keyword">case</span> SDL_KEYDOWN:
      <span class="hljs-keyword">switch</span>(event.key.keysym.sym) {
      <span class="hljs-keyword">case</span> SDLK_LEFT:<font></font>
	incr = <span class="hljs-number">-10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_RIGHT:<font></font>
	incr = <span class="hljs-number">10.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_UP:<font></font>
	incr = <span class="hljs-number">60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;
      <span class="hljs-keyword">case</span> SDLK_DOWN:<font></font>
	incr = <span class="hljs-number">-60.0</span>;
	<span class="hljs-keyword">goto</span> do_seek;<font></font>
      do_seek:<font></font>
	<span class="hljs-keyword">if</span>(global_video_state) {<font></font>
	  pos = get_master_clock(global_video_state);<font></font>
	  pos += incr;<font></font>
	  stream_seek(global_video_state, <font></font>
                      (<span class="hljs-keyword">int64_t</span>)(pos * AV_TIME_BASE), incr);<font></font>
	}<font></font>
	<span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">default</span>:
	<span class="hljs-keyword">break</span>;<font></font>
      }<font></font>
      <span class="hljs-keyword">break</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para capturar um pressionamento de tecla, primeiro examinamos se o evento </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_KEYDOWN ocorreu</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em seguida, verificamos qual chave √© recebida usando </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.key.keysym.sym</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Assim que descobrimos em que dire√ß√£o estamos olhando, calculamos um novo tempo, adicionando um incremento ao valor da nossa nova fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">get_master_clock</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Em seguida, chamamos a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para definir os valores de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">search_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> etc. Converta nosso novo hor√°rio em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unidades de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> carimbo de data / hora internas da </font><b><font style="vertical-align: inherit;">avcodec</font></b><font style="vertical-align: inherit;"> . Lembre-se de que os registros de data e hora nos fluxos s√£o medidos em quadros, n√£o segundos, usando a seguinte f√≥rmula: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">segundos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadros</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fps</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por padr√£o, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec √©</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definido como 1.000.000 de quadros por segundo (portanto, uma posi√ß√£o de 2 segundos ter√° um carimbo de data / hora de 2.000.000). Por que precisamos converter esse valor - veja mais adiante. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√° nossa fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_seek</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Observe que definiremos o sinalizador se voltarmos:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stream_seek</span><span class="hljs-params">(VideoState *is, <span class="hljs-keyword">int64_t</span> pos, <span class="hljs-keyword">int</span> rel)</span> </span>{<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(!is-&gt;seek_req) {<font></font>
    is-&gt;seek_pos = pos;<font></font>
    is-&gt;seek_flags = rel &lt; <span class="hljs-number">0</span> ? AVSEEK_FLAG_BACKWARD : <span class="hljs-number">0</span>;<font></font>
    is-&gt;seek_req = <span class="hljs-number">1</span>;<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos para o nosso </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , onde realizamos uma pesquisa. Nos arquivos de origem, voc√™ pode ver que marcamos a √°rea "a pesquisa est√° em andamento". Bem, vamos coloc√°-lo l√° agora. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A pesquisa √© centrada na fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Essa fun√ß√£o usa como argumento o contexto de formato, fluxo, carimbo de data e hora e conjunto de sinalizadores. A fun√ß√£o procurar√° o carimbo de data / hora especificado. A unidade do registro de data e hora √© a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base do</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fluxo que voc√™ passa para a fun√ß√£o. No entanto, voc√™ n√£o precisa transmiti-lo ao fluxo (indicado pela passagem do valor -1). Se voc√™ fizer isso, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> estar√° na </font><b><font style="vertical-align: inherit;">unidade de</font></b><font style="vertical-align: inherit;"> tempo interna da </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ou 1000000fps. √â por isso que multiplicamos nossa posi√ß√£o por </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> quando definimos o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">search_pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, √†s vezes voc√™ pode (raramente) encontrar problemas para alguns arquivos se voc√™ passar </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - 1</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para o fluxo, portanto, vamos selecionar o primeiro fluxo em nosso arquivo e pass√°-lo para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_seek_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . N√£o esque√ßa que devemos alterar a escala do nosso carimbo de data e hora para estar no novo "sistema de coordenadas".</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">if</span>(is-&gt;seek_req) {
  <span class="hljs-keyword">int</span> stream_index= <span class="hljs-number">-1</span>;
  <span class="hljs-keyword">int64_t</span> seek_target = is-&gt;seek_pos;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>     (is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;videoStream;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) stream_index = is-&gt;audioStream;<font></font>
<font></font>
  <span class="hljs-keyword">if</span>(stream_index&gt;=<span class="hljs-number">0</span>){<font></font>
    seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q,<font></font>
                      pFormatCtx-&gt;streams[stream_index]-&gt;time_base);<font></font>
  }<font></font>
  <span class="hljs-keyword">if</span>(av_seek_frame(is-&gt;pFormatCtx, stream_index, <font></font>
                    seek_target, is-&gt;seek_flags) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"%s: error while seeking\n"</span>,<font></font>
            is-&gt;pFormatCtx-&gt;filename);<font></font>
  } <span class="hljs-keyword">else</span> {
     <span class="hljs-comment">/* handle packet queues... more later... */</span>
</code></pre><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_rescale_q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) √© uma fun√ß√£o que escala o registro de data e hora de uma base para outra. Ele basicamente calcula </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mas essa fun√ß√£o √© √∫til porque esse c√°lculo √†s vezes leva ao estouro. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© uma vers√£o fracion√°ria de </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Eles s√£o completamente diferentes: </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_in_seconds</font></font></b></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mas observe que </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AV_TIME_BASE_Q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√© realmente um objeto </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ent√£o voc√™ precisa usar fun√ß√µes </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">q</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especiais </font><font style="vertical-align: inherit;">no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para process√°-lo).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limpeza de Buffer</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, configuramos nossas pesquisas corretamente, mas ainda n√£o terminamos. Lembre-se, temos uma fila configurada para acumular pacotes? Agora que estamos com um carimbo de data e hora diferente, precisamos limpar essa fila, caso contr√°rio, a pesquisa no filme n√£o funcionar√°! Al√©m disso, o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> possui seus pr√≥prios buffers internos, que tamb√©m precisam ser liberados para cada fluxo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para fazer isso, voc√™ deve primeiro escrever uma fun√ß√£o que limpe nossa fila de pacotes. Ent√£o voc√™ precisa de alguma forma instruir o fluxo de √°udio e v√≠deo que eles limparam os buffers internos do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Podemos fazer isso colocando um pacote especial na fila ap√≥s a limpeza, e quando eles (threads) descobrem esse pacote especial, eles simplesmente limpam seus buffers.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos come√ßar com a fun√ß√£o de redefini√ß√£o. </font><font style="vertical-align: inherit;">√â realmente muito simples, ent√£o vou mostrar o c√≥digo:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">packet_queue_flush</span><span class="hljs-params">(PacketQueue *q)</span> </span>{<font></font>
  AVPacketList *pkt, *pkt1;<font></font>
<font></font>
  SDL_LockMutex(q-&gt;mutex);<font></font>
  <span class="hljs-keyword">for</span>(pkt = q-&gt;first_pkt; pkt != <span class="hljs-literal">NULL</span>; pkt = pkt1) {<font></font>
    pkt1 = pkt-&gt;next;<font></font>
    av_free_packet(&amp;pkt-&gt;pkt);<font></font>
    av_freep(&amp;pkt);<font></font>
  }<font></font>
  q-&gt;last_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;first_pkt = <span class="hljs-literal">NULL</span>;<font></font>
  q-&gt;nb_packets = <span class="hljs-number">0</span>;<font></font>
  q-&gt;size = <span class="hljs-number">0</span>;<font></font>
  SDL_UnlockMutex(q-&gt;mutex);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora que a fila est√° limpa, adicione nosso "pacote de limpeza". </font><font style="vertical-align: inherit;">Mas primeiro, seria bom definir o que √© e cri√°-lo:</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket flush_pkt;<font></font>
<font></font>
main() {<font></font>
  ...<font></font>
  av_init_packet(&amp;flush_pkt);<font></font>
  flush_pkt.data = <span class="hljs-string">"FLUSH"</span>;<font></font>
  ...<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora coloque este pacote na fila:</font></font><br>
<br>
<pre><code class="cpp hljs">  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span>(is-&gt;audioStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;audioq);<font></font>
      packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(is-&gt;videoStream &gt;= <span class="hljs-number">0</span>) {<font></font>
      packet_queue_flush(&amp;is-&gt;videoq);<font></font>
      packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);<font></font>
    }<font></font>
  }<font></font>
  is-&gt;seek_req = <span class="hljs-number">0</span>;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Esse trecho de c√≥digo continua o trecho de c√≥digo acima para </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">decode_thread</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .) Tamb√©m precisamos modificar </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_put</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> para n√£o duplicar um pacote especial para limpeza:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">packet_queue_put</span><span class="hljs-params">(PacketQueue *q, AVPacket *pkt)</span> </span>{<font></font>
<font></font>
  AVPacketList *pkt1;<font></font>
  <span class="hljs-keyword">if</span>(pkt != &amp;flush_pkt &amp;&amp; av_dup_packet(pkt) &lt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E ent√£o, no fluxo de √°udio e v√≠deo, colocamos essa chamada em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avcodec_flush_buffers</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> logo ap√≥s </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_queue_get</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">    <span class="hljs-keyword">if</span>(packet_queue_get(&amp;is-&gt;audioq, pkt, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<font></font>
    }<font></font>
    <span class="hljs-keyword">if</span>(pkt-&gt;data == flush_pkt.data) {<font></font>
      avcodec_flush_buffers(is-&gt;audio_st-&gt;codec);<font></font>
      <span class="hljs-keyword">continue</span>;<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O trecho de c√≥digo acima √© exatamente o mesmo para o fluxo de v√≠deo, com a substitui√ß√£o de "√°udio" por "v√≠deo". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
√â isso! </font><font style="vertical-align: inherit;">Conseguimos! </font><font style="vertical-align: inherit;">Compile seu player:</font></font><br>
<br>
<pre><code class="bash hljs">gcc -o tutorial07 tutorial07.c -lavutil -lavformat -lavcodec -lswscale -lz -lm \<font></font>
`sdl-config --cflags --libs`</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
e aproveite o seu reprodutor de filmes feito em menos de 1000 linhas de C! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Embora, √© claro, existam muitas coisas que podem ser adicionadas ou aprimoradas.</font></font><a name="epilogue"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Posf√°cio </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Li√ß√£o 7: Pesquisa"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üê </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚áë </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Ap√™ndice 1. Lista de Fun√ß√µes"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí</font></font></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ent√£o, temos um jogador que trabalha, mas √© claro que n√£o √© t√£o bom quanto poderia ser. </font><font style="vertical-align: inherit;">Seria poss√≠vel modificar o arquivo e adicionar muitas coisas √∫teis:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos ser sinceros, esse jogador √© p√©ssimo. </font><font style="vertical-align: inherit;">A vers√£o do ffplay.c na qual ela se baseia est√° completamente desatualizada e, como resultado, este tutorial precisa ser completamente revisado. </font><font style="vertical-align: inherit;">Se voc√™ deseja avan√ßar para projetos mais s√©rios usando as bibliotecas FFmpeg, recomendo fortemente que voc√™ verifique a vers√£o mais recente do ffplay.c como a pr√≥xima tarefa.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A manipula√ß√£o de erros em nosso c√≥digo √© terr√≠vel e pode ser implementada muito melhor.</font></font></li>
<li>      ,  ,   ,     .   ,    <b>paused</b>    ,   ,    .   ,    ,      .     <b>av_read_play</b>.   -   ,     .  ,    ,       . : ,     ffplay.c.</li>
<li> .</li>
<li> .       ,    ,      ,    ,   <b>VOB-</b>.</li>
<li> .   ,        .</li>
<li> .       .</li>
<li>  ,   ,  ,      ,   <b>YUV</b>,             <b>time_base</b>.</li>
<li> .</li>
<li>--,    ;  ffplay.c      .</li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se voc√™ quiser saber mais sobre o FFmpeg, aqui consideramos longe de tudo. O pr√≥ximo passo √© estudar a codifica√ß√£o multim√≠dia. √â melhor come√ßar com o arquivo </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">output_example.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que voc√™ encontrar√° na distribui√ß√£o FFmpeg. Eu poderia escrever outro livro sobre esse assunto, mas √© improv√°vel que supere este guia. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√° muito tempo, n√£o atualizei este texto, mas, enquanto isso, o mundo n√£o p√°ra. Este tutorial requer apenas atualiza√ß√µes simples da API; muito pouco mudou em termos de conceitos b√°sicos. A maioria dessas atualiza√ß√µes simplificou o c√≥digo. No entanto, embora eu tenha percorrido todo o c√≥digo e o atualizado, o FFplay ainda √© superior a este reprodutor de brinquedos. De cora√ß√£o, admitimos: nessas li√ß√µes, escrevemos um p√©ssimo reprodutor de filmes. Portanto, se hoje (ou no futuro) voc√™ deseja melhorar este tutorial, recomendo que voc√™ se familiarize com o FFplay e descubra o que est√° faltando. Acredito que isso se refira principalmente ao uso de equipamento de v√≠deo, mas, possivelmente, estou perdendo outras coisas √≥bvias. Talvez uma compara√ß√£o com o FFplay atual leve a uma reescrita radical de algumas coisas - eu ainda n√£o o assisti.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas estou muito orgulhoso de que, ao longo dos anos, meu trabalho tenha ajudado muito, mesmo levando em conta o fato de que as pessoas geralmente procuravam c√≥digo em outro lugar. </font><font style="vertical-align: inherit;">Sou imensamente grato a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chelyaev</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que assumiu a rotina de substituir todas as fun√ß√µes desatualizadas desde que escrevi essa monografia h√° 8 (!) Anos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Alegro-me na esperan√ßa de que essas li√ß√µes tenham sido √∫teis e n√£o chatas. </font><font style="vertical-align: inherit;">Se houver sugest√µes, erros, reclama√ß√µes, agradecimentos etc. em rela√ß√£o a este guia, escreva-me em dranger dog gmail dot com. </font><font style="vertical-align: inherit;">E sim, n√£o faz sentido pedir que eu ajude no seu projeto FFmpeg. </font><font style="vertical-align: inherit;">H√° </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamb√©m</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muitas </font><font style="vertical-align: inherit;">cartas semelhantes </font><font style="vertical-align: inherit;">.</font></font><a name="functions"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√™ndice 1. Lista de fun√ß√µes </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Posf√°cio"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üê </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚áë </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Ap√™ndice 2. Estruturas de Dados"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí</font></font></a></h2><br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avformat_open_input</span><span class="hljs-params">(AVFormatContext **ptr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * filename, AVInputFormat *fmt, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Abre o nome do arquivo de m√≠dia, salva o contexto do formato no endere√ßo especificado em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se n√£o for NULL, define o formato do arquivo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">buf_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho do buffer (opcional). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√ß√µes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVDictionary √© preenchido com os par√¢metros do </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVFormatContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e desmultiplexador.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avformat_close_input</span><span class="hljs-params">(AVFormatContext **s)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fecha o arquivo de m√≠dia. </font><font style="vertical-align: inherit;">No entanto, ele n√£o fecha os codecs.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">nt <span class="hljs-title">avio_open2</span> <span class="hljs-params">(AVIOContext **s, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *url, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">const</span> AVIOInterruptCB *int_cb, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cria um contexto de E / S para usar o recurso especificado na </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ponteiro para o local onde o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIOContext</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ser√° criado </font><font style="vertical-align: inherit;">. Em caso de falha, o valor especificado √© definido como NULL. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">url</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : nome do recurso a ser acessado. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : controla a abertura do recurso especificado no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">URL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int_cb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : interrompe o retorno de chamada para uso no n√≠vel do protocolo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">op√ß√µes</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um dicion√°rio preenchido com par√¢metros de protocolo privado. Quando a fun√ß√£o retornar, o par√¢metro ser√° destru√≠do e substitu√≠do por um ditado contendo op√ß√µes que n√£o foram encontradas. Pode ser NULL.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_dup_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, isso √© um hack: se este pacote n√£o foi alocado, n√≥s o publicamos aqui. </font><font style="vertical-align: inherit;">Retorna 0 em caso de sucesso ou AVERROR_NOMEM em falha.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_find_stream_info</span><span class="hljs-params">(AVFormatContext *s, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa fun√ß√£o procura informa√ß√µes de fluxo n√£o √≥bvias, como taxa de quadros. </font><font style="vertical-align: inherit;">Isso √© √∫til para formatos de arquivo sem cabe√ßalho, como MPEG. </font><font style="vertical-align: inherit;">√â recomend√°vel ligar depois de abrir o arquivo. </font><font style="vertical-align: inherit;">Retorna&gt; = 0 se for bem-sucedido, AVERROR_ * em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_free_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nome antigo para av_frame_free. </font><font style="vertical-align: inherit;">Alterado em lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_frame_free</span> <span class="hljs-params">(AVFrame **frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libera um quadro e quaisquer objetos alocados dinamicamente nele, por exemplo, extended_data.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libera mem√≥ria alocada usando av_malloc () ou av_realloc (). </font><font style="vertical-align: inherit;">Voc√™ pode chamar esta fun√ß√£o com ptr == NULL. </font><font style="vertical-align: inherit;">√â recomend√°vel que voc√™ chame av_freep ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_freep</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libera mem√≥ria e define o ponteiro para NULL. </font><font style="vertical-align: inherit;">Usa internamente av_free ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_free_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Envolva o m√©todo de destrui√ß√£o de pacotes (pkt-&gt; destruct).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_gettime</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obtenha a hora atual em microssegundos.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_init_packet</span><span class="hljs-params">(AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializando campos de pacote opcionais.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_malloc</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamanho de bytes de aloca√ß√£o de mem√≥ria com alinhamento adequado para todos os acessos √† mem√≥ria (incluindo vetores, se dispon√≠veis na CPU). </font><font style="vertical-align: inherit;">av_malloc (0) deve retornar um ponteiro diferente de zero.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">av_mallocz</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O mesmo que av_malloc (), mas inicializa a mem√≥ria para zero.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">av_q2d</span><span class="hljs-params">(AVRational a)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Duplas AVRational.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_read_frame</span><span class="hljs-params">(AVFormatContext *s, AVPacket *pkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna o pr√≥ximo quadro de fluxo. As informa√ß√µes s√£o armazenadas como um pacote na pkt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O pacote retornado √© v√°lido at√© o pr√≥ximo av_read_frame () ou at√© av_close_input_file () e deve ser liberado usando av_free_packet. Para um pacote de v√≠deo, cont√©m exatamente um quadro. Para √°udio, ele cont√©m um n√∫mero inteiro de quadros se cada quadro tiver um tamanho fixo conhecido (por exemplo, dados PCM ou ADPCM). Se os quadros de √°udio tiverem tamanho vari√°vel (por exemplo, √°udio MPEG), ele conter√° um quadro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pkt-&gt; pts, pkt-&gt; dts e pkt-&gt; duration s√£o sempre definidos com os valores corretos em unidades de AVStream.timebase (e sup√µe-se que o formato n√£o possa fornec√™-los). pkt-&gt; pts pode ser AV_NOPTS_VALUE se o formato de v√≠deo tiver quadros B, por isso √© melhor confiar em pkt-&gt; dts se voc√™ n√£o estiver descompactando a carga √∫til.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado retornado:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0, se estiver tudo bem, &lt;0, se houver um erro ou o final do arquivo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">av_register_all</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Registra todos os codecs na biblioteca.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_rescale_q</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> a, AVRational bq, AVRational cq)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">av_seek_frame</span><span class="hljs-params">(AVFormatContext *s, <span class="hljs-keyword">int</span> stream_index, <span class="hljs-keyword">int64_t</span> timestamp, <span class="hljs-keyword">int</span> flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Procura um quadro-chave em um carimbo de data / hora. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : se stream_index for -1, o fluxo padr√£o ser√° selecionado e o registro de data e hora ser√° automaticamente convertido de unidades AV_TIME_BASE em um time_base espec√≠fico do fluxo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : timestamp medido em unidades de AVStream.time_base ou, se nenhum fluxo for especificado, em unidades de AV_TIME_BASE. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinalizadores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : defina os par√¢metros relativos √† dire√ß√£o e modo de busca: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_ANY: procure em qualquer quadro, n√£o apenas nos principais. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BACKWARD: pesquise na dire√ß√£o oposta. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AVSEEK_FLAG_BYTE: pesquisa com base na posi√ß√£o em bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">avcodec_alloc_frame</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nome antigo para av_frame_alloc. </font><font style="vertical-align: inherit;">Alterado em lavc 55.28.1.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVFrame *<span class="hljs-title">av_frame_alloc</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seleciona um AVFrame e o inicializa. </font><font style="vertical-align: inherit;">Pode ser liberado usando av_frame_free ().</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_audio4</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *frame, <span class="hljs-keyword">int</span> *got_frame_ptr, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decodifica um quadro de √°udio de avpkt para quadro. A fun√ß√£o avcodec_decode_audio4 () decodifica um arquivo de √°udio do AVPacket. Para sua decodifica√ß√£o, √© usado um codec de √°udio, que foi associado ao avctx usando avcodec_open2 (). O quadro decodificado resultante √© armazenado no AVFrame especificado. Se o quadro tiver sido descompactado, ele definir√° got_frame_ptr como 1. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso: o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> buffer de entrada, avpkt-&gt; data, deve ser FF_INPUT_BUFFER_PADDING_SIZE maior que os bytes de leitura reais, porque alguns leitores de fluxo de bits otimizados leem 32 ou 64 bits por vez e podem ler at√© o fim. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contexto do codec. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quadro</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">quadro de</font></b><font style="vertical-align: inherit;"> destino. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">got_frame_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : target int, que ser√° definido se o quadro for descompactado. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPKT</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: AVPacket contendo √°udio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado retornado:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se um erro for retornado, um valor negativo ser√° retornado; caso contr√°rio, o n√∫mero de bytes usados ‚Äã‚Äãna entrada AVPacket ser√° retornado.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_decode_video2</span><span class="hljs-params">(AVCodecContext *avctx, AVFrame *picture, <span class="hljs-keyword">int</span> *frameFinished, <span class="hljs-keyword">const</span> AVPacket *avpkt)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Decodifica um quadro de v√≠deo de buf para uma imagem. A fun√ß√£o avcodec_decode_video2 () decodifica um quadro de v√≠deo a partir de um buffer de entrada do tamanho buf_size. Para sua decodifica√ß√£o, √© usado um codec de v√≠deo associado ao avctx usando avcodec_open2 (). O quadro decodificado resultante √© salvo na imagem. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aviso:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> exemplos de alinhamento e problemas de buffer que se aplicam a avcodec_decode_audio4 tamb√©m se aplicam a esta fun√ß√£o. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avctx</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : contexto do codec. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">picture</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : AVFrame no qual o v√≠deo decodificado ser√° salvo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frameFinished</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : zero se nenhum quadro puder ser descompactado, caso contr√°rio, n√£o ser√° igual a zero. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">avpkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: entrada AVPacket contendo buffer de entrada. </font><font style="vertical-align: inherit;">Voc√™ pode criar esse pacote usando av_init_packet () e, com dados e tamanho especificados, alguns decodificadores podem precisar adicionalmente de outros campos, como sinalizadores e AV_PKT_FLAG_KEY. </font><font style="vertical-align: inherit;">Todos os decodificadores s√£o projetados para usar o menor n√∫mero poss√≠vel de campos. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultado retornado:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Em caso de erro, um valor negativo √© retornado; caso contr√°rio, o n√∫mero de bytes √© usado ou zero se nenhum quadro puder ser descompactado.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">av_frame_get_best_effort_timestamp</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVFrame *frame)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um m√©todo de acesso simples para obter best_effort_timestamp a partir de um objeto AVFrame.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodec *<span class="hljs-title">avcodec_find_decoder</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> CodecID id)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Procura por um decodificador com CodecID. </font><font style="vertical-align: inherit;">Retorna NULL em erro. </font><font style="vertical-align: inherit;">Ele deve ser chamado depois de obter o AVCodecContext necess√°rio a partir do fluxo no AVFormatContext usando codecCtx-&gt; codec_id.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avcodec_flush_buffers</span><span class="hljs-params">(AVCodecContetx *avctx)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tamp√£o nivelado. </font><font style="vertical-align: inherit;">Chamado ao pesquisar ou alternar para outro fluxo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">AVCodecContext * <span class="hljs-title">avcodec_alloc_context3</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> AVCodec *codec)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Atribui AVCodecContext e define seus campos para os valores padr√£o.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_copy_context</span> <span class="hljs-params">(AVCodecContext *dest, <span class="hljs-keyword">const</span> AVCodecContext *src)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Copie as configura√ß√µes do AVCodecContext de origem no AVCodecContext de destino. </font><font style="vertical-align: inherit;">O contexto resultante do codec de destino ser√° fechado, ou seja, </font><font style="vertical-align: inherit;">voc√™ deve chamar avcodec_open2 () antes de usar este AVCodecContext para decodificar / codificar dados de v√≠deo / √°udio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dest</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : deve ser inicializado com avcodec_alloc_context3 (NULL), caso contr√°rio, n√£o ser√° inicializado.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avcodec_open2</span><span class="hljs-params">(AVCodecContext *avctx, AVCodec *codec, AVDictionary **options)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializa o avctx para usar o codec especificado no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Deve ser usado ap√≥s avcodec_find_decoder. </font><font style="vertical-align: inherit;">Retorna zero em caso de sucesso e um valor negativo em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_fill</span><span class="hljs-params">(AVPicture *picture, <span class="hljs-keyword">uint8_t</span> *ptr, <span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Define a estrutura para a qual a imagem aponta, com o buffer </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , o formato </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pix_fmt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e a largura e altura especificadas. </font><font style="vertical-align: inherit;">Retorna o tamanho dos dados da imagem em bytes.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">avpicture_get_size</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pix_fmt, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calcula quantos bytes s√£o necess√°rios para uma imagem de uma determinada largura, altura e formato de imagem.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct SwsContext* <span class="hljs-title">sws_getContext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> srcW, <span class="hljs-keyword">int</span> srcH, <span class="hljs-keyword">int</span> srcFormat, <span class="hljs-keyword">int</span> dstW, <span class="hljs-keyword">int</span> dstH, <span class="hljs-keyword">int</span> dstFormat, <span class="hljs-keyword">int</span> flags, SwsFilter *srcFilter, SwsFilter *dstFilter, <span class="hljs-keyword">double</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna SwsContext para uso em sws_scale. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largura, altura e formato dos pixels desejados. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstW</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstH</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largura, altura e formato dos pixels finais. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinalizadores</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o m√©todo de dimensionamento a ser usado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As seguintes op√ß√µes est√£o dispon√≠veis: SWS_FAST_BILINEAR, SWS_BILINEAR, SWS_BICUBIC, SWS_X, SWS_POINT, SWS_AREA, SWS_BICUBLIN, SWS_GAUSS, SWS_SINC, SWS_LANCZOS, SWS_SPLINE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outros sinalizadores incluem sinalizadores de capacidade da CPU: SWS_CPU_CAPS_MMX, SWS_CPU_CAPS_MMX2, SWS_CPU_CAPS_3DNOW, SWS_CPU_CAPS_ALTIVEC.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outros sinalizadores incluem (atualmente n√£o totalmente implementado) SWS_FULL_CHR_H_INT, SWS_FULL_CHR_H_INP e SWS_DIRECT_BGR. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por fim, h√° SWS_ACCURATE_RND e talvez o mais √∫til para iniciantes, SWS_PRINT_INFO. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N√£o tenho ideia do que a maioria deles faz. Talvez escreva para mim? </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : SwsFilter para origem e destino. O SwsFilter permite a filtragem de cores / brilho. O valor padr√£o √© NULL. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">param</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : deve ser um ponteiro para um buffer int [2] com coeficientes. N√£o documentado. Parece ser usado para modificar levemente os algoritmos de escala padr√£o. O valor padr√£o √© NULL. Somente para especialistas!</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sws_scale</span><span class="hljs-params">(SwsContext *c, <span class="hljs-keyword">uint8_t</span> *src, <span class="hljs-keyword">int</span> srcStride[], <span class="hljs-keyword">int</span> srcSliceY, <span class="hljs-keyword">int</span> srcSliceH, <span class="hljs-keyword">uint8_t</span> dst[], <span class="hljs-keyword">int</span> dstStride[]
sws_scale(sws_ctx, pFrame-&gt;data, pFrame-&gt;linesize, <span class="hljs-number">0</span>, is-&gt;video_st-&gt;codec-&gt;height, pict.data, pict.linesize);</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dimensiona os dados no </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">src de</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> acordo com nossas configura√ß√µes em nosso </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwsContext * c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">srcStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dstStride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> s√£o os tamanhos das linhas de origem e de destino.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_TimerID <span class="hljs-title">SDL_AddTimer</span><span class="hljs-params">(Uint32 interval, SDL_NewTimerCallback callback, <span class="hljs-keyword">void</span> *param)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adiciona uma fun√ß√£o de retorno de chamada que √© executada ap√≥s um n√∫mero especificado de milissegundos. A fun√ß√£o de retorno de chamada passa o intervalo atual do timer e o par√¢metro fornecido pelo usu√°rio da chamada SDL_AddTimer e retorna o pr√≥ximo intervalo do timer. (Se o valor de retorno do retorno de chamada corresponder ao valor passado, o cron√¥metro continuar√° funcionando na mesma velocidade.) Se o valor de retorno do retorno de chamada for 0, o cron√¥metro ser√° cancelado. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Outra maneira de cancelar o timer atual √© chamar SDL_RemoveTimer com o identificador de timer (retornado do SDL_AddTimer). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A fun√ß√£o de retorno de chamada do timer pode ser executada em um segmento diferente do seu programa principal e, portanto, n√£o deve chamar nenhuma fun√ß√£o por si mesma. No entanto, voc√™ sempre pode chamar SDL_PushEvent.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O grau de detalhe do cron√¥metro depende da plataforma, mas voc√™ deve esperar pelo menos 10 ms, pois esse √© o valor mais comum. </font><font style="vertical-align: inherit;">Isso significa que, se voc√™ solicitar um timer de 16 ms, o retorno de chamada ser√° iniciado ap√≥s cerca de 20 ms em um sistema descarregado. </font><font style="vertical-align: inherit;">Se voc√™ precisar definir um sinalizador que sinalize a atualiza√ß√£o de quadros a uma velocidade de 30 quadros por segundo (a cada 33 ms), poder√° definir um temporizador para 30 ms (veja o exemplo abaixo). </font><font style="vertical-align: inherit;">Se voc√™ usar esta fun√ß√£o, precisar√° passar SDL_INIT_TIMER para SDL_Init. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna o valor do identificador para o timer adicionado, ou NULL se ocorrer um erro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Formato para retorno de chamada:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-function">Uint32 <span class="hljs-title">callback</span> <span class="hljs-params">( Uint32, <span class="hljs-keyword">void</span> * param)</span></span></code></pre><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondSignal</span><span class="hljs-params">(SDL_cond *cond)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reiniciando um dos encadeamentos aguardando a vari√°vel de condi√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cond</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Retorna 0 em caso de sucesso e -1 em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_CondWait</span><span class="hljs-params">(SDL_cond *cond, SDL_mutex *mut)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desbloqueie o mutex fornecido e aguarde outro segmento chamar SDL_CondSignal ou SDL_CondBroadcast para a vari√°vel de condi√ß√£o cond e, em seguida, bloqueie novamente o mutex. </font><font style="vertical-align: inherit;">O mutex deve ser bloqueado antes de entrar nesta fun√ß√£o. </font><font style="vertical-align: inherit;">Retorna 0 quando um sinal √© recebido ou -1 em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_cond *<span class="hljs-title">SDL_CreateCond</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cria uma vari√°vel de condi√ß√£o.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Thread *<span class="hljs-title">SDL_CreateThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span> *), <span class="hljs-keyword">void</span> *data)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateThread cria um novo encadeamento de execu√ß√£o que compartilha toda a mem√≥ria global de seu pai, manipuladores de sinal, descritores de arquivo etc. </font><font style="vertical-align: inherit;">E executa a fun√ß√£o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fn</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , passando os dados do ponteiro nulo. </font><font style="vertical-align: inherit;">O encadeamento termina quando fn retorna um valor.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Delay</span> <span class="hljs-params">(Uint32 )</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aguarda o n√∫mero especificado de milissegundos. O SDL_Delay aguardar√° pelo menos o tempo especificado, mas possivelmente mais por causa do planejamento do SO. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nota:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> espere uma granularidade de atraso de pelo menos 10 ms. Algumas plataformas t√™m medidas mais curtas, mas esta √© a op√ß√£o mais comum.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Overlay *<span class="hljs-title">SDL_CreateYUVOverlay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, Uint32 format, SDL_Surface *display)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_CreateYUVOverlay cria uma sobreposi√ß√£o YUV da largura, altura e formato especificados (para obter uma lista dos formatos dispon√≠veis, consulte a estrutura de dados SDL_Overlay) para a exibi√ß√£o fornecida. </font><font style="vertical-align: inherit;">Retorna SDL_Overlay. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">display</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> deve ser uma superf√≠cie derivada de SDL_SetVideoMode, caso contr√°rio, essa fun√ß√£o funcionar√° por padr√£o. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O termo ‚Äúsobreposi√ß√£o‚Äù est√° incorreto, porque se a sobreposi√ß√£o n√£o for criada no hardware, o conte√∫do da superf√≠cie de exibi√ß√£o abaixo da √°rea em que a sobreposi√ß√£o √© exibida ser√° sobrescrito quando a sobreposi√ß√£o for exibida.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockYUVOverlay bloqueia a sobreposi√ß√£o para acesso direto aos dados de pixel. </font><font style="vertical-align: inherit;">Retorna 0 em caso de sucesso ou -1 em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_UnlockYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desbloqueia uma sobreposi√ß√£o bloqueada anteriormente. </font><font style="vertical-align: inherit;">A sobreposi√ß√£o deve ser desbloqueada antes de poder ser exibida.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_DisplayYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay, SDL_Rect *dstrect)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Coloca a sobreposi√ß√£o na superf√≠cie especificada quando foi criada. </font><font style="vertical-align: inherit;">A estrutura SDL_Rect dstrect define a posi√ß√£o e o tamanho do destino. </font><font style="vertical-align: inherit;">Se o dstrect tiver mais ou menos sobreposi√ß√£o, a sobreposi√ß√£o ser√° dimensionada; isso √© otimizado para 2x. </font><font style="vertical-align: inherit;">Retorna 0 se for bem-sucedido.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_FreeYUVOverlay</span><span class="hljs-params">(SDL_Overlay *overlay)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Libera a sobreposi√ß√£o criada por SDL_CreateYUVOverlay.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_Init</span><span class="hljs-params">(Uint32 flags)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicializa o SDL. Isso deve ser chamado antes de todas as outras fun√ß√µes SDL. O par√¢metro </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> especifica quais partes do SDL inicializar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_TIMER - inicializa o subsistema de timer. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_AUDIO - inicializa o subsistema de √°udio. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_VIDEO - inicializa o subsistema de v√≠deo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_CDROM - inicializa o subsistema de CD-ROM. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_JOYSTICK - inicializa o subsistema do joystick. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVERYTHING - Inicializa todas as op√ß√µes acima. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_NOPARACHUTE - n√£o permite que o SDL capture erros fatais. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_INIT_EVENTTHREAD - inicia o gerenciador de eventos em um encadeamento separado.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Retorna -1 com erro ou 0 com √™xito. </font><font style="vertical-align: inherit;">Voc√™ pode receber uma mensagem de erro estendida chamando SDL_GetError. </font><font style="vertical-align: inherit;">Uma causa t√≠pica de um erro √© o uso de uma exibi√ß√£o espec√≠fica sem o suporte correspondente para o subsistema, por exemplo, a aus√™ncia de um driver de mouse ao usar um buffer de quadro com o dispositivo. </font><font style="vertical-align: inherit;">Nesse caso, voc√™ pode compilar o SDL sem um mouse ou definir a vari√°vel de ambiente "SDL_NOMOUSE = 1" antes de iniciar o aplicativo.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_mutex *<span class="hljs-title">SDL_CreateMutex</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cria um novo mutex desbloqueado.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_LockMutex</span><span class="hljs-params">(SDL_mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_LockMutex √© um alias para SDL_mutexP. </font><font style="vertical-align: inherit;">Ele bloqueia um mutex que foi criado anteriormente usando SDL_CreateMutex. </font><font style="vertical-align: inherit;">Se o mutex j√° estiver bloqueado por outro encadeamento, o SDL_mutexP n√£o retornar√° um valor at√© que o encadeamento bloqueado por ele o desbloqueie (usando SDL_mutexV). </font><font style="vertical-align: inherit;">Quando o mutex √© chamado novamente, SDL_mutexV (tamb√©m conhecido como SDL_UnlockMutex) deve ser chamado um n√∫mero igual de vezes para retornar o mutex a um estado desbloqueado. </font><font style="vertical-align: inherit;">Retorna 0 em caso de sucesso ou -1 em caso de erro.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_UnlockMutex</span><span class="hljs-params">(SDL_Mutex *mutex)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desbloqueio Mutex.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_OpenAudio</span><span class="hljs-params">(SDL_AudioSpec *desired, SDL_AudioSpec *obtained)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta fun√ß√£o abre a unidade de √°udio com os par√¢metros necess√°rios e retorna 0 se for bem-sucedida, colocando os par√¢metros de hardware reais na estrutura para a qual finalmente aponta. Se um valor NULL for recebido, os dados de √°udio passados ‚Äã‚Äãpara a fun√ß√£o de retorno de chamada ter√£o o formato necess√°rio e, se necess√°rio, ser√£o convertidos automaticamente para o formato de √°udio do hardware. Esta fun√ß√£o retorna -1 se o dispositivo de √°udio n√£o puder ser aberto ou o fluxo de √°udio n√£o puder ser configurado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para abrir um dispositivo de √°udio, voc√™ precisa criar o SDL_AudioSpec desejado. Ent√£o voc√™ precisa preencher essa estrutura com as especifica√ß√µes de √°udio desejadas. </font><font style="vertical-align: inherit;">desejado- </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : frequ√™ncia sonora desejada em amostras por segundo. </font><font style="vertical-align: inherit;">desejado- </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; formato</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">formato de</font></b><font style="vertical-align: inherit;"> √°udio desejado (consulte SDL_AudioSpec). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Canais desejados</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Canais necess√°rios (1 para mono, 2 para est√©reo, 4 para som surround, 6 para som surround com centraliza√ß√£o e LFE). </font><font style="vertical-align: inherit;">desejado- </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">&gt; amostras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho do buffer de √°udio desejado nas amostras. Esse n√∫mero deve ter uma pot√™ncia de dois e pode ser ajustado pelo driver de √°udio para um valor mais adequado para o hardware. Os valores ideais variam de 512 a 8192, inclusive, dependendo da velocidade do aplicativo e do processador. Valores menores resultam em tempos de resposta mais r√°pidos, mas podem levar a um desempenho ruim se o aplicativo executar um processamento pesado e n√£o conseguir preencher o buffer de √°udio a tempo. A amostra est√©reo consiste nos canais direito e esquerdo na ordem LR. Observe que o n√∫mero de amostras est√° diretamente relacionado ao tempo usando a seguinte f√≥rmula: </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ms</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = (</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">amostras</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * 1000) / </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">desejado-&gt; retorno de chamada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : deve ser definido para uma fun√ß√£o que ser√° chamada quando a unidade de √°udio estiver pronta para receber dados adicionais. O ponteiro para o buffer de √°udio e o comprimento em bytes do buffer de √°udio s√£o transmitidos. Essa fun√ß√£o geralmente √© executada em um thread separado e, portanto, √© necess√°rio proteger as estruturas de dados acessadas chamando SDL_LockAudio e SDL_UnlockAudio no c√≥digo. O prot√≥tipo de retorno de chamada √© um </font></font><nobr><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorno de chamada nulo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint8</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stream</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font></nobr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - um ponteiro armazenado no campo userdata SDL_AudioSpec. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">corrente</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√â um ponteiro para o buffer de √°udio que voc√™ deseja preencher com informa√ß√µes e </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">len</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o tamanho do buffer de √°udio em bytes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">required-&gt; userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esse ponteiro √© passado como o primeiro par√¢metro para a fun√ß√£o de retorno de chamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio l√™ esses campos da estrutura SDL_AudioSpec desejada passada para a fun√ß√£o e tenta encontrar a configura√ß√£o de √°udio que corresponde ao seu desejo. Como mencionado acima, se o par√¢metro resultante for NULL, o SDL ser√° convertido das configura√ß√µes de som desejadas para as configura√ß√µes do equipamento durante a reprodu√ß√£o.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se NULL for retornado, o SDL_AudioSpec necess√°rio √© sua especifica√ß√£o de trabalho; caso contr√°rio, o SDL_AudioSpec resultante se tornar√° uma especifica√ß√£o de trabalho e a especifica√ß√£o desejada poder√° ser exclu√≠da. Os dados na especifica√ß√£o de trabalho s√£o usados ‚Äã‚Äãao criar o SDL_AudioCVT para converter os dados baixados no formato do equipamento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OpenAudio calcula os campos de tamanho e sil√™ncio para a especifica√ß√£o desejada e a resultante. O campo tamanho armazena o tamanho total do buffer de √°udio em bytes, enquanto o sil√™ncio armazena o valor usado para representar o sil√™ncio no buffer de √°udio</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O dispositivo de som come√ßa a tocar sil√™ncio quando est√° aberto e deve ser ativado para reprodu√ß√£o chamando SDL_PauseAudio (0) quando voc√™ estiver pronto para chamar a fun√ß√£o de retorno de chamada de √°udio. </font><font style="vertical-align: inherit;">Como o driver de √°udio pode alterar o tamanho solicitado do buffer de √°udio, voc√™ deve selecionar os buffers do mixer local ap√≥s abrir o dispositivo de √°udio.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_PauseAudio</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pause_on)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta fun√ß√£o pausa e interrompe o processamento de retorno de chamada de √°udio. </font><font style="vertical-align: inherit;">Ele deve ser chamado com pause_on = 0 ap√≥s abrir o dispositivo de √°udio para iniciar a reprodu√ß√£o do som. </font><font style="vertical-align: inherit;">Isso permite que voc√™ inicialize com seguran√ßa os dados da fun√ß√£o de retorno de chamada ap√≥s abrir a unidade de √°udio. </font><font style="vertical-align: inherit;">O sil√™ncio ser√° gravado no dispositivo de √°udio durante uma pausa.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_PushEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma fila de eventos que √© realmente usada como um canal de comunica√ß√£o bidirecional. </font><font style="vertical-align: inherit;">N√£o apenas os eventos podem ser lidos na fila, mas o usu√°rio tamb√©m pode colocar seus pr√≥prios eventos nela. </font><font style="vertical-align: inherit;">Um evento √© um ponteiro para a estrutura do evento que voc√™ deseja enfileirar. </font><font style="vertical-align: inherit;">O evento √© copiado para a fila e o chamador pode gerenciar a mem√≥ria apontada ap√≥s retornar o SDL_PushEvent. </font><font style="vertical-align: inherit;">Essa fun√ß√£o √© orientada a threads e pode ser chamada com seguran√ßa de outros threads. </font><font style="vertical-align: inherit;">Retorna 0 se for bem-sucedido ou -1 se o evento n√£o puder ser despachado.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">SDL_WaitEvent</span><span class="hljs-params">(SDL_Event *event)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aguarda indefinidamente o pr√≥ximo evento dispon√≠vel, retornando 0 se ocorrer um erro ao aguardar eventos, 1 caso contr√°rio. </font><font style="vertical-align: inherit;">Se o evento n√£o for NULL, o pr√≥ximo evento ser√° removido da fila e armazenado nesta √°rea.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SDL_Quit</span><span class="hljs-params">()</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desativa todos os subsistemas SDL e libera os recursos alocados a ele. Isso sempre deve ser chamado antes de sair.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">SDL_Surface *<span class="hljs-title">SDL_SetVideoMode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> bitsperpixel, Uint32 flags)</span></span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Configura√ß√£o do modo de v√≠deo com a largura, altura e bits de pixel especificados. A partir do SDL 1.2.10, se a largura e a altura forem 0, ele usar√° a largura e a altura do modo de v√≠deo atual (ou modo de √°rea de trabalho se o modo n√£o estiver definido). Se </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bitsperpixel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for 0, ele ser√° tratado como os bits de exibi√ß√£o atuais por pixel. O par√¢metro </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √© o mesmo que o campo flags da estrutura SDL_Surface. Ou uma combina√ß√£o dos seguintes valores: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - crie uma superf√≠cie de v√≠deo na mem√≥ria do sistema. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - crie uma superf√≠cie de v√≠deo na mem√≥ria de v√≠deo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - permite o uso de atualiza√ß√µes ass√≠ncronas na superf√≠cie da tela. Isso geralmente diminui o trabalho em computadores de processador √∫nico, mas pode aumentar a velocidade nos sistemas SMP.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - normalmente, se uma superf√≠cie de v√≠deo com os bits solicitados por pixel (bpp - de bits por pixel) n√£o estiver dispon√≠vel, o SDL emular√° o v√≠deo com uma superf√≠cie sombreada. Passar SDL_ANYFORMAT evita isso e for√ßa o SDL a usar a superf√≠cie do v√≠deo, independentemente da profundidade em pixels. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - fornece acesso exclusivo ao SDL para a paleta. Sem esse sinalizador, voc√™ nem sempre pode obter as cores solicitadas usando SDL_SetColors ou SDL_SetPalette.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - habilita o buffer duplo de hardware; v√°lido apenas com SDL_HWSURFACE. Uma chamada para SDL_Flip reverter√° os buffers e atualizar√° a tela. Todo o desenho ocorrer√° em uma superf√≠cie que n√£o √© exibida no momento. Se o buffer duplo n√£o puder ser ativado, o SDL_Flip simplesmente executar√° o SDL_UpdateRect em tela cheia. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN SDL - tente usar o modo de tela cheia. Se n√£o for poss√≠vel alterar a resolu√ß√£o do hardware (por qualquer motivo), a pr√≥xima resolu√ß√£o mais alta ser√° usada e a janela de exibi√ß√£o ser√° centralizada em um fundo preto. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - crie um contexto de renderiza√ß√£o OpenGL. Sup√µe-se que os atributos de v√≠deo do OpenGL com SDL_GL_SetAttribute estejam predefinidos.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - crie um contexto de renderiza√ß√£o OpenGL, conforme descrito acima, mas permita opera√ß√µes normais de blitting. Uma superf√≠cie da tela (2D) pode ter um canal alfa e SDL_UpdateRects deve ser usado para atualizar as altera√ß√µes na superf√≠cie da tela. NOTA. Esta op√ß√£o √© salva apenas para compatibilidade e ser√° removida em vers√µes futuras. N√£o recomendado para uso em novo c√≥digo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABL - crie uma janela redimension√°vel. Quando o tamanho da janela √© alterado pelo usu√°rio, o evento SDL_VIDEORESIZE √© gerado e SDL_SetVideoMode pode ser chamado novamente com um novo tamanho. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_NOFRAME Se poss√≠vel, SDL_NOFRAME for√ßa o SDL a criar uma janela sem um t√≠tulo ou emoldurado. Este sinalizador √© definido automaticamente no modo de tela cheia.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota. Independentemente de quais sinalizadores SDL_SetVideoMode possam atender, eles s√£o configurados no elemento flags da superf√≠cie retornada. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NOTA. O pixel de bit 24 usa uma representa√ß√£o compactada de 3 bytes por pixel. Para o modo mais comum de 4 bytes por pixel, use um pixel de 32 bits. Por incr√≠vel que pare√ßa, 15 e 16 solicitar√£o um modo de 2 bytes por pixel, mas com diferentes formatos de pixel.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NOTA. Use SDL_SWSURFACE se voc√™ planeja executar manipula√ß√µes de pixel separadas ou arrastar superf√≠cies usando canais alfa e exigir uma alta taxa de quadros. Quando voc√™ usa superf√≠cies de hardware (SDL_HWSURFACE), o SDL copia superf√≠cies da mem√≥ria de v√≠deo para a mem√≥ria do sistema quando voc√™ as bloqueia e vice-versa quando as desbloqueia. Isso pode levar a uma diminui√ß√£o significativa no desempenho. (Lembre-se de que voc√™ pode consultar uma superf√≠cie de hardware, mas ainda obter uma superf√≠cie de software. Muitas plataformas s√≥ podem fornecer uma superf√≠cie de hardware ao usar SDL_FULLSCREEN.) SDL_HWSURFACE √© melhor usado quando as superf√≠cies que voc√™ pisca tamb√©m podem ser armazenadas na mem√≥ria de v√≠deo.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NOTA. </font><font style="vertical-align: inherit;">Se voc√™ deseja controlar a posi√ß√£o na tela ao criar a superf√≠cie da janela, pode fazer isso definindo as vari√°veis ‚Äã‚Äãde ambiente ‚ÄúSDL_VIDEO_CENTERED = center‚Äù ou ‚ÄúSDL_VIDEO_WINDOW_POS = x, y‚Äù. </font><font style="vertical-align: inherit;">Voc√™ pode instal√°-los via SDL_putenv. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Valor de retorno:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Superf√≠cie do buffer do quadro ou NULL em caso de falha. </font><font style="vertical-align: inherit;">A superf√≠cie retornada √© liberada pelo SDL_Quit e n√£o deve ser liberada pelo chamador. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NOTA. </font><font style="vertical-align: inherit;">Essa regra inclui chamadas consecutivas para SDL_SetVideoMode (ou seja, redimensionamento) - a superf√≠cie existente ser√° liberada automaticamente.</font></font><a name="data"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ap√™ndice 2. Estruturas de Dados </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Ap√™ndice 1. Lista de Fun√ß√µes"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üê </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚áë </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Refer√™ncias"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üí</font></font></a></h2><br>
<br>
<pre><code class="cpp hljs">AVCodecContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todas as informa√ß√µes sobre o codec do fluxo, do AVStream-&gt; codec. Alguns atributos importantes: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de quadros por segundo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sample_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : amostras por segundo </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">channel</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de canais </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veja a lista completa (muito impressionante) </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=http://web.archive.org/web/20090410064257/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arquivo da web, pois o link original j√° n√£o existe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Muitos par√¢metros s√£o usados ‚Äã‚Äãprincipalmente para codifica√ß√£o, n√£o para decodifica√ß√£o.</font></font><br>
<br>
<pre><code class="cpp hljs">AVFormatContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Campos de dados: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVClass</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">av_class </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVInputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVOutputFormat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oformat </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ByteIOContext </font></font></b> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pb</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : usado para manipula√ß√£o de arquivos de baixo n√≠vel. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">unsigned int nb_streams</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de threads no arquivo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fluxos AVStream * [MAX_STREAMS]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : os dados de cada fluxo s√£o armazenados aqui. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char nome do arquivo [1024]:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mas e sem ele (no original - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duh</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Informa√ß√µes do arquivo: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">timestamp</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">title</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">autor</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">copyright</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">comment</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">album</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [512]: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ano</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faixa</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
char </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g√™nero</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [32]: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ctx_flags</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os valores poss√≠veis s√£o AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS, AVFMT_RAWPICTURE, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> * </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">packet_buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esse buffer √© necess√°rio apenas quando os pacotes j√° est√£o em buffer, mas n√£o decodificados, por exemplo, para receber par√¢metros de codec em fluxos MPEG. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
int64_t</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : when decoding: a posi√ß√£o do primeiro quadro do componente, em fra√ß√µes de segundo, AV_TIME_BASE. NUNCA defina esse valor diretamente: √© inferido a partir dos valores do AVStream. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t duration: decoding</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dura√ß√£o do fluxo, em fra√ß√µes de AV_TIME_BASE. NUNCA defina esse valor diretamente: √© inferido a partir dos valores do AVStream. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t file_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho total do arquivo, 0 se desconhecido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int bit_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : decoding: taxa de bits total do fluxo em bit / s, 0 se n√£o estiver dispon√≠vel. NUNCA defina-o diretamente se o tamanho do arquivo e a dura√ß√£o conhecida no ffmpeg puderem calcul√°-lo automaticamente. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVStream * cur_st </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * cur_ptr </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int cur_len </font></font></b><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket cur_pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t data_offset</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index_built</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : deslocamento do primeiro pacote. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int mux_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int preload</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_delay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_output</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de loops de sa√≠da nos formatos suportados. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinalizadores int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int loop_input</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o assinado int probesize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : decodifica√ß√£o: tamanho dos dados da amostra; n√£o usado na codifica√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_analyze_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dura√ß√£o m√°xima em unidades de AV_TIME_BASE durante a qual os dados de entrada devem ser analisados ‚Äã‚Äãem av_find_stream_info () </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const uint8_t * key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int keylen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contexto de E / S para acessar recursos. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">const AVClass * av_class</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : classe para configura√ß√µes particulares. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n√£o assinado char * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : in√≠cio do buffer. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho m√°ximo do buffer. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char n√£o assinado * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o atual no buffer. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char n√£o assinado * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Os dados podem ser menores que buffer + buffer_size se a fun√ß√£o de leitura retornar menos dados do que o solicitado, por exemplo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaco</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : ponteiro privado passado para leitura / grava√ß√£o / pesquisa / ... </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) (void * opaco, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaco, uint8_t * buf, int buf_size )</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* busca) (nulo * opaco, int64_t deslocamento, int donde)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o no arquivo do buffer atual. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true se a pr√≥xima pesquisa deve ser redefinida. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true se o final do arquivo for atingido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : true se aberto para grava√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soma de verifica√ß√£o longa n√£o </font></font></b><font style="vertical-align: inherit;"></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assinada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">soma de verifica√ß√£o longa n√£o </font></b><b><font style="vertical-align: inherit;">assinada</font></b><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">soma de </font></b><b><font style="vertical-align: inherit;">verifica√ß√£o_ptr</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longa n√£o assinada (* update_checksum) (soma de verifica√ß√£o longa n√£o assinada, const uint8_t * buf, tamanho int n√£o assinado)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cont√©m o c√≥digo de erro ou 0 se nenhum erro ocorreu. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_pause) (void * opaco, int pause)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: pausar ou retomar a reprodu√ß√£o de protocolos de streaming em rede, por exemplo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t (* read_seek) (void * opaco, int stream_index, int64_t timestamp, int flags)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : procure o timestamp especificado no fluxo com o √≠ndice stream_index especificado. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seekable</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : combina√ß√£o dos sinalizadores AVIO_SEEKABLE_ ou 0 quando o fluxo n√£o √© pesquis√°vel. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t maxsize</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho m√°ximo do arquivo usado para limitar a sele√ß√£o. Este campo √© interno ao libavformat e o acesso a ele a partir do exterior √© proibido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int direct</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : avio_read e avio_write devem ser executados diretamente sempre que poss√≠vel, e n√£o passar pelo buffer, e avio_seek sempre chamar√° diretamente a principal fun√ß√£o de pesquisa. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t bytes_read</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: byte read statistics Esse campo √© interno ao libavformat e o acesso externo √© negado. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int seek_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : estat√≠sticas de pesquisa. </font><font style="vertical-align: inherit;">Este campo √© interno ao libavformat e o acesso a ele a partir do exterior √© proibido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int writeout_count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : escreve estat√≠sticas. </font><font style="vertical-align: inherit;">Este campo √© interno ao libavformat e o acesso a ele a partir do exterior √© proibido. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int orig_buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o tamanho original do buffer usado internamente ap√≥s verificar e fornecer um retorno para redefinir o tamanho do buffer. </font><font style="vertical-align: inherit;">Este campo √© interno ao libavformat e o acesso a ele a partir do exterior √© proibido.</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionary</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usado para passar par√¢metros para ffmpeg. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int count</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVDictionaryEntry * elems</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVDictionaryEntry</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usado para armazenar entradas de dicion√°rio no AVDictionary. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * ket</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char * value</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVFrame</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura depende do tipo de codec e, portanto, √© determinada dinamicamente. No entanto, existem propriedades e m√©todos comuns para essa estrutura: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int tamanho da linha [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : passo da informa√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * base [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int key_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int pict_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : esses n√£o s√£o os pts que voc√™ espera ao decodificar. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int coded_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int display_picture_number</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qualidade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int idade</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int refer√™ncia</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * qscale_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qstride</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * mbskip_table</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int16_t (* motion_val [2]) [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint32_t * mb_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t motion_subsample_log2</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaco</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dados do usu√°rio </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erro uint64_t [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int tipo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int repeat_pict</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : instrui voc√™ a repetir a imagem um n√∫mero especificado de vezes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int qscale_type</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int interlaced_frame</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int top_field_first</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPanScan * pan_scan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int palette_has_changed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_hints</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">short * dct_coeff</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int8_t * ref_index [2]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacket</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura na qual os dados brutos do pacote s√£o armazenados. Esses dados devem ser transferidos para avcodec_decode_audio2 ou avcodec_decode_video para receber um quadro. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : registro de data e hora da apresenta√ß√£o em unidades time_base. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">registro de</font></b><font style="vertical-align: inherit;"> data e hora de descompacta√ß√£o em unidades de time_base. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dados brutos. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho dos dados. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fluxo do qual AVPacket veio, com base na quantidade em AVFormatContext. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinalizadores int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : PKT_FLAG_KEY √© definido se o pacote for um quadro-chave. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : dura√ß√£o da apresenta√ß√£o em unidades de time_base (0 se n√£o dispon√≠vel)</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void (* destruct) (struct AVPacket *)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fun√ß√£o de libera√ß√£o de recurso para este pacote (av_destruct_packet por padr√£o). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o de bytes no fluxo, -1 se desconhecido.</font></font><br>
<br>
<pre><code class="cpp hljs">AVPacketList</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma lista vinculada simples para pacotes. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacket pkt</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVPacketList * pr√≥ximo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">AVPicture</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura √© exatamente a mesma que os dois primeiros elementos de dados do AVFrame, portanto √© frequentemente descartada. </font><font style="vertical-align: inherit;">Comumente usado em fun√ß√µes SWS. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t * data [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int tamanho da linha [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o n√∫mero de bytes na string.</font></font><br>
<br>
<pre><code class="cpp hljs">AVRational</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estrutura simples para representar n√∫meros racionais. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int num</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : numerador. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int den</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : denominador.</font></font><br>
<br>
<pre><code class="cpp hljs">AVStream</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura para o fluxo. √â prov√°vel que voc√™ use essas informa√ß√µes no codec com mais frequ√™ncia. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int index</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int id</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecContext * codec</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVRational r_frame_rate</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * priv_data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codec_info_duration int64_t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codec_info_nb_frames int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts AVFrac</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">time_base AVRational</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pts_wrap_bits int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int stream_copy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma enumera√ß√£o AVDiscard o descarte</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : voc√™ pode escolher os pacotes que ser√£o jogados fora porque eles n√£o precisam na desmultiplexa√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qualidade do flutuador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t start_time</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Char idioma [4]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">need_parsing int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : 1 -&gt; precisa de an√°lise completo, 2 -&gt; apenas cabe√ßalhos de an√°lise, sem mudan√ßa de embalagem </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVCodecParserContext * analisador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t cur_dts</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int last_IP_duration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">last_IP_pts int64_t</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AVIndexEntry * index_entries</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nb_index_entries int</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">um int index_entries_allocated_size n√£o assinado</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t nb_frames</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de quadros neste fluxo (se conhecido) ou 0 </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int64_t pts_buffer [MAX_REORDER_DELAY + 1]</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cpp hljs">ByteIOContext</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uma estrutura que armazena informa√ß√µes de baixo n√≠vel sobre um arquivo de filme. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char n√£o assinado * buffer</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int buffer_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char n√£o assinado * buf_ptr</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">char n√£o assinado * buf_end</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * opaco</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* read_packet) (void * opaco, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int (* write_packet) (void * opaque, uint8_t * buf, int buf_size)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t (* seek) (void * opaco, offset_t offset, int whence)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">offset_t pos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int must_flush</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int eof_reached</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int write_flag</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int is_streamed</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int max_packet_size</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">soma de verifica√ß√£o longa n√£o </font></font></b><font style="vertical-align: inherit;"></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">assinada</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">char n√£o assinado * checksum_ptr</font></b><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longa n√£o assinada (* update_checksum) (soma de verifica√ß√£o longa n√£o assinada: </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
const uint8_t * buf, tamanho int n√£o assinado)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int error</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : cont√©m o c√≥digo de erro ou 0 se nenhum erro ocorreu.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_AudioSpec</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Usado para descrever o formato de alguns dados de √°udio. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freq</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : frequ√™ncia do som em amostras por segundo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">formato</font></b><font style="vertical-align: inherit;"> de dados de √°udio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">canais</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : n√∫mero de canais: 1 - mono, 2 - est√©reo, 4 surround, 6 surround com centraliza√ß√£o e </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sil√™ncio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LFE </font><font style="vertical-align: inherit;">: valor de </font><b><font style="vertical-align: inherit;">sil√™ncio</font></b><font style="vertical-align: inherit;"> do buffer de som (calculado). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">samples</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tamanho do buffer de √°udio em samples. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tamanho</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o tamanho do buffer de √°udio em bytes (calculado). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">retorno de chamada (..)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : fun√ß√£o de retorno de chamada para preencher o buffer de √°udio. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">userdata</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um ponteiro para os dados do usu√°rio que s√£o passados ‚Äã‚Äãpara a fun√ß√£o de retorno de chamada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os seguintes valores de formato s√£o </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
v√°lidos </font><font style="vertical-align: inherit;">: </font><font style="vertical-align: inherit;">AUDIO_U8 - ‚Äã‚Äãamostras n√£o assinadas de 8 bits.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S8 - amostras de 8 bits assinadas. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16 ou AUDIO_U16LSB - n√£o suportado por todo o hardware (ordem de bytes baixos n√£o assinados de 16 bits). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16 ou AUDIO_S16LS - n√£o suportado por todo o hardware (16 bits com ordem de bytes antigos) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16MSB - n√£o suportado por todo o hardware (big endian n√£o assinado de 16 bits). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16MS - n√£o √© suportado por todo o hardware (16 bits com alta ordem de bytes). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_U16SYS: AUDIO_U16LSB ou AUDIO_U16MSB - dependendo do processador de hardware. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AUDIO_S16SYS: AUDIO_S16LSB ou AUDIO_S16MSB - dependendo do processador de hardware.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Event</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A estrutura b√°sica para eventos. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tipo</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : tipo de evento. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">active</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de ativa√ß√£o (consulte SDL_ActiveEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">key</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento do teclado (consulte SDL_KeyboardEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">motion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de movimento do mouse (consulte SDL_MouseMotionEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bot√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de clique do mouse (consulte SDL_MouseButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jaxis</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de movimento do eixo do joystick (consulte SDL_JoyAxisEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jball</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de movimento do trackball do joystick (consulte SDL_JoyBallEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jhat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de movimento do cabe√ßalho do joystick (consulte SDL_JoyHatEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">jbutton</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de pressionar o bot√£o do joystick (consulte SDL_JoyButtonEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">redimensionar</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: Evento de redimensionamento da janela do aplicativo (consulte SDL_ResizeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exposi√ß√£o</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento aberto da janela do aplicativo (consulte SDL_ExposeEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quit</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento de solicita√ß√£o de sa√≠da do aplicativo (consulte SDL_QuitEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">usu√°rio</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento do usu√°rio (consulte SDL_UserEvent). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">syswm</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : evento indefinido do gerenciador de janelas (consulte SDL_SysWMEvent). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui est√£o os tipos de eventos. Consulte a documenta√ß√£o SDL para mais informa√ß√µes :. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ACTIVEEVENT SDL_ActiveEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_KEYDOWN / UP SDL_KeyboardEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEMOTION SDL_MouseMotionEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_MOUSEBUTTONDOWN / UP SDL_MouseButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYAXISMOTION SDL_JoyAxisEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBALLMOTION SDL_JoyBallEvent</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JoyHatEvent SDL_JOYHATMOTION </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_JOYBUTTONDOWN / UP SDL_JoyButtonEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEORESIZE SDL_ResizeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_VIDEOEXPOSE SDL_ExposeEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Quit SDL_QuitEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_USEREVENT SDL_UserEvent </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SYSWMEVENT SDL_SysWMEvent</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Overlay</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobreposi√ß√£o de YUV. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formato</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font><b><font style="vertical-align: inherit;">formato de</font></b><font style="vertical-align: inherit;"> sobreposi√ß√£o (veja abaixo). </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largura / altura da sobreposi√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">planos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : o n√∫mero de planos a serem sobrepostos. Geralmente 1 ou 3. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arremessos</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma matriz de recuos, um para cada plano. Recuo √© o comprimento da sequ√™ncia em bytes. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : uma matriz de ponteiros de dados para cada plano. A sobreposi√ß√£o deve estar bloqueada antes de usar esses ponteiros. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hw_overlay</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : defina como 1 se a sobreposi√ß√£o for acelerada por hardware.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Rect</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A √°rea retangular. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sint16 x, y</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : posi√ß√£o do canto superior esquerdo do ret√¢ngulo. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uint16 w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a largura e a altura do ret√¢ngulo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Rect define uma √°rea retangular de pixels. √â usado pelo SDL_BlitSurface para identificar √°reas de blitting e alguns outros recursos de v√≠deo.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Surface</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Estrutura gr√°fica do lado externo (superf√≠cie). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sinalizadores Uint32</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Sinalizadores dos stotrons externos. Somente para leitura. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formato SDL_PixelFormat *</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : somente leitura. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int w, h</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : largura e altura. Somente para leitura. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passo Uint16</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : passo. Somente para leitura. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">void * pixels</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : um ponteiro para os dados de pixel reais. Apenas para grava√ß√£o. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL_Rect clip_rect</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : a parte externa retangular do clipe. Somente para leitura. </font></font><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">int refcount</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : usado para alocar mem√≥ria. Principalmente para leitura. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura tamb√©m cont√©m campos particulares n√£o mostrados aqui.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_Surface representa uma √°rea da mem√≥ria "gr√°fica" que pode ser desenhada. O quadro do buffer de v√≠deo √© retornado como SDL_Surface usando SDL_SetVideoMode e SDL_GetVideoSurface. Os campos w e h s√£o valores que representam a largura e a altura da superf√≠cie em pixels. O campo de pixel √© um ponteiro para os dados de pixel reais. Nota: a superf√≠cie deve estar bloqueada (via SDL_LockSurface) antes de acessar este campo. O campo clip_rect √© o ret√¢ngulo recortado definido por SDL_SetClipRect. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O campo sinalizador suporta os seguintes valores OR: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SWSURFACE - o exterior √© armazenado na mem√≥ria do sistema. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWSURFACE - O lado externo √© armazenado na mem√≥ria de v√≠deo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ASYNCBLIT - A parte externa usa brilho ass√≠ncrono, se poss√≠vel.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_ANYFORMAT - Qualquer formato de pixel (superf√≠cie da tela) √© permitido. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWPALETTE - A superf√≠cie possui uma paleta exclusiva. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_DOUBLEBUF - superf√≠cie com buffer duplo (superf√≠cie da tela). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_FULLSCREEN - superf√≠cie de tela cheia (superf√≠cie de exibi√ß√£o). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGL - a superf√≠cie possui um contexto OpenGL (superf√≠cie de exibi√ß√£o). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_OPENGLBLIT - a superf√≠cie suporta blinting OpenGL (superf√≠cie da tela). NOTA. Esta op√ß√£o √© apenas para compatibilidade e n√£o √© recomendada para novo c√≥digo. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RESIZABLE - √© poss√≠vel redimensionar uma superf√≠cie (superf√≠cie da tela). </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_HWACCEL - o blit de superf√≠cie usa acelera√ß√£o de hardware. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCCOLORKEY - A superficialidade usa cores cegas.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_RLEACCEL - a divis√£o de cores √© acelerada usando o RLE. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_SRCALPHA - Surface Blyth usa mistura alfa. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SDL_PREALLOC - A superf√≠cie usa mem√≥ria pr√©-alocada.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_Thread</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura √© independente do sistema e voc√™ provavelmente n√£o precisa us√°-la. </font><font style="vertical-align: inherit;">Veja src / thread / sdl_thread_c.h no c√≥digo fonte para mais informa√ß√µes.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_cond</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura √© independente do sistema e voc√™ provavelmente n√£o precisa us√°-la. </font><font style="vertical-align: inherit;">Consulte src / thread / &lt;system&gt; /SDL_syscond.c no c√≥digo fonte para obter mais informa√ß√µes.</font></font><br>
<br>
<pre><code class="cpp hljs">SDL_mutex</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essa estrutura √© independente do sistema e voc√™ provavelmente n√£o precisa us√°-la. </font><font style="vertical-align: inherit;">Veja src / thread / &lt;system&gt; /SDL_sysmutex.c no c√≥digo fonte para obter mais informa√ß√µes.</font></font><a name="links"></a><br>
<br>
<hr><hr><hr><hr><hr><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Links </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Ap√™ndice 2. Estruturas de Dados"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Üê </font></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" title="Para o √≠ndice"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚áë</font></font></a></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/ts/cs/ro/tscsrofdmymu7o1rbml2evolway.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um tutorial sobre FFmpeg e SDL ou Como gravar um player de v√≠deo em menos de 1000 linhas </font></font></a><br>
<br>
<img width="30" height="30" src="https://habrastorage.org/webt/3y/wq/mh/3ywqmhuo7fv68jggkc416kbzuw4.png"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FFmpeg</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDL </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">FFmpeg HomePage </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">SDL HomePage</font></a></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="122" height="30" src="https://habrastorage.org/webt/z0/e1/6o/z0e16ozcekig9i8jdthljdqpgga.png"></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img width="60" height="30" src="https://habrastorage.org/webt/js/4n/23/js4n231ba7glkow_nud5i3dsveq.png"> </a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"></font></a><br>
<br>
<hr><hr><hr><hr><hr><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img align="right" width="420" height="125" src="https://habrastorage.org/webt/co/i3/m0/coi3m0tliby9r5uxtiydjoeaqkm.png"></a><br clear="left">
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Leia tamb√©m no blog da empresa EDISON:</font></font></h4><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manual do FFmpeg libav</font></font></b></a><br></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502834/index.html">Como se tornar um engenheiro de DevOps em seis meses ou at√© mais r√°pido. Parte 5. Implanta√ß√£o</a></li>
<li><a href="../pt502836/index.html">Aventuras do editor de unidade: Matryoshka serializado</a></li>
<li><a href="../pt502838/index.html">Qual √© a diferen√ßa entre TI e profiss√µes digitais: transforma√ß√£o digital e opini√µes de especialistas</a></li>
<li><a href="../pt502840/index.html">Revis√£o do scanner 3D EinScan Pro 2X Plus 3D brilhante</a></li>
<li><a href="../pt502842/index.html">Como proteger os dados biom√©tricos do usu√°rio contra uso criminoso</a></li>
<li><a href="../pt502846/index.html">Zuckerberg lan√ßou Lojas. Instagram e Facebook gradualmente se tornam lojas.</a></li>
<li><a href="../pt502852/index.html">Por que as pessoas resistem √†s mudan√ßas e como elas podem ajud√°-las a reconstruir</a></li>
<li><a href="../pt502854/index.html">Por que as implementa√ß√µes de ERP falham?</a></li>
<li><a href="../pt502860/index.html">Transporte em 20 de maio: recupera√ß√£o r√°pida da avia√ß√£o √© vis√≠vel</a></li>
<li><a href="../pt502862/index.html">LabVIEW NXG - No√ß√µes b√°sicas do painel frontal - Controles e indicadores</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>