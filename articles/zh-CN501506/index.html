<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🏭 📥 🍍 关于GDI泄漏和运气的重要性 ⛵️ 🎂 🎑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在2019年5月，我被要求查看一个潜在危险的Chrome错误。起初，我诊断他不重要，以这种方式浪费了两个星期。后来，当我返回调查时，它成为导致浏览器进程崩溃的第一大原因，Chrome浏览器Beta通道中。哎呀
 
 6月6日，也就是我意识到我在解释出发数据时出错的那天，该错误被标记为ReleaseB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>关于GDI泄漏和运气的重要性</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/501506/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e75/586/6da/e755866da35a13300e4fde55ebfd100b.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在2019年5月，我被要求查看一个潜在危险的Chrome错误。起初，我诊断他不重要，以这种方式浪费了两个星期。后来，当我返回调查时，它成为导致浏览器进程崩溃的第一大原因，Chrome浏览器Beta通道中。哎呀</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6月6日，也就是我意识到我在解释出发数据时出错的那天，该错误被标记为ReleaseBlock-Stable。这意味着我们将无法确定大多数用户的新版本的Chrome。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
发生崩溃是因为我们用完了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDI对象（图形设备接口）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但是我们不知道它们是什么类型的GDI对象，诊断数据没有提供有关问题所在的任何线索，因此我们无法重新创建它。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们团队中的许多人在6月6日至7日努力解决了该错误，他们测试了他们的理论，但没有推进。 6月8日，我决定检查我的邮件，Chrome立即崩溃了。这是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样的失败</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
真是讽刺。在我寻找更改并检查崩溃报告时，试图找出是什么原因导致Chrome浏览器进程泄漏GDI对象，但我的浏览器中GDI对象的数量却在不断增加，到6月8日上午，它已经超过了</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">神奇的10,000</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。此时，针对GDI对象的内存分配操作之一失败，并且我们故意使浏览器崩溃。真是不可思议的运气。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果可以重现该错误，则不可避免地可以对其进行修复。</font><font style="vertical-align: inherit;">我只需要弄清楚是怎么引起这个错误的，然后我们就可以消除它。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，这个问题的简短历史</font></font></h2><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a10/aba/273/a10aba273e79a9fc534a6d436c21f8de.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在Chromium代码的大多数地方，当我们尝试为GDI对象分配内存时，我们首先会检查此分配是否成功。如果不可能分配内存，那么我们将一些信息写入堆栈，并有意执行崩溃，如</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该源代码所示</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。失败是有意造成的，因为如果我们不能为GDI对象分配内存，那么我们将无法在屏幕上进行渲染-报告问题（如果启用了崩溃报告）并重新启动该过程比显示一个空UI更好。默认情况下，每个进程最多可以创建10,000个GDI对象，通常只使用数百个。因此，如果我们超过此限制，则完全出错。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当我们收到一份崩溃报告，其中指出GDI对象的内存分配错误时，我们就有了调用堆栈和各种其他有用的信息。</font><font style="vertical-align: inherit;">精细！</font><font style="vertical-align: inherit;">但是问题是这样的崩溃转储不一定与错误有关。</font><font style="vertical-align: inherit;">这是因为导致GDI对象泄漏的代码和报告失败的代码可能不是同一代码。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大致来说，我们有两种类型的代码：</font></font><br>
<br>
<blockquote><pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">无效的GoodCode（）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   自动x = AllocateGDIObject（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   如果（！x）</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
     CollectGDIUsageAndDie（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   UseGDIObject（x）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   FreeGDIObject（x）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font><font></font>
<font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
无效BadCode（）{</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   自动x = AllocateGDIObject（）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
   UseGDIObject（x）;</font></font><font></font><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
}</font></font></pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好的代码会注意到内存分配失败，并报告此错误，而坏的代码会忽略崩溃并溢出对象，从而“替换”好代码，使其负责。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
铬包含几百万行代码。我们不知道哪个函数有错误，甚至不知道</font><font style="vertical-align: inherit;">泄漏了</font><font style="vertical-align: inherit;">什么</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> GDI对象</font><font style="vertical-align: inherit;">。我的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一位同事添加</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了崩溃之前绕过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Process Environment Block的</font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">代码</font></a><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">以获取每种类型的GDI对象的数量，但是对于所有枚举类型（设备上下文，区域，位图，调色板，画笔，羽毛和未知），数量都不超过一百。真奇怪。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原来，我们直接为其分配内存的对象在此表中，但是内核没有代表我们创建的对象，它们存在于Windows对象管理器中。</font><font style="vertical-align: inherit;">这意味着</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDIView</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和我们一样对这个问题也视而不见（此外，GDIView仅在本地发生故障时有用）。</font><font style="vertical-align: inherit;">因为我们泄漏了游标，并且游标是附加了GDI对象的USER32对象；</font><font style="vertical-align: inherit;">这些GDI对象的内存是由内核分配的，我们看不到发生了什么。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">误解</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的函数</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CollectGDIUsageAndDie具有</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">非常生动的名称，我想您会同意我的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">观点</font></a><font style="vertical-align: inherit;">。很有表现力。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
问题在于它执行了太多的动作。 CollectGDIUsageAndDie检查了GDI对象的大约十二种不同类型的内存分配失败，并且由于代码的嵌入，它们因此收到了相同的失败签名-它们都崩溃到主要功能中并合并在一起。因此，我的一位同事明智地</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">进行了更改</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将不同的检查分解为单独的（不是内置的）功能。因此，乍一看，我们可以了解到哪个检查失败了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
las，这导致了一个事实，当我们开始从</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">CrashIfExcessiveHandles</font></a><font style="vertical-align: inherit;">获取</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">崩溃</font></a><font style="vertical-align: inherit;">报告时</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我自信地说：“这不是失败的原因，仅仅是由签名更改引起的。” </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我错了。</font><font style="vertical-align: inherit;">这是导致失败</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">签名更改的原因。</font><font style="vertical-align: inherit;">哎呀 </font><font style="vertical-align: inherit;">尴尬的分析，道森。</font><font style="vertical-align: inherit;">没有适合您的Cookie。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回到我们的故事</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至此，我已经知道我在6月7日所做的某件事每天使用近10,000个GDI对象。</font><font style="vertical-align: inherit;">如果我能理解的话，我将解决这个难题。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c0/b8e/9ee/0c0b8e9ee9f5afdfff26391eb2e360f8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows任务管理器还有一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GDI对象</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列</font><font style="vertical-align: inherit;">，可用于查找泄漏。 6月7日，我在家工作，连接到我的工作机，并且在工作机上启用了此列，因为我进行了测试并试图重现崩溃情况。但是与此同时，我的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">家用</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">计算机</font><font style="vertical-align: inherit;">上的浏览器中</font><font style="vertical-align: inherit;">存在GDI对象泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在家中使用浏览器的主要任务是使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Chrome远程桌面（CRD）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应用程序连接到正在运行的计算机</font><font style="vertical-align: inherit;">。因此，我打开了家用计算机上的GDI对象列，并开始进行实验。很快我得到了结果。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
实际上，该错误的时间轴表明，从“我发生故障”（14:00）到“它与CRD有某种联系”，然后到“光标所在的情况”，只有35分钟。我已经说过，当您可以在本地播放bug时，调查bug有多容易？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
事实证明，每次CRD应用程序（或任何Chrome应用程序？）更改光标时，都会导致六个GDI对象泄漏。如果您在使用Chrome远程桌面时将鼠标移到屏幕的所需部分，则每分钟数百个GDI对象和每小时数千个GDI对象可能会泄漏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在解决此问题一个月都没有进展之后，它突然从无法移动的状态变成了简单的校正。我很快写了一个修正草案，然后我的一位同事（我没有处理此错误）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建了一个真正的修正</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它于6月10日11:16下载，并于13:00发布。</font><font style="vertical-align: inherit;">几次合并后，错误消失了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">就这样？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们已修复了该错误，这很棒，但更重要的是，此类错误永远不会再发生。</font><font style="vertical-align: inherit;">显然，使用C ++（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RAII</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">对象进行资源管理是正确的</font><font style="vertical-align: inherit;">，但是在这种情况下，该错误包含在WebCursor类中。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
关于内存泄漏，有一套可靠的系统。</font><font style="vertical-align: inherit;">Microsoft具有</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆快照</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，Chromium具有</font><font style="vertical-align: inherit;">针对用户版本的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">堆概要分析</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">泄漏消除程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在测试机器上。</font><font style="vertical-align: inherit;">但是，似乎GDI对象的泄漏已被忽略。</font><font style="vertical-align: inherit;">进程信息块包含不完整的信息，某些GDI对象只能在内核模式下列出，并且没有单点可以为便于跟踪的对象分配和释放内存。</font><font style="vertical-align: inherit;">这不是我必须处理的GDI对象的第一次泄漏，也不是最后一次泄漏，因为没有可靠的跟踪它们的方法。</font><font style="vertical-align: inherit;">这是我对以下Windows版本的建议：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使获取</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类型的GDI对象</font><font style="vertical-align: inherit;">数量的过程变得</font><font style="vertical-align: inherit;">微不足道，而不必模糊地阅读PEB（并且无需忽略游标）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建一种受支持的方式来拦截和跟踪</font><font style="vertical-align: inherit;">创建和销毁GDI对象的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">操作，以进行可靠的跟踪；</font><font style="vertical-align: inherit;">包括那些间接创建的</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在文档中反映所有这些</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就这样。</font><font style="vertical-align: inherit;">这样的跟踪甚至都不难实现，因为必须以不限制内存的方式限制GDI对象。</font><font style="vertical-align: inherit;">如果使用这些奇怪但不可避免的GDI对象会更安全，那就太好了。</font><font style="vertical-align: inherit;">哦拜托。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以阅读有关Reddit的讨论。</font><font style="vertical-align: inherit;">Twitter上的主题从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此处</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开始</font><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN501494/index.html">不是灵魂的克星：杜洛夫失败的加密货币的故事</a></li>
<li><a href="../zh-CN501496/index.html">彗星湖，迭代完成</a></li>
<li><a href="../zh-CN501498/index.html">使用RESTinio中的easy_parser，需要编写多少C ++代码来解析Authorization HTTP标头？</a></li>
<li><a href="../zh-CN501500/index.html">视觉黑客：什么构成威胁以及如何保护自己免受间谍侵害</a></li>
<li><a href="../zh-CN501502/index.html">新实验室数字综合继续哈里斯书并帮助制作FPGA视频游戏</a></li>
<li><a href="../zh-CN501508/index.html">该死的老客户关系管理</a></li>
<li><a href="../zh-CN501510/index.html">Ruby on Rails框架对Fullstack开发的新见解</a></li>
<li><a href="../zh-CN501516/index.html">让我们关闭真空吗？阿列克谢·列索夫斯基</a></li>
<li><a href="../zh-CN501520/index.html">C＃8，无效。我们如何生活</a></li>
<li><a href="../zh-CN501522/index.html">免费的Skillbox网络研讨会：用PHP，Unity和Unreal Engine编写游戏</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>