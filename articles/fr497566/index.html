<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👵🏿 ♣️ 🚼 Algorithme de compression de Huffman 🙃 🧚🏼 🍔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En prévision du début du cours, "Algorithmes pour les développeurs" a préparé pour vous une traduction d'un autre matériel utile.
 
 
 
 Le codage Huf...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algorithme de compression de Huffman</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/497566/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En prévision du début du cours, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Algorithmes pour les développeurs" a</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> préparé pour vous une traduction d'un autre matériel utile.</font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/u2/bz/ax/u2bzaxiq2huxqrzfavfpesnofvo.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le codage Huffman est un algorithme de compression de données qui formule l'idée de base de la compression de fichiers. Dans cet article, nous parlerons du codage de longueur fixe et variable, des codes décodés de manière unique, des règles de préfixe et de la construction d'un arbre Huffman. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons que chaque caractère est stocké sous la forme d'une séquence de 0 et 1 et prend 8 bits. C'est ce qu'on appelle le codage à longueur fixe car chaque caractère utilise le même nombre fixe de bits à stocker.</font></font><a name="habracut"></a><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disons que le texte est donné. Comment pouvons-nous réduire la quantité d'espace nécessaire pour stocker un personnage?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
L'idée de base est le codage à longueur variable. Nous pouvons utiliser le fait que certains caractères du texte sont plus courants que d'autres ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voir ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) pour développer un algorithme qui représentera la même séquence de caractères avec moins de bits. Lors du codage d'une longueur variable, nous attribuons un nombre variable de bits aux caractères en fonction de la fréquence de leur apparition dans ce texte. En fin de compte, certains caractères peuvent prendre seulement 1 bit, et d'autres 2 bits, 3 ou plus. Le problème avec le codage de longueur variable n'est que le décodage ultérieur de la séquence. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comment, en connaissant la séquence de bits, la décoder de façon unique?</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Considérez la chaîne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«aabacdab»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il a 8 caractères et lors du codage d'une longueur fixe, 64 bits seront nécessaires pour le stocker. Notez que la fréquence des caractères </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«a», «b», «c»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«d»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est respectivement de 4, 2, 1, 1. Essayons d'imaginer </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«aabacdab» avec</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> moins de bits, en utilisant le fait que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«a»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est plus commun que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«b»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«b»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est plus commun que </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«c»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«d»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pour commencer, nous codons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«a» en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisant un bit égal à 0, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«b»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous attribuons un code à deux bits 11, et en utilisant trois bits 100 et 011, nous codons </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«c»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"D"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conséquence, nous réussirons:</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Onze</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ré</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, </font><font style="vertical-align: inherit;">nous </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codons la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chaîne </font><i><font style="vertical-align: inherit;">«aabacdab»</font></i><font style="vertical-align: inherit;"> comme </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011 (0 | 0 | 11 | 0 | 100 | 011 | 0 | 11) en</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilisant les codes présentés ci-dessus. </font><font style="vertical-align: inherit;">Cependant, le principal problème sera le décodage. </font><font style="vertical-align: inherit;">Lorsque nous essayons de décoder la ligne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00110100011011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous obtenons un résultat ambigu, car il peut être représenté comme:</font></font><br>
<br>
<pre><code class="plaintext hljs">0|011|0|100|011|0|11    adacdab<font></font>
0|0|11|0|100|0|11|011   aabacabd<font></font>
0|011|0|100|0|11|0|11   adacabab <font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
etc. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour éviter cette ambiguïté, nous devons nous assurer que notre codage satisfait le concept d'une </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">règle de préfixe</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui implique à son tour que les codes peuvent être décodés d'une seule manière unique. Une règle de préfixe garantit qu'aucun code n'est le préfixe d'un autre. Par code, nous entendons des bits utilisés pour représenter un caractère particulier. Dans l'exemple ci-dessus, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le préfixe </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">011</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui viole la règle de préfixe. Donc, si nos codes satisfont à la règle du préfixe, alors nous pouvons décoder de manière unique (et vice versa). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Passons en revue l'exemple ci-dessus. Cette fois, nous allons attribuer les caractères </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"a", "b", "c"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"d"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Codes qui satisfont à la règle de préfixe.</font></font><br>
<br>
<div class="scrollable-table"><table>
<tbody><tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">une</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dix</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">c</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">110</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ré</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></td>
</tr>
</tbody></table></div><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant cet encodage, la chaîne </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«aabacdab»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera encodée en </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010 (0 | 0 | 10 | 0 | 100 | 011 | 0 | 10)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Et ici </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00100100011010,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous pouvons décoder de manière unique et revenir à notre ligne d'origine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"aabacdab"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codage Huffman</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant que nous avons compris le codage de longueur variable et une règle de préfixe, parlons du codage Huffman. </font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode est basée sur la création d'arbres binaires. Dans celui-ci, un nœud peut être fini ou interne. Initialement, tous les nœuds sont considérés comme des feuilles (feuilles), qui représentent le symbole lui-même et son poids (c'est-à-dire la fréquence d'occurrence). Les nœuds internes contiennent le poids du caractère et se réfèrent à deux nœuds descendants. D'un commun accord, le bit </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«0»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> représente un suivi sur la branche gauche et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«1»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> représente </font><font style="vertical-align: inherit;">sur la droite. Dans un arbre complet, il y a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> feuilles et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nœuds internes. Il est recommandé que lors de la construction d'un arbre Huffman, les caractères inutilisés soient supprimés pour obtenir des codes de longueur optimale.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous utiliserons la file d'attente prioritaire pour construire l'arbre Huffman, où le nœud avec la fréquence la plus basse recevra la priorité la plus élevée. </font><font style="vertical-align: inherit;">Les étapes de construction sont décrites ci-dessous:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un nœud feuille pour chaque personnage et ajoutez-les à la file d'attente prioritaire.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pendant que vous êtes en ligne pour plusieurs feuilles, procédez comme suit:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Supprimez les deux nœuds avec la priorité la plus élevée (avec la fréquence la plus basse) de la file d'attente;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Créez un nouveau nœud interne où ces deux nœuds seront héritiers et la fréquence d'occurrence sera égale à la somme des fréquences de ces deux nœuds.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajoutez un nouveau nœud à la file d'attente prioritaire.</font></font></li>
</ul></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le seul nœud restant sera la racine, ceci terminera la construction de l'arbre.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Imaginez que nous ayons du texte composé uniquement des caractères </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«a», «b», «c», «d»</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">«e»,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et les fréquences de leur apparition sont respectivement 15, 7, 6, 6 et 5. Voici des illustrations qui reflètent les étapes de l'algorithme. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/08/nz/g9/08nzg9y-qguo05argcfhzg7dfbo.png"><br>
<br>
<img src="https://habrastorage.org/webt/1t/fb/5l/1tfb5lnkadshv9ckwwbq2w8jm0k.png"><br>
<br>
<img src="https://habrastorage.org/webt/dh/uo/be/dhuobemww5m4uoxswnpndawrfok.png"><br>
<br>
<img src="https://habrastorage.org/webt/i-/9a/we/i-9awedtfaylpuh834b3xwby0pu.png"><br>
<br>
<img src="https://habrastorage.org/webt/vu/1z/us/vu1zusm2bv_1z0qunv7okiv8s5k.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le chemin de la racine à n'importe quel nœud d'extrémité stockera le code de préfixe optimal (également connu sous le nom de code Huffman) correspondant au caractère associé à ce nœud d'extrémité. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/cc/vy/qm/ccvyqm21nyslsu41zf-f-ppl9go.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Huffman Tree</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Ci-dessous vous trouverez l'implémentation de l'algorithme de compression Huffman en C ++ et Java:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node *left, *right;<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// Function to allocate a new tree node</span>
<span class="hljs-function">Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node* left, Node* right)</span>
</span>{<font></font>
	Node* node = <span class="hljs-keyword">new</span> Node();<font></font>
<font></font>
	node-&gt;ch = ch;<font></font>
	node-&gt;freq = freq;<font></font>
	node-&gt;left = left;<font></font>
	node-&gt;right = right;<font></font>
<font></font>
	<span class="hljs-keyword">return</span> node;<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Comparison object to be used to order the heap</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">comp</span>
{</span>
	<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Node* l, Node* r)</span>
	</span>{
		<span class="hljs-comment">// highest priority item has lowest frequency</span>
		<span class="hljs-keyword">return</span> l-&gt;freq &gt; r-&gt;freq;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
<span class="hljs-comment">// in a map.</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node* root, <span class="hljs-built_in">string</span> str,
			<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; &amp;huffmanCode)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)
		<span class="hljs-keyword">return</span>;<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) {<font></font>
		huffmanCode[root-&gt;ch] = str;<font></font>
	}<font></font>
<font></font>
	encode(root-&gt;left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
	encode(root-&gt;right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node* root, <span class="hljs-keyword">int</span> &amp;index, <span class="hljs-built_in">string</span> str)</span>
</span>{
	<span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) {
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// found a leaf node</span>
	<span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right)<font></font>
	{<font></font>
		<span class="hljs-built_in">cout</span> &lt;&lt; root-&gt;ch;
		<span class="hljs-keyword">return</span>;<font></font>
	}<font></font>
<font></font>
	index++;<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (str[index] ==<span class="hljs-string">'0'</span>)<font></font>
		decode(root-&gt;left, index, str);<font></font>
	<span class="hljs-keyword">else</span><font></font>
		decode(root-&gt;right, index, str);<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Builds Huffman Tree and decode given input text</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(<span class="hljs-built_in">string</span> text)</span>
</span>{
	<span class="hljs-comment">// count frequency of appearance of each character</span>
	<span class="hljs-comment">// and store it in a map</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; freq;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		freq[ch]++;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Create a priority queue to store live nodes of</span>
	<span class="hljs-comment">// Huffman tree;</span>
	priority_queue&lt;Node*, <span class="hljs-built_in">vector</span>&lt;Node*&gt;, comp&gt; pq;<font></font>
<font></font>
	<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
	<span class="hljs-comment">// to the priority queue.</span>
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: freq) {<font></font>
		pq.push(getNode(pair.first, pair.second, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// do till there is more than one node in the queue</span>
	<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
	{<font></font>
		<span class="hljs-comment">// Remove the two nodes of highest priority</span>
		<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
		Node *left = pq.top(); pq.pop();<font></font>
		Node *right = pq.top();	pq.pop();<font></font>
<font></font>
		<span class="hljs-comment">// Create a new internal node with these two nodes</span>
		<span class="hljs-comment">// as children and with frequency equal to the sum</span>
		<span class="hljs-comment">// of the two nodes' frequencies. Add the new node</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">int</span> sum = left-&gt;freq + right-&gt;freq;<font></font>
		pq.push(getNode(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
	Node* root = pq.top();<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map. Also prints them</span>
	<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-built_in">string</span>&gt; huffmanCode;<font></font>
	encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Huffman Codes are :\n"</span> &lt;&lt; <span class="hljs-string">'\n'</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair: huffmanCode) {
		<span class="hljs-built_in">cout</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">" "</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nOriginal string was :\n"</span> &lt;&lt; text &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// print encoded string</span>
	<span class="hljs-built_in">string</span> str = <span class="hljs-string">""</span>;
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> ch: text) {<font></font>
		str += huffmanCode[ch];<font></font>
	}<font></font>
<font></font>
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nEncoded string is :\n"</span> &lt;&lt; str &lt;&lt; <span class="hljs-string">'\n'</span>;<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
	<span class="hljs-comment">// decode the encoded string</span>
	<span class="hljs-keyword">int</span> index = <span class="hljs-number">-1</span>;
	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"\nDecoded string is: \n"</span>;
	<span class="hljs-keyword">while</span> (index &lt; (<span class="hljs-keyword">int</span>)str.size() - <span class="hljs-number">2</span>) {<font></font>
		decode(root, index, str);<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Huffman coding algorithm</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
	<span class="hljs-built_in">string</span> text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
	buildHuffmanTree(text);<font></font>
<font></font>
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<font></font>
}</code></pre><br>
<pre><code class="java hljs"><span class="hljs-keyword">import</span> java.util.HashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.PriorityQueue;<font></font>
<font></font>
<span class="hljs-comment">// A Tree node</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>
</span>{
	<span class="hljs-keyword">char</span> ch;
	<span class="hljs-keyword">int</span> freq;<font></font>
	Node left = <span class="hljs-keyword">null</span>, right = <span class="hljs-keyword">null</span>;<font></font>
<font></font>
	Node(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq)<font></font>
	{<font></font>
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">char</span> ch, <span class="hljs-keyword">int</span> freq, Node left, Node right)</span> </span>{
		<span class="hljs-keyword">this</span>.ch = ch;
		<span class="hljs-keyword">this</span>.freq = freq;
		<span class="hljs-keyword">this</span>.left = left;
		<span class="hljs-keyword">this</span>.right = right;<font></font>
	}<font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Huffman</span>
</span>{
	<span class="hljs-comment">// traverse the Huffman Tree and store Huffman Codes</span>
	<span class="hljs-comment">// in a map.</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Node root, String str,
							  Map&lt;Character, String&gt; huffmanCode)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span>;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>) {<font></font>
			huffmanCode.put(root.ch, str);<font></font>
		}<font></font>
<font></font>
<font></font>
		encode(root.left, str + <span class="hljs-string">"0"</span>, huffmanCode);<font></font>
		encode(root.right, str + <span class="hljs-string">"1"</span>, huffmanCode);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// traverse the Huffman Tree and decode the encoded string</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">decode</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> index, StringBuilder sb)</span>
	</span>{
		<span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>)
			<span class="hljs-keyword">return</span> index;<font></font>
<font></font>
		<span class="hljs-comment">// found a leaf node</span>
		<span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span> &amp;&amp; root.right == <span class="hljs-keyword">null</span>)<font></font>
		{<font></font>
			System.out.print(root.ch);<font></font>
			<span class="hljs-keyword">return</span> index;<font></font>
		}<font></font>
<font></font>
		index++;<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (sb.charAt(index) == <span class="hljs-string">'0'</span>)<font></font>
			index = decode(root.left, index, sb);<font></font>
		<span class="hljs-keyword">else</span><font></font>
			index = decode(root.right, index, sb);<font></font>
<font></font>
		<span class="hljs-keyword">return</span> index;<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Builds Huffman Tree and huffmanCode and decode given input text</span>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHuffmanTree</span><span class="hljs-params">(String text)</span>
	</span>{
		<span class="hljs-comment">// count frequency of appearance of each character</span>
		<span class="hljs-comment">// and store it in a map</span>
		Map&lt;Character, Integer&gt; freq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {
			<span class="hljs-keyword">if</span> (!freq.containsKey(text.charAt(i))) {<font></font>
				freq.put(text.charAt(i), <span class="hljs-number">0</span>);<font></font>
			}<font></font>
			freq.put(text.charAt(i), freq.get(text.charAt(i)) + <span class="hljs-number">1</span>);<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// Create a priority queue to store live nodes of Huffman tree</span>
		<span class="hljs-comment">// Notice that highest priority item has lowest frequency</span>
		PriorityQueue&lt;Node&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<font></font>
										(l, r) -&gt; l.freq - r.freq);<font></font>
<font></font>
		<span class="hljs-comment">// Create a leaf node for each character&nbsp;and add it</span>
		<span class="hljs-comment">// to the priority queue.</span>
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : freq.entrySet()) {<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(entry.getKey(), entry.getValue()));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// do till there is more than one node in the queue</span>
		<span class="hljs-keyword">while</span> (pq.size() != <span class="hljs-number">1</span>)<font></font>
		{<font></font>
			<span class="hljs-comment">// Remove the two nodes of highest priority</span>
			<span class="hljs-comment">// (lowest frequency) from the queue</span><font></font>
			Node left = pq.poll();<font></font>
			Node right = pq.poll();<font></font>
<font></font>
			<span class="hljs-comment">// Create a new internal node with these two nodes as children </span>
			<span class="hljs-comment">// and with frequency equal to the sum of the two nodes</span>
			<span class="hljs-comment">// frequencies. Add the new node to the priority queue.</span>
			<span class="hljs-keyword">int</span> sum = left.freq + right.freq;<font></font>
			pq.add(<span class="hljs-keyword">new</span> Node(<span class="hljs-string">'\0'</span>, sum, left, right));<font></font>
		}<font></font>
<font></font>
		<span class="hljs-comment">// root stores pointer to root of Huffman Tree</span><font></font>
		Node root = pq.peek();<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman tree and store the Huffman codes in a map</span>
		Map&lt;Character, String&gt; huffmanCode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<font></font>
		encode(root, <span class="hljs-string">""</span>, huffmanCode);<font></font>
<font></font>
		<span class="hljs-comment">// print the Huffman codes</span>
		System.out.println(<span class="hljs-string">"Huffman Codes are :\n"</span>);
		<span class="hljs-keyword">for</span> (Map.Entry&lt;Character, String&gt; entry : huffmanCode.entrySet()) {<font></font>
			System.out.println(entry.getKey() + <span class="hljs-string">" "</span> + entry.getValue());<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nOriginal string was :\n"</span> + text);<font></font>
<font></font>
		<span class="hljs-comment">// print encoded string</span>
		StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; text.length(); i++) {<font></font>
			sb.append(huffmanCode.get(text.charAt(i)));<font></font>
		}<font></font>
<font></font>
		System.out.println(<span class="hljs-string">"\nEncoded string is :\n"</span> + sb);<font></font>
<font></font>
		<span class="hljs-comment">// traverse the Huffman Tree again and this time</span>
		<span class="hljs-comment">// decode the encoded string</span>
		<span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<font></font>
		System.out.println(<span class="hljs-string">"\nDecoded string is: \n"</span>);
		<span class="hljs-keyword">while</span> (index &lt; sb.length() - <span class="hljs-number">2</span>) {<font></font>
			index = decode(root, index, sb);<font></font>
		}<font></font>
	}<font></font>
<font></font>
	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>
	</span>{<font></font>
		String text = <span class="hljs-string">"Huffman coding is a data compression algorithm."</span>;<font></font>
<font></font>
		buildHuffmanTree(text);<font></font>
	}<font></font>
}</code></pre><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Remarque: la</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mémoire utilisée par la chaîne d'entrée est de 47 * 8 = 376 bits, et la chaîne codée ne prend que 194 bits, c'est-à-dire </font><font style="vertical-align: inherit;">les données sont compressées d'environ 48%. </font><font style="vertical-align: inherit;">Dans le programme C ++ ci-dessus, nous utilisons la classe de chaîne pour stocker la chaîne codée pour rendre le programme lisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Étant donné que les structures de données efficaces de la file d'attente prioritaire nécessitent un temps </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (log (N))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour être insérées, et dans un arbre binaire complet avec </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> feuilles, il y a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2N-1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nœuds, et l'arbre Huffman est un arbre binaire complet, l'algorithme fonctionne pour </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O (Nlog (N ))</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> heure, où </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le nombre de caractères.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sources:</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en.wikipedia.org/wiki/Huffman_coding</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">en.wikipedia.org/wiki/Variable-length_code</a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">www.youtube.com/watch?v=5wRPin4oxCo</a> <br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   .<br>
</a><br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr497554/index.html">IntelliJ IDEA 2020.1: Java 14, analyse du flux de données dans le débogueur, le nouveau mode LightEdit et bien plus encore</a></li>
<li><a href="../fr497558/index.html">Nous enseignons la physique avec un enfant nous-mêmes, pour que tout le monde soit intéressé</a></li>
<li><a href="../fr497560/index.html">Comment la quarantaine affecte le marché du travail dans les TI</a></li>
<li><a href="../fr497562/index.html">Mitap: restez à la maison et GOnline</a></li>
<li><a href="../fr497564/index.html">Local Hack Day - Hackathon en ligne</a></li>
<li><a href="../fr497568/index.html">Comment les employés de LANIT travaillent dans des sites éloignés en Italie et en Biélorussie</a></li>
<li><a href="../fr497570/index.html">Bases de données dans la plate-forme IIoT: comment Mail.ru Cloud Solutions fonctionne avec des pétaoctets de données provenant de plusieurs appareils</a></li>
<li><a href="../fr497572/index.html">Gestion de l'état orientée service avec Lamp-Luwak</a></li>
<li><a href="../fr497574/index.html">L'oncologie dans le contexte de la pandémie de COVID-19: comment sauver un maximum de vies</a></li>
<li><a href="../fr497578/index.html">AMD s'engage à gagner une part significative du marché des datacenters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>