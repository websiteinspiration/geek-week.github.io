<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üèè ‚ÜôÔ∏è üàÇÔ∏è 3D graphics on the STM32F103 üßìüèø üïõ üôãüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A short story about how to shove the non-editable and display real-time three-dimensional graphics using a controller that has neither speed nor memor...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>3D graphics on the STM32F103</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/496046/"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/cf8/e1c/7e5cf8e1c0fbc2ee47c87c71d72e865f.jpg" alt="image"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A short story about how to shove the non-editable and display real-time three-dimensional graphics using a controller that has neither speed nor memory for this.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Back in 2017 (judging by the file modification date), I decided to switch from AVR controllers to more powerful STM32s. Naturally, the first controller was the widely-publicized F103. It is no less natural that the use of off-the-shelf debug boards was rejected in favor of manufacturing one from scratch in accordance with its requirements. Oddly enough, there were almost no jambs (except that UART1 should be brought to a normal connector, and not crutched on wiring).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Compared with AVR, the characteristics of the stone are pretty decent: 72 MHz clock (in practice, you can overclock to 100 MHz, or even more, but only at your own peril and risk!), 20 kB of RAM and 64 kB of flash. Plus, a ton of peripherals, when using which the main problem is not to be afraid of this abundance and realize that you do not need to shovel all ten registers to start, it is enough to set three bits in the right ones. At least until you want something strange.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the first euphoria from the possession of such power passed, a desire arose to probe its limits. As an effective example, I chose the calculation of three-dimensional graphics with all these matrices, lighting, polygonal models and a Z-buffer with a 320x240 display on the ili9341 controller. The two most obvious problems to be solved are speed and volume. A screen size of 320x240 at 16 bits per color gives 150 kB per frame. But the total RAM we have is only 20 kB ... And these 150 kB must be transferred to the display at least 10 times per second, that is, the exchange rate should be at least 1.5 MB / s or 12 MB / s, which already looks like a significant load on the core. Fortunately, in this controller there is an RAP module (direct access to memory, aka Direct Memory Access, DMA), which allows you not to load the kernel with transfusion operations from empty to empty.That is, you can prepare a buffer, tell the module ‚Äúhere you have the data buffer, work!‚Äù, And at this time prepare the data for the next transfer. And taking into account the ability of the display to receive data in a stream, the following algorithm emerges: the front buffer is highlighted, from which the DMA transfers data to the display, the back buffer into which the rendering takes place, and the Z-buffer used for cutting in depth. Buffers are a single row (or column, whatever) of the display. And instead of 150 kB, we need only 1920 bytes (320 pixels per line * 3 buffers * 2 bytes per point), which fits perfectly in memory. The second hack is based on the fact that the calculation of transformation matrices and vertex coordinates cannot be performed for each row, otherwise the image will be distorted in the most bizarre ways, and it‚Äôs disadvantageous in speed. Instead, "external" calculations,that is, the multiplication of transformation matrices and their application to the vertices are recalculated on each frame, and then converted to an intermediate representation, which is optimized for rendering in a 320x1 picture.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For hooligan reasons, the library will resemble OpenGL from the outside. As in the original OpenGL, rendering begins with the formation of the transformation matrix - clearing glLoadIdentity () makes the current matrix unit, then a set of transformations glRotateXY (...), glTranslate (...), each of which is multiplied by the current matrix. Since these calculations will be carried out only once per frame, there are no special speed requirements; simple floats can be dispensed with without perversions with fixed-point numbers. The matrix itself is an array of float [4] [4], mapped to a one-dimensional array of float [16] - in fact, this method is usually used for dynamic arrays, but you can also get a little benefit from static arrays. Another standard hack: instead of constantly calculating sines and cosines, which are many in the rotation matrices,count them in advance and write them on the tablet. To do this, divide the full circle into 256 parts, calculate the sine value for each and dump it into the sin_table [] array. Well, anyone from school can get the cosine from the sine. It should be noted that the rotation functions take an angle not in radians, but in fractions of a full revolution, after reduction to the range [0 ... 255]. However, ‚Äúhonest‚Äù functions have been implemented that perform the conversion from angle to lobes under the hood.performing conversion from angle to lobes under the hood.performing conversion from angle to lobes under the hood.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the matrix is ‚Äã‚Äãready, you can start drawing the primitives. In general, in three-dimensional graphics there are three types of primitives - a point, a line and a triangle. But if we are interested in polygonal models, attention should be paid only to the triangle. Its "rendering" occurs in the function glDrawTriangle () or glDrawTriangleV (). The word "rendering" is enclosed in quotation marks because no rendering occurs at this stage. We just multiply all the points of the primitive by the transformation matrix, and then we extract from them the analytical formulas of the edges y = ky * x + by, which allow us to find the intersections of all three edges of the triangle with the current output line. We discard one of them, since it lies not on the interval between the vertices, but on its continuation.That is, to draw a frame, you just need to go through all the lines and for each paint the area between the intersection points. But if you apply this algorithm ‚Äúhead-on‚Äù, each primitive will overlap those that were drawn earlier. We need to consider the Z-coordinate (depth) so that the triangles intersect beautifully. Instead of simply printing point by point, we will consider its Z-coordinate and, in comparison with the Z-coordinate stored in the depth buffer, either output (updating the Z-buffer) or ignore it. And to calculate the Z-coordinate of each point of the line of interest to us, we use the same straight line formula z = kz * y + bz calculated by the same two intersection points with edges. As a result, the object of the ‚Äúsemi-finished‚Äù triangle struct glTriangle consists of three X-coordinates of the vertices (there is no sense in storing the Y and Z-coordinates, they will be calculated) and k,b direct coefficients, well, color to the heap. Here, in contrast to the calculation of transformation matrices, the speed is critical, so we already use fixed-point numbers. Moreover, if for the term b, the same accuracy is sufficient as for the coordinates (2 bytes), then the accuracy of the factor k, the greater the better, so we take 4 bytes. But not a float, since working with integers is still faster, even with the same size.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, by calling a bunch of glDrawTriangle () we prepared an array of semi-finished triangles. In my implementation, triangles are deduced one at a time by explicit function calls. In fact, it would be logical to have an array of triangles with the addresses of the vertices, but here I decided not to complicate. Anyway, the rendering function is written by robots, and it does not matter to them whether to fill out a constant array or write three hundred identical calls. It's time to translate the semi-finished products of the triangles into a beautiful picture on the screen. To do this, the glSwapBuffers () function is called. As described above, it goes through the lines of the display, searches for each intersection point with all the triangles, and draws segments in accordance with depth filtering. After rendering each line, you need to send this line to the display. To do this, DMA is launched, which indicates the address of the string and its size.In the meantime, DMA works, you can switch to another buffer and render the next line. The main thing is not to forget to wait for the end of the transfer if you suddenly finished rendering earlier. To visualize the ratio of speeds, I added the inclusion of a red LED after the end of rendering and off after completion of the DMA wait. It turns out something like PWM, which adjusts the brightness depending on the latency. Theoretically, instead of a ‚Äúdumb" wait, DMA interrupts could be used, but then I could not use them, and the algorithm would have become much more complicated. For a demo program, this is redundant.To visualize the ratio of speeds, I added the inclusion of a red LED after rendering, and off after completion of the DMA wait. It turns out something like PWM, which adjusts the brightness depending on the latency. Theoretically, instead of a ‚Äúdumb‚Äù wait, DMA interrupts could be used, but then I could not use them, and the algorithm would have become much more complicated. For a demo program, this is redundant.To visualize the ratio of speeds, I added the inclusion of a red LED after the end of rendering and off after completion of the DMA wait. It turns out something like PWM, which adjusts the brightness depending on the latency. Theoretically, instead of a ‚Äúdumb" wait, DMA interrupts could be used, but then I could not use them, and the algorithm would have become much more complicated. For a demo program, this is redundant.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The result of the above procedures was a rotating picture of three intersecting planes of different colors, and with a fairly decent speed: the brightness of the red LED is quite high, which indicates a large margin in kernel performance.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Well, if the core is idle, you need to load it. And we will load it with better models. However, do not forget that the memory is still very limited, so the controller will not pull too many polygons physically. The simplest calculation showed that after subtracting the memory on the line buffer and the like, there was a place for 378 triangles. As practice has shown, models from the old but interesting Gothic game are perfect for this size. Actually, the models of a snake and a blood fly were pulled out from there (and already at the time of writing this article and a glocoor, flaunting on KDPV), after which the controller ran out of flash memory. But game models are not intended for use by a microcontroller.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's say they contain animation, textures and the like, which is not useful to us, and does not fit in memory. Fortunately, blender allows not only to save them to * .obj, which is more amenable to parsing, but also to reduce the number of polygons if necessary. Further, with the help of a simple self-written program obj2arr * .obj, the files are sorted into coordinates, from which a * .h file is subsequently formed for direct inclusion in the firmware.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But for now, the models look just like plain curly blots. On the test model, this did not bother us, since all the faces were painted in their own colors, but do not prescribe the same colors to each polygon of the model. No, you can, of course, paint a fly in random colors, but it will look pretty out of the blue, I checked. Especially when the colors also change on each frame ... Instead, apply another drop of vector magic and add lighting. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The calculation of lighting in its primitive version consists in calculating the scalar product of the normal and direction to the light source, followed by multiplying by the ‚Äúnative‚Äù color of the face.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We now have three models - two from the game and one test, from which we started. To switch them, we will use one of the two buttons soldered on the board. At the same time, you can add control over the processor. We already have one control - a red LED associated with DMA latency. And the second, green, LED, we will blink with each frame update - so we can estimate the frame rate. For the naked eye, it was about 15 fps.</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/afyTgpuA6sc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In general, I am satisfied with the result: it‚Äôs nice to implement something that is fundamentally impossible to solve head on. </font><font style="vertical-align: inherit;">Of course, there is still much to optimize and improve, but there is little point in this. </font><font style="vertical-align: inherit;">Objectively, the controller for three-dimensional graphics is weak, and it‚Äôs not even about speed, but rather RAM. </font><font style="vertical-align: inherit;">However, like any demoscene sample, this project is valuable not by the result, but by the process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If someone is suddenly interested, the source code is available </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en496036/index.html">Open source: CI / CD and Avito test infrastructure for Android</a></li>
<li><a href="../en496038/index.html">Bilirubin - the molecule responsible for jaundice</a></li>
<li><a href="../en496040/index.html">10 Zen Lifehacks</a></li>
<li><a href="../en496042/index.html">Habr, I will not inform you of errors on your site</a></li>
<li><a href="../en496044/index.html">Launch of spacecraft and ... weather in the regions</a></li>
<li><a href="../en496050/index.html">Tigers and Lions get coronavirus in New York</a></li>
<li><a href="../en496052/index.html">How can a service company avoid fines from a customer? A couple of unobvious advantages of process automation</a></li>
<li><a href="../en496056/index.html">Digital: how numbers and terms deceive us</a></li>
<li><a href="../en496058/index.html">Why it is necessary to robotic agricultural combines, what are the difficulties, and how we did it in two years</a></li>
<li><a href="../en496064/index.html">Laser "blaster" operating model</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>