<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚è≤Ô∏è üçñ üéÖ C # Implementations in C # .NET üë©‚Äçüî¨ ü•¢ üë∞üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! In anticipation of the start of the course "C # ASP.NET Core Developer" , we prepared a translation of interesting material on the implem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>C # Implementations in C # .NET</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/502974/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello, Habr! </font><font style="vertical-align: inherit;">In anticipation of the start of the course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"C # ASP.NET Core Developer"</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , we prepared a translation of interesting material on the implementation of the cache in C #. </font><font style="vertical-align: inherit;">Enjoy reading.</font></font></b></i><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One of the most commonly used patterns in software development is </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caching</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is a simple and, at the same time, very effective concept. The idea is to reuse the results of operations performed. After a time-consuming operation, we save the result in our </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cache container</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The next time we need this result, we will extract it from the cache container, instead of having to perform a laborious operation again. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For example, to get a user avatar, you may have to request it from the database. Instead of executing the request with each call, we will store this avatar in the cache, extracting it from memory every time you need it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caching is great for data that changes infrequently. </font><font style="vertical-align: inherit;">Or, ideally, they never change. </font><font style="vertical-align: inherit;">Data that is constantly changing, for example, the current time, should not be cached, otherwise you run the risk of getting incorrect results.</font></font><a name="habracut"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Local cache, persistent local cache, and distributed cache</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are 3 types of caches:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In-Memory Cache is used for cases when you just need to implement the cache in one process. </font><font style="vertical-align: inherit;">When a process dies, the cache dies with it. </font><font style="vertical-align: inherit;">If you are running the same process on multiple servers, you will have a separate cache for each server.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persistent in-process Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - this is when you back up the cache outside the process memory. </font><font style="vertical-align: inherit;">It can be located in a file or in a database. </font><font style="vertical-align: inherit;">It is more complex than the cache in memory, but if your process restarts, the cache is not flushed. </font><font style="vertical-align: inherit;">Best suited for cases where getting a cached item is expensive and your process tends to restart frequently.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distributed Cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is when you need a shared cache for multiple machines. </font><font style="vertical-align: inherit;">Usually these are several servers. </font><font style="vertical-align: inherit;">The distributed cache is stored in an external service. </font><font style="vertical-align: inherit;">This means that if one server has retained a cache element, other servers can also use it. </font><font style="vertical-align: inherit;">Services like </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Redis</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are great for this.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
We will only talk about the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">local cache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Primitive implementation</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's start by creating a very simple cache implementation in C #:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NaiveCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    Dictionary&lt;<span class="hljs-keyword">object</span>, TItem&gt; _cache = <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-keyword">object</span>, TItem&gt;();<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        <span class="hljs-keyword">if</span> (!_cache.ContainsKey(key))<font></font>
        {<font></font>
            _cache[key] = createItem();<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> _cache[key];<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> NaiveCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar = _avatarCache.GetOrCreate(userId, () =&gt; _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This simple code solves an important problem. To get a user avatar, only the first request will be the actual request from the database. The avatar data ( </font></font><code>byte []</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) by the result of the request is stored in the process memory. All subsequent avatar requests will retrieve it from memory, saving time and resources. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But, like most things in programming, things are not so simple. The above implementation is not a good solution for a number of reasons. On the one hand, this implementation is not </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread safe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . When used from multiple threads, exceptions may occur. In addition, cached items will remain in memory forever, which is actually very bad. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is why we should remove items from the cache:</font></font></b><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A cache can start to take up a lot of memory, which ultimately leads to exceptions due to its shortage and crashes.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">High memory consumption can lead to memory pressure (also known as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GC Pressure</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">In this state, the garbage collector works much more than it should, which reduces performance.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cache may need to be updated when data changes. </font><font style="vertical-align: inherit;">Our caching infrastructure must support this feature.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To solve these problems exist in the frameworks </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">of displacement policies</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (also known as </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the removal of policy - Eviction / Removal policies</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">These are the rules for removing items from the cache according to the given logic. </font><font style="vertical-align: inherit;">Among the common removal policies are the following:</font></font><br>
<br>
<ul>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">An Absolute Expiration policy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that removes an item from the cache after a fixed amount of time, no matter what.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A Sliding Expiration policy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that removes an item from the cache if it has not been accessed for a certain period of time. </font><font style="vertical-align: inherit;">That is, if I set the expiration time to 1 minute, the item will remain in the cache while I use it every 30 seconds. </font><font style="vertical-align: inherit;">If I do not use it for more than a minute, the item will be deleted.</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Size Limit policy</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which will limit the size of the cache.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now that we‚Äôve figured out everything we need, let's move on to better solutions.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Better Solutions</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To my great disappointment as a blogger, Microsoft has already created a wonderful cache implementation. </font><font style="vertical-align: inherit;">This deprived me of the pleasure of creating a similar implementation myself, but at least the writing of this article is also less. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will show you a Microsoft solution, how to use it effectively, and then how to improve it for some scenarios.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">System.Runtime.Caching / MemoryCache vs Microsoft.Extensions.Caching.Memory</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Microsoft has 2 solutions, 2 different NuGet caching packages. </font><font style="vertical-align: inherit;">Both are great. </font><font style="vertical-align: inherit;">According to the </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recommendations of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Microsoft, it is preferable to use </font></font><code>Microsoft.Extensions.Caching.Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, because it integrates better with Asp. </font><font style="vertical-align: inherit;">NET Core. </font><font style="vertical-align: inherit;">It can be </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">easily</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> integrated into the Asp .NET Core dependency injection mechanism. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is a simple example with </font></font><code>Microsoft.Extensions.Caching.Memory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMemoryCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions());<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry)) <span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            <span class="hljs-comment">//    ,   .</span><font></font>
            cacheEntry = createItem();<font></font>
            <font></font>
            <span class="hljs-comment">//    . </span><font></font>
            _cache.Set(key, cacheEntry);<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> SimpleMemoryCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar = _avatarCache.GetOrCreate(userId, () =&gt; _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It is very reminiscent of my own </font></font><code>NaiveCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so what has changed? </font><font style="vertical-align: inherit;">Well, firstly, it's a </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">thread safe</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementation. </font><font style="vertical-align: inherit;">You can safely call it from multiple threads at once. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secondly, it </font></font><code>MemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">takes into account all the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crowding-out policies</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that we spoke about earlier. </font><font style="vertical-align: inherit;">Here is an example: </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IMemoryCache with preemption policies:</font></font></b><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MemoryCacheWithPolicy</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions()<font></font>
    {<font></font>
        SizeLimit = <span class="hljs-number">1024</span><font></font>
    });<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> TItem <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;TItem&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            <span class="hljs-comment">//    ,   . </span><font></font>
            cacheEntry = createItem();<font></font>
 <font></font>
            <span class="hljs-keyword">var</span> cacheEntryOptions = <span class="hljs-keyword">new</span> MemoryCacheEntryOptions()<font></font>
         	.SetSize(<span class="hljs-number">1</span>)<span class="hljs-comment">// </span>
         	<span class="hljs-comment">//        (  )</span><font></font>
                .SetPriority(CacheItemPriority.High)<font></font>
                <span class="hljs-comment">//       ,    .</span>
                 .SetSlidingExpiration(TimeSpan.FromSeconds(<span class="hljs-number">2</span>))
                <span class="hljs-comment">//       ,    .</span>
                .SetAbsoluteExpiration(TimeSpan.FromSeconds(<span class="hljs-number">10</span>));<font></font>
 <font></font>
            <span class="hljs-comment">//    .</span><font></font>
            _cache.Set(key, cacheEntry, cacheEntryOptions);<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's analyze the new elements:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The MemoryCacheOptions has been added </font></font><code>SizeLimit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This adds a size limit policy to our cache container. </font><font style="vertical-align: inherit;">The cache does not have a mechanism for measuring the size of records. </font><font style="vertical-align: inherit;">Therefore, we need to set the size of each cache entry. </font><font style="vertical-align: inherit;">In this case, each time we set the size to 1 with </font></font><code>SetSize(1)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This means that our cache will have a limit of 1024 elements.</font></font></li>
<li>     ,      ?       <code>.SetPriority (CacheItemPriority.High)</code>.   : <b>Low (), Normal (), High ()</b>  <b>NeverRemove (  )</b>.</li>
<li><code>SetSlidingExpiration(TimeSpan.FromSeconds(2))</code>  <b>   </b>  2 .  ,         2 ,   .</li>
<li><code>SetAbsoluteExpiration(TimeSpan.FromSeconds(10))</code>  <b>   </b>  10 .  ,       10 ,      .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In addition to the options in the example, you can also set a delegate </font></font><code>RegisterPostEvictionCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that will be called when the item is deleted. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is a fairly wide range of functions, but, nevertheless, we need to think about whether there is anything else to add. </font><font style="vertical-align: inherit;">There are actually a couple of things.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Problems and missing features</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are several important parts missing from this implementation.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While you can set a size limit, caching does not actually control memory pressure. </font><font style="vertical-align: inherit;">If we monitored, we could tighten policy with high pressure and weaken policy with low.</font></font></li>
<li>         ,      .     . , ,    ,        10 .      2    ,  ,     ( ),       .</li>
</ol><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regarding the first problem of</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressure on gc: it is possible to control the pressure on gc by several methods and heuristics. </font><font style="vertical-align: inherit;">This post is not about this, but you can read my article </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúFinding, Fixing, and Preventing Memory Leaks in C # .NET: 8 Best Practices‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to learn about some useful methods. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second problem is easier to solve</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Actually, here is an implementation </font></font><code>MemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that completely solves it:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WaitToFinishMemoryCache</span>&lt;TItem&gt;<font></font>
{<font></font>
    <span class="hljs-keyword">private</span> MemoryCache _cache = <span class="hljs-keyword">new</span> MemoryCache(<span class="hljs-keyword">new</span> MemoryCacheOptions());
    <span class="hljs-keyword">private</span> ConcurrentDictionary&lt;<span class="hljs-keyword">object</span>, SemaphoreSlim&gt; _locks = <span class="hljs-keyword">new</span> ConcurrentDictionary&lt;<span class="hljs-keyword">object</span>, SemaphoreSlim&gt;();<font></font>
 <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;TItem&gt; <span class="hljs-title">GetOrCreate</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> key, Func&lt;Task&lt;TItem&gt;&gt; createItem</span>)</span><font></font>
    {<font></font>
        TItem cacheEntry;<font></font>
 <font></font>
        <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<span class="hljs-comment">//    .</span><font></font>
        {<font></font>
            SemaphoreSlim mylock = _locks.GetOrAdd(key, k =&gt; <span class="hljs-keyword">new</span> SemaphoreSlim(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<font></font>
 <font></font>
            <span class="hljs-keyword">await</span> mylock.WaitAsync();
            <span class="hljs-keyword">try</span><font></font>
            {<font></font>
                <span class="hljs-keyword">if</span> (!_cache.TryGetValue(key, <span class="hljs-keyword">out</span> cacheEntry))<font></font>
                {<font></font>
                    <span class="hljs-comment">//    ,   .</span>
                    cacheEntry = <span class="hljs-keyword">await</span> createItem();<font></font>
                    _cache.Set(key, cacheEntry);<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">finally</span><font></font>
            {<font></font>
                mylock.Release();<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> cacheEntry;<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Using:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span> _avatarCache = <span class="hljs-keyword">new</span> WaitToFinishMemoryCache&lt;<span class="hljs-keyword">byte</span>[]&gt;();
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">var</span> myAvatar =
<span class="hljs-keyword">await</span> _avatarCache.GetOrCreate(userId, <span class="hljs-keyword">async</span> () =&gt; <span class="hljs-keyword">await</span> _database.GetAvatar(userId));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this implementation, when you try to get an element, if the same element is already in the process of being created by another thread, you will wait until the first thread completes. </font><font style="vertical-align: inherit;">Then you will get an already cached item created by another thread.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code parsing</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This implementation blocks the creation of an element. </font><font style="vertical-align: inherit;">Locking occurs on a key. </font><font style="vertical-align: inherit;">For example, if we are waiting for Alexey's avatar, we can still get the cached values ‚Äã‚Äãof Zhenya or Barbara in another thread. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The dictionary </font></font><code>_locks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stores all locks. </font><font style="vertical-align: inherit;">Regular locks do not work with </font></font><code>async/await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we need to use </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SemaphoreSlim</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There are 2 checks to check if the value is already cached if </font></font><code>(!_Cache.TryGetValue(key, out cacheEntry))</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The one in the lock is the one that provides the only creation of the element. </font><font style="vertical-align: inherit;">One that is outside of the lock, for optimization.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When to use </font></font><code>WaitToFinishMemoryCache</code></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This implementation obviously has some overhead. </font><font style="vertical-align: inherit;">Let's look at when it is relevant. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Use </font></font><code>WaitToFinishMemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the creation time of an item has any value, and you want to minimize the number of creations as much as possible.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the time to create an item is very long.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When an item must be created once for each key.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Do not use </font></font><code>WaitToFinishMemoryCache</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">when:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is no danger that multiple threads will gain access to the same cache element.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You are not categorically against creating elements more than once. </font><font style="vertical-align: inherit;">For example, if one additional query to the database does not greatly affect anything.</font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Summary</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Caching is a very powerful pattern. </font><font style="vertical-align: inherit;">And also it is also dangerous and has its pitfalls. </font><font style="vertical-align: inherit;">Cache too much and you can cause pressure on the GC. </font><font style="vertical-align: inherit;">Cache too little and you can cause performance issues. </font><font style="vertical-align: inherit;">There is also distributed caching, which represents a whole new world to explore. </font><font style="vertical-align: inherit;">This is software development, there is always something new that can be mastered. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I hope you enjoyed this article. </font><font style="vertical-align: inherit;">If you are interested in memory management, my next article will focus on the dangers of pressure on the GC and how to prevent it, so </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sign up</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Enjoy your coding.</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Learn more about the course.</font></font></a><br>
<br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en502954/index.html">Sample 5 more webinar platforms</a></li>
<li><a href="../en502962/index.html">Why we will not return to the office (a look at the remote work after 2 months)</a></li>
<li><a href="../en502964/index.html">Financial nuance in the project agreement of the IT project</a></li>
<li><a href="../en502968/index.html">Data Vault Basics</a></li>
<li><a href="../en502972/index.html">SD Express: SD 8.0 & PCIe 4.0 standard. What is this and why?</a></li>
<li><a href="../en502978/index.html">Color scheme without the help of a designer</a></li>
<li><a href="../en502980/index.html">ENT and plot in non-plot games on the example of Throne: Kingdom at War</a></li>
<li><a href="../en502984/index.html">How to choose a psychologist / psychotherapist?</a></li>
<li><a href="../en502986/index.html">F #, increasing the contrast of the image by aligning the histograms</a></li>
<li><a href="../en502988/index.html">Business expert and programming. Combine cannot be shared</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>