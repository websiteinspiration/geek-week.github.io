<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚓️ 👩🏾‍🏭 🚶 Verwenden der OpenCV-Bibliothek zum Erkennen von elliptischen Bögen in 2D-Abschnitten von 3D-Punktwolken 🦏 👩🏻‍💼 🖕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Zusammenhang mit der größeren Verbreitung erschwinglicher Laserscanner (Lidars), die 3D-Punktwolken ( 3dOT ) empfangen können, und der breiteren An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Verwenden der OpenCV-Bibliothek zum Erkennen von elliptischen Bögen in 2D-Abschnitten von 3D-Punktwolken</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Zusammenhang mit der größeren Verbreitung erschwinglicher Laserscanner (Lidars), die 3D-Punktwolken ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><em><font style="vertical-align: inherit;">empfangen können,</font></em><font style="vertical-align: inherit;"> und der breiteren Anwendung dieser Technologie in verschiedenen Bereichen (vom Maschinenbau bis zur Sicherheit, von der Ölindustrie bis zur Architektur) hat das Interesse an Verarbeitungsalgorithmen wieder zugenommen Wolken von Punkten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der beliebtesten Anwendungen von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Industrie ist die Erstellung von Konstruktionsdokumentationen nur für konstruierte, alte oder umgebaute Geräte, die normalerweise aus Rohrleitungen und anderen Strukturen mit zylindrischer Geometrie bestehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um geometrische </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundelemente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><em><font style="vertical-align: inherit;">3dOT</font></em><font style="vertical-align: inherit;"> zu erkennen </font><font style="vertical-align: inherit;">, werden normalerweise spezielle 3D-Bibliotheken verwendet, z. B. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PCL</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Ansatz mit der Verwendung von vorgefertigten Bibliotheken hat neben den Vorteilen auch Nachteile. Zum Beispiel ist es schwierig, sie in bestehende Kadov-Verarbeitungsschemata zu integrieren, die normalerweise eine 2D-Dimension haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir, wie es möglich wäre, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , beispielsweise eine Pumpstation, zu verarbeiten, beginnend mit 2D-Schnitten und unter Verwendung des gesamten Arsenals der 2D-Verarbeitung, das in zuverlässigen und optimierten Bildverarbeitungsbibliotheken, beispielsweise </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verfügbar ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1. 3D-OT-Modell einer Pumpstation</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptelement der Abschnitte, die durch Scannen verschiedener Rohrstrukturen erhalten werden, sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptische Bögen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2. Horizontaler Querschnitt eines 3D-Modells einer Pumpstation auf durchschnittlicher Ebene.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Artikel beschränken wir uns auf einen Schlüsselalgorithmus, mit dem wir beliebige elliptische Bögen erkennen können. Dies ist ein iterativer Algorithmus für das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wachstum von Bogensegmenten und die Regionsbindung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regionswachstum und Kantenverknüpfung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wachstumsalgorithmen sind die offensichtlichsten und am einfachsten zu überprüfenden, wenn auch zeitaufwändigen Algorithmen im Vergleich zu statistischen Algorithmen, die besser für den Fall geeignet sind, dass die Szene lose gekoppelte, entfernte Objekte enthält, die zu einer Ellipse gehören. </font><font style="vertical-align: inherit;">Diese Algorithmen werden in zukünftigen Artikeln diskutiert.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Einfachheit halber lassen wir das Verfahren zum </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrufen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eines Abschnitts aus der </font><em><font style="vertical-align: inherit;">3dOT-Quelldatei</font></em><font style="vertical-align: inherit;"> , zum Vorverarbeiten eines Abschnitts, zum Clustering zum </font><em><font style="vertical-align: inherit;">Isolieren</font></em><font style="vertical-align: inherit;"> geometrischer </font><em><font style="vertical-align: inherit;">Grundelemente</font></em><font style="vertical-align: inherit;"> sowie zum anschließenden Binden, Korrigieren und anderen photogrammetrischen Operationen, die zum </font><em><font style="vertical-align: inherit;">Abrufen</font></em><font style="vertical-align: inherit;"> von </font><em><font style="vertical-align: inherit;">Modellparametern erforderlich sind</font></em><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">weg</font></em><font style="vertical-align: inherit;"> . Wir werden die Parametrisierung heuristischer Suchalgorithmen nicht auf die gleiche Weise diskutieren. Beschreiben wir alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grundlegenden Operationen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus denen der Algorithmus aufgebaut ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass wir in diesem Bild, das aus dem horizontalen Abschnitt der Punktwolke ausgeschnitten ist, einen elliptischen Bogen erkennen (erkennen, klassifizieren) müssen (dh die Parameter der Ellipse sowie den Anfangs- und Endwinkel des elliptischen Bogens berechnen). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3. Einer der elliptischen Bögen des Querschnitts des 3D-Modells (nach dem Glätten)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Arbeit mit dem Raster blind zu minimieren, führen wir alle Operationen mit dem Raster durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gliederung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die OpenCV </font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">findet auf der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raster </font><font style="vertical-align: inherit;">alle externen (ohne interne Formen) </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Form eines Vektors von ganzzahligen Punktvektoren (in Rasterkoordinaten):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist unsere Schlüsseloperation, die in einigen einfachen Fällen </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Aufgabe vollständig löst</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Da jedoch nicht immer entartete Fälle gefunden werden, betrachten wir die Verarbeitungstechnologie durch Konturierung genauer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die umgekehrte Operation, bei der mithilfe der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">ein Raster gemäß dem vorhandenen externen Schaltkreis generiert wird </font><font style="vertical-align: inherit;">, sieht ebenfalls einfach aus:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird auch sehr oft verwendet, um Konturen zu maskieren, zu zeichnen oder die Fläche zu berechnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher haben wir im Anfangsstadium eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von Flecken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Teile einer bestimmten Kurve), die zu einem elliptischen Bogen verbunden werden müssen, um Teile anderer Komponenten der Struktur (z. B. Befestigungselemente) oder optisches Rauschen zu eliminieren, das durch Abschatten während des Scannens und andere verursacht wird Gründe dafür. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen wir eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskriminanzfunktion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den Konturtyp (Ellipse, lineares Segment, Schraffur oder etwas anderes) sowie die Endpunkte der Kontur und ihres gedrehten Umrissrechtecks ​​zurückgibt:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verhältnis von Länge und Breite des Rechtecks ​​hilft dabei, Konturen in der Nähe von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen Segmenten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie kleine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschkonturen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schnell zu unterscheiden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das gedrehte Rechteck in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat ein </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komplexes</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinatensystem. Wenn nicht der Winkel selbst erforderlich ist, sondern seine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trigonometrischen Funktionen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ist dies aus dem Kontext umso weniger ersichtlich. Wenn der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absolutwert des Winkels verwendet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss berücksichtigt werden, dass der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkel von der Horizontalen bis zur ersten Kante des Rechtecks ​​gegen den Uhrzeigersinn gezählt wird und einen negativen Wert hat</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Endpunkte der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elliptischen Konturen werden mit unserem Verfahren ermittelt, das das </font><em><font style="vertical-align: inherit;">Mat-</font></em><font style="vertical-align: inherit;"> Raster erhält</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem diskriminierten Umriss, der durch Maskieren aus dem Originalbild extrahiert wird und den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximalen Fehler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zurückgibt </font><font style="vertical-align: inherit;">:</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, … );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptcode für diese Funktion besteht darin, zwei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prozeduren aufzurufen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Verfahren findet ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konvexes Polygon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> für die untersuchte Kontur, das zweite - berechnet alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexitätsfehler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den größten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defekt in Bezug auf die Konvexität, wenn man bedenkt, dass er die Endpunkte der Kontur bestimmt. Dies ist möglicherweise nicht der Fall, wenn die äußeren oder inneren Grenzen der Kontur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale aufweisen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um sie zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glätten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenden wir eine zusätzliche Glättung auf die zu untersuchende Kontur an (und nicht auf das gesamte Bild, um die Landenschen zwischen den Konturen nicht zu „verwischen“ und die ursprüngliche Topologie nicht zu verletzen). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4. Berechnung des Ausbuchtungsdefekts. </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert fälschlicherweise den roten Endpunkt. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endpunkte werden korrekt definiert. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert die Endpunkte in der ursprünglichen Form neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da in der Technologie , die </font><font style="vertical-align: inherit;">wir angenommen, wird die Schaltung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regeneriert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Mal </font><font style="vertical-align: inherit;">, haben wir Neusuche für die Punkte der Übereinstimmung (oder besser gesagt, deren Indizes) durch die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erschöpfende Suche</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">:</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Für Fälle, in denen es nicht möglich ist, die Merkmale vollständig zu entfernen, wurde auch ein zusätzlicher Modus der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtbogentrennung</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">(separat mit dem internen / externen Lichtbogen arbeiten). Dies ist beispielsweise in Fällen wichtig, in denen der äußere Bogen der Kontur </font><font style="vertical-align: inherit;">mit anderen Objekten </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontakt steht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrauscht ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In diesem Fall können Sie mit dem internen Lichtbogen arbeiten. In diesem Fall ist es nicht erforderlich, die externen und internen Lichtbögen getrennt zu verarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gemäß der bekannten Formel für das Verhältnis der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexität des Bogens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radius des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kreises </font><font style="vertical-align: inherit;">ungefähr geschätzt </font><font style="vertical-align: inherit;">und zu große Ellipsen werden verworfen:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wurde für alle Konturen ihre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexitätsdefektmetrik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gefunden </font><font style="vertical-align: inherit;">(oder sie werden als linear oder klein klassifiziert und aus dem Verfahren entfernt). </font><font style="vertical-align: inherit;">In der letzten Phase werden der ursprünglichen Metrik zusätzliche Parameter hinzugefügt, z. B. der gedrehte Bemaßungsparameter usw., und der gesamte Satz der untersuchten Metriken wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Größe sortiert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus zum Verknüpfen von Bogensegmenten an Endpunkten</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wachstumsalgorithmus ist klar und offensichtlich: Wir nehmen die größte Kontur als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und versuchen, sie zu züchten, dh die nächstgelegenen Flecken zu finden und an ihren Endpunkten anzubringen, die die Wachstumsbedingungen erfüllen. In der gewachsenen Figur geben wir den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gewünschten elliptischen Bogen ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Maskieren und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtrahieren Sie die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Figur vom Originalsatz. Wir wiederholen den Wachstumsvorgang, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis der anfängliche Satz abgelaufen ist</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das grundlegende Verfahren des Wachstumsalgorithmus sieht folgendermaßen aus:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die untersuchte Kontur, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Konvexitätsfehler, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rumpf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das konvexe Polygon der gesamten Region, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Hilfspuffermatrix. Am Ausgang erhalten wir eine vektorgewachsene Kontur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren besteht aus einem Zyklus von Versuchen, das Wachstum zu säen, der entweder durch Erschöpfung der verfügbaren Patches für das Wachstum endet oder durch den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter der maximalen Anzahl von Iterationen begrenzt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 5. Viele Flecken für das Wachstum ohne Samen Die</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hauptschwierigkeit besteht darin, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flecken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auszuwählen, die </font><font style="vertical-align: inherit;">den Endpunkten der Kontur </font><font style="vertical-align: inherit;">am </font><i><font style="vertical-align: inherit;">nächsten liegen</font></i><font style="vertical-align: inherit;"> , sodass die Figur nur nach </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorne</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wächst </font><font style="vertical-align: inherit;">. Für </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangentiale Richtung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nehmen die gemittelte Linie, die zum Bogen in der Nähe des Endpunkts gehört. In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden die Kandidaten für die Verbindung mit dem Startwert bei einer bestimmten Iteration angezeigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6. Samen, umgeben von mehreren Wachstumskandidaten-Patches.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Für jedes Kandidaten-Patch wird die folgende Metrik berechnet:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden nur Flecken berücksichtigt, die in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangentialkegel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fallen </font><font style="vertical-align: inherit;">. Dann wird </font><font style="vertical-align: inherit;">der Patch mit dem geringsten Abstand gewählt wird , </font><font style="vertical-align: inherit;">und durch Aufdrucken der Verbindungsabschnitt in das Raster, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbindet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem entsprechenden Ende des Samens. Für das andere Ende des Seeds wird ein Patch gesucht, der den Parametern entspricht, und wenn es gefunden wird, wird es auch mit dem Seed verbunden. Dann wird der Samen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maskiert und</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von den vielen Flecken </font><i><font style="vertical-align: inherit;">abgezogen</font></i><font style="vertical-align: inherit;"> . Der Vorgang wird von Anfang an wiederholt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Wachstumsvorgangs haben wir einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptischen Bogen erhalten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der noch überprüft werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie zunächst das Standard- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Prozedur, die unser Patch empfängt (in Form eines Pfads erinnern wir uns, dass der Pfad und das Raster mit uns austauschbar sind) und gibt die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gedrehte Dimension zurück</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh eine vollständige Ellipse.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann lehnen wir zu große und zu kleine Ellipsen ab und wenden dann unser ursprüngliches Verfahren zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen der Bereiche des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resultierenden elliptischen Bogens und des anfänglichen Wachstumsfelds in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rasterform an</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Prozedur enthält einige getarnte Tricks, daher werden wir ihre Beschreibung vorerst weglassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schließlich finden wir die verbleibenden Parameter der erkannten Ellipse - den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start- und </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endwinkel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (die Halbachsen kennen wir bereits aus </font><em><font style="vertical-align: inherit;">fitEllipse</font></em><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Start- und Endwinkel zu bestimmen, gehen wir wie folgt vor: Wir transformieren unsere vollständige Ellipse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zurück zum Polygon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und finden durch direkte Aufzählung die Punkte, die unseren Enden am nächsten liegen. Ihre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkelkoordinaten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in der Tat Indizes) und sind die Start- und Endwinkel eines elliptischen Bogens. </font><font style="vertical-align: inherit;">Im Code sieht es so aus (etwas vereinfacht):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">berücksichtigt die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topologie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font><font style="vertical-align: inherit;">elliptischen </font><em><font style="vertical-align: inherit;">Bogenquerung</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Insgesamt sollten acht mögliche Fälle der Umgehung der Indizes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berücksichtigt werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gehen wir entlang der äußeren oder der inneren Kontur, und welcher der Indizes ist größer, anfänglich oder endgültig? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einfacher zu erkennender Code:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Ergebnisse der Erkennung von Ellipsen in komplexen Fällen sind in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 7 dargestellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den folgenden Artikeln werden statistische Nachweismethoden betrachtet.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490386/index.html">Wie man sonst an der Börse Geld verdient und das Risiko reduziert: Aktien von Unternehmen mit Dividendenzahlung</a></li>
<li><a href="../de490390/index.html">Olga Makushenko, Geschäftsführerin von 101XP: „5 wichtige Fehler bei der Entwicklung eines Spiels als Unternehmen“</a></li>
<li><a href="../de490392/index.html">Catchain: TON Blockchain-Konsensalgorithmus</a></li>
<li><a href="../de490394/index.html">Commodore Amiga 500+: Lass niemanden beleidigt gehen</a></li>
<li><a href="../de490398/index.html">Red Hogwarts. Offiziere oder warum ein Historiker wie ein Detektiv ist</a></li>
<li><a href="../de490404/index.html">Warum und wie 5G alles verändern wird: Technologie, schrittweise Implementierung und Elementbasis für Teilnehmergeräte</a></li>
<li><a href="../de490406/index.html">Unaussprechlich attraktiv: Wie wir einen Haniot geschaffen haben, der nicht entlarvt werden kann</a></li>
<li><a href="../de490408/index.html">FreeBSD: Viel besser als GNU / Linux</a></li>
<li><a href="../de490410/index.html">Lebende und künstliche Neuronen, die über das Internet verbunden sind</a></li>
<li><a href="../de490412/index.html">Vielleicht sollten wir uns mit JavaScript etwas beruhigen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>