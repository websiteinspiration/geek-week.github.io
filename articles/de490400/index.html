<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öìÔ∏è üë©üèæ‚Äçüè≠ üö∂ Verwenden der OpenCV-Bibliothek zum Erkennen von elliptischen B√∂gen in 2D-Abschnitten von 3D-Punktwolken ü¶è üë©üèª‚Äçüíº üñïüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Zusammenhang mit der gr√∂√üeren Verbreitung erschwinglicher Laserscanner (Lidars), die 3D-Punktwolken ( 3dOT ) empfangen k√∂nnen, und der breiteren An...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Verwenden der OpenCV-Bibliothek zum Erkennen von elliptischen B√∂gen in 2D-Abschnitten von 3D-Punktwolken</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490400/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Zusammenhang mit der gr√∂√üeren Verbreitung erschwinglicher Laserscanner (Lidars), die 3D-Punktwolken ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font><em><font style="vertical-align: inherit;">empfangen k√∂nnen,</font></em><font style="vertical-align: inherit;"> und der breiteren Anwendung dieser Technologie in verschiedenen Bereichen (vom Maschinenbau bis zur Sicherheit, von der √ñlindustrie bis zur Architektur) hat das Interesse an Verarbeitungsalgorithmen wieder zugenommen Wolken von Punkten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eine der beliebtesten Anwendungen von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3d</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in der Industrie ist die Erstellung von Konstruktionsdokumentationen nur f√ºr konstruierte, alte oder umgebaute Ger√§te, die normalerweise aus Rohrleitungen und anderen Strukturen mit zylindrischer Geometrie bestehen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um geometrische </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Grundelemente</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in </font><em><font style="vertical-align: inherit;">3dOT</font></em><font style="vertical-align: inherit;"> zu erkennen </font><font style="vertical-align: inherit;">, werden normalerweise spezielle 3D-Bibliotheken verwendet, z. B. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft PCL</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Ansatz mit der Verwendung von vorgefertigten Bibliotheken hat neben den Vorteilen auch Nachteile. Zum Beispiel ist es schwierig, sie in bestehende Kadov-Verarbeitungsschemata zu integrieren, die normalerweise eine 2D-Dimension haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Betrachten wir, wie es m√∂glich w√§re, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3dOT</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , beispielsweise eine Pumpstation, zu verarbeiten, beginnend mit 2D-Schnitten und unter Verwendung des gesamten Arsenals der 2D-Verarbeitung, das in zuverl√§ssigen und optimierten Bildverarbeitungsbibliotheken, beispielsweise </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> verf√ºgbar ist </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/c2/bu/-i/c2bu-isuyb45ji2pz_6nibzg8zi.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 1. 3D-OT-Modell einer Pumpstation</font></font></i><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Hauptelement der Abschnitte, die durch Scannen verschiedener Rohrstrukturen erhalten werden, sind </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptische B√∂gen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8w/zl/2h/8wzl2hcgbhlmexqxdvl6ezottgm.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 2. Horizontaler Querschnitt eines 3D-Modells einer Pumpstation auf durchschnittlicher Ebene.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In diesem Artikel beschr√§nken wir uns auf einen Schl√ºsselalgorithmus, mit dem wir beliebige elliptische B√∂gen erkennen k√∂nnen. Dies ist ein iterativer Algorithmus f√ºr das </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wachstum von Bogensegmenten und die Regionsbindung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Regionswachstum und Kantenverkn√ºpfung</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wachstumsalgorithmen sind die offensichtlichsten und am einfachsten zu √ºberpr√ºfenden, wenn auch zeitaufw√§ndigen Algorithmen im Vergleich zu statistischen Algorithmen, die besser f√ºr den Fall geeignet sind, dass die Szene lose gekoppelte, entfernte Objekte enth√§lt, die zu einer Ellipse geh√∂ren. </font><font style="vertical-align: inherit;">Diese Algorithmen werden in zuk√ºnftigen Artikeln diskutiert.</font></font><br>
<br>
</p><h4>  </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Einfachheit halber lassen wir das Verfahren zum </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abrufen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> eines Abschnitts aus der </font><em><font style="vertical-align: inherit;">3dOT-Quelldatei</font></em><font style="vertical-align: inherit;"> , zum Vorverarbeiten eines Abschnitts, zum Clustering zum </font><em><font style="vertical-align: inherit;">Isolieren</font></em><font style="vertical-align: inherit;"> geometrischer </font><em><font style="vertical-align: inherit;">Grundelemente</font></em><font style="vertical-align: inherit;"> sowie zum anschlie√üenden Binden, Korrigieren und anderen photogrammetrischen Operationen, die zum </font><em><font style="vertical-align: inherit;">Abrufen</font></em><font style="vertical-align: inherit;"> von </font><em><font style="vertical-align: inherit;">Modellparametern erforderlich sind</font></em><font style="vertical-align: inherit;"> , </font><em><font style="vertical-align: inherit;">weg</font></em><font style="vertical-align: inherit;"> . Wir werden die Parametrisierung heuristischer Suchalgorithmen nicht auf die gleiche Weise diskutieren. Beschreiben wir alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">grundlegenden Operationen,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> aus denen der Algorithmus aufgebaut ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir gehen davon aus, dass wir in diesem Bild, das aus dem horizontalen Abschnitt der Punktwolke ausgeschnitten ist, einen elliptischen Bogen erkennen (erkennen, klassifizieren) m√ºssen (dh die Parameter der Ellipse sowie den Anfangs- und Endwinkel des elliptischen Bogens berechnen). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/co/rj/km/corjkmmhyxcxvrnex89_iex1aei.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 3. Einer der elliptischen B√∂gen des Querschnitts des 3D-Modells (nach dem Gl√§tten)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Arbeit mit dem Raster blind zu minimieren, f√ºhren wir alle Operationen mit dem Raster durch </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gliederung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> durch </font><font style="vertical-align: inherit;">. </font></font><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die OpenCV </font></font></em><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">findContours</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">findet auf der </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matte</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> raster </font><font style="vertical-align: inherit;">alle externen (ohne interne Formen) </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konturen</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Form eines Vektors von ganzzahligen Punktvektoren (in Rasterkoordinaten):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">Mat <span class="hljs-title">mat</span><span class="hljs-params">(size)</span></span>;
 <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;Point&gt;&gt; contours;<font></font>
 findContours(mat, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist unsere Schl√ºsseloperation, die in einigen einfachen F√§llen </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Aufgabe vollst√§ndig l√∂st</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Da jedoch nicht immer entartete F√§lle gefunden werden, betrachten wir die Verarbeitungstechnologie durch Konturierung genauer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die umgekehrte Operation, bei der mithilfe der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Funktion </font><font style="vertical-align: inherit;">ein Raster gem√§√ü dem vorhandenen externen Schaltkreis generiert wird </font><font style="vertical-align: inherit;">, sieht ebenfalls einfach aus:</font></font><br>
<pre><code class="cpp hljs"> drawContours(mat, contours, <span class="hljs-number">-1</span>, Scalar(<span class="hljs-number">255</span>), <span class="hljs-number">-1</span>);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird auch sehr oft verwendet, um Konturen zu maskieren, zu zeichnen oder die Fl√§che zu berechnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Daher haben wir im Anfangsstadium eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reihe von Flecken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (Teile einer bestimmten Kurve), die zu einem elliptischen Bogen verbunden werden m√ºssen, um Teile anderer Komponenten der Struktur (z. B. Befestigungselemente) oder optisches Rauschen zu eliminieren, das durch Abschatten w√§hrend des Scannens und andere verursacht wird Gr√ºnde daf√ºr. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Erstellen wir eine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskriminanzfunktion</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , die den Konturtyp (Ellipse, lineares Segment, Schraffur oder etwas anderes) sowie die Endpunkte der Kontur und ihres gedrehten Umrissrechtecks ‚Äã‚Äãzur√ºckgibt:</font></font><br>
<pre><code class="cpp hljs"> contourTypeSearch(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, Vec4i &amp;def, RotatedRect &amp;rc);
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verh√§ltnis von L√§nge und Breite des Rechtecks ‚Äã‚Äãhilft dabei, Konturen in der N√§he von </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">linearen Segmenten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sowie kleine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rauschkonturen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schnell zu unterscheiden </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das gedrehte Rechteck in </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hat ein </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">komplexes</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Koordinatensystem. Wenn nicht der Winkel selbst erforderlich ist, sondern seine </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trigonometrischen Funktionen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ist dies aus dem Kontext umso weniger ersichtlich. Wenn der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absolutwert des Winkels verwendet wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , muss ber√ºcksichtigt werden, dass der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkel von der Horizontalen bis zur ersten Kante des Rechtecks ‚Äã‚Äãgegen den Uhrzeigersinn gez√§hlt wird und einen negativen Wert hat</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Endpunkte der</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> elliptischen Konturen werden mit unserem Verfahren ermittelt, das das </font><em><font style="vertical-align: inherit;">Mat-</font></em><font style="vertical-align: inherit;"> Raster erh√§lt</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mit einem diskriminierten Umriss, der durch Maskieren aus dem Originalbild extrahiert wird und den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximalen Fehler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zur√ºckgibt </font><font style="vertical-align: inherit;">:</font></font><br>
<pre><code class="cpp hljs"> contourConvFeature(mat, &amp;def, ‚Ä¶ );</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Hauptcode f√ºr diese Funktion besteht darin, zwei </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prozeduren aufzurufen </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; *hull = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;();<font></font>
 convexHull(contour, *hull);<font></font>
 <span class="hljs-built_in">vector</span>&lt;Vec4i&gt; *defs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">vector</span>&lt;Vec4i&gt;();<font></font>
 convexityDefects(contour, *hull, *defs);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das erste Verfahren findet ein </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">konvexes Polygon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> f√ºr die untersuchte Kontur, das zweite - berechnet alle </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexit√§tsfehler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wir nehmen nur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den gr√∂√üten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Defekt in Bezug auf die Konvexit√§t, wenn man bedenkt, dass er die Endpunkte der Kontur bestimmt. Dies ist m√∂glicherweise nicht der Fall, wenn die √§u√üeren oder inneren Grenzen der Kontur </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Merkmale aufweisen</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Um sie zu </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gl√§tten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , wenden wir eine zus√§tzliche Gl√§ttung auf die zu untersuchende Kontur an (und nicht auf das gesamte Bild, um die Landenschen zwischen den Konturen nicht zu ‚Äûverwischen‚Äú und die urspr√ºngliche Topologie nicht zu verletzen). </font></font><br>
<br>
<img src="https://habrastorage.org/webt/cb/e2/tl/cbe2tlqhmia2hyb727mcspjsb5w.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 4. Berechnung des Ausbuchtungsdefekts. </font></font></i><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (a)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert f√§lschlicherweise den roten Endpunkt. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (b)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endpunkte werden korrekt definiert. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option (c)</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> definiert die Endpunkte in der urspr√ºnglichen Form neu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da in der Technologie , die </font><font style="vertical-align: inherit;">wir angenommen, wird die Schaltung </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">regeneriert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> jedes Mal </font><font style="vertical-align: inherit;">, haben wir Neusuche f√ºr die Punkte der √úbereinstimmung (oder besser gesagt, deren Indizes) durch die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ersch√∂pfende Suche</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">:</font></font><br>
<pre><code class="cpp hljs"> nearestContourPtIdx(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;contour, <span class="hljs-keyword">const</span> Point&amp; pt);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F√ºr F√§lle, in denen es nicht m√∂glich ist, die Merkmale vollst√§ndig zu entfernen, wurde auch ein zus√§tzlicher Modus der </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lichtbogentrennung</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> implementiert </font><font style="vertical-align: inherit;">(separat mit dem internen / externen Lichtbogen arbeiten). Dies ist beispielsweise in F√§llen wichtig, in denen der √§u√üere Bogen der Kontur </font><font style="vertical-align: inherit;">mit anderen Objekten </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontakt steht</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verrauscht ist</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In diesem Fall k√∂nnen Sie mit dem internen Lichtbogen arbeiten. In diesem Fall ist es nicht erforderlich, die externen und internen Lichtb√∂gen getrennt zu verarbeiten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gem√§√ü der bekannten Formel f√ºr das Verh√§ltnis der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexit√§t des Bogens</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wird der </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Radius des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kreises </font><font style="vertical-align: inherit;">ungef√§hr gesch√§tzt </font><font style="vertical-align: inherit;">und zu gro√üe Ellipsen werden verworfen:</font></font><br>
<pre><code class="matlab hljs">R = bulge / <span class="hljs-number">2</span> + SQR(<span class="hljs-built_in">hypot</span>) / (<span class="hljs-number">8</span> * bulge);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Somit wurde f√ºr alle Konturen ihre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konvexit√§tsdefektmetrik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gefunden </font><font style="vertical-align: inherit;">(oder sie werden als linear oder klein klassifiziert und aus dem Verfahren entfernt). </font><font style="vertical-align: inherit;">In der letzten Phase werden der urspr√ºnglichen Metrik zus√§tzliche Parameter hinzugef√ºgt, z. B. der gedrehte Bema√üungsparameter usw., und der gesamte Satz der untersuchten Metriken wird </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nach Gr√∂√üe sortiert</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-keyword">typedef</span> tuple&lt;<span class="hljs-keyword">int</span> , <span class="hljs-comment">// </span>
   RotatedRect, <span class="hljs-comment">//  </span>
   Vec4i, <span class="hljs-comment">//  </span>
   <span class="hljs-keyword">int</span>&gt; <span class="hljs-comment">// </span>
   RectDefMetric;</code></pre><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algorithmus zum Verkn√ºpfen von Bogensegmenten an Endpunkten</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Wachstumsalgorithmus ist klar und offensichtlich: Wir nehmen die gr√∂√üte Kontur als </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Keim</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und versuchen, sie zu z√ºchten, dh die n√§chstgelegenen Flecken zu finden und an ihren Endpunkten anzubringen, die die Wachstumsbedingungen erf√ºllen. In der gewachsenen Figur geben wir den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gew√ºnschten elliptischen Bogen ein</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Maskieren und </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">subtrahieren Sie die</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Figur vom Originalsatz. Wir wiederholen den Wachstumsvorgang, </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bis der anf√§ngliche Satz abgelaufen ist</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das grundlegende Verfahren des Wachstumsalgorithmus sieht folgenderma√üen aus:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-built_in">vector</span>&lt;Point&gt; *patch =<font></font>
    growingContours(contour, def, tmp, hull);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dabei ist </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kontur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> die untersuchte Kontur, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Def</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist der Konvexit√§tsfehler, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rumpf</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist das konvexe Polygon der gesamten Region, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die Hilfspuffermatrix. Am Ausgang erhalten wir eine vektorgewachsene Kontur. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Verfahren besteht aus einem Zyklus von Versuchen, das Wachstum zu s√§en, der entweder durch Ersch√∂pfung der verf√ºgbaren Patches f√ºr das Wachstum endet oder durch den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Parameter der maximalen Anzahl von Iterationen begrenzt wird</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/tp/se/p1/tpsep1tdzgtvitxcnptg9rxu4m0.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 5. Viele Flecken f√ºr das Wachstum ohne Samen Die</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hauptschwierigkeit besteht darin, die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Flecken</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> auszuw√§hlen, die </font><font style="vertical-align: inherit;">den Endpunkten der Kontur </font><font style="vertical-align: inherit;">am </font><i><font style="vertical-align: inherit;">n√§chsten liegen</font></i><font style="vertical-align: inherit;"> , sodass die Figur nur nach </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vorne</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> w√§chst </font><font style="vertical-align: inherit;">. F√ºr </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tangentiale Richtung</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir nehmen die gemittelte Linie, die zum Bogen in der N√§he des Endpunkts geh√∂rt. In </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> werden die Kandidaten f√ºr die Verbindung mit dem Startwert bei einer bestimmten Iteration angezeigt. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/5g/8x/ij/5g8xijwx2owywp4kgjielcgoft8.png"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 6. Samen, umgeben von mehreren Wachstumskandidaten-Patches.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
F√ºr jedes Kandidaten-Patch wird die folgende Metrik berechnet:</font></font><br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> tuple&lt;
   <span class="hljs-keyword">double</span>, <span class="hljs-comment">//    2      2   </span>
   <span class="hljs-keyword">bool</span>, <span class="hljs-keyword">bool</span>, <span class="hljs-comment">//,  4   </span>
   <span class="hljs-keyword">int</span>, <span class="hljs-comment">// </span>
   Vec4i&gt; <span class="hljs-comment">//  </span>
   DistMetric;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es werden nur Flecken ber√ºcksichtigt, die in den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tangentialkegel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fallen </font><font style="vertical-align: inherit;">. Dann wird </font><font style="vertical-align: inherit;">der Patch mit dem geringsten Abstand gew√§hlt wird , </font><font style="vertical-align: inherit;">und durch Aufdrucken der Verbindungsabschnitt in das Raster, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verbindet</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> mit dem entsprechenden Ende des Samens. F√ºr das andere Ende des Seeds wird ein Patch gesucht, der den Parametern entspricht, und wenn es gefunden wird, wird es auch mit dem Seed verbunden. Dann wird der Samen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maskiert und</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von den vielen Flecken </font><i><font style="vertical-align: inherit;">abgezogen</font></i><font style="vertical-align: inherit;"> . Der Vorgang wird von Anfang an wiederholt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Am Ende des Wachstumsvorgangs haben wir einen </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">elliptischen Bogen erhalten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , der noch √ºberpr√ºft werden muss. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Verwenden Sie zun√§chst das Standard- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCV</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Prozedur, die unser Patch empf√§ngt (in Form eines Pfads erinnern wir uns, dass der Pfad und das Raster mit uns austauschbar sind) und gibt die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gedrehte Dimension zur√ºck</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dh eine vollst√§ndige Ellipse.</font></font><br>
<pre><code class="cpp hljs"> RotatedRect box = fitEllipse(patch);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann lehnen wir zu gro√üe und zu kleine Ellipsen ab und wenden dann unser urspr√ºngliches Verfahren zum </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vergleichen der Bereiche des</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> resultierenden elliptischen Bogens und des anf√§nglichen Wachstumsfelds in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rasterform an</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Diese Prozedur enth√§lt einige getarnte Tricks, daher werden wir ihre Beschreibung vorerst weglassen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und schlie√ülich finden wir die verbleibenden Parameter der erkannten Ellipse - den </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start- und </font></font></i><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Endwinkel</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (die Halbachsen kennen wir bereits aus </font><em><font style="vertical-align: inherit;">fitEllipse</font></em><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um den Start- und Endwinkel zu bestimmen, gehen wir wie folgt vor: Wir transformieren unsere vollst√§ndige Ellipse </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zur√ºck zum Polygon</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und finden durch direkte Aufz√§hlung die Punkte, die unseren Enden am n√§chsten liegen. Ihre </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Winkelkoordinaten</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(in der Tat Indizes) und sind die Start- und Endwinkel eines elliptischen Bogens. </font><font style="vertical-align: inherit;">Im Code sieht es so aus (etwas vereinfacht):</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function">pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;
   <span class="hljs-title">ellipseAngles</span><span class="hljs-params">(<span class="hljs-keyword">const</span> RotatedRect &amp;box,
   <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell, <span class="hljs-keyword">const</span> Point &amp;ps, 
   <span class="hljs-keyword">const</span> Point &amp;pe, <span class="hljs-keyword">const</span> Point &amp;pm)</span> 
 </span>{
    <span class="hljs-built_in">vector</span>&lt;Point&gt; ell0;<font></font>
    ellipse2Poly(Point(box.center.x, box.center.y), <font></font>
      Size(box.size.width / <span class="hljs-number">2</span>, box.size.height / <span class="hljs-number">2</span>),<font></font>
      box.angle, <span class="hljs-number">0</span>, <span class="hljs-number">355</span>, <span class="hljs-number">5</span>, ell0);
    <span class="hljs-keyword">int</span> i0 = nearestContourPtIdx(ell0, ps);
    <span class="hljs-keyword">int</span> i1 = nearestContourPtIdx(ell0, pe);<font></font>
    cutSides(ell0, i0, i1, i2, ell, <span class="hljs-literal">nullptr</span>);
    <span class="hljs-keyword">return</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;(i0, i1);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unser </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cutSides-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Verfahren </font><font style="vertical-align: inherit;">ber√ºcksichtigt die </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Topologie</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der </font><font style="vertical-align: inherit;">elliptischen </font><em><font style="vertical-align: inherit;">Bogenquerung</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Insgesamt sollten acht m√∂gliche F√§lle der Umgehung der Indizes </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i0, i1, i2</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ber√ºcksichtigt werden </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Gehen wir entlang der √§u√üeren oder der inneren Kontur, und welcher der Indizes ist gr√∂√üer, anf√§nglich oder endg√ºltig? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einfacher zu erkennender Code:</font></font><br>
<pre><code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cutSides</span><span class="hljs-params">(
   <span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;Point&gt; &amp;ell0, <span class="hljs-keyword">int</span> i0, <span class="hljs-keyword">int</span> i1, <span class="hljs-keyword">int</span> i2, 
   <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_in, <span class="hljs-built_in">vector</span>&lt;Point&gt; *ell_out)</span>
 </span>{
   <span class="hljs-keyword">if</span> (i0 &lt; i1) {
      <span class="hljs-keyword">if</span> (i2 &gt; i0 &amp;&amp; i2 &lt; i1) {
         <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}<font></font>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (i2 &gt; i1 &amp;&amp; i2 &lt; i0) {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">if</span> (ell_in) {...}
            <span class="hljs-keyword">if</span> (ell_out) {...}<font></font>
        }}}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Einige Ergebnisse der Erkennung von Ellipsen in komplexen F√§llen sind in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abbildung 7 dargestellt</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jv/56/hd/jv56hdcpfuvmi59k0unppjknlq4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In den folgenden Artikeln werden statistische Nachweismethoden betrachtet.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de490386/index.html">Wie man sonst an der B√∂rse Geld verdient und das Risiko reduziert: Aktien von Unternehmen mit Dividendenzahlung</a></li>
<li><a href="../de490390/index.html">Olga Makushenko, Gesch√§ftsf√ºhrerin von 101XP: ‚Äû5 wichtige Fehler bei der Entwicklung eines Spiels als Unternehmen‚Äú</a></li>
<li><a href="../de490392/index.html">Catchain: TON Blockchain-Konsensalgorithmus</a></li>
<li><a href="../de490394/index.html">Commodore Amiga 500+: Lass niemanden beleidigt gehen</a></li>
<li><a href="../de490398/index.html">Red Hogwarts. Offiziere oder warum ein Historiker wie ein Detektiv ist</a></li>
<li><a href="../de490404/index.html">Warum und wie 5G alles ver√§ndern wird: Technologie, schrittweise Implementierung und Elementbasis f√ºr Teilnehmerger√§te</a></li>
<li><a href="../de490406/index.html">Unaussprechlich attraktiv: Wie wir einen Haniot geschaffen haben, der nicht entlarvt werden kann</a></li>
<li><a href="../de490408/index.html">FreeBSD: Viel besser als GNU / Linux</a></li>
<li><a href="../de490410/index.html">Lebende und k√ºnstliche Neuronen, die √ºber das Internet verbunden sind</a></li>
<li><a href="../de490412/index.html">Vielleicht sollten wir uns mit JavaScript etwas beruhigen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>