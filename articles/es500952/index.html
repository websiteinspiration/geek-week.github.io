<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>↗️ ⛵️ 💣 Habilidades clave del programador de Python 👨🏽‍🤝‍👨🏻 ✊🏾 🌃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En nuestro tiempo dinámico, el programador necesita mantenerse al día y aprender constantemente nuevas habilidades para seguir siendo un especialista ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Habilidades clave del programador de Python</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500952/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En nuestro tiempo dinámico, el programador necesita mantenerse al día y aprender constantemente nuevas habilidades para seguir siendo un especialista solicitado. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
He estado programando en Python durante aproximadamente dos años, y ahora ha llegado el momento de abordar conscientemente el desarrollo de nuevas habilidades. </font><font style="vertical-align: inherit;">Para hacer esto, decidí analizar las vacantes y presentar las habilidades requeridas en forma de gráfico. </font><font style="vertical-align: inherit;">Esperaba ver que las habilidades formarían grupos que corresponden a diferentes especialidades: desarrollo de backend, ciencia de datos, etc. Pero, ¿qué pasa con la realidad? </font><font style="vertical-align: inherit;">Lo primero es lo primero.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Recopilación de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primero tenía que decidir sobre la fuente de datos. Consideré varias opciones: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Habr Career</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Yandex Work</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HeadHunter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y otras. HeadHunter parecía el más conveniente, porque aquí en las vacantes hay una lista de habilidades clave y hay una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> abierta conveniente </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Después de estudiar la API HeadHunter, decidí analizar primero la lista de ID de trabajo para la palabra clave dada (en este caso, "python"), y luego analizar la lista de etiquetas correspondientes para cada trabajo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al buscar vacantes, las vacantes se devuelven página por página, el número máximo de vacantes por página es 100. Al principio guardé los resultados completos como una lista de respuestas de página.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para esto, se utilizó el módulo de solicitudes. </font><font style="vertical-align: inherit;">En el campo "agente de usuario", de acuerdo con la API, se ingresó el nombre del navegador virtual para que HH entendiera que el script estaba accediendo a él. </font><font style="vertical-align: inherit;">Hizo un ligero retraso entre las solicitudes para no sobrecargar el servidor.</font></font><br>
<br>
<pre><code class="python hljs">ses = requests.Session()<font></font>
ses.headers = {<span class="hljs-string">'HH-User-Agent'</span>: <span class="hljs-string">"Mozilla/5.0 (X11; Linux x86_64; rv:10.0) Gecko/20100101 Firefox/10.0"</span>}<font></font>
<font></font>
phrase_to_search = <span class="hljs-string">'python'</span>
url = <span class="hljs-string">f'https://api.hh.ru/vacancies?text=<span class="hljs-subst">{phrase_to_search}</span>&amp;per_page=100'</span><font></font>
res = ses.get(url)<font></font>
<font></font>
<span class="hljs-comment"># getting a list of all pesponses</span><font></font>
res_all = []<font></font>
<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(res.json()[<span class="hljs-string">'pages'</span>]):<font></font>
    print(<span class="hljs-string">f'scraping page <span class="hljs-subst">{p}</span>'</span>)<font></font>
    url_p = url + <span class="hljs-string">f'&amp;page=<span class="hljs-subst">{p}</span>'</span><font></font>
    res = ses.get(url_p)<font></font>
    res_all.append(res.json())<font></font>
    time.sleep(<span class="hljs-number">0.2</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, obtuve una lista de diccionarios de respuestas, donde cada diccionario correspondía a una página de resultados de búsqueda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al final resultó que, la API hh.ru limita el número máximo de vacantes a dos mil, es decir, con 100 vacantes por página, el número máximo de páginas puede ser 20. Para la palabra clave Python, se devolvieron 20 páginas vacantes, lo que significa que es más probable que haya vacantes reales en Python. cuanto más. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para obtener una lista de etiquetas, hice lo siguiente:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterado sobre cada página de resultados de búsqueda,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterado sobre cada trabajo en la página y obtuve la identificación del trabajo,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detalles solicitados de la vacante a través de la API,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se especificó al menos una etiqueta en la vacante, entonces la lista de etiquetas se agregó a la lista.</font></font></li>
</ul><br>
<pre><code class="python hljs"><span class="hljs-comment"># parcing vacancies ids, getting vacancy page and scraping tags from each vacancy</span><font></font>
tags_list = []<font></font>
<span class="hljs-keyword">for</span> page_res_json <span class="hljs-keyword">in</span> res_all:
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> page_res_json[<span class="hljs-string">'items'</span>]:<font></font>
        vac_id = item[<span class="hljs-string">'id'</span>]<font></font>
        vac_res = ses.get(<span class="hljs-string">f'https://api.hh.ru/vacancies/<span class="hljs-subst">{vac_id}</span>'</span>)
        <span class="hljs-keyword">if</span> len(vac_res.json()[<span class="hljs-string">"key_skills"</span>]) &gt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># at least one skill present</span><font></font>
            print(vac_id)<font></font>
            tags = [v <span class="hljs-keyword">for</span> v_dict <span class="hljs-keyword">in</span> vac_res.json()[<span class="hljs-string">"key_skills"</span>] <span class="hljs-keyword">for</span> _, v <span class="hljs-keyword">in</span> v_dict.items()]<font></font>
            print(<span class="hljs-string">' '</span>.join(tags))<font></font>
            tags_list.append(tags)<font></font>
            print()<font></font>
        time.sleep(<span class="hljs-number">0.1</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las listas de etiquetas se guardaron como un diccionario</font></font><br>
<br>
<pre><code class="python hljs">res = {<span class="hljs-string">'phrase'</span>: phrase_to_search, <span class="hljs-string">'items_number'</span>: len(tags_list), <span class="hljs-string">'items'</span>: tags_list}
<span class="hljs-keyword">with</span> open(<span class="hljs-string">f'./data/raw-tags_<span class="hljs-subst">{phrase_to_search}</span>.json'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> fp:  <span class="hljs-comment"># Serializing</span>
    json.dump(res, fp)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Curiosamente, de las 2000 vacantes vistas, solo 1579 vacantes tenían etiquetas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Formateo de datos</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora necesita procesar las etiquetas y traducirlas a un formato conveniente para mostrar como un gráfico, a saber:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">traiga todas las etiquetas a un solo registro, por lo que "aprendizaje automático", "aprendizaje automático" y "aprendizaje automático" significan lo mismo</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcular el valor del nodo como la frecuencia de aparición de cada etiqueta,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calcule el valor de la conexión como la frecuencia de la reunión conjunta de etiquetas entre sí.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reduciendo a un solo registro, calculando la frecuencia de aparición de cada etiqueta, el filtrado por el tamaño del nodo se realizó de la siguiente manera.</font></font><br>
<br>
<pre><code class="python hljs">tags_list[<span class="hljs-string">'items'</span>] = [[i.lower() <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> line] <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list[<span class="hljs-string">'items'</span>]]<font></font>
<font></font>
<span class="hljs-comment"># counting words occurrences</span>
flattened_list = [i <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> line]<font></font>
nodes_dict_all = {i: flattened_list.count(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> set(flattened_list)}<font></font>
nodes_dict = {k:v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> nodes_dict_all.items() <span class="hljs-keyword">if</span> v &gt; del_nodes_count}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ocurrencia en parejas calculada de la siguiente manera. </font><font style="vertical-align: inherit;">Primero creé un diccionario en el que las claves eran todos los pares de etiquetas posibles en forma de tupla, y los valores eran cero. </font><font style="vertical-align: inherit;">Luego revisó la lista de etiquetas y aumentó los contadores para cada par encontrado. </font><font style="vertical-align: inherit;">Luego eliminé todos aquellos elementos cuyos valores eran cero.</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment"># tags connection dict initialization</span>
formatted_tags = {(tag1, tag2): <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> tag1, tag2 <span class="hljs-keyword">in</span> itertools.permutations(set(nodes_dict.keys()), <span class="hljs-number">2</span>)}<font></font>
<font></font>
<span class="hljs-comment"># count tags connection</span>
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> tags_list:
    <span class="hljs-keyword">for</span> tag1, tag2 <span class="hljs-keyword">in</span> itertools.permutations(line, <span class="hljs-number">2</span>):
        <span class="hljs-keyword">if</span> (tag1, tag2) <span class="hljs-keyword">in</span> formatted_tags.keys():<font></font>
            formatted_tags[(tag1, tag2)] += <span class="hljs-number">1</span><font></font>
<font></font>
<span class="hljs-comment"># filtering pairs with zero count</span>
<span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> formatted_tags.copy().items():
    <span class="hljs-keyword">if</span> v == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">del</span> formatted_tags[k]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En la salida, formé un diccionario de la forma</font></font><br>
<br>
<pre><code class="json hljs">{<font></font>
'phrase': phrase searched,<font></font>
'items_number': number of vacancies parced, <font></font>
'items': {<font></font>
 	<span class="hljs-attr">"nodes"</span>: [<font></font>
			{<font></font>
			<span class="hljs-attr">"id"</span>: tag name, 
		 	<span class="hljs-attr">"group"</span>: group id, 
		 	<span class="hljs-attr">"popularity"</span>: tag count<font></font>
			},<font></font>
		… <font></font>
		] <font></font>
	<span class="hljs-string">"links"</span>: [<font></font>
			{<font></font>
			<span class="hljs-attr">"source"</span>: pair[<span class="hljs-number">0</span>], 
			<span class="hljs-attr">"target"</span>: pair[<span class="hljs-number">1</span>], 
			<span class="hljs-attr">"value"</span>: pair count<font></font>
			},<font></font>
		…<font></font>
		]<font></font>
	}<font></font>
}</code></pre><br>
<pre><code class="python hljs">nodes = []<font></font>
links = []<font></font>
<span class="hljs-keyword">for</span> pair, count <span class="hljs-keyword">in</span> formatted_tags.items():<font></font>
    links.append({<span class="hljs-string">"source"</span>: pair[<span class="hljs-number">0</span>], <span class="hljs-string">"target"</span>: pair[<span class="hljs-number">1</span>], <span class="hljs-string">"value"</span>: count})<font></font>
<font></font>
max_count = max(list(nodes_dict.values()))<font></font>
count_step = max_count // <span class="hljs-number">7</span>
<span class="hljs-keyword">for</span> node, count <span class="hljs-keyword">in</span> nodes_dict.items():<font></font>
    nodes.append({<span class="hljs-string">"id"</span>: node, <span class="hljs-string">"group"</span>: count // count_step, <span class="hljs-string">"popularity"</span>: count})<font></font>
<font></font>
data_to_dump = in_json.copy()<font></font>
data_to_dump[<span class="hljs-string">'items'</span>] = {<span class="hljs-string">"nodes"</span>: nodes, <span class="hljs-string">"links"</span>: links}
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualización de Python</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para visualizar el gráfico, utilicé el módulo networkx. Esto es lo que sucedió la primera vez sin filtrar los nodos. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/yp/kq/jgypkqkfuip3g6sde0gylgyvdqu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta visualización se parece más a una bola de hilos enredados que a un gráfico de habilidades. Las conexiones son confusas y penetran en el gráfico tan densamente que es imposible distinguir los nodos. Además, hay demasiados nodos en el gráfico, algunos tan pequeños que no tienen significación estadística. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, filtré los nodos más pequeños de menos de 5 de tamaño, y también hice enlaces grises. En esta imagen, todavía no he traído las palabras a un solo registro, mientras trataba de eliminar el nodo Python más grande para descargar la conexión.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/_6/dc/u5/_6dcu5zvmb4yblypzliyx_69ezy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se ha vuelto mucho mejor. </font><font style="vertical-align: inherit;">Ahora los nodos están separados y los enlaces no obstruyen la visualización. </font><font style="vertical-align: inherit;">Se hizo posible ver las habilidades básicas, se encuentran en grandes bolas en el centro del gráfico y pequeños nodos. </font><font style="vertical-align: inherit;">Pero este gráfico todavía tiene mucho que mejorar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visualización de JavaScript</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Probablemente continuaría eligiendo este código si en ese momento no tuviera ayuda en forma de hermano. </font><font style="vertical-align: inherit;">Participó activamente en el trabajo e hizo una hermosa pantalla dinámica basada en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">módulo D3 de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JavaScript </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Resultó así. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/94/uk/ih/94ukihcm4utgytmwbilp1pjtt-i.png"><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La visualización dinámica</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> está disponible aquí. </font><font style="vertical-align: inherit;">Tenga en cuenta que los nodos se pueden extraer.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Análisis de resultados</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como podemos ver, el gráfico resultó estar muy entrelazado, y los grupos claramente definidos no se pueden detectar a primera vista. </font><font style="vertical-align: inherit;">Puede notar de inmediato varios nodos grandes que son más demandados: linux, sql, git, postgresql y django. </font><font style="vertical-align: inherit;">También hay habilidades de popularidad media y habilidades raramente encontradas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Además, puede prestar atención al hecho de que las habilidades todavía forman grupos por profesión, ubicadas en lados opuestos del centro:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abajo a la izquierda - análisis de datos,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la parte inferior están las bases de datos,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">abajo a la derecha - desarrollo front-end,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la derecha está probando,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arriba a la derecha - desarrollo web,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">arriba a la izquierda: aprendizaje automático.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta descripción de los grupos se basa en mi conocimiento y puede contener errores, pero la idea en sí misma, espero, es clara. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a los resultados obtenidos, se pueden extraer las siguientes conclusiones:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">necesita dominar habilidades que corresponden a nodos grandes, siempre serán útiles,</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">debes dominar las habilidades del grupo que se adapte a tus intereses.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espero que lo hayan disfrutado y este análisis les sea útil. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede echar un vistazo al código o participar en su desarrollo utilizando los enlaces: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proyecto GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">portátil observable</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> con visualización ¡ </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Éxito en dominar nuevos horizontes!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es500934/index.html">Winnum anuncia un nuevo lanzamiento de la plataforma insignia Winnum Platform 4.3</a></li>
<li><a href="../es500936/index.html">Integración simple de RabbitMQ y Spring Boot</a></li>
<li><a href="../es500942/index.html">Ultravioleta: desinfección efectiva y seguridad</a></li>
<li><a href="../es500944/index.html">WexLang Reader: cómo leer libros en idiomas extranjeros con placer (104 idiomas)</a></li>
<li><a href="../es500948/index.html">Rust 1.43.1 lanzamiento: lanzamiento de ajuste</a></li>
<li><a href="../es500956/index.html">Mobile ML: aprendizaje automático en tu bolsillo. Parte 1 - Hierro</a></li>
<li><a href="../es500958/index.html">Por qué WSL 2 es 13 veces más rápido que WSL: impresiones de vista previa de información privilegiada</a></li>
<li><a href="../es500962/index.html">Códigos paso a paso: leer / codificar PDF417</a></li>
<li><a href="../es500966/index.html">SLS vs STARSHIP: ¿Por qué existen ambos programas? Astronauta todos los días</a></li>
<li><a href="../es500968/index.html">Material Python. ¿Qué hay de nuevo en la biblioteca KivyMD?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>