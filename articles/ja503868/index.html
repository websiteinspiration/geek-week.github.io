<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎽 👭 🏉 ドメインモデルの輝きと貧困 🌛 👨🏼‍⚕️ 😻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Martin Fowlerは、彼の著書 『Patterns of Enterprise Application Architecture』で、ドメインモデルをビジネスロジックを編成するための複雑なアプローチとして説明しています。この方法は、データ構造と動作の両方の観点から、実世界からサブジェクト領域...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ドメインモデルの輝きと貧困</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/503868/"><img src="https://habrastorage.org/webt/aw/7y/e7/aw7ye7s-mdtqfzjx6gjouazliy8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Martin Fowlerは、彼の著書 『</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns of Enterprise Application Architecture』で</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、ドメインモデルをビジネスロジックを編成するための複雑なアプローチとして説明しています。</font><font style="vertical-align: inherit;">この方法は、データ構造と動作の両方の観点から、実世界からサブジェクト領域のオブジェクトに対応するクラスを作成することで構成されています。</font><font style="vertical-align: inherit;">同時に、データストレージ、認証と承認、トランザクション管理などの技術的な側面は、ビジネスロジックレイヤーから取り除かれます。</font><font style="vertical-align: inherit;">パターンは、次の2つの方法のいずれかで実装されます。</font></font><br>
<br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リッチ（飽和）モデル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -データと動作は、サブジェクトエリアのオブジェクト内にカプセル化されます。</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貧血モデル</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -データのみがドメインのオブジェクトにカプセル化され、動作（メソッド）はサービスの別のレイヤーに転送されます。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
FowlerとEvansは貧血モデルを</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">アンチパターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と見なしてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ただし、私が使用したコードベースの多くは、貧血モデルのスタイルで正確に実装されています。</font><font style="vertical-align: inherit;">カットシーンの下には、DotNext 2019モスクワでの私のレポートの筆記録とビデオがあり、両方のアプローチの長所と短所を比較し、OOPパラダイムおよび機能的なスタイルでのドメインモデルの実装の明確ではない詳細に焦点を当てています。</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/rFiuLeSFZsA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポートのプレゼンテーション</font></font></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ポストの構造：</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">歴史的背景</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
-分裂の理由</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-常に有効（神話か現実か？）</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実用的なDDDパターン</font></font></b></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
-DDD専門用語</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-タイプ</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-</font><font style="vertical-align: inherit;">ベースの設計</font><font style="vertical-align: inherit;">-集合体</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-ドメインとインフラストラクチャ</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
-すべて一緒に</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b>  («» )</b></a><br>
—   SOLID<br>
— Lazy Load<br>
—  — </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b>Workarounds</b></a><br>
— Expressions<br>
— Specification<br>
— Default Interfaces Implementation<br>
— Bulk Extensions<br>
—   F#?</li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b>Bounded Context</b></a><br>
—    (      )<br>
—    ()<br>
—   Domain Model  Bounded Context<br>
—   <br>
—    </li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><b> ?</b></a></li>
<li><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> </a></b></li>
</ul><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><img src="https://habrastorage.org/webt/wk/h5/rk/wkh5rkdfas875smzhckwz2vah5a.jpeg"></a><br>
<a name="history"></a><br>
<h2> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin Fowlerの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patterns Of Enterprise Application Architecture（PoEAA）</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
を読んでいるときに、初めて「ドメインモデル」という用語に出くわしました</font><font style="vertical-align: inherit;">。少し読んで理解しました。たぶん、時間が正しくなかったのかもしれませんし、ファウラーがそれを非常に簡潔に書いたのかもしれません。いずれにしても、パターンを読んだ後、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ドメインドリブンデザインの</font></a><font style="vertical-align: inherit;">エリックエヴァンスによる悪名高い「ブルーブック」が私の手に渡るまで、それは数年間忘れられていました</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。今回は、映画「マトリックス」の中で、ネオがようやく心を解放することができるようになりました。もちろん、彼が思考の力によって弾丸を止め始めた、または他のいくつかの超能力を獲得したという意味ではありません。代わりに、エンタープライズソフトウェア開発のコンテキストではそれほど重要ではなく、何が重要であるかについての私の見方が大きく変わりました。本を読む前は、技術的な側面だけが重要だと考えていましたが、その後は分析を行い、要件やその他の重要なことを収集する必要があるという考えが忍び寄り、企業領域の主な困難は一般的にテクノロジーではなく人に関係しています。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/q2/ac/am/q2acamortuzl3dq8wzquke_aude.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、誰もがエバンスについて私の子犬の熱意を共有しているわけではありません。もっと多く</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、ヴァーノンの「赤い」本のようです。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。彼らが言うように、味と色については、すべてのマーカーが異なるので、誰もがどちらを読むべきかを読むことを決定します。どちらも読み取ることができますが、内容はほとんど重複しています。しかし、スコットバラシン</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメインモデリングメイドファンク</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ショナルによる本は、</font><font style="vertical-align: inherit;">文字通り昨年</font><font style="vertical-align: inherit;">出版され</font><font style="vertical-align: inherit;">ました。これは、関数型プログラミングのプリズムを通して主題指向設計の典型的な問題を調べ、OOPでは利用できない予期しない答えをいくつか与えるという点で注目に値します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、OOPには、歴史的にドメインモデリングへの2つの主要なアプローチがあります。「リッチ」モデルと「貧弱または貧血」モデルです。</font><font style="vertical-align: inherit;">FPでは、関数型言語の機能が従来のOOP言語と異なるため、および関数型の世界ではデータ構造とそれらに対する操作（動作）をオブジェクトに結合することが一般に受け入れられないため、そのような分離はありません。</font><font style="vertical-align: inherit;">レポートの文脈では、私は主にオブジェクト指向のパラダイムにとどまり、機能主義の曲がった経路に数回だけスリップします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リッチ</font></font></h3><br>
<img src="https://habrastorage.org/webt/at/pn/x7/atpnx7_ti6lnxiggui4pw5chsr8.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リッチモデルは、ファウラーとエヴァンスが念頭に置いていたモデリング手法です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造と動作は同じクラスにまとめられています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムコードの構造は、ドメインの構造を反映しています。</font><font style="vertical-align: inherit;">ビジネスロジックに関連するクラスは、レジ係、転記、給与と呼ばれるべきであり、サービス、リポジトリ、またはプロキシと呼ばれるべきではありません。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最も重要なのは、オブジェクトの不変条件が観察されることです。</font><font style="vertical-align: inherit;">彼らの状態は一貫しています。</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貧血</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
貧血では、すべてが正反対です。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ構造とそれらに対する操作（動作）は分離されています。</font><font style="vertical-align: inherit;">ほとんどの場合、データ構造は「エンティティ」と呼ばれ、動作は「サービス」と呼ばれます。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プログラムコードの構造は、パターンとフレームワークを反映している可能性が高いです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスルールは、コードを研究して理解することが不可能であるか、非常に困難になっています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、不変条件は尊重されず、そのような必要性または機会はしばしば否定されます</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 FowlerとEvansは、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">貧血モデルはアンチパターン</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ある</font></a><font style="vertical-align: inherit;">と考えてい</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。これは、開発チームがドメインをOOPスタイルで正しくモデル化できなかったことを示しています。</font><font style="vertical-align: inherit;">これにもかかわらず、多くのプログラマーは貧血モデルがまさにあなたが必要とするもの、あるいはそれの将来さえあると確信しています。</font><font style="vertical-align: inherit;">さらに、貧血モデルはSOLIDの原則に厳密に準拠しています。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分割の理由</font></font></h2><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この分裂</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
が起こった正確な瞬間</font><font style="vertical-align: inherit;">とそれを引き起こした原因</font><font style="vertical-align: inherit;">を述べるのは難しい</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">個人的には、主に2つの理由があると思います。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドミナンスORM</font></font></h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nuget.org</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
からパッケージをダウンロードするための統計を見てみましょう</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">Entity Frameworkは、ASP.NET MVCよりも頻繁にダウンロードされます。</font><font style="vertical-align: inherit;">ASP.NET MVCとEntity Frameworkの多くのダウンロードはかなりの程度重複していると想定でき、多くのWebアプリケーションがORMを介してデータを操作していると結論付けられます。</font><font style="vertical-align: inherit;">これを実際にどの程度行う必要があるかは未解決の問題です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実装のしやすさ</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
貧血モデルは、おそらく少なくとも一生に一度は、このテキストの各読者によって実現されました。</font><font style="vertical-align: inherit;">リッチモデルを適切に実装する方法は、あまり明確ではありません。</font><font style="vertical-align: inherit;">理論的な資料は豊富にありますが、実用的な実装になるとすぐに疑問が生じますが、これまで明確な答えを見つけられなかったものもあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">常に有効（神話か現実か）</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> <img width="300" align="left" src="https://habrastorage.org/webt/w6/jy/8p/w6jy8pr5x5fj3gst8yuevcsagtg.jpeg"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は、プログラマの資格不足にあると考えられます。では、なぜこのような「ばかげた」が業界に非常に多いのでしょうか。なぜ人々は「ビジネスルールが明確なコードを書く」、「常に不変条件を観察する」などの魅力的なアイデアを放棄するのでしょうか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結局のところ、すべての不変条件の絶対遵守はどういう意味ですか？限界-「間違った状態」ではオブジェクトをまったく作成できないという事実。そして、これは、ユニットテスト、受け入れテスト、または禁じられた段階ではなく、生産時にエラーが検出されることを意味します。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに詳しくは、不変条件と設計のトピックは、プログラムのコンパイル中のエラーの可能性を排除することを目的としており、スコットバラシンの記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違法な状態を表現できないものにする</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">」で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">はありません</font></a><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="> <img width="300" align="right" src="https://habrastorage.org/webt/lj/br/hi/ljbrhil3e5axldhxi21hkhwvxhm.jpeg"></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼らの正しい心の中で誰がそのようなことを拒否するでしょうか？</font><font style="vertical-align: inherit;">人生ではなく、おとぎ話...あるいは神話...あるいは多分フィクション？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そのような議論</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インターネット上でグレッグ・ヤングとジェフリー・パレルモの間で</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">行わ</font></a><font style="vertical-align: inherit;">れました。</font><font style="vertical-align: inherit;">1つ目はAlways Validコンセプトのサポーターであり、2つ目は、このアプローチは実際には一般的に実現可能ではないと主張しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ジェフリーの議論は非常に論理的です。</font><font style="vertical-align: inherit;">変更可能な環境でのオブジェクトの状態の正確性を保証するために、セッターなどに保護構造を提供する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> Name<font></font>
{<font></font>
   <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> _name; }
   <span class="hljs-keyword">set</span><font></font>
   {<font></font>
       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">string</span>.IsNullOrEmpty(<span class="hljs-keyword">value</span>))<font></font>
       {<font></font>
           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"Name is required"</span>);<font></font>
       }<font></font>
       _name = <span class="hljs-keyword">value</span>;<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このアプローチは、コードを散らかしたりノイズを加えたりするだけでなく、SOLIDにあまり友好的ではありません。そのようなクラスには、データの保存と検証という2つの変更理由があるためです。単独の責任の原則に違反しないようにするために、個別のバリデーターインターフェースを宣言して実装し、検証ロジックを対応する実装に転送することができます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IValidator</span>&lt;T&gt;<font></font>
{<font></font>
   <span class="hljs-function">ValidationResult <span class="hljs-title">Validate</span>(<span class="hljs-params">T obj</span>)</span>;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SOLIDをそのままにして、この議論を反対側から見てみましょう。場合によっては、オブジェクトの正しい状態を保証することは単に不可能である可能性があります。商人は長い間、オンラインストアでの購入の可能性は、記入する必要のあるフォームの数に応じて減少することを認識してきました。理想的には、巨大な購入ボタンが1つだけあり、ユーザーに連絡する何らかの方法があるべきです。残りの「必須」フィールドは、支払いを受け取った後、コールセンターによって入力できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、ストアがあなたのことを知っているほど、より関連性の高い広告を表示するためのマーケティングキャンペーンを設定できるようになります。これにより、ストアのWebサイトに何度もアクセスして購入を強いられる可能性が高くなります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、場合によっては、必須フィールドに最小値を指定し、他の場合には最大値を指定する必要があります。</font><font style="vertical-align: inherit;">これは、異なるコンテキストでは「必須」のクラスフィールドのルールが異なる可能性があり、クラスのインスタンスが常に「正しい」状態になるとは限らないことを意味します。</font><font style="vertical-align: inherit;">チェックメイト、グレッグ・ヤング？</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニバーサルの問題</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
人類に知られている歴史上初めて、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プラトンとアリストテレス</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">がコンピュータサイエンスとコンピュータの発明によるサイバネティックスの長期的な発展について</font><font style="vertical-align: inherit;">同様の質問をしたのは驚くべきことです</font><font style="vertical-align: inherit;">。私はオントロジーには深く入りませんが、古代ギリシャの哲学者は彼らの考えについてかなり自由な解釈を求めています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユニコーンを想像してみてください。具体的ではなく、抽象的な概念としての原則としてユニコーン。 「ユニコーン」のクラスに属するオブジェクトを想像してみてください。ここで私はオブジェクトとクラスという用語を広く解釈します。OOP用語の意味ではなく、あらゆる種類のユニコーンとこのカテゴリーの1つの代表を含むカテゴリーとして解釈します。左の写真のユニコーンを思い浮かべますか？でしょ？</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/st/ml/wa/stmlwaulbxvybarcpyj5jeqg5wk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここではすべてがそれほど明白ではありません。</font><font style="vertical-align: inherit;">これは、怪盗グルーのアニメ3のキャラクターです。左のユニコーンがお気に入りのおもちゃだったため、一人の少女が生きているユニコーンを探していました。</font><font style="vertical-align: inherit;">古代ギリシャの哲学者と現代の漫画は文脈検証とどのような関係がありますか？</font><font style="vertical-align: inherit;">奇妙なことに、最も直接的です。</font></font><br>
<br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8ZZ-CDtrJ3M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキスト検証と不変</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証を2つの亜種に分割しましょう：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトが特定のクラスに属するために必要な特性：ユニコーンはまだ1つの角を持つ馬であり、2つの角を持つ羊ではなく、そのうちの1つが途切れています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストに応じて、不変条件に加えて機能する他のタイプの検証があります。</font><font style="vertical-align: inherit;">販売のコンテキストでは、ユーザーは連絡先の詳細を用意するだけで十分です。配信のコンテキストでは、姓と名前、そして場合によっては他の必要なフィールドも必須になります。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一見すると、この分離により、モデルを常に一貫した状態に保つことができます。</font><font style="vertical-align: inherit;">したがって、問題は依然として、リッチモデルのメリットを得るためにもう少し考えたくないプログラマに限定されているのでしょうか。</font><font style="vertical-align: inherit;">理論的には、はい、実際には、物事はそれほど単純ではありません。</font></font><br>
<br>
<blockquote>            <b></b>,      - ,   ,    <b></b>,        .      .<br>
</blockquote><a name="patterns"></a><br>
<h2> DDD  </h2><h2></h2><h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">DDD-</a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテストを始める前に、DDDの専門用語を思い出しました。モデルはモノリシックではありませんが、いくつかの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">限られたコンテキストに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分かれてい</font><font style="vertical-align: inherit;">ます。レポートのフレームワークでは重要ではないため、用語ドメイン、サブドメイン、および限定されたコンテキストの相関関係の問題は括弧から外します。組織上の理由により、コンテキストは限られています。ほとんどの場合、企業全体の単一のモデルを作成することは不可能です。そのようなモデルは、部門ごとに異なる会社の実際の異種構造を反映しないためです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが製品の製造を注文することにしたとしましょう。あなたがそれを支払うまで、誰も5番目のポイントを上げることはありません。しかし、支払い後、アプリケーションは生産部門に行きます。製造部門は、アプリケーションが支払われたかどうかは関係ありません。彼らにとって、納期と倉庫で必要な資材の入手可能性は重要です。次に、商品は配送のために送られます。これは、一般的にどのような種類の商品であるかを示しています。彼らは、出荷倉庫から配達ポイントまでの距離のみを気にします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、3つのアプリケーションがあります。支払い、製造、および配送用であり、さまざまな特性があり、企業全体ではなく、限られた状況でのみ意味があります。限られた文脈の中で同様に理解される用語集は、単一言語と呼ばれます。限られたコンテキストの中で、DDDは3つの基本的なモデリングツールを提供します：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">値オブジェクト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティ、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">および</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集約</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/t_/e3/t8/t_e3t8lkkz61uijtux1yt4ezrau.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集合体は、単一のオブジェクトではなくグループに対して不変量を持つオブジェクトのツリーです。アグリゲートへのアクセスは、「アグリゲーションルート」-ツリーのルートにあるオブジェクトを介して行われます。したがって、ルートはカプセル化によってグループ全体の不変条件を提供します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
エンティティと値オブジェクトは、アプリケーションの基本的な構成要素であり、集計に含まれる場合と含まれない場合があります。</font><font style="vertical-align: inherit;">彼らの</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主な違いは、</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティが一意の識別子を持っているということですが、値オブジェクトにはありません。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タイプデザイン</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オンラインストアのユーザーに戻ります。</font><font style="vertical-align: inherit;">「リッチ」モデルのスタイルで1つのオブジェクトのみをモデル化してみましょう。</font><font style="vertical-align: inherit;">不変の検証とコンテキストの検証を分離する必要があるという結論に達しました。</font><font style="vertical-align: inherit;">目標を達成する最も簡単な方法は、ユーザーをシミュレートするクラスを分割することです。</font><font style="vertical-align: inherit;">主なサブタイプは2つあります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザープロファイル-後で入力する必要がある個人データ。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">識別と注文に必要な連絡先情報を含むユーザーアカウント。</font></font></li>
</ol><img src="https://habrastorage.org/webt/ip/rk/ay/iprkayg8pjrrwvi3duscwvy_-4e.gif"><br>
<blockquote>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Domain Modeling Made Functional</a>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">  -</a>.</blockquote><br>
<h3> IO   (Anticorruption Layer)</h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のステップは、アプリケーションの境界に入力/出力を転送することです。</font><font style="vertical-align: inherit;">外部からのデータは、定義により、合意されているかどうかにかかわらず、どのような状態でもかまいません。</font><font style="vertical-align: inherit;">DDDは、限られたコンテキストの境界制御のための特別なパターンを提供します。それは、腐敗防止レイヤーです。ただし、通常のファサードとは、より狭い特殊化だけが異なります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/-k/ie/pn/-kiepni2-7nlqpdetqy1vpabkta.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンテキスト外のすべてのデータは、最初に検証が行われるファサードに分類されます。</font><font style="vertical-align: inherit;">無効なデータは拒否され、検証されたデータはさらにドメインレイヤーに入ります。</font><font style="vertical-align: inherit;">それらに対してビジネスロジック操作が実行されます。</font><font style="vertical-align: inherit;">結果はドメイン層を離れます。</font><font style="vertical-align: inherit;">新しい入力データは、「クリーン」なドメインレイヤーの結果に基づいていても、「ダーティ」と見なされ、操作が繰り返されます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラッドすべてに始まりがあります</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、正しいデータのみがドメインに入ります。ドメイン層自体はすべての不変条件を監視するため、すべての操作の入力および出力パラメーターは常に一貫している必要があります。正確性を保証する最初の行はクラスコンストラクタです。コンストラクターはもともと一貫したオブジェクトのみを作成するために考案されましたが、長い間、ORMとシリアライザーはノンパラメトリックコンストラクターでのみ機能することができました。さらに、C ++のような言語のコンストラクターの構文は冗長すぎることが判明しました。その結果、デザイナーが必要であり有用であると信じている人と、これが冗長すぎると信じている人のワクチン接種者と反ワクチン接種者との間の対立を観察することができます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの初期化の問題は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータプロパティを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持つTypeScriptで十分に解決され</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">C＃9では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">約束します</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">この機能はC＃8で計画されていましたが、言語開発者はコンセプトを完成させることを決定し、次のバージョンの言語ではまだ待たれているようです。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
リッチモデルの場合、選択肢はなく、コンストラクターが必要です。</font><font style="vertical-align: inherit;">連絡先データを一意の識別子として使用する必須フィールドにします。ユーザープロファイルはオプションのコンストラクタパラメータです。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> Contact Contact { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
  <font></font>
   <span class="hljs-keyword">public</span> UserName? UserName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
  <font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span>(<span class="hljs-params">Contact contact, UserName? userName = <span class="hljs-literal">null</span></span>)</span><font></font>
   {<font></font>
       Contact = contact;<font></font>
       UserName = userName;<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
連絡先情報はメールまたは電話です。</font><font style="vertical-align: inherit;">両方を記入する必要はありません。コールセンターがコミュニケーションの方法を手配します。主なことは、正しく記入されることです。</font><font style="vertical-align: inherit;">メールの場合-アドレスに犬とドメインが存在し、電話の場合は「+」記号とそれに続く番号。</font><font style="vertical-align: inherit;">より正確な電子メールと電話の検証ルールは、現時点では重要ではないため、意図的に省略されています。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span><font></font>
{<font></font>
   <span class="hljs-keyword">const</span> <span class="hljs-keyword">string</span> PhonePattern = <span class="hljs-string">@"\+?\d"</span>;<font></font>
  <font></font>
   [<span class="hljs-meta">EmailAddress</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span>? Email { <span class="hljs-keyword">get</span>; }<font></font>
  <font></font>
   [<span class="hljs-meta">RegularExpression(PhonePattern)</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span>? Phone { <span class="hljs-keyword">get</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Contact</span>(<span class="hljs-params"><span class="hljs-keyword">string</span>? email, <span class="hljs-keyword">string</span>? phone</span>)</span><font></font>
   {<font></font>
       Email = email;<font></font>
       Phone = phone;<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このようなコンストラクターを使用することもできますが、C＃ではパラメーターの1つが必要であることを示す方法はありません。</font><font style="vertical-align: inherit;">メソッドのシグネチャは、両方のパラメータがオプションであることを示します。</font><font style="vertical-align: inherit;">したがって、コンストラクターをプライベートにして、代わりに2つのパブリックメソッドを提供し、より読みやすい名前を付けます。</font><font style="vertical-align: inherit;">C＃は通常、失敗する可能性のある操作にTryプレフィックスを使用しますが、例外はスローしません。</font><font style="vertical-align: inherit;">この方法でコンストラクタを実装できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Contact</span><font></font>
{<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">TryParsePhone</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> phone, <span class="hljs-keyword">out</span> Contact c</span>)</span><font></font>
   {<font></font>
       <span class="hljs-keyword">if</span> (PhoneRegex.IsMatch(phone))<font></font>
       {<font></font>
           c = <span class="hljs-keyword">new</span> Contact(<span class="hljs-literal">null</span>, phone);
           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
       }<font></font>
<font></font>
       c = <span class="hljs-literal">null</span>;
       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TryPatternを使用したくない場合は、属性を使用できます。</font><font style="vertical-align: inherit;">属性はプログラムの実行にまったく影響を与えないメタ情報であるという事実にもかかわらず、すべてのテストがコンストラクターを通過するように強制する既製の非常に便利なAPIがあります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UserName</span><font></font>
{<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserName</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> firstName, <span class="hljs-keyword">string</span> lastName, <span class="hljs-keyword">string</span>? middleName</span>)</span><font></font>
   {<font></font>
       FirstName = firstName;<font></font>
       LastName = lastName;<font></font>
       MiddleName = middleName;<font></font>
       Validator.ValidateObject(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">new</span> ValidationContext(<span class="hljs-keyword">this</span>));<font></font>
   }<font></font>
<font></font>
   [<span class="hljs-meta">Required, StringLength(255)</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> FirstName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
   [<span class="hljs-meta">Required, StringLength(255)</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> LastName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
   [<span class="hljs-meta">StringLength(1)</span>]
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span>? MiddleName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーはどこから来たのですか</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いくつかの単純なアクションでプログラムコードでビジネスルールをより明確にすることが不可能である場合は、これで停止できます。</font><font style="vertical-align: inherit;">コンストラクターのシグニチャーからは、ユーザーがシステムに出現した状況は明らかではありません。</font><font style="vertical-align: inherit;">2つのパラメーターを1つに置き換え、明確な名前を付けます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> Contact Contact { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
  <font></font>
   <span class="hljs-keyword">public</span> UserName? UserName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">SignUp command</span>)</span><font></font>
   {<font></font>
       Contact = command.Contact;<font></font>
       UserName = command.UserName;<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ユーザーが個別に登録する（SignUp）か、友達の招待で登録する（SignUpByInvite）ことができることが明らかになりました。</font><font style="vertical-align: inherit;">招待メカニズムは、紹介プログラムがシステムに存在するという考えを読者に促す場合があります。</font><font style="vertical-align: inherit;">この変更には、別の予期しない副作用があります。</font><font style="vertical-align: inherit;">ログに2つの異なるエラーメッセージがあるとします。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザー登録中に問題が発生しました</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マーシャがパシャの招待で登録しようとしたときに問題が発生しました</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2番目ははるかに有益です。</font><font style="vertical-align: inherit;">特定のマーシャとパシャ、特定の登録プロセスであり、孤立した抽象的な登録エラーではありません。</font><font style="vertical-align: inherit;">したがって、すべての要件に精通していない新しい開発者に製品を同梱することは、やや簡単になります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> User? Invitee { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>;}<font></font>
<font></font>
   <span class="hljs-keyword">public</span> Contact Contact { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
  <font></font>
   <span class="hljs-keyword">public</span> UserName? UserName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">InviteUser command</span>)</span><font></font>
   {<font></font>
       Contact = command.Contact;<font></font>
       UserName = command.UserName;<font></font>
       Invitee = command.Invitee;<font></font>
   }<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">信念</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はORMとシリアライゼーションについてこれまで述べたことはありません。</font><font style="vertical-align: inherit;">現在でも、パラメーターを持つコンストラクターはサポートされていないと考えているプログラマーがいます。</font><font style="vertical-align: inherit;">遅いがサポートが追加されている。</font><font style="vertical-align: inherit;">ORMがパラメトリックコンストラクターに対応できない場合、プランBは常に残ります。プロキシーを使用するかどうかに応じて、パラメーターをプライベートまたは保護なしで残し、必要なパブリックコンストラクターを追加します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> User? Invitee { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>;} <span class="hljs-comment">// For ORM</span><font></font>
<font></font>
   <span class="hljs-keyword">public</span> Contact Contact { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// For ORM</span><font></font>
  <font></font>
   <span class="hljs-keyword">public</span> UserName? UserName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// For ORM</span><font></font>
  <font></font>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>)</span> { } <span class="hljs-comment">// For ORM</span><font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">InviteUser command</span>)

   <span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">SignUp command</span>)
}
</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ORMは、アクセス修飾子にかかわらず、パラメーターなしでコンストラクターを使用し、パブリックコードはプログラムコードで使用する必要があります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> User? Invitee { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>;} <span class="hljs-comment">// For ORM</span><font></font>
<font></font>
   <span class="hljs-keyword">public</span> Contact Contact { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// For ORM</span><font></font>
  <font></font>
   <span class="hljs-keyword">public</span> UserName? UserName { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">protected</span> <span class="hljs-keyword">set</span>; } <span class="hljs-comment">// For ORM</span><font></font>
  <font></font>
   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">User</span> (<span class="hljs-params"></span>)</span> { } <span class="hljs-comment">// For ORM</span><font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">InviteUser command</span>)

   <span class="hljs-keyword">public</span> <span class="hljs-title">User</span> (<span class="hljs-params">SignUp command</span>)
}
</span></code></pre><br>
<blockquote>       ,       public.    -,    .<br>
<br>
,    async/await.         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Asynchronous Injection</a>. <br>
<br>
          ,  TryPattern.      -  .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">   </a>.<br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の結果を要約します。</font><font style="vertical-align: inherit;">豊富なモデルのおかげでスコアは1-0だと思います。</font><font style="vertical-align: inherit;">いくつかのささいな変換を行った結果、コードの可読性が向上し、ビジネスルールが明確になり、プログラムの保守の信頼性と利便性が向上しました。</font><font style="vertical-align: inherit;">より複雑なシナリオに移りましょう。</font><font style="vertical-align: inherit;">これまでは、エンティティと値オブジェクトのみを使用してきました。</font><font style="vertical-align: inherit;">ユニットはどうですか？</font><font style="vertical-align: inherit;">オブジェクトのグループ全体の不変条件はどのように提供されますか？</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計の典型的な例は、オンラインストアでの注文です。</font><font style="vertical-align: inherit;">注文が支払われて配送された場合、新しい商品を追加するには遅すぎます。</font><font style="vertical-align: inherit;">したがって、注文の商品のリストを公開することはできません。それ以外の場合は、ステータスに関係なく、プログラマーがこのプロパティを使用して商品を追加できます。同時に、クラスの署名によって注文のステータスと商品の関係が通知されなかったため、完全に正しくなります。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">private</span> List&lt;CartItem&gt; _cartItems = <span class="hljs-keyword">new</span> List&lt;CartItem&gt;();<font></font>
<font></font>
   <span class="hljs-keyword">public</span> IReadOnlyList&lt;CartItem&gt; CartItems =&gt; _cartItems;<font></font>
  <font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Product product</span>)</span><font></font>
   {<font></font>
       _cartItems.Add(<span class="hljs-keyword">new</span> CartItem(<span class="hljs-keyword">this</span>, product));<font></font>
   }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この問題に対する同様に古典的な解決策は、外部の読み取り専用リストを提供し、必要なチェックを含む特殊なメソッドを使用して操作を書き込むことです。そして、この瞬間から最初の問題が始まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
パターン集約-紙の上では非常に良く見えますが、練習になるとかなり厄介であることがわかります。集合体は単一のオブジェクトではなくツリー全体であるため、本質的にエンティティや値オブジェクトよりも複雑です。したがって、エンティティのレベルでは重要ではないと思われた問題は、オブジェクトのツリーが成長し、状態が組み合わされる可能性があるため、非常に不愉快になります。注文を処理する一般的なシナリオ、在庫状況の確認、送信、キャンセルについて考えてみましょう。</font></font><img src="https://habrastorage.org/webt/c3/8k/ex/c38kexagtkrsuqy6rheap4b_pee.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
支払い前に在庫状況を確認する必要がありますか？要件によって異なります。支払い前に注文できますか？一部の店舗では、宅配便で受領時に支払うことができますが、ほとんどの場合、配達が市内にある場合のみです。購入者に正常に配達された注文をキャンセルすることはできますか？ほとんどの場合、設計には十分なステータスがなく、「キャンセル」されていない方がいいですが、新しいステータスは「試用版」であり、配送中に商品が破損したか、倉庫で何かを混ぜたかなど、まったく新しいプロセスが開かれます。バイヤーが何かを混乱させ、彼が注文したものを正確に彼に持ってきたかどうか。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
対応する注文状態に関連付けられたデータとメソッドは、1つの状態のフレームワーク内でのみ意味があります。</font><font style="vertical-align: inherit;">私たちは再びすべてを1つのクラスにまとめ、美味しくてまだビネグレットを食べました。</font><font style="vertical-align: inherit;">したがって、スコアは1-1でした。</font><font style="vertical-align: inherit;">貧血モデルは、特にオブジェクトのグループについては不変条件が尊重されると主張したことはなく、ビジネスルールがプログラムコードから明確になるとは約束しなかったため、貧血モデルのフレームワークの設計に関する不満はありませんでしたが、豊富なモデルについては疑問がありました。</font><font style="vertical-align: inherit;">表現力はどこにありますか？</font><font style="vertical-align: inherit;">ビジネスルールの静的分析はどこにありますか？</font><font style="vertical-align: inherit;">それは、少なくとも古典的なオブジェクト指向言語ではそうではありません。</font><font style="vertical-align: inherit;">しかし、そのような可能性は、より強力な型システムを持つ機能的なPLに存在します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F＃では、すべてが異なります</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
F＃には、いわゆる代数的データ型があります。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レコード</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（そう、C＃9に持ち込まれるものそのもの）と</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">識別された共用体</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><img src="https://habrastorage.org/webt/bh/bb/th/bhbbthhv2fx9h7ogvjb_7n3e-sk.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C＃での差別化された労働組合のサポートは、近い将来計画されていません。あなたはそれらをステロイドの列挙型と考えることができます。従来の列挙型とは対照的に、次のような他の型を差別化された共用体列挙型に含めることができますと記録。そのため、そのような型システムは「代数的」と呼ばれます。レコードはタイプ「and＆」であり、識別された共用体0はタイプ「or |」です。したがって、小さな型を1つの方法で組み合わせることで、アプリケーション全体を構築できます。</font></font><img src="https://habrastorage.org/webt/dw/_x/kx/dw_xkxho75rincwvzkrwxvqxmpi.gif"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPで一般的なポリモーフィズムとは対照的に、ポリモーフィズムに基づく制御フローでは、</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">パターンマッチング</font></a><font style="vertical-align: inherit;">を使用した制御転送がよく使用され</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">識別された共用体のサブタイプごとに、独自の実行ブランチを作成する必要があります。このブランチでは、オブジェクトの特定の状態内で意味のあるデータと動作のみを使用できます。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">この問題はF＃を使用しなくても解決できますが、C＃ではソリューションの見栄えが低下します。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">20年後の「設計パターン」「状態」</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">という記事</font><font style="vertical-align: inherit;">は、</font><font style="vertical-align: inherit;">最新のC＃言語構成を使用</font><font style="vertical-align: inherit;">した古典的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPパターンに</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基づく機能的アプローチを模倣しています</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">執筆時点では、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スイッチ式</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はまだリリースされていません。</font><font style="vertical-align: inherit;">これにより、パターンマッチングの見栄えが良くなります。</font><font style="vertical-align: inherit;">Roslynアナライザーを作成すると、すべての相続人の分析を制御できます。</font></font><br>
</blockquote> <img src="https://habrastorage.org/webt/8f/1h/4x/8f1h4xw7rk07zfoou531tu1ihtu.gif"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私はプログラミング言語を変更しなければならなかったという事実にもかかわらず、リッチモデルにもう1つポイントを与えることができると思います。</font><font style="vertical-align: inherit;">スコアは2：1になります。</font><font style="vertical-align: inherit;">F＃はC＃と互換性があり、オブジェクト指向のパラダイムをサポートしているため、C＃と組み合わせてF＃またはF＃のみを使用すると、さまざまな状態でのさまざまな動作の問題を解決できます。</font><font style="vertical-align: inherit;">残念ながら、喜ぶには早すぎます。</font><font style="vertical-align: inherit;">問題のあるスクリプトのスクリプトがさらにいくつかあります。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメインとインフラストラクチャ</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">分散トランザクション</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「クラシックFowler-evansvo」DDDは、インフラストラクチャとドメインを分離する必要があると主張しています。しかし、インフラストラクチャがドメインの一部になるとどうなるでしょうか。どうして？簡単です。たとえば、ワークフローシステム。何十万ものドキュメントのデータをダウンロードしてデジタル署名し、データを解析して処理する必要があると想像してください。バイナリファイルを毎回開くことはできません。したがって、新しいドキュメントを追加したり、古いドキュメントを編集したりするときに、バイナリファイルとリレーショナル構造のデータの一貫性を確保するメカニズムが必要になります。</font></font><img src="https://habrastorage.org/webt/df/uz/1h/dfuz1hchrerctjdhpybzznw4ob8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような保証は、ファイルストレージシステムとデータベースの両方に関連するエラー処理に基づいています。</font><font style="vertical-align: inherit;">最初または2番目の更新時にエラーが発生した場合、補正が実行されます。ダウンロードされたファイルが削除されるか、トランザクションがデータベースにロールバックされます。</font><font style="vertical-align: inherit;">はい、分散トランザクションメカニズムがあります。</font><font style="vertical-align: inherit;">彼らがインフラストラクチャで作業した場合、問題はデータウェアハウスには存在しません。</font><font style="vertical-align: inherit;">残念ながら、これはそうではなく、多くの場合、特定のプロジェクトとそのインフラストラクチャに固有のコードを記述する必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを開発者に委任できますが、各開発者が十分な責任を負い、何かを処理することを忘れないという保証はどこにありますか？</font><font style="vertical-align: inherit;">私の経験では、そのような保証を与えることはできません。</font><font style="vertical-align: inherit;">スコアは2と比較されます：2。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何かを保証する唯一の方法は、選択する機会を取ることだと思います。</font><font style="vertical-align: inherit;">publicをinternalに置き換え、これらのオブジェクトを1つのアセンブリに配置し、特殊なサービスメソッドを介してpublic APIを提供する場合、潜水艦からどこにアクセスしますか？</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Document</span>&lt;T&gt; : <span class="hljs-title">Document</span><font></font>
{ <font></font>
    <span class="hljs-keyword">try</span> <font></font>
    {      <font></font>
       <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-title">Document</span>(<span class="hljs-params">UploadedFile file, T meta</span>)</span>;<font></font>
<font></font>
       <span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Update</span>(<span class="hljs-params">UploadedFile file, T meta</span>)</span>;<font></font>
    }<font></font>
}<font></font>
<span class="hljs-keyword">catch</span>(FileStorageException)
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">catch</span>(SqlException)
<span class="hljs-comment">// ...</span>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス層</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドキュメントを更新するには、次のようにします。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント自体とダウンロードしたファイルの両方をUpdateメソッドに渡します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fileStorageにファイルをアップロードしようとしています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データベースにデータを書き込もうとしています。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">try-catchハンドラーを作成します。問題が発生した場合は、ファイルストレージをロールバックしてください。</font><font style="vertical-align: inherit;">ファイルストレージがロールバックしない場合は、このエラーを保護して、後で解決できるようにします。</font></font></li>
</ol> <img src="https://habrastorage.org/webt/et/wi/o-/etwio-fp4rchd4tcncuajp8lyi8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、誰もがこの特定の方法を使用します。</font><font style="vertical-align: inherit;">私はこの恐ろしい騒々しいコードを決して記述しないでここに残したいと思います-そのため、それは1つのサービスだけにあり、内部キーワードはそれを行うのに役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインモデルのサービスレイヤーははるかに薄く、特定のタスクを処理します。</font><font style="vertical-align: inherit;">すべてのビジネスロジックではなく、たとえばインフラストラクチャとの通信に役立ちます。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一緒</font></font></h2><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティ+値オブジェクト：オブジェクトのプロパティは、個別におよび一緒に正しいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計：オブジェクトのグループは正しいです。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマッチング：状態ごとに異なる動作。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">サービス+内部：インフラストラクチャとドメインが同期されます。</font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">主な質問は、DDD、人生の意味などです。</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OutOfMemoryExceptionで操作がクラッシュした場合、または10時間実行した場合の対処方法 </font><font style="vertical-align: inherit;">この質問に答える前に、Erlang言語開発者のJoe Armstrongを引用します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなた</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はバナナ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">手に入れ</font></a><font style="vertical-align: inherit;">たいのです</font><font style="vertical-align: inherit;">が、バナナとそれに加えてすべてのジャングルを持つゴリラを手に入れます。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OOPに固有の暗黙の可変状態に関する皮肉を聞いていますか？</font><font style="vertical-align: inherit;">参照によってオブジェクト、特にインターフェイスリンクを操作し、実際の実装がわからない場合は、外部リンクの数がわかりません。</font><font style="vertical-align: inherit;">そして、まさに「ジャングル」が得られます。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/nb/bx/ok/nbbxokx74iircv6jkzb2yo2iabo.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
確かに、2：3。</font><font style="vertical-align: inherit;">大きな集合体はOutOfMemoryExceptionから落ちるため、何もできません。</font><font style="vertical-align: inherit;">少なくともオブジェクトパラダイムでは。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cRud</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてを読み取りスタックにロードしたくない場合を除きます。そして、読み取りスタックでは、何もロードしたくないことがよくあります。したがって、OOPの世界では、この質問に対する答えは多少異なり、SQLクエリを作成するように聞こえます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これに先立って、正しいドメインモデルを作成する必要があること、SQLクエリは絶対に作成しないでください、すべてが客観的である必要があることを説明しました。次に、「SQLクエリを作成しましょう」と言いました。外出中に靴を交換するのではなく、DDDがツールです。ドメインモデリングはツールであり、パターンです。すべての状況で機能するスイスのナイフはありません。レポートはDDDの悪用です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
読み取りスタックは、DDDを制御するものがないため、DDDの多くの場合、悪用されます。データを読み取るだけです。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここでは、データへのアクセスを提供する重要な側面を省略します。</font><font style="vertical-align: inherit;">もちろん、読むだけでなく「読む」必要もあります。</font><font style="vertical-align: inherit;">読み取りスタックでORMを使用する場合、記事「</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=https://habr.com/ru/post/414897/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マルチユーザーアプリケーションでのデータアクセス」に</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">興味があるかもしれません</font><font style="vertical-align: inherit;">。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、レコーディングスタックでは、これは非常に適しています。</font><font style="vertical-align: inherit;">さらに、HTTPプロトコルはPOSTメソッドとDELETEメソッドがサーバーの状態を変更し、データを返さず、READメソッドを読み取る必要があることを明確に示しているため、CQRSは原則としてHTTPの一種のシンビオントです。</font><font style="vertical-align: inherit;">したがって、アプリケーションがWeb上にある場合は、この機会を利用してみませんか。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クラッド</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインモデルを読み取りスタックにスローすることで問題を回避しましたが、他の場合はどうすればよいですか？古典的な答えはこれです。あるユニットから別のユニットに参照でリンクしないでください。あなたは幸せになります。この議論には特定のニュアンスがあります。誰かがこれは流動的な抽象概念であると信じていますが、これはあまり良いとは言えませんが、うまくいきます。少なくとも、ユニットが非常に大きくなるまでは。</font></font><br>
<img src="https://habrastorage.org/webt/uc/gd/91/ucgd91u7jfmjeqspm9yrbsjx5wg.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらが少し大きくなるか非常に大きくなるとすぐに、特定の集合の集合が落ち始めませんが、それは1つです。</font><font style="vertical-align: inherit;">あなたがそのようなユニットを持っているなら、おそらくこれらは間違ったユニットであり、間違った蜂蜜を作ります。</font><font style="vertical-align: inherit;">それらを誤って切り刻んだ可能性があります。</font><font style="vertical-align: inherit;">非常にまれですが、これが避けられない場合もあります。</font><font style="vertical-align: inherit;">次に何をすべきか？</font><font style="vertical-align: inherit;">私が今お答えする答えは、「悪い」レベルから「非常に悪い」レベルへと下り坂になるとすぐに警告します。</font></font><br>
<a name="cases"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">傾斜（「悪い」ケース）</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちはしっかりしていません</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「悪い」レベルに行き、自分自身の質問に答えてみましょう：SOLIDに本当にどれだけ感謝していますか？</font><font style="vertical-align: inherit;">原則Dがあなたにあまり近くなく、抽象化が抽象化または実装に依存する理由が本当にわからない場合、一般に気にしない-結構です、ここにIQueryableを配置するだけで、心配する必要はありません。</font><font style="vertical-align: inherit;">はい、私たちは原則に違反しました-それで何ですか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
LINQを使用しても何も違反していないと思われる場合は、ラムダ</font></font><code>x =&gt; x.OrderId == Id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を他の</font><font style="vertical-align: inherit;">ものに置き換えてみてください</font><font style="vertical-align: inherit;">。Lの原則はここで満たされますか？</font><font style="vertical-align: inherit;">ここで原則Lが常に満たされていると確信している場合は、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">悪いニュース</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">があります</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これは、特定の条件下での抽象化が流れ始めることを意味します。</font><font style="vertical-align: inherit;">それはあなたのピューリタン育成がそれを許すか許さないかに依存します。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> IQueryable&lt;OrderItem&gt; ItemsQuery <font></font>
       =&gt; _dbContext<font></font>
           .Set&lt;OrderItem&gt;<font></font>
           .Where(x =&gt; x.OrderId == Id);<font></font>
}<font></font>
</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">遅延ロード</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「悪い」オプション-私は絶対的な悪に移行しています-レイジーロードをオンにします。</font><font style="vertical-align: inherit;">それは多くの理由で良いです：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デメテルの法則</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">持続性の無知</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ボイラープレートが少ない</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使いやすさ</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それにもかかわらず、彼には多くのよく知られた問題があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パフォーマンス</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">予期しないIO</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リフレクションまたはランタイム生成コードで起こりうる問題</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一括操作</font></font></li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デザインは妥協です</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
理想的なツールがないということをすでに2回繰り返しているようです。常に妥協点があり、設計は妥協点です。私の観点からは、これは繰り返しますが、重要な注意点です。読み取りスタックでDDDを作成できない場合でも、DDDを実行できなかったということではありません。そのDDDは悪い-これはDDDがこのタスクには悪いツールであることを示唆しているので、別のツールを入手してください。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/va/o7/8q/vao78qhr7felnavqjfh7waavqpk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すべてを絶対的なレベルに引き上げて「いいえ、私たちはそのようなコードを記述しません。FowlerEvans、Vernan-誰もが-あなたはできない」と言ったので、すぐにフラストレーションだけが発生します。</font><font style="vertical-align: inherit;">これらの人だけが（スライドで映画「スター・ウォーズ」のキャラクターが）すべてを絶対的なものに引き上げます。</font><font style="vertical-align: inherit;">したがって、私が提案したソリューションの最高品質ではなく、すべての予約にもかかわらず、同じスコア（3：3）があると仮定しましょう。</font></font><br>
<a name="work"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">回避策</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
集計に戻りましょう。使用する貧弱なモデルやリッチモデルに関係なく、大きな集計はまだここにあります。</font><font style="vertical-align: inherit;">つまり、データベースの半分をドラッグして何かを計算する場合、デフォルトでは、このアプローチはデータベースをクエリするよりも効果が低くなります。</font><font style="vertical-align: inherit;">ネットワーク経由でデータをドラッグする必要がないため、手書きのリクエストに答えることは常により効果的です。RAMにデータを取り込み、そこで読み取ることができます。</font><font style="vertical-align: inherit;">データベースは、アプリケーション内でこれを行います。</font><font style="vertical-align: inherit;">これは、特定のクラスのタスクについて、オブジェクトモデルがまったく適合しないことを意味しますか？</font><font style="vertical-align: inherit;">私たちがJavaで作業していたとしたら、「はい、そうです」と言います。</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">式</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
.NETには、この制限を克服する技術、Expression Treeがあります。</font><font style="vertical-align: inherit;">意図した目的、つまりC＃コードを記述するために使用したり、データ構造として使用したり、必要な方法でデータ構造をバイパスしてさらに変換したりできます。</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初にデータセット全体を引き出してからRAMでフィルタリングする必要があったため、「仕様」パターンはオブジェクトでのみ機能し、パフォーマンスの問題を引き起こしていました。</font><font style="vertical-align: inherit;">C＃では、このパターンは新たな動きを見せます。価格がゼロより大きい特定の製品のみを販売するというルールがある場合、このルールを式として宣言できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> Spec&lt;Product&gt; IsForSale { <span class="hljs-keyword">get</span>; } =&gt;<font></font>
 <font></font>
    <span class="hljs-keyword">new</span> Spec&lt;Product&gt;(x =&gt; x.Price &gt; <span class="hljs-number">0</span>);
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それぞれC＃コードのように見えますが、ドメインモデルの一部にすることができますが、C＃コードとして実行することはありません。データベースクエリに変換するために使用します。</font></font><img src="https://habrastorage.org/webt/hc/1n/c0/hc1nc0bq5sxwo3_xw5y2es92eww.gif"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同時に、非常に効果的なリクエストをいただいています。</font><font style="vertical-align: inherit;">また、オブジェクト、集計、またはエンティティが大きすぎる場合、それらを完全に読み取る必要はありません。C＃とプロジェクションを使用して、このデータの一部のみをDTOの形式で読み取り、より効率的なプログラムを作成できます。</font><font style="vertical-align: inherit;">また、匿名型を作成する必要もありません。</font><font style="vertical-align: inherit;">AutoMapperまたはMapsterを使用する場合、通常は命令コードの量を減らし、それを宣言型に置き換えることができます。</font></font><br>
<br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルトのインターフェースの実装</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、古典的なOOPパラダイムでは正確には不可能であったいくつかの興味深い抜け穴が発生します。</font><font style="vertical-align: inherit;">まず、C＃の8番目のバージョンでは、デフォルトのインターフェース実装を取得しました。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> : <span class="hljs-title">EntityBase</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span> Price { <span class="hljs-keyword">get</span>; }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span> DiscountPercent { <span class="hljs-keyword">get</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span> <span class="hljs-title">DiscountedPrice</span>(<span class="hljs-params"></span>)</span> 
       =&gt; Price - Price / <span class="hljs-number">100</span> * DiscountPercent;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同じオブジェクトに配置した割引を計算するロジックが製品にあるとしましょう。つまり、リッチモデルを作成しようとしました。</font><font style="vertical-align: inherit;">このようなデザインには、先ほどお話したすべての問題が伴います。大量の商品を引き抜く必要がある場合、必然的に記憶は終わります。</font><font style="vertical-align: inherit;">これを最適化したいと思います。エンティティでメソッドを直接宣言する代わりに、デフォルトの実装を使用してインターフェースにメソッドを転送できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IHasDiscount</span><font></font>
{<font></font>
   <span class="hljs-keyword">decimal</span> Price { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }
   <span class="hljs-keyword">decimal</span> DiscountPercent { <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">decimal</span> <span class="hljs-title">DiscountedPrice</span>(<span class="hljs-params"></span>)</span> 
       =&gt; Price - Price / <span class="hljs-number">100</span> * DiscountPercent;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、このインターフェースはエンティティとDTOの両方に「スタック」できます。</font><font style="vertical-align: inherit;">直接、コードはどちらのオブジェクトにも配置されますが、インターフェイスの実装に配置されます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductListItem</span> : <span class="hljs-title">IHasDiscount</span><font></font>
<font></font>
<span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">IHasDiscount</span><font></font>
{<font></font>
   <span class="hljs-keyword">decimal</span> Price { <span class="hljs-keyword">get</span>; }
   <span class="hljs-keyword">decimal</span> DiscountPercent { <span class="hljs-keyword">get</span>; }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">decimal</span> <span class="hljs-title">DiscountedPrice</span>(<span class="hljs-params"></span>)</span> 
       =&gt; Price - Price / <span class="hljs-number">100</span> * DiscountPercent;<font></font>
}<font></font>
</code></pre><br>
<h3><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一括拡張</font></font></a></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大量操作の場合、式はアクションの自由も提供します。</font><font style="vertical-align: inherit;">ロジックをSQLに転送したくない場合は、式をC＃コードに残しておくことができます。</font><font style="vertical-align: inherit;">次に、Bulk Extensionsなどを使用して、C＃で同じ仕様を使用できます。この例では、現在販売していないすべての商品を削除するか、まだ販売している商品のコストを100ドルまたはルーブルだけ引き上げます。</font></font><img src="https://habrastorage.org/webt/i2/jn/yd/i2jnyd2v6obuktgj02rxj2muj_m.gif"> <h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それともF＃？</font></font></h3><br>
<img src="https://habrastorage.org/webt/zy/8u/k1/zy8uk1jcqv-zp1lmrtcuyxih2n4.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、これらの抜け穴のいくつかを使い始めたらすぐに、プログラミング言語を書いているのでしょうか。それが私が使うツールなのでしょうか。</font><font style="vertical-align: inherit;">インターフェースのデフォルトの実装は、実際には、インターフェースを使用してあらゆるタイプのデータに「固定」できる関数であるためです。</font><font style="vertical-align: inherit;">ドメインモデルを実装するためにF＃に切り替えることは価値がありますか？プロジェクトのニーズに基づいて、誰もが自分で決定します。</font><font style="vertical-align: inherit;">あえて引っ越したわけではありません。</font><font style="vertical-align: inherit;">それにもかかわらず、他のいくつかのプログラミング言語の方向を見ることは、そこからいくつかのアイデアを借りるために役立つ可能性があります。</font></font><br>
<a name="context"></a><br>
<h2><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">境界付きコンテキスト</font></font></a></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
どちらのモデルが使用されているかに関係なく（リッチか貧弱か）、管理しやすいという理由だけで、アプリケーションを小さなアプリケーションに分割すると便利です。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0f/pe/bc/0fpebcqojrtjl1y3v2rlw7nhk8a.jpeg"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">偽の集計</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
骨材が成長する傾向があるという事実について話しました。これは、マイクロソフトのドキュメントを使用し、盲目的にそれに従っている場合に発生します。たとえば、関連するコレクションを宣言する場合、通常、それらを2つの方向にバインドします。しかし、ユーザーがシステムで多くのことを実行できる場合、Userオブジェクトは非常に大きくなります。これがアンチパターン「神のオブジェクト」です。</font></font><br>
<img src="https://habrastorage.org/webt/s8/ya/3v/s8ya3vtdezn0ca1ednzrm7gszq0.gif"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、もし彼がメモリリソースを無駄にしただけなら、式でこれを最適化できます。このアプローチでは、注文にユーザーのセット、コメントに製品のセットなどを含めることができるため、多数の循環依存関係も生成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらすべてのオブジェクトが1つのアセンブリに存在する限り、AはBに依存し、BはCに依存し、CはAに依存します。その結果、大きくてひどいモノリスができます。</font><font style="vertical-align: inherit;">重要なのは、この集計が偽であり、ユーザークラスで可能なすべてを組み合わせているため、実世界には存在しないということです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
では、どうやって集約のルーツを見つけ、正しい方法でそれらを選択するのでしょうか？</font><font style="vertical-align: inherit;">あなたがユニットを持っているかどうかを理解する可能性が非常に高いことに答えることによって、質問の2つのリストがあります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問の最初のリスト（組織に関するものであり、テクノロジーに関連するものではない）</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実世界にアナログはありますか？</font><font style="vertical-align: inherit;">（アナリストにこの質問をしてください。）</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">あなたのデザインについてビジネスユーザーに伝えるとき、彼らはあなたを地元の狂人だと思いますか？</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたが狂っているとは見なされず、彼らが「はい、私たちはそのように働いています」と言ったら、あなたはマシンを正しく見つけました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">質問の2番目のリスト（技術）</font></font></h4><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユニットは境界付きコンテキストを越えませんか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このオブジェクトのグループに不変条件はありますか？</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単一のトランザクションでデータを変更する必要がありますか？</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
彼のすべての質問に対する答えが「はい」である場合、ユニットは正しいです。</font><font style="vertical-align: inherit;">私たちの場合、これらすべてに対する答えは「いいえ」です。</font><font style="vertical-align: inherit;">注文は別のもので、ユーザー設定は異なり、製品レビューは3番目です。</font><font style="vertical-align: inherit;">したがって、この集約を3つの小さな集約に分割し、循環依存の数を減らします。</font><font style="vertical-align: inherit;">さらに、それらを別のアセンブリに転送し、これらのクラスでの作業をチームに委任できます。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> : <span class="hljs-title">User</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> ICollection&lt;Order&gt; Orders =&gt; _orders;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> : <span class="hljs-title">User</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> ICollection&lt;Setting&gt; Settings =&gt; _settings;<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Blogger</span> : <span class="hljs-title">User</span><font></font>
{<font></font>
   <span class="hljs-keyword">public</span> ICollection&lt;Comment&gt; Comments =&gt; _comments;<font></font>
}<font></font>
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメインモデルを境界付きコンテキストに分割する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ドメインモデルを境界付きコンテキストに分割する方法 </font><font style="vertical-align: inherit;">結局のところ、コンテキスト内にはエンティティーと集合体があるとすでに述べました。</font><font style="vertical-align: inherit;">エンティティは小さいため、めったに離れない傾向があり、以前に「神」の集計の例を示しました。</font><font style="vertical-align: inherit;">また、2つのコンテキスト間でアグリゲートがクロールされたことがわかった場合、それは誤りです。</font><font style="vertical-align: inherit;">ただし、このルールは逆の方向にも機能します。単位が正しいことが確実で、上記の質問に対する答えが「はい」の場合、コンテキストを誤って切り取ったようです。</font><font style="vertical-align: inherit;">したがって、「ドメインモデルを制限されたコンテキストにカットする方法」という質問への回答-集計の境界に沿って。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/hy/b-/e5/hyb-e5luxa-1okcdiwxbzwzkhno.gif"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マイクロサービス上のモノリス</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この質問は、よりおしゃれに再定式化できます。モノリスをマイクロサービスに分割する方法は？プログラムをサブモジュールに分割することは、一般にシステムが分散されているかどうかに依存するとは思いません。分散システムには、データが異なるプロセスにあり、何かを常にシリアル化および逆シリアル化する必要があるという事実に関連するいくつかの追加の問題が伴います。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/3f/53/ar/3f53arrb2bt_mqacuj2lh2cc2ik.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、それにもかかわらず、その答えは次のとおりです。ドメインモデルをさまざまな境界コンテキストにドラッグし、境界コンテキストは独立したマイクロサービスであり、恐ろしいモノリスから多くの小さな美しいマイクロサービスを取得したと述べました。</font><font style="vertical-align: inherit;">そして、注意してください、鋸で切られない恐ろしいモノリスに関連するすべての問題は、ほとんどの場合、切り離すのが難しい循環依存関係があるという事実に関連しています。</font><font style="vertical-align: inherit;">最初の瞬間にこれらの依存関係が存在しない場合は、アプリケーションをいくつかのプロセスに分割する方がはるかに簡単です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンテキストの境界を越える方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あるコンテキストから別のコンテキストに切り替える必要がある場合はどうすればよいですか？彼らは独立しているという事実にもかかわらず、これも起こります。同じプロセスで機能するさまざまなサービスまたはさまざまなアセンブリがあるかどうかに関係なく、1つのコンテキストが別のコンテキストに依存している場合は、これらのオブジェクトへのリンクがあるため、一方向に到達する方が簡単です。同じアセンブリ内で暗黙的に行われていた循環依存関係が明示的になるため、反対側は機能しません。コンパイラーは、2つのアセンブリーを使用して互いに参照することを許可しなくなります。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ld/ja/z5/ldjaz5h7se0qt1giejbjqg-z-lm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この状況に対する古典的な解決策は、イベントを使用することです。</font><font style="vertical-align: inherit;">イベントはシリアル化され、コンテキストの境界を越えることができます。</font><font style="vertical-align: inherit;">イベントを正確に「スロー」する方法は別の話です。</font><font style="vertical-align: inherit;">これがマイクロサービスの場合は、バスが必要になる可能性が高いです。</font><font style="vertical-align: inherit;">これが単一のアプリケーションの場合、これはメモリ内で実行できます。</font><font style="vertical-align: inherit;">いずれにしても、これらすべてのイベントをリッスンし、タイプごとに異なるハンドラーに送信するディスパッチャーになります。</font><font style="vertical-align: inherit;">あるコンテキストから別のコンテキストにいくつかのイベントに応答する必要がある場合は、イベントを「破棄」して、必要なコンテキストでそれらを処理します。</font></font><a name="choice"></a><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">何を選ぶ？</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
何を選ぶ？</font><font style="vertical-align: inherit;">豊富なモデルまたは貧血モデル？</font><font style="vertical-align: inherit;">私たちは同じスコアを持っているという事実に落ち着きました。</font><font style="vertical-align: inherit;">いずれにせよ、私は5〜6年にわたって企業システムの開発を管理してきましたが、私はリッチモデルを好みます。</font><font style="vertical-align: inherit;">しかし、常に、リッチモデルを実装しようとしたときに、それが高価であるだけでなく、信じられないほど高価であることに気付きました。</font><font style="vertical-align: inherit;">したがって、この質問に答える前に、そのような平面を描くことをお勧めします。横軸はドメインの複雑さであり、縦軸はプロジェクトの技術的な複雑さです。</font></font><br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単純なドメインでの技術的に複雑なプロジェクトはDDDで実行するべきではありません。それらには他の困難があります。テクノロジーに問題があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複雑なドメインで技術的に複雑なプロジェクトを実行する方法がまだわからないので、そのようなプロジェクトを実行しないことを提案します。まったく実行しないという意味ではなく、プロジェクトをより小さなプロジェクトに分割するという意味で。</font></font></li>
<li>        —   .</li>
<li>        —    DDD. , ,    , ,  ,  —   . ,   ,                   ,       ,    .</li>
</ol><br>
<br>
<img src="https://habrastorage.org/webt/f0/bp/xv/f0bpxv4buvqu3hcglxwf-dnooj4.gif"><br>
<br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでも、プロジェクトの開始時に、それが難しいかどうかがよくわからなかった場合。</font><font style="vertical-align: inherit;">または、プロジェクトが3、6、12、24か月続くかどうかはわかりません-私の観察によれば、3か月後にどこかで結果が出始めます-そして、再び、貧血モデルから始めていくつかを実装することを妨げるものは何もありませんあなたがそれらを要求し始めたときのパターン。</font><font style="vertical-align: inherit;">最初の段階では、自分自身を次のように制限することはかなり合理的です。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カプセル化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仕様</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンティティおよび値オブジェクト</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらのオーバーヘッドはほとんどなく、簡単に実装できるという結論に達しましたが、プログラマーには多くの追加情報があります。</font><font style="vertical-align: inherit;">使用を開始できる次のステップ：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">集計</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">境界付きコンテキスト</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パターンマッチング</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
AgregateとBounded Contextは正確に連携して、境界を正しく分割します。</font><font style="vertical-align: inherit;">最近、行く：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一括操作</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">イベント</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IHasインターフェース</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この段階に達している場合は、プログラミング言語を変更するか、複雑なドメインを持っているだけかもしれません。ここにあるすべてはそれほど明白ではありません。</font><font style="vertical-align: inherit;">これらの手法は困難であり、より適切に実行するための明確な指示がないため、これらの手法はできるだけ遅く実装することをお勧めします。</font></font><br>
<a name="ref"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">役立つリンク</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちは長い間DDDを分析してきたという事実にもかかわらず、私はあなたに言った、おそらくこのトピックに関する一般的なものの10％。</font><font style="vertical-align: inherit;">したがって、私は自分のストーリーをよく補完する資料を選びました。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ロシア語で</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">エンタープライズ開発式ツリー</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">インスタントデザイン</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ビジネスオブジェクトの後の人生</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドメイン主導の設計：実用主義者のためのレシピ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entity Framework Coreを使用したDDDスタイルのエンティティ</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DDDの基本に関するチートシート</font></font></a></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英語で</font></font></h4><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソフトウェアの中心にある複雑さに取り組む</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F＃タイプシステムで機能するドメインモデリング</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">削除しないでください</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Design Smell: Redundant Required Attribute</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">EF Core 2.1 vs NHibernate 5.1: DDD perspective</a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">Value Object: a better implementation</a></li>
</ul><br>
<blockquote>     MC (Master of Ceremonies)   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=">DotNext 2020 Piter</a>,    15  18 .  -         ,   Scott Hanselmann  Jon Skeet.</blockquote><br>
<blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link">indienkova</a>     .          .<br>
</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja503858/index.html">本「Terraform：コードレベルのインフラストラクチャ」</a></li>
<li><a href="../ja503860/index.html">ニューラルネットワーク環境の設定R-CNNマスク</a></li>
<li><a href="../ja503862/index.html">画期的な製品を生み出す成功への対価としての心理的問題</a></li>
<li><a href="../ja503864/index.html">Flutterのフレーバー組織</a></li>
<li><a href="../ja503866/index.html">2020年のロードマップ開発Zextras Suiteを公開</a></li>
<li><a href="../ja503876/index.html">ESP32の組み込みデバイス用のゲームのプログラミング：ドライブ、バッテリー、サウンド</a></li>
<li><a href="../ja503880/index.html">心配しないことを学び、マシンビジョンを愛した方法</a></li>
<li><a href="../ja503884/index.html">非同期で作業する方法を学ぶ方法</a></li>
<li><a href="../ja503888/index.html">AdaBoostアルゴリズム</a></li>
<li><a href="../ja503890/index.html">ReactおよびReact Nativeパート1でAzure AD B2Cを構成した方法の物語（チュートリアル）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>