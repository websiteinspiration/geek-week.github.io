<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎽 💱 🛌🏽 車にコードからテストを書く方法 👩🏽‍⚕️ 🖕🏼 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="私たちは不完全な世界に住んでいます。ここではコードを記述しますが、間違いを犯しがちです。すべてが問題なく、テスト段階でエラーが検出され、誰にも害が及ばないようにすることができます。テストを書けば可能です。どういうわけか人々が嫌いなこと。しかし、おそらく希望がある-書かれたコードからのテストの自動生成...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>車にコードからテストを書く方法</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/490670/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちは不完全な世界に住んでいます。ここではコードを記述しますが、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">間違いを犯しがち</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。すべてが問題なく、テスト段階でエラーが検出され、誰にも害が及ばないようにすることができます。テストを書けば可能です。どういうわけか人々が嫌いなこと。しかし、おそらく希望がある-書かれたコードからのテストの自動生成。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Julia Volkovaは、アイデアを実際にテストしたいと考えており、追加の指示やコントラクトを使用せずに、コードに基づくテストの作成をマシンにシフトしようとしています。ジュリアは、旅がメタプログラミング、AST、構文解析、トークン化の世界にもたらす発見について、そして</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">モスクワのPython会議++</font></a><font style="vertical-align: inherit;">で、テストの自動生成でこれを実現するために何が可能になったかについて説明し</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">その間、私はアイデアがどこから来たのかを尋ねました-テストを自動化するために、プロトタイプの基礎は何であり、何が行われなければなりませんか。</font></font><a name="habracut"></a><br>
<br>
<em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ジュリア・ボルコワ（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u=" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Xnuinside</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）GridDynamicsのシニアPython開発者。彼は自由な時間にペットプロジェクトを書いており、実際の生活に応用されることもあります。そのため、従来のコードを何度もテストして、ジュリアは多くのことが自動的に実行できることに気づきました。もちろん、コードを理解して「正しい」テストを作成することは、経験豊富な開発者にとって難しい場合があります。しかし、自動化は多くの単純なテストを実行し、コードベースを準備することができます。開発者は自分の裁量でそれを変更できます。</font></font></em><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-患者自身から始めましょう。なぜ人々はテストを書かないと思いますか？賢い人はテストを書くと言いますが、まだ書いていません。なぜそのような問題があるのですか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -理由はいくつかあると思います。</font><font style="vertical-align: inherit;">まず、私たちのほとんどは本質的に怠惰です。</font><font style="vertical-align: inherit;">テストを直接書きたい人はほとんどいません。朝起きて、「1日は15回のテストから始める必要があります。そうしないと、すべてが悪くなりますが、私の人生は成功しません。」</font><font style="vertical-align: inherit;">自然な怠惰はより頻繁に現れます。特に、メソッドがあまり興味深くなく、明確で基本的なコードが含まれている場合は、テストでカバーする必要があります。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TDDを書くことはほとんどないため、テストを記述する必要があるだけでなく、コードに時間を費やす必要もあります。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">問題は、開発に無限の時間が割り当てられていないことです。期間限定のウィッシュリスト製品が常にあります。一般に、製品チームでは、時間はお金であるため、原則として昨日すべてが必要でした。管理者には、機能をグリーン化すればするほど、製品の価格が高くなり、より良いものになると思われます。また、カバレッジのテスト、コードの品質が、機能の追加、コードのサポート、更新などのその後の速度に直接影響することは必ずしも明らかではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私たちはしばしばすべてをマネージャーのせいにして、彼らは私たちに十分な時間を与えないと言います。さもなければ、私たちは座ってテストを書くでしょう。実際、これは常に当てはまるとは限りません。また、常に経験豊富な堅牢な開発者がテストを書くとは限らず、若い同僚はそうしたくないと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私は長い間ITに携わってきましたが、3〜4年間は直接開発に携わってきました。それ以前は、管理職でより多くの仕事をしていて、さまざまな開発者を見ていました。彼らは10年間コードを書いているので、経験の浅いとは言えない人がたくさんいますが、同時に、そのようなテストは必要ないと信じています。バグをキャッチする必要のあるQAエンジニアがいるため、ユニットテストでコードをカバーする必要がないとします。また、そのようなエンジニアがすべてのケースをエンドツーエンドのテストでカバーできるわけではないと考えています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「そのような極端に行かない場合、あなたはどう思いますか、誰がテストを書くべきですか？」それはプログラマー自身、ジュニア、または逆に、チームで最もクールな開発者であるべきでしょうか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -単体テストについて話している場合、それは間違いなくQAであってはなりません。これらは間違いなく、コミットの前にチェック、パス、および書き込まれるテストである必要があり、後で他の人が書いてはならない場合は、プルリクエストに転送する必要があります。たとえば、私は怠惰な非ジュニア開発者として、プリミティブコードのテストを書くためにジュニアを置くだけでした。単に中間レベルでコードを読み取ってアサートを作成するだけで十分なものもあります。そのような作業は後輩に非常に適しており、彼らの開発に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらは、単体の状態コードをそのままカバーする単体テストです。これらのテストは、関数がタスク内のタスク要件に関連してどの程度有効であるかをチェックするのではなく、コードがその機能を実行し、正しく実行することを確認します...</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、ビジネス要件、ビジネスロジックのコードの有効性を検証するには、これらの要件を実装する人が必要です。彼は何をどのようにテストでカバーするかを理解しなければなりません。しかし、人が最初に問題を理解しなかった場合、それが誤って解決する方法を書いたが、この誤った方法に対して正しいテストを行った場合、それがどのように役立つかは明らかではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-問題は、ソフトウェア開発プロセスがどのように進んでいるのかについて人々がよく理解していないことです？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -これは非常に主観的です。</font><font style="vertical-align: inherit;">あなたは自分がテストが必要であることを理解し、なぜ必要なのかを理解し、それが真実で良いと考える開発者のユニットとして自分を想像します。</font><font style="vertical-align: inherit;">しかし、これは冗長であると考える開発者のかなり大きな層があります。</font><font style="vertical-align: inherit;">そして、ある意味では、テストはすべてのコードをカバーする必要はなく、ステージでの手動テストで十分であると言うとき、マネージャーはおそらく自分のやり方で正しいでしょう。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">テストが嫌いな人は、未熟な開発者であると言うのは必ずしも正しくありません。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">彼には自分自身のビジョンがあり、私が判断することはできません。私はまだ10年間コードを書いている開発者にしばしば会い、ユニットテストですべてをカバーすることは冗長であり、十分なスモークテストとQA作業で十分だと言います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、機能の単体テストがないプロジェクトには不快に感じます。私にとって重要なのは、ランダムに配置されたコンマまたは変更されたキー名をディクテーションでキャッチできる、ヒューマンファクターからの保護を保証するテストがあることです。しかし、私は常に「よりスマートな」タスクを実行したいので、それに時間を費やすのは好きではありません。したがって、テストを書くプロセスを自動化するためのツールについて考えています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Pythonは動的に型付けされており、コンパイル段階で何もチェックしないと思いますか？これで他の言語の方が簡単になりますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -私は思う、遊ぶ、そして強い。これは型についての永遠の話ですが、型注釈の出現により、操作がより簡単になりました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、Pythonではネストされた関数のチェーンが存在する場合があり、リストの最後にある理由で予期されるものが辞書に変わります。実行が最終的な関数に到達することはありませんが、例外的な場合には到達し、エラーが表示されることがあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、型付けされた言語では、コンパイル段階ですでにエラーが発生するため、これは原則として発生しません。もちろん、この点に関して、Pythonは足で（頭などで）自分を撃つための追加の方法を提供します。特に、分岐ロジックを使用する大規模なプロジェクトで作業する場合は、データをさまざまなバリエーションやさまざまな集計に注ぎ込むことができます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-それでは、類型化とは何でしょうか？タイピングは最大にするべきか、最小にするべきだと思いますか？動的コードを入力する際のバランスはどうあるべきですか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -これもまたかなり主観的です。</font><font style="vertical-align: inherit;">タイピングがなく、柔軟性があり便利なので、多くの人がPythonを使い始めました。</font><font style="vertical-align: inherit;">このことを忘れないでください。また、データサイエンティストやコードを作成するアナリストなど、開発者の膨大な層を排除しないでください。</font><font style="vertical-align: inherit;">私が、バックエンド開発者として、タイピングが一般的にどこにでもあるときはもちろんより快適であると仮定します。</font><font style="vertical-align: inherit;">理想的には、mypyも機能します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、私が参加したほとんどのプロジェクトでは、これは不可能です。</font><font style="vertical-align: inherit;">プロジェクトにはデータアナリストもいます。データアナリストは、型をいじりたくないのでPythonで記述しているので、とても便利です。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの人々は、タイプやタイピングがない場合は、それに加えてPythonを信じています。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それがマイナスになる時期と理由を理解するには、一定のレベルまで成長する必要があります。一部の小さなPythonスクリプトまたは小さなプロジェクトでは、タイプも使用しません。これは、2関数スクリプトではタイプは特に必要ないことを知っているためです。しかし、これは大まかに言えば、ベースから何かを引っ張るために膝の上ですぐにやったことです。そして、より大きなプロジェクトでは、他の開発者からの抵抗がない場合は、どこにでもタイプを最大に追加しようとします。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-私はこれに完全に同意します。これは別のあいまいなトピックであるため、タイプの使用方法を理解するだけです。</font></font></strong><br>
<br>
<blockquote><em>    : «, Haskell      ,      :  ,          .     Python    ,         ,    ».</em></blockquote><br>
<strong> —    . ,      </strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><strong></strong></a><strong>,  legacy-   smoke-.        .    ?</strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -私のアプローチの方が優れているとは言いません。違うだけです。可能な場合は、コードを煙のテストでカバーすることをお勧めします。私の以前のプロジェクトは、テストに関連する典型的な痛みでした。これは、8つのマイクロサービスと2万行のコードのデータサイエンスプラットフォームでした。問題は、プラットフォームが車両、駅、都市、さまざまな駐車場、さまざまな種類の供給品に関する大量のデータと特性を受け取り、世界中のこれらの車両の膨大なスケジュールの集合を作成して作成することです。スケジュールでは、車両に燃料を補給できる場所、中間停止する場所など、さまざまな条件が考慮されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
システムには、1から2の状況で使用できるさまざまな方法があり、おそらくクライアントも覚えていないでしょう。次に、実際に煙のテストを作成すると、すべての機能とその組み合わせを考慮に入れて、システム全体のテストを作成することになります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Smoke-testは、すべてが出力で機能し、最小限の破損がないことを確認する必要があります。システムが開始し、何らかの形で機能する非常に原始的な煙のテストは、私たちの場合には何の利益ももたらしません。データベースへの接続があること、何かが始まっていること、UIがなんらかのAPIを取得していることを確認したとしましょう。そして、左へのステップ、右へのステップ-そして何も機能しません。つまり、実際には煙のテストがありますが、まだプロダクションからエラーが飛んでいます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このシステムでは、単体テストは問題なく機能しました。関数が変更されていないことが明確に監視されていれば、一部のコード変更後に機能が停止していません。コードも異なります。プロジェクトが異なれば、タスクごとに異なるテスト方法が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が現在取り組んでいるアイデアは、条件付きのテストの自動生成としか言えません。それはむしろ開発者ツールです。私のためにテストを作成し、私なしで実行できるすべてのコードを実行するツールを入手したいと考えています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例を挙げましょう。いくつかの値とキーから、辞書を取得する小さな関数があります。このキーはビジネスにとって非常に重要ですが、コードの観点からはかなり基本的な操作です。ネストされたキーである場合でも、辞書から取得してください。彼がそこにいること、彼がゼロでないことを確認してください。それを交換するか、単に値を返すだけです。これは、ASTの観点から見ると、かなり原始的なコードです。私は彼に時間を費やしてテストを書きたくありません。車にやってもらいたい。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、正確に入力コードと出力コードを持つメタプログラムです。 「ここで私は断言します、私は「支援しました」そのような条件でエラーが発生したこと、そのような状況で有効な値が返されたこと、そのような引数で何か他のことが起こったことをあなたに伝えました」 。つまり、実際には、私が関数の入力に何が供給されているかを調べてテストに書き込む作業を行います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラム自体が実行できる最小値をプログラムに生成させたい。ただし、これはテストファイルである必要があります。テストファイルでは、必要に応じて変更または拡張できます。 Git、テストテストなどでコミットできるもの。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-このような自動生成されたテストにどれだけ依存できますか？どういう意味ですか？それらは特定の実装にどの程度結び付けられており、ビジネスロジックまたはリファクタリングの通常の変更の下ではどのように動作しますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -アイデアは、コードを現在の形で受け取り、それに基づいて現時点で有効なテストを生成することです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
もちろん、毎回テストを再生成できますが、これは正しくありません。コード変更の状態を追跡できないためです。したがって、このためのテストdiffがまだあります。つまり、テストは、以前のテストでカバーされていなかったものに対してのみ生成されます。そして、すでに作成されたテストは自分でサポートする必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
おそらくこれは少し偏執狂かもしれませんが、これまでのところ、自動生成では、テストを再生成することによって有効なコードで有効なコードをカバーできないことを保証できるとは思えません。</font><font style="vertical-align: inherit;">2019年2月にテストを生成したときの1つのことです。ロジックを変更した場合は、自分でテストを変更します。これは、変更内容がわかっているためです。</font><font style="vertical-align: inherit;">テストが落ちた理由を知っているので、それに応じてテストを修正できます。</font><font style="vertical-align: inherit;">そして、毎回それらを再生する場合、それは完全に異なる問題です。</font><font style="vertical-align: inherit;">テストは有効ですが、コードの変更された状態に対してのみです。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードカバレッジを増やすためのツールではなく、開発者のためのツールを入手したいのです。</font></font></blockquote><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-成功の指標は何ですか？テストが適切に生成されたことをどのように理解できますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
私が注意を払っているものに名前を付けます。これがないと、テストが意味をなさないように見えます。開発者によって記述されたコード動作のすべてのケースがテストで処理されることが不可欠です。たとえば、ifが何も返さないがログを書き込む場合、テストではこのログが機能するはずです。人々が警告を書いて印刷するだけではありません。したがって、raise-error処理がどこかにある場合、テストでそれを解決する必要があります。突然レイズが消えた場合、つまり、コードのロジックに変更がある場合、これも解決する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、ifステートメントがある場合は、各条件のアサートで処理を行う必要があります。その後、テストは多かれ少なかれ真実に近いものになります。そして、これをすべて開始する必要があることを忘れないでください。PyTestで空のテスト本体で「成功」を発行するだけではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-技術的に難しいことを教えてください。かなり難しい仕事のように聞こえます。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
はい、これは非常に困難な作業であり、おそらく</font><font style="vertical-align: inherit;">モスクワのPython会議++の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">これについて話をしたのは、おそらくこの事実と他のいくつかの状況</font><font style="vertical-align: inherit;">です。私はこのトピックを提起し、他の人々に興味を持ってもらい、解決策について彼らと話し合いたいです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
難しいので、誰もやってみたわけではないような気がします。それ以外の場合は、コード、説明、記事、または少なくともそのようなものがあったことを言及するなど、ネットワーク上にアーティファクトがいくつかありますが、それは破棄されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがどれほど難しいかを理解するために、インタプリタがどのように機能するかを思い出してみましょう。コードには操作、ステートメントがあり、インタープリターがそれらを実行します-良い、良くない、失敗した、失敗しなかった-結果を生成します。さらに、開発者は手動で新しい引数を追加し、インタプリタを再度起動して、すべてが今成功することを確認します。ただし、コードのテストを生成しようとするときは、最初にASTツリーを調べ、結果を得るために必要な手順を理解する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関数は、引数のグループ、引数の戦略、およびこれらの戦略の多くの結果を持つことができます。戦略といえば、あるとしましょう</font></font><code>if arg_1==1: raise error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。これは</font></font><code>arg_1=1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、関数が常にエラーを返す</font><font style="vertical-align: inherit;">グループがいくつかあることを意味し</font><font style="vertical-align: inherit;">ます。しかし、引数がある</font></font><code>arg_1&gt;2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、関数</font><font style="vertical-align: inherit;">の</font><font style="vertical-align: inherit;">結果は異なり、2番目のグループである2番目の戦略が作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、関数がその動作を変更する引数のグループ（もちろん、そうである場合）をすべて見つけて強調表示する必要があります。そして、一連のアクションに従います。これらの引数を使用して関数内で何が起こり、最終的な結果が得られますか。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、いくつかの引数があるという事実のほかに、たとえば、変数の割り当て、他の関数の呼び出しなど、関数の内部にもアクションがあることを忘れないでください。つまり、いくつかのコードをチェックするために最初に別のコードの結果を取得する必要がある場合、メソッドに対するメソッドの依存関係のグラフも取得します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、テストを生成するには、まずASTツリーから必要なすべての情報を取得し、次に各戦略の引数、パラメーター、データを生成する必要があります。それらを使用して、一連のアクション全体を実行し、結果を取得します。そうしないと、さまざまなアサートを使用した有効なテストが行​​われます。これは難しい仕事です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
いつかDjangoソースコードの巨大なキャンバスなど、あらゆる種類のケースを自動的に100％カバーすることが可能になるとは思いません。</font><font style="vertical-align: inherit;">面倒ですが面白いです。</font><font style="vertical-align: inherit;">これまでのところ、私が忍耐と強さを持っているところに興味があります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-他の言語の例や、このようなものが機能する分野はありますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -既知の同様のものはありません。</font><font style="vertical-align: inherit;">特別な道具を切るよりテストを書くほうが簡単だからだと思います。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">でも、遅かれ早かれ、すでにうまくやっていることを自動化する気がします。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">単体テストを上手に書く開発者の大規模なプールがあります。 Python開発には、これを行うためのツールまたはライブラリを作成したいほどの能力があります。そして、より複雑なもの、より複雑なテストを作成します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Java、C、および.Netには、ある種のテスト生成があります。しかし、そこにも、すべてがかなりプロパティベースまたは契約ベースです。 Cでは、文字ごとのテスト生成があり、コードを見るだけのようで、これに基づいていくつかのテストを行います。しかし、これは言語自体の非常に異なる抽象化レベルであり、これが同様の物語であるかどうかはわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
非常によく似たものがあれば、もちろん、それを採用することもできます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-Pythonコードを作成するためのフレームワークまたは手法は、ASTツリーからテストを生成するタスクを単純化または複雑化すると思いますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -この意味で、単にライブラリをインポートするか、直接特定のフレームワークを使用するかが非常に異なるかどうかを言うのは困難です。絶対に、コードプロセスの解釈の動作を変更する何か（C拡張など）の作業を非常に複雑にする可能性があります。これに対処する方法はわかりませんが、この問題でこれまでのところ私のお気に入りの3番目のパッケージを使用するには、インポートを解決する必要があります。組み込みパッケージではすべてがシンプルですが、インポートではすべてがより複雑になります。 Mypyにはいくつかのアイデアと実装がありますが、サードパーティパッケージのインポートの履歴にはまだ触れていません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-多分それはある種のテクニックです-多くのダイナミクス、getattrの使用-そのようなものですか？それともうまくいきますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 「完全に問題なく動作します。」なぜなら、</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">getattr</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">やメタクラスを使った操作はASTで見えるからです。はい、それらは解決する必要があり、これはいくつかの複雑さを追加します。しかし、これはとにかく追跡されます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-自動生成されたテストは主にユーザーを対象としていると既に述べました。人々にとってどれほど読みやすいでしょうか？各テスト内には多くのロジックがあります、断言しますか？コードとデータの分離はどのように見えますか、どのように見ますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -今、私は最初にあらゆる種類の平凡なものをテストに追加しようとします。なんらかのレイズエラーの場合は、レイズだけではなく、少なくともコメントを残し、どのようなエラーが表示され、なぜポップアップするのかを考えて、テストを読んだ後、実際に何が起こったのか、どの引数がどのエラーにつながるのかを理解できるようにします。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、アサートは1つのメソッドにまとめられています。つまり、関数があり、チェックしたい状態が5つある場合、5つのアサートが関数内に入るまでです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、名前の規則を導入するというアイデアがありました。たとえば、エラーをエラーの最後に置く、テストログにも独自のものがあります。しかし、コードで最終的なタイプのテストを直接作成する方法、つまりテストを含むテキストブロックを直接作成する方法の問題が最も低コストの操作であるため、ここではそれを延期しました。すべてを再フォーマットする必要があるという考えが突然現れた場合、これは簡単に実行できます。既製の組み立てられたアサートがあり、テストに対して別の外観を選択するだけです。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-unittestまたはpytestをサポートしていますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -パイテスト。そして、今は出力に多くのエネルギーを費やしたくないからです。使いやすいプラグイン、デコレーター、さまざまな修飾子がたくさんあるので、Pytestは優れています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
かわいさは、エンドユーザーと開発者の両方にとって重要です。しかし、これはアイデアの発展にはまったく影響しません。単体テストをサポートする必要がある場合、これは簡単に追加できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-このアプローチは、プロパティベースのテストにどの程度関連していますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -引数を生成するために、mokiタイプが使用されます。intが必要で、ランダムなintを指定します。しかし、そのような戦略は、たとえば仮説の使用を開始するなど、簡単に書き直すことができます。私はこれに多くの時間と労力を費やしていませんが、サードパーティのジェネレーターを価値のために使用できることを理解しているためです。さて、私には思えますが、これはASTでの作業ほど重要ではありません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-契約プログラミングをサポートする予定ですか、それとも特別な方法で分離する予定ですか？なぜなら、ビジネスロジックを理解するために、ユニットテスト、プロパティベースのテスト、および原則的にはテストでの作業に非常に役立つからです。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -契約プログラミングがコード内の契約を意味する場合、私はこれからできるだけ離れます。コントラクトプログラミングを使用できる場合は、基本的にコントラクトを使用してコントラクトをコーディングし、それに基づいて単体テストを生成できます。そして、私のツールはそれほど必要ありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今、私はコードを変更するものについては考えないようにしています。</font><font style="vertical-align: inherit;">たとえば、私がテスト不足の問題に直面したアウトソーシングのプロジェクトでは-そしてこれらはほとんどすべてのプロジェクトでしたが、残念ながら現在の会社では-コードに触れることはほとんど不可能でした。</font><font style="vertical-align: inherit;">つまり、このデコレータまたはコントラクトがコードの機能コンポーネント全体を変更しないことが保証されるまで、変更を加えることは不可能でした。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コードを編集できる場合は、契約テストが適切です。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">しかし今のところ、そのような可能性はないという事実から始めます。実際、コントラクトに基づいて、ユニットテストを生成し、実際には機能の複製を実装できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-次の重要なポイントについて教えてください：受け取ったテストをテストする方法と、これらのテストが実際に何かをテストすることをどれだけ保証できますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">突然変異テスト</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はキャンセルされていません。そして、世界の理想的な状況では、それは確かにこのストーリーで使用される必要があります。全体としての考え方は、テストが開発者によって手動で記述された場合と同じです。つまり、テストのテストに使用できるすべてのものを完全に適用できます。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-では、モスクワPython Conf ++カンファレンスについて少し説明しましょう。私たちはします</font></font></strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">実行します</font></font></strong></a><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私たちが数回言及した仮説開発者の1人。彼に何を聞いてみたいですか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -Zachに、メンテナと一緒にプロジェクトをどこで開発したいか、何を追加するか、どのように開発するかについて尋ねたいと思います。 Zachがテスト生成用のPRを持っていることは確かです。彼らは定期的にそれを行います。より正確には、デコレータは既存の単体テストに追加されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
自動テスト生成のアイデアについて、仮説がどのように見られるか、貢献者がどのように見られるかという点について説明したいと思います。確かにそのようなレベルでテストに従事している人々は、いくつかのアイデアを持っているか、多分誰かがすでに何かを試したことがあります。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「会議プログラムを準備しているとき、これを頼りにしています。レポートは議論のためのトピックを設定するためのものであり、その間誰もが新しいアイデアと開発の方向性を見つけるでしょう。どのレポートに行きますか？</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -私は動揺して、すべてのレポートに12時に行きたいと思います。現時点では、Zac Hatfield-Dodds、</font><font style="vertical-align: inherit;">非同期プログラミング</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に関するレポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">書いたAndrey Svetlov </font><font style="vertical-align: inherit;">、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">リファクタリングオートメーションを</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">書いたVladimir Protasovが登場し</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">ます</font></a><font style="vertical-align: inherit;">。私は最後の2つのうちの1つに行き、その後レポートの最後にザックに向かいます（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">編集者注：ライフハックをサービスに取り入れます-新しいトピックをほぼ完全に聞いて、レポートの最後に行き、話したいスピーカーに質問します</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。 。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
とても面白い</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">データ検証に関するレポート</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。直接興味があります。そして、私が行くことになる2つのレポートがありますが、それらはすべて私のものと並行して行われます。これは、</font><font style="vertical-align: inherit;">タイピングに関するVitaly Bragilevsky </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">による</font></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">プロファイリングに関する</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">クリスチャンハイム</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">によるレポート</font></a><font style="vertical-align: inherit;">です。残念ながら、私はそれらに到達することはできません。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-レポートのトピックについて、もう少し詳しく教えてください。なぜ、何をしているのか、何をしているのか、なぜ話しているのか、スピーチから何を待っているのですか。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
 -開発プロセスを自動化するためのツールと、これに関連するコラボレーションを増やしたい。そのような活動はありますが、常に同じコードを書くという背景から、もっとあるべきだと思います。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
先ほど述べたように、Pythonでの自動生成テストにはオープンエクスペリエンスはありません。誰かがこれを行っていたかどうかは不明ですが、もしそうなら、なぜ離陸しなかったのですか？ ASTベースのテストの生成がコミュニティにどの程度関連するか、それがどこまで進むことができるかわかりません。プロセス自体に興味があり、ASTツリーを掘り下げ、Pythonコードがどのように機能するかについてさらに学習し、コードのトップレベルで作業するときに明白ではない多くの異なるニュアンスに遭遇することに興味があるので、今、これを行っています。 ASTツリーでの作業は、突然の発見をもたらします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
レポートの後に、たとえば、作業で使用するものを自動化する方法などのアイデアを提供してほしい。そのため、彼らの一部は、すでに毎日作成しているコードの一部を作成することをやめ、それらを作成する時間を生成または削減し始めます。私は誰かがこの問題を解決する方法の新しい理解で出てくることを願っています。</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-会議で話す時間をどこで取っていますか、独自のライブラリを作成していますか？この質問は実際に絶えず浮かび上がり、多くの人々は何のためにも時間がないと不平を言います。</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -まず、時間について。</font><font style="vertical-align: inherit;">私は自分にとって効果がないように見えることをしないという意味で、多くの会社にとってあまり便利な従業員ではありません。</font><font style="vertical-align: inherit;">私は自分にとって本当に興味深いことや、効果的で正しいことができることをしようとしています。</font><font style="vertical-align: inherit;">たとえば、マネージャーがある種のバグを修正することを望んでいる場合、これは実際にはバグではなく、新しい顧客のウィッシュリストですが、座ってすべてを修正することはありません。顧客が戻ってきて、なぜあなたが言うのかわかっているからです。それをやった。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私は仕事で不必要な仕事をしないようにし、後で時間を失うことになるようなことはしないようにします。</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">たとえば、金曜日に配備するように言われたら、次のように言います。月曜日に配備できます。金曜日に配備したい、そのような状況が発生した理由についてお話しします。」これを初めて顧客やマネージャに伝えるのは初めてのことかもしれませんが、後で慣れると、金曜日の夜に非常に急を要することを習得し、依頼しないでください。彼らは、第一に、誰も洪水がなく、誰もお金を失っていない、先週の金曜日に誰も亡くならなかったことを理解しています。私は自分に害を与えるようなことはしないようにしています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
バグに関する同じ話-常に修正する必要のある多くのバグがある場合、問題は次のとおりです。なぜこれらのバグが表示されるのですか。私たちはそれらを修正するべきではありませんが、なぜそれらの多くが存在するのかを考えます。これらは、運用環境で機能を修正する緊急の必要性があるとマネージャーまたは顧客が言ったときに、常に痛みを伴う問題でもあります。しかし、ここでこのコードに触れた場合、おそらくこの機能以外のものがあるため、本番環境にはないことになります。コードはテストの対象外なので、別のコードを追加することはできません。他の6人が何をしているか覚えていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
時には自分を乗り越えて話し始める必要があります。これは常に可能であるとは限らず、どのような種類の作業にどれだけの時間を費やしているのかは、自分の責任であるという一定のレベルの認識に成長する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私にはおそらく時間があります。作業時間を最適化しようとするので、タスクを完了するのに特定の時間数がかかるようにします。同時に、良い構造では、技術的負債といくつかの改善のために1〜2時間あるはずだと理解しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
起きずに8時間働くとは言わない。私は座ってコードを8時間書く開発者を見てみます。私の通常の営業日をとれば、2時間はあらゆる種類のテスト、コードレビュー、技術的負債、コードの「バズ」です。 3時間目は、現在の問題の解決策であり、マネージャーとのコミュニケーションに1時間かかります。そして、残りの2時間は、チームやフリーランスとの議論のために、何らかの理由で分散されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたがやりたいことはあります-あなたがし、あなたが力を持っていないとき、彼らはあなたに力を与えます。</font><font style="vertical-align: inherit;">私はたくさんの異なる活動をしています-これはおそらく便利な先延ばしと呼ばれています-私が今興味があることをするときであり、私がする必要があることではありません。</font><font style="vertical-align: inherit;">興味深いものとまだ必要なものとを変えることを学ぶなら、それが最も成功することがわかります。</font><font style="vertical-align: inherit;">自分がやりたくないことをするために時間を無駄に費やしてはいけません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
秘密はありません。好きなことをするだけで、同時に周りの人やプロジェクトに害を与えることはありません。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pythonコードからのテスト生成の実装の詳細、およびPython開発者のその他の多くのタスクの解決については、</font><font style="vertical-align: inherit;">9月15日に延期された</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モスクワPython Conf ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">に</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">アクセスして</font></a><font style="vertical-align: inherit;">ください。</font></font></blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja490654/index.html">MQシリーズガスセンサーに点を打つ-データシートとチューニングに関する深い理解</a></li>
<li><a href="../ja490656/index.html">Camunda外部タスク-復元力のあるスケーラブルなアーキテクチャでアプリケーションを構築するための強力なツール</a></li>
<li><a href="../ja490660/index.html">CityMobileの成長をどのように確保したか</a></li>
<li><a href="../ja490664/index.html">PHP：array_key_existsは、in_arrayより500倍高速に検索します</a></li>
<li><a href="../ja490668/index.html">製品からプロジェクトへ、またはその逆への変換の歴史（モスクワ地域の善の例を使用）</a></li>
<li><a href="../ja490674/index.html">Habr Wickley＃41 /より多くの自動運転車、教授。Fortran、Yandex zashkvar、ロボットの痛み、競合他社のサイトをブロックする方法</a></li>
<li><a href="../ja490676/index.html">ユニットテスト、科学、数学</a></li>
<li><a href="../ja490678/index.html">MonbMQパート5でのRabbitMQの使用</a></li>
<li><a href="../ja490680/index.html">PodDisruptionBudgetsを使用したKubernetesクラスターでのダウンタイムの回避</a></li>
<li><a href="../ja490682/index.html">アイントホーフェンの企業がマイクロ回路の製造のための近代的な機器の市場で独占企業になった方法</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>