<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐌 🌝 🕐 Programmation d'un jeu pour un appareil embarqué sur ESP32 👨🏼‍🎓 🖖🏽 👨🏽‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 0: motivation
 introduction
 Je cherchais un projet de loisir sur lequel je pourrais travailler en dehors de mes tâches principales afin d'écha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation d'un jeu pour un appareil embarqué sur ESP32</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502528/"><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 0: motivation</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je cherchais un projet de loisir sur lequel je pourrais travailler en dehors de mes tâches principales afin d'échapper à la situation dans le monde. </font><font style="vertical-align: inherit;">Je suis principalement intéressé par la programmation de jeux, mais j'aime aussi les systèmes embarqués. </font><font style="vertical-align: inherit;">Maintenant, je travaille dans une entreprise de jeux, mais avant j'étais principalement engagé dans les microcontrôleurs. </font><font style="vertical-align: inherit;">Bien qu'à la fin j'ai décidé de changer de voie et de me lancer dans l'industrie du jeu, j'aime toujours les expérimenter. </font><font style="vertical-align: inherit;">Alors pourquoi ne pas combiner les deux hobbies?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid go</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
J'avais </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Odroid Go qui traînait</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui serait intéressant de jouer avec. </font><font style="vertical-align: inherit;">Son cœur est ESP32 - un microcontrôleur très populaire avec des fonctionnalités MK standard (SPI, I2C, GPIO, minuteries, etc.), mais aussi avec WiFi et Bluetooth, ce qui le rend attrayant pour la création d'appareils IoT. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go complète l'ESP32 avec un tas de périphériques, le transformant en une machine de jeu portable rappelant Gameboy Color: un écran LCD, un haut-parleur, une croix de contrôle, deux boutons principaux et quatre auxiliaires, une batterie et un lecteur de carte SD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La plupart des gens achètent Odroid Go pour </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exécuter des émulateurs d'</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> anciens systèmes 8 bits. </font><font style="vertical-align: inherit;">Si cette chose est capable d'émuler d'anciens jeux, elle fera également face au lancement d'un jeu natif spécialement conçu pour elle.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/44b/800/42e/44b80042e94aa2f2da9da2d2296461ad.jpg"></div><a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Limites</font></font></h3><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Résolution 320x240 L'</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
écran n'a qu'une taille de 320x240, nous sommes donc très limités dans la quantité d'informations affichées à l'écran en même temps. Nous devons examiner attentivement quel jeu nous allons créer et quelles ressources utiliser. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Couleur 16 bits L'</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
écran prend en charge la </font><strong><font style="vertical-align: inherit;">couleur</font></strong><font style="vertical-align: inherit;"> 16 bits par pixel: 5 bits pour le rouge, 6 bits pour le vert et 5 pour le bleu. Pour des raisons évidentes, un tel circuit est généralement appelé RGB565. Le vert est devenu un peu plus rouge et bleu, car l'œil humain distingue mieux les dégradés de vert que de bleu ou de rouge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La couleur 16 bits signifie que nous n'avons accès qu'à 65 000 couleurs. Comparez cela avec la couleur standard 24 bits (8 bits par couleur), fournissant 16 </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">millions de</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> couleurs. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Manque de GPU</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sans GPU, nous ne pouvons pas utiliser une API comme OpenGL. Aujourd'hui, les mêmes GPU sont généralement utilisés pour le rendu des jeux 2D que pour les jeux 3D. Juste au lieu d'objets, des quadrangles sont dessinés, sur lesquels des textures de bits sont superposées. Sans GPU, nous devons pixelliser chaque pixel avec un processeur, ce qui est plus lent mais plus simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec une résolution d'écran de 320x240 et des couleurs 16 bits, la taille totale du tampon de trame est de 153 600 octets. Cela signifie qu'au moins trente fois par seconde, nous devrons transmettre 153 600 octets à l'écran. Cela peut finalement causer des problèmes, nous devons donc être plus intelligents lors du rendu de l'écran. Par exemple, vous pouvez convertir une couleur indexée en une palette de sorte que pour chaque pixel, vous devez stocker un octet, qui sera utilisé comme index d'une palette de 256 couleurs.</font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4 Mo</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
ESP32 a 520 Ko de RAM interne, tandis que Odroid Go ajoute 4 Mo de RAM externe supplémentaires. Mais toute cette mémoire n'est pas disponible pour nous, car une partie est utilisée par le SDK ESP32 (plus à ce sujet plus tard). Après avoir désactivé toutes les fonctions étrangères possibles et entré dans ma fonction principale, ESP32 signale que nous pouvons utiliser 4 494 848 octets. Si, à l'avenir, nous avons besoin de plus de mémoire, nous pourrons ensuite revenir à la suppression des fonctions inutiles. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processeur 80-240 MHz</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le CPU est configuré à trois vitesses possibles: 80 MHz, 160 MHz et 240 MHz. Même un maximum de 240 MHz est loin de la puissance de plus de trois gigahertz d'ordinateurs modernes avec lesquels nous avons l'habitude de travailler. Nous allons commencer à 80 MHz et voir jusqu'où nous pouvons aller. Si nous voulons que le jeu fonctionne sur batterie, la consommation électrique doit être faible. Pour ce faire, il serait bon de baisser la fréquence. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mauvais débogage</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe des moyens d'utiliser des débogueurs avec des appareils intégrés (JTAG), mais, malheureusement, Odroid Go ne nous fournit pas les contacts nécessaires, nous ne pouvons donc pas parcourir le code dans le débogueur, comme c'est généralement le cas. </font><font style="vertical-align: inherit;">Cela signifie que le débogage peut être un processus difficile, et nous devrons utiliser activement le débogage à l'écran (en utilisant des couleurs et du texte), ainsi que des informations de sortie sur la console de débogage (qui, heureusement, est facilement accessible via USB UART).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pourquoi tous ces ennuis?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pourquoi même essayer de créer un jeu pour cet appareil faible avec toutes les limitations énumérées ci-dessus, et ne rien écrire pour un ordinateur de bureau? Il y a deux raisons à cela: Les </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">limitations stimulent la créativité.</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Lorsque vous travaillez avec un système qui a un certain ensemble d'équipements, chacun ayant ses propres limitations, cela vous fait réfléchir sur la meilleure façon d'utiliser les avantages de ces limitations. Nous nous rapprochons donc des développeurs de jeux d'anciens systèmes, par exemple Super Nintendo (mais c'est toujours beaucoup plus facile pour nous que pour eux). </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le développement de bas niveau est amusant</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour écrire un jeu à partir de zéro pour un système de bureau classique, nous devons travailler avec des concepts de moteur de bas niveau standard: rendu, physique, reconnaissance des collisions. </font><font style="vertical-align: inherit;">Mais lors de la mise en œuvre de tout cela sur un périphérique intégré, nous devons également faire face à des concepts informatiques de bas niveau, par exemple, l'écriture d'un pilote LCD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">À quel point le développement sera-t-il faible?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En ce qui concerne le bas niveau et la création de votre propre code, vous devez tracer une frontière quelque part. Si nous essayons d'écrire un jeu sans bibliothèques pour le bureau, la frontière est probablement un système d'exploitation ou une API multiplateforme comme SDL. Dans mon projet, je vais tracer une ligne sur l'écriture de choses comme les pilotes SPI et les chargeurs de démarrage. Avec eux beaucoup plus de tourments que de plaisir. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons donc utiliser l'ESP-IDF, qui est essentiellement un SDK pour ESP32. Nous pouvons supposer qu'il nous fournit certains utilitaires que le système d'exploitation fournit habituellement, mais le </font><font style="vertical-align: inherit;">système d'exploitation </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fonctionne </font><strong><font style="vertical-align: inherit;">pas</font></strong><font style="vertical-align: inherit;"> dans ESP32 </font><font style="vertical-align: inherit;">. À strictement parler, ce MK utilise FreeRTOS, qui est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un système d'exploitation en temps réel</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mais ce n'est pas un vrai OS. </font><font style="vertical-align: inherit;">Ce n'est qu'un planificateur. </font><font style="vertical-align: inherit;">Très probablement, nous n'interagirons pas avec lui, mais dans son noyau ESP-IDF l'utilise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF nous fournit une API pour les périphériques ESP32 tels que SPI, I2C et UART, ainsi qu'une bibliothèque d'exécution C, donc lorsque nous appelons quelque chose comme printf, il transfère en fait des octets via UART pour être affiché sur le moniteur de l'interface série. </font><font style="vertical-align: inherit;">Il traite également tout le code de démarrage nécessaire pour préparer la machine avant d'invoquer le point de lancement de notre jeu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans ce billet je garderai un magazine de développement dans lequel je parlerai des points intéressants qui m'ont paru et expliquerai les aspects les plus difficiles. </font><font style="vertical-align: inherit;">Je n'ai pas de plan et je ferai très probablement de nombreuses erreurs. </font><font style="vertical-align: inherit;">Je crée tout cela par intérêt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 1: système de construction</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer à écrire du code pour Odroid Go, nous devons configurer le SDK ESP32. </font><font style="vertical-align: inherit;">Il contient le code qui démarre ESP32 et appelle notre fonction principale, ainsi que le code périphérique (par exemple, SPI) dont nous aurons besoin lors de l'écriture du pilote LCD. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Espressif appelle son SDK </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP-IDF</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ; </font><font style="vertical-align: inherit;">nous utilisons la dernière version stable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">v4.0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons soit cloner le référentiel selon leurs instructions (avec l'indicateur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">récursif</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), soit simplement télécharger le zip depuis la page des versions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notre premier objectif est une application minimale de style Hello World installée sur Odroid Go qui prouve la configuration correcte de l'environnement de génération.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ou C ++</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ESP-IDF utilise C99, nous allons donc le choisir aussi. </font><font style="vertical-align: inherit;">Si vous le souhaitez, nous pourrions utiliser C ++ (il y a un compilateur C ++ dans la chaîne d'outils ESP32), mais pour l'instant, nous nous en tiendrons à C. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En fait, j'aime C et sa simplicité. </font><font style="vertical-align: inherit;">Peu importe combien j'écris du code en C ++, je n'ai jamais réussi à en profiter. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cette personne résume assez bien mes pensées. </font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, si nécessaire, nous pouvons à tout moment passer au C ++.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Projet minimal</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF utilise CMake pour gérer le système de génération. Il prend également en charge Makefile, mais ils sont obsolètes dans la version 4.0, nous allons donc simplement utiliser CMake. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au minimum, nous avons besoin d'un fichier </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec une description de notre projet, un dossier </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principal</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec le fichier source du point d'entrée dans le jeu et un autre fichier </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à l' </font><font style="vertical-align: inherit;">intérieur de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui répertorie les fichiers source. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CMake doit référencer les variables d'environnement qui lui indiquent où chercher IDF et la chaîne d'outils. J'étais ennuyé de devoir les réinstaller à chaque fois que je commençais une nouvelle session de terminal, j'ai donc écrit le script </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Il définit </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et est également une source d'exportation IDF qui définit d'autres variables d'environnement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il suffit à l'utilisateur du script de définir les </font><strong><font style="vertical-align: inherit;">variables </font></strong></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IDF_TOOLS_PATH</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="powershell hljs">IDF_PATH=<font></font>
IDF_TOOLS_PATH=<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<span class="hljs-keyword">if</span> [ -<span class="hljs-type">z</span> <span class="hljs-string">"<span class="hljs-variable">$IDF_TOOLS_PATH</span>"</span> ]<font></font>
then<font></font>
	<span class="hljs-built_in">echo</span> <span class="hljs-string">"IDF_TOOLS_PATH not set"</span>
	<span class="hljs-keyword">return</span><font></font>
fi<font></font>
<font></font>
<font></font>
export IDF_PATH<font></font>
export IDF_TOOLS_PATH<font></font>
<font></font>
source <span class="hljs-variable">$IDF_PATH</span>/export.sh</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> à la racine:</font></font><br>
<br>
<pre><code class="cmake hljs"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.5</span>)<font></font>
<font></font>
<span class="hljs-keyword">set</span>(COMPONENTS <span class="hljs-string">"esptool_py main"</span>)<font></font>
<font></font>
<span class="hljs-keyword">include</span>($ENV{IDF_PATH}/tools/cmake/<span class="hljs-keyword">project</span>.cmake)<font></font>
<font></font>
<span class="hljs-keyword">project</span>(game)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par défaut, le système de construction construira tous les composants possibles dans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ ESP_IDF / components</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ce qui entraînera plus de temps de compilation. </font><font style="vertical-align: inherit;">Nous voulons compiler un ensemble minimal de composants pour appeler notre fonction principale et connecter des composants supplémentaires plus tard si nécessaire. </font><font style="vertical-align: inherit;">C'est à cela que sert la variable </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COMPOSANTS</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CMakeLists.txt à l'</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> intérieur de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> :</font></font><br>
<br>
<pre><code class="cmake hljs">idf_component_register(<font></font>
	SRCS <span class="hljs-string">"main.c"</span>
    INCLUDE_DIRS <span class="hljs-string">""</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout ce qu'il fait - infiniment une fois par seconde affiche sur le moniteur l'interface série "Hello World". </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VTaskDelay</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilise FreeRTOS </font><font style="vertical-align: inherit;">pour retarder </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le fichier </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.c</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">très simple:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/FreeRTOS.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;freertos/task.h&gt;</span></span><font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);<font></font>
		vTaskDelay(<span class="hljs-number">1000</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Notez que notre fonction s'appelle </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas </font></font></em> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">principale</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><font style="vertical-align: inherit;">utilisée par l'IDF pour la préparation nécessaire, puis elle crée une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tâche</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec notre fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">app_main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme point d'entrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une tâche n'est qu'un bloc exécutable que FreeRTOS peut gérer. Bien que nous ne devrions pas nous en préoccuper (ou peut-être pas du tout), il est important de noter ici que notre jeu s'exécute dans un cœur (ESP32 a deux cœurs), et à chaque itération de la boucle for, la tâche retarde l'exécution d'une seconde. Pendant ce délai, le planificateur FreeRTOS peut exécuter un autre code en attente d'exécution (le cas échéant).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons utiliser les deux cœurs, mais pour l'instant, limitons-nous à un seul.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Composants</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Même si nous réduisons la liste des composants au minimum nécessaire pour l'application Hello World (qui sont </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esptool_py</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), en raison de la configuration de la chaîne de dépendances, elle collecte toujours d'autres composants dont nous n'avons pas besoin. </font><font style="vertical-align: inherit;">Il rassemble tous ces composants:</font></font><br>
<br>
<pre><code class="cmake hljs">app_trace app_update bootloader bootloader_support cxx driver efuse esp32 esp_common esp_eth esp_event esp_ringbuf<font></font>
esp_rom esp_wifi espcoredump esptool_py freertos heap log lwip main mbedtls newlib nvs_flash partition_table pthread<font></font>
soc spi_flash tcpip_adapter vfs wpa_supplicant xtensa</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Beaucoup d'entre eux sont assez logiques ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bootloader</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">freertos</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), mais ils sont suivis de composants inutiles car nous n'utilisons pas de fonctions réseau: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_eth, esp_wifi, lwip, mbedtls, tcpip_adapter, wpa_supplicant</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Malheureusement, nous sommes toujours obligés d'assembler ces composants. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Heureusement, l'éditeur de liens est assez intelligent et ne place pas les composants inutilisés dans un fichier binaire prêt à l'emploi du jeu. </font><font style="vertical-align: inherit;">Nous pouvons le vérifier avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make size-components</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<code><pre>Total sizes:
 DRAM .data size:    8476 bytes
 DRAM .bss  size:    4144 bytes
Used static DRAM:   12620 bytes ( 168116 available, 7.0% used)
Used static IRAM:   56345 bytes (  74727 available, 43.0% used)
      Flash code:   95710 bytes
    Flash rodata:   40732 bytes
Total image size:~ 201263 bytes (.bin may be padded larger)
Per-archive contributions to ELF file:
            Archive File DRAM .data &amp; .bss   IRAM Flash code &amp; rodata   Total
                  libc.a        364      8   5975      63037     3833   73217
              libesp32.a       2110    151  15236      15415    21485   54397
           libfreertos.a       4148    776  14269          0     1972   21165
                libsoc.a        184      4   7909        875     4144   13116
          libspi_flash.a        714    294   5069       1320     1386    8783
                libvfs.a        308     48      0       5860      973    7189
         libesp_common.a         16   2240    521       1199     3060    7036
             libdriver.a         87     32      0       4335     2200    6654
               libheap.a        317      8   3150       1218      748    5441
             libnewlib.a        152    272    869        908       99    2300
        libesp_ringbuf.a          0      0    906          0      163    1069
                liblog.a          8    268    488         98        0     862
         libapp_update.a          0      4    127        159      486     776
 libbootloader_support.a          0      0      0        634        0     634
                libhal.a          0      0    519          0       32     551
            libpthread.a          8     12      0        288        0     308
             libxtensa.a          0      0    220          0        0     220
                libgcc.a          0      0      0          0      160     160
               libmain.a          0      0      0         22       13      35
                libcxx.a          0      0      0         11        0      11
                   (exe)          0      0      0          0        0       0
              libefuse.a          0      0      0          0        0       0
         libmbedcrypto.a          0      0      0          0        0       0
     libwpa_supplicant.a          0      0      0          0        0       0</pre></code><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surtout, libc affecte la taille du binaire, et c'est très bien.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration du projet</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IDF vous permet de spécifier les paramètres de configuration au moment de la compilation qu'il utilise lors de l'assemblage pour activer ou désactiver diverses fonctions. </font><font style="vertical-align: inherit;">Nous devons définir des paramètres qui nous permettront de tirer parti des aspects supplémentaires d'Odroid Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, vous devez exécuter le script source d' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">export.sh</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour que CMake ait accès aux variables d'environnement nécessaires. </font><font style="vertical-align: inherit;">De plus, comme pour tous les projets CMake, nous devons créer un dossier d'assemblage et appeler CMake à partir de celui-ci.</font></font><br>
<br>
<pre><code class="cmake hljs">source <span class="hljs-keyword">export</span>.sh<font></font>
mkdir build<font></font>
cd build<font></font>
cmake ..</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous exécutez </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make menuconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , une fenêtre s'ouvre dans laquelle vous pouvez configurer les paramètres du projet.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extension de la mémoire flash jusqu'à 16 Mo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go étend la capacité standard du lecteur flash à 16 Mo. </font><font style="vertical-align: inherit;">Vous pouvez activer cette fonctionnalité en allant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">config flasher série -&gt; Taille flash -&gt; 16Mo</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Activer la RAM SPI externe</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons également accès à 4 Mo supplémentaires de RAM externe connectés via SPI. </font><font style="vertical-align: inherit;">Vous pouvez l'activer en allant dans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration des composants -&gt; Spécifique à ESP32 -&gt; Prise en charge de la RAM externe connectée SPI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et en appuyant sur la barre d'espace pour l'activer. </font><font style="vertical-align: inherit;">Nous voulons également pouvoir allouer explicitement de la mémoire à partir de la RAM SPI; </font><font style="vertical-align: inherit;">ceci peut être activé en allant dans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI RAM config -&gt; SPI RAM access method -&gt; Make RAM allocatable using heap_caps_malloc</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baisser la fréquence</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ESP32 fonctionne par défaut avec une fréquence de 160 MHz, mais abaissons-le à 80 MHz pour voir jusqu'où vous pouvez aller avec la fréquence d'horloge la plus basse. Nous voulons que le jeu fonctionne sur batterie, et abaisser la fréquence permettra d'économiser de l'énergie. Vous pouvez le changer en allant dans </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration des composants -&gt; Spécifique à ESP32 -&gt; Fréquence du processeur -&gt; 80 MHz</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous sélectionnez </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Enregistrer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , le fichier </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera enregistré à la racine du dossier du projet </font><font style="vertical-align: inherit;">. Nous pouvons écrire ce fichier dans git, mais il a beaucoup de paramètres qui ne sont pas importants pour nous. Jusqu'à présent, nous sommes satisfaits des paramètres standard, à l'exception de ceux que nous venons de changer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez créer le fichier </font><strong><font style="vertical-align: inherit;">sdkconfig.defaults à</font></strong><font style="vertical-align: inherit;"> la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">place</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qui contiendra les valeurs modifiées ci-dessus. </font><font style="vertical-align: inherit;">Tout le reste sera configuré par défaut. </font><font style="vertical-align: inherit;">Pendant la construction, l'IDF lira </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , remplacera les valeurs que nous avons définies et utilisera la norme pour tous les autres paramètres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sdkconfig.defaults</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ressemble à ceci:</font></font><br>
<br>
<pre><code class="cpp hljs"># Set flash size to <span class="hljs-number">16</span>MB<font></font>
CONFIG_ESPTOOLPY_FLASHSIZE_16MB=y<font></font>
<font></font>
# Set CPU frequency to <span class="hljs-number">80</span>MHz<font></font>
CONFIG_ESP32_DEFAULT_CPU_FREQ_80=y<font></font>
<font></font>
# Enable SPI RAM <span class="hljs-keyword">and</span> allocate with heap_caps_malloc()<font></font>
CONFIG_ESP32_SPIRAM_SUPPORT=y<font></font>
CONFIG_SPIRAM_USE_CAPS_ALLOC=y</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, la structure originale du jeu ressemble à ceci:</font></font><br>
<br>
<code><pre>game
├── CMakeLists.txt
├── export.sh
├── main
│   ├── CMakeLists.txt
│   └── main.c
└── sdkconfig.defaults</pre></code><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Construire et flasher</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le processus d'assemblage et de firmware lui-même est assez simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous lançons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">make</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to compile (pour la construction parallèle, ajoutons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ou </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-j8</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faisons flash</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour écrire l'image sur Odroid Go, et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">faisons moniteur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour voir la sortie des instructions </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cmake hljs">make<font></font>
make flash<font></font>
make monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons également les exécuter sur une seule ligne.</font></font><br>
<br>
<pre><code class="cmake hljs">make flash monitor</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le résultat n'est pas particulièrement impressionnant, mais il deviendra la base du reste du projet.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c2/329/62f/3c232962f8e782c9220b25b7e3c0df5e.png"></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: Build System</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation de FreeRTOS: vTaskDelay</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 2: entrée</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons être en mesure de lire les boutons enfoncés par le joueur et la croix sur Odroid Go.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boutons</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/106/142/ca2/106142ca2250eb9301215015b6f0bbad.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPIO</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Odroid Go a six boutons: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Select</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Start</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menu</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Volume</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacun des boutons est connecté à une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">broche GPO (General Purpose IO)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> distincte </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Les broches GPIO peuvent être utilisées comme entrées (pour la lecture) ou comme sorties (nous leur écrivons). </font><font style="vertical-align: inherit;">Dans le cas des boutons, nous avons besoin d'une lecture. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez d'abord configurer les contacts comme entrées, après quoi nous pouvons lire leur état. </font><font style="vertical-align: inherit;">Les contacts à l'intérieur ont l'une des deux tensions (3,3 V ou 0 V), mais lors de leur lecture à l'aide de la fonction IDF, ils sont convertis en valeurs entières.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Initialisation</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les éléments marqués </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dans le diagramme </font><font style="vertical-align: inherit;">sont les boutons physiques eux-mêmes. Lorsqu'ils ne sont pas enfoncés, les contacts ESP32 ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , etc.) sont connectés à 3,3 V; soit 3,3 V signifie que le bouton n'est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pas enfoncé</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . La logique ici est à l'opposé de ce qui est attendu. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ont des résistances physiques sur la carte. Si le bouton n'est pas enfoncé, la résistance </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tire les</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> contacts à une haute tension. Si le bouton est enfoncé, le courant traversant les contacts passe à la terre à la place, de sorte que la tension 0 sera lue à partir des contacts. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">n'ont pas de résistances, car le contact sur l'ESP32 a des résistances internes, que nous avons configurées pour le mode pull-up. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sachant cela, nous pouvons configurer six boutons à l'aide de l'API GPIO.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_A = GPIO_NUM_32;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_B = GPIO_NUM_33;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_START = GPIO_NUM_39;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_SELECT = GPIO_NUM_27;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_VOLUME = GPIO_NUM_0;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> BUTTON_PIN_MENU = GPIO_NUM_13;<font></font>
<font></font>
<span class="hljs-keyword">gpio_config_t</span> gpioConfig = {};<font></font>
<font></font>
gpioConfig.mode = GPIO_MODE_INPUT;<font></font>
gpioConfig.pull_up_en = GPIO_PULLUP_ENABLE;<font></font>
gpioConfig.pin_bit_mask =<font></font>
	  (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_A)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_B)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_START)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_SELECT)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_VOLUME)<font></font>
	| (<span class="hljs-number">1U</span>LL &lt;&lt; BUTTON_PIN_MENU);<font></font>
<font></font>
ESP_ERROR_CHECK(gpio_config(&amp;gpioConfig));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les constantes spécifiées au début du code correspondent à chacun des contacts du circuit. Nous utilisons la structure </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour configurer chacun des six boutons comme entrée pull-up. Dans le cas de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO13</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO27</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO32</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO33,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous devons demander à IDF d'activer les résistances de rappel de ces contacts. Pour </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO39,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous n'avons pas besoin de le faire car ils ont des résistances physiques, mais nous le ferons quand même pour rendre la configuration magnifique. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_ERROR_CHECK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est une macro d'aide de l'IDF qui vérifie automatiquement le résultat de toutes les fonctions qui renvoient </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esp_err_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la plupart des IDF) et affirment que le résultat n'est pas égal à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ESP_OK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Cette macro est pratique à utiliser pour une fonction si son erreur est critique et après cela n'a aucun sens pour continuer l'exécution. </font><font style="vertical-align: inherit;">Dans ce jeu, un jeu sans entrée n'est pas un jeu, donc cette affirmation est vraie. </font><font style="vertical-align: inherit;">Nous utiliserons souvent cette macro.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boutons de lecture</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons donc configuré tous les contacts et pouvons enfin lire les valeurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les boutons numériques sont lus par la fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpio_get_level</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais nous devons inverser les valeurs reçues, car les contacts sont relevés, c'est-à-dire qu'un signal haut signifie en fait «non enfoncé», et un faible signifie «enfoncé». </font><font style="vertical-align: inherit;">L'inversion conserve la logique habituelle: 1 signifie «pressé», 0 - «non pressé».</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">int</span> a = !gpio_get_level(BUTTON_PIN_A);
<span class="hljs-keyword">int</span> b = !gpio_get_level(BUTTON_PIN_B);
<span class="hljs-keyword">int</span> select = !gpio_get_level(BUTTON_PIN_SELECT);
<span class="hljs-keyword">int</span> start = !gpio_get_level(BUTTON_PIN_START);
<span class="hljs-keyword">int</span> menu = !gpio_get_level(BUTTON_PIN_MENU);
<span class="hljs-keyword">int</span> volume = !gpio_get_level(BUTTON_PIN_VOLUME);</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Traverse (D-pad)</font></font></h3><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e8/d9e/a73/1e8d9ea7303257afd45846771726a275.png"></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Connecter la croix est différent de connecter les boutons. </font><font style="vertical-align: inherit;">Les boutons haut et bas sont connectés à une broche d'un </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertisseur analogique-numérique (ADC)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et les boutons gauche et droit sont </font><font style="vertical-align: inherit;">connectés </font><font style="vertical-align: inherit;">à une autre broche ADC. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contrairement aux contacts numériques GPIO, à partir desquels nous pouvons lire l'un des deux états (haut ou bas), l'ADC convertit une tension analogique continue (par exemple, de 0 V à 3,3 V) en une valeur numérique discrète (par exemple, de 0 à 4095 ) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je suppose que les concepteurs d'Odroid Go l'ont fait pour économiser sur les broches GPIO (vous n'avez besoin que de deux broches analogiques au lieu de quatre broches numériques). </font><font style="vertical-align: inherit;">Quoi qu'il en soit, cela complique légèrement la configuration et la lecture de ces contacts.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Configuration</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le contact </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> connecté à l'axe Y de l' </font><strong><font style="vertical-align: inherit;">araignée</font></strong><font style="vertical-align: inherit;"> et le contact </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est </font><strong><font style="vertical-align: inherit;">connecté</font></strong><font style="vertical-align: inherit;"> à l'axe X de l' </font><strong><font style="vertical-align: inherit;">araignée</font></strong><font style="vertical-align: inherit;"> . On voit que les articulations de la croix sont un peu plus compliquées que les touches numériques. Chaque axe possède deux commutateurs ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour l'axe Y, </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour l'axe X), chacun étant connecté à un ensemble de résistances ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si ni «haut» ni «bas» n'est enfoncé, la </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">broche IO35 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tirée vers le bas via </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et nous considérons la valeur 0 V. Si ni «gauche» ni «droite» n'est enfoncé, contactez </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tire vers le sol par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R5</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , et nous comptons la valeur à 0 V. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW1 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressé </font><strong><font style="vertical-align: inherit;">("haut")</font></strong><font style="vertical-align: inherit;"> , puis avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous comptons 3,3 V. Si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW2 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressé </font><strong><font style="vertical-align: inherit;">("bas")</font></strong><font style="vertical-align: inherit;"> , puis avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO35</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous comptons environ 1, 65 V, car la moitié de la tension chutera sur la résistance </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R2</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW3 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressé </font><strong><font style="vertical-align: inherit;">("à gauche")</font></strong><font style="vertical-align: inherit;"> , alors avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous comptons 3,3 V. Si </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SW4 est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pressé </font><strong><font style="vertical-align: inherit;">("à droite")</font></strong><font style="vertical-align: inherit;"> , alors avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO34</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nous comptons également environ 1,65 V, car la moitié de la tension chutera sur la résistance </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les deux cas sont des exemples de </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">diviseurs</font></a><font style="vertical-align: inherit;"> de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tension.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lorsque deux résistances dans le diviseur de tension ont la même résistance (dans notre cas - 100K), la chute de tension sera alors la moitié de la tension d'entrée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sachant cela, nous pouvons configurer la traverse:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_X_AXIS = ADC1_GPIO34_CHANNEL;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">adc1_channel_t</span> DPAD_PIN_Y_AXIS = ADC1_GPIO35_CHANNEL;<font></font>
<font></font>
ESP_ERROR_CHECK(adc1_config_width(ADC_WIDTH_BIT_12));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_X_AXIS,ADC_ATTEN_DB_11));<font></font>
ESP_ERROR_CHECK(adc1_config_channel_atten(DPAD_PIN_Y_AXIS,ADC_ATTEN_DB_11));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons défini l'ADC sur 12 bits de large afin que 0 V soit lu comme 0 et 3,3 V comme 4095 (2 ^ 12). </font><font style="vertical-align: inherit;">L'atténuation signale que nous n'avons pas besoin d'atténuer le signal pour obtenir la plage de tension complète de 0 V à 3,3 V. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À 12 bits, nous pouvons nous attendre à ce que si rien n'est pressé, alors 0 sera lu, lorsqu'il est pressé vers le haut et à gauche - 4096, environ 2048 seront lus en appuyant vers le bas et vers la droite (car les résistances réduisent la tension de moitié).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lecture croisée</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La lecture de la croix est plus difficile que les boutons, car il faut lire les valeurs brutes (de 0 à 4095) et les interpréter.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_POSITIVE_LEVEL = <span class="hljs-number">3072</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint32_t</span> ADC_NEGATIVE_LEVEL = <span class="hljs-number">1024</span>;<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadX = adc1_get_raw(DPAD_PIN_X_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadX &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Left pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadX &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Right pressed</span><font></font>
}<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">uint32_t</span> dpadY = adc1_get_raw(DPAD_PIN_Y_AXIS);<font></font>
<font></font>
<span class="hljs-keyword">if</span> (dpadY &gt; ADC_POSITIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Up pressed</span><font></font>
}<font></font>
<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dpadY &gt; ADC_NEGATIVE_LEVEL)<font></font>
{<font></font>
	<span class="hljs-comment">// Down pressed</span>
}</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_POSITIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ADC_NEGATIVE_LEVEL</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont des valeurs avec une marge, garantissant que nous lisons toujours les valeurs correctes.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sondage</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe deux options pour obtenir les valeurs des boutons: interrogation ou interruptions. Nous pouvons créer des fonctions de traitement d'entrée et demander à IDF d'appeler ces fonctions lorsque les boutons sont enfoncés, ou d'interroger manuellement l'état des boutons lorsque nous en avons besoin. Les comportements provoqués par les interruptions rendent les choses plus compliquées et difficiles à comprendre. De plus, je m'efforce toujours de rendre tout aussi simple que possible. Si nécessaire, nous pouvons ajouter des interruptions ultérieurement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons créer une structure qui stockera l'état de six boutons et quatre directions de la croix. Nous pouvons créer une structure avec 10 booléens, ou 10 int, ou 10 int non signé. Cependant, à la place, nous allons créer la structure en utilisant </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">des champs de bits</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
	<span class="hljs-keyword">uint16_t</span> a : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> b : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> volume : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> menu : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> select : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> start : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> left : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> right : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> up : <span class="hljs-number">1</span>;
	<span class="hljs-keyword">uint16_t</span> down : <span class="hljs-number">1</span>;<font></font>
} Odroid_Input;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de la programmation de systèmes de bureau, les champs de bits sont généralement évités car ils sont mal portés sur différentes machines, mais nous programmons pour une machine spécifique et nous n'avons pas à nous en préoccuper. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de champs, une structure de 10 valeurs booléennes d'une taille totale de 10 octets peut être utilisée. </font><font style="vertical-align: inherit;">Une autre option est une </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint16_t avec des macros de</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> décalage et de masquage de bits qui peuvent définir, </font><strong><font style="vertical-align: inherit;">effacer</font></strong><font style="vertical-align: inherit;"> et vérifier des bits individuels. </font><font style="vertical-align: inherit;">Cela fonctionnera, mais ce ne sera pas très beau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un simple champ de bits nous permet de tirer parti des deux approches: deux octets de données et des champs nommés.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons maintenant interroger l'état des entrées à l'intérieur de la boucle principale et afficher le résultat.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-built_in">printf</span>(
			<span class="hljs-string">"\ra: %d  b: %d  start: %d  select: %d  vol: %d  menu: %d  up: %d  down: %d  left: %d  right: %d"</span>,<font></font>
			input.a, input.b, input.start, input.select, input.volume, input.menu,<font></font>
			input.up, input.down, input.left, input.right);<font></font>
<font></font>
		fflush(<span class="hljs-built_in">stdout</span>);<font></font>
<font></font>
		vTaskDelay(<span class="hljs-number">250</span> / portTICK_PERIOD_MS);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">printf</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> utilise </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ r</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour remplacer la ligne précédente au lieu d'en ajouter une nouvelle. </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fflush est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nécessaire pour afficher une ligne, car à l'état normal, elle est réinitialisée par le caractère de nouvelle ligne </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\ n</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vidéo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_2/media/input.mp4" type="video/mp4"></video></div></div></div><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: ADC</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: GPIO</font></font></a></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Partie 3: affichage</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">introduction</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons être capables de rendre les pixels sur l'écran LCD Odroid Go. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'affichage des couleurs à l'écran sera plus difficile que la lecture de l'état d'entrée car l'écran LCD a du cerveau. </font><font style="vertical-align: inherit;">L'écran est contrôlé par </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ILI9341</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - un pilote LCD TFT très populaire sur une seule puce. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En d'autres termes, nous parlons à ILI9341, qui répond à nos commandes en contrôlant les pixels sur l'écran LCD. </font><font style="vertical-align: inherit;">Quand je dis «écran» ou «affichage» dans cette partie, je veux dire en fait ILI9341. </font><font style="vertical-align: inherit;">Nous avons affaire à ILI9341. </font><font style="vertical-align: inherit;">Il contrôle l'écran LCD.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'écran LCD est connecté à l'ESP32 via </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI (Serial Peripheral Interface)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SPI est un protocole standard utilisé pour échanger des données entre des périphériques sur une carte de circuit imprimé. Il a quatre signaux: </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI (Master Out Slave In)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO (Master In Slave Out)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK (Clock)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS (Chip Select)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un seul appareil maître sur le bus coordonne le transfert de données en contrôlant SCK et CS. Il peut y avoir plusieurs appareils sur un bus, chacun ayant ses propres signaux CS. Lorsque le signal CS de cet appareil est activé, il peut transmettre et recevoir des données.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ESP32 sera le maître SPI (maître) et l'écran LCD sera l'esclave SPI esclave. </font><font style="vertical-align: inherit;">Nous devons configurer le bus SPI avec les paramètres requis et ajouter un écran LCD au bus en configurant les contacts correspondants.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7bc/60e/18c/7bc60e18c1b066ba7c22756464f92512.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f12/463/615/f124636158029efeab3259f299a2af36.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les noms </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VSPI.XXXX ne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sont que des étiquettes pour les contacts dans le diagramme, mais nous pouvons parcourir les contacts eux-mêmes en regardant les parties des diagrammes LCD et ESP32.</font></font><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MOSI</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MOSI -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO23</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MISO</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.MISO -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO19</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SCK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.SCK -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO18</font></font></strong></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CS0</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -&gt; VSPI.CS0 -&gt; </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO5</font></font></strong></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons également </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO14</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est la broche GPIO utilisée pour allumer le rétro-éclairage, et également </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IO21</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui est connecté à la broche </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> de l' </font><font style="vertical-align: inherit;">écran LCD. Ce contact contrôle le type d'informations que nous transmettons à l'écran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, configurez le bus SPI.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MISO = GPIO_NUM_19;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_MOSI = GPIO_NUM_23;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_SCLK = GPIO_NUM_18;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_CS = GPIO_NUM_5;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_DC = GPIO_NUM_21;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">gpio_num_t</span> LCD_PIN_BACKLIGHT = GPIO_NUM_14;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_WIDTH = <span class="hljs-number">320</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_HEIGHT = <span class="hljs-number">240</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> LCD_DEPTH = <span class="hljs-number">2</span>;<font></font>
<font></font>
<font></font>
<span class="hljs-keyword">spi_bus_config_t</span> spiBusConfig = {};<font></font>
spiBusConfig.miso_io_num = LCD_PIN_MISO;<font></font>
spiBusConfig.mosi_io_num = LCD_PIN_MOSI;<font></font>
spiBusConfig.sclk_io_num = LCD_PIN_SCLK;<font></font>
spiBusConfig.quadwp_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span>
spiBusConfig.quadhd_io_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">// Unused</span><font></font>
spiBusConfig.max_transfer_sz = LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_initialize(VSPI_HOST, &amp;spiBusConfig, <span class="hljs-number">1</span>));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous configurons le bus à l'aide de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_bus_config_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il est nécessaire de communiquer les contacts que nous utilisons et la taille maximale d'un transfert de données. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'instant, nous effectuerons une transmission SPI pour toutes les données du tampon de trame, qui est égale à la largeur de l'écran LCD (en pixels) multipliée par sa hauteur (en pixels) multipliée par le nombre d'octets par pixel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La largeur est de 320, la hauteur est de 240 et la profondeur de couleur est de 2 octets (l'écran s'attend à ce que les couleurs des pixels aient une profondeur de 16 bits).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">spi_handle_t</span> gSpiHandle;<font></font>
<font></font>
<span class="hljs-keyword">spi_device_interface_config_t</span> spiDeviceConfig = {};<font></font>
spiDeviceConfig.clock_speed_hz = SPI_MASTER_FREQ_40M;<font></font>
spiDeviceConfig.spics_io_num = LCD_PIN_CS;<font></font>
spiDeviceConfig.queue_size = <span class="hljs-number">1</span>;<font></font>
spiDeviceConfig.flags = SPI_DEVICE_NO_DUMMY;<font></font>
<font></font>
ESP_ERROR_CHECK(spi_bus_add_device(VSPI_HOST, &amp;spiDeviceConfig, &amp;gSpiHandle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir initialisé le bus, nous devons ajouter un périphérique LCD au bus afin que nous puissions commencer à lui parler.</font></font><br>
<br>
<ul>
<li><strong>clock_speed_hz</strong> —   - ,      SPI   40 ,     .        80 ,         .</li>
<li><strong>spics_io_num</strong> —    CS,  IDF     CS,        ( SD-     SPI).</li>
<li><strong>queue_size</strong> —     1,           (  ).</li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">drapeaux</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - le pilote IDF SPI insère généralement des bits vides dans la transmission pour éviter les problèmes de synchronisation lors de la lecture à partir du périphérique SPI, mais nous effectuons une transmission unidirectionnelle (nous ne lirons pas à partir de l'écran). </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_DEVICE_NO_DUMMY</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> signale que nous confirmons cette transmission unidirectionnelle et que nous n'avons pas besoin d'insérer des bits vides.</font></font></li>
</ul><br>
<br>
<pre><code class="cpp hljs">gpio_set_direction(LCD_PIN_DC, GPIO_MODE_OUTPUT);<font></font>
gpio_set_direction(LCD_PIN_BACKLIGHT, GPIO_MODE_OUTPUT);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous devons également définir les </font><font style="vertical-align: inherit;">broches </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et de rétroéclairage en tant que broches GPIO. </font><font style="vertical-align: inherit;">Après avoir commuté </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC, le</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> rétro </font><strong><font style="vertical-align: inherit;">-</font></strong><font style="vertical-align: inherit;"> éclairage sera constamment allumé.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Équipes</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La communication avec l'écran LCD se fait sous forme de commandes. </font><font style="vertical-align: inherit;">Tout d'abord, nous transmettons un octet indiquant la commande que nous voulons envoyer, puis nous transmettons les paramètres de commande (le cas échéant). </font><font style="vertical-align: inherit;">L'écran comprend que l'octet est une commande si le </font><font style="vertical-align: inherit;">signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est faible. </font><font style="vertical-align: inherit;">Si le </font><font style="vertical-align: inherit;">signal </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est élevé, les données reçues seront considérées comme les paramètres de la commande précédemment transmise. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En général, le flux ressemble à ceci:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous donnons un </font><font style="vertical-align: inherit;">signal faible </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous envoyons un octet de la commande</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous donnons un </font><font style="vertical-align: inherit;">signal élevé </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Envoyer zéro ou plusieurs octets, selon les exigences de la commande</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Répétez les étapes 1 à 4</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, notre meilleur ami est </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la spécification ILI9341</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Il répertorie toutes les commandes possibles, leurs paramètres et comment les utiliser.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68d/8d8/09c/68d8d809ceb9446142cd5c77bb78d0e2.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple de commande sans paramètres est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Display ON</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'octet de commande est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x29</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais aucun paramètre n'est spécifié pour lui.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35a/4e0/446/35a4e04466c22aa6746fe441f345c02f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un exemple de commande avec des paramètres est l' </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ensemble d'adresses de colonne</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">L'octet de commande est </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mais quatre paramètres obligatoires lui sont spécifiés. </font><font style="vertical-align: inherit;">Pour utiliser la commande, vous devez envoyer un </font><font style="vertical-align: inherit;">signal bas </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , envoyer </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0x2A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , envoyer un </font><font style="vertical-align: inherit;">signal haut </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , puis transférer les octets de quatre paramètres. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les codes de commande eux-mêmes sont spécifiés dans l'énumération.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><font></font>
{<font></font>
	SOFTWARE_RESET = <span class="hljs-number">0x01</span>u,<font></font>
	SLEEP_OUT = <span class="hljs-number">0x11</span>u,<font></font>
	DISPLAY_ON = <span class="hljs-number">0x29</span>u,<font></font>
	COLUMN_ADDRESS_SET = <span class="hljs-number">0x2A</span>u,<font></font>
	PAGE_ADDRESS_SET = <span class="hljs-number">0x2B</span>u,<font></font>
	MEMORY_WRITE = <span class="hljs-number">0x2C</span>u,<font></font>
	MEMORY_ACCESS_CONTROL = <span class="hljs-number">0x36</span>u,<font></font>
	PIXEL_FORMAT_SET = <span class="hljs-number">0x3A</span>u,<font></font>
} CommandCode;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Au lieu de cela, nous pourrions utiliser une macro ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">#define SOFTWARE_RESET (0x01u)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), mais ils n'ont pas de symboles dans le débogueur et ils n'ont aucune portée. </font><font style="vertical-align: inherit;">Il serait également possible d'utiliser des constantes statiques entières, comme nous l'avons fait avec les contacts GPIO, mais grâce à l'énumération, nous pouvons en un coup d'œil comprendre quelles données sont passées à une fonction ou à un membre de la structure: elles sont de type </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CommandCode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Sinon, il pourrait s'agir de </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uint8_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> brut </font><font style="vertical-align: inherit;">qui ne </font><strong><font style="vertical-align: inherit;">dit</font></strong><font style="vertical-align: inherit;"> rien au programmeur qui lit le code.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lancement</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lors de l'initialisation, nous pouvons passer différentes commandes pour pouvoir dessiner quelque chose. </font><font style="vertical-align: inherit;">Chaque commande a un octet de commande, que nous appellerons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de commande</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allons définir une structure pour stocker la commande de lancement afin que vous puissiez spécifier leur tableau.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span><font></font>
	CommandCode code;<font></font>
	<span class="hljs-keyword">uint8_t</span> parameters[<span class="hljs-number">15</span>];
	<span class="hljs-keyword">uint8_t</span> length;<font></font>
} StartupCommand;</code></pre><br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le code de commande.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parameters</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est un tableau de paramètres de commande (le cas échéant). </font><font style="vertical-align: inherit;">Il s'agit d'un tableau statique de taille 15, car il s'agit du nombre maximal de paramètres dont nous avons besoin. </font><font style="vertical-align: inherit;">En raison de la nature statique du tableau, nous n'avons pas à nous soucier d'allouer un tableau dynamique pour chaque commande à chaque fois.</font></font></li>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">longueur</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> est le nombre de paramètres dans le tableau des </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètres</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant cette structure, nous pouvons spécifier une liste de commandes de lancement.</font></font><br>
<br>
<pre><code class="cpp hljs">StartupCommand gStartupCommands[] =<font></font>
{<font></font>
	<span class="hljs-comment">// Reset to defaults</span><font></font>
	{<font></font>
		SOFTWARE_RESET,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Landscape Mode</span>
	<span class="hljs-comment">// Top-Left Origin</span>
	<span class="hljs-comment">// BGR Panel</span><font></font>
	{<font></font>
		MEMORY_ACCESS_CONTROL,<font></font>
		{<span class="hljs-number">0x20</span> | <span class="hljs-number">0xC0</span> | <span class="hljs-number">0x08</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// 16 bits per pixel</span><font></font>
	{<font></font>
		PIXEL_FORMAT_SET,<font></font>
		{<span class="hljs-number">0x55</span>},
		<span class="hljs-number">1</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Exit sleep mode</span><font></font>
	{<font></font>
		SLEEP_OUT,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
<font></font>
	<span class="hljs-comment">// Turn on the display</span><font></font>
	{<font></font>
		DISPLAY_ON,<font></font>
		{},<font></font>
		<span class="hljs-number">0</span><font></font>
	},<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les commandes sans paramètres, par exemple </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOFTWARE_RESET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , définissent la liste d'initialisation sur les </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">paramètres</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> comme vides (c'est-à-dire avec un zéro) et la longueur définie sur 0. Les commandes avec paramètres remplissent les paramètres et spécifient la longueur. </font><font style="vertical-align: inherit;">Ce serait formidable si nous pouvions définir la longueur automatiquement et ne pas écrire de nombres (au cas où nous ferions une erreur ou si les paramètres changent), mais je ne pense pas que cela en vaille la peine. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le but de la plupart des équipes est clair d'après le nom, à l'exception de deux. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_ACCESS_CONTROL</font></font></strong><br>
<br>
<ul>
<li><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mode paysage:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> par défaut, l'affichage utilise l'orientation portrait (240x320), mais nous voulons utiliser le paysage (320x240).</font></font></li>
<li><strong>Top-Left Origin:</strong>      (0,0)     ,    ( )         .</li>
<li><strong>BGR Panel:</strong>  ,        BGR.   ,    , ,   ,     .</li>
</ul><br>
<strong>PIXEL_FORMAT_SET</strong><br>
<br>
<ul>
<li><strong>16 bits per pixel:</strong>   16- .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe de nombreuses autres commandes qui peuvent être envoyées au démarrage pour contrôler divers aspects, tels que le gamma. Les paramètres nécessaires sont décrits dans la spécification de l'écran LCD lui-même (et non du contrôleur ILI9341), auquel nous n'avons pas accès. Si nous ne transmettons pas ces commandes, les paramètres d'affichage par défaut sont utilisés, ce qui nous convient parfaitement. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir préparé un tableau de commandes de lancement, nous pouvons commencer à les transférer sur l'écran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous avons besoin d'une fonction qui envoie un octet de commande à l'écran. N'oubliez pas que l'envoi de commandes est différent de l'envoi de paramètres, car nous devons envoyer un </font><font style="vertical-align: inherit;">signal faible </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BYTES_TO_BITS(value) ( (value) * 8 )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandCode</span><span class="hljs-params">(CommandCode code)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(<span class="hljs-number">1</span>);<font></font>
	transaction.tx_data[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">uint8_t</span>)code;<font></font>
	transaction.flags = SPI_TRANS_USE_TXDATA;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">0</span>);<font></font>
	spi_device_transmit(gSpiHandle, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'IDF a une structure </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">spi_transaction_t</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , que nous </font><strong><font style="vertical-align: inherit;">remplissons</font></strong><font style="vertical-align: inherit;"> lorsque nous voulons transférer quelque chose via le bus SPI. Nous savons combien de bits représente la charge utile et transférons la charge elle-même. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons soit passer un pointeur vers la charge utile, soit utiliser la structure interne struct </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , qui ne fait que quatre octets, mais évite au pilote d'avoir à accéder à la mémoire externe. Si nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tx_data</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , nous devons définir l'indicateur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de transmettre des données, nous envoyons un </font><font style="vertical-align: inherit;">signal bas </font><font style="vertical-align: inherit;">au </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , indiquant qu'il s'agit d'un code de commande.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SendCommandParameters</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">int</span> length)</span>
</span>{
	<span class="hljs-keyword">spi_transaction_t</span> transaction = {};<font></font>
<font></font>
	transaction.length = BYTES_TO_BITS(length);<font></font>
	transaction.tx_buffer = data;<font></font>
	transaction.flags = <span class="hljs-number">0</span>;<font></font>
<font></font>
	gpio_set_level(LCD_PIN_DC, <span class="hljs-number">1</span>);<font></font>
	spi_device_transmit(SPIHANDLE, &amp;transaction);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La transmission de paramètres est similaire à l'envoi d'une commande, mais cette fois-ci, nous utilisons notre propre tampon ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">données</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et envoyons un </font><font style="vertical-align: inherit;">signal élevé </font><font style="vertical-align: inherit;">à </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DC</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> pour indiquer à l'écran que les paramètres sont transmis. </font><font style="vertical-align: inherit;">De plus, nous ne définissons pas l'indicateur </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPI_TRANS_USE_TXDATA</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> car nous transmettons notre propre tampon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ensuite, vous pouvez envoyer toutes les commandes de lancement.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ARRAY_COUNT(value) ( sizeof(value) / sizeof(value[0]) )</span><font></font>
<font></font>
<span class="hljs-keyword">int</span> commandCount = ARRAY_COUNT(gStartupCommands);<font></font>
<font></font>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> commandIndex = <span class="hljs-number">0</span>; commandIndex &lt; commandCount; ++commandIndex)<font></font>
{<font></font>
	StartupCommand* command = &amp;gStartupCommands[commandIndex];<font></font>
<font></font>
	SendCommandCode(command-&gt;code);<font></font>
<font></font>
	<span class="hljs-keyword">if</span> (command-&gt;length &gt; <span class="hljs-number">0</span>)<font></font>
	{<font></font>
		SendCommandData(command-&gt;parameters, command-&gt;length);<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous parcourons de manière itérative le tableau des commandes de lancement, en passant d'abord le code de commande, puis les paramètres (le cas échéant).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dessin de cadre</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Après avoir initialisé l'affichage, vous pouvez commencer à dessiner dessus.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> UPPER_BYTE_16(value) ( (value) &gt;&gt; 8u )</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LOWER_BYTE_16(value) ( (value) &amp; 0xFFu )</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Odroid_DrawFrame</span><span class="hljs-params">(<span class="hljs-keyword">uint8_t</span>* buffer)</span>
</span>{
	<span class="hljs-comment">// Set drawing window width to (0, LCD_WIDTH)</span>
    <span class="hljs-keyword">uint8_t</span> drawWidth[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_WIDTH), LOWER_BYTE_16(LCD_WIDTH) };<font></font>
	SendCommandCode(COLUMN_ADDRESS_SET);<font></font>
	SendCommandParameters(drawWidth, ARRAY_COUNT(drawWidth));<font></font>
<font></font>
	<span class="hljs-comment">// Set drawing window height to (0, LCD_HEIGHT)</span>
    <span class="hljs-keyword">uint8_t</span> drawHeight[] = { <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, UPPER_BYTE_16(LCD_HEIGHT), LOWER_BYTE_16(LCD_HEIGHT) };<font></font>
	SendCommandCode(PAGE_ADDRESS_SET);<font></font>
	SendCommandParameters(drawHeight, ARRAY_COUNT(drawHeight));<font></font>
<font></font>
	<span class="hljs-comment">// Send the buffer to the display</span><font></font>
	SendCommandCode(MEMORY_WRITE);<font></font>
	SendCommandParameters(buffer, LCD_WIDTH * LCD_HEIGHT * LCD_DEPTH);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 a la possibilité de redessiner des parties individuelles de l'écran. Cela peut être utile à l'avenir si nous remarquons une baisse de la fréquence d'images. Dans ce cas, il sera possible de mettre à jour uniquement les parties modifiées de l'écran, mais pour l'instant nous allons simplement redessiner tout l'écran à nouveau. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour rendre un cadre, il faut définir une fenêtre de rendu. Pour ce faire, envoyez la commande </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">COLUMN_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la largeur de la fenêtre et la commande </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PAGE_ADDRESS_SET</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> avec la hauteur de la fenêtre. Chacune des commandes prend quatre octets du paramètre qui décrivent la fenêtre dans laquelle nous allons effectuer le rendu. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPPER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LOWER_BYTE_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ce sont des macros auxiliaires pour extraire les octets haut et bas d'une valeur 16 bits. </font><font style="vertical-align: inherit;">Les paramètres de ces commandes nous obligent à diviser la valeur 16 bits en deux valeurs 8 bits, c'est pourquoi nous le faisons. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le rendu est initié par la commande </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MEMORY_WRITE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et envoie à l'affichage tous les </font><strong><font style="vertical-align: inherit;">153 600</font></strong><font style="vertical-align: inherit;"> octets du tampon de trame à la fois. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe d'autres façons de transférer le tampon de trame vers l'affichage:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nous pouvons créer une autre tâche FreeRTOS (tâche), qui est responsable de la coordination des transactions SPI.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez transférer un cadre non pas en un, mais en plusieurs transactions.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez utiliser une transmission non bloquante, dans laquelle nous initions l'envoi, puis continuons à effectuer d'autres opérations.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vous pouvez utiliser n'importe quelle combinaison des méthodes ci-dessus.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour l'instant, nous allons utiliser le moyen le plus simple: la seule transaction de blocage. </font><font style="vertical-align: inherit;">Lorsque </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DrawFrame est</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> appelé, le </font><font style="vertical-align: inherit;">transfert vers l'affichage est lancé et notre tâche est suspendue jusqu'à ce que le transfert soit terminé. </font><font style="vertical-align: inherit;">Si plus tard, nous découvrons que nous ne pouvons pas atteindre une bonne fréquence d'images avec cette méthode, nous reviendrons sur ce problème.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565 et ordre des octets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un affichage typique (par exemple, le moniteur de votre ordinateur) a une profondeur de 24 bits (1,6 million de couleurs): 8 bits par rouge, vert et bleu. Le pixel est écrit en mémoire sous la forme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRRRRGGGGGGGGGBBBBBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'écran LCD Odroid a une profondeur de 16 bits (65 000 couleurs): 5 bits de rouge, 6 bits de vert et 5 bits de bleu. Le pixel est écrit en mémoire sous la forme </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RRRRRGGGGGGGBBBBB</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Ce format est appelé </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SWAP_ENDIAN_16(value) ( (((value) &amp; 0xFFu) <span class="hljs-meta-string">&lt;&lt; 8u) | ((value) &gt;&gt; 8u)  )</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RGB565(red, green, blue) ( SWAP_ENDIAN_16( ((red) &lt;&lt; 11u) | ((green) &lt;&lt; 5u) | (blue) ) )</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Définissez une macro qui crée une couleur au format RGB565. Nous lui passerons un octet de rouge, un octet de vert et un octet de bleu. Il prendra les cinq bits de rouge les plus significatifs, les six bits de vert les plus significatifs et les cinq bits de bleu les plus significatifs. Nous avons choisi des bits hauts car ils contiennent plus d'informations que des bits bas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cependant, l'ESP32 stocke les données dans l'ordre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Little Endian</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , c'est-à-dire que l'octet le moins significatif est stocké dans l'adresse mémoire inférieure. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple, la valeur 32 bits </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xDE 0xAD 0xBE 0xEF]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sera stockée en mémoire en tant que </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[0xEF 0xBE 0xAD 0xDE]</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Lors du transfert de données vers l'affichage, cela devient un problème car l'octet le moins significatif sera envoyé en premier et l'écran LCD s'attend à recevoir l'octet le plus significatif en premier. </font><strong><font style="vertical-align: inherit;">Définir la</font></strong></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
macro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SWAP_ENDIAN_16</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour échanger des octets et l'utiliser dans la macro </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RGB565</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici comment chacune des trois couleurs primaires est décrite dans RGB565 et comment elles sont stockées dans la mémoire ESP32 si vous ne changez pas l'ordre des octets. </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rouge</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
11111 | 000000 | 00000? -&gt; 11111000 00000000 -&gt; 00000000 11111000 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vert</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 111111 | 00000? -&gt; 00000111 11100000 -&gt; 11100000 00000111 </font></font><br>
<br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleu</font></font></strong><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
00000 | 000000 | 11111? -&gt; 00000000 00011111 -&gt; 00011111 00000000</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous pouvons créer une démo simple pour regarder l'écran LCD en action. </font><font style="vertical-align: inherit;">Au début du cadre, il vide le tampon de cadre au noir et dessine un carré de 50x50. </font><font style="vertical-align: inherit;">Nous pouvons déplacer le carré avec une croix et changer sa couleur avec les boutons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">B</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Démarrer</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">app_main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{<font></font>
	Odroid_InitializeInput();<font></font>
	Odroid_InitializeDisplay();<font></font>
<font></font>
	ESP_LOGI(LOG_TAG, <span class="hljs-string">"Odroid initialization complete - entering main loop"</span>);<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span>* framebuffer = (<span class="hljs-keyword">uint16_t</span>*)heap_caps_malloc(<span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>, MALLOC_CAP_DMA);<font></font>
	assert(framebuffer);<font></font>
<font></font>
	<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;<font></font>
<font></font>
	<span class="hljs-keyword">uint16_t</span> color = <span class="hljs-number">0xffff</span>;<font></font>
<font></font>
	<span class="hljs-keyword">for</span> (;;)<font></font>
	{<font></font>
		<span class="hljs-built_in">memset</span>(framebuffer, <span class="hljs-number">0</span>, <span class="hljs-number">320</span> * <span class="hljs-number">240</span> * <span class="hljs-number">2</span>);<font></font>
<font></font>
		Odroid_Input input = Odroid_PollInput();<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.left) { x -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.right) { x += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.up) { y -= <span class="hljs-number">10</span>; }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.down) { y += <span class="hljs-number">10</span>; }<font></font>
<font></font>
		<span class="hljs-keyword">if</span> (input.a) { color = RGB565(<span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.b) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>); }
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (input.start) { color = RGB565(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>); }<font></font>
<font></font>
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = y; row &lt; y + <span class="hljs-number">50</span>; ++row)<font></font>
		{<font></font>
			<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = x; col &lt; x + <span class="hljs-number">50</span>; ++col)<font></font>
			{<font></font>
				framebuffer[<span class="hljs-number">320</span> * row + col] = color;<font></font>
			}<font></font>
		}<font></font>
<font></font>
		Odroid_DrawFrame(framebuffer);<font></font>
	}<font></font>
<font></font>
	<span class="hljs-comment">// Should never get here</span><font></font>
	esp_restart();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous allouons le tampon de trame en fonction de la taille totale de l'affichage: 320 x 240, deux octets par pixel (couleur 16 bits). </font><font style="vertical-align: inherit;">Nous utilisons </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">heap_caps_malloc</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> afin qu'il soit alloué en mémoire, ce qui peut être utilisé pour les transactions SPI avec </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">accès direct à la mémoire (DMA)</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Le DMA permet aux périphériques SPI d'accéder au tampon de trame sans nécessiter l'intervention du processeur. </font><font style="vertical-align: inherit;">Sans DMA, les transactions SPI prennent beaucoup plus de temps. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous n'effectuons pas de vérifications pour nous assurer que le rendu ne se produit pas en dehors des bordures de l'écran.</font></font><br>
<br>
<div class="oembed"><div><div style="left: 0; width: 100%; height: 0; position: relative; padding-bottom: 56.25%;"><video controls="" style="top: 0; left: 0; width: 100%; height: 100%; position: absolute;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Votre navigateur ne prend pas en charge la vidéo HTML5.</font></font><source src="https://austinmorlan.com/posts/embedded_game_programming_3/media/demo.mp4" type="video/mp4"></video></div></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un fort déchirement est perceptible. Dans les applications de bureau, la méthode standard pour éliminer les déchirures consiste à utiliser plusieurs tampons. Par exemple, lors d'une double mise en mémoire tampon, il y a deux tampons: les tampons avant et arrière. Pendant que le tampon avant est affiché, l'enregistrement est effectué </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
à l'arrière. Ensuite, ils changent de place et le processus se répète. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'ESP32 n'a pas assez de RAM avec des capacités DMA pour stocker deux tampons de trame (4 Mo de RAM SPI externe, malheureusement, n'a pas de capacités DMA), donc cette option ne convient pas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ILI9341 a un signal ( </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TE</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) qui vous indique quand </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VBLANK</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se produit </font><strong><font style="vertical-align: inherit;">afin</font></strong><font style="vertical-align: inherit;"> que nous puissions écrire sur l'écran jusqu'à ce qu'il soit dessiné. Mais avec Odroid (ou le module d'affichage), ce signal n'est pas connecté, nous ne pouvons donc pas y accéder.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Peut-être pourrions-nous trouver une valeur décente, mais pour l'instant nous ne le ferons pas, car maintenant notre tâche consiste simplement à afficher les pixels à l'écran.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La source</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout le code source peut être trouvé </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ici</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Références</font></font></h3><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schéma Odroid Go</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Va jouer</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentation ESP-IDF: SPI Master</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fiche technique du pilote LCD</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr502518/index.html">Comment grimper à un arbre</a></li>
<li><a href="../fr502520/index.html">Rapports vidéo des rapports Mitap sur l'analyse des produits</a></li>
<li><a href="../fr502522/index.html">Nous ouvrons la puce d'isolation galvanique avec un minuscule transformateur à l'intérieur</a></li>
<li><a href="../fr502524/index.html">Les psychos font la civilisation</a></li>
<li><a href="../fr502526/index.html">Semaine de diffusion en ligne JUG Ru Group # 2</a></li>
<li><a href="../fr502532/index.html">La révolution dans le département informatique (département). Est-ce nécessaire?</a></li>
<li><a href="../fr502536/index.html">Premières impressions et principales caractéristiques de MIUI 12</a></li>
<li><a href="../fr502538/index.html">Comment créer une ancienne version de NGINX Ingress Controller et la corriger</a></li>
<li><a href="../fr502540/index.html">Alpine.js - continuer la datation</a></li>
<li><a href="../fr502542/index.html">Comment nous enseignons à Yandex à répondre aux questions et à économiser 20 000 heures par jour aux utilisateurs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>