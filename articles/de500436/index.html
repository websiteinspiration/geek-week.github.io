<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòã üëêüèæ ‚ôãÔ∏è Kommen von bin√§ren neuronalen Netzen basierend auf zuf√§lligen Neuronen und logischen Funktionen üõçÔ∏è üò¶ ü§±üèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage sind unter vielen Algorithmen f√ºr maschinelles Lernen neuronale Netze (NS) weit verbreitet. Der Hauptvorteil von NS gegen√ºber anderen Metho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kommen von bin√§ren neuronalen Netzen basierend auf zuf√§lligen Neuronen und logischen Funktionen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500436/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heutzutage sind unter vielen Algorithmen f√ºr maschinelles Lernen neuronale Netze (NS) weit verbreitet. </font><font style="vertical-align: inherit;">Der Hauptvorteil von NS gegen√ºber anderen Methoden des maschinellen Lernens besteht darin, dass sie ziemlich tiefe, oft nicht offensichtliche Muster in den Daten aufdecken k√∂nnen. </font><font style="vertical-align: inherit;">Das klassische Paradigma unter NSs sind vollst√§ndig verbundene Netzwerke mit R√ºckw√§rtsausbreitung von Fehlern.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndig verbundene NS mit R√ºckw√§rtsausbreitung von Fehlern haben viele Vorteile, darunter vor allem die relativ hohe Genauigkeit der Klassifizierung von Quelldaten auf der Grundlage des ‚Äûstarken‚Äú mathematischen Apparats, der ihrer Funktionsweise zugrunde liegt. Andererseits gibt es jedoch Nachteile, von denen der gr√∂√üte die Tendenz zur Umschulung ist, wenn sich der NS an die lokalen Eigenschaften der Trainingsprobe anpasst und seine Verallgemeinerungsf√§higkeit verliert. Dies verringert die Effizienz und Zweckm√§√üigkeit ihrer Verwendung als Mittel zur Klassifizierung oder Prognose au√üerhalb des Trainingssatzes f√ºr beliebige Daten.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel wird vorgeschlagen, eine Variante eines vollst√§ndig verbundenen bin√§ren NS (bin√§re Variablen dienen als Zielwert des Netzwerks) mit einer logischen Funktion am Ausgang zu betrachten, bei der es keinen Mechanismus f√ºr die R√ºckausbreitung des Fehlers gibt. </font><font style="vertical-align: inherit;">In der Trainingsphase wird bei der Bildung der Gewichtskoeffizienten von Neuronen anstelle mehrerer iterativer Berechnungen f√ºr jede Trainingsprobe eine einzelne zuf√§llige Auswahl von Koeffizienten durchgef√ºhrt, wodurch die Trainingszeit erheblich verk√ºrzt wird. </font><font style="vertical-align: inherit;">Ein weiterer grundlegender Vorteil dieses Ansatzes ist das Fehlen eines Problems bei der Umschulung des Netzwerks.</font></font></p><a name="habracut"></a><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Abb. </font><font style="vertical-align: inherit;">Das Blockdiagramm eines bin√§ren zuf√§lligen logischen neuronalen Netzwerks ist gegeben.</font></font></p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/4z/o7/lo4zo7-llf0bqivhmyg7nlzlqha.png"></div><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der bin√§re Zufalls-NS besteht strukturell aus drei aufeinanderfolgenden Schichten, die nummeriert sind, wenn Informationen von Eingabe zu Ausgabe √ºbertragen werden:</font></font></p><br>
<ol>
<li> :  ;</li>
<li> :  ;</li>
<li> :    .</li>
</ol><br>
<p>     .</p><br>
<p>           ,             0  1.             ,           ,    .</p><br>
<p><strong>:</strong>    <strong></strong>     <strong>f()</strong>,     <strong>s=F(x)</strong>     <strong>(0,1)</strong>,   <strong>F(x)</strong>       <strong></strong>, . . <strong>f()=</strong><i><strong>d</strong></i><strong>F(x)/</strong><i><strong>d</strong></i><strong>x</strong>.</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/1z/wm/6y1zwmjxemx9i0bi7t-fiqufxwg.png"></div><br>
<p>,      <strong>X</strong>     <strong>S</strong>,           <strong>(0,1)</strong>        .  ,   <strong>X</strong>,      <i>N</i>- ,     <i>N</i>- ,         <i>N</i>-  ,    .          ,   ,     .</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/vm/fi/yvvmfiei947k9zklv6rwbizq478.png" width="300" height="300"></div><br>
<p>   ,  ,    <strong>F(x)</strong>      X<i><sub>i</sub></i> (<i>i</i>=1,2,‚Ä¶,<i>N</i>)   .               <strong>F</strong><i><strong><sub>i</sub></strong></i><strong>(x)</strong>,        <i>i</i>-   .              .                  ,  :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/f7/am/4pf7amgmjc2dhk9_krzur3nbihq.png" width="163" height="42"></div><br>
<p>  ,       <i>N</i>        <strong>X.</strong>      : <i>a</i> ‚Äì ; <i>x</i>0 ‚Äì  ,     .</p><br>
<p>   ,    <strong>S</strong>       .       <i>N</i>-  ,     <strong>W</strong>={w<sub>0</sub>, w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>, ‚Ä¶, w<sub>N</sub>} ,     <strong>S</strong>={s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, ‚Ä¶, s<sub>N</sub>},  ,  :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/yc/bt/-eycbt39ktvfev9ezwg2xch8g3g.png" width="146" height="64"></div><br>
<p>,  ,    ,                  .        .</p><br>
<p>  -   ,  ,     <strong>W</strong>    :</p><br>
<p><strong> N-       ,    </strong></p><br>
<p>          .          (  ),       .     ,            .</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cy/5a/vh/cy5avhzuvd_v2kmvmpno6px8iju.png" width="300" height="300"></div><br>
<p>        <strong>W</strong>    ,  ,     .     <i>N</i>-         ,   : a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ‚Ä¶, a<sub>N</sub>,    0&lt;a<sub>i</sub>&lt;1. ,   ,   :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/ds/en/rndsen_ctpdfc2gcequujer4_eo.png" width="184" height="61"></div><br>
<p> n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, ‚Ä¶, n<sub>N</sub> ‚Äì     ,         <strong>S</strong> (        ,         ); w<sub>0</sub> ‚Äì    ,  1.          ,           .</p><br>
<p>,         , . .    .      -,      .                 .</p><br>
<p>       :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/n-/uj/zun-ujbmiuzil8h7dge0ymyafxu.png" width="313" height="26"></div><br>
<p>   <i>M</i>          <i>M</i> ,       ,    ,    Sign,   ()   .        ,      .</p><br>
<p>            ,     ,  ,  ,     .           ,             ,    ,     ,      .</p><br>
<p>             -‚Äô      (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/post/424517</a>).      ,     ,        .    ,              ¬´¬ª ¬´*¬ª.                .</p><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">   C#              (  )</b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">using System;<font></font>
using System.Collections.Generic;<font></font>
using System.Linq;<font></font>
<font></font>
namespace RndNeuroNet<font></font>
{<font></font>
  #region   <font></font>
  /// &lt;summary&gt;<font></font>
  ///       <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomNeuralNetwork<font></font>
  {<font></font>
    private DistributionFunc[] pDistributionDataFuncs;<font></font>
    private RandomDiscrimBase pNeuroLogicDiscrim;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public RandomNeuralNetwork()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///    <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pSourceTermsData"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="pTargetFeature"&gt;&lt;/param&gt;<font></font>
    public void CreateNetwork(double[][] pSourceData, bool[] pTargetFeature,<font></font>
      int iFromPos, int iTargetPos, int iWindowSize,<font></font>
      int iAmountLogicDiscrims, int iLogicDiscrimsMaxTrainRestarts = 1,<font></font>
      int iMaxAmountDistributionPoints = 1000, bool bIsNorming = true)<font></font>
    {<font></font>
      //  <font></font>
      double[][] pSrcArray = new double[iTargetPos - iFromPos][];<font></font>
      bool[] pDstArray = new bool[iTargetPos - iFromPos];<font></font>
      for (int i = 0, t = iFromPos; t &lt; iTargetPos; t++, i++)<font></font>
      {<font></font>
        //  <font></font>
        pSrcArray[i] = (bIsNorming ? NormingE(pSourceData[t], iWindowSize, iWindowSize) : pSourceData[t]);<font></font>
        pDstArray[i] = pTargetFeature[t];<font></font>
      }<font></font>
      //    <font></font>
      pDistributionDataFuncs = new DistributionFunc[iWindowSize];<font></font>
      for (int i = 0; i &lt; iWindowSize; i++)<font></font>
      {<font></font>
        //   <font></font>
        double[] pTrend2Recalc = pSrcArray.Select(p =&gt; p != null ? p[i] : 0).ToArray();<font></font>
        // <font></font>
        pDistributionDataFuncs[i] = new DistributionFunc(pTrend2Recalc, iMaxAmountDistributionPoints);<font></font>
        //     <font></font>
        pTrend2Recalc = pDistributionDataFuncs[i].RecalcTrend(pTrend2Recalc);<font></font>
        //    <font></font>
        for (int t = 0; t &lt; pSrcArray.Length; t++) pSrcArray[t][i] = pTrend2Recalc[t];<font></font>
      }<font></font>
      // <font></font>
      pNeuroLogicDiscrim = (RandomDiscrimBase)new RandomLogicDiscrim();<font></font>
      pNeuroLogicDiscrim.CreateDiscrim(pSrcArray, pDstArray, 0, pSrcArray.Length,<font></font>
        iWindowSize, iAmountLogicDiscrims, iLogicDiscrimsMaxTrainRestarts);<font></font>
    }<font></font>
<font></font>
    public double CalcResponce(double[] pSourceData, int iWindowSize = 0, bool bIsNorming = true)<font></font>
    {<font></font>
      // <font></font>
      if (iWindowSize &lt;= 0) iWindowSize = pSourceData.Length;<font></font>
      //  <font></font>
      pSourceData = (bIsNorming ? NormingE(pSourceData, iWindowSize, iWindowSize) : pSourceData);<font></font>
      //  <font></font>
      for (int i = 0; i &lt; iWindowSize; i++)<font></font>
      {<font></font>
        pSourceData[i] = pDistributionDataFuncs[i].RecalcTrend(pSourceData[i]);<font></font>
      }<font></font>
      //  <font></font>
      return pNeuroLogicDiscrim.GetPrognos(pSourceData, iWindowSize);<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///     <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pTrend"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="iTargetPosition"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="iVectorSize"&gt;&lt;/param&gt;<font></font>
    /// &lt;returns&gt;&lt;/returns&gt;<font></font>
    public static double[] NormingE(double[] pTrend, int iTargetPosition,<font></font>
      int iVectorSize, double[] pResultVector = null, bool bIsMinusOffset = false)<font></font>
    {<font></font>
      if (pResultVector == null) pResultVector = new double[iVectorSize];<font></font>
      double dNorming = 0;<font></font>
      for (int i = 0, t = iTargetPosition - iVectorSize; i &lt; iVectorSize; i++, t++)<font></font>
      {<font></font>
        dNorming += pTrend[t];<font></font>
      }<font></font>
      dNorming /= iVectorSize;<font></font>
      double dOffset = (bIsMinusOffset ? 1 : 0);<font></font>
      for (int i = 0, t = iTargetPosition - iVectorSize; i &lt; iVectorSize; i++, t++)<font></font>
      {<font></font>
        pResultVector[i] = (pTrend[t] / dNorming) - dOffset;<font></font>
      }<font></font>
      return pResultVector;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public class DistributionFunc<font></font>
  {<font></font>
    private class DataCont<font></font>
    {<font></font>
      public int Counter;<font></font>
      public double SumSrc;<font></font>
      public double ValueP;<font></font>
    }<font></font>
<font></font>
    private readonly SortedDictionary&lt;int, DataCont&gt; pDistribution =<font></font>
      new SortedDictionary&lt;int, DataCont&gt;();<font></font>
    private int m_iMaxAmountDistributionPoints;<font></font>
    private double dAreaMin, dAreaMax;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public DistributionFunc()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public DistributionFunc(double[] pTrend, int iMaxAmountDistributionPoints = 1000)<font></font>
    {<font></font>
      CreateDistribution(pTrend, iMaxAmountDistributionPoints);<font></font>
    }<font></font>
<font></font>
    //  <font></font>
    public void CreateDistribution(double[] pTrend, int iMaxAmountDistributionPoints = 1000)<font></font>
    {<font></font>
      m_iMaxAmountDistributionPoints = iMaxAmountDistributionPoints;<font></font>
      dAreaMin = double.MaxValue; dAreaMax = 0;<font></font>
      //      <font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        double dTrendVal = pTrend[t];<font></font>
        if (dTrendVal == 0) continue;<font></font>
        dAreaMin = Math.Min(dAreaMin, dTrendVal);<font></font>
        dAreaMax = Math.Max(dAreaMax, dTrendVal);<font></font>
      }<font></font>
      //  <font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        double dTrendVal = pTrend[t];<font></font>
        if (dTrendVal == 0) continue;<font></font>
        int iIndex = (int)(((dTrendVal - dAreaMin) / (dAreaMax - dAreaMin)) * m_iMaxAmountDistributionPoints);<font></font>
        DataCont pKeyVal = null;<font></font>
        pDistribution.TryGetValue(iIndex, out pKeyVal);<font></font>
        if (pKeyVal == null) pDistribution.Add(iIndex, pKeyVal = new DataCont());<font></font>
        pKeyVal.Counter++;<font></font>
        pKeyVal.SumSrc += dTrendVal;<font></font>
      }<font></font>
      //   <font></font>
      double dSumP = 0;<font></font>
      foreach (KeyValuePair&lt;int, DataCont&gt; dataValue in pDistribution)<font></font>
      {<font></font>
        dataValue.Value.SumSrc /= dataValue.Value.Counter;<font></font>
        dSumP += (double)dataValue.Value.Counter / (double)pTrend.Length;<font></font>
        dataValue.Value.ValueP = dSumP;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //    ,   <font></font>
    public double[] RecalcTrend(double[] pTrend, double[] pNewTrend = null)<font></font>
    {<font></font>
      if (pNewTrend == null) pNewTrend = new double[pTrend.Length];<font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        pNewTrend[t] = RecalcTrend(pTrend[t]);<font></font>
      }<font></font>
      return pNewTrend;<font></font>
    }<font></font>
<font></font>
    //    ,   <font></font>
    public double RecalcTrend(double dTrendVal)<font></font>
    {<font></font>
      int iIndex = (int)(((dTrendVal - dAreaMin) / (dAreaMax - dAreaMin)) * m_iMaxAmountDistributionPoints);<font></font>
      if (iIndex &lt; 0) iIndex = pDistribution.Keys.Min();<font></font>
      if (iIndex &gt; pDistribution.Keys.Max()) iIndex = pDistribution.Keys.Max();<font></font>
      if (pDistribution.Keys.Contains(iIndex))<font></font>
      {<font></font>
        dTrendVal = pDistribution[iIndex].ValueP;<font></font>
      }<font></font>
      else<font></font>
      {<font></font>
        int iDnIndex = pDistribution.Keys.Max&lt;int&gt;(p =&gt; p &lt; iIndex ? p : 0);<font></font>
        double dDnVal = pDistribution[iDnIndex].ValueP;<font></font>
        int iUpIndex = pDistribution.Keys.Min&lt;int&gt;(p =&gt; p &gt; iIndex ? p : int.MaxValue);<font></font>
        double dUpVal = pDistribution[iUpIndex].ValueP;<font></font>
        dTrendVal = (dUpVal - dDnVal) * ((double)(iIndex - iDnIndex) / (double)(iUpIndex - iDnIndex)) + dDnVal;<font></font>
      }<font></font>
      return dTrendVal;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomDiscrimBase<font></font>
  {<font></font>
    public static int GetTermPoint(double[] pNeuronWeights,<font></font>
      double[] pData, int iDataCortegeLength = 0)<font></font>
    {<font></font>
      double dVal = pNeuronWeights[iDataCortegeLength]; //  <font></font>
      for (int i = 0; i &lt; iDataCortegeLength; i++) dVal += (pNeuronWeights[i] * pData[i]);<font></font>
      return Math.Sign(dVal);<font></font>
    }<font></font>
<font></font>
    public static int[] GetTermPoint(IList&lt;double[]&gt; pNeuroSurfaces,<font></font>
      double[] pData, int iDataCortegeLength = 0)<font></font>
    {<font></font>
      if (iDataCortegeLength &lt;= 0) iDataCortegeLength = pData.Length;<font></font>
      int[] pLogicData = new int[pNeuroSurfaces.Count];<font></font>
      for (int n = 0; n &lt; pNeuroSurfaces.Count; n++)<font></font>
      {<font></font>
        pLogicData[n] = GetTermPoint(pNeuroSurfaces[n], pData, iDataCortegeLength);<font></font>
      }<font></font>
      return pLogicData;<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///   <font></font>
    /// &lt;/summary&gt;<font></font>
    public virtual void CreateDiscrim(double[][] pSrcData, bool[] pDstData,<font></font>
      int iFromPos, int iToPos, int iDataCortegeLength, int iAmountLogicDiscrims,<font></font>
      int iLogicDiscrimsMaxTrainRestarts)<font></font>
    {<font></font>
      throw new MissingMethodException("  ");<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///  <font></font>
    ///           -1  +1<font></font>
    /// &lt;/summary&gt;<font></font>
    public virtual double GetPrognos(double[] pTermPointData, int iDataCortegeLength = -1)<font></font>
    {<font></font>
      throw new MissingMethodException("  ");<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///        <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomLogicDiscrim : RandomDiscrimBase<font></font>
  {<font></font>
    private IList&lt;double[]&gt; pLogicDiscrims = null;<font></font>
    public LogicFunc.Quine_McCluskey neuronLogic = null;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public RandomLogicDiscrim()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///   <font></font>
    /// &lt;/summary&gt;<font></font>
    public override void CreateDiscrim(double[][] pSrcArray, bool[] pTargetData,<font></font>
      int iFromPos, int iToPos, int iDataCortegeLength, int iAmountLogicDiscrims,<font></font>
      int iLogicDiscrimsMaxTrainRestarts)<font></font>
    {<font></font>
      Random RndFabric = new Random(Environment.TickCount);<font></font>
      //  <font></font>
      int iMaxCounter = 0;<font></font>
      //   <font></font>
      neuronLogic = null;<font></font>
      pLogicDiscrims = new List&lt;double[]&gt;();<font></font>
      do<font></font>
      {<font></font>
        //    <font></font>
        // -   ,  iAmountLogicDiscrims,   <font></font>
        while (pLogicDiscrims.Count &lt; iAmountLogicDiscrims)<font></font>
        {<font></font>
          double[] pNewSurface = new double[iDataCortegeLength + 1];<font></font>
          for (int i = 0; i &lt; iDataCortegeLength; i++)<font></font>
          {<font></font>
            //    <font></font>
            double dNormal = RndFabric.NextDouble() - 0.5;<font></font>
            //   ,    (0...1)<font></font>
            double dPoint = RndFabric.NextDouble();<font></font>
            //  <font></font>
            pNewSurface[i] = dNormal;<font></font>
            //  <font></font>
            pNewSurface[iDataCortegeLength] -= dNormal * dPoint;<font></font>
          }<font></font>
          pLogicDiscrims.Add(pNewSurface);<font></font>
        }<font></font>
        //  <font></font>
        ICollection&lt;byte[]&gt; TermInputUp = new LinkedList&lt;byte[]&gt;();<font></font>
        ICollection&lt;byte[]&gt; TermInputDn = new LinkedList&lt;byte[]&gt;();<font></font>
        for (int t = iFromPos; t &lt; iToPos; t++)<font></font>
        {<font></font>
          byte[] pSrcData = GetTermPoint(pLogicDiscrims, pSrcArray[t], iDataCortegeLength)<font></font>
            .Select(p =&gt; (byte)(p &gt; 0 ? 1 : 0)).ToArray();<font></font>
          if (pTargetData[t])<font></font>
            TermInputUp.Add(pSrcData);<font></font>
          else<font></font>
            TermInputDn.Add(pSrcData);<font></font>
        }<font></font>
        //  <font></font>
        neuronLogic = new LogicFunc.Quine_McCluskey();<font></font>
        neuronLogic.Start(TermInputUp, TermInputDn);<font></font>
        //   , . .<font></font>
        //   ,     <font></font>
        if ((iMaxCounter + 1) &lt; iLogicDiscrimsMaxTrainRestarts)<font></font>
        {<font></font>
          Dictionary&lt;int, int&gt; TermStars = new Dictionary&lt;int, int&gt;(iAmountLogicDiscrims);<font></font>
          for (int i = 0; i &lt; iAmountLogicDiscrims; i++) TermStars.Add(i, 0);<font></font>
          foreach (byte[] pTerm in neuronLogic.Result.Terms)<font></font>
          {<font></font>
            for (int i = 0; i &lt; iAmountLogicDiscrims; i++)<font></font>
            {<font></font>
              if (pTerm[i] != LogicFunc.LogicFunction.cStarSymb) TermStars[i]++;<font></font>
            }<font></font>
          }<font></font>
          foreach (byte[] pTerm in neuronLogic.ResultNeg.Terms)<font></font>
          {<font></font>
            for (int i = 0; i &lt; iAmountLogicDiscrims; i++)<font></font>
            {<font></font>
              if (pTerm[i] != LogicFunc.LogicFunction.cStarSymb) TermStars[i]++;<font></font>
            }<font></font>
          }<font></font>
          foreach (KeyValuePair&lt;int, int&gt; p in TermStars)<font></font>
          {<font></font>
            //    -   <font></font>
            if (p.Value &lt;= 0) pLogicDiscrims[p.Key] = null;<font></font>
          }<font></font>
          pLogicDiscrims = pLogicDiscrims.Where(p =&gt; p != null).ToList();<font></font>
        }<font></font>
      } while ((pLogicDiscrims.Count &lt; iAmountLogicDiscrims) &amp;&amp; (iMaxCounter++ &lt; iLogicDiscrimsMaxTrainRestarts));<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///  <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pTermPointData"&gt;&lt;/param&gt;<font></font>
    /// &lt;returns&gt;&lt;/returns&gt;<font></font>
    public override double GetPrognos(double[] pTermPointData, int iDataCortegeLength = -1)<font></font>
    {<font></font>
      if (iDataCortegeLength &lt;= 0) iDataCortegeLength = pTermPointData.Length;<font></font>
      byte[] pSrcData = GetTermPoint(pLogicDiscrims, pTermPointData, iDataCortegeLength).Select(p =&gt; (byte)(p &gt; 0 ? 1 : 0)).ToArray();<font></font>
      int iPrognos = 0;<font></font>
      iPrognos += (neuronLogic.Result.Calculate(pSrcData)    ? +1 : -1);<font></font>
      iPrognos += (neuronLogic.ResultNeg.Calculate(pSrcData) ? -1 : +1);<font></font>
      return (iPrognos / 2);<font></font>
    }<font></font>
  }<font></font>
  #endregion<font></font>
}<font></font>
<font></font>
namespace LogicFunc<font></font>
{<font></font>
  #region  <font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public abstract class LogicFunction<font></font>
  {<font></font>
    // "" <font></font>
    public const byte cStarSymb = 2;<font></font>
<font></font>
    //   <font></font>
    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;();<font></font>
    //  <font></font>
    public abstract bool Calculate(bool[] X);<font></font>
    //  <font></font>
    public abstract bool Calculate(char[] X);<font></font>
    //  <font></font>
    public abstract bool Calculate(byte[] X);<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///   <font></font>
  /// &lt;/summary&gt;<font></font>
  public class Dnf : LogicFunction<font></font>
  {<font></font>
    public static bool Calculate(byte[] X, byte[] term)<font></font>
    {<font></font>
      bool bResult = true;<font></font>
      for (int i = 0; i &lt; term.Length; i++)<font></font>
      {<font></font>
        if ((term[i] == cStarSymb) || (term[i] == X[i])) continue;<font></font>
        bResult = false;<font></font>
        break;<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(byte[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(char[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(bool[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///  <font></font>
  /// &lt;/summary&gt;<font></font>
  public class TreeFuncTerm<font></font>
  {<font></font>
    //    <font></font>
    public class TreeNodeEnd { }<font></font>
    //   <font></font>
    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd();<font></font>
<font></font>
    //<font></font>
    private readonly object[] rootNode = new object[3];<font></font>
    //      <font></font>
    private readonly bool IsNewTreeNodeEndMode = false;<font></font>
    // () <font></font>
    private int _rang = 0;<font></font>
    public int Rang<font></font>
    {<font></font>
      get { return _rang; }<font></font>
    }<font></font>
    //   <font></font>
    private int enumerationPos = 0;<font></font>
    private object[][] enumerationBuf;<font></font>
    //,     <font></font>
    private byte[] enumerationTerm;<font></font>
    public byte[] EnumerationTerm<font></font>
    {<font></font>
      get { return enumerationTerm; }<font></font>
    }<font></font>
    // ,    <font></font>
    private TreeNodeEnd enumerationNode;<font></font>
    public TreeNodeEnd EnumerationNode<font></font>
    {<font></font>
      get { return enumerationNode; }<font></font>
    }<font></font>
    //    <font></font>
    private UInt32 _count = 0;<font></font>
    public UInt32 Count<font></font>
    {<font></font>
      get { return _count; }<font></font>
    }<font></font>
<font></font>
    //<font></font>
    public TreeFuncTerm(bool bNewTreeNodeEndMode = false)<font></font>
    {<font></font>
      IsNewTreeNodeEndMode = bNewTreeNodeEndMode;<font></font>
      Clear();<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Clear()<font></font>
    {<font></font>
      _count = 0;<font></font>
      _rang = 0;<font></font>
      enumerationPos = 0;<font></font>
      enumerationBuf = null;<font></font>
      enumerationTerm = null;<font></font>
      enumerationNode = null;<font></font>
      rootNode[0] = rootNode[1] = rootNode[2] = null;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public TreeNodeEnd EnumerationInit()<font></font>
    {<font></font>
      enumerationPos = 0;<font></font>
      enumerationTerm = new byte[_rang];<font></font>
      enumerationTerm[0] = 0;<font></font>
      enumerationNode = null;<font></font>
      enumerationBuf = new object[_rang][];<font></font>
      enumerationBuf[0] = rootNode;<font></font>
      //   <font></font>
      return EnumerationNextNode();<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    public TreeNodeEnd EnumerationNextNode()<font></font>
    {<font></font>
      int iIsNext = (enumerationNode != null ? 1 : 0);<font></font>
      enumerationNode = null;<font></font>
      while ((enumerationNode == null) &amp;&amp; (enumerationPos &gt;= 0))<font></font>
      {<font></font>
        object pNextNode = null;<font></font>
        int iSymb = enumerationTerm[enumerationPos] + iIsNext;<font></font>
        for (object[] pNodes = enumerationBuf[enumerationPos]; iSymb &lt; 3; iSymb++)<font></font>
        {<font></font>
          if ((pNextNode = pNodes[iSymb]) != null) break;<font></font>
        }<font></font>
        if (pNextNode == null)<font></font>
        {<font></font>
          //   <font></font>
          enumerationPos--;<font></font>
          iIsNext = 1;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          enumerationTerm[enumerationPos] = (byte)iSymb;<font></font>
          if (pNextNode is TreeNodeEnd)<font></font>
          {<font></font>
            //  <font></font>
            enumerationNode = (TreeNodeEnd)pNextNode;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            //   <font></font>
            enumerationPos++;<font></font>
            enumerationBuf[enumerationPos] = (object[])pNextNode;<font></font>
            enumerationTerm[enumerationPos] = 0;<font></font>
            iIsNext = 0;<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      return enumerationNode;<font></font>
    }<font></font>
<font></font>
    //       <font></font>
    public TreeNodeEnd Add(byte[] term)<font></font>
    {<font></font>
      _rang = Math.Max(_rang, term.Length);<font></font>
      object[] pCurrNode = rootNode;<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      for (int i = 0; i &lt; iTermLength1; i++)<font></font>
      {<font></font>
        byte cSymb = term[i];<font></font>
        object pNextNode = pCurrNode[cSymb];<font></font>
        if (pNextNode == null)<font></font>
        {<font></font>
          pNextNode = new object[3];<font></font>
          pCurrNode[cSymb] = pNextNode;<font></font>
        }<font></font>
        pCurrNode = (object[])pNextNode;<font></font>
      }<font></font>
      object pNewNode = pCurrNode[term[iTermLength1]];<font></font>
      if (pNewNode == null)<font></font>
      {<font></font>
        pNewNode = (IsNewTreeNodeEndMode ? new TreeNodeEnd() : pCommonTreeNodeEnd);<font></font>
        pCurrNode[term[iTermLength1]] = pNewNode;<font></font>
        _count++;<font></font>
      }<font></font>
      return (TreeNodeEnd)pNewNode;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public TreeNodeEnd Remove(byte[] term)<font></font>
    {<font></font>
      object[] pCurrNode = rootNode;<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      for (int i = 0; i &lt; iTermLength1; i++)<font></font>
      {<font></font>
        pCurrNode = (object[])pCurrNode[term[i]];<font></font>
        if (pCurrNode == null) break;<font></font>
      }<font></font>
      TreeNodeEnd pRemovedNode = null;<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        //     <font></font>
        pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]];<font></font>
        if (pRemovedNode != null)<font></font>
        {<font></font>
          //    <font></font>
          pCurrNode[term[iTermLength1]] = null;<font></font>
          // - <font></font>
          _count--;<font></font>
        }<font></font>
      }<font></font>
      return pRemovedNode;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public void Remove(IEnumerable&lt;byte[]&gt; RemovedTerms)<font></font>
    {<font></font>
      if ((RemovedTerms == null) || (RemovedTerms.Count() == 0)) return;<font></font>
      foreach (byte[] x1 in RemovedTerms)<font></font>
      {<font></font>
        //-       Remove<font></font>
        //   IsContains<font></font>
        Remove(x1);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    public bool Contains(byte[] term)<font></font>
    {<font></font>
      object pCurrNode = rootNode;<font></font>
      for (int i = 0; i &lt; term.Length; i++)<font></font>
      {<font></font>
        pCurrNode = ((object[])pCurrNode)[term[i]];<font></font>
        if (pCurrNode == null) break;<font></font>
      }<font></font>
      return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd));<font></font>
    }<font></font>
<font></font>
    //    ,<font></font>
    //     <font></font>
    public bool IsCalculateTrue(byte[] term)<font></font>
    {<font></font>
      return IsCalculateTrue(rootNode, term, 0);<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    private static bool IsCalculateTrue(object[] pCurrNode,<font></font>
      byte[] term, int iStartPos)<font></font>
    {<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      while ((pCurrNode != null) &amp;&amp; (iStartPos &lt; iTermLength1))<font></font>
      {<font></font>
        byte cSymb = term[iStartPos++];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pCurrNode = (object[])pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if ((pCurrNode[0] != null) &amp;&amp; (pCurrNode[1] != null))<font></font>
          {<font></font>
            if (IsCalculateTrue((object[])pCurrNode[1], term, iStartPos)) return true;<font></font>
            pCurrNode = (object[])pCurrNode[0];<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            pCurrNode = (object[])(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      TreeNodeEnd pEndNode = null;<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        byte cSymb = term[iTermLength1];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pEndNode = (TreeNodeEnd)pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          pEndNode = (TreeNodeEnd)(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
        }<font></font>
      }<font></font>
      return (pEndNode != null);<font></font>
    }<font></font>
<font></font>
    //    ,<font></font>
    //     <font></font>
    public void GetAllCalculateTrueTerms(byte[] term,<font></font>
      ICollection&lt;TreeNodeEnd&gt; pAllCalculateTrueTermsList)<font></font>
    {<font></font>
      pAllCalculateTrueTermsList.Clear();<font></font>
      GetAllCalculateTrueTerms(rootNode, term, 0, pAllCalculateTrueTermsList);<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    private static void GetAllCalculateTrueTerms(object[] pCurrNode,<font></font>
      byte[] term, int iStartPos, ICollection&lt;TreeNodeEnd&gt; pAllCalculateTrueTermsList)<font></font>
    {<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      while ((pCurrNode != null) &amp;&amp; (iStartPos &lt; iTermLength1))<font></font>
      {<font></font>
        byte cSymb = term[iStartPos++];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pCurrNode = (object[])pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if ((pCurrNode[0] != null) &amp;&amp; (pCurrNode[1] != null))<font></font>
          {<font></font>
            GetAllCalculateTrueTerms((object[])pCurrNode[1], term, iStartPos,<font></font>
              pAllCalculateTrueTermsList);<font></font>
            pCurrNode = (object[])pCurrNode[0];<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            pCurrNode = (object[])(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        byte cSymb = term[iTermLength1];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          TreeNodeEnd pEndNode = (TreeNodeEnd)pCurrNode[cSymb];<font></font>
          if (pEndNode != null) pAllCalculateTrueTermsList.Add(pEndNode);<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (pCurrNode[0] != null) pAllCalculateTrueTermsList.Add((TreeNodeEnd)pCurrNode[0]);<font></font>
          if (pCurrNode[1] != null) pAllCalculateTrueTermsList.Add((TreeNodeEnd)pCurrNode[1]);<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     ----<font></font>
  /// &lt;/summary&gt;<font></font>
  public class Quine_McCluskey<font></font>
  {<font></font>
    //   <font></font>
    private readonly Dnf _result = new Dnf();<font></font>
    public Dnf Result<font></font>
    {<font></font>
      get { return _result; }<font></font>
    }<font></font>
    //   <font></font>
    private readonly Dnf _resultNeg = new Dnf();<font></font>
    public Dnf ResultNeg<font></font>
    {<font></font>
      get { return _resultNeg; }<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    private static void Skleivanie(TreeFuncTerm X1Tree,<font></font>
      TreeFuncTerm X2Tree, TreeFuncTerm NegativTree,<font></font>
      TreeFuncTerm InpNegTerms, TreeFuncTerm AllOutTerms)<font></font>
    {<font></font>
      bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp;<font></font>
        (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count != 0));<font></font>
      for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit();<font></font>
        x1 != null; x1 = X1Tree.EnumerationNextNode())<font></font>
      {<font></font>
        bool bIsSkleiv = false;<font></font>
        byte[] pCurrTerm = X1Tree.EnumerationTerm;<font></font>
        for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++)<font></font>
        {<font></font>
          byte cSymbSav = pCurrTerm[iPos];<font></font>
          if (cSymbSav == LogicFunction.cStarSymb) continue;<font></font>
          //     <font></font>
          pCurrTerm[iPos] = (byte)(1 - cSymbSav);<font></font>
          if (X1Tree.Contains(pCurrTerm))<font></font>
          {<font></font>
            bIsSkleiv = true;<font></font>
            if (cSymbSav == 0)<font></font>
            {<font></font>
              pCurrTerm[iPos] = LogicFunction.cStarSymb; // <font></font>
              X2Tree.Add(pCurrTerm);<font></font>
            }<font></font>
          }<font></font>
          //    ,    NegativTree<font></font>
          else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm))<font></font>
          {<font></font>
            pCurrTerm[iPos] = LogicFunction.cStarSymb; // <font></font>
            if (!InpNegTerms.IsCalculateTrue(pCurrTerm))<font></font>
            {<font></font>
              bIsSkleiv = true;<font></font>
              X2Tree.Add(pCurrTerm);<font></font>
            }<font></font>
          }<font></font>
          pCurrTerm[iPos] = cSymbSav;<font></font>
        }<font></font>
        //    ,      <font></font>
        if (!bIsSkleiv &amp;&amp; (AllOutTerms != null)) AllOutTerms.Add(pCurrTerm);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    //      <font></font>
    private static void DeleteDublicatingTerms(<font></font>
      IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree)<font></font>
    {<font></font>
      OutX2Tree.Clear();<font></font>
      foreach (byte[] x1 in InX1) OutX2Tree.Add(x1);<font></font>
    }<font></font>
<font></font>
    //           .<font></font>
    // ,   ,       (),<font></font>
    //    ‚Äú ‚Äì ‚Äù<font></font>
    // (http://www.studfiles.ru/preview/5175815/page:4/)<font></font>
    private static void ReduceRedundancyTerms(TreeFuncTerm AllOutputTerms,<font></font>
      TreeFuncTerm AllInputTerms, ICollection&lt;byte[]&gt; ResultTerms)<font></font>
    {<font></font>
      //  <font></font>
      ResultTerms.Clear();<font></font>
      //        ,   <font></font>
      Dictionary&lt;byte[], HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;&gt; Outputs2Inputs =<font></font>
        new Dictionary&lt;byte[], HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;&gt;();<font></font>
      //        ,   <font></font>
      Dictionary&lt;TreeFuncTerm.TreeNodeEnd, HashSet&lt;byte[]&gt;&gt; Inputs2Outputs =<font></font>
        new Dictionary&lt;TreeFuncTerm.TreeNodeEnd, HashSet&lt;byte[]&gt;&gt;();<font></font>
      //      <font></font>
      for (TreeFuncTerm.TreeNodeEnd pNode = AllOutputTerms.EnumerationInit();<font></font>
        pNode != null; pNode = AllOutputTerms.EnumerationNextNode())<font></font>
      {<font></font>
        byte[] outTerm = (byte[])AllOutputTerms.EnumerationTerm.Clone();<font></font>
        //  ,      term<font></font>
        HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt; InpTermsLst = new HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;();<font></font>
        AllInputTerms.GetAllCalculateTrueTerms(outTerm, InpTermsLst);<font></font>
        Outputs2Inputs.Add(outTerm, InpTermsLst);<font></font>
        foreach (TreeFuncTerm.TreeNodeEnd inputTerm in InpTermsLst)<font></font>
        {<font></font>
          if (!Inputs2Outputs.ContainsKey(inputTerm)) Inputs2Outputs.Add(inputTerm, new HashSet&lt;byte[]&gt;());<font></font>
          Inputs2Outputs[inputTerm].Add(outTerm);<font></font>
        }<font></font>
      }<font></font>
      //      -   <font></font>
      Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value);<font></font>
      //   ,   -   <font></font>
      while (Inputs2Outputs.Count &gt; 0)<font></font>
      {<font></font>
        byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First();<font></font>
        ResultTerms.Add(outTerm);<font></font>
        foreach (TreeFuncTerm.TreeNodeEnd inTerm in Outputs2Inputs[outTerm].ToArray())<font></font>
        {<font></font>
          foreach (byte[] outTerm2Del in Inputs2Outputs[inTerm]) Outputs2Inputs[outTerm2Del].Remove(inTerm);<font></font>
          Inputs2Outputs.Remove(inTerm);<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    public static void LogicFuncMinimize(<font></font>
      IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos,<font></font>
      IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg)<font></font>
    {<font></font>
      TreeFuncTerm InpPosTerms = new TreeFuncTerm(true);<font></font>
      DeleteDublicatingTerms(PositivTerms, InpPosTerms);<font></font>
<font></font>
      int iTotalLevels = InpPosTerms.Rang;<font></font>
      if (iTotalLevels &lt;= 0) return;<font></font>
<font></font>
      TreeFuncTerm OutPosTerms = new TreeFuncTerm();<font></font>
      TreeFuncTerm OutNegTerms = null;<font></font>
<font></font>
      TreeFuncTerm InpNegTerms = null;<font></font>
      if ((NegativTerms != null) &amp;&amp; (NegativTerms.Count() != 0))<font></font>
      {<font></font>
        InpNegTerms = new TreeFuncTerm(true);<font></font>
        DeleteDublicatingTerms(NegativTerms, InpNegTerms);<font></font>
        OutNegTerms = new TreeFuncTerm();<font></font>
<font></font>
        //        <font></font>
        for (TreeFuncTerm.TreeNodeEnd pNode = InpPosTerms.EnumerationInit();<font></font>
          pNode != null; pNode = InpPosTerms.EnumerationNextNode())<font></font>
        {<font></font>
          if (!InpNegTerms.Contains(InpPosTerms.EnumerationTerm)) continue;<font></font>
          // -    X1   NegativTerms<font></font>
          int iPos_Count = PositivTerms.Count(p =&gt; Enumerable.SequenceEqual(p, InpPosTerms.EnumerationTerm));<font></font>
          int iNeg_Count = NegativTerms.Count(p =&gt; Enumerable.SequenceEqual(p, InpPosTerms.EnumerationTerm));<font></font>
          if (iPos_Count &gt; iNeg_Count)<font></font>
          {<font></font>
            InpNegTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
          else if (iPos_Count &lt; iNeg_Count)<font></font>
          {<font></font>
            InpPosTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
          else //if (iX1_Count == iNeg_Count)<font></font>
          {<font></font>
            InpPosTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
            InpNegTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
<font></font>
      // <font></font>
      TreeFuncTerm X1PositivTree = InpPosTerms;<font></font>
      TreeFuncTerm X1NegativTree = InpNegTerms;<font></font>
<font></font>
      int iLevelCounter = 0;<font></font>
      //       <font></font>
      while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels))<font></font>
      {<font></font>
        TreeFuncTerm X2PositivTree = new TreeFuncTerm();<font></font>
        Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, OutPosTerms);<font></font>
<font></font>
        if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0))<font></font>
        {<font></font>
          TreeFuncTerm X2NegativTree = new TreeFuncTerm();<font></font>
          Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, OutNegTerms);<font></font>
<font></font>
          //  <font></font>
          if (iLevelCounter &gt; 0) X1NegativTree.Clear();<font></font>
<font></font>
          X1NegativTree = X2NegativTree;<font></font>
        }<font></font>
<font></font>
        //  <font></font>
        if (iLevelCounter &gt; 0) X1PositivTree.Clear();<font></font>
<font></font>
        X1PositivTree = X2PositivTree;<font></font>
<font></font>
        iLevelCounter++;<font></font>
<font></font>
        GC.Collect();<font></font>
      }<font></font>
<font></font>
      if (OutPosTerms.Count &gt; 0)<font></font>
      {<font></font>
        // ,     cStarSymb<font></font>
        OutPosTerms.Remove(Enumerable.Repeat(LogicFunction.cStarSymb, iTotalLevels).ToArray());<font></font>
      }<font></font>
      //   <font></font>
      ReduceRedundancyTerms(OutPosTerms, InpPosTerms, OutPos);<font></font>
<font></font>
      if ((OutNeg != null) &amp;&amp; (OutNegTerms != null))<font></font>
      {<font></font>
        if (OutNegTerms.Count &gt; 0)<font></font>
        {<font></font>
          // ,     cStarSymb<font></font>
          OutNegTerms.Remove(Enumerable.Repeat(LogicFunction.cStarSymb, iTotalLevels).ToArray());<font></font>
        }<font></font>
        //   <font></font>
        ReduceRedundancyTerms(OutNegTerms, InpNegTerms, OutNeg);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;byte[]&gt; TermsInput)<font></font>
    {<font></font>
      LogicFuncMinimize(TermsInput, _result.Terms, null, null);<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms)<font></font>
    {<font></font>
      LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms);<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;char[]&gt; TermsInput)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()),<font></font>
          NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;bool[]&gt; TermsInput)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()),<font></font>
          NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()));<font></font>
    }<font></font>
  }<font></font>
  #endregion<font></font>
}</code></pre></div>
                    </div><br>
<p>     -            ,   .       ,      ,     .            <i>t</i>   <i>N</i>    X(t-j) (j=1,2,‚Ä¶,<i>N</i>),         Sign(X(t)-X(t-1)).       ,          .        , . .   ,         .    ,       Sign(X(t)-X(t-1))  .        ,   ,  -               , . . -  .</p><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">   C#        (  )</b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">    public static void TestRandomNeuralNetwork()<font></font>
    {<font></font>
      //:   <font></font>
      const int iTrendSize = 2000;<font></font>
      //:   <font></font>
      const int iTestTrendSize = 1000;<font></font>
      //:   <font></font>
      const int iWindowSize = 10;<font></font>
      //   <font></font>
      const int iOmega = 100;<font></font>
      //-   <font></font>
      const int iHarmonics = 5;<font></font>
      //    <font></font>
      const int iMinAmpl = 50;<font></font>
      //    <font></font>
      const int iMaxAmpl = 100;<font></font>
      //  /<font></font>
      const double dNoise2SignalRatio = 0;<font></font>
      //:   <font></font>
      const int iAmountLogicDiscrims = 20;<font></font>
      //:  -    <font></font>
      const int iMaxAmountDistributionPoints = 1000;<font></font>
      //:  -    <font></font>
      const int iLogicDiscrimsMaxTrainRestarts = 1;<font></font>
<font></font>
      //   <font></font>
      int iPrepTrendLength = iTrendSize - iTestTrendSize;<font></font>
      double[] pTrend = new double[iTrendSize];<font></font>
      // -<font></font>
      //for (int t = 0; t &lt; iTrendSize; t++) pTrend[t] = Math.Sin((t * Math.PI) / iOmega) + 200;<font></font>
      //  <font></font>
      int[] pFreq = new int[iHarmonics];<font></font>
      int[] pPhase = new int[iHarmonics];<font></font>
      double[] pAmpl = new double[iHarmonics];<font></font>
      //  . <font></font>
      Random RndFabric = new Random(Environment.TickCount);<font></font>
      for (int h = 0; h &lt; iHarmonics; h++)<font></font>
      {<font></font>
        pFreq[h] = RndFabric.Next(iOmega/*iPrepTrendLength*/) + 1;<font></font>
        pPhase[h] = RndFabric.Next(iPrepTrendLength);<font></font>
        pAmpl[h] = RndFabric.NextDouble();<font></font>
      }<font></font>
      double iMinValue = double.MaxValue, iMaxValue = 0;<font></font>
      for (int t = 0; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        double dValue = 0; //iMinAmpl + ((iMaxAmpl - iMinAmpl) * RndFabric.NextDouble());<font></font>
        for (int h = 0; h &lt; iHarmonics; h++)<font></font>
        {<font></font>
          dValue += ((pAmpl[h] * (iMaxAmpl - iMinAmpl)) + iMinAmpl) * Math.Sin(((t + pPhase[h]) * Math.PI) / pFreq[h]);<font></font>
        }<font></font>
        pTrend[t] = dValue;<font></font>
        iMinValue = Math.Min(iMinValue, dValue);<font></font>
        iMaxValue = Math.Max(iMaxValue, dValue);<font></font>
      }<font></font>
      // <font></font>
      if (dNoise2SignalRatio &gt; 0)<font></font>
      {<font></font>
        double dNoiseAmp = (iMaxValue - iMinValue) * dNoise2SignalRatio;<font></font>
        for (int t = 0; t &lt; iTrendSize; t++)<font></font>
        {<font></font>
          pTrend[t] += dNoiseAmp * 2.0 * (RndFabric.NextDouble() - 0.5);<font></font>
          iMinValue = Math.Min(iMinValue, pTrend[t]);<font></font>
        }<font></font>
      }<font></font>
      // ,     <font></font>
      if (iMinValue &lt; 0)<font></font>
      {<font></font>
        for (int t = 0; t &lt; iTrendSize; t++) pTrend[t] -= iMinValue;<font></font>
      }<font></font>
      //  <font></font>
      double[][] pSourceTrendData = new double[iTrendSize][];<font></font>
      bool[] pTargetFeature = new bool[iTrendSize];<font></font>
      // <font></font>
      for (int t = iWindowSize; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        // <font></font>
        double[] pNormData = new double[iWindowSize];<font></font>
        for (int i = 0; i &lt; iWindowSize; i++) pNormData[i] = pTrend[t - iWindowSize + i];<font></font>
        pSourceTrendData[t] = pNormData;<font></font>
        //  <font></font>
        pTargetFeature[t] = (pTrend[t] &gt;= pTrend[t - 1]);<font></font>
      }<font></font>
      DateTime dtStartDt = DateTime.Now;<font></font>
      RndNeuroNet.RandomNeuralNetwork randomNeuralNetwork = new RndNeuroNet.RandomNeuralNetwork();<font></font>
      randomNeuralNetwork.CreateNetwork(pSourceTrendData, pTargetFeature, iWindowSize, iPrepTrendLength, iWindowSize, iAmountLogicDiscrims,<font></font>
        //iClustersAmount, iClustersRestart,<font></font>
        iLogicDiscrimsMaxTrainRestarts, iMaxAmountDistributionPoints);<font></font>
      //  <font></font>
      TimeSpan tsTime = (DateTime.Now - dtStartDt);<font></font>
      //     <font></font>
      int iUpGapCounterTrain = 0, iDnGapCounterTrain = 0, iSuccessCounterTrain = 0, iErrorCounterTrain = 0, iIgnoreCounterTrain = 0;<font></font>
      for (int t = iWindowSize; t &lt; iPrepTrendLength; t++)<font></font>
      {<font></font>
        double dPrognos = randomNeuralNetwork.CalcResponce(pSourceTrendData[t]);<font></font>
        if (dPrognos == 0)<font></font>
        {<font></font>
          iIgnoreCounterTrain++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (((pTargetFeature[t] ? +1 : -1) * dPrognos) &gt; 0)<font></font>
          {<font></font>
            iSuccessCounterTrain++;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            iErrorCounterTrain++;<font></font>
          }<font></font>
        }<font></font>
        // GAP-   <font></font>
        if (pTargetFeature[t])<font></font>
        {<font></font>
          iUpGapCounterTrain++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          iDnGapCounterTrain++;<font></font>
        }<font></font>
      }<font></font>
      //     <font></font>
      int iUpGapCounterTest = 0, iDnGapCounterTest = 0, iSuccessCounterTest = 0, iErrorCounterTest = 0, iIgnoreCounterTest = 0;<font></font>
      for (int t = iPrepTrendLength; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        double dPrognos = randomNeuralNetwork.CalcResponce(pSourceTrendData[t]);<font></font>
        if (dPrognos == 0)<font></font>
        {<font></font>
          iIgnoreCounterTest++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (((pTargetFeature[t] ? +1 : -1) * dPrognos) &gt; 0)<font></font>
          {<font></font>
            iSuccessCounterTest++;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            iErrorCounterTest++;<font></font>
          }<font></font>
        }<font></font>
        // GAP-   <font></font>
        if (pTargetFeature[t])<font></font>
        {<font></font>
          iUpGapCounterTest++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          iDnGapCounterTest++;<font></font>
        }<font></font>
      }<font></font>
      //<font></font>
      Console.WriteLine("-      = " + iUpGapCounterTrain + Environment.NewLine +<font></font>
                      "-      = " + iDnGapCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iSuccessCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iErrorCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iIgnoreCounterTrain + Environment.NewLine +<font></font>
                      "-      = " + iUpGapCounterTest + Environment.NewLine +<font></font>
                      "-      = " + iDnGapCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iSuccessCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iErrorCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iIgnoreCounterTest + Environment.NewLine +<font></font>
                      "  = " + (int)tsTime.TotalMinutes + " . " + tsTime.Seconds + " ."<font></font>
      );<font></font>
      Console.WriteLine("Press Enter to exit ...");<font></font>
      Console.ReadLine();<font></font>
    }</code></pre></div>
                    </div><br>
<p>     ,  ,               .     ,   ,   :</p><br>
<ul>
<li>    ;</li>
<li>            ;</li>
<li>    , . .        ,  ¬´  - ¬ª.</li>
</ul><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Nachteil des NS ist es notwendig, seine hohen Anforderungen an die Menge des verf√ºgbaren Arbeitsspeichers und den erheblichen Zeitaufwand f√ºr das Training zu beachten. </font><font style="vertical-align: inherit;">Ihr Hauptverbraucher ist der Algorithmus zum Minimieren logischer Funktionen durch das Quine-Mac'Klaski-Verfahren, d. H. Die dritte Ausgabeschicht. </font><font style="vertical-align: inherit;">Es besteht jedoch die M√∂glichkeit, diesen Nachteil durch Kaskadierung mehrerer logischer Funktionen etwas abzumildern. </font><font style="vertical-align: inherit;">Im √úbrigen hat sich dieser NS als zuverl√§ssiges Werkzeug zur Vorhersage und Klassifizierung von Bin√§rdaten etabliert.</font></font></p></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500422/index.html">Visual Debugger f√ºr Jupyter</a></li>
<li><a href="../de500424/index.html">Verz√∂gerte Verwendung der Direktivenfunktionalit√§t in Angular</a></li>
<li><a href="../de500426/index.html">Python, Pandas und das L√∂sen von drei Problemen aus der Excel-Welt</a></li>
<li><a href="../de500428/index.html">Wie kann man Pandas bei der Verarbeitung gro√üer Datenmengen helfen?</a></li>
<li><a href="../de500430/index.html">Wie ich nach Quarant√§ne gesucht habe</a></li>
<li><a href="../de500438/index.html">SFTP und FTPS</a></li>
<li><a href="../de500444/index.html">9 Python-Programmierkenntnisse, die Anf√§nger von erfahrenen unterscheiden</a></li>
<li><a href="../de500446/index.html">Ein paar Worte zu R2DBC und PostgreSQL</a></li>
<li><a href="../de500448/index.html">Prometheus: HTTP-√úberwachung √ºber den Blackbox-Exporter</a></li>
<li><a href="../de500450/index.html">Erstellen eines MIDI-Keyboards aus einem Synthesizer f√ºr alte Kinder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>