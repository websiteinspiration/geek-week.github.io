<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😋 👐🏾 ♋️ Kommen von binären neuronalen Netzen basierend auf zufälligen Neuronen und logischen Funktionen 🛍️ 😦 🤱🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heutzutage sind unter vielen Algorithmen für maschinelles Lernen neuronale Netze (NS) weit verbreitet. Der Hauptvorteil von NS gegenüber anderen Metho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kommen von binären neuronalen Netzen basierend auf zufälligen Neuronen und logischen Funktionen</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500436/"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Heutzutage sind unter vielen Algorithmen für maschinelles Lernen neuronale Netze (NS) weit verbreitet. </font><font style="vertical-align: inherit;">Der Hauptvorteil von NS gegenüber anderen Methoden des maschinellen Lernens besteht darin, dass sie ziemlich tiefe, oft nicht offensichtliche Muster in den Daten aufdecken können. </font><font style="vertical-align: inherit;">Das klassische Paradigma unter NSs sind vollständig verbundene Netzwerke mit Rückwärtsausbreitung von Fehlern.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollständig verbundene NS mit Rückwärtsausbreitung von Fehlern haben viele Vorteile, darunter vor allem die relativ hohe Genauigkeit der Klassifizierung von Quelldaten auf der Grundlage des „starken“ mathematischen Apparats, der ihrer Funktionsweise zugrunde liegt. Andererseits gibt es jedoch Nachteile, von denen der größte die Tendenz zur Umschulung ist, wenn sich der NS an die lokalen Eigenschaften der Trainingsprobe anpasst und seine Verallgemeinerungsfähigkeit verliert. Dies verringert die Effizienz und Zweckmäßigkeit ihrer Verwendung als Mittel zur Klassifizierung oder Prognose außerhalb des Trainingssatzes für beliebige Daten.</font></font></p><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel wird vorgeschlagen, eine Variante eines vollständig verbundenen binären NS (binäre Variablen dienen als Zielwert des Netzwerks) mit einer logischen Funktion am Ausgang zu betrachten, bei der es keinen Mechanismus für die Rückausbreitung des Fehlers gibt. </font><font style="vertical-align: inherit;">In der Trainingsphase wird bei der Bildung der Gewichtskoeffizienten von Neuronen anstelle mehrerer iterativer Berechnungen für jede Trainingsprobe eine einzelne zufällige Auswahl von Koeffizienten durchgeführt, wodurch die Trainingszeit erheblich verkürzt wird. </font><font style="vertical-align: inherit;">Ein weiterer grundlegender Vorteil dieses Ansatzes ist das Fehlen eines Problems bei der Umschulung des Netzwerks.</font></font></p><a name="habracut"></a><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Abb. </font><font style="vertical-align: inherit;">Das Blockdiagramm eines binären zufälligen logischen neuronalen Netzwerks ist gegeben.</font></font></p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/lo/4z/o7/lo4zo7-llf0bqivhmyg7nlzlqha.png"></div><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der binäre Zufalls-NS besteht strukturell aus drei aufeinanderfolgenden Schichten, die nummeriert sind, wenn Informationen von Eingabe zu Ausgabe übertragen werden:</font></font></p><br>
<ol>
<li> :  ;</li>
<li> :  ;</li>
<li> :    .</li>
</ol><br>
<p>     .</p><br>
<p>           ,             0  1.             ,           ,    .</p><br>
<p><strong>:</strong>    <strong></strong>     <strong>f()</strong>,     <strong>s=F(x)</strong>     <strong>(0,1)</strong>,   <strong>F(x)</strong>       <strong></strong>, . . <strong>f()=</strong><i><strong>d</strong></i><strong>F(x)/</strong><i><strong>d</strong></i><strong>x</strong>.</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/6y/1z/wm/6y1zwmjxemx9i0bi7t-fiqufxwg.png"></div><br>
<p>,      <strong>X</strong>     <strong>S</strong>,           <strong>(0,1)</strong>        .  ,   <strong>X</strong>,      <i>N</i>- ,     <i>N</i>- ,         <i>N</i>-  ,    .          ,   ,     .</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/yv/vm/fi/yvvmfiei947k9zklv6rwbizq478.png" width="300" height="300"></div><br>
<p>   ,  ,    <strong>F(x)</strong>      X<i><sub>i</sub></i> (<i>i</i>=1,2,…,<i>N</i>)   .               <strong>F</strong><i><strong><sub>i</sub></strong></i><strong>(x)</strong>,        <i>i</i>-   .              .                  ,  :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/4p/f7/am/4pf7amgmjc2dhk9_krzur3nbihq.png" width="163" height="42"></div><br>
<p>  ,       <i>N</i>        <strong>X.</strong>      : <i>a</i> – ; <i>x</i>0 –  ,     .</p><br>
<p>   ,    <strong>S</strong>       .       <i>N</i>-  ,     <strong>W</strong>={w<sub>0</sub>, w<sub>1</sub>, w<sub>2</sub>, w<sub>3</sub>, …, w<sub>N</sub>} ,     <strong>S</strong>={s<sub>1</sub>, s<sub>2</sub>, s<sub>3</sub>, …, s<sub>N</sub>},  ,  :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/-e/yc/bt/-eycbt39ktvfev9ezwg2xch8g3g.png" width="146" height="64"></div><br>
<p>,  ,    ,                  .        .</p><br>
<p>  -   ,  ,     <strong>W</strong>    :</p><br>
<p><strong> N-       ,    </strong></p><br>
<p>          .          (  ),       .     ,            .</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/cy/5a/vh/cy5avhzuvd_v2kmvmpno6px8iju.png" width="300" height="300"></div><br>
<p>        <strong>W</strong>    ,  ,     .     <i>N</i>-         ,   : a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, …, a<sub>N</sub>,    0&lt;a<sub>i</sub>&lt;1. ,   ,   :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/rn/ds/en/rndsen_ctpdfc2gcequujer4_eo.png" width="184" height="61"></div><br>
<p> n<sub>1</sub>, n<sub>2</sub>, n<sub>3</sub>, …, n<sub>N</sub> –     ,         <strong>S</strong> (        ,         ); w<sub>0</sub> –    ,  1.          ,           .</p><br>
<p>,         , . .    .      -,      .                 .</p><br>
<p>       :</p><br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/zu/n-/uj/zun-ujbmiuzil8h7dge0ymyafxu.png" width="313" height="26"></div><br>
<p>   <i>M</i>          <i>M</i> ,       ,    ,    Sign,   ()   .        ,      .</p><br>
<p>            ,     ,  ,  ,     .           ,             ,    ,     ,      .</p><br>
<p>             -’      (<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://habr.com/ru/post/424517</a>).      ,     ,        .    ,              «» «*».                .</p><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">   C#              (  )</b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">using System;<font></font>
using System.Collections.Generic;<font></font>
using System.Linq;<font></font>
<font></font>
namespace RndNeuroNet<font></font>
{<font></font>
  #region   <font></font>
  /// &lt;summary&gt;<font></font>
  ///       <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomNeuralNetwork<font></font>
  {<font></font>
    private DistributionFunc[] pDistributionDataFuncs;<font></font>
    private RandomDiscrimBase pNeuroLogicDiscrim;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public RandomNeuralNetwork()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///    <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pSourceTermsData"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="pTargetFeature"&gt;&lt;/param&gt;<font></font>
    public void CreateNetwork(double[][] pSourceData, bool[] pTargetFeature,<font></font>
      int iFromPos, int iTargetPos, int iWindowSize,<font></font>
      int iAmountLogicDiscrims, int iLogicDiscrimsMaxTrainRestarts = 1,<font></font>
      int iMaxAmountDistributionPoints = 1000, bool bIsNorming = true)<font></font>
    {<font></font>
      //  <font></font>
      double[][] pSrcArray = new double[iTargetPos - iFromPos][];<font></font>
      bool[] pDstArray = new bool[iTargetPos - iFromPos];<font></font>
      for (int i = 0, t = iFromPos; t &lt; iTargetPos; t++, i++)<font></font>
      {<font></font>
        //  <font></font>
        pSrcArray[i] = (bIsNorming ? NormingE(pSourceData[t], iWindowSize, iWindowSize) : pSourceData[t]);<font></font>
        pDstArray[i] = pTargetFeature[t];<font></font>
      }<font></font>
      //    <font></font>
      pDistributionDataFuncs = new DistributionFunc[iWindowSize];<font></font>
      for (int i = 0; i &lt; iWindowSize; i++)<font></font>
      {<font></font>
        //   <font></font>
        double[] pTrend2Recalc = pSrcArray.Select(p =&gt; p != null ? p[i] : 0).ToArray();<font></font>
        // <font></font>
        pDistributionDataFuncs[i] = new DistributionFunc(pTrend2Recalc, iMaxAmountDistributionPoints);<font></font>
        //     <font></font>
        pTrend2Recalc = pDistributionDataFuncs[i].RecalcTrend(pTrend2Recalc);<font></font>
        //    <font></font>
        for (int t = 0; t &lt; pSrcArray.Length; t++) pSrcArray[t][i] = pTrend2Recalc[t];<font></font>
      }<font></font>
      // <font></font>
      pNeuroLogicDiscrim = (RandomDiscrimBase)new RandomLogicDiscrim();<font></font>
      pNeuroLogicDiscrim.CreateDiscrim(pSrcArray, pDstArray, 0, pSrcArray.Length,<font></font>
        iWindowSize, iAmountLogicDiscrims, iLogicDiscrimsMaxTrainRestarts);<font></font>
    }<font></font>
<font></font>
    public double CalcResponce(double[] pSourceData, int iWindowSize = 0, bool bIsNorming = true)<font></font>
    {<font></font>
      // <font></font>
      if (iWindowSize &lt;= 0) iWindowSize = pSourceData.Length;<font></font>
      //  <font></font>
      pSourceData = (bIsNorming ? NormingE(pSourceData, iWindowSize, iWindowSize) : pSourceData);<font></font>
      //  <font></font>
      for (int i = 0; i &lt; iWindowSize; i++)<font></font>
      {<font></font>
        pSourceData[i] = pDistributionDataFuncs[i].RecalcTrend(pSourceData[i]);<font></font>
      }<font></font>
      //  <font></font>
      return pNeuroLogicDiscrim.GetPrognos(pSourceData, iWindowSize);<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///     <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pTrend"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="iTargetPosition"&gt;&lt;/param&gt;<font></font>
    /// &lt;param name="iVectorSize"&gt;&lt;/param&gt;<font></font>
    /// &lt;returns&gt;&lt;/returns&gt;<font></font>
    public static double[] NormingE(double[] pTrend, int iTargetPosition,<font></font>
      int iVectorSize, double[] pResultVector = null, bool bIsMinusOffset = false)<font></font>
    {<font></font>
      if (pResultVector == null) pResultVector = new double[iVectorSize];<font></font>
      double dNorming = 0;<font></font>
      for (int i = 0, t = iTargetPosition - iVectorSize; i &lt; iVectorSize; i++, t++)<font></font>
      {<font></font>
        dNorming += pTrend[t];<font></font>
      }<font></font>
      dNorming /= iVectorSize;<font></font>
      double dOffset = (bIsMinusOffset ? 1 : 0);<font></font>
      for (int i = 0, t = iTargetPosition - iVectorSize; i &lt; iVectorSize; i++, t++)<font></font>
      {<font></font>
        pResultVector[i] = (pTrend[t] / dNorming) - dOffset;<font></font>
      }<font></font>
      return pResultVector;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public class DistributionFunc<font></font>
  {<font></font>
    private class DataCont<font></font>
    {<font></font>
      public int Counter;<font></font>
      public double SumSrc;<font></font>
      public double ValueP;<font></font>
    }<font></font>
<font></font>
    private readonly SortedDictionary&lt;int, DataCont&gt; pDistribution =<font></font>
      new SortedDictionary&lt;int, DataCont&gt;();<font></font>
    private int m_iMaxAmountDistributionPoints;<font></font>
    private double dAreaMin, dAreaMax;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public DistributionFunc()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public DistributionFunc(double[] pTrend, int iMaxAmountDistributionPoints = 1000)<font></font>
    {<font></font>
      CreateDistribution(pTrend, iMaxAmountDistributionPoints);<font></font>
    }<font></font>
<font></font>
    //  <font></font>
    public void CreateDistribution(double[] pTrend, int iMaxAmountDistributionPoints = 1000)<font></font>
    {<font></font>
      m_iMaxAmountDistributionPoints = iMaxAmountDistributionPoints;<font></font>
      dAreaMin = double.MaxValue; dAreaMax = 0;<font></font>
      //      <font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        double dTrendVal = pTrend[t];<font></font>
        if (dTrendVal == 0) continue;<font></font>
        dAreaMin = Math.Min(dAreaMin, dTrendVal);<font></font>
        dAreaMax = Math.Max(dAreaMax, dTrendVal);<font></font>
      }<font></font>
      //  <font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        double dTrendVal = pTrend[t];<font></font>
        if (dTrendVal == 0) continue;<font></font>
        int iIndex = (int)(((dTrendVal - dAreaMin) / (dAreaMax - dAreaMin)) * m_iMaxAmountDistributionPoints);<font></font>
        DataCont pKeyVal = null;<font></font>
        pDistribution.TryGetValue(iIndex, out pKeyVal);<font></font>
        if (pKeyVal == null) pDistribution.Add(iIndex, pKeyVal = new DataCont());<font></font>
        pKeyVal.Counter++;<font></font>
        pKeyVal.SumSrc += dTrendVal;<font></font>
      }<font></font>
      //   <font></font>
      double dSumP = 0;<font></font>
      foreach (KeyValuePair&lt;int, DataCont&gt; dataValue in pDistribution)<font></font>
      {<font></font>
        dataValue.Value.SumSrc /= dataValue.Value.Counter;<font></font>
        dSumP += (double)dataValue.Value.Counter / (double)pTrend.Length;<font></font>
        dataValue.Value.ValueP = dSumP;<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //    ,   <font></font>
    public double[] RecalcTrend(double[] pTrend, double[] pNewTrend = null)<font></font>
    {<font></font>
      if (pNewTrend == null) pNewTrend = new double[pTrend.Length];<font></font>
      for (int t = 0; t &lt; pTrend.Length; t++)<font></font>
      {<font></font>
        pNewTrend[t] = RecalcTrend(pTrend[t]);<font></font>
      }<font></font>
      return pNewTrend;<font></font>
    }<font></font>
<font></font>
    //    ,   <font></font>
    public double RecalcTrend(double dTrendVal)<font></font>
    {<font></font>
      int iIndex = (int)(((dTrendVal - dAreaMin) / (dAreaMax - dAreaMin)) * m_iMaxAmountDistributionPoints);<font></font>
      if (iIndex &lt; 0) iIndex = pDistribution.Keys.Min();<font></font>
      if (iIndex &gt; pDistribution.Keys.Max()) iIndex = pDistribution.Keys.Max();<font></font>
      if (pDistribution.Keys.Contains(iIndex))<font></font>
      {<font></font>
        dTrendVal = pDistribution[iIndex].ValueP;<font></font>
      }<font></font>
      else<font></font>
      {<font></font>
        int iDnIndex = pDistribution.Keys.Max&lt;int&gt;(p =&gt; p &lt; iIndex ? p : 0);<font></font>
        double dDnVal = pDistribution[iDnIndex].ValueP;<font></font>
        int iUpIndex = pDistribution.Keys.Min&lt;int&gt;(p =&gt; p &gt; iIndex ? p : int.MaxValue);<font></font>
        double dUpVal = pDistribution[iUpIndex].ValueP;<font></font>
        dTrendVal = (dUpVal - dDnVal) * ((double)(iIndex - iDnIndex) / (double)(iUpIndex - iDnIndex)) + dDnVal;<font></font>
      }<font></font>
      return dTrendVal;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomDiscrimBase<font></font>
  {<font></font>
    public static int GetTermPoint(double[] pNeuronWeights,<font></font>
      double[] pData, int iDataCortegeLength = 0)<font></font>
    {<font></font>
      double dVal = pNeuronWeights[iDataCortegeLength]; //  <font></font>
      for (int i = 0; i &lt; iDataCortegeLength; i++) dVal += (pNeuronWeights[i] * pData[i]);<font></font>
      return Math.Sign(dVal);<font></font>
    }<font></font>
<font></font>
    public static int[] GetTermPoint(IList&lt;double[]&gt; pNeuroSurfaces,<font></font>
      double[] pData, int iDataCortegeLength = 0)<font></font>
    {<font></font>
      if (iDataCortegeLength &lt;= 0) iDataCortegeLength = pData.Length;<font></font>
      int[] pLogicData = new int[pNeuroSurfaces.Count];<font></font>
      for (int n = 0; n &lt; pNeuroSurfaces.Count; n++)<font></font>
      {<font></font>
        pLogicData[n] = GetTermPoint(pNeuroSurfaces[n], pData, iDataCortegeLength);<font></font>
      }<font></font>
      return pLogicData;<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///   <font></font>
    /// &lt;/summary&gt;<font></font>
    public virtual void CreateDiscrim(double[][] pSrcData, bool[] pDstData,<font></font>
      int iFromPos, int iToPos, int iDataCortegeLength, int iAmountLogicDiscrims,<font></font>
      int iLogicDiscrimsMaxTrainRestarts)<font></font>
    {<font></font>
      throw new MissingMethodException("  ");<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///  <font></font>
    ///           -1  +1<font></font>
    /// &lt;/summary&gt;<font></font>
    public virtual double GetPrognos(double[] pTermPointData, int iDataCortegeLength = -1)<font></font>
    {<font></font>
      throw new MissingMethodException("  ");<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///        <font></font>
  /// &lt;/summary&gt;<font></font>
  public class RandomLogicDiscrim : RandomDiscrimBase<font></font>
  {<font></font>
    private IList&lt;double[]&gt; pLogicDiscrims = null;<font></font>
    public LogicFunc.Quine_McCluskey neuronLogic = null;<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    /// <font></font>
    /// &lt;/summary&gt;<font></font>
    public RandomLogicDiscrim()<font></font>
    {<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///   <font></font>
    /// &lt;/summary&gt;<font></font>
    public override void CreateDiscrim(double[][] pSrcArray, bool[] pTargetData,<font></font>
      int iFromPos, int iToPos, int iDataCortegeLength, int iAmountLogicDiscrims,<font></font>
      int iLogicDiscrimsMaxTrainRestarts)<font></font>
    {<font></font>
      Random RndFabric = new Random(Environment.TickCount);<font></font>
      //  <font></font>
      int iMaxCounter = 0;<font></font>
      //   <font></font>
      neuronLogic = null;<font></font>
      pLogicDiscrims = new List&lt;double[]&gt;();<font></font>
      do<font></font>
      {<font></font>
        //    <font></font>
        // -   ,  iAmountLogicDiscrims,   <font></font>
        while (pLogicDiscrims.Count &lt; iAmountLogicDiscrims)<font></font>
        {<font></font>
          double[] pNewSurface = new double[iDataCortegeLength + 1];<font></font>
          for (int i = 0; i &lt; iDataCortegeLength; i++)<font></font>
          {<font></font>
            //    <font></font>
            double dNormal = RndFabric.NextDouble() - 0.5;<font></font>
            //   ,    (0...1)<font></font>
            double dPoint = RndFabric.NextDouble();<font></font>
            //  <font></font>
            pNewSurface[i] = dNormal;<font></font>
            //  <font></font>
            pNewSurface[iDataCortegeLength] -= dNormal * dPoint;<font></font>
          }<font></font>
          pLogicDiscrims.Add(pNewSurface);<font></font>
        }<font></font>
        //  <font></font>
        ICollection&lt;byte[]&gt; TermInputUp = new LinkedList&lt;byte[]&gt;();<font></font>
        ICollection&lt;byte[]&gt; TermInputDn = new LinkedList&lt;byte[]&gt;();<font></font>
        for (int t = iFromPos; t &lt; iToPos; t++)<font></font>
        {<font></font>
          byte[] pSrcData = GetTermPoint(pLogicDiscrims, pSrcArray[t], iDataCortegeLength)<font></font>
            .Select(p =&gt; (byte)(p &gt; 0 ? 1 : 0)).ToArray();<font></font>
          if (pTargetData[t])<font></font>
            TermInputUp.Add(pSrcData);<font></font>
          else<font></font>
            TermInputDn.Add(pSrcData);<font></font>
        }<font></font>
        //  <font></font>
        neuronLogic = new LogicFunc.Quine_McCluskey();<font></font>
        neuronLogic.Start(TermInputUp, TermInputDn);<font></font>
        //   , . .<font></font>
        //   ,     <font></font>
        if ((iMaxCounter + 1) &lt; iLogicDiscrimsMaxTrainRestarts)<font></font>
        {<font></font>
          Dictionary&lt;int, int&gt; TermStars = new Dictionary&lt;int, int&gt;(iAmountLogicDiscrims);<font></font>
          for (int i = 0; i &lt; iAmountLogicDiscrims; i++) TermStars.Add(i, 0);<font></font>
          foreach (byte[] pTerm in neuronLogic.Result.Terms)<font></font>
          {<font></font>
            for (int i = 0; i &lt; iAmountLogicDiscrims; i++)<font></font>
            {<font></font>
              if (pTerm[i] != LogicFunc.LogicFunction.cStarSymb) TermStars[i]++;<font></font>
            }<font></font>
          }<font></font>
          foreach (byte[] pTerm in neuronLogic.ResultNeg.Terms)<font></font>
          {<font></font>
            for (int i = 0; i &lt; iAmountLogicDiscrims; i++)<font></font>
            {<font></font>
              if (pTerm[i] != LogicFunc.LogicFunction.cStarSymb) TermStars[i]++;<font></font>
            }<font></font>
          }<font></font>
          foreach (KeyValuePair&lt;int, int&gt; p in TermStars)<font></font>
          {<font></font>
            //    -   <font></font>
            if (p.Value &lt;= 0) pLogicDiscrims[p.Key] = null;<font></font>
          }<font></font>
          pLogicDiscrims = pLogicDiscrims.Where(p =&gt; p != null).ToList();<font></font>
        }<font></font>
      } while ((pLogicDiscrims.Count &lt; iAmountLogicDiscrims) &amp;&amp; (iMaxCounter++ &lt; iLogicDiscrimsMaxTrainRestarts));<font></font>
    }<font></font>
<font></font>
    /// &lt;summary&gt;<font></font>
    ///  <font></font>
    /// &lt;/summary&gt;<font></font>
    /// &lt;param name="pTermPointData"&gt;&lt;/param&gt;<font></font>
    /// &lt;returns&gt;&lt;/returns&gt;<font></font>
    public override double GetPrognos(double[] pTermPointData, int iDataCortegeLength = -1)<font></font>
    {<font></font>
      if (iDataCortegeLength &lt;= 0) iDataCortegeLength = pTermPointData.Length;<font></font>
      byte[] pSrcData = GetTermPoint(pLogicDiscrims, pTermPointData, iDataCortegeLength).Select(p =&gt; (byte)(p &gt; 0 ? 1 : 0)).ToArray();<font></font>
      int iPrognos = 0;<font></font>
      iPrognos += (neuronLogic.Result.Calculate(pSrcData)    ? +1 : -1);<font></font>
      iPrognos += (neuronLogic.ResultNeg.Calculate(pSrcData) ? -1 : +1);<font></font>
      return (iPrognos / 2);<font></font>
    }<font></font>
  }<font></font>
  #endregion<font></font>
}<font></font>
<font></font>
namespace LogicFunc<font></font>
{<font></font>
  #region  <font></font>
  /// &lt;summary&gt;<font></font>
  ///     <font></font>
  /// &lt;/summary&gt;<font></font>
  public abstract class LogicFunction<font></font>
  {<font></font>
    // "" <font></font>
    public const byte cStarSymb = 2;<font></font>
<font></font>
    //   <font></font>
    public readonly ICollection&lt;byte[]&gt; Terms = new LinkedList&lt;byte[]&gt;();<font></font>
    //  <font></font>
    public abstract bool Calculate(bool[] X);<font></font>
    //  <font></font>
    public abstract bool Calculate(char[] X);<font></font>
    //  <font></font>
    public abstract bool Calculate(byte[] X);<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///   <font></font>
  /// &lt;/summary&gt;<font></font>
  public class Dnf : LogicFunction<font></font>
  {<font></font>
    public static bool Calculate(byte[] X, byte[] term)<font></font>
    {<font></font>
      bool bResult = true;<font></font>
      for (int i = 0; i &lt; term.Length; i++)<font></font>
      {<font></font>
        if ((term[i] == cStarSymb) || (term[i] == X[i])) continue;<font></font>
        bResult = false;<font></font>
        break;<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(byte[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || (term[i] == X[i])) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(char[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || (term[i] == (byte)(X[i] == '0' ? 0 : 1))) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
<font></font>
    public override bool Calculate(bool[] X)<font></font>
    {<font></font>
      bool bResult = false;<font></font>
      foreach (byte[] term in Terms)<font></font>
      {<font></font>
        bool bTermVal = true;<font></font>
        for (int i = 0; i &lt; term.Length; i++)<font></font>
        {<font></font>
          if ((term[i] &gt;= cStarSymb) || ((term[i] != 0) == X[i])) continue;<font></font>
          bTermVal = false;<font></font>
          break;<font></font>
        }<font></font>
        //bResult |= bTermVal;<font></font>
        if (bTermVal)<font></font>
        {<font></font>
          bResult = true;<font></font>
          break;<font></font>
        }<font></font>
      }<font></font>
      return bResult;<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///  <font></font>
  /// &lt;/summary&gt;<font></font>
  public class TreeFuncTerm<font></font>
  {<font></font>
    //    <font></font>
    public class TreeNodeEnd { }<font></font>
    //   <font></font>
    private readonly TreeNodeEnd pCommonTreeNodeEnd = new TreeNodeEnd();<font></font>
<font></font>
    //<font></font>
    private readonly object[] rootNode = new object[3];<font></font>
    //      <font></font>
    private readonly bool IsNewTreeNodeEndMode = false;<font></font>
    // () <font></font>
    private int _rang = 0;<font></font>
    public int Rang<font></font>
    {<font></font>
      get { return _rang; }<font></font>
    }<font></font>
    //   <font></font>
    private int enumerationPos = 0;<font></font>
    private object[][] enumerationBuf;<font></font>
    //,     <font></font>
    private byte[] enumerationTerm;<font></font>
    public byte[] EnumerationTerm<font></font>
    {<font></font>
      get { return enumerationTerm; }<font></font>
    }<font></font>
    // ,    <font></font>
    private TreeNodeEnd enumerationNode;<font></font>
    public TreeNodeEnd EnumerationNode<font></font>
    {<font></font>
      get { return enumerationNode; }<font></font>
    }<font></font>
    //    <font></font>
    private UInt32 _count = 0;<font></font>
    public UInt32 Count<font></font>
    {<font></font>
      get { return _count; }<font></font>
    }<font></font>
<font></font>
    //<font></font>
    public TreeFuncTerm(bool bNewTreeNodeEndMode = false)<font></font>
    {<font></font>
      IsNewTreeNodeEndMode = bNewTreeNodeEndMode;<font></font>
      Clear();<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Clear()<font></font>
    {<font></font>
      _count = 0;<font></font>
      _rang = 0;<font></font>
      enumerationPos = 0;<font></font>
      enumerationBuf = null;<font></font>
      enumerationTerm = null;<font></font>
      enumerationNode = null;<font></font>
      rootNode[0] = rootNode[1] = rootNode[2] = null;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public TreeNodeEnd EnumerationInit()<font></font>
    {<font></font>
      enumerationPos = 0;<font></font>
      enumerationTerm = new byte[_rang];<font></font>
      enumerationTerm[0] = 0;<font></font>
      enumerationNode = null;<font></font>
      enumerationBuf = new object[_rang][];<font></font>
      enumerationBuf[0] = rootNode;<font></font>
      //   <font></font>
      return EnumerationNextNode();<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    public TreeNodeEnd EnumerationNextNode()<font></font>
    {<font></font>
      int iIsNext = (enumerationNode != null ? 1 : 0);<font></font>
      enumerationNode = null;<font></font>
      while ((enumerationNode == null) &amp;&amp; (enumerationPos &gt;= 0))<font></font>
      {<font></font>
        object pNextNode = null;<font></font>
        int iSymb = enumerationTerm[enumerationPos] + iIsNext;<font></font>
        for (object[] pNodes = enumerationBuf[enumerationPos]; iSymb &lt; 3; iSymb++)<font></font>
        {<font></font>
          if ((pNextNode = pNodes[iSymb]) != null) break;<font></font>
        }<font></font>
        if (pNextNode == null)<font></font>
        {<font></font>
          //   <font></font>
          enumerationPos--;<font></font>
          iIsNext = 1;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          enumerationTerm[enumerationPos] = (byte)iSymb;<font></font>
          if (pNextNode is TreeNodeEnd)<font></font>
          {<font></font>
            //  <font></font>
            enumerationNode = (TreeNodeEnd)pNextNode;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            //   <font></font>
            enumerationPos++;<font></font>
            enumerationBuf[enumerationPos] = (object[])pNextNode;<font></font>
            enumerationTerm[enumerationPos] = 0;<font></font>
            iIsNext = 0;<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      return enumerationNode;<font></font>
    }<font></font>
<font></font>
    //       <font></font>
    public TreeNodeEnd Add(byte[] term)<font></font>
    {<font></font>
      _rang = Math.Max(_rang, term.Length);<font></font>
      object[] pCurrNode = rootNode;<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      for (int i = 0; i &lt; iTermLength1; i++)<font></font>
      {<font></font>
        byte cSymb = term[i];<font></font>
        object pNextNode = pCurrNode[cSymb];<font></font>
        if (pNextNode == null)<font></font>
        {<font></font>
          pNextNode = new object[3];<font></font>
          pCurrNode[cSymb] = pNextNode;<font></font>
        }<font></font>
        pCurrNode = (object[])pNextNode;<font></font>
      }<font></font>
      object pNewNode = pCurrNode[term[iTermLength1]];<font></font>
      if (pNewNode == null)<font></font>
      {<font></font>
        pNewNode = (IsNewTreeNodeEndMode ? new TreeNodeEnd() : pCommonTreeNodeEnd);<font></font>
        pCurrNode[term[iTermLength1]] = pNewNode;<font></font>
        _count++;<font></font>
      }<font></font>
      return (TreeNodeEnd)pNewNode;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public TreeNodeEnd Remove(byte[] term)<font></font>
    {<font></font>
      object[] pCurrNode = rootNode;<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      for (int i = 0; i &lt; iTermLength1; i++)<font></font>
      {<font></font>
        pCurrNode = (object[])pCurrNode[term[i]];<font></font>
        if (pCurrNode == null) break;<font></font>
      }<font></font>
      TreeNodeEnd pRemovedNode = null;<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        //     <font></font>
        pRemovedNode = (TreeNodeEnd)pCurrNode[term[iTermLength1]];<font></font>
        if (pRemovedNode != null)<font></font>
        {<font></font>
          //    <font></font>
          pCurrNode[term[iTermLength1]] = null;<font></font>
          // - <font></font>
          _count--;<font></font>
        }<font></font>
      }<font></font>
      return pRemovedNode;<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    public void Remove(IEnumerable&lt;byte[]&gt; RemovedTerms)<font></font>
    {<font></font>
      if ((RemovedTerms == null) || (RemovedTerms.Count() == 0)) return;<font></font>
      foreach (byte[] x1 in RemovedTerms)<font></font>
      {<font></font>
        //-       Remove<font></font>
        //   IsContains<font></font>
        Remove(x1);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    public bool Contains(byte[] term)<font></font>
    {<font></font>
      object pCurrNode = rootNode;<font></font>
      for (int i = 0; i &lt; term.Length; i++)<font></font>
      {<font></font>
        pCurrNode = ((object[])pCurrNode)[term[i]];<font></font>
        if (pCurrNode == null) break;<font></font>
      }<font></font>
      return ((pCurrNode != null) &amp;&amp; (pCurrNode is TreeNodeEnd));<font></font>
    }<font></font>
<font></font>
    //    ,<font></font>
    //     <font></font>
    public bool IsCalculateTrue(byte[] term)<font></font>
    {<font></font>
      return IsCalculateTrue(rootNode, term, 0);<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    private static bool IsCalculateTrue(object[] pCurrNode,<font></font>
      byte[] term, int iStartPos)<font></font>
    {<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      while ((pCurrNode != null) &amp;&amp; (iStartPos &lt; iTermLength1))<font></font>
      {<font></font>
        byte cSymb = term[iStartPos++];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pCurrNode = (object[])pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if ((pCurrNode[0] != null) &amp;&amp; (pCurrNode[1] != null))<font></font>
          {<font></font>
            if (IsCalculateTrue((object[])pCurrNode[1], term, iStartPos)) return true;<font></font>
            pCurrNode = (object[])pCurrNode[0];<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            pCurrNode = (object[])(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      TreeNodeEnd pEndNode = null;<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        byte cSymb = term[iTermLength1];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pEndNode = (TreeNodeEnd)pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          pEndNode = (TreeNodeEnd)(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
        }<font></font>
      }<font></font>
      return (pEndNode != null);<font></font>
    }<font></font>
<font></font>
    //    ,<font></font>
    //     <font></font>
    public void GetAllCalculateTrueTerms(byte[] term,<font></font>
      ICollection&lt;TreeNodeEnd&gt; pAllCalculateTrueTermsList)<font></font>
    {<font></font>
      pAllCalculateTrueTermsList.Clear();<font></font>
      GetAllCalculateTrueTerms(rootNode, term, 0, pAllCalculateTrueTermsList);<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    private static void GetAllCalculateTrueTerms(object[] pCurrNode,<font></font>
      byte[] term, int iStartPos, ICollection&lt;TreeNodeEnd&gt; pAllCalculateTrueTermsList)<font></font>
    {<font></font>
      int iTermLength1 = term.Length - 1;<font></font>
      while ((pCurrNode != null) &amp;&amp; (iStartPos &lt; iTermLength1))<font></font>
      {<font></font>
        byte cSymb = term[iStartPos++];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          pCurrNode = (object[])pCurrNode[cSymb];<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if ((pCurrNode[0] != null) &amp;&amp; (pCurrNode[1] != null))<font></font>
          {<font></font>
            GetAllCalculateTrueTerms((object[])pCurrNode[1], term, iStartPos,<font></font>
              pAllCalculateTrueTermsList);<font></font>
            pCurrNode = (object[])pCurrNode[0];<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            pCurrNode = (object[])(pCurrNode[0] != null ? pCurrNode[0] : pCurrNode[1]);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
      if (pCurrNode != null)<font></font>
      {<font></font>
        byte cSymb = term[iTermLength1];<font></font>
        if (cSymb != LogicFunction.cStarSymb)<font></font>
        {<font></font>
          TreeNodeEnd pEndNode = (TreeNodeEnd)pCurrNode[cSymb];<font></font>
          if (pEndNode != null) pAllCalculateTrueTermsList.Add(pEndNode);<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (pCurrNode[0] != null) pAllCalculateTrueTermsList.Add((TreeNodeEnd)pCurrNode[0]);<font></font>
          if (pCurrNode[1] != null) pAllCalculateTrueTermsList.Add((TreeNodeEnd)pCurrNode[1]);<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
  }<font></font>
<font></font>
  /// &lt;summary&gt;<font></font>
  ///     ----<font></font>
  /// &lt;/summary&gt;<font></font>
  public class Quine_McCluskey<font></font>
  {<font></font>
    //   <font></font>
    private readonly Dnf _result = new Dnf();<font></font>
    public Dnf Result<font></font>
    {<font></font>
      get { return _result; }<font></font>
    }<font></font>
    //   <font></font>
    private readonly Dnf _resultNeg = new Dnf();<font></font>
    public Dnf ResultNeg<font></font>
    {<font></font>
      get { return _resultNeg; }<font></font>
    }<font></font>
<font></font>
    //    <font></font>
    private static void Skleivanie(TreeFuncTerm X1Tree,<font></font>
      TreeFuncTerm X2Tree, TreeFuncTerm NegativTree,<font></font>
      TreeFuncTerm InpNegTerms, TreeFuncTerm AllOutTerms)<font></font>
    {<font></font>
      bool IsVirtSkleivOn = ((NegativTree != null) &amp;&amp;<font></font>
        (InpNegTerms != null) &amp;&amp; (InpNegTerms.Count != 0));<font></font>
      for (TreeFuncTerm.TreeNodeEnd x1 = X1Tree.EnumerationInit();<font></font>
        x1 != null; x1 = X1Tree.EnumerationNextNode())<font></font>
      {<font></font>
        bool bIsSkleiv = false;<font></font>
        byte[] pCurrTerm = X1Tree.EnumerationTerm;<font></font>
        for (int iPos = 0; iPos &lt; pCurrTerm.Length; iPos++)<font></font>
        {<font></font>
          byte cSymbSav = pCurrTerm[iPos];<font></font>
          if (cSymbSav == LogicFunction.cStarSymb) continue;<font></font>
          //     <font></font>
          pCurrTerm[iPos] = (byte)(1 - cSymbSav);<font></font>
          if (X1Tree.Contains(pCurrTerm))<font></font>
          {<font></font>
            bIsSkleiv = true;<font></font>
            if (cSymbSav == 0)<font></font>
            {<font></font>
              pCurrTerm[iPos] = LogicFunction.cStarSymb; // <font></font>
              X2Tree.Add(pCurrTerm);<font></font>
            }<font></font>
          }<font></font>
          //    ,    NegativTree<font></font>
          else if (IsVirtSkleivOn &amp;&amp; !NegativTree.Contains(pCurrTerm))<font></font>
          {<font></font>
            pCurrTerm[iPos] = LogicFunction.cStarSymb; // <font></font>
            if (!InpNegTerms.IsCalculateTrue(pCurrTerm))<font></font>
            {<font></font>
              bIsSkleiv = true;<font></font>
              X2Tree.Add(pCurrTerm);<font></font>
            }<font></font>
          }<font></font>
          pCurrTerm[iPos] = cSymbSav;<font></font>
        }<font></font>
        //    ,      <font></font>
        if (!bIsSkleiv &amp;&amp; (AllOutTerms != null)) AllOutTerms.Add(pCurrTerm);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //     <font></font>
    //      <font></font>
    private static void DeleteDublicatingTerms(<font></font>
      IEnumerable&lt;byte[]&gt; InX1, TreeFuncTerm OutX2Tree)<font></font>
    {<font></font>
      OutX2Tree.Clear();<font></font>
      foreach (byte[] x1 in InX1) OutX2Tree.Add(x1);<font></font>
    }<font></font>
<font></font>
    //           .<font></font>
    // ,   ,       (),<font></font>
    //    “ – ”<font></font>
    // (http://www.studfiles.ru/preview/5175815/page:4/)<font></font>
    private static void ReduceRedundancyTerms(TreeFuncTerm AllOutputTerms,<font></font>
      TreeFuncTerm AllInputTerms, ICollection&lt;byte[]&gt; ResultTerms)<font></font>
    {<font></font>
      //  <font></font>
      ResultTerms.Clear();<font></font>
      //        ,   <font></font>
      Dictionary&lt;byte[], HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;&gt; Outputs2Inputs =<font></font>
        new Dictionary&lt;byte[], HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;&gt;();<font></font>
      //        ,   <font></font>
      Dictionary&lt;TreeFuncTerm.TreeNodeEnd, HashSet&lt;byte[]&gt;&gt; Inputs2Outputs =<font></font>
        new Dictionary&lt;TreeFuncTerm.TreeNodeEnd, HashSet&lt;byte[]&gt;&gt;();<font></font>
      //      <font></font>
      for (TreeFuncTerm.TreeNodeEnd pNode = AllOutputTerms.EnumerationInit();<font></font>
        pNode != null; pNode = AllOutputTerms.EnumerationNextNode())<font></font>
      {<font></font>
        byte[] outTerm = (byte[])AllOutputTerms.EnumerationTerm.Clone();<font></font>
        //  ,      term<font></font>
        HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt; InpTermsLst = new HashSet&lt;TreeFuncTerm.TreeNodeEnd&gt;();<font></font>
        AllInputTerms.GetAllCalculateTrueTerms(outTerm, InpTermsLst);<font></font>
        Outputs2Inputs.Add(outTerm, InpTermsLst);<font></font>
        foreach (TreeFuncTerm.TreeNodeEnd inputTerm in InpTermsLst)<font></font>
        {<font></font>
          if (!Inputs2Outputs.ContainsKey(inputTerm)) Inputs2Outputs.Add(inputTerm, new HashSet&lt;byte[]&gt;());<font></font>
          Inputs2Outputs[inputTerm].Add(outTerm);<font></font>
        }<font></font>
      }<font></font>
      //      -   <font></font>
      Inputs2Outputs = Inputs2Outputs.OrderBy(p =&gt; p.Value.Count).ToDictionary(p =&gt; p.Key, v =&gt; v.Value);<font></font>
      //   ,   -   <font></font>
      while (Inputs2Outputs.Count &gt; 0)<font></font>
      {<font></font>
        byte[] outTerm = Inputs2Outputs.First().Value.OrderByDescending(q =&gt; Outputs2Inputs[q].Count()).First();<font></font>
        ResultTerms.Add(outTerm);<font></font>
        foreach (TreeFuncTerm.TreeNodeEnd inTerm in Outputs2Inputs[outTerm].ToArray())<font></font>
        {<font></font>
          foreach (byte[] outTerm2Del in Inputs2Outputs[inTerm]) Outputs2Inputs[outTerm2Del].Remove(inTerm);<font></font>
          Inputs2Outputs.Remove(inTerm);<font></font>
        }<font></font>
      }<font></font>
    }<font></font>
<font></font>
    //   <font></font>
    public static void LogicFuncMinimize(<font></font>
      IEnumerable&lt;byte[]&gt; PositivTerms, ICollection&lt;byte[]&gt; OutPos,<font></font>
      IEnumerable&lt;byte[]&gt; NegativTerms, ICollection&lt;byte[]&gt; OutNeg)<font></font>
    {<font></font>
      TreeFuncTerm InpPosTerms = new TreeFuncTerm(true);<font></font>
      DeleteDublicatingTerms(PositivTerms, InpPosTerms);<font></font>
<font></font>
      int iTotalLevels = InpPosTerms.Rang;<font></font>
      if (iTotalLevels &lt;= 0) return;<font></font>
<font></font>
      TreeFuncTerm OutPosTerms = new TreeFuncTerm();<font></font>
      TreeFuncTerm OutNegTerms = null;<font></font>
<font></font>
      TreeFuncTerm InpNegTerms = null;<font></font>
      if ((NegativTerms != null) &amp;&amp; (NegativTerms.Count() != 0))<font></font>
      {<font></font>
        InpNegTerms = new TreeFuncTerm(true);<font></font>
        DeleteDublicatingTerms(NegativTerms, InpNegTerms);<font></font>
        OutNegTerms = new TreeFuncTerm();<font></font>
<font></font>
        //        <font></font>
        for (TreeFuncTerm.TreeNodeEnd pNode = InpPosTerms.EnumerationInit();<font></font>
          pNode != null; pNode = InpPosTerms.EnumerationNextNode())<font></font>
        {<font></font>
          if (!InpNegTerms.Contains(InpPosTerms.EnumerationTerm)) continue;<font></font>
          // -    X1   NegativTerms<font></font>
          int iPos_Count = PositivTerms.Count(p =&gt; Enumerable.SequenceEqual(p, InpPosTerms.EnumerationTerm));<font></font>
          int iNeg_Count = NegativTerms.Count(p =&gt; Enumerable.SequenceEqual(p, InpPosTerms.EnumerationTerm));<font></font>
          if (iPos_Count &gt; iNeg_Count)<font></font>
          {<font></font>
            InpNegTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
          else if (iPos_Count &lt; iNeg_Count)<font></font>
          {<font></font>
            InpPosTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
          else //if (iX1_Count == iNeg_Count)<font></font>
          {<font></font>
            InpPosTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
            InpNegTerms.Remove(InpPosTerms.EnumerationTerm);<font></font>
          }<font></font>
        }<font></font>
      }<font></font>
<font></font>
      // <font></font>
      TreeFuncTerm X1PositivTree = InpPosTerms;<font></font>
      TreeFuncTerm X1NegativTree = InpNegTerms;<font></font>
<font></font>
      int iLevelCounter = 0;<font></font>
      //       <font></font>
      while ((X1PositivTree.Count != 0) &amp;&amp; (iLevelCounter &lt; iTotalLevels))<font></font>
      {<font></font>
        TreeFuncTerm X2PositivTree = new TreeFuncTerm();<font></font>
        Skleivanie(X1PositivTree, X2PositivTree, X1NegativTree, InpNegTerms, OutPosTerms);<font></font>
<font></font>
        if ((X1NegativTree != null) &amp;&amp; (X1NegativTree.Count != 0))<font></font>
        {<font></font>
          TreeFuncTerm X2NegativTree = new TreeFuncTerm();<font></font>
          Skleivanie(X1NegativTree, X2NegativTree, X1PositivTree, InpPosTerms, OutNegTerms);<font></font>
<font></font>
          //  <font></font>
          if (iLevelCounter &gt; 0) X1NegativTree.Clear();<font></font>
<font></font>
          X1NegativTree = X2NegativTree;<font></font>
        }<font></font>
<font></font>
        //  <font></font>
        if (iLevelCounter &gt; 0) X1PositivTree.Clear();<font></font>
<font></font>
        X1PositivTree = X2PositivTree;<font></font>
<font></font>
        iLevelCounter++;<font></font>
<font></font>
        GC.Collect();<font></font>
      }<font></font>
<font></font>
      if (OutPosTerms.Count &gt; 0)<font></font>
      {<font></font>
        // ,     cStarSymb<font></font>
        OutPosTerms.Remove(Enumerable.Repeat(LogicFunction.cStarSymb, iTotalLevels).ToArray());<font></font>
      }<font></font>
      //   <font></font>
      ReduceRedundancyTerms(OutPosTerms, InpPosTerms, OutPos);<font></font>
<font></font>
      if ((OutNeg != null) &amp;&amp; (OutNegTerms != null))<font></font>
      {<font></font>
        if (OutNegTerms.Count &gt; 0)<font></font>
        {<font></font>
          // ,     cStarSymb<font></font>
          OutNegTerms.Remove(Enumerable.Repeat(LogicFunction.cStarSymb, iTotalLevels).ToArray());<font></font>
        }<font></font>
        //   <font></font>
        ReduceRedundancyTerms(OutNegTerms, InpNegTerms, OutNeg);<font></font>
      }<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;byte[]&gt; TermsInput)<font></font>
    {<font></font>
      LogicFuncMinimize(TermsInput, _result.Terms, null, null);<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;byte[]&gt; TermsInput, IEnumerable&lt;byte[]&gt; NegativTerms)<font></font>
    {<font></font>
      LogicFuncMinimize(TermsInput, _result.Terms, NegativTerms, _resultNeg.Terms);<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;char[]&gt; TermsInput)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;char[]&gt; TermsInput, IEnumerable&lt;char[]&gt; NegativTerms)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()),<font></font>
          NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p == '0' ? 0 : 1)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;bool[]&gt; TermsInput)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()));<font></font>
    }<font></font>
<font></font>
    // <font></font>
    public void Start(IEnumerable&lt;bool[]&gt; TermsInput, IEnumerable&lt;bool[]&gt; NegativTerms)<font></font>
    {<font></font>
      Start(TermsInput.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()),<font></font>
          NegativTerms.Select(t =&gt; t.Select(p =&gt; (byte)(p ? 1 : 0)).ToArray()));<font></font>
    }<font></font>
  }<font></font>
  #endregion<font></font>
}</code></pre></div>
                    </div><br>
<p>     -            ,   .       ,      ,     .            <i>t</i>   <i>N</i>    X(t-j) (j=1,2,…,<i>N</i>),         Sign(X(t)-X(t-1)).       ,          .        , . .   ,         .    ,       Sign(X(t)-X(t-1))  .        ,   ,  -               , . . -  .</p><br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title">   C#        (  )</b>
                        <div class="spoiler_text"><pre><code class="plaintext hljs">    public static void TestRandomNeuralNetwork()<font></font>
    {<font></font>
      //:   <font></font>
      const int iTrendSize = 2000;<font></font>
      //:   <font></font>
      const int iTestTrendSize = 1000;<font></font>
      //:   <font></font>
      const int iWindowSize = 10;<font></font>
      //   <font></font>
      const int iOmega = 100;<font></font>
      //-   <font></font>
      const int iHarmonics = 5;<font></font>
      //    <font></font>
      const int iMinAmpl = 50;<font></font>
      //    <font></font>
      const int iMaxAmpl = 100;<font></font>
      //  /<font></font>
      const double dNoise2SignalRatio = 0;<font></font>
      //:   <font></font>
      const int iAmountLogicDiscrims = 20;<font></font>
      //:  -    <font></font>
      const int iMaxAmountDistributionPoints = 1000;<font></font>
      //:  -    <font></font>
      const int iLogicDiscrimsMaxTrainRestarts = 1;<font></font>
<font></font>
      //   <font></font>
      int iPrepTrendLength = iTrendSize - iTestTrendSize;<font></font>
      double[] pTrend = new double[iTrendSize];<font></font>
      // -<font></font>
      //for (int t = 0; t &lt; iTrendSize; t++) pTrend[t] = Math.Sin((t * Math.PI) / iOmega) + 200;<font></font>
      //  <font></font>
      int[] pFreq = new int[iHarmonics];<font></font>
      int[] pPhase = new int[iHarmonics];<font></font>
      double[] pAmpl = new double[iHarmonics];<font></font>
      //  . <font></font>
      Random RndFabric = new Random(Environment.TickCount);<font></font>
      for (int h = 0; h &lt; iHarmonics; h++)<font></font>
      {<font></font>
        pFreq[h] = RndFabric.Next(iOmega/*iPrepTrendLength*/) + 1;<font></font>
        pPhase[h] = RndFabric.Next(iPrepTrendLength);<font></font>
        pAmpl[h] = RndFabric.NextDouble();<font></font>
      }<font></font>
      double iMinValue = double.MaxValue, iMaxValue = 0;<font></font>
      for (int t = 0; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        double dValue = 0; //iMinAmpl + ((iMaxAmpl - iMinAmpl) * RndFabric.NextDouble());<font></font>
        for (int h = 0; h &lt; iHarmonics; h++)<font></font>
        {<font></font>
          dValue += ((pAmpl[h] * (iMaxAmpl - iMinAmpl)) + iMinAmpl) * Math.Sin(((t + pPhase[h]) * Math.PI) / pFreq[h]);<font></font>
        }<font></font>
        pTrend[t] = dValue;<font></font>
        iMinValue = Math.Min(iMinValue, dValue);<font></font>
        iMaxValue = Math.Max(iMaxValue, dValue);<font></font>
      }<font></font>
      // <font></font>
      if (dNoise2SignalRatio &gt; 0)<font></font>
      {<font></font>
        double dNoiseAmp = (iMaxValue - iMinValue) * dNoise2SignalRatio;<font></font>
        for (int t = 0; t &lt; iTrendSize; t++)<font></font>
        {<font></font>
          pTrend[t] += dNoiseAmp * 2.0 * (RndFabric.NextDouble() - 0.5);<font></font>
          iMinValue = Math.Min(iMinValue, pTrend[t]);<font></font>
        }<font></font>
      }<font></font>
      // ,     <font></font>
      if (iMinValue &lt; 0)<font></font>
      {<font></font>
        for (int t = 0; t &lt; iTrendSize; t++) pTrend[t] -= iMinValue;<font></font>
      }<font></font>
      //  <font></font>
      double[][] pSourceTrendData = new double[iTrendSize][];<font></font>
      bool[] pTargetFeature = new bool[iTrendSize];<font></font>
      // <font></font>
      for (int t = iWindowSize; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        // <font></font>
        double[] pNormData = new double[iWindowSize];<font></font>
        for (int i = 0; i &lt; iWindowSize; i++) pNormData[i] = pTrend[t - iWindowSize + i];<font></font>
        pSourceTrendData[t] = pNormData;<font></font>
        //  <font></font>
        pTargetFeature[t] = (pTrend[t] &gt;= pTrend[t - 1]);<font></font>
      }<font></font>
      DateTime dtStartDt = DateTime.Now;<font></font>
      RndNeuroNet.RandomNeuralNetwork randomNeuralNetwork = new RndNeuroNet.RandomNeuralNetwork();<font></font>
      randomNeuralNetwork.CreateNetwork(pSourceTrendData, pTargetFeature, iWindowSize, iPrepTrendLength, iWindowSize, iAmountLogicDiscrims,<font></font>
        //iClustersAmount, iClustersRestart,<font></font>
        iLogicDiscrimsMaxTrainRestarts, iMaxAmountDistributionPoints);<font></font>
      //  <font></font>
      TimeSpan tsTime = (DateTime.Now - dtStartDt);<font></font>
      //     <font></font>
      int iUpGapCounterTrain = 0, iDnGapCounterTrain = 0, iSuccessCounterTrain = 0, iErrorCounterTrain = 0, iIgnoreCounterTrain = 0;<font></font>
      for (int t = iWindowSize; t &lt; iPrepTrendLength; t++)<font></font>
      {<font></font>
        double dPrognos = randomNeuralNetwork.CalcResponce(pSourceTrendData[t]);<font></font>
        if (dPrognos == 0)<font></font>
        {<font></font>
          iIgnoreCounterTrain++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (((pTargetFeature[t] ? +1 : -1) * dPrognos) &gt; 0)<font></font>
          {<font></font>
            iSuccessCounterTrain++;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            iErrorCounterTrain++;<font></font>
          }<font></font>
        }<font></font>
        // GAP-   <font></font>
        if (pTargetFeature[t])<font></font>
        {<font></font>
          iUpGapCounterTrain++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          iDnGapCounterTrain++;<font></font>
        }<font></font>
      }<font></font>
      //     <font></font>
      int iUpGapCounterTest = 0, iDnGapCounterTest = 0, iSuccessCounterTest = 0, iErrorCounterTest = 0, iIgnoreCounterTest = 0;<font></font>
      for (int t = iPrepTrendLength; t &lt; iTrendSize; t++)<font></font>
      {<font></font>
        double dPrognos = randomNeuralNetwork.CalcResponce(pSourceTrendData[t]);<font></font>
        if (dPrognos == 0)<font></font>
        {<font></font>
          iIgnoreCounterTest++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          if (((pTargetFeature[t] ? +1 : -1) * dPrognos) &gt; 0)<font></font>
          {<font></font>
            iSuccessCounterTest++;<font></font>
          }<font></font>
          else<font></font>
          {<font></font>
            iErrorCounterTest++;<font></font>
          }<font></font>
        }<font></font>
        // GAP-   <font></font>
        if (pTargetFeature[t])<font></font>
        {<font></font>
          iUpGapCounterTest++;<font></font>
        }<font></font>
        else<font></font>
        {<font></font>
          iDnGapCounterTest++;<font></font>
        }<font></font>
      }<font></font>
      //<font></font>
      Console.WriteLine("-      = " + iUpGapCounterTrain + Environment.NewLine +<font></font>
                      "-      = " + iDnGapCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iSuccessCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iErrorCounterTrain + Environment.NewLine +<font></font>
                      "-     = " + iIgnoreCounterTrain + Environment.NewLine +<font></font>
                      "-      = " + iUpGapCounterTest + Environment.NewLine +<font></font>
                      "-      = " + iDnGapCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iSuccessCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iErrorCounterTest + Environment.NewLine +<font></font>
                      "-     = " + iIgnoreCounterTest + Environment.NewLine +<font></font>
                      "  = " + (int)tsTime.TotalMinutes + " . " + tsTime.Seconds + " ."<font></font>
      );<font></font>
      Console.WriteLine("Press Enter to exit ...");<font></font>
      Console.ReadLine();<font></font>
    }</code></pre></div>
                    </div><br>
<p>     ,  ,               .     ,   ,   :</p><br>
<ul>
<li>    ;</li>
<li>            ;</li>
<li>    , . .        ,  «  - ».</li>
</ul><br>
<p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Nachteil des NS ist es notwendig, seine hohen Anforderungen an die Menge des verfügbaren Arbeitsspeichers und den erheblichen Zeitaufwand für das Training zu beachten. </font><font style="vertical-align: inherit;">Ihr Hauptverbraucher ist der Algorithmus zum Minimieren logischer Funktionen durch das Quine-Mac'Klaski-Verfahren, d. H. Die dritte Ausgabeschicht. </font><font style="vertical-align: inherit;">Es besteht jedoch die Möglichkeit, diesen Nachteil durch Kaskadierung mehrerer logischer Funktionen etwas abzumildern. </font><font style="vertical-align: inherit;">Im Übrigen hat sich dieser NS als zuverlässiges Werkzeug zur Vorhersage und Klassifizierung von Binärdaten etabliert.</font></font></p></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500422/index.html">Visual Debugger für Jupyter</a></li>
<li><a href="../de500424/index.html">Verzögerte Verwendung der Direktivenfunktionalität in Angular</a></li>
<li><a href="../de500426/index.html">Python, Pandas und das Lösen von drei Problemen aus der Excel-Welt</a></li>
<li><a href="../de500428/index.html">Wie kann man Pandas bei der Verarbeitung großer Datenmengen helfen?</a></li>
<li><a href="../de500430/index.html">Wie ich nach Quarantäne gesucht habe</a></li>
<li><a href="../de500438/index.html">SFTP und FTPS</a></li>
<li><a href="../de500444/index.html">9 Python-Programmierkenntnisse, die Anfänger von erfahrenen unterscheiden</a></li>
<li><a href="../de500446/index.html">Ein paar Worte zu R2DBC und PostgreSQL</a></li>
<li><a href="../de500448/index.html">Prometheus: HTTP-Überwachung über den Blackbox-Exporter</a></li>
<li><a href="../de500450/index.html">Erstellen eines MIDI-Keyboards aus einem Synthesizer für alte Kinder</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>