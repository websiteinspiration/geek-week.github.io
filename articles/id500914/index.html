<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍🌾 ↕️ 📂 Algoritma rendering volume yang cepat dan mudah 📥 🤵🏾 🥄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya baru-baru ini menulis ShaderToy kecil yang melakukan rendering volumetrik sederhana, dan kemudian memutuskan untuk menerbitkan posting yang menje...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Algoritma rendering volume yang cepat dan mudah</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500914/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/8r/iy/wc/8riywca1jhipnzh4e3ycjritfec.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya baru-baru ini menulis ShaderToy kecil yang melakukan rendering volumetrik sederhana, dan kemudian memutuskan untuk menerbitkan posting yang menjelaskan pekerjaannya. </font><font style="vertical-align: inherit;">ShaderToy interaktif itu sendiri dapat dilihat di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Jika Anda membaca dari ponsel atau laptop, saya sarankan menonton </font><font style="vertical-align: inherit;">versi cepat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya menyertakan cuplikan kode di pos yang akan membantu Anda memahami kinerja ShaderToy di tingkat tinggi, tetapi mereka tidak memiliki semua detailnya. </font><font style="vertical-align: inherit;">Jika Anda ingin menggali lebih dalam, saya sarankan memeriksa dengan kode ShaderToy. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ShaderToy saya memiliki tiga tugas utama:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eksekusi waktu nyata</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesederhanaan</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kebenaran fisik (... atau sesuatu seperti itu)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan mulai dengan adegan kode kosong ini. </font><font style="vertical-align: inherit;">Saya tidak akan membahas detail implementasi, karena ini tidak terlalu menarik, tetapi saya akan memberi tahu Anda secara singkat di mana kita mulai:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ray menelusuri benda-benda buram. </font><font style="vertical-align: inherit;">Semua benda primitif dengan persimpangan sederhana dengan sinar (1 bidang dan 3 bola)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghitung pencahayaan, Phong shading digunakan, dan dalam tiga sumber cahaya bulat, koefisien redaman cahaya khusus digunakan. </font><font style="vertical-align: inherit;">Sinar bayangan tidak diperlukan, karena kami hanya menerangi pesawat.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Begini tampilannya:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba8/4dc/f82/ba84dcf8277762a067454fb786d266be.jpg" alt="Tangkapan layar ShaderToy"></div><a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami akan membuat volume sebagai bagian terpisah yang bercampur dengan adegan buram; </font><font style="vertical-align: inherit;">ini mirip dengan bagaimana semua mesin render waktu-nyata secara individual memproses permukaan yang buram dan tembus cahaya.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian 1: mensimulasikan volume</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi pertama-tama, sebelum kita dapat memulai rendering volumetrik, kita membutuhkan volume yang sama! Untuk mensimulasikan volume, saya memutuskan untuk menggunakan fungsi jarak yang ditandatangani (SDF). Mengapa tepatnya fungsi field jarak? Karena saya bukan seorang seniman, tetapi mereka memungkinkan Anda untuk membuat formulir yang sangat organik hanya dalam beberapa baris kode. Saya tidak akan berbicara secara rinci tentang fungsi jarak dengan tanda, karena Inigo Kiles telah menjelaskannya dengan sangat baik. Jika Anda penasaran, maka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ada</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> daftar hebat berbagai fungsi jarak tanda dan pengubah. Dan di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ada artikel lain tentang SDF raymarching ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita mulai dengan yang sederhana dan menambahkan bola di sini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c03/5c4/536/c035c45368ef0cd0e232041b4ca2eec4.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita akan menambahkan bola lain dan menggunakan konjugasi halus untuk menggabungkan fungsi jarak bola. </font><font style="vertical-align: inherit;">Kode ini saya ambil langsung dari halaman Inigo, tetapi untuk kejelasan, saya akan memasukkannya di sini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm</span>
<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">sdSmoothUnion</span><span class="hljs-params">( <span class="hljs-keyword">float</span> d1, <span class="hljs-keyword">float</span> d2, <span class="hljs-keyword">float</span> k )</span> 
</span>{
    <span class="hljs-keyword">float</span> h = clamp( <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>*(d2-d1)/k, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span> );
    <span class="hljs-keyword">return</span> mix( d2, d1, h ) - k*h*(<span class="hljs-number">1.0</span>-h); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pasangan berpasangan adalah alat yang sangat kuat, karena Anda bisa mendapatkan sesuatu yang cukup menarik hanya dengan menggabungkannya dengan beberapa bentuk sederhana. </font><font style="vertical-align: inherit;">Inilah yang terlihat dari banyak bidang konjugasi saya yang lancar:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddc/c3c/4b4/ddcc3c4b4f6d38d509b69cae63088c4a.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, kami mendapatkan sesuatu yang berbentuk tetesan air mata, tetapi kami membutuhkan sesuatu yang lebih seperti awan daripada setetes. Fitur hebat dari SDF adalah betapa mudahnya mengubah permukaan dengan hanya menambahkan sedikit noise ke SDF. Jadi mari kita tambahkan beberapa gerakan Brown fraktal (fBM) di atas kebisingan, menggunakan posisi untuk mengindeks fungsi kebisingan. Inigo Kiles juga membahas topik ini dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hebat </font><font style="vertical-align: inherit;">tentang fBM noise. Inilah yang akan terlihat seperti gambar dengan noise fBM:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a47/bd6/bbd/a47bd6bbd487a37bc5e07a8f65e6436d.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Baik! </font><font style="vertical-align: inherit;">Berkat kebisingan fBM, objek tiba-tiba mulai terlihat jauh lebih menarik! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kita perlu menciptakan ilusi bahwa volume berinteraksi dengan bidang bumi. </font><font style="vertical-align: inherit;">Untuk melakukan ini, saya menambahkan jarak bidang yang ditandatangani sedikit di bawah bidang tanah dan menggunakan kembali kombinasi pasangan halus dengan nilai pemasangan yang sangat agresif (parameter k). </font><font style="vertical-align: inherit;">Setelah itu, kami mendapat gambar ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d2/7e9/863/8d27e9863fb9637575e23a4cf593f90e.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sentuhan terakhir adalah perubahan dalam indeks xz dari kebisingan fBM dari waktu ke waktu, sehingga volumenya terlihat seperti kabut yang berputar-putar. </font><font style="vertical-align: inherit;">Bergerak, itu terlihat sangat bagus!</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/167/2d6/6fa/1672d66fa4b2760e9e57bd6062281cc2.gif" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hebat, kami punya sesuatu seperti awan! </font><font style="vertical-align: inherit;">Kode perhitungan SDF juga cukup kompak:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">QueryVolumetricDistanceField</span><span class="hljs-params">( in vec3 pos)</span>
</span>{    <font></font>
    vec3 fbmCoord = (pos + <span class="hljs-number">2.0</span> * vec3(iTime, <span class="hljs-number">0.0</span>, iTime)) / <span class="hljs-number">1.5f</span>;
    <span class="hljs-keyword">float</span> sdfValue = sdSphere(pos, vec3(<span class="hljs-number">-8.0</span>, <span class="hljs-number">2.0</span> + <span class="hljs-number">20.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">-1</span>), <span class="hljs-number">5.6</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(<span class="hljs-number">8.0</span>, <span class="hljs-number">8.0</span> + <span class="hljs-number">12.0</span> * <span class="hljs-built_in">cos</span>(iTime), <span class="hljs-number">3</span>), <span class="hljs-number">5.6</span>), <span class="hljs-number">3.0f</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(<span class="hljs-number">5.0</span> * <span class="hljs-built_in">sin</span>(iTime), <span class="hljs-number">3.0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">8.0</span>), <span class="hljs-number">3.0</span>) + <span class="hljs-number">7.0</span> * fbm_4(fbmCoord / <span class="hljs-number">3.2</span>);<font></font>
    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0</span>)), <span class="hljs-number">22.0</span>);
    <span class="hljs-keyword">return</span> sdfValue;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini hanya merender objek yang buram. Kita membutuhkan kabut yang luar biasa indah! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana kita membuatnya dalam bentuk volume, dan bukan objek buram? Mari kita bicara tentang fisika yang kita simulasikan. Volume adalah sejumlah besar partikel di area ruang tertentu. Dan ketika saya mengatakan "besar", maksud saya "BESAR". Sedemikian rupa sehingga pemodelan masing-masing partikel hari ini adalah tugas yang mustahil, bahkan untuk render offline. Contoh bagus dari ini adalah api, kabut, dan awan. Sebenarnya, semuanya volume, tetapi demi kecepatan perhitungan, lebih mudah untuk menutup mata kita untuk ini dan berpura-pura tidak. Kami mewakili akumulasi partikel-partikel ini sebagai nilai kerapatan yang biasanya disimpan dalam beberapa jenis kisi 3D (atau sesuatu yang lebih kompleks, misalnya, dalam OpenVDB).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika cahaya melewati volume, sepasang fenomena dapat terjadi ketika cahaya bertabrakan dengan sebuah partikel. </font><font style="vertical-align: inherit;">Ia dapat menyebar dan pergi ke arah lain, atau sebagian dari cahaya dapat diserap oleh partikel dan larut. </font><font style="vertical-align: inherit;">Untuk mematuhi persyaratan eksekusi waktu-nyata, kami akan melakukan apa yang disebut pencar tunggal. </font><font style="vertical-align: inherit;">Ini berarti yang berikut: kita akan mengasumsikan bahwa cahaya tersebar hanya sekali, ketika cahaya bertabrakan dengan partikel dan terbang ke arah kamera. </font><font style="vertical-align: inherit;">Artinya, kita tidak akan dapat mensimulasikan efek dari hamburan berganda, misalnya, kabut, di mana objek di kejauhan biasanya terlihat lebih kabur. </font><font style="vertical-align: inherit;">Tetapi untuk sistem kami ini sudah cukup. </font><font style="vertical-align: inherit;">Inilah yang tampak seperti hamburan tunggal saat raymarching:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f2d/19e/00f/f2d19e00fa758b0addc4ca447c0b024e.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode semu untuknya terlihat seperti ini:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">for</span> n steps along the camera ray:<font></font>
   Calculate what % <span class="hljs-function">of your ray hit <span class="hljs-title">particles</span> <span class="hljs-params">(i.e. were absorbed)</span> <span class="hljs-keyword">and</span> needs lighting
   <span class="hljs-keyword">for</span> m lights:
      <span class="hljs-keyword">for</span> k steps towards the light:
         Calculate % of light that were absorbe in <span class="hljs-keyword">this</span> step
      Calculate lighting based on how much light is visible
Blend results on top of opaque objects pass based on % of your ray that made it through the volume</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artinya, kita berhadapan dengan perhitungan dengan kompleksitas O (n * m * k). </font><font style="vertical-align: inherit;">Jadi GPU harus bekerja keras.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghitung penyerapan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, mari kita lihat penyerapan cahaya dalam volume di sepanjang sorotan kamera (mis., Jangan melakukan raymarching ke arah sumber cahaya). </font><font style="vertical-align: inherit;">Untuk melakukan ini, kita perlu dua tindakan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lakukan raymarching di dalam volume</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hitung penyerapan / pencahayaan pada setiap langkah</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk menghitung berapa banyak cahaya yang diserap pada setiap titik, kami menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hukum Bouguer - Lambert - Beer</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menjelaskan redaman cahaya ketika melewati suatu material. </font><font style="vertical-align: inherit;">Perhitungannya sangat sederhana:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">BeerLambert</span><span class="hljs-params">(<span class="hljs-keyword">float</span> absorptionCoefficient, <span class="hljs-keyword">float</span> distanceTraveled)</span>
</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">exp</span>(-absorptionCoefficient * distanceTraveled);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Koefisien absorpsi adalah parameter material. </font><font style="vertical-align: inherit;">Misalnya, dalam volume transparan, misalnya, dalam air, nilai ini akan rendah, dan untuk sesuatu yang lebih tebal, misalnya, susu, koefisiennya akan lebih tinggi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk melakukan volume raymarching, kami cukup mengambil langkah-langkah dengan ukuran tetap di sepanjang balok dan mendapatkan penyerapan di setiap langkah. </font><font style="vertical-align: inherit;">Anda mungkin tidak mengerti mengapa harus mengambil langkah-langkah tetap alih-alih sesuatu yang lebih cepat, misalnya, melacak bola, tetapi jika Anda ingat bahwa kepadatan di dalam volume itu heterogen, maka semuanya menjadi jelas. </font><font style="vertical-align: inherit;">Di bawah ini adalah kode penyerapan dan akumulasi raymarching. </font><font style="vertical-align: inherit;">Beberapa variabel berada di luar cakupan snipet kode ini, jadi lihat implementasi penuh di ShaderToy.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">float</span> opaqueVisiblity = <span class="hljs-number">1.0f</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> marchSize = <span class="hljs-number">0.6f</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_VOLUME_MARCH_STEPS; i++) {<font></font>
	volumeDepth += marchSize;<font></font>
	<span class="hljs-keyword">if</span>(volumeDepth &gt; opaqueDepth) <span class="hljs-keyword">break</span>;<font></font>
	<font></font>
	vec3 position = rayOrigin + volumeDepth*rayDirection;<font></font>
	<span class="hljs-keyword">bool</span> isInVolume = QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0f</span>;
	<span class="hljs-keyword">if</span>(isInVolume) 	{
		<span class="hljs-keyword">float</span> previousOpaqueVisiblity = opaqueVisiblity;<font></font>
		opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
		<span class="hljs-keyword">float</span> absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;
		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> lightIndex = <span class="hljs-number">0</span>; lightIndex &lt; NUM_LIGHTS; lightIndex++) {
			<span class="hljs-keyword">float</span> lightDistance = length((GetLight(lightIndex).Position - position));<font></font>
			vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance);  <font></font>
			volumetricColor += absorptionFromMarch * volumeAlbedo * lightColor;<font></font>
		}<font></font>
		volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();<font></font>
	}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah yang kita dapatkan dengan ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/14e/a86/c8714ea862797c656d9c64105c7befed.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sepertinya benang permen! </font><font style="vertical-align: inherit;">Mungkin untuk beberapa efek ini sudah cukup! </font><font style="vertical-align: inherit;">Tetapi kita kurang memiliki bayangan diri. </font><font style="vertical-align: inherit;">Cahaya mencapai semua bagian volume secara merata. </font><font style="vertical-align: inherit;">Tapi ini tidak benar secara fisik, tergantung pada ukuran volume antara titik yang diberikan dan sumber cahaya, kami akan menerima jumlah cahaya yang masuk berbeda.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membayangi diri sendiri</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami sudah melakukan yang paling sulit. </font><font style="vertical-align: inherit;">Kita perlu melakukan hal yang sama seperti yang kita lakukan untuk menghitung penyerapan sepanjang sinar kamera, tetapi hanya sepanjang sinar cahaya. </font><font style="vertical-align: inherit;">Kode untuk menghitung jumlah cahaya yang mencapai setiap titik pada dasarnya akan menjadi pengulangan kode, tetapi menduplikasinya lebih mudah daripada meretas HLSL untuk mendapatkan rekursi yang kita butuhkan. </font><font style="vertical-align: inherit;">Jadi seperti inilah tampilannya:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetLightVisiblity</span><span class="hljs-params">(in vec3 rayOrigin, in vec3 rayDirection, in <span class="hljs-keyword">float</span> maxT, in <span class="hljs-keyword">int</span> maxSteps, in <span class="hljs-keyword">float</span> marchSize)</span> </span>{
    <span class="hljs-keyword">float</span> t = <span class="hljs-number">0.0f</span>;
    <span class="hljs-keyword">float</span> lightVisiblity = <span class="hljs-number">1.0f</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSteps; i++) {                       <font></font>
        t += marchSize;<font></font>
        <span class="hljs-keyword">if</span>(t &gt; maxT) <span class="hljs-keyword">break</span>;<font></font>
<font></font>
        vec3 position = rayOrigin + t*rayDirection;<font></font>
        <span class="hljs-keyword">if</span>(QueryVolumetricDistanceField(position) &lt; <span class="hljs-number">0.0</span>) {<font></font>
            lightVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT, marchSize);<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">return</span> lightVisiblity;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menambahkan bayangan diri memberi kita hal berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4f/6e0/96e/a4f6e096e2250a9aa17594b59cc7e25d.jpg" alt="Tangkapan layar ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lembutkan ujungnya</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat ini, saya sudah cukup menyukai volume kami. </font><font style="vertical-align: inherit;">Saya menunjukkannya kepada pemimpin berbakat departemen VFX The Coalition, James Sharp. </font><font style="vertical-align: inherit;">Dia segera memperhatikan bahwa tepi-tepi volume terlihat terlalu tajam. </font><font style="vertical-align: inherit;">Dan ini benar-benar benar - benda-benda seperti awan terus-menerus tersebar di ruang di sekitarnya, sehingga tepinya bercampur dengan ruang kosong di sekitar volume, yang seharusnya mengarah pada penciptaan tepi yang sangat halus. </font><font style="vertical-align: inherit;">James menawarkan saya ide bagus - untuk mengurangi kepadatan tergantung pada seberapa dekat kita ke tepi. </font><font style="vertical-align: inherit;">Dan karena kami bekerja dengan fungsi jarak dengan tanda, sangat mudah untuk diterapkan! </font><font style="vertical-align: inherit;">Jadi mari kita tambahkan fungsi yang dapat digunakan untuk meminta kepadatan di setiap titik di volume:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">return</span> sdfMultiplier;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan kemudian kita hanya mengelompokkannya ke dalam nilai penyerapan:</font></font><br>
<br>
<pre><code class="cpp hljs">opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position), marchSize);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan inilah tampilannya:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/7b3/ab5/7887b3ab53afcfc69c33e12bd473de9d.gif" alt="Tangkapan layar ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi kepadatan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang kami memiliki fungsi kerapatan, Anda dapat dengan mudah menambahkan sedikit noise ke volume untuk memberikan detail dan kemegahan tambahan. </font><font style="vertical-align: inherit;">Dalam hal ini, saya hanya menggunakan kembali fungsi fBM yang kami gunakan untuk menyesuaikan bentuk volume.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">GetFogDensity</span><span class="hljs-params">(vec3 position)</span>
</span>{   
    <span class="hljs-keyword">float</span> sdfValue = QueryVolumetricDistanceField(position)
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxSDFMultiplier = <span class="hljs-number">1.0</span>;
    <span class="hljs-keyword">bool</span> insideSDF = sdfDistance &lt; <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">float</span> sdfMultiplier = insideSDF ? min(<span class="hljs-built_in">abs</span>(sdfDistance), maxSDFMultiplier) : <span class="hljs-number">0.0</span>;
   <span class="hljs-keyword">return</span> sdfMultiplier * <span class="hljs-built_in">abs</span>(fbm_4(position / <span class="hljs-number">6.0</span>) + <span class="hljs-number">0.5</span>);<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan jadi kami mendapat yang berikut:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b9/c0a/1e6/1b9c0a1e68d020206e9567b9044317d9.jpg" alt="Tangkapan layar ShaderToy"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Membayangi bayangan diri sendiri</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Volume sudah terlihat sangat cantik! </font><font style="vertical-align: inherit;">Tapi sedikit cahaya masih bocor melalui itu. </font><font style="vertical-align: inherit;">Di sini kita melihat bagaimana warna hijau merembes di mana volume pasti menyerapnya:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/051/e16/dbf/051e16dbfa5d9f307c635a6293dcc69f.jpg" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini terjadi karena objek buram dirender sebelum volume diberikan, sehingga mereka tidak memperhitungkan bayangan yang disebabkan oleh volume. </font><font style="vertical-align: inherit;">Ini cukup mudah untuk diperbaiki - kami memiliki fungsi GetLightVisiblity yang dapat digunakan untuk menghitung bayangan, jadi kami hanya perlu memanggilnya untuk menerangi objek buram. </font><font style="vertical-align: inherit;">Kami mendapatkan yang berikut ini:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cda/1c4/99d/cda1c499d05729265b374378e3da9481.gif" alt="Tangkapan layar ShaderToy"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain menciptakan bayangan multi-warna yang indah, ini membantu meningkatkan bayangan dan membangun volume ke dalam adegan. </font><font style="vertical-align: inherit;">Selain itu, berkat tepi yang halus dari volume, kami mendapatkan bayangan lembut, meskipun pada kenyataannya, kami berbicara dengan sumber pencahayaan titik. </font><font style="vertical-align: inherit;">Itu saja! </font><font style="vertical-align: inherit;">Banyak hal yang dapat dilakukan di sini, tetapi bagi saya tampaknya saya telah mencapai kualitas visual yang saya butuhkan, dengan tetap menjaga kesederhanaan relatif dari contoh tersebut.</font></font><br>
<br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimalisasi</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada akhirnya, saya akan mendaftar secara singkat beberapa kemungkinan optimasi:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum melakukan raymarching ke arah sumber cahaya, perlu untuk memeriksa dengan nilai kepunahan cahaya apakah sejumlah besar cahaya ini benar-benar mencapai titik yang dimaksud. </font><font style="vertical-align: inherit;">Dalam implementasi saya, saya melihat kecerahan cahaya, dikalikan dengan bahan albedo, dan memastikan bahwa nilainya cukup besar untuk melakukan raymarching.</font></font></li>
<li>      ,     ,     raymarching   </li>
<li>        raymarching .      ,        .           ,       raymarching ,     .</li>
</ol><br>
<h1></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu saja! </font><font style="vertical-align: inherit;">Secara pribadi, saya terkejut bahwa Anda dapat membuat sesuatu yang secara fisik cukup benar dalam jumlah kode yang kecil (sekitar 500 baris). </font><font style="vertical-align: inherit;">Terima kasih sudah membaca, semoga menarik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan satu lagi catatan: inilah perubahan yang menyenangkan - saya menambahkan emisi cahaya berdasarkan jarak SDF untuk menciptakan efek ledakan. </font><font style="vertical-align: inherit;">Lagi pula, ledakan tidak pernah banyak.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c64/2f1/ab0/c642f1ab0fbc3df3b35cfafa97f9c694.gif" alt="Tangkapan layar ShaderToy"></div></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id500896/index.html">Apa yang harus dilihat di karantina? Pilihan bahan dari Technostream (bagian 3)</a></li>
<li><a href="../id500898/index.html">Paket Bulan SpaceX Gila? Evaluasi Program oleh U / S_Hirangy (reddit)</a></li>
<li><a href="../id500902/index.html">Intisari materi menarik untuk pengembang seluler # 343 (27 April - 3 Mei)</a></li>
<li><a href="../id500904/index.html">Siapa yang ada dalam ekosistem pembayaran 2020. Bagian 1</a></li>
<li><a href="../id500910/index.html">Sistem komunikasi ruang angkasa jarak jauh Cina</a></li>
<li><a href="../id500918/index.html">Apa yang kami perhatikan ketika menghitung signifikansi statistik uji A / B</a></li>
<li><a href="../id500920/index.html">Barang Antik: ZX Spectrum dan igrozhur kuno</a></li>
<li><a href="../id500922/index.html">Serigala berbulu domba: cara menangkap hacker yang dengan hati-hati menyamar sebagai pengguna biasa</a></li>
<li><a href="../id500924/index.html">Pertemuan online JUG.ru "Pembuat musim semi" dengan Evgeny Borisov</a></li>
<li><a href="../id500926/index.html">Mengetik dinamis bukan alat pengembangan. Ini omong kosong (buruk)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>