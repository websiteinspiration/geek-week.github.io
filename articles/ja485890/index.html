<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕧 📈 💝 Kerasによるモデルのトレーニングと評価 👴 👨‍🔧 👩🏼‍⚖️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="このガイドでは、2つの一般的な状況でのTensorFlow 2.0のモデルのトレーニング、評価、予測（結論）について説明します。
 
 

- 使用している場合、内蔵のトレーニングと検証のためのAPI（のようなmodel.fit()、model.evaluate()、model.predict()）...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Kerasによるモデルのトレーニングと評価</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/485890/"><img src="https://habrastorage.org/webt/gt/q2/58/gtq258bwdr1hxjw1fwbwup18j3i.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このガイドでは、2つの一般的な状況でのTensorFlow 2.0のモデルのトレーニング、評価、予測（結論）について説明します。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用している場合、内蔵のトレーニングと検証のためのAPI（のような</font></font><code>model.fit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>model.evaluate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>model.predict()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><font style="vertical-align: inherit;">これは、</font><b><font style="vertical-align: inherit;">「組み込みの学習および評価サイクルの使用」</font></b><font style="vertical-align: inherit;">セクションの主題です</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></b></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">熱心な実行とオブジェクトを使用して、ゼロからカスタムループを記述する場合</font></font><code>GradientTape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">これらの問題については、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「独自の学習および評価サイクルを最初から作成する」</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">セクションで説明しています</font><font style="vertical-align: inherit;">。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、組み込みループを使用するか独自のループを作成するかに関係なく、モデルの学習と評価はすべてのタイプのKerasモデルでまったく同じように機能します。FunctionalAPIを使用して作成され、サブクラス化を使用して最初から作成されたシーケンシャルモデル。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">取り付け</font></font></h2><br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> absolute_import, division, print_function, unicode_literals<font></font>
<font></font>
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<font></font>
<font></font>
tf.keras.backend.clear_session()  <span class="hljs-comment"># #     .</span></code></pre><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パートI：組み込みの学習および評価サイクルの使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
組み込みモデルのトレーニングサイクルにデータを転送する場合は、</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpy配列</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（データが小さく、メモリに収まる場合）、または</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dataset tf.data</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトを使用する</font><b><font style="vertical-align: inherit;">必要があり</font></b><font style="vertical-align: inherit;">ます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">次のいくつかの段落では、MNISTデータセットをNumpy配列として使用して、オプティマイザー、損失関数、およびメトリックの使用方法を示します。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">APIの概要：最初の完全な例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のモデルを見てみましょう（Functional APIを使用して作成しますが、シーケンシャルモデルでもサブクラスモデルでもかまいません）。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras
<span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers<font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
典型的な完全なワークフローは次のとおりです。トレーニング、トレーニングソースデータから生成された保留データのチェック、そして最後にテストデータでの評価で構成されています。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#      </span><font></font>
(x_train, y_train), (x_test, y_test) = keras.datasets.mnist.load_data()<font></font>
<font></font>
<span class="hljs-comment">#   (  Numpy)</span>
x_train = x_train.reshape(<span class="hljs-number">60000</span>, <span class="hljs-number">784</span>).astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255</span>
x_test = x_test.reshape(<span class="hljs-number">10000</span>, <span class="hljs-number">784</span>).astype(<span class="hljs-string">'float32'</span>) / <span class="hljs-number">255</span><font></font>
<font></font>
y_train = y_train.astype(<span class="hljs-string">'float32'</span>)<font></font>
y_test = y_test.astype(<span class="hljs-string">'float32'</span>)<font></font>
<font></font>
<span class="hljs-comment">#  10,000   </span>
x_val = x_train[<span class="hljs-number">-10000</span>:]<font></font>
y_val = y_train[<span class="hljs-number">-10000</span>:]<font></font>
x_train = x_train[:<span class="hljs-number">-10000</span>]<font></font>
y_train = y_train[:<span class="hljs-number">-10000</span>]<font></font>
<font></font>
<span class="hljs-comment">#    (,  , )</span>
model.compile(optimizer=keras.optimizers.RMSprop(),  <span class="hljs-comment"># Optimizer</span>
              <span class="hljs-comment">#   </span><font></font>
              loss=keras.losses.SparseCategoricalCrossentropy(),<font></font>
              <span class="hljs-comment">#    </span><font></font>
              metrics=[keras.metrics.SparseCategoricalAccuracy()])<font></font>
<font></font>
<span class="hljs-comment">#      ""</span>
<span class="hljs-comment">#  "batch_size",   </span>
<span class="hljs-comment">#     ""</span>
print(<span class="hljs-string">'#     '</span>)<font></font>
history = model.fit(x_train, y_train,<font></font>
                    batch_size=<span class="hljs-number">64</span>,<font></font>
                    epochs=<span class="hljs-number">3</span>,
                    <span class="hljs-comment">#     </span>
                    <span class="hljs-comment">#       </span>
                    <span class="hljs-comment">#    </span><font></font>
                    validation_data=(x_val, y_val))<font></font>
<font></font>
<span class="hljs-comment">#   "history"  </span>
<span class="hljs-comment">#       </span>
print(<span class="hljs-string">'\nhistory dict:'</span>, history.history)<font></font>
<font></font>
<span class="hljs-comment">#     ,  "evaluate"</span>
print(<span class="hljs-string">'\n#    '</span>)<font></font>
results = model.evaluate(x_test, y_test, batch_size=<span class="hljs-number">128</span>)<font></font>
print(<span class="hljs-string">'test loss, test acc:'</span>, results)<font></font>
<font></font>
<span class="hljs-comment">#   ( -    )</span>
<span class="hljs-comment">#      "predict"</span>
print(<span class="hljs-string">'\n#    3 '</span>)<font></font>
predictions = model.predict(x_test[:<span class="hljs-number">3</span>])<font></font>
print(<span class="hljs-string">' :'</span>, predictions.shape)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">損失、メトリック、およびオプティマイザの定義</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
を使用してモデルをトレーニング</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">するには、損失関数、オプティマイザー、およびオプションでモニタリング用のいくつかのメトリックを設定する必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それらをメソッドの引数としてモデルに渡す必要があります</font></font><code>compile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=keras.losses.SparseCategoricalCrossentropy(),<font></font>
              metrics=[keras.metrics.SparseCategoricalAccuracy()])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数</font></font><code>metrics</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">はリストとして与えられます-モデルは任意の数のメトリックを持つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデルに複数の出力がある場合は、各出力に異なるメトリックと損失関数を設定し、モデル損失の合計値に対する各出力の寄与を調整できます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
多くの場合、損失関数とメトリックは文字列識別子を使用して指定されます。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,<font></font>
              metrics=[<span class="hljs-string">'sparse_categorical_accuracy'</span>])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その後の再利用のために、モデルの定義とコンパイルステップを関数に配置します。</font><font style="vertical-align: inherit;">このガイドの別の例では、それらを数回呼び出します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_uncompiled_model</span>():</span>
  inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
  x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
  x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
  outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
  model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
  <span class="hljs-keyword">return</span> model<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_compiled_model</span>():</span><font></font>
  model = get_uncompiled_model()<font></font>
  model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>,<font></font>
              metrics=[<span class="hljs-string">'sparse_categorical_accuracy'</span>])
  <span class="hljs-keyword">return</span> model
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">多くの組み込みオプティマイザ、損失関数、およびメトリックが利用可能です。</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原則として、独自の損失関数、メトリック、またはオプティマイザを最初から作成する必要はありません。必要なのは、おそらくすでにKeras APIの一部である</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマイザであるためです。</font></font><br>
<br>
<ul>
<li><code>SGD() </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（勢いの有無にかかわらず）</font></font></li>
<li><code>RMSprop()</code></li>
<li><code>Adam()</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
損失関数：</font></font><br>
<br>
<ul>
<li><code>MeanSquaredError()</code></li>
<li><code>KLDivergence()</code></li>
<li><code>CosineSimilarity()</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
指標：</font></font><br>
<br>
<ul>
<li><code>AUC()</code></li>
<li><code>Precision()</code></li>
<li><code>Recall()</code></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタム損失関数</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerasでカスタム損失関数を取得するには2つの方法があります。</font><font style="vertical-align: inherit;">この例では、入力</font></font><code>y_true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font><font style="vertical-align: inherit;">を受け取り</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際のデータと予測の間の平均距離を計算</font><font style="vertical-align: inherit;">する関数が作成されます</font><font style="vertical-align: inherit;">。</font></font><br>
 <br>
<pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">basic_loss_function</span>(<span class="hljs-params">y_true, y_pred</span>):</span>
    <span class="hljs-keyword">return</span> tf.math.reduce_mean(y_true - y_pred)<font></font>
<font></font>
model.compile(optimizer=keras.optimizers.Adam(),<font></font>
              loss=basic_loss_function)<font></font>
<font></font>
model.fit(x_train, y_train, batch_size=<span class="hljs-number">64</span>, epochs=<span class="hljs-number">3</span>)
</code></pre><br><font style="vertical-align: inherit;"></font><code>y_true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">
以外のパラメーターを持つ損失関数が必要な場合は</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、クラス</font></font><code>tf.keras.losses.Loss</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">サブクラス化して</font><font style="vertical-align: inherit;">、次の2つのメソッドを実装</font><font style="vertical-align: inherit;">でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<ul>
<li><code>__init__(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> -損失関数を呼び出すときに渡されるパラメーターを受け入れる</font></font></li>
<li><code>call(self, y_true, y_pred)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-回答（</font></font><code>y_true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）とモデル予測（</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">を使用して</font><font style="vertical-align: inherit;">モデル損失を計算する</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
渡されたパラメータは、</font><font style="vertical-align: inherit;">損失の計算</font></font><code>__init__()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中に使用できます</font></font><code>call()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次の例は</font><font style="vertical-align: inherit;">、特定のクラスまたは関数全体の損失がスカラーを使用して変更できる場所</font></font><code>WeightedCrossEntropy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を計算</font><font style="vertical-align: inherit;">する損失関数を実装する方法を示しています</font></font><code>BinaryCrossEntropy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeightedBinaryCrossEntropy</span>(<span class="hljs-params">keras.losses.Loss</span>):</span>
    <span class="hljs-string">"""
    Args:
      pos_weight:       .
      weight:      .
      from_logits:       .
      reduction:  tf.keras.losses.Reduction     .
      name:   .
    """</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, pos_weight, weight, from_logits=False,
                 reduction=keras.losses.Reduction.AUTO,
                 name=<span class="hljs-string">'weighted_binary_crossentropy'</span></span>):</span><font></font>
        super(WeightedBinaryCrossEntropy, self).__init__(reduction=reduction,<font></font>
                                                         name=name)<font></font>
        self.pos_weight = pos_weight<font></font>
        self.weight = weight<font></font>
        self.from_logits = from_logits<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, y_true, y_pred</span>):</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.from_logits:
            <span class="hljs-comment">#    -.</span>
            <span class="hljs-comment">#   qz * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))</span>
            <span class="hljs-comment">#  z - , x - ,  q - .</span>
            <span class="hljs-comment">#      (   )</span>
            <span class="hljs-comment"># sigmoid(x)    y_pred</span><font></font>
<font></font>
            <span class="hljs-comment"># qz * -log(sigmoid(x)) 1e-6   ,      </span>
            x_1 = y_true * self.pos_weight * -tf.math.log(y_pred + <span class="hljs-number">1e-6</span>)<font></font>
<font></font>
            <span class="hljs-comment"># (1 - z) * -log(1 - sigmoid(x)).  ,      </span>
            x_2 = (<span class="hljs-number">1</span> - y_true) * -tf.math.log(<span class="hljs-number">1</span> - y_pred + <span class="hljs-number">1e-6</span>)<font></font>
<font></font>
            <span class="hljs-keyword">return</span> tf.add(x_1, x_2) * self.weight <font></font>
<font></font>
        <span class="hljs-comment">#   </span>
        <span class="hljs-keyword">return</span> tf.nn.weighted_cross_entropy_with_logits(y_true, y_pred, self.pos_weight) * self.weight<font></font>
<font></font>
<font></font>
model.compile(optimizer=keras.optimizers.Adam(),<font></font>
              loss=WeightedBinaryCrossEntropy(<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>))<font></font>
<font></font>
model.fit(x_train, y_train, batch_size=<span class="hljs-number">64</span>, epochs=<span class="hljs-number">3</span>)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">カスタムメトリック</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
APIの一部ではない指標が必要な場合は、クラスをサブクラス化することで簡単にカスタム指標を作成できます</font></font><code>Metric</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">4つのメソッドを実装する必要があります。</font></font><br>
<br>
<ul>
<li><code>__init__(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ここで、メトリックの状態変数を作成します。</font></font></li>
<li><code>update_state(self, y_true, y_pred, sample_weight=None)</code><font style="vertical-align: inherit;"></font><code>y_true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルの</font><font style="vertical-align: inherit;">応答</font><font style="vertical-align: inherit;">と予測</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">使用して</font><font style="vertical-align: inherit;">状態変数を更新します。</font></font></li>
<li><code>result(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状態変数を使用して最終結果を計算します。</font></font></li>
<li><code>reset_states(self)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックの状態を再初期化します。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
状態を更新し、結果を計算すること（に別々に格納されている</font></font><code>update_state()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>result()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">いくつかのケースでは、結果を計算することは非常に高価であることができ、周期的にのみ行われるので、それに応じて）。</font><font style="vertical-align: inherit;">このクラスに属するものとして正しく分類された要素の数をカウント</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
するメトリックを実装する方法を示す簡単な例を次に示します</font></font><code>CategoricalTruePositives</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoricalTruePositives</span>(<span class="hljs-params">keras.metrics.Metric</span>):</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">'categorical_true_positives'</span>, **kwargs</span>):</span><font></font>
      super(CategoricalTruePositives, self).__init__(name=name, **kwargs)<font></font>
      self.true_positives = self.add_weight(name=<span class="hljs-string">'tp'</span>, initializer=<span class="hljs-string">'zeros'</span>)<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update_state</span>(<span class="hljs-params">self, y_true, y_pred, sample_weight=None</span>):</span>
      y_pred = tf.reshape(tf.argmax(y_pred, axis=<span class="hljs-number">1</span>), shape=(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>))<font></font>
      values = tf.cast(y_true, <span class="hljs-string">'int32'</span>) == tf.cast(y_pred, <span class="hljs-string">'int32'</span>)<font></font>
      values = tf.cast(values, <span class="hljs-string">'float32'</span>)
      <span class="hljs-keyword">if</span> sample_weight <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<font></font>
        sample_weight = tf.cast(sample_weight, <span class="hljs-string">'float32'</span>)<font></font>
        values = tf.multiply(values, sample_weight)<font></font>
      self.true_positives.assign_add(tf.reduce_sum(values))<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">result</span>(<span class="hljs-params">self</span>):</span>
      <span class="hljs-keyword">return</span> self.true_positives<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset_states</span>(<span class="hljs-params">self</span>):</span>
      <span class="hljs-comment">#        .</span>
      self.true_positives.assign(<span class="hljs-number">0.</span>)<font></font>
<font></font>
<font></font>
model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=keras.losses.SparseCategoricalCrossentropy(),<font></font>
              metrics=[CategoricalTruePositives()])<font></font>
model.fit(x_train, y_train,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">3</span>)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準の署名と一致しない損失関数とメトリックの処理</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
損失とメトリクスの大半はから計算することができる</font></font><code>y_true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">場合は、</font></font><code>y_pred</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">お使いのモデルの出力があります。</font><font style="vertical-align: inherit;">すべてではありません。</font><font style="vertical-align: inherit;">たとえば、正則化損失はレイヤーのアクティブ化のみを必要とする場合があり（この場合、ターゲット値はありません）、このアクティブ化はモデルの出力ではない場合があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような場合、</font><font style="vertical-align: inherit;">カスタムレイヤー</font></font><code>self.add_loss(loss_value)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メソッドから</font><font style="vertical-align: inherit;">呼び出すことができます</font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">以下は、アクティビティの正則化を追加する簡単な例です（アクティビティの正則化はすべてのKerasレイヤーに組み込まれていることに注意してください-このレイヤーは特定の例を示すためにのみ使用されます）：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityRegularizationLayer</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span>
    self.add_loss(tf.reduce_sum(inputs) * <span class="hljs-number">0.1</span>)
    <span class="hljs-keyword">return</span> inputs  <span class="hljs-comment"># Pass-through layer.</span><font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
<font></font>
<span class="hljs-comment">#      </span><font></font>
x = ActivityRegularizationLayer()(x)<font></font>
<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>)<font></font>
<font></font>
<span class="hljs-comment">#       </span>
<span class="hljs-comment"># -  .</span><font></font>
model.fit(x_train, y_train,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メトリック値のロギングについても同じことができます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MetricLoggingLayer</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span>
    <span class="hljs-comment">#  `aggregation` </span>
    <span class="hljs-comment">#    </span>
    <span class="hljs-comment">#   :</span>
    <span class="hljs-comment">#       .</span><font></font>
    self.add_metric(keras.backend.std(inputs),<font></font>
                    name=<span class="hljs-string">'std_of_activation'</span>,<font></font>
                    aggregation=<span class="hljs-string">'mean'</span>)
    <span class="hljs-keyword">return</span> inputs  <span class="hljs-comment">#  .</span><font></font>
<font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
<font></font>
<span class="hljs-comment">#   std   .</span><font></font>
x = MetricLoggingLayer()(x)<font></font>
<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
model.compile(optimizer=keras.optimizers.RMSprop(learning_rate=<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>)<font></font>
model.fit(x_train, y_train,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
機能APIでは</font></font><code>model.add_loss(loss_tensor)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、またはを</font><font style="vertical-align: inherit;">呼び出すこともできます</font></font><code>model.add_metric(metric_tensor, name, aggregation)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に簡単な例を示します。</font></font><br>
<br>
<pre><code class="python hljs">inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x1 = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
x2 = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x1)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x2)<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
<font></font>
model.add_loss(tf.reduce_sum(x1) * <span class="hljs-number">0.1</span>)<font></font>
<font></font>
model.add_metric(keras.backend.std(x1),<font></font>
                 name=<span class="hljs-string">'std_of_activation'</span>,<font></font>
                 aggregation=<span class="hljs-string">'mean'</span>)<font></font>
<font></font>
model.compile(optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
              loss=<span class="hljs-string">'sparse_categorical_crossentropy'</span>)<font></font>
model.fit(x_train, y_train,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">1</span>)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証延期セットの自動割り当て</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の完全な例では、</font></font><code>validation_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ご覧のとおり</font><font style="vertical-align: inherit;">、引数を使用して</font><font style="vertical-align: inherit;">Numpy配列のタプルを</font></font><code>(x_val, y_val)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルに</font><font style="vertical-align: inherit;">渡し、</font><font style="vertical-align: inherit;">各時代の終わりに検証の損失とメトリックを評価しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のオプションを次に示します。この引数を</font></font><code>validation_split</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用すると、検証用にトレーニングデータの一部を自動的に予約できます。引数の値は、検証のために予約する必要があるデータの割合であるため、値は0より大きく1未満である必要があります。たとえば、</font></font><code>validation_split=0.2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「検証にデータの20％を使用」、</font></font><code>validation_split=0.6</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">つまり「検証にデータの60％を使用」</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">意味します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証は、によって計算される</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールで受信されたアレイ・レコードの最後のx％を取って</font></font></i> <code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">任意の混合の前に</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは使うことができます</font></font><code>validation_split</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Numpyデータでモデルをトレーニングする場合のみ。</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
model.fit(x_train, y_train, batch_size=<span class="hljs-number">64</span>, validation_split=<span class="hljs-number">0.2</span>, epochs=<span class="hljs-number">1</span>, steps_per_epoch=<span class="hljs-number">1</span>)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tf.dataデータセットを使用したトレーニングと評価</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最後のいくつかの段落では、あなたは損、評価指標、およびオプティマイザーをどのように処理するかを見て、あなたは引数を使用する方法を見て</font></font><code>validation_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>validation_split</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あなたのデータはnumpyの配列として渡されたとき。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次に、データがデータセットtf.dataの形式である場合を見てみましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
tf.data APIは、高速でスケーラブルな方法でデータを読み込んで前処理するためのTensorFlow 2.0のユーティリティセットです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは、メソッドに直接データセットのインスタンスを渡すことができ</font></font><code>fit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>evaluate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">そして</font></font><code>predict()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
<span class="hljs-comment">#      Dataset.</span>
<span class="hljs-comment">#          MNIST   .</span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
<span class="hljs-comment">#     .</span>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<span class="hljs-comment">#    .</span><font></font>
test_dataset = tf.data.Dataset.from_tensor_slices((x_test, y_test))<font></font>
test_dataset = test_dataset.batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<span class="hljs-comment">#        ,</span>
<span class="hljs-comment">#     `batch_size`.</span>
model.fit(train_dataset, epochs=<span class="hljs-number">3</span>)<font></font>
<font></font>
<span class="hljs-comment">#          .</span>
print(<span class="hljs-string">'\n# '</span>)<font></font>
model.evaluate(test_dataset)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
データセットは各時代の終わりにリセットされるため、次の時代に再利用できることに注意してください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータセットの特定の数のパッケージからのみ学習する場合は、 `steps_per_epoch`引数を渡すことができます。これは、次の時代に進む前に、このデータセットを使用してモデルが使用するトレーニングステップの数を示します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この場合、データセットは各時代の終わりにリセットされず、代わりに次のパケットの処理を続行します。</font><font style="vertical-align: inherit;">データは最終的にデータセットで終わる可能性があります（無限ループのデータセットでない限り）。</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<span class="hljs-comment">#   100    ( 64 * 100 )</span>
model.fit(train_dataset.take(<span class="hljs-number">100</span>), epochs=<span class="hljs-number">3</span>)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証データセットの使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは、引数としてデータセットのインスタンスを渡すことができます</font></font><code>validation_data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">します</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
val_dataset = tf.data.Dataset.from_tensor_slices((x_val, y_val))<font></font>
val_dataset = val_dataset.batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
model.fit(train_dataset, epochs=<span class="hljs-number">3</span>, validation_data=val_dataset)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
各時代の終わりに、モデルは検証データセットを通過し、検証の損失とメトリックを計算します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このデータセットから特定の数のパッケージに対してのみ検証を実行する場合は、</font></font><code>validation_steps</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">検証を終了して次の時代に進む前にモデルが完了する必要がある検証ステップの数を示す</font><font style="vertical-align: inherit;">引数</font><font style="vertical-align: inherit;">を</font><font style="vertical-align: inherit;">渡すことができ</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
val_dataset = tf.data.Dataset.from_tensor_slices((x_val, y_val))<font></font>
val_dataset = val_dataset.batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
model.fit(train_dataset, epochs=<span class="hljs-number">3</span>,
          <span class="hljs-comment">#      10  </span>
          <span class="hljs-comment">#   `validation_steps`</span>
          validation_data=val_dataset, validation_steps=<span class="hljs-number">10</span>)
</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
検証データセットは使用のたびにリセットされることに注意してください（そのため、常に同じ例についての時代ごとの評価が得られます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数</font></font><code>validation_split</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（トレーニングデータから遅延サンプルを生成する）は、Datasetオブジェクトでトレーニングする場合はサポートされていません。これには、要素にインデックスを付ける機能が必要になるため、通常Dataset APIでは不可能です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その他のサポートされている入力形式</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
NumpyおよびTensorFlow Dataset配列に加えて、Pandasデータフレームを使用して、またはバッチで値を提供するPythonジェネレーターを使用して、Kerasモデルをトレーニングできます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、数値が小さくメモリに収まる場合はNumpy入力を使用し、それ以外の場合はデータセットを使用することをお勧めします。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">例とクラスに重みを使用する</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力ラベルとモデルラベルに加えて、次を使用する場合は、例の重みとクラスの重みを転送できます</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Numpyデータでトレーニングする場合：引数 `sample_weight`および` class_weight`を使用します。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Datasetでトレーニングする場合：Datasetがタプル `（input_batch、target_batch、sample_weight_batch）`を返す場合。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「サンプルの重み」配列は、損失値を計算するときにパケットの各要素に与える重みの量を決定する数値の配列です。このプロパティは通常、不均衡な分類の問題で使用されます（重要なのは、まれなクラスにより多くの重みを与えることです）。使用される重みが1と0に等しい場合、配列</font><font style="vertical-align: inherit;">は損失関数の</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">マスク</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">として使用できます</font><font style="vertical-align: inherit;">（損失の合計値に対する特定の要素の影響を完全に排除します）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
辞書「クラスの重み」は、同じ概念のより具体的なインスタンスです。このクラスに属する要素に使用する必要がある重みクラスインデックスを比較します。たとえば、データのクラス「0」がクラス「1」より3倍小さい場合、を使用できます</font></font><code>class_weight={0: 1., 1: 0.5}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Numpyクラスの重みと要素の重みの例を以下に示します。これにより、クラス＃5（MNISTデータセットの番号「5」に対応）の正しい分類をより重要にすることができます。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<font></font>
<font></font>
class_weight = {<span class="hljs-number">0</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">1</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">2</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">3</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">4</span>: <span class="hljs-number">1.</span>,
                <span class="hljs-comment">#   "2"   "5",</span>
                <span class="hljs-comment">#     2x  </span>
                <span class="hljs-number">5</span>: <span class="hljs-number">2.</span>,
                <span class="hljs-number">6</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">7</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">8</span>: <span class="hljs-number">1.</span>, <span class="hljs-number">9</span>: <span class="hljs-number">1.</span>}<font></font>
print(<span class="hljs-string">'   '</span>)<font></font>
model.fit(x_train, y_train,<font></font>
          class_weight=class_weight,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">4</span>)<font></font>
<font></font>
<span class="hljs-comment">#      `sample_weight`:</span><font></font>
sample_weight = np.ones(shape=(len(y_train),))<font></font>
sample_weight[y_train == <span class="hljs-number">5</span>] = <span class="hljs-number">2.</span>
print(<span class="hljs-string">'\n   '</span>)<font></font>
<font></font>
model = get_compiled_model()<font></font>
model.fit(x_train, y_train,<font></font>
          sample_weight=sample_weight,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          epochs=<span class="hljs-number">4</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下は、対応するデータセットの例です。</font></font><br>
<br>
<pre><code class="python hljs">sample_weight = np.ones(shape=(len(y_train),))<font></font>
sample_weight[y_train == <span class="hljs-number">5</span>] = <span class="hljs-number">2.</span><font></font>
<font></font>
<span class="hljs-comment">#   Dataset   </span>
<span class="hljs-comment"># (3-    ).</span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices(<font></font>
    (x_train, y_train, sample_weight))<font></font>
<font></font>
<span class="hljs-comment">#    .</span>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
model = get_compiled_model()<font></font>
model.fit(train_dataset, epochs=<span class="hljs-number">3</span>)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">複数の入力と出力を持つモデルでのデータ転送</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例では、単一の入力（サイズテンソル</font></font><code>(764,)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と1つの出力（サイズ予測子テンソル</font></font><code>(10,)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）を</font><font style="vertical-align: inherit;">持つモデルを検討しました</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">しかし、複数の入力または出力を持つモデルはどうでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
入力データがサイズ画像</font></font><code>(32, 32, 3)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（this </font></font><code>(height, width, channels)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と時系列サイズ</font></font><code>(None, 10)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（this </font></font><code>(timesteps, features)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">である次のモデルを考えます</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">私たちのモデルには、これらの入力の組み合わせから計算された2つの出力があります。「スコア」（ディメンション</font></font><code>(1,)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）と5つのクラスの確率分布（ディメンション</font></font><code>(5,)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）です。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras
<span class="hljs-keyword">from</span> tensorflow.keras <span class="hljs-keyword">import</span> layers<font></font>
<font></font>
image_input = keras.Input(shape=(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>), name=<span class="hljs-string">'img_input'</span>)<font></font>
timeseries_input = keras.Input(shape=(<span class="hljs-literal">None</span>, <span class="hljs-number">10</span>), name=<span class="hljs-string">'ts_input'</span>)<font></font>
<font></font>
x1 = layers.Conv2D(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)(image_input)<font></font>
x1 = layers.GlobalMaxPooling2D()(x1)<font></font>
<font></font>
x2 = layers.Conv1D(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>)(timeseries_input)<font></font>
x2 = layers.GlobalMaxPooling1D()(x2)<font></font>
<font></font>
x = layers.concatenate([x1, x2])<font></font>
<font></font>
score_output = layers.Dense(<span class="hljs-number">1</span>, name=<span class="hljs-string">'score_output'</span>)(x)<font></font>
class_output = layers.Dense(<span class="hljs-number">5</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'class_output'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=[image_input, timeseries_input],<font></font>
                    outputs=[score_output, class_output])<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このモデルを描画して、ここで何をしているのかが明確にわかるようにします（図に表示されている寸法は、パケット単位の寸法であり、要素単位の寸法ではありません）。</font></font><br>
<br>
<pre><code class="python hljs">keras.utils.plot_model(model, <span class="hljs-string">'multi_input_and_output_model.png'</span>, show_shapes=<span class="hljs-literal">True</span>)</code></pre><br>
<img src="https://habrastorage.org/webt/lg/85/tn/lg85tn_0a8cc-c8zxzhoxyrxdn4.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイル中に、さまざまな出力にさまざまな損失関数を指定して、損失関数をリストで渡すことができます。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss=[keras.losses.MeanSquaredError(),<font></font>
          keras.losses.CategoricalCrossentropy()])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
モデル損失関数を1つだけ転送すると、各出力に適用されるため、ここでは適していません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同様に、指標の場合：</font></font><br>
<br>
<pre><code class="python hljs">model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss=[keras.losses.MeanSquaredError(),<font></font>
          keras.losses.CategoricalCrossentropy()],<font></font>
    metrics=[[keras.metrics.MeanAbsolutePercentageError(),<font></font>
              keras.metrics.MeanAbsoluteError()],<font></font>
             [keras.metrics.CategoricalAccuracy()]])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
出力レイヤーに名前を付けたので、dictの各出力の損失関数とメトリックを指定することもできます。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss={<span class="hljs-string">'score_output'</span>: keras.losses.MeanSquaredError(),
          <span class="hljs-string">'class_output'</span>: keras.losses.CategoricalCrossentropy()},<font></font>
    metrics={<span class="hljs-string">'score_output'</span>: [keras.metrics.MeanAbsolutePercentageError(),<font></font>
                              keras.metrics.MeanAbsoluteError()],<font></font>
             <span class="hljs-string">'class_output'</span>: [keras.metrics.CategoricalAccuracy()]})
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3つ以上の出力がある場合は、名前と辞書を使用することをお勧めします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
引数を使用して、異なる損失関数に異なる重みを割り当てることができます（たとえば、この例では、「スコア」損失を優先し、クラス損失の重要度を2倍に増やすことができます）</font></font><code>loss_weights</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss={<span class="hljs-string">'score_output'</span>: keras.losses.MeanSquaredError(),
          <span class="hljs-string">'class_output'</span>: keras.losses.CategoricalCrossentropy()},<font></font>
    metrics={<span class="hljs-string">'score_output'</span>: [keras.metrics.MeanAbsolutePercentageError(),<font></font>
                              keras.metrics.MeanAbsoluteError()],<font></font>
             <span class="hljs-string">'class_output'</span>: [keras.metrics.CategoricalAccuracy()]},<font></font>
    loss_weights={<span class="hljs-string">'score_output'</span>: <span class="hljs-number">2.</span>, <span class="hljs-string">'class_output'</span>: <span class="hljs-number">1.</span>})
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一部の出力が予測のみを目的としており、トレーニングを目的としていない場合、一部の出力の損失を計算することもできません。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#   </span><font></font>
model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss=[<span class="hljs-literal">None</span>, keras.losses.CategoricalCrossentropy()])<font></font>
<font></font>
<span class="hljs-comment">#   </span><font></font>
model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss={<span class="hljs-string">'class_output'</span>: keras.losses.CategoricalCrossentropy()})</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
複数の入力と出力を持つモデルへのデータ転送</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、の損失関数の定義と同様</font><font style="vertical-align: inherit;">に</font><font style="vertical-align: inherit;">行わ</font></font><code>compile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れ</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ます。Numpy配列のリスト（損失関数を持つ出力と1：1に</font></font></i><font style="vertical-align: inherit;"></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一致</font></font></i><font style="vertical-align: inherit;"><i><font style="vertical-align: inherit;">）</font></i><font style="vertical-align: inherit;">または</font><i><font style="vertical-align: inherit;">出力の名前をトレーニングデータのNumpy配列に一致する辞書を転送できます</font></i><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">model.compile(<font></font>
    optimizer=keras.optimizers.RMSprop(<span class="hljs-number">1e-3</span>),<font></font>
    loss=[keras.losses.MeanSquaredError(),<font></font>
          keras.losses.CategoricalCrossentropy()])<font></font>
<font></font>
<span class="hljs-comment">#   Numpy </span>
img_data = np.random.random_sample(size=(<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>))<font></font>
ts_data = np.random.random_sample(size=(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>))<font></font>
score_targets = np.random.random_sample(size=(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>))<font></font>
class_targets = np.random.random_sample(size=(<span class="hljs-number">100</span>, <span class="hljs-number">5</span>))<font></font>
<font></font>
<span class="hljs-comment">#       </span><font></font>
model.fit([img_data, ts_data], [score_targets, class_targets],<font></font>
          batch_size=<span class="hljs-number">32</span>,<font></font>
          epochs=<span class="hljs-number">3</span>)<font></font>
<font></font>
<span class="hljs-comment">#       </span>
model.fit({<span class="hljs-string">'img_input'</span>: img_data, <span class="hljs-string">'ts_input'</span>: ts_data},<font></font>
          {<span class="hljs-string">'score_output'</span>: score_targets, <span class="hljs-string">'class_output'</span>: class_targets},<font></font>
          batch_size=<span class="hljs-number">32</span>,<font></font>
          epochs=<span class="hljs-number">3</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下はDatasetの例です。Numpy配列と同様に、Datasetはディクショナリタプルを返す必要があります。</font></font><br>
<br>
<pre><code class="python hljs">train_dataset = tf.data.Dataset.from_tensor_slices(<font></font>
    ({<span class="hljs-string">'img_input'</span>: img_data, <span class="hljs-string">'ts_input'</span>: ts_data},<font></font>
     {<span class="hljs-string">'score_output'</span>: score_targets, <span class="hljs-string">'class_output'</span>: class_targets}))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
model.fit(train_dataset, epochs=<span class="hljs-number">3</span>)</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kerasでのコールバックは（など、時代の終わりに、パッケージの終わりに、時代の初めに）トレーニング中に異なる場所に呼ばれ、このような動作を実装するために使用できるオブジェクトです：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
全体のさまざまなポイントで検証を実行しますトレーニング時間（各時代の終わりに組み込まれた検証を除く）</font></font><br>
 <br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">定期的に、または特定の精度しきい値を超えたときに、モデルのブレークポイントを設定します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学習が収束していないように思われるときにモデルの学習速度を変更する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングが収束しなくなったように見える場合は、上層を微調整します</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングが終了したとき、または特定のパフォーマンスしきい値を超えたときにメールまたはメッセージを送信する</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コールバックは、呼び出されたときにリストによって転送できます</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
callbacks = [<font></font>
    keras.callbacks.EarlyStopping(<font></font>
        <span class="hljs-comment">#    `val_loss`   </span>
        monitor=<span class="hljs-string">'val_loss'</span>,
        <span class="hljs-comment"># "  "   "   1e-2  "</span>
        min_delta=<span class="hljs-number">1e-2</span>,
        <span class="hljs-comment"># "  "    "    2 "</span>
        patience=<span class="hljs-number">2</span>,<font></font>
        verbose=<span class="hljs-number">1</span>)<font></font>
]<font></font>
model.fit(x_train, y_train,<font></font>
          epochs=<span class="hljs-number">20</span>,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          callbacks=callbacks,<font></font>
          validation_split=<span class="hljs-number">0.2</span>)</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ユーザーは多数の組み込みコールバックを使用できます。</font></font></h4><br>
<ul>
<li><code>ModelCheckpoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：定期的にモデルを保存します。</font></font></li>
<li><code>EarlyStopping</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：検証メトリックの改善が止まったときにトレーニングを停止します。</font></font></li>
<li><code>TensorBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：TensorBoardで可視化できるモデルのログを定期的に書き込みます（詳細については、「可視化」を参照してください）。</font></font></li>
<li><code>CSVLogger</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：損失値とメトリックをCSVファイルにストリーミングします。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等</font></font></li>
</ul><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">独自のコールバックを書く</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
keras.callbacks.Callback基本クラスを展開することで、独自のコールバックを作成できます。</font><font style="vertical-align: inherit;">コールバックは、クラスプロパティを通じて関連するモデルにアクセスできます</font></font><code>self.model</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニング中にパケット損失値のリストを保存する簡単な例を次に示します。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LossHistory</span>(<span class="hljs-params">keras.callbacks.Callback</span>):</span><font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_train_begin</span>(<span class="hljs-params">self, logs</span>):</span><font></font>
        self.losses = []<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_batch_end</span>(<span class="hljs-params">self, batch, logs</span>):</span>
        self.losses.append(logs.get(<span class="hljs-string">'loss'</span>))</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">モデルブレークポイントの保存</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
比較的大きなデータセットでモデルをトレーニングする場合、モデルのチェックポイントを定期的に維持することが不可欠です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを行う最も簡単な方法は、コールバックを使用すること</font></font><code>ModelCheckpoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<pre><code class="python hljs">model = get_compiled_model()<font></font>
<font></font>
callbacks = [<font></font>
    keras.callbacks.ModelCheckpoint(<font></font>
        filepath=<span class="hljs-string">'mymodel_{epoch}.h5'</span>,
        <span class="hljs-comment">#      </span>
        <span class="hljs-comment">#       </span>
        <span class="hljs-comment">#         , </span>
        <span class="hljs-comment">#   `val_loss`.</span>
        save_best_only=<span class="hljs-literal">True</span>,<font></font>
        monitor=<span class="hljs-string">'val_loss'</span>,<font></font>
        verbose=<span class="hljs-number">1</span>)<font></font>
]<font></font>
model.fit(x_train, y_train,<font></font>
          epochs=<span class="hljs-number">3</span>,<font></font>
          batch_size=<span class="hljs-number">64</span>,<font></font>
          callbacks=callbacks,<font></font>
          validation_split=<span class="hljs-number">0.2</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
独自のコールバックを記述して、モデルを保存および復元することもできます。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">学習速度のグラフの使用</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
深層学習モデルをトレーニングするときの一般的なパターンは、モデルをトレーニングするときに徐々に学習速度を低下させることです。</font><font style="vertical-align: inherit;">これは一般に「学習速度の低下」として知られています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
速度低下のグラフは、静的（現在の時代または現在のパッケージのインデックスの関数として事前に固定）または動的（モデルの現在の動作、特に検証損失に応じて）のいずれかになります。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">スケジュールをオプティマイザに渡す</font></font></h4><br><font style="vertical-align: inherit;"></font><code>learning_rate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オプティマイザに</font><font style="vertical-align: inherit;">
引数としてスケジュールオブジェクトを渡すことにより、学習速度の静的な低下のグラフを簡単に使用でき</font><font style="vertical-align: inherit;">ます。</font></font><br>
<br>
<pre><code class="python hljs">initial_learning_rate = <span class="hljs-number">0.1</span><font></font>
lr_schedule = keras.optimizers.schedules.ExponentialDecay(<font></font>
    initial_learning_rate,<font></font>
    decay_steps=<span class="hljs-number">100000</span>,<font></font>
    decay_rate=<span class="hljs-number">0.96</span>,<font></font>
    staircase=<span class="hljs-literal">True</span>)<font></font>
<font></font>
optimizer = keras.optimizers.RMSprop(learning_rate=lr_schedule)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：あり内蔵の回路のいくつかは、学習率を低減している</font></font><code>ExponentialDecay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>PiecewiseConstantDecay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、</font></font><code>PolynomialDecay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>InverseTimeDecay</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コールバックを使用して動的に変化する学習速度のスケジュールを実装する</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オプティマイザが検証インジケータにアクセスできないため、これらのスケジュールオブジェクトでは、学習速度を動的に変更するスケジュール（たとえば、検証中の損失が改善されなくなったときに学習速度を下げる）を達成できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、コールバックは検証メトリックを含むすべてのメトリックにアクセスできます！</font><font style="vertical-align: inherit;">したがって、オプティマイザの現在の学習速度を変更するコールバックを使用してこのパターンを実現できます。</font><font style="vertical-align: inherit;">実際、組み込みのコールバックもあります</font></font><code>ReduceLROnPlateau</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニング中の損失と測定基準の視覚化</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニング中にモデルを追跡する最良の方法は、TensorBoardを使用することです。TensorBoardは、ローカルで実行でき、次の機能を提供するブラウザーベースのアプリケーションです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">トレーニングと評価のための損失関数とメトリックのライブグラフ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプション）レイヤーのアクティブ化のヒストグラムの視覚化</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（オプション）</font></font><code>Embedding</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">レイヤーが</font><font style="vertical-align: inherit;">探索したネスト空間の3D視覚化</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tipをpipを使用してインストールした場合は、コマンドラインからTensorBoardを起動できます。</font></font><br>
<br>
<pre><code class="python hljs">tensorboard --logdir=/full_path_to_your_logs</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TensorBoardの使用</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
KerasモデルとメソッドでTensorBoardを使用する最も簡単な方法</font></font><code>fit</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、コールバックすること</font></font><code>TensorBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最も単純なケースでは、コールバックでログを書き込む場所を指定するだけで完了です。</font></font><br>
<br>
<pre><code class="python hljs">tensorboard_cbk = keras.callbacks.TensorBoard(log_dir=<span class="hljs-string">'/full_path_to_your_logs'</span>)<font></font>
model.fit(dataset, epochs=<span class="hljs-number">10</span>, callbacks=[tensorboard_cbk])</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kolbekに</font></font><code>TensorBoard</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は、添付ファイル、ヒストグラムのログを書き込むかどうか、ログを書き込む</font><font style="vertical-align: inherit;">頻度</font><font style="vertical-align: inherit;">など、多くの便利なオプションがあります。</font></font><br>
<br>
<pre><code class="python hljs">keras.callbacks.TensorBoard(<font></font>
  log_dir=<span class="hljs-string">'/full_path_to_your_logs'</span>,<font></font>
  histogram_freq=<span class="hljs-number">0</span>,  <span class="hljs-comment">#      </span>
  embeddings_freq=<span class="hljs-number">0</span>,  <span class="hljs-comment">#      </span>
  update_freq=<span class="hljs-string">'epoch'</span>)  <span class="hljs-comment">#     ( :   )</span></code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パートII：独自の学習および評価サイクルをゼロから作成する</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
あなたは、彼らが与えるものよりもあなたのトレーニングと評価のサイクルの低いレベルを必要とする場合</font></font><code>fit()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と</font></font><code>evaluate()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、あなたはあなた自身を記述する必要があります。</font><font style="vertical-align: inherit;">それは実際には非常に簡単です！</font><font style="vertical-align: inherit;">ただし、さらにデバッグする準備をする必要があります。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GradientTapeの使用：最初の完全な例</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
スコープ内でモデルを呼び出す</font></font><code>GradientTape</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">と、損失値に対するトレーニング済みレイヤーの重みの勾配を取得できます。</font><font style="vertical-align: inherit;">オプティマイザーインスタンスを使用すると、これらの勾配を使用して変数を更新できます（変数はで取得できます</font></font><code>model.trainable_weights</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初の部分から元のMNISTモデルを再利用し、カスタム学習サイクルを備えたミニバッチ勾配降下法を使用してトレーニングします。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#  .</span>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
<font></font>
<span class="hljs-comment">#   .</span>
optimizer = keras.optimizers.SGD(learning_rate=<span class="hljs-number">1e-3</span>)
<span class="hljs-comment"># Instantiate a loss function.</span>
loss_fn = keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="hljs-literal">True</span>)<font></font>
<font></font>
<span class="hljs-comment">#   .</span>
batch_size = <span class="hljs-number">64</span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(batch_size)<font></font>
<font></font>
<span class="hljs-comment">#   .</span>
epochs = <span class="hljs-number">3</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(epochs):<font></font>
  print(<span class="hljs-string">'  %d'</span> % (epoch,))<font></font>
<font></font>
  <span class="hljs-comment">#     .</span>
  <span class="hljs-keyword">for</span> step, (x_batch_train, y_batch_train) <span class="hljs-keyword">in</span> enumerate(train_dataset):<font></font>
<font></font>
    <span class="hljs-comment">#  GradientTape   </span>
    <span class="hljs-comment">#     ,  .</span>
    <span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<font></font>
<font></font>
      <span class="hljs-comment">#    .</span>
      <span class="hljs-comment">#     </span>
      <span class="hljs-comment">#    </span>
      <span class="hljs-comment">#  GradientTape.</span>
      logits = model(x_batch_train, training=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># Logits for this minibatch</span><font></font>
<font></font>
      <span class="hljs-comment">#      .</span><font></font>
      loss_value = loss_fn(y_batch_train, logits)<font></font>
<font></font>
    <span class="hljs-comment">#  gradient tape    </span>
    <span class="hljs-comment">#    .</span><font></font>
    grads = tape.gradient(loss_value, model.trainable_weights)<font></font>
<font></font>
    <span class="hljs-comment">#      </span>
    <span class="hljs-comment">#    .</span><font></font>
    optimizer.apply_gradients(zip(grads, model.trainable_weights))<font></font>
<font></font>
    <span class="hljs-comment">#    200 .</span>
    <span class="hljs-keyword">if</span> step % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<font></font>
        print(<span class="hljs-string">'   (  )   %s: %s'</span> % (step, float(loss_value)))<font></font>
        print(<span class="hljs-string">' : %s '</span> % ((step + <span class="hljs-number">1</span>) * <span class="hljs-number">64</span>))
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">低レベルのメトリック処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
メトリックを見てみましょう。</font><font style="vertical-align: inherit;">ゼロから作成されたトレーニングサイクルでは、組み込みメトリック（または独自に作成したメトリック）を簡単に使用できます。</font><font style="vertical-align: inherit;">アクションのシーケンスは次のとおりです。</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ループの開始時にメトリックのインスタンスを作成し、</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>metric.update_state()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">各パケットの後に</font><font style="vertical-align: inherit;">呼び出す</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>metric.result()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">現在のメトリック値を表示する必要があるときに</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">ます。</font></font></li>
<li><font style="vertical-align: inherit;"></font><code>metric.reset_states()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">メトリックの状態をクリアする必要があるときに</font><font style="vertical-align: inherit;">呼び出し</font><font style="vertical-align: inherit;">ます（通常、各時代の終わり）</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この知識を使用</font></font><code>SparseCategoricalAccuracy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">して、各時代の終わりに検証データ</font><font style="vertical-align: inherit;">を頼りに</font><font style="vertical-align: inherit;">し</font><font style="vertical-align: inherit;">ましょう</font><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-comment">#  </span>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
<font></font>
<span class="hljs-comment">#      .</span>
optimizer = keras.optimizers.SGD(learning_rate=<span class="hljs-number">1e-3</span>)
<span class="hljs-comment">#    .</span><font></font>
loss_fn = keras.losses.SparseCategoricalCrossentropy()<font></font>
<font></font>
<span class="hljs-comment">#  .</span><font></font>
train_acc_metric = keras.metrics.SparseCategoricalAccuracy()<font></font>
val_acc_metric = keras.metrics.SparseCategoricalAccuracy()<font></font>
<font></font>
<span class="hljs-comment">#   .</span>
batch_size = <span class="hljs-number">64</span><font></font>
train_dataset = tf.data.Dataset.from_tensor_slices((x_train, y_train))<font></font>
train_dataset = train_dataset.shuffle(buffer_size=<span class="hljs-number">1024</span>).batch(batch_size)<font></font>
<font></font>
<span class="hljs-comment">#   .</span><font></font>
val_dataset = tf.data.Dataset.from_tensor_slices((x_val, y_val))<font></font>
val_dataset = val_dataset.batch(<span class="hljs-number">64</span>)<font></font>
<font></font>
<font></font>
<span class="hljs-comment">#   .</span>
epochs = <span class="hljs-number">3</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(epochs):<font></font>
  print(<span class="hljs-string">'  %d'</span> % (epoch,))<font></font>
<font></font>
  <span class="hljs-comment">#     .</span>
  <span class="hljs-keyword">for</span> step, (x_batch_train, y_batch_train) <span class="hljs-keyword">in</span> enumerate(train_dataset):
    <span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<font></font>
      logits = model(x_batch_train)<font></font>
      loss_value = loss_fn(y_batch_train, logits)<font></font>
    grads = tape.gradient(loss_value, model.trainable_weights)<font></font>
    optimizer.apply_gradients(zip(grads, model.trainable_weights))<font></font>
<font></font>
    <span class="hljs-comment">#    .</span><font></font>
    train_acc_metric(y_batch_train, logits)<font></font>
<font></font>
    <span class="hljs-comment">#    200 .</span>
    <span class="hljs-keyword">if</span> step % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<font></font>
        print(<span class="hljs-string">'   (  )   %s: %s'</span> % (step, float(loss_value)))<font></font>
        print(<span class="hljs-string">' : %s '</span> % ((step + <span class="hljs-number">1</span>) * <span class="hljs-number">64</span>))<font></font>
<font></font>
  <span class="hljs-comment">#      .</span><font></font>
  train_acc = train_acc_metric.result()<font></font>
  print(<span class="hljs-string">'Accuracy    : %s'</span> % (float(train_acc),))
  <span class="hljs-comment">#       </span><font></font>
  train_acc_metric.reset_states()<font></font>
<font></font>
  <span class="hljs-comment">#      .</span>
  <span class="hljs-keyword">for</span> x_batch_val, y_batch_val <span class="hljs-keyword">in</span> val_dataset:<font></font>
    val_logits = model(x_batch_val)<font></font>
    <span class="hljs-comment">#   </span><font></font>
    val_acc_metric(y_batch_val, val_logits)<font></font>
  val_acc = val_acc_metric.result()<font></font>
  val_acc_metric.reset_states()<font></font>
  print(<span class="hljs-string">'Accuracy  : %s'</span> % (float(val_acc),))
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">追加損失の低レベル処理</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションで、レイヤに対して</font></font><code>self.add_loss(value)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、メソッドを</font><font style="vertical-align: inherit;">呼び出すこと</font><font style="vertical-align: inherit;">で</font><font style="vertical-align: inherit;">正則化損失を追加できることを確認し</font><font style="vertical-align: inherit;">ました</font></font><code>call</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、ユーザートレーニングサイクルでこれらの損失を考慮に入れることをお勧めします（自分でモデルを作成していて、そのような損失が発生しないことがすでにわかっている場合を除きます）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前のセクションの例を思い出してください。ここでは、正則化損失を作成するレイヤーがあります。</font></font><br>
<br>
<pre><code class="python hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityRegularizationLayer</span>(<span class="hljs-params">layers.Layer</span>):</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span>(<span class="hljs-params">self, inputs</span>):</span>
    self.add_loss(<span class="hljs-number">1e-2</span> * tf.reduce_sum(inputs))
    <span class="hljs-keyword">return</span> inputs<font></font>
<font></font>
inputs = keras.Input(shape=(<span class="hljs-number">784</span>,), name=<span class="hljs-string">'digits'</span>)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_1'</span>)(inputs)
<span class="hljs-comment"># Insert activity regularization as a layer</span><font></font>
x = ActivityRegularizationLayer()(x)<font></font>
x = layers.Dense(<span class="hljs-number">64</span>, activation=<span class="hljs-string">'relu'</span>, name=<span class="hljs-string">'dense_2'</span>)(x)<font></font>
outputs = layers.Dense(<span class="hljs-number">10</span>, activation=<span class="hljs-string">'softmax'</span>, name=<span class="hljs-string">'predictions'</span>)(x)<font></font>
<font></font>
model = keras.Model(inputs=inputs, outputs=outputs)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のようにモデルを呼び出すと、</font></font><br>
<br>
<pre><code class="python hljs">logits = model(x_train)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ダイレクトパス中に発生する損失は、属性に追加されます</font></font><code>model.losses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">logits = model(x_train[:<span class="hljs-number">64</span>])<font></font>
print(model.losses)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
追跡された損失はモデルの最初に最初にクリアされる</font></font><code>__call__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、現在の1つの直接パス中に作成された損失のみが表示されます。</font><font style="vertical-align: inherit;">たとえば、モデルへの繰り返しの呼び出しとそれに続くへの要求</font></font><code>losses</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">では、最後の呼び出し中に作成された最後の損失のみが表示されます。</font></font><br>
<br>
<pre><code class="python hljs">logits = model(x_train[:<span class="hljs-number">64</span>])<font></font>
logits = model(x_train[<span class="hljs-number">64</span>: <span class="hljs-number">128</span>])<font></font>
logits = model(x_train[<span class="hljs-number">128</span>: <span class="hljs-number">192</span>])<font></font>
print(model.losses)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
トレーニング中のこれらの損失を考慮するために必要なのは、トレーニングサイクルを変更して、損失の完全な値に追加することだけです</font></font><code>sum(model.losses)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="python hljs">optimizer = keras.optimizers.SGD(learning_rate=<span class="hljs-number">1e-3</span>)<font></font>
<font></font>
epochs = <span class="hljs-number">3</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> range(epochs):<font></font>
  print(<span class="hljs-string">'  %d'</span> % (epoch,))<font></font>
<font></font>
  <span class="hljs-keyword">for</span> step, (x_batch_train, y_batch_train) <span class="hljs-keyword">in</span> enumerate(train_dataset):
    <span class="hljs-keyword">with</span> tf.GradientTape() <span class="hljs-keyword">as</span> tape:<font></font>
      logits = model(x_batch_train)<font></font>
      loss_value = loss_fn(y_batch_train, logits)<font></font>
<font></font>
      <span class="hljs-comment">#   ,     :</span><font></font>
      loss_value += sum(model.losses)<font></font>
<font></font>
    grads = tape.gradient(loss_value, model.trainable_weights)<font></font>
    optimizer.apply_gradients(zip(grads, model.trainable_weights))<font></font>
<font></font>
    <span class="hljs-comment">#    200 .</span>
    <span class="hljs-keyword">if</span> step % <span class="hljs-number">200</span> == <span class="hljs-number">0</span>:<font></font>
        print(<span class="hljs-string">'   (  )   %s: %s'</span> % (step, float(loss_value)))<font></font>
        print(<span class="hljs-string">': %s '</span> % ((step + <span class="hljs-number">1</span>) * <span class="hljs-number">64</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これがパズルの最後のピースでした！</font><font style="vertical-align: inherit;">ガイドの最後に達しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これで、組み込みの学習サイクルを使用し、独自のサイクルを最初から作成するために必要なすべてがわかりました。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja485878/index.html">JetCalcプラットフォームで管理会計を整理するための一連のステップ</a></li>
<li><a href="../ja485882/index.html">このリストをどのように分類するのですか？</a></li>
<li><a href="../ja485884/index.html">中国のレビトロンを設定する方法</a></li>
<li><a href="../ja485886/index.html">Yandex.DirectおよびGoogle広告からの競合他社のキーと広告を無料で解析する方法（および理由）</a></li>
<li><a href="../ja485888/index.html">サーバー要求偽造、ブラインドSSRF操作</a></li>
<li><a href="../ja485892/index.html">トライデント時代の終わり</a></li>
<li><a href="../ja485896/index.html">超並列データベースGreenplum-短い教育プログラム</a></li>
<li><a href="../ja485898/index.html">Googleフォームをエクスポート+ REST API（Python）経由でGoogleスクリプトをダウンロード</a></li>
<li><a href="../ja485902/index.html">DPI：ディープパケットインジェクション、またはRTKとMRG間の陰謀の陰謀理論</a></li>
<li><a href="../ja485904/index.html">Raiffeisenbankでの負荷テストに関するミートアップ</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>