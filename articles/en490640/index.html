<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçø ü§∏üèæ üßíüèø Overloading in C ++. Part III. Overloading new / delete statements üç® ü•† üó°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue the series "C ++, digging in depth." The purpose of this series is to tell you as much as possible about the various features of the langu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Overloading in C ++. Part III. Overloading new / delete statements</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/490640/"><hr><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We continue the series "C ++, digging in depth." </font><font style="vertical-align: inherit;">The purpose of this series is to tell you as much as possible about the various features of the language, possibly quite special. </font><font style="vertical-align: inherit;">This article is about operator overloading </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This is the third article in the series, the first dedicated to overloading functions and templates, located </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the second dedicated to overloading operators, located </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">This article concludes a three-article series on overloading in C ++.</font></font><br>
<hr><a name="habracut"></a><br>
<h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table of contents</font></font></h1><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Table of contents</font></font></b><div class="spoiler_text">&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">1.    new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">1.1.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">1.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">1.3.     </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.1.     </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.   </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.1.      new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.2.     new/delete</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.3.  </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.4. </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">2.2.5.    operator delete()</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">3.   new/delete</a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">4.    </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">5. -  </a><br>
&nbsp;&nbsp;<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="> </a><br>
</div></div><br>
<a name="id-1"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1. Standard forms of new / delete operators</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ supports several operator options </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">They can be divided into basic standard, additional standard and custom. </font><font style="vertical-align: inherit;">This section and section 2 discuss standard forms; custom forms will be discussed in section 3.</font></font><br>
<br>
<a name="id-1-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.1. </font><font style="vertical-align: inherit;">Basic standard forms</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main standard forms of operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used when creating and deleting an object and an array of the type are </font></font><code>T</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">as follows:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span> T[<span class="hljs-comment">/*   */</span>]
<span class="hljs-keyword">delete</span> ptr;
<span class="hljs-keyword">delete</span>[] ptr;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Their work can be described as follows. When the operator is called </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memory is first allocated to the object. If the selection is successful, the constructor is called. If the constructor throws an exception, then the allocated memory is freed. When the operator is called, </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">everything happens in the reverse order: first, the destructor is called, then the memory is freed. The destructor should not throw exceptions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When the operator</font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">used to create an array of objects, memory is first allocated for the entire array. If the selection is successful, then the default constructor (or another constructor, if there is an initializer) is called for each element of the array starting from zero. If any constructor throws an exception, then for all created array elements the destructor is called in the reverse order of the constructor call, then the allocated memory is freed. To delete an array, you must call the operator </font></font><code>delete[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and for all elements of the array, the destructor is called in the reverse order of the constructor, then the allocated memory is freed. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Attention! It is necessary to call the correct form of the operator</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">depending on whether a single object or an array is deleted. This rule must be observed strictly, otherwise you can get undefined behavior, that is, anything can happen: memory leaks, crash, etc. See [Meyers1] for details. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the above description, one clarification is necessary. For the so-called trivial types (built-in types, C-style structures), the default constructor may not be called, and the destructor does nothing in any case. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The standard memory allocation functions, when it is not possible to satisfy the request, throw a type exception </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. But this exception can be caught, for this you need to install a global interceptor using a function call </font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, for more details see [Meyers1]. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any form of operator</font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">apply safely to null pointer. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When creating an array with an operator, the </font></font><code>new[]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">size can be set to zero. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Both forms of the operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">allow the use of initializers in braces.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">42</span>}
<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">8</span>]{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>}</code></pre><br>
<a name="id-1-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.2. </font><font style="vertical-align: inherit;">Additional standard forms</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When connecting the header file </font></font><code>&lt;new&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, 4 more standard operator forms become available </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(ptr) T(<span class="hljs-comment">/*  */</span>);
<span class="hljs-keyword">new</span>(ptr) T[<span class="hljs-comment">/*   */</span>];
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T(<span class="hljs-comment">/*   */</span>);
<span class="hljs-keyword">new</span>(<span class="hljs-built_in">std</span>::nothrow) T[<span class="hljs-comment">/*   */</span>];</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The first two of them are called </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">non-allocating placement </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. An argument </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is a pointer to a region of memory that is large enough to hold an instance or array. Also, the memory area must have an appropriate alignment. This version of the operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not allocate memory; it provides only a call to the constructor. Thus, this option allows you to separate the phases of memory allocation and initialization of objects. This feature is actively used in standard containers. The operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for objects created in this way cannot, of course, be called. To delete an object, you must directly call the destructor, and then free the memory in a way that depends on the method of allocating memory.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second two options are called the operator not throwing exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(nothrow </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) and differ in that if it is impossible to satisfy the request, they return </font></font><code>nullptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but do not throw a type exception </font></font><code>std::bad_alloc</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Deleting an object occurs using the main operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">These options are considered obsolete and not recommended for use.</font></font><br>
<br>
<a name="id-1-3"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3. </font><font style="vertical-align: inherit;">Memory Allocation and Free Functions</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Standard forms of operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">use the following allocation and deallocation functions:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">void</span>* ptr);
<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These functions are defined in the global namespace. </font><font style="vertical-align: inherit;">The memory allocation functions for the host statements </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">do nothing and simply return </font></font><code>ptr</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 17 supported additional forms of memory allocation and deallocation functions, indicating alignment. </font><font style="vertical-align: inherit;">Here are some of them:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">align_val_t</span> al);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These forms are not directly accessible to the user, they are used by the compiler for objects whose alignment requirements are superior </font></font><code>__STDCPP_DEFAULT_NEW_ALIGNMENT__</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so the main problem is that the user does not accidentally hide them (see section 2.2.1). </font><font style="vertical-align: inherit;">Recall that in C ++ 11 it became possible to explicitly set the alignment of user types.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">struct <span class="hljs-title">alignas</span><span class="hljs-params">(<span class="hljs-number">32</span>)</span> X </span>{ <span class="hljs-comment">/* ... */</span> };</code></pre><br>
<a name="id-2"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2. Overloading the standard forms of new / delete operators</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overloading the standard forms of operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consists in defining user-defined functions for allocating and freeing memory whose signatures coincide with the standard ones. </font><font style="vertical-align: inherit;">These functions can be defined in the global namespace or in a class, but not in a namespace other than global. </font><font style="vertical-align: inherit;">The memory allocation function for a standard host statement </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cannot be defined in the global namespace. </font><font style="vertical-align: inherit;">After such a definition, the corresponding operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will use them, not the standard ones.</font></font><br>
<br>
<a name="id-2-1"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.1. </font><font style="vertical-align: inherit;">Overload in the global namespace</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suppose, for example, in a module in a global namespace that user-defined functions are defined:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
</span>{
<span class="hljs-comment">// ...</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this case, there will actually be a replacement (replacement) of the standard functions for allocating and freeing memory for all operator calls </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for any classes (including standard ones) in the entire module. This can lead to complete chaos. Note that the described substitution mechanism is a special mechanism implemented only for this case, and not some general C ++ mechanism. In this case, when implementing the user functions for allocating and freeing memory, it becomes impossible to call the corresponding standard functions, they are completely hidden (the operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not help), and when you try to call them, a recursive call to the user function occurs. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Global Namespace Defined Function</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">nothrow_t</span>&amp; nth)</span>
</span>{
<span class="hljs-comment">// ...</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It will also replace the standard one, but there will be fewer potential problems, because the operator that does not throw exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is rarely used. </font><font style="vertical-align: inherit;">But the standard form is also not available. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The same situation with functions for arrays. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overloading statements </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the global namespace is strongly discouraged.</font></font><br>
<br>
<a name="id-2-2"></a><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2. </font><font style="vertical-align: inherit;">Class overload</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Overloading operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in a class is devoid of the disadvantages described above. </font><font style="vertical-align: inherit;">Overloading is effective only when creating and deleting instances of the corresponding class, regardless of the context of invoking operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">When implementing user-defined functions for allocating and freeing memory using the operator, </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">you can access the corresponding standard functions. </font><font style="vertical-align: inherit;">Consider an example.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span>
{</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr)</span>
    </span>{
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete\n"</span>;<font></font>
        ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(ptr)</span></span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X new[]\n"</span>;
        <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](size);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* ptr)<font></font>
    {<font></font>
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"X delete[]\n"</span>;<font></font>
        ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](ptr);<font></font>
    }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this example, tracing is simply added to standard operations. </font><font style="vertical-align: inherit;">Now, in terms </font></font><code>new X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>new X[N]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will use these functions to allocate and free memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These functions are formally static and can be declared as </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">But essentially they are instance, with the function call </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the creation of the instance begins, and the call of the function </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">completes its deletion. </font><font style="vertical-align: inherit;">These functions are never called for other tasks. </font><font style="vertical-align: inherit;">Moreover, as will be shown below, the function </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is essentially virtual. </font><font style="vertical-align: inherit;">So it‚Äôs more correct to declare them without </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-1"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.1. </font><font style="vertical-align: inherit;">Access to standard forms of new / delete operators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can be used with an additional scope resolution operator, for example </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In this case, the function </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defined in the class will be ignored, and the corresponding standard will be used. </font><font style="vertical-align: inherit;">In the same way, you can use the operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-2"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.2. </font><font style="vertical-align: inherit;">Hiding other forms of new / delete operators</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If now for the class </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">we try to use throwing or not throwing exceptions </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we get an error. </font><font style="vertical-align: inherit;">The fact is that the function </font></font><code>operator new(std::size_t size)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will hide other forms </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The problem can be solved in two ways. </font><font style="vertical-align: inherit;">In the first, you need to add the appropriate options to the class (these options should simply delegate the operation of the standard function). </font><font style="vertical-align: inherit;">In the second, you need to use an operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with a scope resolution operator, for example </font></font><code>::new(p) X()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-3"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.3. </font><font style="vertical-align: inherit;">Standard containers</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If we try to place the instances </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in some standard container, for example </font></font><code>std::vector&lt;X&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, we will see that our functions are not used to allocate and free memory. </font><font style="vertical-align: inherit;">The fact is that all standard containers have their own mechanism for allocating and freeing memory (a special allocator class, which is a template parameter of the container), and they use a placement operator to initialize the elements </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<a name="id-2-2-4"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.4. </font><font style="vertical-align: inherit;">Inheritance</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Functions for allocating and freeing memory are inherited. If these functions are defined in the base class, but not in the derived one, then the operators will also be overloaded for the derived class </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the functions defined and allocated in the base class will be used to allocate and free memory. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Now consider a polymorphic class hierarchy, where each class overloads operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Now, let the instance of the derived class be deleted using the operator </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through a pointer to the base class. If the destructor of the base class is virtual, then the standard guarantees that the destructor of this derived class is called. In this case </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the </font><font style="vertical-align: inherit;">function call </font><font style="vertical-align: inherit;">defined for this derived class </font><font style="vertical-align: inherit;">is also guaranteed </font><font style="vertical-align: inherit;">. Thus, the function is </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">actually virtual.</font></font><br>
<br>
<a name="id-2-2-5"></a><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2.2.5. </font><font style="vertical-align: inherit;">Alternative form of operator delete () function</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In a class (especially when inheritance is used), it is sometimes convenient to use an alternative form of the function to free memory:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The parameter </font></font><code>size</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sets the size of the element (even in the version for the array). </font><font style="vertical-align: inherit;">This form allows you to use different functions to allocate and free memory, depending on the specific derived class.</font></font><br>
<br>
<a name="id-3"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3. User operators new / delete</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ can support custom operator forms of the </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following form:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T(<span class="hljs-comment">/*   */</span>)
<span class="hljs-keyword">new</span>(<span class="hljs-comment">/*  */</span>) T[<span class="hljs-comment">/*   */</span>]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In order for these forms to be supported, it is necessary to determine the appropriate functions for allocating and freeing memory:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-comment">/* .  */</span>);
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>)</span></span>;
<span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](<span class="hljs-keyword">void</span>* p, <span class="hljs-comment">/* .  */</span>);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The list of additional parameters of the memory allocation functions should not be empty and should not consist of one </font></font><code>void*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">or </font></font><code>const std::nothrow_t&amp;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, that is, their signature should not coincide with one of the standard ones. Lists of additional parameters in </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must match. Arguments passed to the operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">must correspond to additional parameters of the memory allocation functions. A custom function </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">can also be in the form with an optional size parameter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These functions can be defined in the global namespace or in a class, but not in a namespace other than global. If they are defined in the global namespace, they do not replace, but overload the standard functions of allocating and freeing memory, so their use is predictable and safe, and standard functions are always available. If they are defined in the class, they hide the standard forms, but access to standard forms can be obtained using the operator </font></font><code>::</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, this is described in detail in section 2.2. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
User </font><font style="vertical-align: inherit;">-defined </font><font style="vertical-align: inherit;">operator forms </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are called </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">user-defined placement </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. They should not be confused with the standard (non-allocating) placement operator </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">described in section 1.2.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The corresponding operator form </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">does not exist. </font><font style="vertical-align: inherit;">There </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are two ways to </font><font style="vertical-align: inherit;">delete an object created using a user-defined operator </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If a user-defined function </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegates a memory allocation operation to standard memory allocation functions, then a standard operator can be used </font></font><code>delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If not, you will have to explicitly call the destructor, and then the user-defined function </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The compiler calls the user-defined function in </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">only one case: when the </font></font><code>new</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">constructor throws an exception </font><font style="vertical-align: inherit;">during the operation of the user-defined operator </font><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Here is an example (in global scope).</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"new "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;
    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>(size);<font></font>
}<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* b)</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"delete "</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" + "</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">"\n"</span>;<font></font>
    ::<span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(p)</span></span>;<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">X</span> {</span><span class="hljs-comment">/* ... */</span>};<font></font>
X* p = <span class="hljs-keyword">new</span>(<span class="hljs-number">42</span>, <span class="hljs-string">"meow"</span>) X(); <span class="hljs-comment">// : new 42 + meow</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">//   ::operator delete()</span></code></pre><br>
<a name="id-4"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4. Definition of memory allocation functions</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In these examples, user functions </font></font><code>operator new()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>operator delete()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">delegated operation corresponding to the standard functions. Sometimes this option is useful, but the main goal of overloading </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is to create a new mechanism for allocating / freeing memory. The task is not simple, and before undertaking it, one must carefully think through everything. Scott Meyers [Meyers1] discusses possible motives for making such a decision (of course, the main one is efficiency). He also discusses the main technical problems associated with the correct implementation of user-defined functions for allocating and freeing memory (using the function</font></font><code>set_new_handler()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, multi-threaded synchronization, alignment). </font><font style="vertical-align: inherit;">Guntheroth provides an example of the implementation of relatively simple user-defined memory allocation and deallocation functions. </font><font style="vertical-align: inherit;">Before creating your own version, you should look for ready-made solutions, as an example, you can bring the Pool library from the Boost project.</font></font><br>
<br>
<a name="id-5"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5. Allocator classes of standard containers</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As mentioned above, standard containers use special allocator classes for allocating and freeing memory. </font><font style="vertical-align: inherit;">These classes are template parameters of containers and the user can define his version of such a class. </font><font style="vertical-align: inherit;">The motives for such a solution are approximately the same as for overloading operators </font></font><code>new/delete</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">[Guntheroth] describes how to create such classes.</font></font><br>
<br>
<a name="id-refs"></a><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bibliography</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Guntheroth] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gunteroth, Kurt. </font><font style="vertical-align: inherit;">Optimization of programs in C ++. </font><font style="vertical-align: inherit;">Proven methods for increasing productivity .: Per. </font><font style="vertical-align: inherit;">from English </font><font style="vertical-align: inherit;">- SPb .: Alpha-book LLC, 2017. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[Meyers1] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Meyers, Scott. </font><font style="vertical-align: inherit;">Effective use of C ++. </font><font style="vertical-align: inherit;">55 sure ways to improve the structure and code of your programs .: Per. </font><font style="vertical-align: inherit;">from English </font><font style="vertical-align: inherit;">- M.: DMK Press, 2014.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en490626/index.html">A complete guide to data- * HTML attributes</a></li>
<li><a href="../en490628/index.html">What to do when CSS blocks page parsing?</a></li>
<li><a href="../en490630/index.html">Loading NumPy Arrays from Disk: Comparison of memmap () and Zarr / HDF5</a></li>
<li><a href="../en490634/index.html">Digital events in Moscow from March 2 to 8</a></li>
<li><a href="../en490636/index.html">Digital events in St. Petersburg from March 2 to 8</a></li>
<li><a href="../en490642/index.html">Plugin for monitoring K8s applications DevOpsProdigy KubeGraf v1.3.0: new release and new features</a></li>
<li><a href="../en490644/index.html">Simple rpm repository using Inotify and webdav</a></li>
<li><a href="../en490648/index.html">Using Kata Containers in Kubernetes</a></li>
<li><a href="../en490650/index.html">The main mistakes in compiling a CV by beginner IT specialists</a></li>
<li><a href="../en490652/index.html">Logistics. Introduction Just about complicated</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>