<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💪🏽 🌒 👨🏿‍🎓 Escribimos la búsqueda de subcadenas mejor que en los libros de texto 🐟 🐳 👇🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La vida de un ingeniero está llena de sorpresas: especialmente cuando tienes que lidiar con la productividad. Por ejemplo, ¿qué sucede si intenta ejec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Escribimos la búsqueda de subcadenas mejor que en los libros de texto</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491750/"><img src="https://habrastorage.org/webt/ri/ei/to/rieitoeutxefbbjts6ag-carfqk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La vida de un ingeniero está llena de sorpresas: especialmente cuando tienes que lidiar con la productividad. </font><font style="vertical-align: inherit;">Por ejemplo, ¿qué sucede si intenta ejecutar este fragmento de código Java? </font><font style="vertical-align: inherit;">Se ve bastante inocente:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-comment">//   String.repeat  JDK 11  :</span>
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> needle = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">500000</span>) + <span class="hljs-string">"B"</span>;
<span class="hljs-keyword">final</span> <span class="hljs-keyword">var</span> haystack = <span class="hljs-string">"A"</span>.repeat(<span class="hljs-number">1000000</span>) + <span class="hljs-string">"B"</span>;<font></font>
System.out.println(haystack.indexOf(needle));</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esperamos, esperamos, esperamos ... Al menos en mi computadora portátil 2015 OpenJDK 13, encontrar una aguja en un pajar lleva aproximadamente un minuto. </font><font style="vertical-align: inherit;">Nuestro viejo JVM ha pasado por décadas de ajuste de rendimiento, ha implementado de manera efectiva intrínsecos </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y más. </font><font style="vertical-align: inherit;">¿Qué pudo haber salido mal?</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Este es el comienzo de una serie de varios artículos por cortesía de su autor, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Linas Medžiūnas</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y originalmente publicados en el blog de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingeniería de WiX</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
</blockquote><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eche un vistazo más de cerca a lo que se ingresa: los datos se seleccionan especialmente para lograr un rendimiento cuadrático en el peor de los casos ( </font></font><code>O(nm)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donde </font></font><code>n</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está la longitud </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>m</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la longitud </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) para el ingenuo algoritmo de búsqueda de subcadenas. Repasamos todos los caracteres </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, y si coinciden con los primeros caracteres </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, comenzamos a correr </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en el bucle interno, y así sucesivamente hasta el primer carácter no coincidente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede argumentar que este ejemplo es inútil, ya que dichos datos de entrada fueron diseñados y archivados especialmente, en la práctica no encontrará esto. Pensar dos veces. ¿Qué sucede si está trabajando en un servicio web cuyos usuarios pueden cargar cadenas arbitrarias, y en algún lugar en la parte posterior del servicio hay un código que se ejecuta</font></font><code>indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en estas lineas? Luego, solo unas pocas solicitudes maliciosas como la anterior pondrán su servicio de rodillas. Vale la pena saber, al menos, sobre los peores casos para los datos de entrada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afortunadamente, existen </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmos de búsqueda de subcadenas que</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tienen complejidad lineal ( </font></font><code>O(n+m)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). No tienen problemas con los datos del ejemplo anterior. Por ejemplo, el siguiente código Scala hace lo mismo, pero se ejecuta en milisegundos en la misma computadora, la misma JVM y usa exactamente lo mismo bajo el capó </font></font><code>java.lang.String</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="java hljs">val needle = <span class="hljs-string">"A"</span> * <span class="hljs-number">500000</span> + <span class="hljs-string">"B"</span>
val haystack = <span class="hljs-string">"A"</span> * <span class="hljs-number">1000000</span> + <span class="hljs-string">"B"</span>
println(haystack.indexOfSlice(needle))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El secreto de la gran diferencia está dentro del método </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que forma parte de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la biblioteca estándar de Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Implementa el inteligente algoritmo lineal </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Y no, no estoy diciendo que el lenguaje X sea mejor que el lenguaje Y. ¡Desafortunadamente, aquí todo es mucho más complicado! Por ejemplo, </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en Scala, este es un método generalizado que funciona no solo con cadenas, sino también en otras colecciones secuenciales, y puede comparar no solo caracteres, sino también elementos de otros tipos. Debería ser mucho más lento que</font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">de Java en el caso del medio (hablaremos de esto más adelante). Por lo tanto, tenemos un algoritmo eficiente con un rendimiento mucho mejor en el peor de los casos, pero en promedio es más lento porque tiene una parte constante mucho más grande. Dilemas como este son un problema típico en el rendimiento del ajuste. No existe una píldora mágica que resuelva todos los problemas: debe analizar cuidadosamente el problema y hacer los micro-puntos de referencia correctos.</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sigues conmigo ¡Bueno! Verás, esto es solo una introducción. Quería motivarte a lidiar con la complejidad teórica y el rendimiento práctico de los algoritmos. En el resto de este artículo, veremos algunas implementaciones de varios algoritmos de búsqueda de subcadenas y sus puntos de referencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Exploraremos tres algoritmos de búsqueda de subcadenas. Todos ellos trabajan en tiempo lineal y requieren preprocesamiento, que depende linealmente de la longitud </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. El cálculo de lo mismo </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se requiere solo una vez, y luego se puede reutilizar en varios intentos de búsqueda. Esto es razonable, porque en muchos casos necesitamos buscar la misma línea una y otra vez. E incluso si no hacemos esto, la precomputación no es una operación particularmente costosa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Todos los algoritmos a continuación omiten cada uno de los caracteres en</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solo una vez en una fila (sin acceso aleatorio por índice), por lo que todos funcionan bien en modo de transmisión. </font><font style="vertical-align: inherit;">Este artículo surgió durante un trabajo real en un servidor proxy para producción basado en el marco </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Netty</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y esto influyó en algunas de las decisiones de diseño de API. </font><font style="vertical-align: inherit;">Además, dado que necesitábamos hacer una búsqueda en buffers de bytes, el código funcionará con </font></font><code>Byte</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, no con </font></font><code>Char</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Knut-Morris-Pratt (algoritmo KMP)</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es un conocido algoritmo de búsqueda de subcadenas que data de los años 70 del siglo pasado. </font><font style="vertical-align: inherit;">Está </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bien descrito en la literatura</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , por lo que no lo describiré aquí en detalle. </font><font style="vertical-align: inherit;">El ILC se basa en </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">máquinas de estado</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : durante la fase de cálculo preliminar, se construye una matriz de índices de enlace a partir de </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Durante la búsqueda, la máquina acepta caracteres </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uno por uno </font><font style="vertical-align: inherit;">en la entrada </font><font style="vertical-align: inherit;">y actualiza su estado interno en consecuencia (y el estado de que solo hay un índice en la tabla de relaciones). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementación en Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritmo de búsqueda de subcadena binaria</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Inicialmente, tuve que inventar independientemente el nombre de este algoritmo: nunca había visto algo así en ninguna parte de la literatura. Como resultado, llegué al nombre de "Shifting Bit Mask". Más tarde resultó que este algoritmo y sus variaciones se conocen desde 1964 bajo varios </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nombres ingleses</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como "Bitap", "Shift-or", "Shift-and", "Baeza-Yates - Gonnet". Gracias a los lectores que lo han encontrado por mí. Este artículo fue escrito mucho antes de esta noticia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este algoritmo se basa en una idea muy simple y funciona muy bien, ya que casi no hay saltos, y se basa en varias operaciones binarias primitivas. Debido a esto, tiene un límite en la longitud </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que vamos a buscar: no puede tener más de 64 bytes. Este número fue tomado simplemente por el número de bits en</font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">en la JVM </font><font style="vertical-align: inherit;">Esta limitación es lo suficientemente generosa para una gran cantidad de tareas reales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como desarrollé originalmente este algoritmo, intentaré hablar sobre él con más detalle. </font><font style="vertical-align: inherit;">Primero, calculamos previamente el contexto de búsqueda para el deseado </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeBitMasks</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Array</span>[<span class="hljs-type">Long</span>] = {<font></font>
    require(needle.length &lt;= <span class="hljs-number">64</span>, <span class="hljs-string">"Maximum supported search pattern length is 64."</span>)
    <span class="hljs-keyword">val</span> bitMasks = <span class="hljs-type">Array</span>.ofDim[<span class="hljs-type">Long</span>](<span class="hljs-number">256</span>)
    <span class="hljs-keyword">var</span> bit = <span class="hljs-number">1</span>L
    <span class="hljs-keyword">for</span> (c &lt;- needle) {<font></font>
      bitMasks(toUnsignedInt(c)) |= bit<font></font>
      bit &lt;&lt;= <span class="hljs-number">1</span><font></font>
    }<font></font>
    bitMasks<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Calculamos previamente </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(64 bits </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) para cada valor de byte posible (256 piezas </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Para algún valor de byte </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>bitmask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">contiene unidades en todos los lugares donde se </font></font><code>X</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encuentra </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Por ejemplo, aquí hay una máscara de bits para la cadena "abracadabra": </font><font style="vertical-align: inherit;">
además, debe realizar un cálculo previo </font><font style="vertical-align: inherit;">, lo que ayudará a comprender que encontramos una coincidencia exacta. </font><font style="vertical-align: inherit;">Parece un valor </font><font style="vertical-align: inherit;">, con un poco </font><font style="vertical-align: inherit;">en posición </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<a rel="noopener noreferrer" href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/099/0d9/f95/0990d9f9590612cce258139fb7c287bd.png"></a><br>
<br><font style="vertical-align: inherit;"></font><code>successBitMask</code><font style="vertical-align: inherit;"></font><code>Long</code><font style="vertical-align: inherit;"></font><code>1</code><font style="vertical-align: inherit;"></font><code>needle.length — 1</code><font style="vertical-align: inherit;"></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">computeSuccessBitMask</span></span>(needle: <span class="hljs-type">Array</span>[<span class="hljs-type">Byte</span>]): <span class="hljs-type">Long</span> = {
    <span class="hljs-number">1</span>L &lt;&lt; (needle.length - <span class="hljs-number">1</span>)<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y finalmente, debes hacer, de hecho, una búsqueda. El único estado mutable que queremos almacenar es </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">( </font></font><code>Long</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). Para cada byte en, </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nos desplazamos </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bit </font><font style="vertical-align: inherit;">hacia la </font><font style="vertical-align: inherit;">izquierda </font><font style="vertical-align: inherit;">, establecemos su bit menos significativo </font></font><code>1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y hacemos un bit a bit </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entre el resultado y </font></font><code>bitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, calculado para el valor de byte procesado actual de </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(esto </font></font><code>and</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">borra todos los bits en aquellos lugares </font></font><code>currentMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que no coinciden con el byte procesado actual). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, después de procesar cada byte, solo sobrevivirán aquellos bits que estén en posiciones adecuadas. Y con cada byte procesado, todos los bits se desplazan a la izquierda en una posición. Si el bit "sobrevive" durante el número de iteraciones igual a la longitud</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ¡Encontramos una coincidencia! Y podemos verificar esto con </font></font><code>successBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(value: <span class="hljs-type">Byte</span>): <span class="hljs-type">Boolean</span> = {<font></font>
    currentMask = ((currentMask &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>) &amp; bitMasks(toUnsignedInt(value))<font></font>
    (currentMask &amp; successBitMask) == <span class="hljs-number">0</span>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nota: el método descrito anteriormente devuelve </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">si se encuentra algo y parece contradictorio. </font><font style="vertical-align: inherit;">Esto se puede entender para que el valor </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">signifique la necesidad de continuar la búsqueda, pero lo </font></font><code>false</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">detiene, esto se debe al hecho de que, como escribí anteriormente, la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">API se hizo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compatible con Netty. </font><font style="vertical-align: inherit;">Si se pregunta cómo ejecutar una búsqueda, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hay un ejemplo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, toda la lógica se reduce a unas pocas instrucciones simples del procesador. </font><font style="vertical-align: inherit;">Desafortunadamente, sigue habiendo una comprobación completamente inútil de los límites de los índices de la matriz </font></font><code>bitMasks</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que ningún JDK puede eliminar (y miré el ensamblador generado por varios JDK diferentes). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí está la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementación completa en Scala</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aho korasik</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es otro </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">algoritmo popular</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> conocido desde 1975. Su característica distintiva (y a veces bastante útil) es la capacidad de buscar varios </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a la vez, mientras que todos los personajes </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se omiten exactamente una vez (¡creo que es genial!). La idea de que todo esto funciona es una extensión del algoritmo KMP, una máquina de estados finitos que utiliza un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">árbol de prefijos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (que se basa en varios </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), que contiene enlaces a enlaces (compárelos con una matriz unidimensional del KMP). Basado en estos enlaces, el estado interno del autómata se cambia entre los nodos del árbol de prefijos después de cada símbolo procesado, y algunos de los nodos indican un resultado de búsqueda positivo para un determinado</font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">La fase de precomputación aquí es bastante complicada, pero la fase de búsqueda es inesperadamente muy simple. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aquí hay un enlace a una </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementación</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> funcional </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">en Scala</font></a><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta era una lista completamente incompleta de algoritmos de búsqueda de subcadenas. </font><font style="vertical-align: inherit;">También probamos el </font><font style="vertical-align: inherit;">algoritmo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rabin-Karp</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y el algoritmo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boyer-Moore</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">De estos dos, Boyer-Moore mostró un rendimiento comparable, pero ambos no son compatibles con la </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transmisión</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (utilizando acceso aleatorio </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">por índice), por lo que los descarté de esta investigación.</font></font><br>
<br>
<hr><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puntos de referencia</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos a comparar los tres algoritmos descritos anteriormente y, además, veremos los resultados de los métodos </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Java) y </font></font><code>indexOfSlice</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Scala). Para ser honesto, esta no es una comparación completamente correcta, porque </font></font><code>String.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">funciona con cadenas y todos los demás métodos están en matrices de bytes. Pero esto no parece invalidar los resultados de tal comparación. Además, también </font></font><code>Bytes.indexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">incluí </font><font style="vertical-align: inherit;">los resultados </font><font style="vertical-align: inherit;">de Guava (v.28.1). Este método funciona en conjuntos de bytes. Y lo escribieron en Google: todo lo que escriben allí funciona muy rápido, ¿verdad? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Escribir puntos de referencia siempre es difícil, porque puede enviar datos completamente diferentes a la entrada, cambiarlos de muchas maneras diferentes, no solo en longitud </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero también por el contenido interno de estas líneas (que pueden afectar en gran medida a algunos algoritmos). En la práctica, siempre vale la pena verificar los datos de entrada que son más similares a los datos de sus tareas reales (esto es lo que hicimos en nuestro proyecto). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para acortar este artículo, utilicé solo 2 tipos de entrada. Uno de ellos está destinado a reflejar el caso real: </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aproximadamente 1,5 KB de tamaño (con texto legible por humanos dentro) </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 9 bytes, y no en </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta secuencia (esto es necesario para forzar al algoritmo a realizar un escaneo completo). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se necesita otro tipo de entrada para obtener el peor comportamiento de un algoritmo cuadrático. Es mucho más corto que los datos desde el comienzo de este artículo: de lo contrario tendríamos que esperar un minuto entero, ¿recuerdas? Formación</font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se establece en el formato </font></font><code>"AA...AAB"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(la misma longitud que el primer tipo de datos) y </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- 64 bytes (especialmente para el algoritmo de búsqueda de subcadenas binarias para hacer frente a él) una matriz del mismo tipo (la coincidencia es solo al final </font></font><code>haystack</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un punto de referencia escrito en el marco JMH </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">se puede encontrar aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Si tiene otras ideas sobre qué y cómo medir aquí, puede clonar este repositorio, cambiar algo y publicar comentarios.</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A sugerencia de </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , agregué resultados de referencia para </font></font><code>java.util.regex.Pattern</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; él usa el algoritmo Boyer-Moore bajo el capó.</font></font></blockquote><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(Nota del traductor: por cierto, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vladimir Sitnikov</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es miembro de varios comités de programa en el Grupo JUG Ru y hace informes interesantes. Por ejemplo, un </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">video de</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> su informe de JPoint 2019 titulado "Java se ralentiza: edición CodeCache" </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;">está disponible en el enlace</font></a><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Resultados de referencia</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Los resultados se dan en milisegundos, menos es mejor: </font><font style="vertical-align: inherit;">
aquí todo es como se esperaba:</font></font><br>
<br>
<code># JMH version: 1.21<br>
# VM version: JDK 13.0.1, OpenJDK 64-Bit Server VM, 13.0.1+9<br>
Benchmark (searchInput) Mode Cnt Score Error Units<br>
javaIndexOf REGULAR avgt 5 0.622 ± 0.002 us/op<br>
shiftingBitMask REGULAR avgt 5 1.982 ± 0.017 us/op<br>
regexPattern REGULAR avgt 5 2.184 ± 0.006 us/op<br>
kmp REGULAR avgt 5 2.635 ± 0.016 us/op<br>
scalaIndexOfSlice REGULAR avgt 5 3.202 ± 0.009 us/op<br>
guavaIndexOf REGULAR avgt 5 3.696 ± 0.095 us/op<br>
ahoCorasic REGULAR avgt 5 7.063 ± 0.040 us/op<br>
shiftingBitMask WORST_CASE avgt 5 1.986 ± 0.010 us/op<br>
kmp WORST_CASE avgt 5 5.120 ± 0.006 us/op<br>
ahoCorasic WORST_CASE avgt 5 6.892 ± 0.025 us/op<br>
scalaIndexOfSlice WORST_CASE avgt 5 8.765 ± 0.007 us/op<br>
regexPattern WORST_CASE avgt 5 11.566 ± 0.086 us/op<br>
javaIndexOf WORST_CASE avgt 5 23.029 ± 0.124 us/op<br>
guavaIndexOf WORST_CASE avgt 5 52.927 ± 0.275 us/op<br>
</code><br><font style="vertical-align: inherit;"></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para los datos ordinarios, domina </font></font><code>javaIndexOf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, porque utiliza intrínsecos de alto rendimiento en su interior, por lo que la parte constante es pequeña;</font></font></li>
<li>     ,  :     ,     (<code>O(nm)</code>)   <code>javaIndexOf</code>,           —      ,  <code>shiftingBitMask</code> (  )   .</li>
<li><code>guavaIndexOf</code>      ,    <code>javaIndexOf</code>;  ,        2  ,    <code>shiftingBitMask</code>;</li>
<li><code>scalaIndexOfSlice</code>  -  ,  <code>knuthMorrisPratt</code>,   ,      —   ,  ;</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el rendimiento no es la característica más fuerte </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(o al menos de su implementación; debo admitir que realmente no intenté hacer microoptimizaciones en él, porque lo agregué solo por su característica distintiva: la capacidad de buscar en varias líneas a la vez, y esto similar al tema para un artículo separado);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">los datos de entrada (y la longitud </font></font><code>needle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) no afectaron el rendimiento </font></font><code>shiftingBitMask</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>ahoCorasic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font></li>
</ul><br>
<h2><font color="#D93740"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">recomendaciones</font></font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En diferentes casos, los puntos de referencia pueden funcionar de diferentes maneras. </font><font style="vertical-align: inherit;">A pesar de que los resultados anteriores parecen muy indicativos, siempre debe tomar medidas usted mismo y con datos que reflejen sus tareas reales. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En base a los datos presentados, hice las siguientes conclusiones:</font></font><br>
<br>
<ul>
<li>    <code>String</code>-   ,           ,   <code>String.indexOf</code> ( <code>java.util.regex.Pattern</code> —      );</li>
<li>,   <code>needle</code>   64 ,    ;</li>
<li> ,   --;</li>
<li>   Scala        - (     ),   <code>indexOfSlice</code>    —    ;</li>
<li>    ,  -.</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¡Eso es todo! </font><font style="vertical-align: inherit;">Si le gusta leer sobre algoritmos, rendimiento y similares (y también sobre Scala, JVM y Java en general), suscríbase al autor de este artículo, Linas Medziunas ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Medio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Twitter</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El repositorio de github con todo el código en este artículo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">está aquí</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<hr><br>
<img src="https://habrastorage.org/webt/_f/ku/xn/_fkuxncdimo0rsaeealkeqpe8f0.png" align="left"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Las traducciones de los artículos se publican con el apoyo del Grupo JUG Ru y la Conferencia </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JPoint</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br clear="all"></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es491740/index.html">Internet de las cosas en Yandex.Cloud: cómo se organizan los servicios Yandex IoT Core y Yandex Cloud Functions</a></li>
<li><a href="../es491742/index.html">Sorbete: teclado ergonómico para juegos</a></li>
<li><a href="../es491744/index.html">Los piratas informáticos iraníes explotaron vulnerabilidades en VPN</a></li>
<li><a href="../es491746/index.html">La historia de la síntesis del habla: la era de las soluciones eléctricas.</a></li>
<li><a href="../es491748/index.html">Tecnologías que ayudan a los ciegos a aprender inglés</a></li>
<li><a href="../es491780/index.html">GitLab 12.8 lanzado con Log Browser, NuGet y Compliance Dashboard</a></li>
<li><a href="../es491782/index.html">LANIT lanza la Escuela de Pruebas en Moscú, Penza, Sochi y Novorossiysk</a></li>
<li><a href="../es491788/index.html">Lo que mi compromiso en Angular me enseñó</a></li>
<li><a href="../es491792/index.html">Wireless HiFiMan como etapa en la evolución de los auriculares isodinámicos</a></li>
<li><a href="../es491796/index.html">Собеседование здорового человека</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>