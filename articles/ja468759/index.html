<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏿 👩‍🍳 📣 Clangの[[trivial_abi]]について 👩🏾‍⚖️ 🚓 👐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="最後に、[[trivial_abi]]に関する投稿を書きました。
 
 これは、Clangトランクの新しい独自の機能であり、2018年2月の時点で新しくなりました。これはC ++言語のベンダー拡張であり、標準のC ++ではありません。GCCトランクではサポートされていません。また、WG21がC ++...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Clangの[[trivial_abi]]について</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468759/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最後に、[[trivial_abi]]に関する投稿を書きました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは、Clangトランクの新しい独自の機能であり、2018年2月の時点で新しくなりました。これはC ++言語のベンダー拡張であり、標準のC ++ではありません。GCCトランクではサポートされていません。また、WG21がC ++標準に含めることを提案しているところはありません。</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ie/do/9e/iedo9ep8gzdeliscehwljy0clnq.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この機能の実装には参加しませんでした。</font><font style="vertical-align: inherit;">私はcfe-commitsメーリングリストのパッチを見ただけで、黙って自分に拍手を送りました。</font><font style="vertical-align: inherit;">しかし、これはとてもクールな機能なので、誰もが知っておくべきだと思います。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、まず始めに、これは標準属性ではなく、Clangトランクは[[trivial_abi]]属性の標準スペルをサポートしていません。</font><font style="vertical-align: inherit;">代わりに、以下に示すように、古いスタイルで記述する必要があります。</font></font><br>
<br>
<pre><code class="cpp hljs">__attribute__((trivial_abi))<font></font>
__attribute__((__trivial_abi__))<font></font>
[[clang::trivial_abi]]</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、これは属性なので、コンパイラは貼り付ける場所に非常に注意を払い、間違った場所に貼り付けると消極的に無音になります（認識されない属性はメッセージなしで単に無視されるため）。</font><font style="vertical-align: inherit;">これはバグではなく、機能です。</font><font style="vertical-align: inherit;">正しい構文は次のとおりです。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRIVIAL_ABI __attribute__((trivial_abi))</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TRIVIAL_ABI</span> <span class="hljs-title">Widget</span> {</span>
    <span class="hljs-comment">// ...</span>
};</code></pre><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはどのような問題を解決しますか？</font></font></h3><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスの2つのバージョンを示した2018年4月17日の投稿を覚えていますか？</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">注意 </font><font style="vertical-align: inherit;">perev：2018年4月17日の投稿はボリュームが少ないため、個別に公開するのではなく、ここのスポイラーの下に挿入しました。</font></font><br>
</blockquote><div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2018年4月17日からの投稿</font></font></b><div class="spoiler_text"><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自明なデストラクタ呼び出しがないことの欠点</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++標準提案メーリングリストを参照してください。</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fooまたはbarの2つの関数のどちらがコンパイラーによって生成される最良のコードを持ちますか？</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Integer</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    ~Integer() {} <span class="hljs-comment">// deliberately non-trivial</span><font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; v)</span> </span>{<font></font>
    v.back() *= <span class="hljs-number">0xDEADBEEF</span>;<font></font>
    v.pop_back();<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;Integer&gt;&amp; v)</span> </span>{<font></font>
    v.back().value *= <span class="hljs-number">0xDEADBEEF</span>;<font></font>
    v.pop_back();<font></font>
}<font></font>
</code></pre><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GCCおよびlibstdc ++を使用した</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">コンパイル</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">ね？</font></font><br>
<br>
<pre><code class="cpp hljs">foo:<font></font>
  movq   <span class="hljs-number">8</span>(%rdi), %rax<font></font>
  imull  $<span class="hljs-number">-559038737</span>, <span class="hljs-number">-4</span>(%rax), %edx<font></font>
  subq   $<span class="hljs-number">4</span>, %rax<font></font>
  movl   %edx, (%rax)<font></font>
  movq   %rax, <span class="hljs-number">8</span>(%rdi)<font></font>
  ret<font></font>
<font></font>
bar:<font></font>
  subq   $<span class="hljs-number">4</span>, <span class="hljs-number">8</span>(%rdi)<font></font>
  ret</code></pre><br>
<br>
   : GCC  ,  ,       ,    ,         «».  GCC   ,  ,    (,   ~int())   ,     .<br>
<br>
,  bar  pop_back,   ~Integer(),   vec.back() «»,  GCC     0xDEADBEEF.<br>
<br>
  , foo  pop_back,    ~int() (    ,    ), GCC ,       . , GCC  ,  vec.back() ,      0xDEADBEEF.<br>
<br>
    ,    , ,  ~int().   ~Integer() {}  ~Integer() = default;  ,   imull  !<br>
</div></div><br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    ~Foo() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// trivial</span><font></font>
};<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bar</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    ~Bar() {} <span class="hljs-comment">// deliberately non-trivial</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
その投稿では、コンパイラーがFooのコードをBarよりも低く生成したコードが示されています。</font><font style="vertical-align: inherit;">なぜこれが予想外だったのかを説明する価値があります。</font><font style="vertical-align: inherit;">プログラマは直感的に、「自明な」コードが「自明でない」コードよりも優れていることを期待しています。</font><font style="vertical-align: inherit;">これはほとんどの状況に当てはまります。</font><font style="vertical-align: inherit;">特に、関数の呼び出しまたは戻りを行う場合がこれに該当します。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;class T&gt;
T <span class="hljs-title">incr</span><span class="hljs-params">(T obj)</span> </span>{<font></font>
    obj.value += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> obj;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
incr </font><font style="vertical-align: inherit;">は次のコードに</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コンパイルさ</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">れます。</font></font><br>
<br>
<pre><code class="cpp hljs">leal   <span class="hljs-number">1</span>(%rdi), %eax<font></font>
retq</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（lealは</font><font style="vertical-align: inherit;">「追加」を意味</font><font style="vertical-align: inherit;">する</font><font style="vertical-align: inherit;">x86 </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コマンド</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。）4バイトのobjが％ediレジスターのincrに渡され、その値に1を加算して％eaxに返します。</font><font style="vertical-align: inherit;">入力で4バイト、出力で4バイト、簡単でシンプル。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それでは、incr（重要なデストラクタの場合）を見てみましょう。</font></font><br>
<br>
<pre><code class="cpp hljs">movl   (%rsi), %eax<font></font>
addl   $<span class="hljs-number">1</span>, %eax<font></font>
movl   %eax, (%rsi)<font></font>
movl   %eax, (%rdi)<font></font>
movq   %rdi, %rax<font></font>
retq</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、同じ4バイトが同じセマンティクスを持つにもかかわらず、objはレジスターに渡されません。ここでは、objが渡されてアドレスに返されます。ここで、呼び出し元は戻り値用にいくつかのスペースを予約し、rdiでこのスペースへのポインターを渡します。呼び出し元は、引数の次のレジスター％rsiの戻り値objへのポインターを渡します。 （％rsi）から値を抽出し、1を追加して（％rsi）に保存し、obj自体の値を更新してから、（簡単に）4バイトのobjを、％rdiが指す戻り値のスロットにコピーします。最後に、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86-64 ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメント</font><font style="vertical-align: inherit;">（p。22）がこれを行うように指示しているため</font><font style="vertical-align: inherit;">、呼び出し元から渡された元のポインタを％rdiから％raxにコピーします</font><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BarがFooと大きく異なる理由は、Barに自明でないデストラクタがあり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x86-64 ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（p。19）に具体的に次のように</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">記述され</font></a><font style="vertical-align: inherit;">ているため</font><font style="vertical-align: inherit;">です。</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++オブジェクトに重要なコピーコンストラクターまたは重要なデストラクタがある場合、オブジェクトは非表示のリンクを介して渡されます（オブジェクトはパラメーターリストのポインター[...]に置き換えられます）</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
後の</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Itanium C ++ ABI</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントで</font><font style="vertical-align: inherit;">は、次のことを定義しています。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの型は、呼び出しの目的のために自明である場合、呼び出し側は一時的な場所を割り当て、この一時的な場所への参照を渡す必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[...] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
：</font><font style="vertical-align: inherit;">タイプがあれば呼び出しの目的のために自明でないと考えられている</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ことが自明でないコピーコンストラクタを移動させ、コンストラクタ、デストラクタ、またはその移動のすべてを持っています削除されたコピーコンストラクター。</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、これはすべてを説明します。バーは非表示のリンクを介して渡されるため、コード生成が不十分です。</font><font style="vertical-align: inherit;">2つの独立した状況の不運な組み合わせが発生したため、不可視のリンクを介して送信されます。</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ABIドキュメントは、自明でないデストラクタを持つオブジェクトが非表示のリンクを介して渡されると述べています</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Barには重要なデストラクタがあります。</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは古典的な</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">三段論法</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">です。最初の点は主要な前提であり、2番目の点はプライベートです。</font><font style="vertical-align: inherit;">その結果、バーは非表示のリンクを介して送信されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
誰かに三段論法を与えましょう：</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">すべての人が死ぬ</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ソクラテスは男です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">その結果、ソクラテスは致命的です。</font></font></li>
</ul><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
「ソクラテスは致命的である」という結論に反論したい場合は、前提の1つに反論する必要があります。主なものに反論する（おそらく死ぬ人もいる）か、特定のものに反論する（おそらくソクラテスは人間ではない）かのいずれかです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Barがレジスター（Fooなど）で渡されるためには、2つの前提のうちの1つを反駁する必要があります。</font><font style="vertical-align: inherit;">標準のC ++パスは、Barに簡単なデストラクタを与え、プライベートな前提を破壊することです。</font><font style="vertical-align: inherit;">しかし、別の方法があります！</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[[trivial_abi]]が問題を解決する方法</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
新しいClang属性は主要な前提を破壊します。</font><font style="vertical-align: inherit;">ClangはABIドキュメントを次のように拡張します。</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの型は、呼び出しの目的のために自明である場合、呼び出し側は一時的な場所を割り当て、この一時的な場所への参照を渡す必要があります。</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[...] </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは[[trivial_abi]]としてマークされている場合のタイプは、呼び出しの目的のために自明でないとみなされ、：</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
それは、自明でないコピーコンストラクタを持っています移動コンストラクタ、デストラクタ、またはそのすべての移動コンストラクタとコピーコンストラクタが削除されます。</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[[trivial_abi]]とマークされていれば、移動するコンストラクタまたはデストラクタが自明でないクラスは、呼び出しの目的で自明と見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、Clangを使用して、次のように書くことができます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRIVIAL_ABI __attribute__((trivial_abi))</span><font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TRIVIAL_ABI</span> <span class="hljs-title">Baz</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    ~Baz() {} <span class="hljs-comment">// deliberately non-trivial</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
incr &lt;Baz&gt;をコンパイルして、incr &lt;Foo&gt;と同じコードを取得します。</font></font><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告＃1：[[trivial_abi]]は何もしないことがある</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
次のように、標準のライブラリタイプに対して「呼び出しのために簡単な」ラッパーを作成できることを願っています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>, <span class="hljs-title">class</span> <span class="hljs-title">D</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">TRIVIAL_ABI</span> <span class="hljs-title">trivial_unique_ptr</span> :</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, D&gt; {
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;T, D&gt;::<span class="hljs-built_in">unique_ptr</span>;<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
残念ながら、これは機能しません。</font><font style="vertical-align: inherit;">クラスに「呼び出しの目的にとって重要」な基本クラスまたは非静的フィールドがある場合、それが記述された形式のClang拡張機能により、クラスは「不可逆的に重要」になり、属性は効果を発揮しません。</font><font style="vertical-align: inherit;">（診断メッセージは発行されません。これは、オプションテンプレートとしてクラステンプレートで[[trivial_abi]]を使用できることを意味し、クラスは「条件付きで簡単」になります。これは便利な場合があります。もちろん、欠点はクラスを些細なものとしてマークし、コンパイラが静かに修正したことを確認します。）</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
クラスに仮想基本クラスまたは仮想関数がある場合、属性はメッセージなしで無視されます。</font><font style="vertical-align: inherit;">これらの場合、それはレジスターに収まらない可能性があり、値で渡しても何が欲しいかわかりませんが、おそらくご存知でしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、私が知る限り、オプションの&lt;T&gt;、unique_ptr &lt;T&gt;、shared_ptr &lt;T&gt;などの「標準ユーティリティタイプ」にTRIVIAL_ABIを使用する唯一の方法は、</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">それらを最初から実装して属性を適用する、または</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">libc ++のローカルコピーに侵入し、手で属性を挿入します</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（オープンソースの世界では、どちらの方法も基本的に同じです）</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告＃2：デストラクタの責任</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Foo / Barの例では、クラスに空のデストラクタがあります。</font><font style="vertical-align: inherit;">実際のクラスに重要なデストラクタがあるとしましょう。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Up1</span> {</span>
    <span class="hljs-keyword">int</span> value;<font></font>
    Up1(Up1&amp;&amp; u) : value(u.value) { u.value = <span class="hljs-number">0</span>; }<font></font>
    ~Up1() { <span class="hljs-built_in">puts</span>(<span class="hljs-string">"destroyed"</span>); }<font></font>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これはおなじみのはずです。これは、unique_ptr &lt;int&gt;であり、削除するとメッセージが出力され、制限まで簡略化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRIVIAL_ABIがない場合、incr &lt;Up1&gt;はincr &lt;Bar&gt;のようになります。</font></font><br>
<br>
<pre><code class="cpp hljs">movl   (%rsi), %eax<font></font>
addl   $<span class="hljs-number">1</span>, %eax<font></font>
movl   %eax, (%rdi)<font></font>
movl   $<span class="hljs-number">0</span>, (%rsi)<font></font>
movq   %rdi, %rax<font></font>
retq</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRIVIAL_ABIを使用すると、incrが</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大きくて</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">恐ろしく見えます</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="cpp hljs">pushq  %rbx<font></font>
leal   <span class="hljs-number">1</span>(%rdi), %ebx<font></font>
movl   $.L.str, %edi<font></font>
callq  <span class="hljs-built_in">puts</span><font></font>
movl   %ebx, %eax<font></font>
popq   %rbx<font></font>
retq</code></pre><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
従来の呼び出し規約では、重要なデストラクタを持つ型は常に非表示のリンクによって渡されます。つまり、受信側（この場合はincr）は、このオブジェクトを所有せずに常にパラメータオブジェクトへのポインタを受け入れます。オブジェクトには呼び出し側があり、</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">欠落しているコピーを処理します</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（消去作業）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
[[trivial_abi]]を含む型がレジスタに渡されると、基本的にパラメータオブジェクトのコピーが作成されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
x86-64には返されるレジスタが1つしかないため（拍手）、呼び出された関数は最後にオブジェクトを返す方法がありません。呼び出された関数は、渡されたオブジェクトの所有権を取得する必要があります。つまり、呼び出された関数は、終了時にパラメータオブジェクトのデストラクタを呼び出す必要があります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
前の例では、デストラクタFoo / Bar / Bazが呼び出されましたが、空でしたので気づきませんでした。</font><font style="vertical-align: inherit;">incr &lt;Up2&gt;には、呼び出された関数の側のデストラクタによって生成される追加のコードが表示されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この追加コードは、一部のユーザーケースで生成される可能性があると想定できます。</font><font style="vertical-align: inherit;">しかし、逆に、デストラクターの呼び出しはどこにも現れません！</font><font style="vertical-align: inherit;">呼び出し元の関数</font><font style="vertical-align: inherit;">では呼び出され</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ない</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ため、incrで呼び出され</font><font style="vertical-align: inherit;">ます。</font><font style="vertical-align: inherit;">そして一般的に、価格とメリットはバランスが取れています。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">警告＃3：デストラクタの注文</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ささいなABIを持つパラメータのデストラクタは、呼び出された関数ではなく、呼び出された関数によって呼び出されます（警告2）。</font><font style="vertical-align: inherit;">Richard Smithは、これは他のパラメーターのデストラクタが配置されている順序で呼び出されないことを意味していることを指摘しています。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TRIVIAL_ABI</span> <span class="hljs-title">alpha</span> {</span>
    alpha() { <span class="hljs-built_in">puts</span>(<span class="hljs-string">"alpha constructed"</span>); }<font></font>
    ~alpha() { <span class="hljs-built_in">puts</span>(<span class="hljs-string">"alpha destroyed"</span>); }<font></font>
};<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">beta</span> {</span>
    beta() { <span class="hljs-built_in">puts</span>(<span class="hljs-string">"beta constructed"</span>); }<font></font>
    ~beta() { <span class="hljs-built_in">puts</span>(<span class="hljs-string">"beta destroyed"</span>); }<font></font>
};<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(alpha, beta)</span> </span>{}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    foo(alpha{}, beta{});<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このコードは出力します：</font></font><br>
<br>
<pre><code class="cpp hljs">alpha constructed<font></font>
beta constructed<font></font>
alpha destroyed<font></font>
beta destroyed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TRIVIAL_ABIが[[clang :: trivial_abi]]として定義されている場合、次のように出力されます。</font></font><br>
<br>
<pre><code class="cpp hljs">alpha constructed<font></font>
beta constructed<font></font>
beta destroyed<font></font>
alpha destroyed</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「トリビアルリロケータブル」/「move-relocates」オブジェクトとの関係（「トリビアルリロケータブル」/「move-relocates」）</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
関係ない...え？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ご覧のとおり、[[trivial_abi]]クラスが移動コンストラクタ、デストラクタ、またはデフォルトコンストラクタに対して特定のセマンティクスを持つ必要はありません。</font><font style="vertical-align: inherit;">ほとんどのクラスが自明に再配置可能であるため、特定のクラスはおそらく自明に再配置可能になります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
簡単に再配置できないように、単にoffset_ptrクラスを作成できます。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">TRIVIAL_ABI</span> <span class="hljs-title">offset_ptr</span> {</span>
    <span class="hljs-keyword">intptr_t</span> value_;
<span class="hljs-keyword">public</span>:<font></font>
    offset_ptr(T *p) : value_((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)p - (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)<span class="hljs-keyword">this</span>) {}<font></font>
    offset_ptr(<span class="hljs-keyword">const</span> offset_ptr&amp; rhs) : value_((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)rhs.get() - (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)<span class="hljs-keyword">this</span>) {}
    <span class="hljs-function">T *<span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{ <span class="hljs-keyword">return</span> (T *)((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)<span class="hljs-keyword">this</span> + value_); }<font></font>
    offset_ptr&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> offset_ptr&amp; rhs) {<font></font>
        value_ = ((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)rhs.get() - (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)<span class="hljs-keyword">this</span>);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
    offset_ptr&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-keyword">int</span> diff) {<font></font>
        value_ += (diff * <span class="hljs-keyword">sizeof</span> (T));
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<font></font>
    }<font></font>
};<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<font></font>
    offset_ptr&lt;<span class="hljs-keyword">int</span>&gt; top = &amp;a[<span class="hljs-number">4</span>];<font></font>
    top = incr(top);<font></font>
    assert(top.get() == &amp;a[<span class="hljs-number">5</span>]);<font></font>
}</code></pre><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これが完全なコードです。</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
TRIVIAL_ABIが定義されている場合、Clangトランクは-O0と-O1でこのテストに合格しますが、-O2で（つまり、trivial_offset_ptr ::演算子+ =とコピーコンストラクターへの呼び出しをインライン化しようとするとすぐに）、アサートでクラッシュします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
だからもう一つの警告。あなたのタイプがthisポインタでとてもおかしなことをするなら、おそらくそれをレジスタに渡したくないでしょう。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">バグ37319</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">、実際には、ドキュメントの要求。この場合、プログラマーが望む方法でコードを機能させる方法がないことがわかります。 value_の値はthisポインターの値に依存する必要があると言いますが、呼び出し側と呼び出された関数の間の境界では、オブジェクトはレジスターにあり、それへのポインターは存在しません！したがって、呼び出し元の関数はそれをメモリに書き込み、thisポインターを再度渡します。呼び出された関数は、value_に書き込むために正しい値をどのように計算する必要がありますか？おそらく、それが-O0で一般的にどのように機能するかを尋ねる方が良いでしょうか？</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">このコードはまったく機能しません。</font></font></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、[[trivial_abi]]を使用する場合は、オブジェクト自体のアドレスに大きく依存するメンバー関数（特別なものだけでなく、その他のもの）を避ける必要があります（「必須」という単語の意味は定義されていません）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
直感的に、クラスが[[trivial_abi]]としてマークされている場合、コピーすることが予想されるときはいつでも、copy plus memcpyを取得できます。そして同様に、あなたが移動を期待するとき、あなたは実際に移動に加えてmemcpyを得ることができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
型が「自明に再配置可能」である場合（私の</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;">C ++で</font></a><font style="vertical-align: inherit;">定義されているとおり）</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）、その後、コピーと破棄を期待するときはいつでも、実際にmemcpyを取得できます。</font><font style="vertical-align: inherit;">同様に、再配置と破棄が予想される場合は、実際にmemcpyを取得できます。</font><font style="vertical-align: inherit;">実際、「簡単な再配置」について話すと、特別な関数の呼び出しは失われますが、クラスにClangの[[trivial_abi]]属性がある場合、呼び出しは失われません。</font><font style="vertical-align: inherit;">期待通りの呼び出しに加えて、memcpyが（そのまま）取得されます。</font><font style="vertical-align: inherit;">この（一種の）memcpyは、より高速な呼び出しレジスター規約に対して支払う価格です。</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さらに読むためのリンク：</font></font></h3><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2017年11月の畑中明氏のcfe-devスレッド</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clangの公式ドキュメント</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">trivial_abiの単体テスト</font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=ja&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bug 37319：trivial_offset_ptrが機能しない</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja468741/index.html">スマートシティのインターネット</a></li>
<li><a href="../ja468747/index.html">夏をVKで過ごした方法</a></li>
<li><a href="../ja468749/index.html">Android LiveDataイベント</a></li>
<li><a href="../ja468753/index.html">カラーブラインド-人の友（保健省は正しくない）</a></li>
<li><a href="../ja468757/index.html">エラー1040後のMySQL接続：接続が多すぎます</a></li>
<li><a href="../ja468761/index.html">pwnable.kr 24による問題解決-簡単なログイン。スタックフレームオーバーレイ</a></li>
<li><a href="../ja468765/index.html">Delimobileを例にして制御コマンドを確認することの重要性</a></li>
<li><a href="../ja468767/index.html">木のおもちゃ、パート2-1986-1988</a></li>
<li><a href="../ja468769/index.html">Xavier Noria on Rails 6、コンサルティングなど</a></li>
<li><a href="../ja468773/index.html">インドのエネルギー会社NTPCが5,000メガワットのソーラーパークを建設</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>