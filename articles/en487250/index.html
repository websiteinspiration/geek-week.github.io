<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úÇÔ∏è ü§ûüèæ üöµüèΩ Delayed Alpha blending ü§öüèæ ü¶ó üßîüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about methods for mixing rasterized geometry. The classic mixing models of translucent objects - Alpha, Additive, Multi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Delayed Alpha blending</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/playrix/blog/487250/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article I want to talk about methods for mixing rasterized geometry. The classic mixing models of translucent objects - Alpha, Additive, Multiplicative - are united by the same drawing principle: sequentially draw one primitive after another, mixing the pixels received at the output of the fragment shader with what is in the current buffer. Each new primitive updates the area of ‚Äã‚Äãthe buffer into which it is drawn; in the case of alpha blending, the objects that are higher upshade previously drawn ones. But what if you want to do something with a group of objects drawn on top of the scene ‚Äî for example, crop them by mask or highlight them? Here two decisions immediately come to mind: either make changes to their material (i.e. change the shader, expand the set of textures), for example, adding a projection of another texture,which will be responsible for the transparency mask. However, if we have a lot of mottled objects, changing each unique material is inconvenient and fraught with errors. The second option is to draw all the objects of interest to us into a separate full-screen target and draw it already on the final scene. Here we can do whatever we want with its contents, but this requires the allocation of extra memory and, most unpleasantly, switching target rendering. This is not the ‚Äúcheapest‚Äù operation on mobile devices, which will need to be performed twice. And if you want to work with several layers like this?Here we can do whatever we want with its contents, but this requires the allocation of extra memory and, most unpleasantly, switching target rendering. This is not the ‚Äúcheapest‚Äù operation on mobile devices, which will need to be performed twice. And if you want to work with several layers like this?Here we can do whatever we want with its contents, but this requires the allocation of extra memory and, most unpleasantly, switching target rendering. This is not the ‚Äúcheapest‚Äù operation on mobile devices, which will need to be performed twice. And if you want to work with several layers like this?</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/d50/e92/9b9/d50e929b993fd07bbae87c16bef3e65c.png"></a><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is another, simpler and more elegant way to solve these problems. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can paint the scene in reverse!</font></font></b><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A small digression to remind you how the classic rendering method works</font></font></b><div class="spoiler_text">    -  Alpha Blending   ,   ,   ,       .      4  RGBA,  RGB ‚Äî   A(Alpha) ‚Äî  (       ).             .     :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c57/cd7/ea9/c57cd7ea905d4fc58a9e65c1e604b0e2.png"></div><br>
 ColorSrc ‚Äî RGB ,     (  ,    ), ColorDst ‚Äî    ,   , Color_Result ‚Äî ,    ,  ,     .    <b>Variable1</b>  <b>Variable2</b>,          ?   ,    (    ,      ).     ,       :     ,   ...&nbsp;<br>
<br>
     :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa6/d2d/0b1/aa6d2d0b1a1f02685551030ddf1db356.png"></div><br>
 AlphaSrc ‚Äî -   (), OneMinusAlphaSrc,   ,  1.0 ‚Äî AlphaSrc.    : 1 *  + 2 * (1 ‚Äî ).            alpha ().     = 1,     ,    = 0,    .        OpenGL  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="></a>.<br>
<br>
     OpenGL ES 2.0  ‚Äî          .<br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
How the image is formed in steps: first we draw a background, then we draw all the objects in layers one after another. </font><font style="vertical-align: inherit;">What is rendered last overwrites the previous pixels:&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ec5/87f/f0c/ec587ff0c9f1111e43aa75d7352ee72e.png"></div><br>
<br>
<hr><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is the trick?&nbsp;</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The essence of the technology of reverse rendering or, as it can also be called, delayed mixing is as follows. </font><font style="vertical-align: inherit;">We draw the scene backwards using a different blending formula. </font><font style="vertical-align: inherit;">Moreover, the final image will remain exactly the same as with the classical approach.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How it works?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method of mixing through the transparency channel of the image that we draw was described above. Now we will turn it the other way around: we will use the transparency of already drawn pixels (or rather, mixing the drawn transparency with the already drawn). That is, instead of AlphaSrc we will use AlphaSaturate, and instead of OneMinusAlphaSrc - One. It turns out that if there is already something with transparency = 1 in the buffer, then the contribution will be zero, and the color of such a pixel will not change. If there was zero transparency, let's add both colors together (for this we will need to clear the frame buffer with zeros or black with zero transparency). With this addition, the resulting color will be equal to the drawn. The final formula looks like this:</font></font><br>
&nbsp;<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/14b/5cc/537/14b5cc53798ec10be6a67901a4740fb3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
(approx. AlphaSaturate = min (AlphaSrc, 1 - AlphaDst)) </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The transparency values ‚Äã‚Äãneed to be added: it must accumulate layer by layer, that is, we will have One and One in the mix variables for the alpha channel. </font><font style="vertical-align: inherit;">Why don't we modify ColorDst and clear the buffer with zeros? </font><font style="vertical-align: inherit;">This is necessary for Additive mixing, AdditiveBlending will only differ in that it will have Zero in the AlphaSrc variable. </font><font style="vertical-align: inherit;">It should not modify transparency, only color. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
For clarity, the reverse rendering scheme looks like this:&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
First, we clear the frame buffer. </font><font style="vertical-align: inherit;">Then we set the mixing function given above and start drawing from the topmost objects (in the classical approach, they would be drawn last), going down to the bottom ones. </font><font style="vertical-align: inherit;">The background image will be drawn last.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d21/bad/2c5/d21bad2c56508107c644860dff8b9aff.png"></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">How can this be used?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I will describe several tasks solved by this method, using our project as an example:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Clipping objects by mask with transparency. </font><font style="vertical-align: inherit;">Smooth clipping of the game room:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d82/97d/ce0/d8297dce08eac582b70d49b2f28acbdf.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
After drawing the playing field, it is enough to clear the transparency in those places of the image that we want to hide. </font><font style="vertical-align: inherit;">This is done using the mixing formula, in which the drawn mask object overwrites color and transparency inversely with its own transparency, and the degree of cleaning can be continuously adjusted. </font><font style="vertical-align: inherit;">In this case, the following geometry is used for clipping:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2b7/09d/aa3/2b709daa3b9e142938838d4386aaf7cb.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It changes its shape as the camera moves between rooms. </font><font style="vertical-align: inherit;">The mixing formula for cleaning is as follows:</font></font><br>
<br>
<pre><code class="plaintext hljs">ColorSrc = GL_ZERO,<font></font>
ColorDst = GL_ONE_MINUS_SRC_ALPHA,<font></font>
AlphaSrc = GL_ZERO,<font></font>
AlphaDst = GL_ONE_MINUS_SRC_ALPHA</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
You can use any geometry with any textures, starting cleaning from the layer from which you will need: </font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b4/538/994/0b453899413a5208fe9e90c8c9813f3f.gif"></div></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The smooth disappearance of the field is done similarly. </font><font style="vertical-align: inherit;">The issue price is one DrawCall.</font></font></li>
<li>    : <br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/653/96c/ccd/65396cccdc9f687f4156a2115520e50b.gif"></div><br>
 ,             UI,    .   , ¬´¬ª ,   ,  ¬´ ¬ª,     .  ,    :   ,       .   :<br>
<br>
<pre><code class="plaintext hljs">ColorSrc = GL_SRC_ALPHA,<font></font>
ColorDst = GL_ONE_MINUS_SRC_ALPHA,<font></font>
AlphaSrc = GL_ZERO,<font></font>
AlphaDst = GL_ONE</code></pre></li>
<li>,         :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d28/c3e/59a/d28c3e59add17227f8b03de8d41d2540.gif"></div><br>
<div class="spoiler"><b class="spoiler_title"> </b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffc/82a/f61/ffc82af61e49886eb73c1fd5ff20cbbb.gif"></div></div></div></li>
<li>  ¬´¬ª:<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/webt/ic/ml/tr/icmltrnyjda_u3jmvtadpbmu2eo.gif"></div><br>
<div class="spoiler"><b class="spoiler_title"> </b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/08b/68e/852/08b68e852abda76a41ba0b6559ff6509.gif"></div></div></div><br>
            .      ,        .   ‚Äî 2 DrawCalls.</li>
</ol><br>
<hr><br>
<div class="spoiler"><b class="spoiler_title">     Ambient occlusion</b><div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/00e/c3e/611/00ec3e611e8a55efe7b2a8494235c62c.gif"></div><br>
</div></div><br>
<hr><br>
<h2>   </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a downside, or rather restrictions: not all blends can be repeated for such a technique. Alpha mixing and additive are definitely possible, but you have to adapt or not use your own special blends. But there is a way out: you can separate the stages of rendering the scene. Part of it should be done by the reverse method, part of it is the usual one, and this is what we did for special effects on top of the field and post-process. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An important point with Additive and mixed rendering techniques: if it is drawn BEFORE the reverse rendering passage, and if there is no transparency information in the texture (texture like ‚Äúwhite spot on a black background‚Äù), then such an object will overwrite transparency. In the ‚Äúreturn‚Äù passage, information about this area will be lost, and visually it will look like a ‚Äúdark square‚Äù or a black border around a light additive spot:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c6e/4d0/fd8/c6e4d0fd8db8d8477efe064b04683fe7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This can be overcome by modifying additive blending in terms of mixing the alpha channel:</font></font><br>
<br>
<pre><code class="plaintext hljs">AlphaSrc = GL_ONE_MINUS_DST_ALPHA<font></font>
AlphaDst = GL_ONE</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But this is not suitable for all types of mixing, and it will be more reliable to modify the texture itself. </font><font style="vertical-align: inherit;">What is meant: </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If there are textures of the form:&nbsp;</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/946/611/f34946611f5ef341f383f9620291ca75.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/299/678/432/2996784325943157b8494d98a2181cc4.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you need to do one of them:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/2d3/602/7d22d36020fdc1f5cb4f38267ae19a2f.png"></div><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/be2/ecb/0b7/be2ecb0b79fbc39b74d698d2337e60d8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
That is, the brightness of the color channels must be converted into transparency and stretch the colors inversely with transparency. </font><font style="vertical-align: inherit;">The resulting and old texture should look the same on a black background. </font><font style="vertical-align: inherit;">Manually this is unlikely to succeed, it makes sense to make an automatic converter. </font><font style="vertical-align: inherit;">In this case, the channel conversion pseudo code will look like this:</font></font><br>
<br>
<pre><code class="plaintext hljs">RGB_old = Texel_in.rgb<font></font>
A_old = Texel_in.a<font></font>
A_middle = 1.0 / ((RGB_old) / 3.0) * A_old // linear color space<font></font>
RGB_new = RGB_old * A_middle;<font></font>
A_shift = minimum( 1.0 / RGB_new.r, 1.0)<font></font>
A_shift = minimum( 1.0 / RGB_new.g, A_shift)<font></font>
A_shift = minimum( 1.0 / RGB_new.b, A_shift)<font></font>
RGB_result = RGB_new * A_shift;&nbsp;<font></font>
A_result = (RGB_result) / 3.0)<font></font>
Texel_out = Vector4(RGB_result, A_result)</code></pre><br>
<hr><br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here I will go through the steps of rendering the scene of our project</font></font></b><div class="spoiler_text">&nbsp;<br>
<ol>
<li>   .     ,         -.<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74a/d07/24a/74ad0724a6d4de1c97189dea953ed9a2.png"></div></li>
<li> ,   ,  ,    ¬´¬ª :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea2/98b/a4a/ea298ba4a7aaba36c9bb1a381a4da7b7.png"></div><br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/807/66c/c91/80766cc91fd98c7d37c2f0107f4e9338.png"></div></li>
<li>       UI:<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/785/4c9/ccf/7854c9ccfd059b715ea79ea88ae04626.png"></div></li>
<li>  ,     , ,   :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/caa/958/a24/caa958a242d5bbae946879b0ac437659.png"></div></li>
<li>   :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/efd/d3a/fa4/efdd3afa40fb1e03c92e8ff6b89b21ff.png"></div></li>
<li>   :<br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/ec4/c46/df8ec4c465f3f353fdbbd2bab93e1e91.png"></div></li>
<li>  ,         .</li>
</ol><br>
<hr><br>
</div></div><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The method makes it possible to work quite simply and cheaply with the layers of the scene being drawn, using the alpha channel as a mask. </font><font style="vertical-align: inherit;">It is relatively simple to implement it in an already working project: it does not require deep modification of the graphics subsystem code, it is enough to change the rendering order and the mixing formula. </font><font style="vertical-align: inherit;">In places, it can significantly save performance. </font><font style="vertical-align: inherit;">There are limitations, but in most cases you can come to terms with them.</font></font></div>
      
    </div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/en487250/">https://habr.com/ru/post/en487250/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en487234/index.html">Iron or optimization? Badoo, Avito and Mamba - about PHP performance</a></li>
<li><a href="../en487238/index.html">How to design power grid protection equipment</a></li>
<li><a href="../en487242/index.html">February IT Events Digest</a></li>
<li><a href="../en487246/index.html">Tensor Certification Authority may compromise customer private keys</a></li>
<li><a href="../en487248/index.html">A little more about improper testing</a></li>
<li><a href="../en487254/index.html">How to use CCTV cameras not only to monitor intruders</a></li>
<li><a href="../en487256/index.html">Burn and return from the ashes or Phoenix people</a></li>
<li><a href="../en487258/index.html">Asynchronous PHP</a></li>
<li><a href="../en487260/index.html">NoVerify: a PHP linter that works fast</a></li>
<li><a href="../en487262/index.html">Open conference PHP Russia Online</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>