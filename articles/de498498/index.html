<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🚒 👎🏾 🚞 Untersuchung: Was ist höher als die Thread-Prioritäten in Windows? ✨ 🍝 🐅</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Diese Untersuchung begann, wie viele andere, mit der Tatsache, dass ich mein eigenes Geschäft machte und nicht versuchte, nach Problemen für mich selb...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Untersuchung: Was ist höher als die Thread-Prioritäten in Windows?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/498498/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Untersuchung begann, wie viele andere, mit der Tatsache, dass ich mein eigenes Geschäft machte und nicht versuchte, nach Problemen für mich selbst zu suchen. Dieses Mal habe ich nur den Deckel des Laptops geöffnet und versucht, mich beim System anzumelden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zum ersten Mal, als dies zu einer Verzögerung von zwanzig Sekunden führte, ignorierte ich das Problem in der Hoffnung, dass es sich von selbst lösen würde. Die nächsten Male habe ich über die Untersuchung nachgedacht, aber Leistungsprobleme, die auftreten, noch bevor Sie sich angemeldet haben, sind schwieriger zu lösen, und ich war faul. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich bemerkte, dass ich das Schließen des Laptops vermeiden wollte, weil ich Angst vor diesen zu häufigen Verzögerungen hatte, wurde mir klar, dass es Zeit war, dies ernsthaft zu tun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Glücklicherweise habe ich kürzlich den </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">UIforETW-</font></a><font style="vertical-align: inherit;"> Ringpuffer- </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trace behoben</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um es zuverlässig zu machen, habe ich es gestartet und auf das nächste Verzögerungsereignis gewartet. Ich musste nicht lange warten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich habe mehrere Male </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gebraucht</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um die </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">ETW-Spur</font></a><font style="vertical-align: inherit;"> für mich vollständig in Ordnung zu bringen </font><font style="vertical-align: inherit;">. Und da mir dieses Gebiet unbekannt war, dauerte es einige Zeit, um herauszufinden, was geschah. Ich habe das Problem immer noch nicht vollständig verstanden, aber 90% haben die Gründe für sein Auftreten verstanden. Ich habe viel gelernt, einschließlich einiger neuer Details zum Windows-Scheduler, und ich habe auch eine absolut effektive Lösung gefunden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die ideale Ablaufverfolgung, die ich beim Laden in Microsoft Windows Performance Analyzer (WPA) aufgezeichnet habe, sieht folgendermaßen aus:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/349/031/72d/34903172d4e4c5f85b33a02255942315.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Standardereignisse, Fokusfenster und CPU-Auslastung.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Diese Tabelle und zwei Diagramme enthalten eine Menge Informationen. Die obere Tabelle ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Allgemeine Ereignisse</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zeigt die aufgezeichneten Tastenanschläge für UIforETW. Ich habe versucht, einmal pro Sekunde eine Taste (virtueller Schlüsselcode 162) zu drücken, bis ein Passworteingabefeld angezeigt wird. Da diese 17 Tastenanschläge ausgewählt sind, werden sie in der folgenden Grafik mit vertikalen blauen Linien angezeigt, um die Ausführungszeit kritischer Ereignisse zu vereinfachen. Die x-Achse repräsentiert die Zeit in Sekunden.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die horizontalen Balken im oberen Diagramm ( </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenster im Fokus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) zeigen, welcher Prozess während dieser Zeit fokussiert ist. </font><font style="vertical-align: inherit;">Insgesamt gibt es sechs verschiedene Prozesse. </font><font style="vertical-align: inherit;">Die </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rückverfolgungsperiode</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ist die kurze Zeit, in der der Laptop geschlossen wurde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das untere Diagramm zeigt die </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU-Auslastung</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Informationen werden aus Kontextwechseldaten erhalten, daher müssen sie vollständig genau und vollständig sein. </font><font style="vertical-align: inherit;">In dieser Ablaufverfolgung gibt ein Wert von 100% den Moment an, in dem alle acht logischen Prozessoren meines Vier-Kern-Acht-Thread-Notebooks verwendet wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich die Trace-Daten erhalten hatte, musste ich herausfinden, was mein Laptop heimlich tut, wenn die Abdeckung geschlossen ist und bis ich zum System zurückkehre.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sturm vor der Flaute</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie wir sehen können, ist der Laptop am Anfang der Spur des Laptops relativ einfach, wie es sein sollte. Dann schloss ich den Deckel. Dies scheint zu einem Anstieg der CPU-Aktivität und einer Änderung des Fokus von Windows geführt zu haben. </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Fenster im Fokus wurde</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> von UIforETW in Idle, dann in csrss, zurück in Idle, in LogonUI und dann zurück in Idle geändert. Wer hätte das gedacht?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Während dieses Intervalls führte der Laptop ungefähr 17 Sekunden CPU-Verarbeitung verschiedener Typen durch. Ein Teil davon ist die Arbeit, die zum Abschalten benötigt wird. Teil - Dies sind Programme (einschließlich interner Google-Tools), die im Taskplaner für die Ausführung von "Wenn ein Benutzer eine Workstation sperrt" registriert sind. Dies ist sinnvoll. Mir ist sogar aufgefallen, dass daran gearbeitet wird, UI-Elemente für die Anmeldung zu erstellen, wenn der Benutzer weiter arbeitet - Sie müssen im Voraus vorbereitet sein, oder?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
17 Sekunden CPU - ziemlich lange, bis der Laptop in den Ruhezustand wechselt. </font><font style="vertical-align: inherit;">Selbst auf meinem Laptop mit vier Kernen und acht Threads dauert der Vorgang mehr als vier Sekunden. </font><font style="vertical-align: inherit;">Auf meinem Heim-Laptop dauert es mehr als 13 Sekunden CPU-Zeit, um einzuschlafen, und fast alle gehen zu Windows-Code. </font><font style="vertical-align: inherit;">Muss der </font><font style="vertical-align: inherit;">Diagnoserichtliniendienst </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wirklich</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einige SruDbTableSearches ausführen, bevor der Laptop ruhen kann? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke, diese übermäßige Arbeit beim Schlafengehen ist </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch ein</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem, aber das ist nicht </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">genau das</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem, das ich suche. </font><font style="vertical-align: inherit;">Also habe ich beschlossen, ihr den Rücken zu kehren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und erst viel später wurde mir klar, dass in dieser Zeit die Körner der Zerstörung meines Käfers geworfen wurden ...</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schlaf</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach dem Blockieren des Laptops erfolgt keine CPU-Aktivität. </font><font style="vertical-align: inherit;">In diesem speziellen Test wurde der Laptop für ungefähr 16 Sekunden gesperrt.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Krampfhaftes Erwachen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Aktivität der CPU beim Übergang in den Ruhezustand ist nicht mit der Aktivität zu vergleichen, als sie zu erwachen begann. </font><font style="vertical-align: inherit;">Während dieser Zeit benötigte mein überlasteter Laptop 22,6 Sekunden lang ungefähr 172 Sekunden CPU-Zeit (!!!). </font><font style="vertical-align: inherit;">Das ist viel Arbeit. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eines der Rätsel dieses Prozesses ist, dass die CPU-Auslastung etwa eine Sekunde nach dem ersten Aktivitätsausbruch auf nahezu Null sinkt. </font><font style="vertical-align: inherit;">Diese kurze Ausfallzeit erscheint angesichts des Chaos eher ungewöhnlich. </font><font style="vertical-align: inherit;">Aber ich denke, dass diese Funktion nicht mit dem Problem zusammenhängt, deshalb habe ich nicht darauf geachtet. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein weiteres Rätsel ist, warum </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so viele</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Programme werden nach dieser kurzen Pause zum Leben erweckt. Es ist lustig, dass der schwerwiegendste Eindringling, der für 31,6 von 172 Sekunden der CPU verantwortlich war, Windows Performance Analyzer (WPA) war - genau das Programm, mit dem ich Spuren analysiere. Die drei Kopien, die ich noch laufen ließ, arbeiten hart daran, meine Benutzeroberfläche zu rendern, obwohl sie noch nicht sichtbar ist. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Außerdem treten beim Initialisieren von Laptop-Geräten dunkle Muster auf. KeStallExecutionProcessor ist eine Warteschleife, und es war seltsam zu sehen, dass dies die ausführbarste Funktion des gesamten Systems ist. Ist ein zweiter ungerader Wartezyklus der einzige Weg, um die Ausrüstung zu starten? </font><font style="vertical-align: inherit;">Ist es </font><font style="vertical-align: inherit;">wirklich notwendig, 700 ms CPU-Zeit für die Initialisierung von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Maus und Tastatur aufzuwenden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ? Sollten Microsoft und Intel die Empfehlung von Microsoft ignorieren?</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">maximal 50 Mikrosekunden</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ?</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa7/c4e/cf4/fa7c4ecf4fe56c7c9014ee252f4557b0.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Treiber eines Wartezyklus. </font><font style="vertical-align: inherit;">i8042prt.sys wurde von Microsoft geschrieben. </font><font style="vertical-align: inherit;">Die folgenden beiden wurden von Intel erstellt. </font></font></i> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Letztendlich laufen in dieser Zeit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">viele</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Programme </font><font style="vertical-align: inherit;">aktiv </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Die meisten von ihnen scheinen mit dem gleichen Problem wie WPA konfrontiert zu sein - sie möchten unbedingt Pixel auf einem versteckten Bildschirm zeichnen, was auf einen Windows-Fehler hinweist. </font><font style="vertical-align: inherit;">Aber auch ohne diesen Fehler suchen explorer.exe und andere Programme aktiv nach </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> zu tun. </font><font style="vertical-align: inherit;">Obwohl diese übermäßige CPU-Auslastung ein notwendiger </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Teil des</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problems ist, ist sie </font><font style="vertical-align: inherit;">letztendlich </font><font style="vertical-align: inherit;">nicht </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das eigentliche</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Problem. </font><font style="vertical-align: inherit;">Also hörte ich wieder auf, auf sie zu achten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fokus</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bei der Analyse von Spuren ist es wichtig herauszufinden, wann wichtige Aktionen ausgeführt werden. Der Hauptbeweis waren Eingabeereignisse, da ich auf das Steuerelement geklickt habe, nachdem das Kennworteingabeformular angezeigt wurde. Hier sind die letzten drei Tastenanschläge der Steuertaste in ungefährer Form im </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fenster "Fenster im Fokus</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/158/50d/6f9/15850d6f9eecb243c2984cd4988c6bb1.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es scheint, dass die kritischen Ereignisse den Fokus von LockApp.exe erhalten, wonach der Fokus fast sofort LogonUI.exe erhält. </font><font style="vertical-align: inherit;">Vermutlich habe ich das Passwort in LogonUI.exe eingegeben (es ist praktisch, dass der Trace keine Tastaturereignisse abfing), wonach der Fokus kurz auf Explorer und dann auf UIforETW umgeschaltet wurde, von dem aus ich gestartet bin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht auch so aus, als ob LogonUI.exe vor LockApp.exe nicht fokussiert werden kann - dieses Muster wiederholt sich in allen von mir untersuchten Spuren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nach mehr als tausend Worten zur Lösung dieses Rätsels haben wir endlich eine klare Frage, die wir untersuchen können: Warum wird LockApp.exe nach Beendigung der Ausfallzeit fokussiert, es dauert zwanzig Sekunden?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben eine Frage? </font><font style="vertical-align: inherit;">Großartig, lass es uns beantworten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Unter </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung von</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Daten zur </font><em><font style="vertical-align: inherit;">CPU-Auslastung (Präzision)</font></em><font style="vertical-align: inherit;"> , die beim Wechseln von Inhalten erhalten wurden, stellte </font><font style="vertical-align: inherit;">ich schnell fest, dass LockApp.exe innerhalb von 20 Sekunden nach dem Aufwecken weniger als eine Millisekunde CPU-Zeit erhielt und länger als 14 Sekunden (von 35,158 s bis 49,827 s) nicht funktionierte allgemein:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f50/5dc/954/f505dc954915bdbf5a857eac5c4303f4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockApp funktioniert lange Zeit überhaupt nicht</font></font></i><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Dokumentation zur Bedeutung der Spalten in den Tabellen zur CPU-Auslastung (Präzise) finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ein Prozess oder Thread seit einiger Zeit nicht mehr ausgeführt wird und Sie herausfinden möchten, warum, finden Sie in der Regel wichtige Hinweise beim ersten Kontextwechsel nach einer langen Pause, nämlich beim Umschalten auf 49,827 Sekunden Ablaufverfolgung. </font><font style="vertical-align: inherit;">Ich habe die Spalten neu angeordnet, um mehr Daten von diesem Kontextwechsel anzuzeigen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7f4/23d/7ca/7f423d7cad82b87f4c5556551b0e8fec.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LockApp wird vorbereitet, aber nicht ausgeführt. Seltsam ...</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Anzahl gleich 1 bedeutet, dass wir die Daten für einen einzelnen Kontextwechsel betrachten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Time Since Last (38,2 Millionen Mikrosekunden) bedeutet, dass dieser Thread nicht innerhalb von 38,2 Sekunden ausgeführt wird. Das an sich ist weder gut noch schlecht. Leerlaufströme sparen Energie, und am Ende war der Laptop für einige Zeit in einem Traum. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Einschaltzeit sagt uns einfach, wann genau der Thread in die CPU passt - wann der Kontext zu diesem Thread wechselt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Und jetzt gehen wir zur Spalte Bereit. Er sagt uns, wie lange der Thread </font><font style="vertical-align: inherit;">zur Ausführung </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bereit war</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , aber nicht ausgeführt wurde. Mit anderen Worten, dieser Thread hat </font><font style="vertical-align: inherit;">auf </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">etwas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> gewartet (Schloss, Griff) und das </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ist etwas</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wurde freigegeben oder initiiert, aber der Thread wurde </font><font style="vertical-align: inherit;">19.493 Sekunden lang </font><font style="vertical-align: inherit;">immer </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">noch nicht ausgeführt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um die Spalte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereit (uns)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> besser zu verstehen </font><font style="vertical-align: inherit;">, können Sie sich die </font><font style="vertical-align: inherit;">Spalte </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bereitschaftszeit (en)</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ansehen </font><font style="vertical-align: inherit;">. Er sagt uns, wann der Stream vorbereitet ist. Wir sehen, dass dieser Thread für 30,333 Sekunden Ablaufverfolgung für die Ausführung vorbereitet wurde, aber erst 49,827 Sekunden ausgeführt wurde. Dies scheint wichtig zu sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Diese Anordnung der Spalten zeigt uns ansonsten den gleichen Kontextwechsel:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07f/b5c/c85/07fb5cc85d3dfc066a6c3cbd508ef7d7.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neuer Thread-Stapel und fertiger Thread-Stapel</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dieser Thread (von dem der neue Thread-Stapel NtWaitForWorkViaWorkerFactory erwartete) musste kurz nach dem Öffnen des Notebook-Deckels für 30,333 Sekunden nachverfolgt werden (der Systemprozess, der KeSetEvent aufruft). </font><font style="vertical-align: inherit;">Aber es begann nicht dann (was "gut" wäre), sondern nach 19.494 s, und das ist schlecht. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn ich eine solche Analyse der Erwartungen durchführe, verbringe ich normalerweise viel Zeit damit, herauszufinden, warum der Stream wartet und warum er nicht bereit ist. </font><font style="vertical-align: inherit;">Dies war jedoch das erste Mal, dass ich eine Analyse der Erwartungen durchführte, bei der dies nicht wichtig war, und die Frage war, warum dieser vorgefertigte Thread nicht ausgeführt wird.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fälle ...</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten Menschen verbringen nicht so viel Zeit damit, ETW-Spuren zu studieren, daher ist hier eine Erklärung erforderlich. </font><font style="vertical-align: inherit;">Das ist </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sehr</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> seltsam. </font><font style="vertical-align: inherit;">Wenn der Thread fertig ist, startet er normalerweise sofort oder nach einigen Millisekunden. </font><font style="vertical-align: inherit;">Die Bereitschaft des Streams bedeutet, </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wie der Name schon sagt</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dass der Stream zur Ausführung bereit ist und fast nichts ihn stören kann. </font><font style="vertical-align: inherit;">Aber lassen Sie uns herausfinden, was die Ausführung eines fertigen Threads verhindern kann.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thread-Priorität</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zuerst schlug ich vor, dass dies ein einfacher Fall von CPU-Hunger ist. Dutzende von Prozessen erfordern CPU-Zeit, und aus diesem Grund erhält LockApp erst dann die richtige, wenn die Last abnimmt. Diese Theorie </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">entspricht jedoch nicht ganz</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> den Symptomen, da der LockApp-Prozess </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auch</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ohne CPU-Zeit </font><font style="vertical-align: inherit;">etwa 18 Sekunden dauern </font><font style="vertical-align: inherit;">kann.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die CPU-Hungertheorie ist gut, weil sie überprüfbar ist. Es ist mir gelungen, die Priorität des LockApp-Prozesses mithilfe des Task-Managers zu erhöhen (während einer der kurzen Zeiträume, in denen er nicht vom UWP-System angehalten wurde). Daher wurde LockApp in der letzten Ablaufverfolgung, die ich für diesen Beitrag verwendet habe, mit hoher Priorität ausgeführt. Ein normaler Windows-Thread wird mit einer Priorität von ca. 8-10 ausgeführt. Die höchste Priorität, mit der ein regulärer Windows-Thread (nicht in Echtzeit) ausgeführt werden kann, ist 15. Meine ETW-Traces zeigten, dass LockApp immer mit Priorität 13 oder höher arbeitete. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist eine CPU-Zeitleiste für kritische 19,494 Sekunden, gruppiert und gefärbt nach Priorität des Threads ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">New In Pri</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die aktuelle Priorität, die dem Thread zugewiesen wurde). </font><font style="vertical-align: inherit;">Wir sehen, dass Threads mit den Prioritäten 4, 8, 9 und 10 den größten Teil der CPU-Zeit beanspruchen, insbesondere am Ende:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/81b/7d5/431/81b7d5431d0a307a93d2250fec9f2b1c.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwenden der CPU nach Priorität</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Hier ist ein weiteres Bild mit ausgeblendeten Threads mit den Prioritäten 0-12. </font><font style="vertical-align: inherit;">Jedes Mal, wenn das Diagramm unter 12,5% fällt (was einen logischen Prozessor der CPU-Zeit meines Acht-Thread-Notebooks bedeutet), </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">muss</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LockApp </font><font style="vertical-align: inherit;">gestartet werden, und es wird absolut unglaublich, dass die Priorität verhindert, dass es so oft ausgeführt wird, wenn viele Threads mit niedrigerer oder gleicher Priorität ausgeführt werden Holen Sie sich eine Menge Zeit.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2ec/c2c/66b/2ecc2c66b4df4902a3c5be388596524f.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CPU-Auslastung mit Priorität, nur Threads mit hoher Priorität</font></font></i><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beseitigen Sie die Prioritätsinversion</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es wird spekuliert, dass Windows-Prioritätsinversionsalgorithmen anderen Threads so förderlich sind, dass LockApp.exe blockiert wird. </font><font style="vertical-align: inherit;">Da die oben gezeigten Grafiken jedoch zeigen, dass bei Planungsentscheidungen echte Prioritäten verwendet werden, muss diese (immer nicht überzeugende) Annahme aufgegeben werden.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Entladen des Stapelkerns</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich auf Twitter über dieses Rätsel sprach, schlug einer der Kommentatoren vor, dass </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">der Thread-Core-Stack entladen wurde</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ich war mit dieser Situation nicht vertraut, aber nach </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">John Werths</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Erklärungen </font><font style="vertical-align: inherit;">(er versteht auf seinem Gebiet) habe ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">das Austauschen des Kernel-Stacks ausgeschaltet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den Computer neu gestartet. </font><font style="vertical-align: inherit;">Nichts hat sich geändert. </font><font style="vertical-align: inherit;">Tatsächlich dachte ich nicht, dass dies helfen würde, da ich 32 GB Speicher habe und das Problem wiederholt und häufig auftritt. </font><font style="vertical-align: inherit;">aber es war besser, sich dessen sicher zu sein.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozess anhalten</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da LockApp eine moderne UWP-Anwendung ist, unterliegt sie ähnlichen Einschränkungen wie Smartphone-Apps. Dies bedeutet unter anderem, dass es angehalten werden kann, wenn es nicht im Vordergrund steht, und dann „wieder eingefroren“ werden kann, wenn es wieder in den Vordergrund zurückkehrt. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">James Forshaw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> schlug vor </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Microsoft-Windows-Kernel-Process ETW aufzuzeichnen</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , um Daten dazu zu erhalten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ereignisse sollen maximale Verwirrung stiften. Der Name der Aufgabe " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prozess</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> einfrieren" </font><em><font style="vertical-align: inherit;">wird</font></em><font style="vertical-align: inherit;"> sowohl für "Auftauen" als auch für "Einfrieren" verwendet. Die Version des Ereignisses " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">win: Stop"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bedeutet, dass der Prozess </font><em><font style="vertical-align: inherit;">gestartet</font></em><font style="vertical-align: inherit;"> wird (er hat das Einfrieren gestoppt), und die Version von " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">win: Start"</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bedeutet, dass der Prozess stoppt (beginnt einzufrieren). All dies ist äußerst logisch, aber sehr verwirrend. Wenn die Ereignisnamen in Einfrieren und Auftauen unterteilt wären, würde es weniger Verwirrung geben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt keine Dokumentation für diese Ereignisse, aber dank der Analyse habe ich festgestellt, dass diese Ereignisse immer vom </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hintergrundaufgaben- / Broker-Infrastrukturdienst erstellt werden</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Der Name und die Prozess-ID des entsprechenden Prozesses werden im Feld FrozenProcessID angegeben.</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e04/32f/424/e0432f42442fa30ad0f7e6ed77f8d1c2.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessFreeze-Ereignisse (auch zum Abtauen verwendet) Es</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
war interessant, diesen Anbieter zu untersuchen - er hat viele vielversprechende Ereignisse -, aber am Ende stellte sich heraus, dass LockApp während der Ablaufverfolgung nicht pausierte oder abtaute. </font><font style="vertical-align: inherit;">Dieser Anbieter schien jedoch sehr nützlich zu sein, daher habe ich </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UIforETW</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> so </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;">geändert</font></a><font style="vertical-align: inherit;"> , dass zukünftige Versionen ihn immer aufschrieben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben bereits alles ausgeschlossen</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keine der oben beschriebenen Theorien schien mir sehr wahrscheinlich, und jetzt haben wir sie alle ausgeschlossen. </font><font style="vertical-align: inherit;">Ich begann nach Hilfe zu suchen und bat mich, mir Ideen von einem Microsoft-Freund zu geben. </font><font style="vertical-align: inherit;">In diesem Moment stellte ich fest, dass die in Windows so bekannte Flusspriorität 0-31 nur fünf Bits mit niedriger Priorität eines </font><font style="vertical-align: inherit;">Systems mit </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">voller</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Priorität sind.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verwendung der offiziellen Position</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es stellte sich heraus, dass meine Unwissenheit meine eigene Schuld war. </font><font style="vertical-align: inherit;">Wenn ich alle 108 Seiten des Abschnitts " </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> " </font><font style="vertical-align: inherit;">von </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Internals, 7. Ausgabe, Teil 1</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">sorgfältig lesen </font><font style="vertical-align: inherit;">würde, würde ich verstehen, was passiert. </font><font style="vertical-align: inherit;">Wenn Sie weiterspringen möchten, finden Sie dieses Thema auf den Seiten </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">287 bis 295</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieses Feld mit hoher Priorität, von dem ich nichts wusste, heißt </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rang</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Es wird in WPA als versteckte Standardspalte (um es zu finden, müssen Sie den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ansichtseditor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> öffnen) mit dem Namen </font><em><font style="vertical-align: inherit;">NewThreadRank angezeigt</font></em><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Bei der Planung von Threads hat der Thread-Rang Vorrang vor der Priorität. </font><font style="vertical-align: inherit;">Fast alle Streams haben Rang 0, und ein Stream mit Rang 0 hat immer eine höhere Priorität als ein Stream mit Rang 2. Durch Einfügen einer Spalte</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NewThreadRank</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und </font><em><font style="vertical-align: inherit;">wenn</font></em><font style="vertical-align: inherit;"> wir auf die linke Seite der Tabelle schauen, können wir das Problem sofort erkennen:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/745/f0e/374745f0eeaee797c6a8472f62d5b3f4.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Rang ist wichtiger als die Priorität</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
. LockApp.exe-Streams haben Rang 2, was bedeutet, dass sie trotz Priorität 14 die niedrigste Priorität im System haben.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine fast vollständige Erklärung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da sich herausstellte, dass LockApp.exe-Threads Rang 2 haben, können sie nur ausgeführt werden, wenn </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keiner</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> der Threads mit Rang 0 ausgeführt werden soll. </font><font style="vertical-align: inherit;">Da viele Anwendungen (aus unbekannten Gründen) ihre unsichtbaren Bildschirme aktiv rendern, kämpfen sie um jede Menge CPU-Zeit und lassen nichts für höhere Ränge übrig. </font><font style="vertical-align: inherit;">Sobald LockApp.exe einen winzigen Bruchteil der CPU-Zeit erhält, wechselt es schnell auf Rang 0 (und die CPU-Last sinkt). Danach wird der Anmeldevorgang auf die übliche Weise ausgeführt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich diese Informationen erfahren hatte, begann ich zu untersuchen, wie sich der Rang von LockApp im Laufe der Zeit ändert. In den letzten Sekunden wechselte LockApp plötzlich von Rang 0 auf Rang 2, bevor es in den Ruhezustand ging. Der Rang soll verhindern, dass die CPU zu viel Zeit in Anspruch nimmt, z. B. wenn </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Windows Photos zu sehr auf unerwünschte Hintergrundverarbeitung bedacht ist</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> und den Übergang vornimmt von Rang 2 bis 19:</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbc/b93/e8b/cbcb93e8bc2145f78e5ea10edba3fa8e.png"></div><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Microsoft.Photos geht den Rang runter</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Aus der Dokumentation geht hervor, dass der Hauptzweck des Stream-Ranges die gerechte Aufteilung der CPU-Zeit zwischen Sitzungen auf dem Computer ist, damit die Prozesse eines Benutzers anderen nicht schaden. Beide Optionen für die Verwendung des Rangs machen deutlich, dass der Rang des Streams nur erhöht werden sollte, wenn viel CPU-Zeit verbraucht wird. Wenn der Laptop in den Ruhezustand versetzt wurde, verwendete LockApp.exe nur 79,3 ms CPU-Zeit und der Rest des Systems - 17 von der CPU-Zeit . Trotzdem hat das Betriebssystem aus irgendeinem Grund beschlossen, LockApp im Ruhezustand auf 2 herunterzustufen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Betriebssystem ändert den Rang des Streams nur, wenn er zur „Planungsgruppe“ ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KSCHEDULING_GROUP) gehört</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) und die meisten Threads in einer typischen Windows-Installation sind keine Mitglieder. </font><font style="vertical-align: inherit;">Folglich unterliegen die meisten Threads keiner Rangänderung, sodass sie die CPU-Zeit so verbringen können, wie sie möchten.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verbleibende Rätsel</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Leider ist immer noch unklar, warum LockApp.exe vor dem Einschalten des Ruhezustands auf Rang 2 fällt. Ich gehe davon aus, dass LockApp in der Planungsgruppe ist und sich wahrscheinlich einer der Algorithmen falsch verhält. Aber ich konnte keine API finden, um dies zu untersuchen, und die Zeit lief davon. Wenn Sie Details kennen, schreiben Sie in die Kommentare zum Originalartikel. Das Prinzip, Rang als wichtigste Komponente bei Planungsentscheidungen zu verwenden, sollte meines Erachtens unvermeidlich zusammenbrechen, wenn die meisten Prozesse im System nicht daran beteiligt sind - Threads in Planungsgruppen laufen immer Gefahr, ohne die erforderlichen Ressourcen zu bleiben. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dynamic Resource Allocation Planning</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DFSS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) ist zum Scheitern verurteilt, wenn die meisten Threads nicht beteiligt sind.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich weiß auch nicht, warum so viele Anwendungen nach dem Schlafengehen aktiv bleiben. Dies wird normalerweise durch die Tatsache erklärt, dass „viele Timer enden, wenn sich der Laptop mehrere Stunden im Ruhemodus befindet“. Diese Erklärung ist jedoch nicht geeignet, wenn der Laptop nur einige Sekunden im Traum war und das WPA-Rendering-Verhalten anzeigt, dass im Fenstersystem etwas passiert etwas stimmt nicht. Fügen Sie dazu Anwendungen mit schlechtem Verhalten und Wartezyklus-Treiber hinzu, und alles wird im Laufe der Zeit von der CPU gestapelt.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Tatsache, dass CPU-Stürme nachlassen und LockApp gleichzeitig gestartet wird, führt zu einer offensichtlichen Erklärung: LockApp kann nur funktionieren, wenn die CPU-Nachfrage sinkt. </font><font style="vertical-align: inherit;">Es gibt jedoch eine ebenso überzeugende Erklärung: Sobald LockApp die Fähigkeit zum Ausführen erhält (oder möglicherweise von LogonUI), sinkt die CPU-Nachfrage. </font><font style="vertical-align: inherit;">Beide Erklärungen funktionieren, aber ich denke, die zweite ist plausibler, weil wir sonst nicht erklären können, warum das scheinbar endlose Rendern von WPA plötzlich aufhört.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lösung</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sobald ich feststellte, dass LockApp.exe eine separate Anwendung ist, die Probleme beim Starten hat und das Erhöhen der Priorität nicht hilft, habe ich sie deaktiviert. </font><font style="vertical-align: inherit;">Die Datei DisableLockScreen.reg hat mir dabei geholfen:</font></font><br>
<br>
<blockquote>Windows Registry Editor Version 5.00<br>
[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Personalization]<br>
“NoLockScreen”=dword:00000001</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Durch Ausschalten des Sperrbildschirms wird der Laptop sofort nach dem Öffnen der Abdeckung aktiviert. </font><font style="vertical-align: inherit;">Ich habe weder Bremsen noch Stürme der CPU bemerkt, und jetzt dauert es einen Schritt weniger, um einzutreten. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">erste Twitter-Beitrag, den</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ich gepostet habe, als ich zum ersten Mal auf das Problem gestoßen bin, enthält eine Zeitleiste für eine Untersuchung, die für jemanden nützlich sein kann. </font><font style="vertical-align: inherit;">Außerdem kamen dank ihnen viele kluge Leute von Twitter zu dem Beitrag. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Als ich zu dem Artikel zurückkehrte, stellte ich fest, dass das Problem nach dem erneuten Einschalten des Sperrbildschirms verschwand. </font><font style="vertical-align: inherit;">Ein einfacher Neustart hat das Problem nicht behoben. Im Februar habe ich viele Male neu gestartet, aber wir wissen wahrscheinlich nicht, warum es verloren gegangen ist.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diskussionen</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / Programmierung</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r / Windows10</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hacker-News</font></font></a></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de498486/index.html">So erweitern Sie die englischsprachige Semantik für Suchmaschinenwerbung in einer engen Nische</a></li>
<li><a href="../de498490/index.html">Ein effektives Zertifizierungssystem, mit dem Sie ein besserer Marktführer werden können</a></li>
<li><a href="../de498492/index.html">Schatz, wir töten Bürokratie: Wie die Digitalisierung den Dialog zwischen Lieferanten und X5 verändert</a></li>
<li><a href="../de498494/index.html">JEP 360: Versiegelte Typen (Vorschau)</a></li>
<li><a href="../de498496/index.html">Ankündigung des Online-Mitap PiterJS # 46: Leistung, komplexe UI-Komponenten und CSS-in-TS</a></li>
<li><a href="../de498500/index.html">Was gibt es in Quarantäne zu sehen? Eine Auswahl von Materialien aus Technostream (Teil 1)</a></li>
<li><a href="../de498504/index.html">Neujahrsgrüße und COVID-19: Wie Hacker die Nachrichten nutzen</a></li>
<li><a href="../de498510/index.html">X. X. Eine Übersicht über die Box-Version von Telefonie und Verbindung zu einem Remote-Standort</a></li>
<li><a href="../de498512/index.html">Staus in einer kleinen Stadt für ein kleines Budget bekämpfen: Ergebnisse von 6 Monaten des Projekts</a></li>
<li><a href="../de498516/index.html">Postbote - AutoMetrica-Metriken in AppMetrica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>