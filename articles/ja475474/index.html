<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❄️ 🤷 🎫 ほとんどの場合、XMLは誤って適用されます ⚽️ 🐈 🔟</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="XMLは1996年に発明されました。彼が現れたとたんに、その適用の可能性はすでに誤解され始めており、彼らが彼を適応させようとした目的のために、彼は最良の選択ではありませんでした。
 
 私が今まで見たXMLスキーマの大部分は、XMLの不適切または誤用であると言っても過言ではありません。さらに、このX...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>ほとんどの場合、XMLは誤って適用されます</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/475474/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/m7/os/0h/m7os0het6sqwqvxira3t8qaqzjq.jpeg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLは1996年に発明されました。彼が現れたとたんに、その適用の可能性はすでに誤解され始めており、彼らが彼を適応させようとした目的のために、彼は最良の選択ではありませんでした。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私が今まで見たXMLスキーマの大部分は、XMLの不適切または誤用であると言っても過言ではありません。さらに、このXMLの使用は、XMLの主な内容についての根本的な誤解を証明しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLはマークアップ言語です。</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">これはデータ形式ではありません</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ほとんどのXMLスキームでは、この区別が明らかに考慮されておらず、XMLとデータ形式を混同しており、実際にはデータ形式が必要だったため、最終的にXML自体の選択にエラーが発生しました。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
詳細には触れませんが、XMLはテキストのブロックに構造とメタデータで注釈を付けるのに最適です。主な作業がテキストのブロックでの作業ではない場合、XMLの選択が正当化される可能性はほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この観点から、XMLスキーマがどの程度適切に作成されているかを確認する簡単な方法があります。提案されたスキーマのドキュメントを例に取り、すべてのタグと属性を削除します。残されたものに意味がない場合（または空の行が残っている場合）は、スキーマが正しく構築されていないか、XMLを使用しないでください。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以下に、正しく構成されていない回路の最も一般的な例をいくつか示します。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">rot</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"John"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"London"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">rot</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、XMLで単純なキーと値のディクショナリを表現しようとする不合理で奇妙な（非常に広範囲ではありますが）試みの例を示します。すべてのタグと属性を削除すると、空の行が残ります。本質的に、このドキュメントは、それがどんなに不合理に聞こえても、空の行の意味論的注釈です。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"John"</span> <span class="hljs-attr">city</span>=<span class="hljs-string">"London"</span> /&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに悪いことに、ここでは、辞書を表現する贅沢な方法として、空の文字列のセマンティックアノテーションだけではなく、今回は「辞書」がルート要素の属性として直接エンコードされています。このため、要素の特定の属性名のセットは未定義で動的になります。さらに、これは著者が本当に表現したかったのは単純なキーと値の構文だけだったことを示していますが、代わりに彼はXMLを使用するというまったく奇妙な決定を行い、使用するプレフィックスとして単一の空の要素の使用を強制しました属性構文。そして、そのような計画は私に頻繁に出くわします。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">rot</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"name"</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"city"</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">rot</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは既により良いものですが、キーは何らかの理由でメタデータですが、値はそうではありません。辞書を非常に奇妙に見る。すべてのタグと属性を削除すると、情報の半分が失われます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLの正しい辞書式は次のようになります。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">rot</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>Name<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>John<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">item</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span>City<span class="hljs-tag">&lt;/<span class="hljs-name">key</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>London<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">item</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">rot</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、人々がXMLをデータ形式として使用し、それを使用して辞書を整理するという奇妙な決定をした場合、彼らは彼らがしていることが不適切で便利ではないことを理解する必要があります。</font><font style="vertical-align: inherit;">それでも、多くの場合、設計者はアプリケーションを構築するために誤ってXMLを選択します。</font><font style="vertical-align: inherit;">しかし、さらに多くの場合、XMLが単にこれに適していないという事実を無視して、上記の形式のいずれかでXMLを無意味に使用することによって状況を悪化させます。</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最悪のXMLスキーマ？</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ちなみに、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">私が今まで見た中で最悪のXMLスキーマの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">賞品は</font><i><font style="vertical-align: inherit;">、</font></i><font style="vertical-align: inherit;"> Polycom IPテレフォニー電話用の自動リソース割り当て構成ファイルのフォーマットです。</font><font style="vertical-align: inherit;">このようなファイルには、TFTPを介してXML要求ファイルをロードする必要があります。一般的に、このようなファイルからの抜粋を次に示します。</font></font><br>
<br>
<pre><code class="xml hljs"><span class="hljs-tag">&lt;<span class="hljs-name">softkey</span>
        <span class="hljs-attr">softkey.feature.directories</span>=<span class="hljs-string">"0"</span>
        <span class="hljs-attr">softkey.feature.buddies</span>=<span class="hljs-string">"0"</span>
        <span class="hljs-attr">softkey.feature.forward</span>=<span class="hljs-string">"0"</span>
        <span class="hljs-attr">softkey.feature.meetnow</span>=<span class="hljs-string">"0"</span>
        <span class="hljs-attr">softkey.feature.redial</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.feature.search</span>=<span class="hljs-string">"1"</span>

        <span class="hljs-attr">softkey.1.enable</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.1.use.idle</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.1.label</span>=<span class="hljs-string">"Foo"</span>
        <span class="hljs-attr">softkey.1.insert</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.1.action</span>=<span class="hljs-string">"..."</span>

        <span class="hljs-attr">softkey.2.enable</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.2.use.idle</span>=<span class="hljs-string">"1"</span>
        <span class="hljs-attr">softkey.2.label</span>=<span class="hljs-string">"Bar"</span>
        <span class="hljs-attr">softkey.2.insert</span>=<span class="hljs-string">"2"</span>
        <span class="hljs-attr">softkey.2.action</span>=<span class="hljs-string">"..."</span> /&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これは悪い冗談ではありません。</font><font style="vertical-align: inherit;">そして、これは私の発明ではありません：</font></font><br>
<br>
<ul>
<li>       ,       .<br>
</li>
<li>        ,      , <i>   </i>.<br>
</li>
<li> , ,   <code>softkey.</code>,     <code>&lt;softkey/&gt;</code>, ,   <code>feature.</code>,     <code>&lt;feature/&gt;</code>  . .,   ,          .<br>
</li>
<li>, ,   ,           —  ! ,  <code>up.</code>    <code>&lt;userpreferences/&gt;</code>.       — ,   .<br>
</li>
</ul><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントまたはデータ</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。時折、誰かがXMLとJSONを比較しようとして絶対に奇妙なことを行い、それによって彼がどちらか一方を理解していないことを示します。 XMLはドキュメントマークアップ言語です。 JSONは構造化データ形式であるため、相互に比較することは、ウォームとソフトを比較するようなものです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これを理解するには、</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントとデータの</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">違いの概念が役立ちます</font><font style="vertical-align: inherit;">。 XMLの類似物として、機械可読ドキュメントを任意に取得できます。これは機械による読み取りを目的としていますが、比喩的には文書に関連しており、この観点から見ると、実際にはほとんどの場合機械可読ではないPDF文書に匹敵します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
たとえば、XMLでは、要素の順序が重要です。また、JSONでは、オブジェクト内のキーと値のペアの順序は意味がなく、定義されていません。キーと値のペアから順序付けられていないディクショナリを取得する場合、このファイルの項目が実際に続く順序は重要ではありません。ただし</font><font style="vertical-align: inherit;">、ドキュメントには特定の順序があるため、</font><font style="vertical-align: inherit;">このデータからさまざまな</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ドキュメントを作成</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">できます</font><font style="vertical-align: inherit;">。比喩的には、これは紙のドキュメントの類似物ですが、印刷物やPDFファイルとは異なり、物理的な寸法はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
XMLでの辞書の正しい表現の私の例では、JSON言語での表現とは対照的に、辞書の要素の順序が示されています。この順序は無視できません。この線形性は、ドキュメントモデルとXML形式に固有のものです。このXMLドキュメントを解釈するとき、誰かが順序を無視することを決定するかもしれませんが、この問題はフォーマット自体の議論を超えているため、これについて議論することは意味がありません。さらに、カスケードスタイルシートをドキュメントに添付してブラウザーで表示できるようにすると、辞書の要素が特定の順序で続き、それ以外の方法では見えないことがわかります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
つまり、辞書（構造化データのフラグメント）を</font><i><font style="vertical-align: inherit;">n</font></i><font style="vertical-align: inherit;">に変換できます。</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">さまざまな可能なドキュメント（XML、PDF、紙など）</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。n</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">は辞書内の要素の可能な組み合わせの数であり、他の可能な変数はまだ考慮されていません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、このことからも、データを単独で送信する場合は、機械で読み取り可能なドキュメントを使用しても効果がないこともわかります。それはモデルを使用します、この場合、それは余分です、それは干渉するだけです。また、ソースデータを抽出するためには、プログラムを記述する必要があります。特定の段階でドキュメントとしてフォーマットされない（たとえば、CSSまたはXSLT、あるいはその両方を使用する）ためにXMLを使用することはほとんど意味がありません。これが（唯一ではないにしても）主な理由であるためです。ドキュメントモデルに固執します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、XMLには数値（またはブール式、またはその他のデータ型）の概念がないため、この形式で表されるすべての数値は、追加のテキストと見なされます。データを抽出するには、スキームと、対応する表現されたデータとの関係を知る必要があります。また、コンテキストに基づいて、テキストの1つまたは別の要素が数値である場合、それを数値に変換する必要があることなどを知る必要もあります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、XMLドキュメントからデータを抽出するプロセスは、たとえば、数値データの多くのページを形成するテーブルを含むスキャンされたドキュメントを認識するプロセスとそれほど変わりません。はい、原則として可能ですが、極端な場合を除き、他に選択肢がない場合を除いて、これは最適な方法ではありません。賢明な決定は、ドキュメントモデルに埋め込まれていない元のデータのデジタルコピーを単に見つけることです。この場合、データは特定のテキスト表現と組み合わされます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ただし、XMLがビジネスで人気があることはまったく驚きません。その理由は、（紙に書かれた）文書の形式がビジネスにとって理解可能であり、親しみやすいためであり、彼らはそこで親しみやすく理解しやすいモデルを引き続き使用したいと考えています。同じ理由で、ビジネスでは、機械処理フォーマットではなくPDFのドキュメントを使用することがよくあります。これは、ドキュメントが特定の物理サイズの印刷ページの概念に依然として関連付けられているためです。これは、印刷される可能性が低いドキュメント（たとえば、8,000ページのレジストリドキュメントのPDFファイル）にも適用されます。この観点から見ると、ビジネスでのXMLの使用は本質的にスキューモーフィズムの現れで​​す。人々は、限られたサイズの印刷されたページの比喩的な考えを理解し、印刷されたドキュメントに基づいてビジネスプロセスを作成する方法を理解しています。これがあなたのガイドラインなら、機械で読み取り可能な物理的なサイズに制限のないドキュメント-XMLドキュメント-は、ドキュメントのなじみがよく快適なアナログでありながら、革新を表しています。これは、データを提示するための不正確で過度に歪んだ方法を維持することを妨げるものではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これまでのところ、この形式の適切な使用法を本当に言えるのは、XHTMLとDocBookだけです。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja475464/index.html">アーキテクトの方法：認定と製品の没入</a></li>
<li><a href="../ja475466/index.html">Intel Xeon E-2200。サーバーコア、予算</a></li>
<li><a href="../ja475468/index.html">週に4日程度のMicrosoftの実験の何が問題になっているのか、40％の効率を見ても頭がおかしくならない</a></li>
<li><a href="../ja475470/index.html">2019年にBIアナリティクス市場が向かうところ</a></li>
<li><a href="../ja475472/index.html">氷が滑りやすいのはなぜですか：子供の質問に対する科学的回答</a></li>
<li><a href="../ja475476/index.html">データメッシュ：モノリスなしでデータを操作する方法</a></li>
<li><a href="../ja475478/index.html">Netflixエクスペリエンス：Netflix Inside</a></li>
<li><a href="../ja475480/index.html">あなたは何者ですか？なりすましと人間を区別する方法</a></li>
<li><a href="../ja475486/index.html">ARクリエーター：新しい職業の出現</a></li>
<li><a href="../ja475488/index.html">PyTorchの紹介：自然言語処理のディープラーニング</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>