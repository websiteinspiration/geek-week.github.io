<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🔬 👧🏼 🈲 Programador GO: agora não é cooperativo? 🧑🏿‍🤝‍🧑🏿 👣 🌄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Se você leu as notas de versão da versão GO 1.14, provavelmente notou algumas mudanças bastante interessantes no tempo de execução do idioma. Por isso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programador GO: agora não é cooperativo?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/502506/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você leu as notas de versão da versão GO 1.14, provavelmente notou algumas mudanças bastante interessantes no tempo de execução do idioma. </font><font style="vertical-align: inherit;">Por isso, fiquei muito interessado no item: "Agora, as goroutinas são preemptivamente assincrônicas". </font><font style="vertical-align: inherit;">Acontece que o agendador GO (agendador) agora não é cooperativo? </font><font style="vertical-align: inherit;">Bem, depois de ler a </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proposta</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> correspondente na diagonal, a </font><font style="vertical-align: inherit;">curiosidade foi satisfeita. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No entanto, depois de um tempo, decidi pesquisar as inovações em mais detalhes. </font><font style="vertical-align: inherit;">Eu gostaria de compartilhar os resultados desses estudos.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/s0/ur/hn/s0urhnlqgwhwtkwumpnyd2hfmyy.png" alt="imagem"><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requisitos de sistema</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Os itens descritos abaixo exigem do leitor, além do conhecimento da linguagem GO, conhecimentos adicionais, a saber:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> compreensão dos princípios do agendador (embora eu tentarei explicar abaixo, “nos dedos”)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entendendo como o coletor de lixo funciona</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> entender o que é o assembler GO </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No final, deixarei alguns links que, na minha opinião, cobrem bem esses tópicos.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Brevemente sobre o planejador</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primeiro, deixe-me lembrá-lo do que é multitarefa cooperativa e não cooperativa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Com a multitarefa não cooperativa (crowding out), todos conhecemos o exemplo do agendador do SO. Esse agendador trabalha em segundo plano, descarrega os threads com base em várias heurísticas e, em vez do tempo de CPU descarregado, outros threads começam a receber. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O planejador da cooperativa é caracterizado por um comportamento diferente - ele dorme até que uma das goroutines o acorde claramente com uma pitada de prontidão para dar seu lugar a outra. O planejador decidirá por si mesmo se é necessário remover a goroutina atual do contexto e, em caso afirmativo, quem colocar em seu lugar. Foi assim que o agendador GO funcionou. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Além disso, consideramos os pilares com os quais o agendador opera:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Processadores P - lógicos (podemos alterar seu número com a função runtime.GOMAXPROCS), em cada processador lógico uma goroutine pode ser executada independentemente de cada vez. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Threads do M - OS. </font><font style="vertical-align: inherit;">Cada P é executado em um encadeamento de M. Observe que P nem sempre é igual a M; por exemplo, um encadeamento pode ser bloqueado por syscall e, em seguida, outro encadeamento será alocado para seu P. </font><font style="vertical-align: inherit;">E há CGO e outras e outras nuances.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">G - gorutinas. </font><font style="vertical-align: inherit;">Bem, aqui está claro, G deve ser executado em cada P e o planejador monitora isso.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
E a última coisa que você precisa saber e quando o agendador realmente chama goroutine? </font><font style="vertical-align: inherit;">É simples, geralmente as instruções de chamada são inseridas pelo compilador no início do corpo (prólogo) da função (um pouco mais tarde falaremos sobre isso com mais detalhes).</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E qual é o problema realmente?</font></font></h3><br>
<img src="https://habrastorage.org/webt/8o/fa/qt/8ofaqt_aquvkvzoskizadsuzfyw.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desde o início do artigo, você já percebeu que o princípio do trabalho do agendador mudou no GO, vamos considerar os motivos pelos quais essas alterações foram feitas. </font><font style="vertical-align: inherit;">Dê uma olhada no código:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sob o spoiler</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
		<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
		<span class="hljs-keyword">for</span> {<font></font>
			u -= <span class="hljs-number">2</span>
			<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
				<span class="hljs-keyword">break</span><font></font>
			}<font></font>
		}<font></font>
	}()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>) <span class="hljs-comment">//    main   ,         </span><font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se você o compilar com a versão GO &lt;1,14, a linha "go 1,13 nunca esteve aqui" não será exibida na tela. </font><font style="vertical-align: inherit;">Isso acontece porque, assim que o agendador dá tempo ao processador para a goroutine com um loop infinito, ele captura completamente P, nenhuma chamada de função ocorre dentro dessa goroutine, o que significa que não vamos mais ativar o agendador. </font><font style="vertical-align: inherit;">E apenas uma chamada explícita para runtime.Gosched () deixará nosso programa terminar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este é apenas um exemplo em que a goroutine captura P e, por um longo tempo, impede que outras goroutines sejam executadas neste P. Mais opções para quando esse comportamento causa problemas podem ser encontradas lendo a proposta.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analisar proposta</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A solução para esse problema é bastante simples. Vamos fazer o mesmo que no agendador do SO! Apenas deixe o GO executar a goroutine de P e colocar outra lá, e para isso usaremos as ferramentas do sistema operacional. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
OK, como implementar isso? Permitiremos que o tempo de execução envie um sinal para o fluxo no qual a goroutine trabalha. Vamos registrar o processador deste sinal em cada fluxo de M, a tarefa do processador é determinar se a goroutina atual pode ser suplantada. Nesse caso, salvaremos seu estado atual (registradores e o estado da pilha) e forneceremos recursos para outro, caso contrário, continuaremos executando a goroutina atual. Vale ressaltar que o conceito com sinal é uma solução para sistemas baseados em UNIX, enquanto, por exemplo, a implementação para Windows é um pouco diferente. A propósito, o SIGURG foi selecionado como um sinal para o envio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A parte mais difícil desta implementação é determinar se a goroutine pode ser forçada a sair. </font><font style="vertical-align: inherit;">O fato é que alguns lugares em nosso código devem ser atômicos, do ponto de vista do coletor de lixo. </font><font style="vertical-align: inherit;">Chamamos esses lugares de pontos inseguros. </font><font style="vertical-align: inherit;">Se apertarmos a goroutina no momento da execução do código a partir de um ponto inseguro e, em seguida, o GC iniciar, ele substituirá o estado da nossa goroutina, inserida em um ponto inseguro, e poderá fazer as coisas. </font><font style="vertical-align: inherit;">Vamos dar uma olhada no conceito de seguro / não seguro.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Você foi lá, GC?</font></font></h3><br>
<img src="https://habrastorage.org/webt/yw/ao/mw/ywaomwcstazbytzl9gwewm9agy8.png" alt="imagem"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas versões anteriores à 1.12, o tempo de execução Gosched usava pontos de segurança em locais onde você pode definitivamente chamar o agendador sem medo de que caíssemos na seção atômica do código do GC. </font><font style="vertical-align: inherit;">Como já dissemos, os dados dos pontos de segurança estão localizados no prólogo de uma função (mas não de todas as funções, lembre-se). </font><font style="vertical-align: inherit;">Se você desmontou o montador go-shn, pode se opor - nenhuma chamada óbvia ao planejador é visível lá. </font><font style="vertical-align: inherit;">Sim, mas você pode encontrar a instrução de chamada runtime.morestack lá e, se você olhar dentro dessa função, uma chamada do planejador será encontrada. </font><font style="vertical-align: inherit;">Sob o spoiler, ocultarei o comentário das fontes GO, ou você pode encontrar o montador para empilhar mais você mesmo.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">encontrado na fonte</font></font></b>
                        <div class="spoiler_text">Synchronous safe-points are implemented by overloading the stack bound check in function prologues. To preempt a goroutine at the next synchronous safe-point, the runtime poisons the goroutine's stack bound to a value that will cause the next stack bound check to fail and enter the stack growth implementation, which will detect that it was actually a preemption and redirect to preemption handling.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Obviamente, ao mudar para um conceito de exclusão, um sinal de exclusão pode capturar nossa gorutina em qualquer lugar. Mas os autores do GO decidiram não deixar pontos seguros, mas declarar pontos seguros em todos os lugares! Bem, é claro, há um problema, quase em toda parte de fato. Como mencionado acima, existem alguns pontos inseguros em que não forçaremos ninguém a sair. Vamos escrever um ponto inseguro simples.</font></font><br>
<br>
<pre><code class="go hljs"><font></font>
j := &amp;someStruct{}<font></font>
p := unsafe.Pointer(j)<font></font>
<span class="hljs-comment">// unsafe-point start</span>
u := <span class="hljs-keyword">uintptr</span>(p)
<span class="hljs-comment">//do some stuff here</span><font></font>
p = unsafe.Pointer(u)<font></font>
<span class="hljs-comment">// unsafe-point end</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para entender qual é o problema, vamos tentar a capa de um coletor de lixo. Cada vez que vamos trabalhar, precisamos descobrir os nós raiz (ponteiros na pilha e nos registros) com os quais começaremos a marcar. Como é impossível dizer em tempo de execução se 64 bytes de memória são um ponteiro ou apenas um número, recorremos à pilha e registramos cartões (alguns com cache de informações meta), gentilmente fornecidos pelo compilador GO. As informações nesses mapas nos permitem encontrar indicadores. Por isso, fomos acordados e enviados para o trabalho quando o GO executou a linha número 4. Chegando ao local e olhando para os cartões, descobrimos que ele estava vazio (e isso é verdade, porque o uintptr do ponto de vista do GC é um número e não um ponteiro). Bem, ontem ouvimos sobre a alocação de memória para j, já que agora não conseguimos acessar essa memória - precisamos limpá-la e, depois de remover a memória, vamos dormir.Qual é o próximo? Bem, as autoridades acordaram, à noite, gritando, bem, você mesmo entendeu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Isso é tudo com a teoria, proponho considerar na prática como todos esses sinais, pontos inseguros e cartões de registro e pilhas funcionam.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vamos seguir praticando</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Executei duas vezes (vá 1,14 e vá 1,13) um exemplo do início do artigo pelo perf profiler para ver quais chamadas do sistema estão acontecendo e compará-las. </font><font style="vertical-align: inherit;">O syscall necessário na versão 14 foi encontrado rapidamente:</font></font><br>
<br>
<pre><code class="plaintext hljs">15.652 ( 0.003 ms): main/29614 tgkill(tgid: 29613 (main), pid: 29613 (main), sig: URG                ) = 0</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bem, obviamente, o tempo de execução enviou o SIGURG para o segmento no qual a goroutine está girando. </font><font style="vertical-align: inherit;">Tomando esse conhecimento como ponto de partida, fui examinar os commits no GO para descobrir para onde e por que motivo esse sinal é enviado, bem como para encontrar o local onde o manipulador de sinais está instalado. </font><font style="vertical-align: inherit;">Vamos começar com o envio, encontraremos a função de envio de sinal em runtime / os_linux.go</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">signalM</span><span class="hljs-params">(mp *m, sig <span class="hljs-keyword">int</span>)</span></span> {<font></font>
	tgkill(getpid(), <span class="hljs-keyword">int</span>(mp.procid), sig)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora, encontramos lugares no código de tempo de execução, de onde enviamos o sinal:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">quando a goroutine for suspensa, se estiver em um estado de execução. </font><font style="vertical-align: inherit;">A solicitação de suspensão vem do coletor de lixo. </font><font style="vertical-align: inherit;">Aqui, talvez, não adicionarei código, mas ele pode ser encontrado no arquivo runtime / preempt.go (suspendG)</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> se o planejador decidir que a goroutine está funcionando por muito tempo, runtime / proc.go (retoke)</font></font><br>
<pre><code class="go hljs">
<span class="hljs-keyword">if</span> pd.schedwhen+forcePreemptNS &lt;= now {<font></font>
	signalM(_p_)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
forcePreemptNS - constante igual a 10ms, pd.schedwhen - horário em que o agendador do fluxo pd foi chamado pela última vez</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> além de todos os fluxos, esse sinal é enviado durante um pânico, StopTheWorld (GC) e mais alguns casos (que eu tenho que ignorar, porque o tamanho do artigo já vai além dos limites)</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nós descobrimos como e quando o tempo de execução envia um sinal para M. </font><font style="vertical-align: inherit;">Agora vamos encontrar o manipulador para esse sinal e ver o que o fluxo faz quando é recebido.</font></font><br>
<br>
<pre><code class="go hljs">
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSigPreempt</span><span class="hljs-params">(gp *g, ctxt *sigctxt)</span></span> {
	<span class="hljs-keyword">if</span> wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
		<span class="hljs-comment">// Inject a call to asyncPreempt.</span><font></font>
		ctxt.pushCall(funcPC(asyncPreempt))<font></font>
	}<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta função, fica claro que, para "travar", você precisa passar por 2 verificações:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> wantAsyncPreempt - verificamos se G quer ser forçado a sair, aqui, por exemplo, a validade do status atual da goroutina será verificada.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint - verifique se ele pode estar lotado no momento. </font><font style="vertical-align: inherit;">A verificação mais interessante aqui é se G está em um ponto seguro ou não. </font><font style="vertical-align: inherit;">Além disso, devemos ter certeza de que o encadeamento no qual G está executando também está pronto para antecipar G.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se as duas verificações forem aprovadas, as instruções serão chamadas a partir do código executável que salva o estado G e chama o agendador.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">E mais sobre inseguros</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Proponho analisar um novo exemplo, ele ilustrará outro caso com um ponto inseguro:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">outro programa sem fim</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
<span class="hljs-comment">//go:nosplit</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">infiniteLoop</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> u <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> {<font></font>
		u -= <span class="hljs-number">2</span>
		<span class="hljs-keyword">if</span> u == <span class="hljs-number">1</span> {
			<span class="hljs-keyword">break</span><font></font>
		}<font></font>
	}<font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {<font></font>
	runtime.GOMAXPROCS(<span class="hljs-number">1</span>)
	<span class="hljs-keyword">go</span> infiniteLoop()<font></font>
	&lt;-time.After(time.Millisecond * <span class="hljs-number">5</span>)<font></font>
<font></font>
	fmt.Println(<span class="hljs-string">"go 1.13 and 1.14 has never been here"</span>)<font></font>
}</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como você pode imaginar, a inscrição “vá 1.13 e 1.14 nunca esteve aqui” não veremos no GO 1.14. </font><font style="vertical-align: inherit;">Isso ocorre porque proibimos explicitamente interromper a função infiniteLoop (go: nosplit). </font><font style="vertical-align: inherit;">Essa proibição é implementada apenas usando o ponto inseguro, que é todo o corpo da função. </font><font style="vertical-align: inherit;">Vamos ver o que o compilador gerou para a função infiniteLoop.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cuidado Montador</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   TEXT    <span class="hljs-string">""</span>.infiniteLoop(SB), NOSPLIT|ABIInternal, $<span class="hljs-number">0</span><span class="hljs-number">-0</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-2</span>
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">0</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">1</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   FUNCDATA        $<span class="hljs-number">2</span>, gclocals·<span class="hljs-number">33</span>cdeccccebe80329f1fdbee7f5874cb(SB)
        <span class="hljs-number">0x0000</span> <span class="hljs-number">00000</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">10</span>)   XORL    AX, AX
        <span class="hljs-number">0x0002</span> <span class="hljs-number">00002</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">12</span>)   JMP     <span class="hljs-number">8</span>
        <span class="hljs-number">0x0004</span> <span class="hljs-number">00004</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">13</span>)   ADDQ    $<span class="hljs-number">-2</span>, AX
        <span class="hljs-number">0x0008</span> <span class="hljs-number">00008</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   CMPQ    AX, $<span class="hljs-number">3</span>
        <span class="hljs-number">0x000c</span> <span class="hljs-number">00012</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">14</span>)   JNE     <span class="hljs-number">4</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">0</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   PCDATA  $<span class="hljs-number">1</span>, $<span class="hljs-number">-1</span>
        <span class="hljs-number">0x000e</span> <span class="hljs-number">00014</span> (main.<span class="hljs-keyword">go</span>:<span class="hljs-number">15</span>)   RET
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No nosso caso, a instrução PCDATA é de interesse. </font><font style="vertical-align: inherit;">Quando o vinculador vê essa instrução, não a converte em um assembler "real". </font><font style="vertical-align: inherit;">Em vez disso, o valor do 2º argumento com a tecla igual ao contador do programa correspondente (o número que pode ser observado à esquerda do nome da função + linha) será colocado no mapa do registrador ou da pilha (determinado pelo 1º argumento). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como vemos nas linhas 10 e 15, colocamos os valores $ 2 e -1 no mapa $ 0 e $ 1, respectivamente. </font><font style="vertical-align: inherit;">Vamos lembrar desse momento e dar uma olhada na função isAsyncSafePoint, para a qual eu já chamei sua atenção. </font><font style="vertical-align: inherit;">Lá veremos as seguintes linhas:</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">isAsyncSafePoint</font></font></b>
                        <div class="spoiler_text"><pre><code class="go hljs">
	smi := pcdatavalue(f, _PCDATA_RegMapIndex, pc, <span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> smi == <span class="hljs-number">-2</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
	}<font></font>
</code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
É neste local que verificamos se a goroutina está atualmente no ponto seguro. </font><font style="vertical-align: inherit;">Passamos para o mapa de registradores (_PCDATA_RegMapIndex = 0) e, passando o pc atual, verificamos o valor, se -2, então G não está no ponto seguro, o que significa que não pode ser eliminado.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusão</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parei minha "pesquisa" sobre isso, espero que o artigo tenha sido útil para você também. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Publico os links prometidos, mas tenha cuidado, pois algumas das informações desses artigos podem estar desatualizadas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agendador GO - </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uma</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">duas vezes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Assembler GO.</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt502494/index.html">7 erros de uma sexta-feira negra e como funciona o Magento Cloud - vídeo</a></li>
<li><a href="../pt502496/index.html">Fácil acesso da Web a aplicativos PHP do LabVIEW VI via servidor ActiveX</a></li>
<li><a href="../pt502498/index.html">Práticas recomendadas para melhorar o desempenho em C #</a></li>
<li><a href="../pt502500/index.html">A evolução de um scanner de passaporte: do artesanato em compensado aos negócios reais</a></li>
<li><a href="../pt502504/index.html">Coloque o dígito do usuário</a></li>
<li><a href="../pt502508/index.html">Robô de carrinho 2.0. Parte 2. Gerenciamento em rviz e sem elementos de beleza em rviz</a></li>
<li><a href="../pt502510/index.html">O que salvar na nuvem</a></li>
<li><a href="../pt502512/index.html">Resultados do concurso de especialistas em sofás: as regras da cutucada científica</a></li>
<li><a href="../pt502518/index.html">Como escalar uma árvore</a></li>
<li><a href="../pt502520/index.html">Relatórios em vídeo de relatórios mitap sobre análise de produtos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>