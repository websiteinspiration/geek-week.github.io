<!doctype html>
<html class="no-js" lang="de">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üé∞ üßê ü§õ GPU-Programmierung in Java üßï üë¥ üöß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Zugriff auf die GPU √ºber Java zeigt eine enorme Leistung. Es beschreibt, wie die GPU funktioniert und wie von Java aus zugegriffen wird. 
 
 Die G...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>GPU-Programmierung in Java</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/500106/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Zugriff auf die GPU √ºber Java zeigt eine enorme Leistung. </font><font style="vertical-align: inherit;">Es beschreibt, wie die GPU funktioniert und wie von Java aus zugegriffen wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die GPU-Programmierung ist f√ºr Java-Programmierer eine himmelhohe Welt. </font><font style="vertical-align: inherit;">Dies ist verst√§ndlich, da normale Java-Tasks nicht f√ºr die GPU geeignet sind. </font><font style="vertical-align: inherit;">GPUs weisen jedoch Teraflops der Leistung auf. Lassen Sie uns daher ihre Funktionen untersuchen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um das Thema zug√§nglich zu machen, werde ich einige Zeit damit verbringen, die Architektur der GPU zusammen mit einer kleinen Geschichte zu erkl√§ren, die ein Eintauchen in die Eisenprogrammierung erleichtert.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem mir die Unterschiede zwischen der GPU und dem CPU-Computing gezeigt wurden, werde ich zeigen, wie die GPU in der Java-Welt verwendet wird. </font><font style="vertical-align: inherit;">Abschlie√üend werde ich die wichtigsten Frameworks und Bibliotheken beschreiben, die zum Schreiben und Ausf√ºhren von Java-Code auf der GPU verf√ºgbar sind, und einige Codebeispiele geben.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ein bisschen Hintergrund</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die GPU wurde erstmals 1999 von NVIDIA popul√§r gemacht. Es handelt sich um einen speziellen Prozessor, der Grafikdaten verarbeitet, bevor sie auf das Display √ºbertragen werden. </font><font style="vertical-align: inherit;">In vielen F√§llen erm√∂glicht dies einige Berechnungen, die CPU zu entladen, wodurch CPU-Ressourcen freigesetzt werden, die diese entladenen Berechnungen beschleunigen. </font><font style="vertical-align: inherit;">Das Ergebnis ist, dass gro√üe Eingaben mit einer h√∂heren Ausgabeaufl√∂sung verarbeitet und dargestellt werden k√∂nnen, wodurch die visuelle Darstellung attraktiver und die Bildrate fl√ºssiger wird. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Essenz der 2D / 3D-Verarbeitung liegt haupts√§chlich in der Manipulation von Matrizen, dies kann unter Verwendung eines verteilten Ansatzes gesteuert werden. </font><font style="vertical-align: inherit;">Was wird ein effektiver Ansatz f√ºr die Bildverarbeitung sein? </font><font style="vertical-align: inherit;">Um dies zu beantworten, vergleichen wir die Standard-CPU-Architektur (siehe Abbildung 1) und die GPU.</font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d6c/58e/c4c/d6c58ec4ccbec78f237d58a822f9ab92.jpg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feige. 1. CPU-Architekturbl√∂cke</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
In der CPU sind die eigentlichen Verarbeitungselemente - Register, arithmetische Logikeinheit (ALU) und Ausf√ºhrungskontexte - nur kleine Teile des gesamten Systems. Um unregelm√§√üige Zahlungen in unvorhersehbarer Reihenfolge zu beschleunigen, gibt es einen gro√üen, schnellen und teuren Cache. verschiedene Arten von Sammlern; und Zweigpr√§diktoren. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sie ben√∂tigen dies alles nicht auf der GPU, da die Daten auf vorhersehbare Weise empfangen werden und die GPU nur sehr wenige Operationen mit den Daten ausf√ºhrt. Somit ist es m√∂glich, sie sehr klein zu machen, und ein kosteng√ºnstiger Prozessor mit einer Blockarchitektur √§hnlich dieser ist in Fig. 1 gezeigt. 2. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/365/425/84c/36542584c2d34d817c48ca2cd0e8d433.jpg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 2. Blockarchitektur f√ºr einen einfachen GPU-Kern</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Da solche Prozessoren billiger sind und die darin verarbeiteten Daten in parallelen Bl√∂cken verarbeitet werden, ist es einfach, viele von ihnen parallel arbeiten zu lassen. Es wurde unter Bezugnahme auf mehrere Anweisungen, mehrere Daten oder MIMD (ausgesprochen "mim-dee") entwickelt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der zweite Ansatz basiert auf der Tatsache, dass h√§ufig eine einzelne Anweisung auf mehrere Daten angewendet wird. Dies ist als einzelne Anweisung, mehrere Daten oder SIMD (ausgesprochen ‚Äûsim-dee‚Äú) bekannt. In diesem Entwurf enth√§lt eine einzelne GPU mehrere ALUs und Ausf√ºhrungskontexte, kleine Bereiche, die in gemeinsam genutzte Kontextdaten √ºbertragen werden (siehe Abbildung) 3. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/453/4cb/013/4534cb0135c6c5c3075594787c3266c6.jpg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 3. Vergleich der MIMD-Architektur der GPU-Bl√∂cke (von links) mit dem SIMD-Design (von rechts)</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Mischen von SIMD- und MIMD-Verarbeitung bietet die maximale Bandbreite, die ich umgehen werde. </font><font style="vertical-align: inherit;">In diesem Design laufen mehrere SIMD-Prozessoren parallel (siehe Abbildung) </font><font style="vertical-align: inherit;">4. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/d81/fc5/f10/d81fc5f10ab5cf27584669ab846b9836.jpg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. </font><font style="vertical-align: inherit;">4. Mehrere SIMD-Prozessoren gleichzeitig arbeiten; </font><font style="vertical-align: inherit;">Es gibt 16 Kerne mit 128 ALUs.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Da Sie eine Reihe kleiner, einfacher Prozessoren haben, k√∂nnen Sie diese so programmieren, dass sie einen besonderen Effekt in der Ausgabe erzielen.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ausf√ºhren von Programmen auf der GPU</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die meisten fr√ºhen Grafikeffekte in Spielen waren wirklich hartcodierte kleine Programme, die auf der GPU ausgef√ºhrt und auf Datenstr√∂me von der CPU angewendet wurden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies war offensichtlich, selbst wenn hartcodierte Algorithmen unzureichend waren, insbesondere im Spieldesign, wo visuelle Effekte eine der wichtigsten magischen Richtungen sind. Als Reaktion darauf er√∂ffneten gro√üe Verk√§ufer den Zugriff auf die GPU, und dann konnten Entwickler von Drittanbietern sie programmieren.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ein typischer Ansatz bestand darin, ein kleines Programm namens Shader in einer speziellen Sprache (normalerweise eine Unterart von C) zu schreiben und diese mit speziellen Compilern f√ºr die gew√ºnschte Architektur zu kompilieren. </font><font style="vertical-align: inherit;">Der Begriff Shader wurde gew√§hlt, weil Shader h√§ufig zur Steuerung von Licht- und Schatteneffekten verwendet werden. Dies bedeutet jedoch nicht, dass sie andere Spezialeffekte steuern k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jeder GPU-Anbieter verf√ºgte √ºber eine eigene Programmiersprache und Infrastruktur, um Shader f√ºr seine Architektur zu erstellen. </font><font style="vertical-align: inherit;">Auf diesem Ansatz wurden viele Plattformen erstellt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die wichtigsten sind:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DirectCompute: Die private Shader-Sprache / API von Microsoft, die Teil von Direct3D ist, beginnend mit DirectX 10.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AMD FireStream: Private ATI / Radeon-Technologien, die von AMD veraltet sind.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenACC: Multi-Vendor Consortium, Parallel Computing-L√∂sung</font></font></li>
<li>++ AMP:   Microsoft     C++</li>
<li>CUDA:   Nvidia,     </li>
<li>OpenL:  ,   Apple,      Khronos Group</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die Arbeit mit der GPU ist meistens eine einfache Programmierung. </font><font style="vertical-align: inherit;">Um dies f√ºr Entwickler ein wenig verst√§ndlicher zu machen, wurden f√ºr die Codierung mehrere Abstraktionen bereitgestellt. </font><font style="vertical-align: inherit;">Am bekanntesten ist DirectX von Microsoft und OpenGL von der Khronos Group. </font><font style="vertical-align: inherit;">Dies sind APIs zum Schreiben von Code auf hoher Ebene, die dann f√ºr die GPU semantischer f√ºr den Programmierer vereinfacht werden k√∂nnen. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Soweit ich wei√ü, gibt es keine Java-Infrastruktur f√ºr DirectX, aber es gibt eine gute L√∂sung f√ºr OpenGL. </font><font style="vertical-align: inherit;">JSR 231 wurde 2002 gestartet und richtet sich an GPU-Programmierer. Es wurde jedoch 2008 aufgegeben und unterst√ºtzt nur OpenGL 2.0.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Die OpenGL-Unterst√ºtzung wird im unabh√§ngigen JOCL-Projekt (das auch OpenCL unterst√ºtzt) fortgesetzt und steht dem Publikum zur Verf√ºgung. </font><font style="vertical-align: inherit;">So wurde das ber√ºhmte Minecraft-Spiel mit JOCL geschrieben.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">GPGPU kommt</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bisher hatten Java und die GPU keine Gemeinsamkeiten, obwohl dies der Fall sein sollte. </font><font style="vertical-align: inherit;">Java wird h√§ufig in Unternehmen, in der Datenwissenschaft und im Finanzsektor verwendet, wo viel Computer vorhanden ist und viel Rechenleistung ben√∂tigt wird. </font><font style="vertical-align: inherit;">So ist die Idee der Allzweck-GPU (GPGPU). </font><font style="vertical-align: inherit;">Die Idee, die GPU auf diesem Weg zu verwenden, begann, als die Hersteller von Videoadaptern Zugriff auf den Programmrahmenpuffer gew√§hrten, sodass Entwickler den Inhalt lesen konnten. </font><font style="vertical-align: inherit;">Einige Hacker haben festgestellt, dass sie die volle Leistung der GPU f√ºr Universal Computing nutzen k√∂nnen. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Das Rezept war wie folgt:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Codieren Sie Daten als Rasterarray.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Schreiben Sie Shader, um damit umzugehen.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Senden Sie beide an die Grafikkarte.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnis aus Bildpuffer abrufen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dekodieren Sie Daten aus einem Rasterarray.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies ist eine sehr einfache Erkl√§rung. Ich bin nicht sicher, ob dies in der Produktion funktionieren wird, aber es funktioniert wirklich. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dann begannen zahlreiche Studien des Stanford Institute, die Verwendung von GPUs zu vereinfachen. 2005 haben sie BrookGPU entwickelt, ein kleines √ñkosystem, das eine Programmiersprache, einen Compiler und eine Laufzeit enth√§lt. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
BrookGPU kompilierte Programme, die in der Programmiersprache Brook-Thread geschrieben wurden, die eine ANSI C-Variante war. Sie kann OpenGL v1.3 +, DirectX v9 + oder AMD Close to Metal f√ºr den Server-Computing-Teil verwenden und l√§uft unter Microsoft Windows und Linux. Zum Debuggen kann BrookGPU auch eine virtuelle Grafikkarte auf der CPU simulieren.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dies nahm jedoch aufgrund der zu diesem Zeitpunkt verf√ºgbaren Ausr√ºstung nicht zu. In der GPGPU-Welt m√ºssen Sie Daten auf das Ger√§t kopieren (in diesem Zusammenhang bezieht sich das Ger√§t auf die GPU und das Ger√§t, auf dem es sich befindet), warten, bis die GPU die Daten berechnet hat, und dann die Daten zur√ºck in das Steuerprogramm kopieren. Dies f√ºhrt zu vielen Verz√∂gerungen. Mitte der 2000er Jahre, als sich das Projekt in der aktiven Entwicklung befand, schlossen diese Verz√∂gerungen auch die intensive Nutzung der GPU f√ºr das Basic Computing aus. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Viele Unternehmen haben jedoch die Zukunft in dieser Technologie gesehen. Mehrere Entwickler von Videoadaptern begannen, GPGPUs mit ihren propriet√§ren Technologien auszustatten, und andere gebildete Allianzen lieferten weniger grundlegende, vielseitige Programmiermodelle, die auf einer gro√üen Menge an Hardware arbeiteten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem ich Ihnen alles erz√§hlt habe, schauen wir uns die beiden erfolgreichsten GPU-Computertechnologien an - OpenCL und CUDA - und sehen Sie auch, wie Java mit ihnen funktioniert. </font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OpenCL und Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wie andere Infrastrukturpakete bietet OpenCL eine grundlegende Implementierung in C. Diese ist technisch √ºber das Java Native Interface (JNI) oder Java Native Access (JNA) verf√ºgbar, aber dieser Ansatz wird f√ºr die meisten Entwickler zu schwierig sein. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Gl√ºcklicherweise wurde diese Arbeit bereits von mehreren Bibliotheken durchgef√ºhrt: JOCL, JogAmp und JavaCL. Leider ist JavaCL ein totes Projekt geworden. Aber das JOCL-Projekt ist lebendig und sehr angepasst. Ich werde es f√ºr die folgenden Beispiele verwenden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aber zuerst muss ich erkl√§ren, was OpenCL ist. Ich habe bereits erw√§hnt, dass OpenCL ein sehr einfaches Modell bietet, mit dem alle Arten von Ger√§ten programmiert werden k√∂nnen - nicht nur GPUs und CPUs, sondern auch DSP-Prozessoren und FPGAs.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Schauen wir uns das einfachste Beispiel an: Faltvektoren sind wahrscheinlich das hellste und einfachste Beispiel. Sie haben zwei Zahlenfelder zum Hinzuf√ºgen und eines f√ºr das Ergebnis. Sie nehmen ein Element aus dem ersten Array und ein Element aus dem zweiten Array und f√ºgen dann die Summe in das Ergebnisarray ein, wie in Abb. 5. </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/fff/896/f1f/fff896f1feb607506f35dc8dcdce973b.jpg" alt="Bild"><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Abb. 5. Hinzuf√ºgen der Elemente von zwei Arrays und Speichern der Summe im resultierenden Array</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Wie Sie sehen k√∂nnen, ist die Operation sehr konsistent und dennoch verteilt. Sie k√∂nnen jede Additionsoperation in verschiedene Kern-GPUs verschieben. Dies bedeutet, dass Sie bei 2048 Kernen wie beim Nvidia 1080 gleichzeitig 2048 Additionsvorg√§nge ausf√ºhren k√∂nnen. Dies bedeutet, dass hier die potenziellen Teraflops der Computerleistung auf Sie warten. Dieser Code f√ºr ein Array von 10 Millionen Nummern stammt von der JOCL-Website:</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayGPU</span> </span>{
    <span class="hljs-comment">/**
     * The source code of the OpenCL program 
     */</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String programSource =
        <span class="hljs-string">"__kernel void "</span>+
        <span class="hljs-string">"sampleKernel(__global const float *a,"</span>+
        <span class="hljs-string">"             __global const float *b,"</span>+
        <span class="hljs-string">"             __global float *c)"</span>+
        <span class="hljs-string">"{"</span>+
        <span class="hljs-string">"    int gid = get_global_id(0);"</span>+
        <span class="hljs-string">"    c[gid] = a[gid] + b[gid];"</span>+
        <span class="hljs-string">"}"</span>;<font></font>
    <font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span>
    </span>{
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">10_000_000</span>;
        <span class="hljs-keyword">float</span> srcArrayA[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> srcArrayB[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">float</span> dstArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)<font></font>
        {<font></font>
            srcArrayA[i] = i;<font></font>
            srcArrayB[i] = i;<font></font>
        }<font></font>
        Pointer srcA = Pointer.to(srcArrayA);<font></font>
        Pointer srcB = Pointer.to(srcArrayB);<font></font>
        Pointer dst = Pointer.to(dstArray);<font></font>
<font></font>
<font></font>
        <span class="hljs-comment">// The platform, device type and device number</span>
        <span class="hljs-comment">// that will be used</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> platformIndex = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> deviceType = CL.CL_DEVICE_TYPE_ALL;
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> deviceIndex = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-comment">// Enable exceptions and subsequently omit error checks in this sample</span>
        CL.setExceptionsEnabled(<span class="hljs-keyword">true</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Obtain the number of platforms</span>
        <span class="hljs-keyword">int</span> numPlatformsArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetPlatformIDs(<span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numPlatformsArray);
        <span class="hljs-keyword">int</span> numPlatforms = numPlatformsArray[<span class="hljs-number">0</span>];<font></font>
<font></font>
        <span class="hljs-comment">// Obtain a platform ID</span>
        cl_platform_id platforms[] = <span class="hljs-keyword">new</span> cl_platform_id[numPlatforms];<font></font>
        CL.clGetPlatformIDs(platforms.length, platforms, <span class="hljs-keyword">null</span>);<font></font>
        cl_platform_id platform = platforms[platformIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Initialize the context properties</span>
        cl_context_properties contextProperties = <span class="hljs-keyword">new</span> cl_context_properties();<font></font>
        contextProperties.addProperty(CL.CL_CONTEXT_PLATFORM, platform);<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain the number of devices for the platform</span>
        <span class="hljs-keyword">int</span> numDevicesArray[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, numDevicesArray);
        <span class="hljs-keyword">int</span> numDevices = numDevicesArray[<span class="hljs-number">0</span>];<font></font>
        <font></font>
        <span class="hljs-comment">// Obtain a device ID </span>
        cl_device_id devices[] = <span class="hljs-keyword">new</span> cl_device_id[numDevices];<font></font>
        CL.clGetDeviceIDs(platform, deviceType, numDevices, devices, <span class="hljs-keyword">null</span>);<font></font>
        cl_device_id device = devices[deviceIndex];<font></font>
<font></font>
        <span class="hljs-comment">// Create a context for the selected device</span><font></font>
        cl_context context = CL.clCreateContext(<font></font>
            contextProperties, <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> cl_device_id[]{device}, 
            <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create a command-queue for the selected device</span><font></font>
        cl_command_queue commandQueue = <font></font>
            CL.clCreateCommandQueue(context, device, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Allocate the memory objects for the input and output data</span>
        cl_mem memObjects[] = <span class="hljs-keyword">new</span> cl_mem[<span class="hljs-number">3</span>];<font></font>
        memObjects[<span class="hljs-number">0</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcA, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">1</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_ONLY | CL.CL_MEM_COPY_HOST_PTR,<font></font>
            Sizeof.cl_float * n, srcB, <span class="hljs-keyword">null</span>);<font></font>
        memObjects[<span class="hljs-number">2</span>] = CL.clCreateBuffer(context,<font></font>
            CL.CL_MEM_READ_WRITE,<font></font>
            Sizeof.cl_float * n, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the program from the source code</span><font></font>
        cl_program program = CL.clCreateProgramWithSource(context,<font></font>
            <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> String[]{ programSource }, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Build the program</span>
        CL.clBuildProgram(program, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Create the kernel</span>
        cl_kernel kernel = CL.clCreateKernel(program, <span class="hljs-string">"sampleKernel"</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Set the arguments for the kernel</span>
        CL.clSetKernelArg(kernel, <span class="hljs-number">0</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">0</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">1</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">1</span>]));<font></font>
        CL.clSetKernelArg(kernel, <span class="hljs-number">2</span>,<font></font>
            Sizeof.cl_mem, Pointer.to(memObjects[<span class="hljs-number">2</span>]));<font></font>
        <font></font>
        <span class="hljs-comment">// Set the work-item dimensions</span>
        <span class="hljs-keyword">long</span> global_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{n};
        <span class="hljs-keyword">long</span> local_work_size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[]{<span class="hljs-number">1</span>};<font></font>
        <font></font>
        <span class="hljs-comment">// Execute the kernel</span>
        CL.clEnqueueNDRangeKernel(commandQueue, kernel, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>,<font></font>
            global_work_size, local_work_size, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Read the output data</span>
        CL.clEnqueueReadBuffer(commandQueue, memObjects[<span class="hljs-number">2</span>], CL.CL_TRUE, <span class="hljs-number">0</span>,<font></font>
            n * Sizeof.cl_float, dst, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<font></font>
        <font></font>
        <span class="hljs-comment">// Release kernel, program, and memory objects</span>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">0</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">1</span>]);<font></font>
        CL.clReleaseMemObject(memObjects[<span class="hljs-number">2</span>]);<font></font>
        CL.clReleaseKernel(kernel);<font></font>
        CL.clReleaseProgram(program);<font></font>
        CL.clReleaseCommandQueue(commandQueue);<font></font>
        CL.clReleaseContext(context);<font></font>
<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getString</span><span class="hljs-params">(cl_device_id device, <span class="hljs-keyword">int</span> paramName)</span> </span>{
        <span class="hljs-comment">// Obtain the length of the string that will be queried</span>
        <span class="hljs-keyword">long</span> size[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">long</span>[<span class="hljs-number">1</span>];<font></font>
        CL.clGetDeviceInfo(device, paramName, <span class="hljs-number">0</span>, <span class="hljs-keyword">null</span>, size);<font></font>
<font></font>
        <span class="hljs-comment">// Create a buffer of the appropriate size and fill it with the info</span>
        <span class="hljs-keyword">byte</span> buffer[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[(<span class="hljs-keyword">int</span>)size[<span class="hljs-number">0</span>]];<font></font>
        CL.clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), <span class="hljs-keyword">null</span>);<font></font>
<font></font>
        <span class="hljs-comment">// Create a string from the buffer (excluding the trailing \0 byte)</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(buffer, <span class="hljs-number">0</span>, buffer.length-<span class="hljs-number">1</span>);<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dieser Code ist nicht wie Java-Code, aber er ist es. Ich werde den Code weiter erkl√§ren; Verbringen Sie jetzt nicht viel Zeit damit, da ich kurz auf komplexe L√∂sungen eingehen werde. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der Code wird dokumentiert, aber lassen Sie uns einen kleinen Durchgang machen. Wie Sie sehen k√∂nnen, ist der Code dem Code in C sehr √§hnlich. Dies ist normal, da JOCL nur OpenCL ist. Am Anfang steht hier ein Code in der Zeile, und dieser Code ist der wichtigste Teil: Er wird mit OpenCL kompiliert und dann an die Grafikkarte gesendet, wo er ausgef√ºhrt wird. Dieser Code hei√üt Kernel. Verwechseln Sie diesen Begriff nicht mit OC Kernel. Dies ist der Ger√§tecode. Dieser Code wird in eine Teilmenge von C geschrieben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nachdem der Kernel Java-Code zum Installieren und Konfigurieren des Ger√§ts enth√§lt, teilen Sie die Daten auf und erstellen Sie die entsprechenden Speicherpuffer f√ºr die resultierenden Daten.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Zusammenfassend: Hier ist der ‚ÄûHost-Code‚Äú, bei dem es sich normalerweise um eine Sprachbindung handelt (in unserem Fall in Java), und der ‚ÄûGer√§tecode‚Äú. Sie markieren immer, was auf dem Host funktioniert und was auf dem Ger√§t funktionieren soll, da der Host das Ger√§t steuert. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Der vorhergehende Code sollte die GPU anzeigen, die "Hello World!" Wie Sie sehen k√∂nnen, ist das meiste davon riesig. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vergessen wir nicht die SIMD-Funktionen. Wenn Ihr Ger√§t die SIMD-Erweiterung unterst√ºtzt, k√∂nnen Sie arithmetischen Code schneller erstellen. Schauen wir uns als Beispiel den Kernel-Matrix-Multiplikationscode an. Dieser Code befindet sich in einer einfachen Java-Zeile in der Anwendung.</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dim,
                  __global <span class="hljs-keyword">float</span> *A,
                  __global <span class="hljs-keyword">float</span> *B,
                  __global <span class="hljs-keyword">float</span> *C)</span></span>{<font></font>
<font></font>
    <span class="hljs-keyword">int</span> iCol = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">int</span> iRow = get_global_id(<span class="hljs-number">1</span>);
    <span class="hljs-keyword">float</span> result = <span class="hljs-number">0.0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt; dim; ++i)<font></font>
    {<font></font>
          result +=<font></font>
          A[iRow*dim + i]*B[i*dim + iCol];<font></font>
    }<font></font>
    C[iRow*dim + iCol] = result;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Technisch gesehen funktioniert dieser Code mit Daten, die vom OpenCL-Framework f√ºr Sie installiert wurden, mit den Anweisungen, die Sie im vorbereitenden Teil aufgerufen haben. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Ihre Grafikkarte SIMD-Anweisungen unterst√ºtzt und einen Vektor mit vier Gleitkommazahlen verarbeiten kann, k√∂nnen kleine Optimierungen den vorherigen Code wie folgt umwandeln:</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VECTOR_SIZE 4    </span>
<span class="hljs-function">__kernel <span class="hljs-keyword">void</span> <span class="hljs-title">MatrixMul_kernel_basic_vector4</span><span class="hljs-params">(
    <span class="hljs-keyword">size_t</span> dim, <span class="hljs-comment">// dimension is in single floats</span>
    <span class="hljs-keyword">const</span> float4 *A,
    <span class="hljs-keyword">const</span> float4 *B,
    float4 *C)</span>
</span>{
    <span class="hljs-keyword">size_t</span> globalIdx = get_global_id(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">size_t</span> globalIdy = get_global_id(<span class="hljs-number">1</span>);<font></font>
    float4 resultVec = (float4){ <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> };
    <span class="hljs-keyword">size_t</span> dimVec = dim / <span class="hljs-number">4</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; dimVec; ++i) {<font></font>
        float4 Avector = A[dimVec * globalIdy + i];<font></font>
        float4 Bvector[<span class="hljs-number">4</span>];<font></font>
        Bvector[<span class="hljs-number">0</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">0</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">1</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">2</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">2</span>) + globalIdx];<font></font>
        Bvector[<span class="hljs-number">3</span>] = B[dimVec * (i * <span class="hljs-number">4</span> + <span class="hljs-number">3</span>) + globalIdx];<font></font>
        resultVec += Avector[<span class="hljs-number">0</span>] * Bvector[<span class="hljs-number">0</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">1</span>] * Bvector[<span class="hljs-number">1</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">2</span>] * Bvector[<span class="hljs-number">2</span>];<font></font>
        resultVec += Avector[<span class="hljs-number">3</span>] * Bvector[<span class="hljs-number">3</span>];<font></font>
    }<font></font>
<font></font>
    C[dimVec * globalIdy + globalIdx] = resultVec;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mit diesem Code k√∂nnen Sie die Leistung verdoppeln. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cool. </font><font style="vertical-align: inherit;">Sie haben gerade die GPU f√ºr die Java-Welt ge√∂ffnet! </font><font style="vertical-align: inherit;">Aber m√∂chten Sie als Java-Entwickler wirklich all diese Drecksarbeit mit C-Code machen und mit so einfachen Details arbeiten? </font><font style="vertical-align: inherit;">Ich will nicht. </font><font style="vertical-align: inherit;">Nachdem Sie nun einige Kenntnisse √ºber die Verwendung der GPU haben, schauen wir uns eine andere L√∂sung an, die sich von dem gerade vorgestellten JOCL-Code unterscheidet.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CUDA und Java</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
CUDA ist Nvidias L√∂sung f√ºr dieses Programmierproblem. </font><font style="vertical-align: inherit;">CUDA bietet viel mehr gebrauchsfertige Bibliotheken f√ºr Standard-GPU-Operationen wie Matrizen, Histogramme und sogar tiefe neuronale Netze. </font><font style="vertical-align: inherit;">Eine Liste von Bibliotheken mit einer Reihe vorgefertigter L√∂sungen ist bereits erschienen. </font><font style="vertical-align: inherit;">Dies ist alles aus dem JCuda-Projekt:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCublas: alles f√ºr Matrizen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCufft: Schnelle Fourier-Transformation </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCurand: Alles f√ºr Zufallszahlen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusparse: seltene Matrizen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCusolver: Faktorisierung von Zahlen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNvgraph: alles f√ºr Grafiken </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudpp: CUDA-Bibliothek mit primitiven parallelen Daten und einigen Sortieralgorithmen</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JNpp: GPU-Bildverarbeitung</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JCudnn: tiefe neuronale Netzwerkbibliothek</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ich denke dar√ºber nach, JCurand zu verwenden, das Zufallszahlen generiert. </font><font style="vertical-align: inherit;">Sie k√∂nnen dies aus Java-Code ohne eine andere spezielle Kernel-Sprache verwenden. </font><font style="vertical-align: inherit;">Beispielsweise:</font></font><br>
<br>
<pre><code class="java hljs">...
<span class="hljs-keyword">int</span> n = <span class="hljs-number">100</span>;<font></font>
curandGenerator generator = <span class="hljs-keyword">new</span> curandGenerator();
<span class="hljs-keyword">float</span> hostData[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[n];<font></font>
Pointer deviceData = <span class="hljs-keyword">new</span> Pointer();<font></font>
cudaMalloc(deviceData, n * Sizeof.FLOAT);<font></font>
curandCreateGenerator(generator, CURAND_RNG_PSEUDO_DEFAULT); <font></font>
curandSetPseudoRandomGeneratorSeed(generator, <span class="hljs-number">1234</span>);<font></font>
curandGenerateUniform(generator, deviceData, n);<font></font>
cudaMemcpy(Pointer.to(hostData), deviceData, <font></font>
        n * Sizeof.FLOAT, cudaMemcpyDeviceToHost);<font></font>
System.out.println(Arrays.toString(hostData));<font></font>
curandDestroyGenerator(generator);<font></font>
cudaFree(deviceData);<font></font>
...<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es verwendet eine GPU, um eine gro√üe Anzahl von Zufallszahlen von sehr hoher Qualit√§t zu erstellen, basierend auf sehr starker Mathematik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In JCuda k√∂nnen Sie auch generischen CUDA-Code schreiben und von Java aus aufrufen, indem Sie eine JAR-Datei in Ihrem Klassenpfad aufrufen. </font><font style="vertical-align: inherit;">In der JCuda-Dokumentation finden Sie gute Beispiele.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bleiben Sie √ºber dem Low-Level-Code</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es sieht alles gut aus, aber es gibt zu viel Code, zu viel Installation, zu viele verschiedene Sprachen, um alles auszuf√ºhren. Gibt es eine M√∂glichkeit, die GPU zumindest teilweise zu nutzen? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Was ist, wenn Sie nicht √ºber all diese OpenCL, CUDA und andere unn√∂tige Dinge nachdenken m√∂chten? Was ist, wenn Sie nur in Java programmieren und nicht an alles denken m√∂chten, was nicht offensichtlich ist? Aparapi-Projekt kann helfen. Aparapi basiert auf einer "parallelen API". Ich betrachte es als Teil von Hibernate f√ºr die GPU-Programmierung, die OpenCL unter der Haube verwendet. Schauen wir uns ein Beispiel f√ºr die Vektoraddition an.</font></font><br>
<br>
<pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] _args)</span> </span>{
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">512</span>;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    <span class="hljs-comment">/* fill the arrays with random values */</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++){<font></font>
        a[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
        b[i] = (<span class="hljs-keyword">float</span>) (Math.random() * <span class="hljs-number">100</span>);<font></font>
    }<font></font>
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span>[] sum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">float</span>[size];<font></font>
<font></font>
    Kernel kernel = <span class="hljs-keyword">new</span> Kernel(){
        <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{<font></font>
I           <span class="hljs-keyword">int</span> gid = getGlobalId();<font></font>
            sum[gid] = a[gid] + b[gid];<font></font>
        }<font></font>
    };<font></font>
<font></font>
    kernel.execute(Range.create(size));<font></font>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
        System.out.printf(<span class="hljs-string">"%6.2f + %6.2f = %8.2f\n"</span>, a[i], b[i], sum[i])<font></font>
    }<font></font>
    kernel.dispose();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hier ist reiner Java-Code (aus der Aparapi-Dokumentation entnommen), auch hier und da sehen Sie einen bestimmten Begriff Kernel und getGlobalId. </font><font style="vertical-align: inherit;">Sie m√ºssen noch verstehen, wie die GPU programmiert wird, aber Sie k√∂nnen den GPGPU-Ansatz auf eine Java-√§hnliche Weise verwenden. </font><font style="vertical-align: inherit;">Dar√ºber hinaus bietet Aparapi eine einfache M√∂glichkeit, den OpenGL-Kontext f√ºr die OpenCL-Schicht zu verwenden, sodass die Daten vollst√§ndig auf der Grafikkarte verbleiben, und Probleme mit der Speicherlatenz zu vermeiden. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Wenn Sie viele unabh√§ngige Berechnungen durchf√ºhren m√ºssen, schauen Sie sich Aparapi an. </font><font style="vertical-align: inherit;">Es gibt viele Beispiele f√ºr die Verwendung von Parallel Computing. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dar√ºber hinaus gibt es ein Projekt namens TornadoVM, das die entsprechenden Berechnungen automatisch von der CPU auf die GPU √ºbertr√§gt und so eine sofortige Massenoptimierung erm√∂glicht.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ergebnisse</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es gibt viele Anwendungen, bei denen GPUs einige Vorteile bringen k√∂nnen, aber man k√∂nnte sagen, dass es immer noch einige Hindernisse gibt. </font><font style="vertical-align: inherit;">Java und die GPU k√∂nnen jedoch gemeinsam gro√üartige Dinge tun. </font><font style="vertical-align: inherit;">In diesem Artikel habe ich nur dieses umfangreiche Thema angesprochen. </font><font style="vertical-align: inherit;">Ich wollte verschiedene High- und Low-Level-Optionen f√ºr den Zugriff auf die GPU von Java aus zeigen. </font><font style="vertical-align: inherit;">Die Erkundung dieses Bereichs bietet enorme Leistungsvorteile, insbesondere bei komplexen Aufgaben, f√ºr die mehrere Berechnungen erforderlich sind, die parallel ausgef√ºhrt werden k√∂nnen. </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quelllink</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de500086/index.html">Schreiben eines Javascript-Rechners</a></li>
<li><a href="../de500098/index.html">JavaScript Nehronical</a></li>
<li><a href="../de500100/index.html">TV zuerst, reaktionsschnelle Typografie oder wie man nicht alle Gr√∂√üen von Ger√§ten vergisst</a></li>
<li><a href="../de500102/index.html">Roslyn & EF Core: Erstellen eines DbContext zur Laufzeit</a></li>
<li><a href="../de500104/index.html">Gesch√§ftsprozessmodellierung, automatische Diagramm-Text-√úbersetzung und CH-1-Notation</a></li>
<li><a href="../de500108/index.html">(Fr√ºhlings-) Zustand in der (Fr√ºhlings-) Schale: keine einzelne Produktion</a></li>
<li><a href="../de500110/index.html">Ein Wort zur Lieferung von Waren</a></li>
<li><a href="../de500114/index.html">Jobsuche in Deutschland als Produktmanager und mehr. Teil 2/5. Die Struktur des Arbeitsmarktes. ATS. Job B√∂rsen</a></li>
<li><a href="../de500116/index.html">Die Arbeit eines verteilten Teams unter Bedingungen der Selbstisolation: Da wir den Unterschied fast nicht bemerkt haben</a></li>
<li><a href="../de500118/index.html">F√ºnf Schritte, um das Unvermeidliche oder ein Cross-Selling-Empfehlungssystem zu schaffen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>