<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🀄️ 👩🏼‍🤝‍👨🏾 👨🏿‍🍳 Spring Boot，Hibernate和Kotlin为初学者逐步提供 ✋🏿 👁️ 👩🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="大家好，我叫Oleg，我是DomKlik的技术专家。在我们的团队中，堆栈的内核是Kotlin和Spring Boot。我想与大家分享我的经验以及与PostgreSQL和Hibernate结合使用Spring Boot和Kotlin的交互作用和功能。另外，以微服务为例，我将展示Kotlin的优势及其与...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Spring Boot，Hibernate和Kotlin为初学者逐步提供</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/domclick/blog/505860/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/4c/4m/k7/4c4mk7pj7ozce-14ymchq4bsa4s.jpeg" width="500"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大家好，我叫Oleg，我是DomKlik的技术专家。</font><font style="vertical-align: inherit;">在我们的团队中，堆栈的内核是Kotlin和Spring Boot。</font><font style="vertical-align: inherit;">我想与大家分享我的经验以及与PostgreSQL和Hibernate结合使用Spring Boot和Kotlin的交互作用和功能。</font><font style="vertical-align: inherit;">另外，以微服务为例，我将展示Kotlin的优势及其与类似Java应用程序的区别。</font><font style="vertical-align: inherit;">我将讨论在Hibernate中使用此堆栈时新手可能遇到的不太明显的困难。</font><font style="vertical-align: inherit;">对于希望切换到Kotlin并且熟悉Spring Boot，Hibernate Java的开发人员而言，本文将非常有用。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">外挂程式</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
对于Kotlin上的应用程序，作为项目收集器，请使用Gradle Kotlin DSL。</font><font style="vertical-align: inherit;">连接的插件列表将是Spring Boot的标准配置，而对于带有Hibernate的Kotlin，我们将有几个新插件：</font></font><br>
<br>
<pre><code class="kotlin hljs">plugins {<font></font>
    id(<span class="hljs-string">"org.springframework.boot"</span>) version <span class="hljs-string">"2.2.7.RELEASE"</span>
    id(<span class="hljs-string">"io.spring.dependency-management"</span>) version <span class="hljs-string">"1.0.9.RELEASE"</span>
    kotlin(<span class="hljs-string">"jvm"</span>) version <span class="hljs-string">"1.3.72"</span>
    kotlin(<span class="hljs-string">"plugin.spring"</span>) version <span class="hljs-string">"1.3.72"</span>
    kotlin(<span class="hljs-string">"plugin.jpa"</span>) version <span class="hljs-string">"1.3.72"</span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑最后三个。</font></font><br>
<br>
<code>kotlin(«jvm»)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-用于JVM的基本Kotlin插件。否则，将不会启动Java堆栈上的单个应用程序。</font></font><br>
<br>
<code>kotlin(«plugin.spring»)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-因为在科特林默认类是最终的，那么这个插件将自动打上注解类</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@Component</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@Async</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@Transactional</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@Cacheable</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以及</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>@SpringBootTest</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与此相关的文章开放的继承和话题，它将使写在科特林类被代理Spring的代理CGLIB。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是需要注意的重要的是标记注释的实体</font></font><code>@Entity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>@MappedSuperclass</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并</font></font><code>@Embaddable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不会成为</font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接插头后。而且，</font></font><code>get accessor</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们也将是最终的，然后</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将失去</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与之合作</font><strong><font style="vertical-align: inherit;">的机会</font></strong></font><code>entity reference</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了避免这种情况</font></font><code>Entity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">及其字段</font></font><code>open</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，添加到build.gradle.kts中：</font></font><br>
<br>
<pre><code class="kotlin hljs">allOpen {
   <span class="hljs-keyword">annotation</span>(<span class="hljs-string">"javax.persistence.Entity"</span>)
   <span class="hljs-keyword">annotation</span>(<span class="hljs-string">"javax.persistence.MappedSuperclass"</span>)
   <span class="hljs-keyword">annotation</span>(<span class="hljs-string">"javax.persistence.Embeddable"</span>)<font></font>
}</code></pre><br>
<code>kotlin(«plugin.jpa»)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-如果将前两个插件应用于Kotlin + Spring Boot上的任何应用程序，则下一个已经与Hibernate直接相关。</font><font style="vertical-align: inherit;">如您所知，他</font></font><code>Entity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用反射</font><font style="vertical-align: inherit;">进行初始化，</font><font style="vertical-align: inherit;">并使用不带参数的构造函数初始化类。</font><font style="vertical-align: inherit;">但是由于我们用Kotlin编写，所以可能找不到这样的构造函数。</font><font style="vertical-align: inherit;">如果我们确定自己的主构造函数（</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">primary Constructor</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），那么负载</font></font><code>Entity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将引发异常：</font></font><br>
<br>
<pre><code class="plaintext hljs">org.hibernate.InstantiationException: No default constructor for entity
</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">依存关系</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
依赖关系集也将与Java中的依赖项不完全相同：</font></font><br>
<br>
<pre><code class="kotlin hljs">dependencies {<font></font>
  implementation(<span class="hljs-string">"org.springframework.boot:spring-boot-starter-web"</span>)<font></font>
  implementation(<span class="hljs-string">"org.springframework.boot:spring-boot-starter-data-jpa"</span>)<font></font>
  implementation(<span class="hljs-string">"com.fasterxml.jackson.module:jackson-module-kotlin"</span>)<font></font>
  implementation(<span class="hljs-string">"org.jetbrains.kotlin:kotlin-reflect"</span>)<font></font>
  implementation(<span class="hljs-string">"org.jetbrains.kotlin:kotlin-stdlib-jdk8"</span>)<font></font>
  implementation(<span class="hljs-string">"org.liquibase:liquibase-core"</span>)<font></font>
<font></font>
  runtimeOnly(<span class="hljs-string">"org.postgresql:postgresql"</span>)<font></font>
<font></font>
  testImplementation(<span class="hljs-string">"org.springframework.boot:spring-boot-starter-test"</span>)<font></font>
  testImplementation(<span class="hljs-string">"org.testcontainers:testcontainers:<span class="hljs-variable">$testContainersVer</span>"</span>)<font></font>
  testImplementation(<span class="hljs-string">"org.testcontainers:postgresql:<span class="hljs-variable">$testContainersVer</span>"</span>)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
除了标准的Spring Boot Web启动程序和我们感兴趣的主要启动程序之外，还添加了一些依赖关系</font></font><code>org.springframework.boot:spring-boot-starter-data-jpa</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这使Hibernate成为默认的JPA实现：</font></font><br>
<br>
<code>org.jetbrains.kotlin:kotlin-reflect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-反映Kotlin所必需的，Spring Boot已经支持该Kotlin，它广泛用于初始化类。</font></font><br>
<br>
<code>org.jetbrains.kotlin:kotlin-stdlib-jdk8</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-增加了使用Java集合，流支持等的功能。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
与Java相比，这就是配置Kotlin项目的差异所在，让我们继续进行项目本身，表和实体的结构。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表格和实体</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们的应用程序将包含两个部门表和雇员表，它们通过一对多关系链接在一起。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表结构：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/53d/260/2a9/53d2602a91d6b89c3fddb16c27bc824a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PostgreSQL</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DBMS作为基础</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将使用</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">liquibase</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建表结构</font><font style="vertical-align: inherit;">，并将标准启动程序用作测试依赖项：</font></font><br>
<br>
<code>org.springframework.boot:spring-boot-starter-test</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-我们将使用</font><i><font style="vertical-align: inherit;">testcontainers</font></i><font style="vertical-align: inherit;">在Docker中进行</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">测试。</font></font></i><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实体</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
就像在具有多个实体的任何应用程序中一样，我们将为每个人创建一个共同的祖先</font></font><code>entity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>BaseEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@MappedSuperclass</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEntity</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
<font></font>
   <span class="hljs-meta">@Id</span>
   <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
   <span class="hljs-keyword">var</span> id: T? = <span class="hljs-literal">null</span><font></font>
<font></font>
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">equals</span><span class="hljs-params">(other: <span class="hljs-type">Any</span>?)</span></span>: <span class="hljs-built_in">Boolean</span> {<font></font>
       other ?: <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === other) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><font></font>
<font></font>
       <span class="hljs-keyword">if</span> (javaClass != ProxyUtils.getUserClass(other)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><font></font>
<font></font>
       other <span class="hljs-keyword">as</span> BaseEntity&lt;*&gt;<font></font>
<font></font>
       <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.id == other.id<font></font>
   }<font></font>
<font></font>
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span> = <span class="hljs-number">25</span><font></font>
<font></font>
   <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String {
       <span class="hljs-keyword">return</span> <span class="hljs-string">"<span class="hljs-subst">${this.javaClass.simpleName}</span>(id=<span class="hljs-variable">$id</span>)"</span><font></font>
   }<font></font>
}</code></pre><br>
<code>DepartmentEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = <span class="hljs-meta-string">"department"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentEntity</span></span>(<font></font>
<font></font>
       <span class="hljs-keyword">val</span> name: String,<font></font>
<font></font>
       <span class="hljs-meta">@OneToMany(
               mappedBy = <span class="hljs-meta-string">"department"</span>,
               fetch = FetchType.LAZY,
               orphanRemoval = true,
               cascade = [CascadeType.ALL]
       )</span>
       <span class="hljs-keyword">val</span> employees: MutableList&lt;EmployeeEntity&gt; = mutableListOf()<font></font>
) : BaseAuditEntity&lt;<span class="hljs-built_in">Long</span>&gt;() {<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">addEmployee</span><span class="hljs-params">(block: <span class="hljs-type">DepartmentEntity</span>.() -&gt; <span class="hljs-type">EmployeeEntity</span>)</span></span> {<font></font>
       employees.add(block())<font></font>
   }<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setEmployees</span><span class="hljs-params">(block: <span class="hljs-type">DepartmentEntity</span>.() -&gt; <span class="hljs-type">MutableSet</span>&lt;<span class="hljs-type">EmployeeEntity</span>&gt;)</span></span> {<font></font>
       employees.clear()<font></font>
       employees.addAll(block())<font></font>
   }<font></font>
}</code></pre><br>
<code>EmployeeEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@Entity</span>
<span class="hljs-meta">@Table(name = <span class="hljs-meta-string">"employee"</span>)</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeEntity</span></span>(<font></font>
<font></font>
       <span class="hljs-keyword">val</span> firstName: String,<font></font>
<font></font>
       <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>,<font></font>
<font></font>
       <span class="hljs-meta">@ManyToOne</span>
       <span class="hljs-meta">@JoinColumn(name = <span class="hljs-meta-string">"department_id"</span>)</span>
       <span class="hljs-keyword">val</span> department: DepartmentEntity<font></font>
) : BaseAuditEntity&lt;<span class="hljs-built_in">Long</span>&gt;()</code></pre><br>
<strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们不使用数据类</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">对于Kotlin而言，这似乎比Java（版本14之前）具有明显优势，对此有一个解释。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么不使用？</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
数据类，除了是最终对自己，对所有领域的某些领域</font></font><code>equals</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>hashCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>toString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">与Hibernate一起使用时</font><font style="vertical-align: inherit;">，这是</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不可接受的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
为什么？</font><font style="vertical-align: inherit;">以及为什么</font></font><code>hashCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它总是等于常量的原因-答案在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hibernate本身</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">文档中</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">具体来说，我们对本节感兴趣：</font></font><br>
<br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管对于</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">equals</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashCode而言</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font><font style="vertical-align: inherit;">最好使用Natural-id </font><font style="vertical-align: inherit;">，但是有时您只有提供唯一约束的实体标识符。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以使用实体标识符进行相等性检查，但是需要一种变通方法：</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您需要为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hashCode</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供一个常量值，</font><font style="vertical-align: inherit;">以便在刷新实体前后哈希值不会改变。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您只需要比较非瞬态实体的实体标识符相等性。</font></font></li>
</ul></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
也就是说，您需要按进行比较</font></font><code>natural id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，或者像我们的示例一样按进行比较</font></font><code>primary key id</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在比较实体时，这将避免很多问题，并在将实体用作中的元素时避免其丢失</font></font><code>Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
存在</font></font><code>toString</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，所有字段中定义的，完全杀死所有懒惰，例如，记账实体时，由于所有字段都将用于输出到一个字符串被初始化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
鉴于Hibernate的功能，此Kotlin功能不适合我们。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">类构造器</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kotlin允许您通过构造函数设置变量，这是不使用的一种罪过。</font><font style="vertical-align: inherit;">再考虑一下</font></font><code>DepartmentEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentEntity</span></span>(<font></font>
<font></font>
       <span class="hljs-keyword">val</span> name: String,<font></font>
<font></font>
       <span class="hljs-meta">@OneToMany(
               mappedBy = <span class="hljs-meta-string">"department"</span>,
               fetch = FetchType.LAZY,
               orphanRemoval = true,
               cascade = [CascadeType.ALL]
       )</span>
       <span class="hljs-keyword">val</span> employees: MutableList&lt;EmployeeEntity&gt; = mutableListOf()<font></font>
) : BaseAuditEntity&lt;<span class="hljs-built_in">Long</span>&gt;() {</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们还可以通过构造函数初始化单元名称，例如：</font></font><br>
<br>
<pre><code class="kotlin hljs">departmentRepository.save(DepartmentEntity(name = <span class="hljs-string">"Department One"</span>))</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通过构造函数，您可以初始化（除其他外）employees雇员列表。</font><font style="vertical-align: inherit;">当然，集合将被声明为可变的。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">根据需要更改字段使用var / val</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将该组织的名称标记为</font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DepartmentEntity</span></span>(<font></font>
<font></font>
       <span class="hljs-keyword">val</span> name: String,</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
而且不可能</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
选择</font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/ </font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是一个方便的选择，并取决于业务逻辑。</font><font style="vertical-align: inherit;">请</font><font style="vertical-align: inherit;">根据需要在</font><font style="vertical-align: inherit;">两者之间进行选择，</font></font><code>var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且</font></font><code>val</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有必要：实体字段是否可变。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">仅根据DB在字段中的无效有效性</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
至于</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">字段中</font><font style="vertical-align: inherit;">值的有效性，</font><font style="vertical-align: inherit;">并不是那么简单。之前，我们对Hibernate进行了深入研究：说到plugin.jpa，我提到了在初始化实体时使用不带参数的构造函数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
初始化字段时，也使用反射。并且，如果将值存储在数据库中的相应列中</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则将使用带有该值的字段对该类进行静默初始化</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。访问该字段时，尽管该字段标记为，但冒着获得NPE的风险</font></font><code>not nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。为了避免这种情况，有必要监视表和类的结构的同步性。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果您更全面地看一下后两节中描述的内容，那么这些规则不仅适用于基元，还适用于一堆实体。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
例如，它</font></font><code>EmployeeEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">始终附加到</font></font><code>DepartmentEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeEntity</span></span>(<font></font>
<font></font>
       <span class="hljs-keyword">val</span> firstName: String,<font></font>
<font></font>
       <span class="hljs-keyword">var</span> lastName: String? = <span class="hljs-literal">null</span>,<font></font>
<font></font>
       <span class="hljs-meta">@ManyToOne</span>
       <span class="hljs-meta">@JoinColumn(name = <span class="hljs-meta-string">"department_id"</span>)</span>
       <span class="hljs-keyword">val</span> department: DepartmentEntity<font></font>
) : BaseAuditEntity&lt;<span class="hljs-built_in">Long</span>&gt;()</code></pre><br>
<code>Department</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不是</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并且不能更改，这可以消除各种错误，尤其是在业务逻辑需要不变性的情况下。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">储存库</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
使用Kotlin时，现成的存储库现在具有验证检查</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，如果我们确定当</font></font><code>department</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">按名称</font><font style="vertical-align: inherit;">搜索时</font><font style="vertical-align: inherit;">，结果将是唯一且唯一的，则可以将返回类型指定为</font></font><code>non nullable</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DepartmentRepository</span> : <span class="hljs-type">JpaRepository</span>&lt;<span class="hljs-type">DepartmentEntity, Long</span>&gt; </span>{<font></font>
<font></font>
   <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">findOneByName</span><span class="hljs-params">(name: <span class="hljs-type">String</span>)</span></span> : DepartmentEntity<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它</font></font><code>DepartmentEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示唯一的，不能</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果由于某种原因我们没有找到想要的东西</font></font><code>department</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么</font><font style="vertical-align: inherit;">我们将发现的</font><font style="vertical-align: inherit;">不是NPE，而是其他：</font></font><br>
<br>
<pre><code class="plaintext hljs">org.springframework.dao.EmptyResultDataAccessException: Result must not be null!
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这种处理是通过将专业科特林支持，以实现</font></font><code>MethodInvocationValidator</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>ReflectionUtils</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">春季数据公地。</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lateinit var</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我想考虑的另一个Kotlin功能是</font></font><code>lateinit var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
添加新的类祖先：</font></font><code>BaseAuditEntity</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@MappedSuperclass</span>
<span class="hljs-meta">@EntityListeners(AuditingEntityListener::class)</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseAuditEntity</span>&lt;<span class="hljs-type">T</span>&gt; : <span class="hljs-type">BaseEntity</span>&lt;<span class="hljs-type">T</span>&gt;</span>() {<font></font>
<font></font>
   <span class="hljs-meta">@CreatedDate</span>
   <span class="hljs-meta">@Column(updatable = false, nullable = false)</span>
   <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> created: LocalDateTime<font></font>
<font></font>
   <span class="hljs-meta">@LastModifiedDate</span>
   <span class="hljs-meta">@Column(nullable = false)</span>
   <span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> modified: LocalDateTime<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
以使用</font></font><code>lateinit var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">审计字段（</font></font><code>created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>modified</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font><font style="vertical-align: inherit;">为例</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<code>lateinit var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-这是一个</font></font><code>not null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">延迟的初始化字段。</font><font style="vertical-align: inherit;">在初始化字段之前访问该字段会产生错误：</font></font><br>
<br>
<pre><code class="plaintext hljs">kotlin.UninitializedPropertyAccessException: lateinit property has not been initialized
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
通常，我们将字段转到</font></font><code>created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>modified</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">甚至之后，因为实体已存储在数据库中。</font><font style="vertical-align: inherit;">在这种情况下，这些polyahprostavlyayutsya中的数据将被存储并且它们是</font></font><code>not null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，那么</font></font><code>lateinit var</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们就不合适了。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">摘要</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们创建了一个应用程序，该应用程序考虑了Kotlin的许多优点，并研究了与Java的重要区别，从而避免了许多隐藏的惊喜。</font><font style="vertical-align: inherit;">如果本文不仅对初学者有用，我将感到高兴。</font><font style="vertical-align: inherit;">稍后，我们将继续与数据库进行微服务通信的主题。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接到应用程序</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN505834/index.html">中位数样本。置信区间和比较</a></li>
<li><a href="../zh-CN505838/index.html">适用于数千种应用的FPGA技术</a></li>
<li><a href="../zh-CN505846/index.html">从COVID-19开发疫苗时，真正的数学问题是什么？</a></li>
<li><a href="../zh-CN505850/index.html">产品代码中的C ++基于概念的多态性：LLVM中的PassManager</a></li>
<li><a href="../zh-CN505856/index.html">从暴力破解到隐私尝试-SaaS提供商面临的挑战</a></li>
<li><a href="../zh-CN505870/index.html">如何在日本，韩国和中国推广手机游戏和应用程序</a></li>
<li><a href="../zh-CN505872/index.html">无人驾驶车辆的历史</a></li>
<li><a href="../zh-CN505880/index.html">如何在Tarantool中编写索引</a></li>
<li><a href="../zh-CN505884/index.html">鱼叉式网络钓鱼：体验创建有条件的恶意可执行文件来仿冒电子邮件的经验</a></li>
<li><a href="../zh-CN505888/index.html">在没有YouTube API的情况下解析YouTube（包括上传的数据）</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>