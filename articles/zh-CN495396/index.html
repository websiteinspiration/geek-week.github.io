<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤮 🙎🏾 💄 概念的第一印象 🥉 🏯 😃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我决定处理新的C ++ 20功能-概念。
 
 概念（或讲俄语的Wiki所写的概念）是一个非常有趣且有用的功能，长期以来一直缺乏。
 
 本质上，它是在输入模板参数。
 
 C ++ 20之前的模板的主要问题是您可以替换其中的任何内容，包括根本没有设计的内容。也就是说，模板系统是完全没有类型的。结果...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>概念的第一印象</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495396/"><img src="https://habrastorage.org/webt/qd/ja/kc/qdjakcxd4173w_juzv5fx3bf0_o.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我决定处理新的C ++ 20功能-概念。</font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（或</font><font style="vertical-align: inherit;">讲俄语的Wiki所写的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">概念</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）是一个非常有趣且有用的功能，长期以来一直缺乏。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
本质上，它是在输入模板参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
C ++ 20之前的模板的主要问题是您可以替换其中的任何内容，包括根本没有设计的内容。也就是说，模板系统是完全没有类型的。结果，将错误的参数传递给模板时，出现了难以置信的漫长且完全无法读取的错误消息。他们试图借助不同的语言技巧来解决这个问题，我什至不想提及（尽管我不得不处理）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
设计概念是为了纠正这种误解。</font><font style="vertical-align: inherit;">他们在模板中添加了打字系统，功能非常强大。</font><font style="vertical-align: inherit;">现在，在了解了该系统的功能之后，我开始研究Internet上的可用资料。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
坦白说，我有点震惊：） C ++是一种已经很复杂的语言，但至少有一个借口：它发生了。</font><font style="vertical-align: inherit;">设计语言时，发现而不是放下对模板的元编程。</font><font style="vertical-align: inherit;">然后，在开发该语言的下一版本时，由于世界上编写了许多代码，因此他们不得不适应这种“发现”。</font><font style="vertical-align: inherit;">概念从根本上来说是一个新的机会。</font><font style="vertical-align: inherit;">而且，在我看来，它们的实现中已经存在一些不透明性。</font><font style="vertical-align: inherit;">也许这是需要考虑大量继承功能的结果吗？</font><font style="vertical-align: inherit;">让我们尝试弄清楚...</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一般信息</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
概念是基于模板语法的新语言实体。</font><font style="vertical-align: inherit;">概念具有名称，参数和主体-谓词，该谓词根据概念的参数返回常数（即在编译阶段计算的）逻辑值。</font><font style="vertical-align: inherit;">像这样：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt; 
<span class="hljs-keyword">concept</span> Even = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;  <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> FourByte = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
从技术上讲，概念与像bool这样的模板constexpr表达式非常相似：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">int</span> I&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> EvenX = I % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>; <font></font>
<font></font>
<span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> FourByteX = <span class="hljs-keyword">sizeof</span>(T)==<span class="hljs-number">4</span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
您甚至可以在常用表达式中使用概念：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Even&lt;<span class="hljs-number">2</span>&gt;; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该概念的主要思想是可以使用它们代替模板中的typename或class关键字。</font><font style="vertical-align: inherit;">像元类型（“类型的类型”）。</font><font style="vertical-align: inherit;">因此，静态类型被引入到模板中。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;FourByte T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(T <span class="hljs-keyword">const</span> &amp; t)</span> </span>{}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，如果我们将int用作模板参数，那么绝大多数情况下的代码都可以编译；</font><font style="vertical-align: inherit;">如果加倍，则将发出简短易懂的错误消息。</font><font style="vertical-align: inherit;">简单清晰地输入模板，到目前为止一切正常。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个新的“上下文” C ++ 20关键字，具有双重用途：require子句和require表达式。</font><font style="vertical-align: inherit;">如稍后所示，这种奇怪的关键字节省导致一些混乱。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要表达</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
首先，考虑需要表达。</font><font style="vertical-align: inherit;">这个想法非常好：这个词在括号中有一个块，其中的代码将进行编译评估。</font><font style="vertical-align: inherit;">的确，那里的代码不应该用</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">C ++</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写</font><b><font style="vertical-align: inherit;">，而应该使用一种接近C ++的特殊语言，但</font></b><font style="vertical-align: inherit;">要有</font><b><font style="vertical-align: inherit;">自己的特点</font></b><font style="vertical-align: inherit;">（这是第一个奇怪的事情，很可能只编写C ++代码）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果代码正确-require表达式返回true，否则返回false。</font><font style="vertical-align: inherit;">当然，代码本身永远也不会进入代码生成，就像sizeof或decltype的表达式一样。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
不幸的是，这个词是上下文的，仅在模板内部有效，也就是说，在模板外部无法编译：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b = <span class="hljs-keyword">requires</span> { <span class="hljs-number">3.14</span> &gt;&gt; <span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
并在模板中-请：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">bool</span> Shiftable = <span class="hljs-keyword">requires</span>(T i) { i&gt;&gt;<span class="hljs-number">1</span>; };</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它将起作用：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">bool</span> b1 = Shiftable&lt;<span class="hljs-keyword">int</span>&gt;; <span class="hljs-comment">// true</span>
<span class="hljs-keyword">bool</span> b2 = Shiftable&lt;<span class="hljs-keyword">double</span>&gt;; <span class="hljs-comment">// false</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
require表达式的主要用途是概念的创建。</font><font style="vertical-align: inherit;">例如，这是检查类型中字段和方法是否存在的方式。</font><font style="vertical-align: inherit;">一个非常受欢迎的案例。</font></font><br>
<br>
<pre><code class="plaintext hljs">template &lt;typename T&gt;<font></font>
concept Machine = <font></font>
  requires(T m) {  //   `m` ,   Machine<font></font>
	m.start();     //    `m.start()` <font></font>
	m.stop();      //   `m.stop()`<font></font>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一下，必须在括号中的require表达式中声明测试代码中可能需要的所有变量（不仅是模板参数）。</font><font style="vertical-align: inherit;">由于某些原因，根本不可能声明变量。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">内部类型检查要求</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这就是要求代码和标准C ++之间的区别所在。</font><font style="vertical-align: inherit;">为了检查返回的类型，使用了一种特殊的语法：将对象放在大括号中，放置一个箭头，然后在其后写出该类型必须满足的概念。</font><font style="vertical-align: inherit;">此外，不允许直接使用类型。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查函数的返回值可以转换为int：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">int</span>&gt;;<font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
检查返回函数是否​​正好是int：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(T v, <span class="hljs-keyword">int</span> i) {<font></font>
  { v.f(i) } -&gt; <span class="hljs-built_in">std</span>::same_as&lt;<span class="hljs-keyword">int</span>&gt;; <font></font>
}  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
（std :: same_as和std :: convertible_to是标准库中的概念）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果不使用大括号检查其类型的表达式，则编译器将无法理解它们的要求，而是将整个字符串解释为需要检查以进行编译的单个表达式。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">需要里面要求</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
require关键字在require表达式内部具有特殊含义。</font><font style="vertical-align: inherit;">嵌套的require-expressions（已经不带花括号）不进行编译检查，而是检查是否为true或false。</font><font style="vertical-align: inherit;">如果发现这样的表达式为假，则封闭的表达式立即为假（并且进一步的编译分析将中断）。</font><font style="vertical-align: inherit;">一般形式：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> { <font></font>
  expression;         <span class="hljs-comment">// expression is valid</span>
  <span class="hljs-keyword">requires</span> predicate; <span class="hljs-comment">// predicate is true</span>
};</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
作为谓词，例如，可以使用先前定义的概念或类型特征。</font><font style="vertical-align: inherit;">例：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span>(Iter it) {
  <span class="hljs-comment">//     (   Iter   *  ++)</span><font></font>
  *it++;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::convertible_to&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
 <font></font>
  <span class="hljs-comment">//    -  </span>
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_convertible_v&lt;<span class="hljs-keyword">decltype</span>(*it++), <span class="hljs-keyword">typename</span> Iter::value_type&gt;;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同时，使用括号中的代码允许嵌套的require-expressions进行有效性检查。</font><font style="vertical-align: inherit;">但是，如果您仅在另一个内部编写一个require-expression，则将仅检查嵌套表达式（包括嵌套的require关键字在内的所有内容）的有效性：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">typename</span> T::value_type x) { ++x; }; <span class="hljs-comment">//     , </span>
												<span class="hljs-comment">//     !</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，出现了一个带有双重的奇怪形式：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> (T v) { 
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span> <span class="hljs-params">(<span class="hljs-keyword">typename</span> T::value_type x)</span> </span>{ ++x; }; <span class="hljs-comment">//       "++x"</span>
};  </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是来自“ requires”的一个有趣的转义序列。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
顺便说一句，这两个条件的另一个组合是此时间子句（请参见下文）和表达式：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> <span class="hljs-title">requires</span><span class="hljs-params">(T x, T y)</span> </span>{ <span class="hljs-keyword">bool</span>(x &lt; y); }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">equivalent</span><span class="hljs-params">(T <span class="hljs-keyword">const</span>&amp; x, T <span class="hljs-keyword">const</span>&amp; y)</span>
</span>{
  <span class="hljs-keyword">return</span> !(x &lt; y) &amp;&amp; !(y &lt; x);<font></font>
};</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要求条款</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们继续使用需求一词的另一种用法-声明模板类型的限制。</font><font style="vertical-align: inherit;">这是使用概念名称代替类型名称的替代方法。</font><font style="vertical-align: inherit;">在下面的示例中，所有三种方法都是等效的：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-comment">//  require</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
	<span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span></span>;<font></font>
<font></font>
<span class="hljs-comment">//   require (  )</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span> <span class="hljs-keyword">requires</span> Sortable&lt;Cont&gt;</span>;<font></font>
<font></font>
<span class="hljs-comment">//    typename</span>
<span class="hljs-function"><span class="hljs-keyword">template</span>&lt;Sortable Cont&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Cont&amp; container)</span>  </span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
require声明可以使用逻辑运算符组合的多个谓词。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> s;<font></font>
 <font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// ok</span>
  fun(s);  <span class="hljs-comment">// compiler error</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，由于发生编译错误，只需反转条件之一：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_standard_layout_v&lt;T&gt; &amp;&amp; !is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这是一个不会编译的示例</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> !<span class="hljs-function">is_trivial_v&lt;T&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;	</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
原因是解析某些表达式时出现歧义。</font><font style="vertical-align: inherit;">例如，在这样的模板中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt; 
  <span class="hljs-keyword">requires</span> (<span class="hljs-keyword">bool</span>)&amp;<span class="hljs-function">T::<span class="hljs-keyword">operator</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
尚不清楚将unsigned归于什么-运算符或foo（）函数的原型。</font><font style="vertical-align: inherit;">因此，开发人员决定在没有括号的情况下（作为参数require子句使用），只能使用非常有限的实体集-true或false文字，bool类型的字段名称，其形式为value，value，T :: value，ns :: trait :: value，类型为Concept的概念名称，并需要表达式。</font><font style="vertical-align: inherit;">其他所有内容都应放在括号中：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!is_trivial_v&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>;</code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在关于require子句中的谓词功能</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑另一个例子。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此示例中，require使用取决于嵌套value_type类型的特征。</font><font style="vertical-align: inherit;">事先不知道任意类型是否具有可以传递给模板的嵌套类型。</font><font style="vertical-align: inherit;">例如，如果将简单的int类型传递给这样的模板，则会出现编译错误，但是，如果我们对模板进行了两种特殊化，则不会有错误。</font><font style="vertical-align: inherit;">只会选择另一个专业。</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-function"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; 
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"1"</span>; } <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span> </span>{ <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"2"</span>; } <font></font>
 <font></font>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{<font></font>
  fun(<span class="hljs-number">1</span>);  <span class="hljs-comment">// displays: "2"</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，不仅当require子句谓词返回false时，而且在事实证明它不正确时，也将放弃专门化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
谓词周围的括号是一个重要的提醒，即在require子句中，谓词的逆与谓词本身不是相反的。</font><font style="vertical-align: inherit;">所以，</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">requires</span> is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示特征正确，并返回true。</font><font style="vertical-align: inherit;">其中</font></font><br>
<br>
<pre><code class="cpp hljs">!is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
表示“特征正确且返回假” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
，第一个谓词</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">真正逻辑反转不是（“特征正确且返回真”）==“特征不正确或返回假” –这是通过概念的显式定义以稍微复杂的方式实现的：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">concept</span> value_type_valid_and_trivial <font></font>
  = is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;; <font></font>
 <font></font>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
  <span class="hljs-keyword">requires</span> (!value_type_valid_and_trivial&lt;T&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v)</span></span>; </code></pre><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连词和析取词</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
逻辑合取运算符和析取运算符看起来像往常一样，但实际上工作方式与普通C ++略有不同。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
考虑两个非常相似的代码段。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第一个是不带括号的谓词：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		|| <span class="hljs-function"><span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;
<span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个是带有方括号的：</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;
  <span class="hljs-keyword">requires</span> (<span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> T::value_type&gt;<font></font>
		 || <span class="hljs-built_in">std</span>::is_trivial_v&lt;<span class="hljs-keyword">typename</span> U::value_type&gt;)
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">(T v, U u)</span></span>; </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
区别仅在于方括号。</font><font style="vertical-align: inherit;">但是正因为如此，在第二个模板中，没有两个约束由“需求子句”联合，而是一个约束与通常的逻辑“或”联合。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该差异如下。</font><font style="vertical-align: inherit;">考虑代码</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-built_in">std</span>::optional&lt;<span class="hljs-keyword">int</span>&gt; oi {};
<span class="hljs-keyword">int</span> i {};<font></font>
fun(i, oi);</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，模板由int和std ::可选类型实例化。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第一种情况下，int :: value_type类型无效，因此不满足第一个限制。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是类型可选:: :: value_type是有效的，第二个特征返回true，并且由于约束之间存在OR运算符，因此整个谓词都可以满足。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在第二种情况下，这是一个包含无效类型的单个表达式，由于该表达式通常无效，因此不满足该谓词。</font><font style="vertical-align: inherit;">因此，简单的括号会在不知不觉中改变正在发生的事情的含义。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">结论</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
当然，此处未显示概念的所有功能。我只是没有走得更远。但是，作为第一印象，这是一个非常有趣的想法，并且有些奇怪的实现。重复的有趣语法要求，这确实令人困惑。英语中真的有那么少的单词，您不得不将一个单词用于完全不同的目的吗？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
带有编译代码的想法绝对是个好主意。它甚至有点类似于语法宏中的“准引用”。但是，值得混用检查返回类型的特殊语法吗？恕我直言，为此，只需要做一个单独的关键字。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在一个堆中隐式混合使用“ true / false”和“ compiles / not compile”的概念，因此，带有括号的笑话也是错误的。</font><font style="vertical-align: inherit;">这些是不同的概念，它们必须严格存在于不同的上下文中（尽管我了解它的来源-SFINAE规则，未编译的代码只是默默地排除了特殊性）。</font><font style="vertical-align: inherit;">但是，如果这些概念的目标是使代码尽可能明确，那么将所有这些隐式内容拖到新功能中是否值得？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这篇文章主要基于</font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/01/29/requires-expression </font></font></a><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akrzemi1.wordpress.com/2020/03/26/requires-clause</font></font></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
（有更多示例和有趣功能）</font><font style="vertical-align: inherit;">撰写</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
，而我的补充来自其他来源，</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
可以检查所有示例</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wandbox.org</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495380/index.html">大埃及防火墙</a></li>
<li><a href="../zh-CN495384/index.html">我在Microsoft Redmond的实习经历并获得录取通知</a></li>
<li><a href="../zh-CN495388/index.html">1970年代电视节目成为电子竞技的始祖</a></li>
<li><a href="../zh-CN495390/index.html">STM32CubeMonitor值得一试</a></li>
<li><a href="../zh-CN495392/index.html">如何在前端搜索错误：4个主要阶段</a></li>
<li><a href="../zh-CN495398/index.html">罗·里·雷</a></li>
<li><a href="../zh-CN495400/index.html">通过SPI接口使用SD卡。VHDL实施</a></li>
<li><a href="../zh-CN495402/index.html">去年，我们终于拍摄了一个黑洞。怎么办？</a></li>
<li><a href="../zh-CN495404/index.html">股市下跌是否有希望？让我们用python分析</a></li>
<li><a href="../zh-CN495408/index.html">＃02-整个字节还不够... | 变化的十字架</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>