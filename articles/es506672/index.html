<!doctype html>
<html class="no-js" lang="es">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§¶üèΩ üë©‚Äç‚öïÔ∏è üëãüèª SwiftUI en los estantes: Animaci√≥n, parte 2 üëé üêÄ üçÇ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta es la segunda parte de la historia de animaci√≥n en SwiftUI. En el primer art√≠culo, vimos ejemplos simples de los conceptos b√°sicos de c√≥mo funcio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>SwiftUI en los estantes: Animaci√≥n, parte 2</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/506672/"><img src="https://habrastorage.org/webt/1u/td/t6/1utdt6xa6tcsov4biwj2ura36s0.png" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta es la segunda parte de la historia de animaci√≥n en SwiftUI. En el primer </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo,</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vimos ejemplos simples de los conceptos b√°sicos de c√≥mo funciona la animaci√≥n en SwiftUI. En esta parte, iremos m√°s all√° y analizaremos en detalle el ejemplo anunciado con la animaci√≥n del arco iris. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d7/am/oa/d7amoa5ktffdezfstl4a1pisyjw.gif" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debajo del corte, encontrar√° un an√°lisis del tiempo de la animaci√≥n, creando su propio mecanismo de curva de tiempo para trabajar en una animaci√≥n lineal en bucle, ejemplos de la implementaci√≥n de diferentes gradientes y algunas t√©cnicas interesantes que ayudar√°n a comprender la animaci√≥n bajo el cap√≥.</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perm√≠teme recordarte que vi la idea de implementar tal animaci√≥n </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . All√≠, los autores tomaron el camino de menor resistencia e implementaron la forma m√°s obvia de implementar este concepto animando la forma. El principio es simple: cada onda es un contorno delineado por una curva de Bezier, y el par√°metro "tiempo" afecta la posici√≥n del l√≠mite derecho de esta onda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como se ve la animaci√≥n terminada: </font></font><br>
<br>
<img src="https://habrastorage.org/getpro/habr/post_images/7a7/cbf/7a0/7a7cbf7a05561123ceff4be47fff5ed6.gif" alt="imagen"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para mayor claridad, extender√© las ondas un poco verticalmente. Esto es f√°cil de hacer, acabo de agregar al final de NotchWave moviendo todo el contorno hasta la altura de la ola, de acuerdo con la fase actual de la animaci√≥n:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-keyword">return</span> p.applying(.<span class="hljs-keyword">init</span>(translationX: <span class="hljs-number">0</span>, y: height * <span class="hljs-keyword">self</span>.phase))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno y tambi√©n .drowingGroup () es necesario no olvidar desconectarse, no significa que la imagen vaya m√°s all√° de los bordes del marco fijo. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/z3/zv/bi/z3zvbiseywno8t1fnt-i0ugcqgm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El enfoque es simple, produce el resultado deseado ... pero me pareci√≥ demasiado aburrido. </font><font style="vertical-align: inherit;">Mi camino result√≥ ser mucho m√°s largo, y no dir√≠a que el resultado final ser√≠a al menos algo mejor, pero ser√≠a interesante en el camino. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si a√∫n no conoce los principios del trabajo de animaci√≥n en SwiftUI, le recomiendo leer el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">art√≠culo anterior</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Y quiero profundizar en el c√≥digo fuente en el </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trabajar con gradientes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al principio, eleg√≠ un enfoque diferente. Me result√≥ mucho m√°s √∫til tratar con la animaci√≥n del desplazamiento de objetos que con la animaci√≥n de los formularios (todav√≠a llamo la estructura de forma del formulario). Offset puede funcionar con cualquier cosa: varias formas, im√°genes, otras vistas. Como tarea educativa, quer√≠a implementar una transici√≥n de color suave de una ola a otra. En el concepto original, algo as√≠ era as√≠. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En total, SwiftIUI ofrece tres posibles usos del gradiente: lineal, circular y angular. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/t7/o6/7d/t7o67dwcm_v5svufist7tfp0kwe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el c√≥digo, esto parece una especie de constructor de bloques. Observe c√≥mo se segmenta toda la onda.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wa/af/el/waafeltt9cgiasfzxg1gjexwc8i.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un gradiente lineal se caracteriza por un punto inicial y final para el gradiente. </font><font style="vertical-align: inherit;">Estos no son puntos CGPoint con coordenadas absolutas (x: y :), sino puntos UnitPoint, es decir </font><font style="vertical-align: inherit;">coordenadas relativas, donde x: y: se especifican en fracciones del ancho y alto del √°rea seleccionada para esta Vista. </font><font style="vertical-align: inherit;">Tambi√©n hay puntos predefinidos correspondientes a las esquinas (.topLeading, .bottomTrailing, etc.) y los puntos medios de los lados (.top, .trailing, etc.).</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
    .fill(<span class="hljs-type">LinearGradient</span>(<font></font>
         gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
             .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
          startPoint: .leading,<font></font>
          endPoint: .trailing))<font></font>
    .frame(width: <span class="hljs-keyword">self</span>.gradientLength)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El segmento de gradiente lineal es "caucho". </font><font style="vertical-align: inherit;">Tiene un ancho fijo, pero su altura no est√° especificada. </font><font style="vertical-align: inherit;">Por lo tanto, completar√° la cantidad total proporcionada. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una historia un poco m√°s complicada con un degradado circular. </font><font style="vertical-align: inherit;">Indicamos el punto: el centro del c√≠rculo, el radio del comienzo del gradiente y el radio del final del gradiente. </font><font style="vertical-align: inherit;">Los radios ya est√°n en t√©rminos absolutos, es decir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">puntos</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El centro del c√≠rculo todav√≠a est√° configurado como UnitPoint.</font></font><br>
<br>
<pre><code class="swift hljs">
<span class="hljs-type">Rectangle</span>()<font></font>
     .fill(<span class="hljs-type">RadialGradient</span>(<font></font>
          gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">0</span>),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-keyword">self</span>.middleGradientStop),<font></font>
              .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">1</span>)]),<font></font>
          center: .bottomTrailing,<font></font>
          startRadius: <span class="hljs-keyword">self</span>.topRadius,<font></font>
          endRadius: <span class="hljs-keyword">self</span>.topRadius + <span class="hljs-keyword">self</span>.gradientLength)<font></font>
                )<font></font>
    .frame(height: <span class="hljs-keyword">self</span>.topRadius)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Una pieza con un c√≠rculo superior tiene una altura fija, pero se estira horizontalmente. Despu√©s de todo, establecemos radios fijos espec√≠ficos en puntos, por lo que no es necesario pegar un rect√°ngulo de estiramiento adicional del color base, como es el caso con un gradiente lineal. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El m√°s dif√≠cil de aplicar es un gradiente angular. Est√° dado por el √°ngulo inicial y final, as√≠ como la direcci√≥n. Como puede ver en la lista de c√≥digos, trabajar con esquinas no es muy conveniente. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Debe calcular el curso escolar de trigonometr√≠a para calcular el √°ngulo requerido, si necesita comenzar el gradiente angular en un punto y terminar en otro.</font></font><br>
<br>
<pre><code class="swift hljs">       
<span class="hljs-type">Rectangle</span>()<font></font>
      .fill(<span class="hljs-type">AngularGradient</span>(<font></font>
            gradient: <span class="hljs-type">Gradient</span>(stops: [<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.end, location: <span class="hljs-number">0</span>),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.middle, location: <span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.angularGradientMiddleStop(blockWidth: geometry.size.width)),<font></font>
                  .<span class="hljs-keyword">init</span>(color: <span class="hljs-keyword">self</span>.start, location: <span class="hljs-number">1</span>)]),<font></font>
            center: .bottomLeading,<font></font>
            startAngle: <span class="hljs-keyword">self</span>.directionTo(gradientPart: <span class="hljs-keyword">self</span>.start, blockWidth: geometry.size.width),<font></font>
            endAngle: <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)))<font></font>
<font></font>
...<font></font>
   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">directionTo</span><span class="hljs-params">(gradientPart: Color, blockWidth: CGFloat)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> angleOf = gradientAngles(blockWidth: blockWidth)
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>.zero
        <span class="hljs-keyword">switch</span> gradientPart{
            <span class="hljs-keyword">case</span> start: angle = angleOf.start
            <span class="hljs-keyword">case</span> middle: angle = angleOf.middle
            <span class="hljs-keyword">case</span> end: angle = angleOf.end
            <span class="hljs-keyword">default</span>: <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"there is no gradient stop with that color: \(gradientPart)"</span>)<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gradientAngles</span><span class="hljs-params">(blockWidth: CGFloat)</span></span> -&gt; (start: <span class="hljs-type">Angle</span>, middle: <span class="hljs-type">Angle</span>, end: <span class="hljs-type">Angle</span>){
        <span class="hljs-keyword">let</span> blockHeight = <span class="hljs-keyword">self</span>.bottomRadius
        <span class="hljs-keyword">let</span> center = <span class="hljs-type">CGPoint</span>(x: <span class="hljs-number">0</span>, y: blockHeight)
        <span class="hljs-keyword">let</span> topRight = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength)
        <span class="hljs-keyword">let</span> topGradientStarts = <span class="hljs-type">CGPoint</span>(x: blockWidth, y: blockHeight - <span class="hljs-keyword">self</span>.gradientLength * (<span class="hljs-number">1</span> - <span class="hljs-keyword">self</span>.middleGradientStop))
        <span class="hljs-keyword">let</span> startAngle = center.radialDirection(to: topRight)
        <span class="hljs-keyword">let</span> middleAngle = center.radialDirection(to: topGradientStarts)
        <span class="hljs-keyword">let</span> endAngle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">360</span>)
        <span class="hljs-keyword">return</span> (start: startAngle, middle: middleAngle, end: endAngle)<font></font>
    }<font></font>
<font></font>
...<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CGPoint</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">radialDirection</span><span class="hljs-params">(to point: CGPoint)</span></span> -&gt; <span class="hljs-type">Angle</span>{
        <span class="hljs-keyword">let</span> deltaX =  point.x - <span class="hljs-keyword">self</span>.x
        <span class="hljs-keyword">let</span> deltaY =  point.y - <span class="hljs-keyword">self</span>.y
        <span class="hljs-keyword">var</span> angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> deltaX == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaY == <span class="hljs-number">0</span>{
            <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">0</span>)<font></font>
            }<span class="hljs-keyword">else</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>)<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &gt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">270</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaX / -deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &gt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">90</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(-deltaX / deltaY)))<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> deltaX &lt; <span class="hljs-number">0</span> &amp;&amp; deltaY &lt; <span class="hljs-number">0</span>{<font></font>
                angle = <span class="hljs-type">Angle</span>(degrees: <span class="hljs-number">180</span>) + <span class="hljs-type">Angle</span>(radians: atan(<span class="hljs-type">Double</span>(deltaY / deltaX)))<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> angle<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El gradiente angular, que es la cola de la ola, tambi√©n es de goma, pero ya de ancho, ocupa la mitad del tama√±o restante. En realidad, es por eso que hay tanta trigonometr√≠a. S√© la posici√≥n de puntos espec√≠ficos en el borde de la pantalla donde deber√≠a estar un determinado color (ya que estoy pegando un degradado circular con uno angular). Adem√°s, los valores de los √°ngulos dependen no solo de los radios del gradiente inferior, sino tambi√©n del ancho del bloque mismo con el gradiente. Por primera vez desde la escuela, tom√© un l√°piz y record√© √°lgebra :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las tres opciones usan una √∫nica descripci√≥n de colores dentro del degradado. </font><font style="vertical-align: inherit;">Esta es una lista simple de colores en una matriz. </font><font style="vertical-align: inherit;">Su distribuci√≥n ser√° uniforme en un segmento dado. </font><font style="vertical-align: inherit;">Puede refinar la distribuci√≥n utilizando una matriz de elementos Stop. </font><font style="vertical-align: inherit;">De hecho, esta es la misma enumeraci√≥n de colores, solo para cada uno de ellos tambi√©n se indica la coordenada en un solo segmento donde se ubicar√°. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, cre√© una ola de aproximadamente la misma forma que en el concepto original. </font><font style="vertical-align: inherit;">Sin embargo, la transici√≥n de un color a otro ahora no es n√≠tida, sino suavizada, lo que podr√≠a hacer que la animaci√≥n sea m√°s suave.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El color no es lo que parece</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un punto relacionado con el color. </font><font style="vertical-align: inherit;">Para crear el efecto de una onda ondulante, decid√≠ hacer que la transici√≥n entre colores no fuera bastante lineal. </font><font style="vertical-align: inherit;">Si observa detenidamente, notar√° que el gradiente es m√°s n√≠tido en el borde mismo, y cuanto m√°s lejos del borde, m√°s suave fluye hacia el color principal. </font></font><br>
<img src="https://habrastorage.org/webt/hb/k-/f-/hbk-f-u1tcrri8furxdgeg8tx50.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo logr√© calculando el color intermedio y creando un degradado con esta distribuci√≥n:</font></font><br>
<blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">color inicial - 0 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
color intermedio - 0.3 </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
color final - 1</font></font><br>
</blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El problema surgi√≥ al calcular el promedio de dos colores. SwiftUI significa usar el objeto Color para degradados, y me sedujo. De hecho, si desea trabajar con colores al igual que con los objetos RGB, inicialmente use UIColor en su modelo, porque el color no tiene acceso directo al color. Tampoco puedes convertirlo f√°cilmente a UIColor. La √∫nica </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(no)</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> soluci√≥n adecuada que encontr√© </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqu√≠</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> es obtener un reflejo de espejo con un an√°lisis de su representaci√≥n de cadena. Tal repetitivo, pero todav√≠a no hay otras opciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y esto no es un error, no una omisi√≥n. </font><font style="vertical-align: inherit;">El punto es que SwiftUI en el objeto Color no duplica la funcionalidad de UIColor. </font><font style="vertical-align: inherit;">Si necesita trabajar con canales rgb, √∫selo. </font><font style="vertical-align: inherit;">El color en SwiftUI es una vista que tiene un color b√°sico, cuyo valor espec√≠fico puede variar ligeramente seg√∫n la ubicaci√≥n de las estrellas en el cielo; un color rgb espec√≠fico se determina solo en el momento del dibujo en la pantalla. </font><font style="vertical-align: inherit;">La documentaci√≥n dice</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SwiftUI solo lo resuelve a un valor concreto justo antes de usarlo en un entorno determinado.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, pero qu√© se entiende por entorno: el color de la pared detr√°s de la espalda del usuario o el tema de dise√±o de iOS no est√° claro. </font><font style="vertical-align: inherit;">Si esto no le conviene, use UIColor de forma nativa.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n sin fin</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La animaci√≥n se especifica mediante el modificador .animation () y comienza despu√©s de que View se inicializa en el modificador </font></font><code>.onAppear()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cambiando la </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. </font><font style="vertical-align: inherit;">Como resultado, el modificador se </font></font><code>.rotationEffect()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suscribe para recibir animatableData en el intervalo de "fue" a "se convirti√≥", de acuerdo con el temporizador del sistema. </font><font style="vertical-align: inherit;">Hablamos de esto en la √∫ltima parte.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
       <span class="hljs-keyword">return</span> <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>))
            <span class="hljs-type">Spacer</span>()<font></font>
       }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/fl/dw/_0/fldw_0xguydvz5fe_-2tpcp3qkm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Al ejecutar una animaci√≥n sin fin de esta manera, debe comprender que cualquier cambio posterior a los modificadores animados lo "romper√°". </font><font style="vertical-align: inherit;">Por ejemplo, si despu√©s de comenzar, por alguna raz√≥n, cambia el valor del √°ngulo a 0, obtendr√° este efecto:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ad/vi/iv/adviivgxhwuw0rwwv1itknh2kie.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øPor qu√©? La respuesta est√° en el mecanismo de animaci√≥n de la transici√≥n de una animaci√≥n a otra. En nuestro ejemplo, cuando apareci√≥ por primera vez la Vista en la pantalla, comenzamos una transici√≥n animada de 0 a 90. La Vista en realidad almacena solo el valor final de 90, y el valor original de 0 no se almacena en ning√∫n lado. El motor de animaci√≥n conoce la posici√≥n de tiempo actual de la animaci√≥n y el valor actual de AnimatableData. En el punto de tiempo 0.5, ser√° 45. ¬øQu√© sucede si en este momento el usuario cambia el valor a 0? Respuesta: comenzar√° la animaci√≥n de cambiar el valor de 45 a 0. Todo sigue en bucle. Pero solo visualmente, el ciclo no est√° cerrado, sino roto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, hay casos en los que la animaci√≥n tambi√©n se "rompe" si su Vista usa @ObservedObject u otros par√°metros que hacen que la Vista se vuelva a representar. Para resolver este problema, el modificador .animation tiene un par√°metro .animation (: value :). Al pasar el valor all√≠, le indicamos al renderizador que el reinicio de la animaci√≥n solo es necesario cuando este valor cambia.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sin embargo, descubramos c√≥mo detener la animaci√≥n si ya no la necesitamos. Para hacer esto, debe proporcionar dos cosas. Obviamente, debemos decirle a SwiftUI que la animaci√≥n sin fin ya no es necesaria, reemplaz√°ndola por la habitual, final. Pero esto no es suficiente. El modificador .animation () es una instrucci√≥n sobre qu√© temporizaciones usar, pero la rotaci√≥n misma se describe dentro del modificador .rotationEffect (), y ya est√° suscrita para recibir nuevos valores del √°ngulo de rotaci√≥n por temporizador. Para detener la rotaci√≥n, tambi√©n necesitamos cambiar su valor.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animation)<font></font>
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.angle == <span class="hljs-number">90</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">self</span>.animation = .<span class="hljs-keyword">default</span>
                }<span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span>
                    <span class="hljs-keyword">self</span>.animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle = <span class="hljs-number">90</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/-o/-d/ui/-o-dui_0ep12qm5zwovo2iedvjm.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como antes, cambiar el valor del √°ngulo condujo al inicio de una nueva animaci√≥n (que parec√≠a rota), este cambio tambi√©n ser√° animado, pero ahora con los tiempos de la animaci√≥n normal. Por eso, nuestro cuadrado deja de girar no instant√°neamente, sino como si fuera m√°s lento. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lo mismo se puede escribir un poco m√°s sucintamente, si suspende toda la funcionalidad en una </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable del tipo on / off:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButton</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isStarted = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
            }<font></font>
        }<font></font>
        .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.isStarted.toggle()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hasta este punto, todo era relativamente f√°cil. Pero tenga en cuenta que todos los eventos aqu√≠ se generan dentro de la Vista. </font></font><code>.onAppear{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es invocado por el sistema y </font></font><code>onTapGesture{}</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, por supuesto, por el usuario. Sin embargo, ¬øqu√© sucede si desea encapsular toda la animaci√≥n dentro de una Vista, pas√°ndola solo de encendido / apagado? SwiftUI no implica la posibilidad de ning√∫n m√©todo principal desde la vista principal. Te√≥ricamente, puede almacenar la Vista secundaria como una estructura y llamar a sus m√©todos de mutaci√≥n, pero las </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables de la Vista secundaria no se pueden cambiar de esta manera, lo prob√©, no funciona. La √∫nica forma de hacer algo como esto es utilizar el PassthroughSubject de Combine, como lo hizo en el art√≠culo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, todo es mucho m√°s simple. Si se coloca claramente en los estantes de la cabeza, eso</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Este es el estado interno de la Vista, y al no tratar de manipularlo desde el exterior, la soluci√≥n correcta ser√° muy simple:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectStopButtonFromOutside</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Spacer</span>()
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: isStarted ? <span class="hljs-number">90</span> : <span class="hljs-number">0</span>))<font></font>
                .animation(isStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectParentView</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> isOn = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">AnimatedRectStopButtonFromOutside</span>(isStarted: isOn)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle Animation"</span>).onTapGesture {
                <span class="hljs-keyword">self</span>.isOn.toggle()<font></font>
            }<font></font>
        }.onAppear(){<font></font>
            <span class="hljs-keyword">self</span>.isOn = <span class="hljs-literal">true</span><font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, no necesitamos una </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suscripci√≥n para actualizar la Vista dentro de la vista secundaria: ya se actualiza en su conjunto cuando cambia el par√°metro externo. </font><font style="vertical-align: inherit;">A veces no es conveniente. </font><font style="vertical-align: inherit;">A veces no quisi√©ramos inicializar la vista secundaria una vez m√°s, por ejemplo, para no interrumpir la animaci√≥n, o en init () ocurren algunos c√°lculos complejos e intensivos en recursos (consultas, por ejemplo). </font><font style="vertical-align: inherit;">En estos casos, es mejor usar entidades de objeto, cuyos cambios se pueden monitorear usando el modificador onReceive.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modificaci√≥n del estado durante la actualizaci√≥n de la vista</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay una cosa m√°s digna de cobertura. Operamos con solo dos valores de 0 y 90 grados. Apagar la animaci√≥n restablece el √°ngulo a 0. ¬øPero es posible pausar la animaci√≥n en el momento en que hacemos clic en el bot√≥n y continuar de nuevo desde el mismo lugar cuando se reanuda? Veamos el c√≥digo que permite esto:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRect</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalStarted: <span class="hljs-type">Bool</span>
    <span class="hljs-keyword">let</span> externalStarted = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(started externalStarted: <span class="hljs-type">Bool</span>){
        <span class="hljs-keyword">self</span>.externalStarted = externalStarted
        <span class="hljs-keyword">self</span>._internalStarted = <span class="hljs-type">State</span>(initialValue: !externalStarted)<span class="hljs-comment">//forse to start animation</span><font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-comment">//thats wrong. It just hiding a problem from SwiftUI not solving it</span>
        <span class="hljs-type">DispatchQueue</span>.main.async {
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted == <span class="hljs-literal">false</span>{
                <span class="hljs-comment">// print("stop animation")</span>
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">false</span>
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
            }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.internalStarted == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.externalStarted {
             <span class="hljs-comment">//    print("start animation")</span>
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.internalStarted = <span class="hljs-literal">true</span>
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
       }<font></font>
         <font></font>
       <span class="hljs-keyword">return</span>  <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.red)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(internalStarted ? animation : .<span class="hljs-keyword">default</span>)
            <span class="hljs-type">Spacer</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e9/ci/ge/e9cigegcoxid1l9skuw2qxle238.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea principal es rastrear el tiempo al comienzo de la animaci√≥n. Despu√©s de un tiempo, cuando depende de nosotros detener la animaci√≥n, podremos verificar cu√°ntos ciclos completos de animaci√≥n han pasado y adivinar qu√© √°ngulo de rotaci√≥n del cuadrado estamos viendo en este momento. Despu√©s de eso, podemos asignar </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exactamente este valor a la variable del √°ngulo de rotaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para que este enfoque funcione, necesitamos rastrear el inicio y el final de la animaci√≥n. Init () no funcionar√°. No podemos acceder a los </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metros </font><font style="vertical-align: inherit;">existentes </font><font style="vertical-align: inherit;">para obtener la hora de inicio anterior de la animaci√≥n. Este es un token de </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables. Dentro de init, puede establecer solo el estado inicial de esta variable, pero al final de la inicializaci√≥n, si View ya exist√≠a antes de init (), el valor de las </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables se restaurar√°.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, aqu√≠ se implementa el par√°metro let externalStarted (que controlamos desde el exterior) y el par√°metro </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">interno var internalStarted, con el que controlamos directamente la animaci√≥n. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Solo faltaba uno: alg√∫n modificador que verificara su cumplimiento y se actualizara si fuera necesario, como .onRecieve (), solo para trabajar con cada renderizado. </font><font style="vertical-align: inherit;">Y luego pens√©: despu√©s de todo, el cuerpo se llama para cada dibujo, entonces, ¬øpor qu√© no hacer esta verificaci√≥n directamente en √©l? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Result√≥ que SwiftUI jura mucho, si durante el proceso de renderizado la Vista cambia el valor de las </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables, da</font></font><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al modificar el estado durante la actualizaci√≥n de la vista, esto provocar√° un comportamiento indefinido.</font></font></blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y bloquea tal cambio. Luego busqu√© un truco sucio y us√© DispatchQueue.main.async. Pero veamos por qu√© este es un truco sucio, y ¬øpor qu√© esto nunca deber√≠a hacerse? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este es realmente el problema. Si escribimos dentro del cuerpo alguna estupidez obvia como i + = 1, donde i es alg√∫n tipo de</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable, entonces obtenemos un bucle infinito. En el momento de la representaci√≥n, hacemos que la Vista en la memoria no sea relevante, porque cambiamos los datos iniciales para la representaci√≥n. Esto significa que inmediatamente despu√©s de que se complete el renderizado, nuestra Vista se pondr√° en cola para volver a renderizar, pero incluso as√≠ lo volveremos a hacer irrelevante de inmediato. Creamos un ciclo interminable con nuestras propias manos. Una llamada asincr√≥nica en este caso no cambia nada. Solo cambia ligeramente el inicio de la siguiente ronda al momento "inmediatamente despu√©s de la renderizaci√≥n". Por lo tanto, una llamada asincr√≥nica no resuelve el problema, solo lo disfraza, evitando que SwiftUI nos toque con la nariz. Es como en un autom√≥vil que se apaga la bombilla de "revisar motor".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por un lado, ¬øqu√© hay de malo en eso? En cualquier lenguaje de programaci√≥n, hay muchas formas de dispararse en el pie si no entiende lo que est√° haciendo. Pero, por otro lado, este enfoque no es en absoluto c√≥mo deber√≠a funcionar SwiftUI. Trabajar con View en tiempo de ejecuci√≥n es malo. S√≠, puedes golpearte los talones en el cofre, asegur√°ndote de que siempre escribes el c√≥digo correcto que nunca terminar√° en un bucle sin fin ... Pero es como con una recuperaci√≥n insegura de una opci√≥n: es una mala pr√°ctica. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como dije, en tales casos, debe usar Combinar, pasando un nuevo valor usando PassthroughSubject. Pero puede sobrevivir con el ObservableObject habitual suscribi√©ndose a su evento willChange.</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AnimatedRectObservedObject</span>: <span class="hljs-title">View</span></span>{<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> startTime: <span class="hljs-type">Date</span> = <span class="hljs-type">Date</span>()<font></font>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> angle: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandlerTest</span>
    <span class="hljs-keyword">let</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandlerTest</span>){
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Rectangle</span>()<font></font>
                .fill(<span class="hljs-type">Color</span>.green)<font></font>
                .frame(width: <span class="hljs-number">200</span>, height: <span class="hljs-number">200</span>)<font></font>
                .rotationEffect(<span class="hljs-type">Angle</span>(degrees: angle))<font></font>
                .animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)<font></font>
       }.onReceive(animationHandler.objectWillChange){<font></font>
            <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
            <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                 <span class="hljs-keyword">let</span> timePassed = <span class="hljs-type">Date</span>().timeIntervalSince(<span class="hljs-keyword">self</span>.startTime)
                 <span class="hljs-keyword">let</span> fullSecondsPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(timePassed))
                 <span class="hljs-keyword">let</span> currentStage = timePassed - fullSecondsPassed
                 <span class="hljs-keyword">let</span> newAngle = <span class="hljs-keyword">self</span>.angle - <span class="hljs-number">90</span> + currentStage * <span class="hljs-number">90</span>
                withAnimation(.<span class="hljs-keyword">none</span>){<span class="hljs-comment">//not working:(((</span>
                 <span class="hljs-keyword">self</span>.angle = newAngle<font></font>
                }<font></font>
            }<span class="hljs-keyword">else</span> {
                 <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()
                 <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span><font></font>
             }<font></font>
        }<font></font>
       .onAppear{<font></font>
            <span class="hljs-keyword">self</span>.angle += <span class="hljs-number">90</span>
            <span class="hljs-keyword">self</span>.startTime = <span class="hljs-type">Date</span>()<font></font>
        }<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El punto controvertido aqu√≠ es el uso de los valores del objeto en s√≠ mismo en la suscripci√≥n a la notificaci√≥n de que el objeto solo se cambiar√°. </font><font style="vertical-align: inherit;">Hasta ahora, en mis ejemplos, tengo un objeto ya modificado. </font><font style="vertical-align: inherit;">Aparentemente, las notificaciones vienen con cierto retraso. </font><font style="vertical-align: inherit;">Pero no puedo garantizar que este sea siempre el caso, por lo tanto, le recomiendo usar las notificaciones didChange hechas por usted mismo o PassthroughSubject, pasando el nuevo valor a trav√©s de √©l.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wj/ou/nd/wjoundfihtxhnar7iucx7rrkvnm.gif"><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n Cambios de animaci√≥n</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como puede ver en el gif, la animaci√≥n no se detiene al instante. </font><font style="vertical-align: inherit;">Ella necesita algo de tiempo. </font><font style="vertical-align: inherit;">Esto se debe a que cuando asignamos un valor intermedio al √°ngulo, tambi√©n usamos cierta animaci√≥n, la predeterminada.</font></font><br>
<br>
<pre><code class="swift hljs">.animation(animationHandler.isStarted ? animation : .<span class="hljs-keyword">default</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esto lleva a un comportamiento inusual. </font><font style="vertical-align: inherit;">A pesar de la relativa simplicidad de todo lo que describo, un mont√≥n de matices de interacci√≥n permanecen bajo el cap√≥ para que la imagen siempre se vea suave, incluso si el programador descuidado no indic√≥ algo. </font><font style="vertical-align: inherit;">Por lo tanto, la animaci√≥n predeterminada es primavera. </font><font style="vertical-align: inherit;">Es m√°s adecuado para simular las leyes de la f√≠sica. </font><font style="vertical-align: inherit;">Y esta es una animaci√≥n bastante corta, de unos 0.2 segundos. </font><font style="vertical-align: inherit;">Si la animaci√≥n de la transici√≥n a un nuevo estado (el √°ngulo calculado e indicado por nosotros) no logra encajar perfectamente en los 0.2 segundos predeterminados para cambiar de la velocidad de animaci√≥n actual con una hermosa desaceleraci√≥n a una parada completa, SwiftUI agregar√° otro bucle de animaci√≥n sin fin, reproducida en la versi√≥n acelerada.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/z0/b0/so/z0b0soljlzjqudxhek_irdxgyoy.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para evitar esto, es suficiente no usar la animaci√≥n predeterminada. </font><font style="vertical-align: inherit;">Para el cuadro inferior, apagu√© la animaci√≥n de parada de rotaci√≥n de esta manera:</font></font><br>
<br>
<pre><code class="swift hljs">                
.animation(animationHandler.isStarted ? animation : <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0</span>))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O bien, puede calcular con mayor precisi√≥n el valor requerido del par√°metro en el momento de la detenci√≥n, pero para esto necesita no solo asumir aproximadamente el momento actual de la animaci√≥n, sino conocerlo exactamente. </font><font style="vertical-align: inherit;">Mostrar√© a continuaci√≥n c√≥mo hacer esto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El movimiento de varias olas en una animaci√≥n.</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De vuelta a la animaci√≥n del arco iris. </font><font style="vertical-align: inherit;">Entonces, tenemos las olas mismas, ense√±√©moslas a moverse. </font><font style="vertical-align: inherit;">Lo primero que me gustar√≠a hacer es ejecutar una animaci√≥n sin fin. </font><font style="vertical-align: inherit;">Decid√≠ hacerlo de esta manera: tendr√© una </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable responsable de la posici√≥n actual de la animaci√≥n. </font><font style="vertical-align: inherit;">En el estado 0, la primera ola ser√° al comienzo y la √∫ltima al final. </font><font style="vertical-align: inherit;">Las olas mismas se superpondr√°n. </font><font style="vertical-align: inherit;">Por lo tanto, la longitud de la parte visible de cada onda depender√° del n√∫mero de ondas. </font><font style="vertical-align: inherit;">Implement√© esto usando ZStack, que enumera todas las ondas, y mi propio modificador .wavePosition, dentro del cual calculo la posici√≥n actual de cada onda en el momento de la animaci√≥n, y el orden en que se superponen.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mucho c√≥digo</font></font></b>
                        <div class="spoiler_text"><pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpWavePosition</span>: <span class="hljs-title">AnimatableModifier</span> </span>{
    <span class="hljs-keyword">let</span> wave: <span class="hljs-type">WaveDescription</span>
    <span class="hljs-keyword">let</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    <span class="hljs-keyword">var</span> time: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">var</span> currentPosition: <span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
                <span class="hljs-keyword">self</span>.time = newValue
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)<font></font>
        }<font></font>
    }<font></font>
    <span class="hljs-keyword">init</span>(wave: <span class="hljs-type">WaveDescription</span>, time: <span class="hljs-type">CGFloat</span>, animationHandler: <span class="hljs-type">AnimationHandler</span>){
        <span class="hljs-keyword">self</span>.wave = wave
        <span class="hljs-keyword">self</span>.time = time
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-number">0</span><font></font>
    }<font></font>
    <font></font>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calculate</span><span class="hljs-params">(forWave: Int, ofWaves: Int, overTime: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{<font></font>
<font></font>
        <span class="hljs-keyword">let</span> time = overTime - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(overTime))
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(ofWaves)
        <span class="hljs-keyword">let</span> initialPosition = oneWaveWidth * <span class="hljs-type">CGFloat</span>(forWave)
        <span class="hljs-keyword">let</span> currentPosition = initialPosition + time
        <span class="hljs-keyword">let</span> fullRounds = <span class="hljs-type">Int</span>(currentPosition)
        <span class="hljs-keyword">var</span> result = currentPosition - <span class="hljs-type">CGFloat</span>(fullRounds)
        <span class="hljs-keyword">if</span> fullRounds &gt; <span class="hljs-number">0</span> &amp;&amp; result == <span class="hljs-number">0</span>{
            <span class="hljs-comment">// at the end of the round it should be 1, not 0</span>
            result = <span class="hljs-number">1</span><font></font>
        }<font></font>
 <span class="hljs-comment">//       print("wave \(forWave) in time \(overTime) was at position \(result)")</span>
        <span class="hljs-keyword">return</span> result<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">let</span> oneWaveWidth = <span class="hljs-type">CGFloat</span>(<span class="hljs-number">1</span>) / <span class="hljs-type">CGFloat</span>(wave.totalWavesCount)
        <span class="hljs-keyword">var</span> thisIsFirstWave = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> currentPosition &lt; oneWaveWidth{<font></font>
            thisIsFirstWave = <span class="hljs-literal">true</span><font></font>
        }<font></font>
        <span class="hljs-keyword">return</span>
            <span class="hljs-type">Group</span>{<font></font>
                content<font></font>
                            .offset(x: -wave.width + currentPosition * (wave.width +  wave.gradientLength),<font></font>
                            <span class="hljs-comment">//to watch how waves move uncoment this</span>
                           <span class="hljs-comment">// y: CGFloat(self.waveInd * 20))</span>
                        y:<span class="hljs-number">0</span>)<font></font>
                    .zIndex(-<span class="hljs-type">Double</span>(currentPosition))<font></font>
                    .transition(.identity)<font></font>
                    .animation(<span class="hljs-literal">nil</span>)<font></font>
<font></font>
                <span class="hljs-keyword">if</span> thisIsFirstWave{<font></font>
                    content<font></font>
                        .offset(x: wave.gradientLength, y: <span class="hljs-number">0</span>)<font></font>
                        .zIndex(-<span class="hljs-number">2</span>)<font></font>
                        .transition(.identity)<font></font>
                        .animation(<span class="hljs-literal">nil</span>)<font></font>
                }<font></font>
            }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">positionOfSharp</span><span class="hljs-params">(wave: WaveDescription, inTime: CGFloat, animationHandler: AnimationHandler)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.modifier(<span class="hljs-type">SharpWavePosition</span>(wave: wave, time: inTime, animationHandler: animationHandler))<font></font>
    }<font></font>
}<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SharpRainbowView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> waves: [<span class="hljs-type">SharpGradientBorder</span>]
    <span class="hljs-keyword">var</span> animation: <span class="hljs-type">Animation</span> = <span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">1</span>).repeatForever(autoreverses: <span class="hljs-literal">false</span>)
    <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> rainbowPosition: <span class="hljs-type">CGFloat</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(animationHandler: <span class="hljs-type">AnimationHandler</span>,<font></font>
        backgroundColor: <span class="hljs-type">Color</span> = .clear<font></font>
    ){<font></font>
        <span class="hljs-keyword">self</span>.animationHandler = animationHandler
        <span class="hljs-keyword">let</span> bottomRadius = animationHandler.waveGeometry.bottomRadius
        <span class="hljs-keyword">let</span> topRadius = animationHandler.waveGeometry.topRadius
        <span class="hljs-keyword">let</span> gradientLength = animationHandler.waveGeometry.gradientLength
        <span class="hljs-keyword">let</span> rainbowColors = animationHandler.rainbowColors
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">var</span> lastColor = rainbowColors.last <span class="hljs-keyword">else</span> {<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"no colors to display in rainbow"</span>)}
        <span class="hljs-keyword">var</span> allWaves = [<span class="hljs-type">SharpGradientBorder</span>]()
        <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> rainbowColors{
            <span class="hljs-keyword">let</span> view = <span class="hljs-type">SharpGradientBorder</span>(start: color,<font></font>
                                      end: lastColor,<font></font>
                                      bottomRadius: bottomRadius,<font></font>
                                      topRadius: topRadius,<font></font>
                                      gradientLength: gradientLength)<font></font>
            allWaves.append(view)<font></font>
            lastColor = color<font></font>
        }<font></font>
        <span class="hljs-keyword">self</span>.waves = allWaves<font></font>
    }<font></font>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">GeometryReader</span>{geometry <span class="hljs-keyword">in</span>
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">ZStack</span>{
                    <span class="hljs-type">ForEach</span>(<span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">indices</span>, id: \.<span class="hljs-keyword">self</span>){ind <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">self</span>.waves[ind]<font></font>
                            .positionOfSharp(wave: <span class="hljs-type">WaveDescription</span>(ind: ind,<font></font>
                                                    totalWavesCount: <span class="hljs-keyword">self</span>.waves.<span class="hljs-built_in">count</span>,<font></font>
                                                    width: geometry.size.width,<font></font>
                                                    baseColor: <span class="hljs-keyword">self</span>.waves[ind].end,<font></font>
                                                    gradientLength: <span class="hljs-keyword">self</span>.waves[ind].bottomRadius + <span class="hljs-keyword">self</span>.waves[ind].topRadius),<font></font>
                                             inTime: <span class="hljs-keyword">self</span>.rainbowPosition,<font></font>
                                             animationHandler: <span class="hljs-keyword">self</span>.animationHandler)<font></font>
                            .animation(<span class="hljs-keyword">self</span>.animationHandler.isStarted ? <span class="hljs-keyword">self</span>.animation : .linear(duration: <span class="hljs-number">0</span>))<font></font>
                    }<font></font>
                }<font></font>
     <span class="hljs-comment">//           .clipped()</span><font></font>
            }<font></font>
<font></font>
        }<font></font>
        .onAppear(){<font></font>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.rainbowPosition = <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
        .onReceive(animationHandler.objectWillChange){<font></font>
             <span class="hljs-keyword">let</span> newValue = <span class="hljs-keyword">self</span>.animationHandler.isStarted
             <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">false</span>{
                <span class="hljs-keyword">let</span> newPosition = <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"animated from \(self.rainbowPosition - 1) to \(self.rainbowPosition) stopped at \(newPosition)"</span>)
                    <span class="hljs-keyword">self</span>.rainbowPosition = newPosition<font></font>
             }<span class="hljs-keyword">else</span> {
                  <span class="hljs-keyword">self</span>.rainbowPosition += <span class="hljs-number">1</span><font></font>
            }<font></font>
        }<font></font>
    }<font></font>
}<font></font>
 </code></pre><br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La primera vez que se muestra la Vista en la pantalla, cambiamos el estado de 0 a 1, lo que, teniendo en cuenta la animaci√≥n lineal declarada, hace que las ondas corran sin cesar por la pantalla. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bg/vr/ym/bgvrymyoubpekjmpgnsrtxxgco8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cuando el borde de la onda alcanza el borde derecho, su pr√≥xima posici√≥n ser√° al principio, m√°s all√° del borde de la pantalla. Se ver√° como si simplemente desapareciera del final de la ola, exponiendo el sustrato de fondo, lo que nos gustar√≠a evitar. Para este prop√≥sito, el bloque if {...} apareci√≥ en el modificador, en la funci√≥n body (), en la que se dibuja una copia de la primera onda que falta en la pantalla.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/si/6m/vt/si6mvtiimlv73kxy4c4imperxc4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tenga en cuenta que tuve que transferir las caracter√≠sticas geom√©tricas de cada onda en forma de par√°metros modificadores. </font><font style="vertical-align: inherit;">El problema era que necesitaba redefinir el √≠ndice z de cada onda en funci√≥n de la fase de animaci√≥n actual. </font><font style="vertical-align: inherit;">Pude extraer el ancho de la regi√≥n visible usando el modificador GeometryReader {} dentro, sin embargo, me enfrent√© al hecho de que bloquea el cambio en el orden de las ondas. </font><font style="vertical-align: inherit;">El modificador .zIndex () funciona solo en el contexto del primer contenedor ZStack {} en la jerarqu√≠a de Vista. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
GeometryReader corta esta conexi√≥n y zIndex () deja de funcionar. </font><font style="vertical-align: inherit;">Si hasta este momento cre√≠a que GeometryReader es una forma inofensiva de obtener datos sobre el tama√±o de la Vista actual, esto no es del todo cierto.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Animaci√≥n de flujo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Otro punto importante es comprender la animaci√≥n de los modificadores integrados dentro de sus propios modificadores. En alg√∫n momento, cada onda se acerca al borde de la pantalla, obteniendo el desplazamiento horizontal m√°ximo, y luego va a la posici√≥n inicial, obteniendo el desplazamiento m√≠nimo. Este es el mismo cambio que cualquier otro, y est√° animado, incluso dentro de la animaci√≥n. Despu√©s de todo, la animaci√≥n es solo una transferencia muy frecuente de valores al modificador, y tambi√©n se realizar√° con animaci√≥n, sin importar cu√°n extra√±o suene. Resulta que dentro de la animaci√≥n, al pasar un nuevo valor dentro de este modificador, solo cambiamos el punto final de la animaci√≥n de movimiento actual. Resulta que cada ola, que llega al borde de la pantalla, se da vuelta y flota hacia atr√°s. Pero tampoco alcanza el inicio, pero tarde o temprano se est√° poniendo al d√≠a con la posici√≥n requerida,y luego comienza a moverse de izquierda a derecha nuevamente.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/aj/xp/ky/ajxpkyp6nxn-e6ixzzrv7y-g-c4.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Puede resolver este problema insertando el modificador .animation (nil). Por lo tanto, apago la animaci√≥n de todos los modificadores aplicados anteriormente en el texto. Esta es la l√≥gica general del trabajo de cualquier modificador: cambia lo que est√° en su entrada, y en la entrada tenemos el resultado de todos los modificadores anteriores.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En t√©rminos generales, aqu√≠ funciona una jerarqu√≠a completa de diferentes animaciones. El valor predeterminado es el que se usar√° para mostrar los cambios en todos los modificadores, a menos que especifique lo contrario para su Vista. Tenemos un hilo de ejecuci√≥n (digamos que esto es principal), dentro del cual se llama al cuerpo. Suponemos que tiene el par√°metro .animation, que se verifica cada vez que un modificador recibe un nuevo valor. Si el modificador admite animaci√≥n (cumple con el protocolo AnimatableModifier) ‚Äã‚Äãy la animaci√≥n est√° habilitada para la transmisi√≥n (se utiliza alguna animaci√≥n espec√≠fica, no .none o nil), entonces el cambio ser√° animado. Esto es lo que hacemos, adjuntando un c√≥digo para cambiar los </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par√°metros en el bloque withAnimation {}: prescribimos una cierta animaci√≥n en el hilo actual, y luego hacemos alg√∫n tipo de cambio</font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. En este caso, conAnimation {}, este es un tipo de transacci√≥n equivalente, y todos los cambios realizados en esta transacci√≥n ser√°n animados. Como resultado, dentro de la misma secuencia, se inicia un ciclo de traducci√≥n de estos cambios a todas las vistas dependientes, los modificadores de estas vistas obtienen un nuevo valor y se suscriben para recibir valores intermedios de AnimatableData. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, hay elementos en la animaci√≥n sobre los que no puede influir. Por ejemplo, la posici√≥n del control deslizante est√° animada por s√≠ misma, por mecanismos internos, y no hay nada que hacer al respecto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, withAnimation () es una forma de iniciar la animaci√≥n predeterminada para la acci√≥n que se realiza. Pero para ciertas Vistas, puede especificar expl√≠citamente su propia animaci√≥n usando el modificador .animation (). En este caso, los modificadores y las formas que componen el contenido pasado a .animation () (todo lo que aparece en el c√≥digo antes de aplicar .animation ()) reciben el tiempo que describe e ignoran la animaci√≥n de la secuencia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En mi modificador WavePosition, utilizo .animation (nil) para deshacerme de la animaci√≥n de desplazamiento incorporada, lo que indica que ignore la animaci√≥n de flujo actual.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La misma historia con la tapa final. D√©jame recordarte las conclusiones del √∫ltimo art√≠culo. De hecho, tenemos estructuras modificadoras de N WavePosition en nuestra memoria, una para cada onda. Y todos obtienen un nuevo valor de posici√≥n del temporizador del sistema, calculando la posici√≥n de cada onda en un punto dado en el tiempo. Esto significa que tambi√©n tenemos N tapas de extremo para cada onda. Es solo que solo se muestra uno de ellos en un momento dado, gracias al bloque if {}. Sin embargo, el mismo bloque nos pone un cerdo. La desaparici√≥n y aparici√≥n de la Vista tambi√©n se realiza con la animaci√≥n de la secuencia. Esto significa que el modificador .transition se usa para animar la apariencia y desaparici√≥n de la Vista despu√©s de cambiar la condici√≥n. Por lo general, .opacity se usa por defecto, sin embargo, por alguna raz√≥n .slide se us√≥ en mi lugar. Ninguno de los dos me conviene, as√≠ que acabo de cancelar esta animaci√≥n,utilizando .transition (.identity).</font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">upd </font><font style="vertical-align: inherit;">Mientras preparaba el art√≠culo, sali√≥ Xcode 11.4, en el que, al parecer, la transici√≥n se modific√≥ por defecto. </font><font style="vertical-align: inherit;">Al menos ahora coment√© .transition (.identity) sin ning√∫n problema y no recib√≠ el problema que me hizo agregarlo.</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiempos de animaci√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y ahora finalmente llegamos a la pregunta m√°s interesante: ¬øc√≥mo hacer que las olas se muevan aceleradamente? </font><font style="vertical-align: inherit;">Como siempre, vendr√© desde muy lejos.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En realidad, la animaci√≥n es una descripci√≥n de la velocidad de una animaci√≥n dada. Podemos determinar la ruta desde el punto A al punto B dentro del modificador en s√≠, pero SwiftUI decide cu√°ndo y qu√© tipo de valor AnimatableData pasarle. Lo hace con una curva de tiempo. Supongamos que tomamos el punto A como origen y marcamos el punto B como un punto con coordenadas (1; 1). Horizontal marcaremos el tiempo transcurrido (el movimiento desde el punto A al punto B toma exactamente 1 unidad de tiempo). Vertical: la distancia recorrida en fracciones de una unidad. Cuando se usa animaci√≥n lineal, nos ponemos directos. Si queremos que el movimiento sea un poco similar al presente, primero debemos dedicar un poco de tiempo a la aceleraci√≥n y, al final, al frenado. Justo </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Puede jugar con diferentes opciones dibujando su propia curva y comparando su animaci√≥n de movimiento con las est√°ndar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En SwiftUI, las curvas de Bezier se usan para varios tipos de animaci√≥n. </font><font style="vertical-align: inherit;">En cualquier caso, debe comenzar en (0; 0) y finalizar en (1; 1). </font><font style="vertical-align: inherit;">La curvatura de la l√≠nea est√° determinada por los puntos de control.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Curva de tiempo anidada dentro de la animaci√≥n lineal sin fin</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Entonces, ¬øqu√© necesitamos hacer para lograr el movimiento acelerado de cada onda (easeIn) dentro de una animaci√≥n lineal en bucle? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La opci√≥n m√°s desglosada que se me ocurri√≥ fue implementar mi propia curva de tiempo y convertir el flujo lineal de tiempo en una especie de .easeIn. </font><font style="vertical-align: inherit;">Con este ejemplo, puedes entender muy bien c√≥mo funciona esto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea es simple. Haremos nuestra propia clase, basada en la ruta: la curva de Bezier con la que determinaremos la distancia desde el punto A al punto B, que debe mostrarse en cada punto espec√≠fico en el tiempo. De hecho, as√≠ es exactamente c√≥mo funciona la animaci√≥n en SwiftUI y en cualquier otro marco con una funcionalidad similar. Con la ayuda de la curva de tiempo, los segundos reales y los milisegundos (que fluyen con mayor frecuencia, sin embargo, linealmente) se convierten en fracciones de la distancia (m√°s precisamente, fracciones del segmento animado, el vector AnimatableData, que representa el cambio realizado). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqu√≠ est√° mi primera implementaci√≥n:</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActualPosition</span><span class="hljs-params">(of position: CGFloat)</span></span> -&gt; <span class="hljs-type">CGFloat</span>{
        <span class="hljs-keyword">let</span> correctPosition = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(position, <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) / duration
        <span class="hljs-keyword">let</span> trimmingCurve = <span class="hljs-type">TimingCurve</span>.superEaseInPath
        <span class="hljs-keyword">if</span> correctPosition &lt; <span class="hljs-number">0.0000001</span>{
            <span class="hljs-keyword">let</span> reversedCurve = <span class="hljs-type">Path</span>(<span class="hljs-type">UIBezierPath</span>(cgPath: trimmingCurve.cgPath).reversing().cgPath)
            <span class="hljs-comment">//trim to start point is impossible, so reverce the curve and get last point</span>
            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = reversedCurve.currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve start point"</span>)}
            <span class="hljs-keyword">return</span> point.y<font></font>
        }<font></font>
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> point = trimmingCurve.trimmedPath(from: <span class="hljs-number">0</span>, to: correctPosition).currentPoint <span class="hljs-keyword">else</span>{<span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"cant get current timing curve point at \(position)"</span>)}
        <span class="hljs-keyword">return</span> point.y * <span class="hljs-keyword">self</span>.duration<font></font>
    }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aparentemente, era un poco tonto. Por definici√≥n, tengo que encontrar un punto en la curva correspondiente a un valor X dado y devolverlo a Y. No pude encontrar ning√∫n m√©todo incorporado est√°ndar para resolver este problema, o un patr√≥n popular, as√≠ que decid√≠ adaptar el m√©todo de recorte existente ( ) Decid√≠ que podr√≠a muy bien reconsiderar el enfoque y obtener el punto deseado al obtener la parte de la ruta correspondiente a la fracci√≥n de la distancia recorrida. Para cero, este m√©todo devolver√° 0, para 1 devolver√° 1, bueno, en el medio, probablemente, todo tambi√©n ser√° aproximadamente correcto.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sab√≠a que este enfoque no dar√≠a un resultado muy preciso, sin embargo, la gravedad del problema surgi√≥ m√°s tarde cuando intent√© reproducir exactamente la misma animaci√≥n de una manera est√°ndar. Me sorprendi√≥ lo diferente que es, y decid√≠ verificar en el gr√°fico qu√© tan lejos estar√°n los puntos obtenidos de esta forma de la curva original. El resultado no me gust√≥. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/fl/ed/s-/fleds-cdj4f8ellnui32gn-kiyk.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No solo los puntos est√°n lejos de la curva deseada, sino que la naturaleza misma de la curva est√° distorsionada. Hay una torcedura adicional, que no necesito en absoluto. Como resultado, todav√≠a ten√≠a que encontrar una forma relativamente precisa de encontrar un punto en una curva de Bezier, conociendo solo una coordenada:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tuve que almacenar en la memoria muchos segmentos, cuyos extremos se encuentran en una curva dada. Una b√∫squeda de Y por una X dada con este enfoque es una b√∫squeda del segmento correspondiente, su divisi√≥n a la mitad, si es necesario, hasta que uno de los l√≠mites de dicho segmento se encuentre lo suficientemente cerca del punto deseado. En este caso, encontramos el punto con la coordenada X requerida en este segmento y lo devolvemos Y. Si conoce formas m√°s simples de encontrar un punto en una curva de Bezier arbitraria, utilizando una coordenada dada, escriba los comentarios. Creo que puede ser √∫til para muchos. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como resultado, los puntos est√°n bastante cerca del gr√°fico:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wx/bk/qi/wxbkqitda0fmf516tl1vjarqgoq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hice un objeto Singlton para crear una curva de tiempo para los puntos de control y almacenar en cach√© la matriz de segmentos con los que se busca Y. Por lo tanto, todo lo que necesito para encontrar un punto espec√≠fico en la curva es encontrar el segmento dentro del cual se ubicar√° este punto, dividirlo en mitades hasta que uno de los extremos del segmento est√© lo suficientemente cerca de este punto como para caer en un error dado, y luego interpolar linealmente el valor de Y sobre la X dada, reemplazando parte de la curva por este segmento. No afirmo que esta sea la mejor manera, y que funcionar√° en todos los casos. Nuevamente, escriba en los comentarios si conoce mejores formas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Con la ayuda de dicha herramienta, la transformaci√≥n de la animaci√≥n lineal en no lineal se vuelve simple. </font><font style="vertical-align: inherit;">Todo lo que se necesita es describir la curva mediante dos puntos de control y volver a calcular la posici√≥n en el segmento de acuerdo con esta curva. </font><font style="vertical-align: inherit;">Si se requiere animaci√≥n de varias duraciones, todav√≠a usamos una curva unitaria usando el coeficiente apropiado para la coordenada X.</font></font><br>
<br>
<pre><code class="swift hljs">        
<span class="hljs-keyword">self</span>.timing = <span class="hljs-type">TimingCurve</span>.superEaseIn(duration: <span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> animatedPosition = timing.getY(onX: currentPosition)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As√≠ es como se ve la animaci√≥n, junto con nuestra curva de tiempo: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/vf/f0/fe/vff0fe07bgvlvqhhuok5vy_w8ga.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
para ver el c√≥digo completo, bienvenido al </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mire el archivo TimingCurveView. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Habiendo entendido este ejemplo, comprender√° al 100% c√≥mo se organizan los tiempos de animaci√≥n. </font><font style="vertical-align: inherit;">Por cierto, puede usar este conocimiento, porque SwiftUI le permite crear su propia curva de tiempo para los puntos de control usando la funci√≥n timingCurve (), y usarla como cualquier otra animaci√≥n.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transici√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ahora, tenemos una animaci√≥n infinita tolerable. Solo queda descubrir c√≥mo deber√≠a encenderse y apagarse. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La idea de animar la apariencia es hacer que el bloque de animaci√≥n simplemente aparezca en el lugar ya encendido, pero la cortina se retirar√≠a, como una cortina en el teatro. Si sincronizamos la velocidad de la cortina con la velocidad de las ondas dentro de la animaci√≥n, y en la cortina misma hacemos un gradiente del color de fondo al color de la onda incidente actual, obtenemos un efecto visual, como si esta cortina fuera la primera ola rodante. Para sincronizar la velocidad de movimiento, simplemente utilizamos la misma curva de sincronizaci√≥n que para animar el movimiento de la onda. Afortunadamente, ahora sabemos c√≥mo hacer esto.</font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-keyword">let</span> animation = <span class="hljs-type">Animation</span>.timingCurve(<span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point1.y),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.x),
                                <span class="hljs-type">Double</span>(<span class="hljs-type">TimingCurve</span>.control.point2.y),<font></font>
                                duration: <span class="hljs-number">1</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Animation.timingCurve (x: y :) le permite establecer su propio tiempo de animaci√≥n en funci√≥n de los puntos de control de las curvas de Bezier. </font><font style="vertical-align: inherit;">En la salida, obtenemos un objeto de animaci√≥n completo, como el familiar .linear (duraci√≥n: 1), que puede usarse sin restricciones. </font><font style="vertical-align: inherit;">Y teniendo en cuenta que uso exactamente los mismos puntos de control para la animaci√≥n de onda, la animaci√≥n ser√° sincr√≥nica.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ser√≠a m√°s conveniente organizar el c√≥digo ...</font></font></b>
                        <div class="spoiler_text">   .<br>
<br>
 ,           ,    ,          ‚Ä¶     ,     ,     .  -  ,        ‚Äî    .<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La desactivaci√≥n de la animaci√≥n se puede hacer de la misma manera, solo la cortina debe arrastrarse sobre el bloque de animaci√≥n, cerr√°ndolo gradualmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
El primer problema surgi√≥ en el momento en que necesitaba obtener el estado actual de la animaci√≥n para elegir el color de la cortina. </font><font style="vertical-align: inherit;">Para hacer esto, cre√© un ObservableObject, que paso dentro del modificador y que cambio dentro del configurador AnimatableData. </font><font style="vertical-align: inherit;">Es importante comprender aqu√≠ que cambiar la propiedad @Published 60 veces por segundo no es en absoluto lo que necesita. </font><font style="vertical-align: inherit;">As√≠ es como se cambian las </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables dentro de un bloque corporal. </font><font style="vertical-align: inherit;">No necesitamos iniciar nada cuando cambia el estado de la animaci√≥n. </font><font style="vertical-align: inherit;">Pero si es necesario, podemos averiguar el estado de la animaci√≥n en cualquier momento.</font></font><br>
<br>
<pre><code class="swift hljs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> animatableData: <span class="hljs-type">CGFloat</span> {
        <span class="hljs-keyword">get</span> { time}
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">if</span> animationHandler.isStarted{
                <span class="hljs-keyword">self</span>.time = newValue
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.time != <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition{
                    <span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition = <span class="hljs-keyword">self</span>.time<font></font>
                }<font></font>
            }<font></font>
            <span class="hljs-keyword">let</span> currentTime = newValue - <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>(newValue))
            <span class="hljs-keyword">self</span>.currentPosition = <span class="hljs-type">SharpWavePosition</span>.calculate(forWave: wave.ind, ofWaves: wave.totalWavesCount, overTime: currentTime)
            <span class="hljs-keyword">if</span> currentPosition &lt; <span class="hljs-number">0.01</span>{<font></font>
                animationHandler.currentWaveBaseColor = wave.baseColor<font></font>
            }<font></font>
        }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Es por eso que no me registr√© SharpRainbowView para rastrear los cambios de AnimationHendler: </font></font><br>
<br>
<pre><code class="swift hljs">   <span class="hljs-comment">//@ObservedObject</span>
    <span class="hljs-keyword">var</span> animationHandler: <span class="hljs-type">AnimationHandler</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para ilustrar el funcionamiento de estas cortinas, activar√© la visualizaci√≥n de lo que est√° sucediendo fuera de la Vista comentando .clipped (). Adem√°s, mover√© la cortina ligeramente por encima de la animaci√≥n, para mayor claridad. Ahora est√° m√°s claro, ¬øno? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/uf/0k/6suf0klfghhgxj95qfnrxd29zpe.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Las cortinas ten√≠an que ser cortas para que el camino recorrido por cada ola y cortina coincidiera (de lo contrario resultar√≠a una animaci√≥n asincr√≥nica), pero al mismo tiempo, logr√≥ desaparecer por completo de la pantalla. Al mismo tiempo, la cortina est√° dispuesta como un degradado de tres colores. Esto es claramente visible en la cortina de cierre. Esto se debe a las largas colas que me gustaron tanto al principio.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La cuesti√≥n es que la primera onda es el gradiente de los √∫ltimos y primeros colores de la matriz transmitida. Ninguno de ellos puede coincidir con el color de fondo. Por lo tanto, hab√≠a una necesidad de cortinas en general. Para hacer que la cortina sea de dos tonos, desde el color de fondo hasta el color base de la primera ola, la longitud de la cortina me lo impidi√≥. Simplemente no se superpone a la larga cola de la primera ola, y se obtiene un borde de un color y la cola de otro. Por lo tanto, tuve que hacer que la cortina tuviera tres colores: primero del fondo al color de la √∫ltima ola, y luego del color de la √∫ltima ola a la primera. Entonces la cola de la primera ola encaja bien con el borde de la cortina.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por casi las mismas razones, hicieron que la cortina de cierre tambi√©n fuera tricolor. De lo contrario, la frontera no parec√≠a natural. Pero como resultado, la primera "ola" (y ahora sabemos que esta es realmente la cortina descrita en Transition.truncate) result√≥ ser corta. Y aunque se mueve completamente sincr√≥nicamente con la primera ola, es decir acelerado, y no lineal, su ancho no cambia con el tiempo, aunque el ancho de las ondas posteriores aumenta visualmente. Esto puede ser derrotado cambiando din√°micamente el ancho de la cortina, pero yo era francamente vago. Consideremos esto como tarea para aquellos que quieren sumergirse en estos mecanismos y fumar un c√≥digo (pido disculpas a esas personas de antemano, hay muchos rastros de mis experimentos que pueden confundirlo).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Hay un problema </font><font style="vertical-align: inherit;">Si presiona el bot√≥n en un momento sin √©xito, la cortina de cierre apenas cubrir√° la pr√≥xima ola. </font><font style="vertical-align: inherit;">No se ve muy bien. </font><font style="vertical-align: inherit;">Puede resolver el problema introduciendo un ligero retraso en ocultar la vista con animaci√≥n. </font><font style="vertical-align: inherit;">Tenemos una manera de averiguar la posici√≥n actual de la animaci√≥n, solo necesitamos posponer un poco el comienzo de la transici√≥n, y la √∫ltima ola siempre se mostrar√° por completo.</font></font><br>
<br>
<pre><code class="swift hljs">    <span class="hljs-type">Text</span>(<span class="hljs-string">"toggle animation"</span>).onTapGesture {<font></font>
                withAnimation(){<font></font>
                    <span class="hljs-keyword">var</span> delay: <span class="hljs-type">Double</span> = <span class="hljs-number">0</span>
                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShown{
                        <span class="hljs-keyword">let</span> waveChangeTime: <span class="hljs-type">Double</span> = <span class="hljs-type">Double</span>(<span class="hljs-number">1</span>) /  <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.rainbowColors.<span class="hljs-built_in">count</span>)
                        <span class="hljs-keyword">let</span> currentTime = <span class="hljs-type">Double</span>(<span class="hljs-keyword">self</span>.animationHandler.currentAnimationPosition)
                        <span class="hljs-keyword">let</span> wavesPassed = <span class="hljs-type">Double</span>(<span class="hljs-type">Int</span>(currentTime / waveChangeTime))<font></font>
                        delay =  (wavesPassed + <span class="hljs-number">1</span>) * waveChangeTime - currentTime<font></font>
                        delay = <span class="hljs-built_in">max</span>(delay - <span class="hljs-number">0.05</span>, <span class="hljs-number">0</span>)
                        <span class="hljs-built_in">print</span>(<span class="hljs-string">"currentTime: \(currentTime); delay \(delay)"</span>)<font></font>
                    }<font></font>
                    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + delay) {
                        <span class="hljs-keyword">self</span>.isShown.toggle()<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por supuesto, tambi√©n puede hacer la cortina de ancho variable para crear la ilusi√≥n de diferentes velocidades del borde entre el fondo y la cortina, y la cortina y la primera ola, pero ahora la primera ola parece un poco antinatural, pero ya soy demasiado vago para molestarme.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transition ama forrar a un cerdo</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En general, las animaciones de aparici√≥n y desaparici√≥n, para m√≠, son una herramienta genial. Pero parece que este concepto es nuevo, y no todas las herramientas lo manejan normalmente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por lo tanto, el modificador .rotation3DEffect () invierte con √©xito la vista con algunas animaciones complejas en su interior, pero no sabe c√≥mo invertir .transition. Fue muy decepcionante escribir un c√≥digo conciso, ver c√≥mo sus ondas se dispersan desde el centro de la pantalla y luego ver que a la izquierda Ver las cortinas corren de izquierda a derecha. Tuve que escribir un mont√≥n de repeticiones, para que el modificador de transici√≥n pudiera funcionar en ambas direcciones.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/pn/3c/fg/pn3cfg8f6zsersnfgdv5_ixrqu8.gif"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adem√°s, el modificador drowingGroup (), con el que puede conectar Metal para transferir a la GPU una representaci√≥n ZStack con una gran cantidad de Vista anidada, especialmente Vista con degradados, no sabe c√≥mo hacer la transici√≥n. </font><font style="vertical-align: inherit;">√âl no entiende la animaci√≥n de aparici√≥n y desaparici√≥n descrita por usted y la reemplaza con algunas de las suyas.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øPero c√≥mo ocultamos la barra de estado?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Muy simple. SwiftUI tiene el modificador .statisBar (oculto :). Estas son solo las API para controlar la transici√≥n de la barra de estado que SwiftUI no proporciona. Para hacer esto, tendremos que aprovechar las capacidades de UIKit. El archivo SceneDelegate utiliza UIHostingController para convertir SwiftUI View en un UIKit ViewController. Es en esta etapa que es m√°s conveniente usar algunas funciones UIKit globales, como trabajar con la barra de estado o deshabilitar los gestos del sistema asociados con el borde de la pantalla (preferiblementeScreenEdgesDeferringSystemGestures). Puede heredar de UIHostingController anulando los valores de algunas propiedades del sistema, y ‚Äã‚Äãuse este descendiente para pasar su Vista a rootViewController. Desafortunadamente, solo un n√∫mero limitado de transiciones puede aceptar una barra de estado: .fade, .slide y .none. El valor predeterminado es fade,y encaja mejor aqu√≠, as√≠ que vamos a dejarlo como est√°. Esperemos que esta funcionalidad se siga ampliando.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para sincronizar la ocultaci√≥n y la apariencia de la barra de estado con el movimiento de la onda, cre√© una Vista separada, dentro de la cual cambio el valor de este par√°metro con una pausa:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarHider</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> isShown: <span class="hljs-type">Bool</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> internalIsShown = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">false</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">true</span>{
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.7</span>){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> isShown == <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-keyword">self</span>.internalIsShown == <span class="hljs-literal">false</span>{
            <span class="hljs-type">DispatchQueue</span>.main.async(){
                <span class="hljs-keyword">self</span>.internalIsShown = <span class="hljs-keyword">self</span>.isShown<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-type">Spacer</span>()<font></font>
            .statusBar(hidden: internalIsShown)<font></font>
            .animation(<span class="hljs-type">Animation</span>.linear(duration: <span class="hljs-number">0.3</span>))<font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, aqu√≠ se forma un simple Spacer (), que ya necesitaba, pero el modificador statusBar est√° enrollado encima. En general, por supuesto, era il√≥gico que Apple enviara esta funcionalidad a modificadores, como esto no se aplica a la Vista espec√≠fica que est√° modificando, pero aparentemente no descubri√≥ c√≥mo hacerlo mejor. Mucho m√°s interesante es otro. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Utiliza el mismo truco sucio que consideramos anteriormente: dentro del cuerpo, realizo algunas acciones en tiempo de ejecuci√≥n, mientras cambio el valor de la </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable. La l√≥gica en su conjunto es la misma, hay un par√°metro de estructura que se transmite desde el exterior y una </font></font><code>@State</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variable que se modifica despu√©s de un tiempo, lo que hace que la barra de estado desaparezca o aparezca.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En este caso, necesitaba este truco porque controlar la animaci√≥n de la barra de estado es una funci√≥n UIKit que todav√≠a est√° bastante mal desarrollada en SwiftUI. </font><font style="vertical-align: inherit;">En teor√≠a, me gustar√≠a atornillar la animaci√≥n de inicio diferido al modificador .statusBar (oculto :), pero esto no funciona. </font><font style="vertical-align: inherit;">La animaci√≥n de ocultaci√≥n y la apariencia de la barra de estado son fijas y SwiftUI no puede cambiarlas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De hecho, nada me impidi√≥ hacer el mismo cambio de forma asincr√≥nica con el retraso deseado, no dentro de esta Vista, sino en el padre, incluso cuando el usuario hizo clic en el bot√≥n, pero dejemos esto como un monumento a mis intentos de descubrir qu√© es qu√© (y una raz√≥n m√°s para contar que esto no se debe hacer).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬øY c√≥mo se introdujo el tama√±o y la posici√≥n de la barra de estado en @Environment?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
@Environment (que no debe confundirse con @EnvironmentObject) es un contenedor que da acceso a una lista fija de variables que reflejan el entorno de nuestra aplicaci√≥n. Por ejemplo, orientaci√≥n de la pantalla o tema de color del sistema operativo. El mismo contenedor permite que su vista se suscriba para cambiar estos par√°metros. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esta lista se puede ampliar. Pens√© que tener @Environment ten√≠a acceso al tama√±o y la posici√≥n de la barra de estado ser√≠a correcto. As√≠ es como lo hice:</font></font><br>
<br>
<pre><code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StatusBarFrame</span>: <span class="hljs-title">EnvironmentKey</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> defaultValue: <span class="hljs-type">CGRect</span> {
        <span class="hljs-type">CGRect</span>()<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">EnvironmentValues</span> </span>{
    <span class="hljs-keyword">var</span> statusBarFrame: <span class="hljs-type">CGRect</span>{
        <span class="hljs-keyword">get</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>]<font></font>
        }<font></font>
        <span class="hljs-keyword">set</span> {
            <span class="hljs-keyword">self</span>[<span class="hljs-type">StatusBarFrame</span>.<span class="hljs-keyword">self</span>] = newValue<font></font>
        }<font></font>
    }<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cre√© una estructura con un valor predeterminado est√°tico. </font><font style="vertical-align: inherit;">Luego, expand√≠ la estructura del sistema SystemValues ‚Äã‚Äãagregando mi propia propiedad calculada, cuyo captador y definidor se refieren al tipo que cre√©. </font><font style="vertical-align: inherit;">El tipo se usa aqu√≠, porque EnvironmentValues ‚Äã‚Äãimplementa un sub√≠ndice en el que pasa el tipo y obtiene el valor almacenado correspondiente a este tipo. </font><font style="vertical-align: inherit;">No es el valor de este tipo, sino el valor almacenado en el diccionario condicional, donde el tipo en s√≠ es la clave. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se accede al valor en @Environment usando keyPath \ .statusBarFrame. </font><font style="vertical-align: inherit;">Por ejemplo, para pasar el valor del entorno a todas las vistas de la jerarqu√≠a:</font></font><br>
<br>
<pre><code class="swift hljs">.environment(\.statusBarFrame, statusBarFrame) 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Y en la Vista en s√≠ para recuperar el valor de la tienda:</font></font><br>
<br>
<pre><code class="swift hljs">@<span class="hljs-type">Environment</span>(\.statusBarFrame) <span class="hljs-keyword">var</span> statusBarframe: <span class="hljs-type">CGRect</span> 
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por cierto, para trabajar con la barra de estado en el objeto UIWindowScene en IOS 13, ha aparecido el atributo statusBarManager. </font><font style="vertical-align: inherit;">Algunos par√°metros se pueden extraer de √©l. </font><font style="vertical-align: inherit;">Pero ahora no puedes gestionarlos. </font><font style="vertical-align: inherit;">Seg√∫n tengo entendido, antes era posible acceder a la barra de estado de ViewController y agregarle una subvista. </font><font style="vertical-align: inherit;">Aparentemente, cerraron el banco. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En t√©rminos generales, transferir√≠a la funcionalidad del modificador .statusBar (oculto :) exactamente aqu√≠, aqu√≠ ser√≠a m√°s apropiado, en cuanto a m√≠. </font><font style="vertical-align: inherit;">Creo que tarde o temprano, los desarrolladores llegar√°n a este punto.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusi√≥n</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bueno, creo que en este ejemplo fascinante, una excursi√≥n a la animaci√≥n usando las herramientas SwiftUI puede considerarse completa. Utilizando ejemplos simples, habl√© sobre las herramientas b√°sicas de animaci√≥n, dije c√≥mo funcionan exactamente bajo el cap√≥, c√≥mo deber√≠an usarse y por qu√© exactamente. Usando ejemplos m√°s complejos, mostr√© las dificultades t√≠picas que puede encontrar y formas de superarlas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
¬øMi c√≥digo, en comparaci√≥n con el ejemplo del art√≠culo anterior, fue m√°s limpio, m√°s claro, m√°s corto o tal vez es m√°s f√°cil de mantener? Talvez no. ¬øConsume menos recursos? Por desgracia no. Quiz√°s mi enfoque es m√°s universal, pero esto no es exacto. Sin embargo, hay una tarea que definitivamente realiza mejor. Ilustra mucho m√°s profundamente el funcionamiento de SwiftUI debajo del cap√≥. Con √©l, puede poner la animaci√≥n en los estantes de su cabeza y aplicarla libremente en sus aplicaciones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
SwiftUI es aserrado activamente. </font><font style="vertical-align: inherit;">Incluso ahora, dos semanas despu√©s de escribir el c√≥digo para el primer art√≠culo, ahora, verificando el c√≥digo en la versi√≥n actual de Xcode, veo c√≥mo algunos errores que tuve que sortear ya estaban solucionados. </font><font style="vertical-align: inherit;">Por lo tanto, me qued√© un poco con el art√≠culo. </font><font style="vertical-align: inherit;">Algo ten√≠a que cortarse por irrelevancia, y todo lo dem√°s, para verificar dos veces. </font><font style="vertical-align: inherit;">Y le agrada. </font><font style="vertical-align: inherit;">SwiftUI es definitivamente el futuro del desarrollo nativo de iOS, y es muy informativo para mantenerse en sus or√≠genes y observar c√≥mo se desarrolla.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ep√≠logo</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En el proceso de preparaci√≥n de los materiales para este art√≠culo, tambi√©n me met√≠ muchas cosas en la cabeza. </font><font style="vertical-align: inherit;">Descubr√≠ muchos matices sobre los que no ten√≠a idea cuando comenc√© a escribirlos. </font><font style="vertical-align: inherit;">Por lo tanto, insto a todos los que ya tienen experiencia en el desarrollo de SwiftUI: no sean t√≠midos, compartan su experiencia y conocimiento. </font><font style="vertical-align: inherit;">Esto es muy √∫til tanto para la comunidad como para la integridad de su propio conocimiento. </font><font style="vertical-align: inherit;">Esto es m√°s genial que </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">el m√©todo de patito</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , y aqu√≠ la respuesta debe formularse. </font><font style="vertical-align: inherit;">Lo principal es no ser flojo para buscar una respuesta as√≠ para que no sea vergonzoso que los </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ni√±os se muestren</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es506648/index.html">Laravel Digest (8 al 14 de junio de 2020)</a></li>
<li><a href="../es506658/index.html">GitLab 13.0 lanzado con cl√∫steres Gitaly, jerarqu√≠a √©pica en hojas de ruta e implementaci√≥n autom√°tica para ECS</a></li>
<li><a href="../es506662/index.html">Partici√≥n adaptativa de curvas Bezier de segundo y tercer orden</a></li>
<li><a href="../es506664/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 419 (8 al 14 de junio de 2020)</a></li>
<li><a href="../es506666/index.html">Texturas ORM, pero ¬øvale la pena?</a></li>
<li><a href="../es506676/index.html">Qatar: centro mundial de trasplantes y ciudad nocturna</a></li>
<li><a href="../es506680/index.html">.NET Core vs Node.js. Argumentos y hechos</a></li>
<li><a href="../es506684/index.html">C√≥mo transfir√≠ dedic.ru a las p√°ginas de github y qued√© satisfecho</a></li>
<li><a href="../es506686/index.html">Eventos digitales en Mosc√∫ del 15 al 21 de junio.</a></li>
<li><a href="../es506688/index.html">Eventos digitales en San Petersburgo del 15 al 21 de junio.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>