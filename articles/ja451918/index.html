<!doctype html>
<html class="no-js" lang="ja">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍⚖️ 🧖🏿 🥔 TIの質問へ 🐵 🎉 🙀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="「これからポートレートを表示します...うーん...これはポートレートであることを警告します...いずれにしても、ポートレートのように扱ってください...
 
 この投稿では、メーカーが推奨する環境でのMK CC1350のプログラムの開発とデバッグについて説明しますCCS開発。上記の製品のメリット（...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>TIの質問へ</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/451918/"><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">「これからポートレートを表示します...うーん...これはポートレートであることを警告します...いずれにしても、ポートレートのように扱ってください...</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
この投稿では、メーカーが推奨する環境でのMK CC1350のプログラムの開発とデバッグについて説明しますCCS開発。上記の製品のメリット（およびそのメリット）とデメリット（およびこれらのメリットがない場合）が影響を受けます。テキストには、統合プログラミング環境でのコンパイルアイコンの場所を示す（丸で囲まれた）、またはディレクトリ内のファイルを選択するためのスクリーンショットはありません。似たようなスタイルの記事の基本的な可能性を認識して、読者が詳細を理解できるように、概念的な問題に焦点を当てます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
この作品の目的は、得られた経験を共有することに加えて、TIの直接のライバルである国内のMKメーカー（「私たちが繁栄している国」）の間で健康的な羨望をそそる試みです。</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Windows（さらには）バージョン7についてのみであることをすぐに強調します。TIのWebサイトにはMacとLinuxの両方に対応するオプションがありますが、まだ試していないので、すべてがそれほどクールではないことを確信しています。悪いことについて（またはその逆、すべてがそこで素晴らしいですが、それでなぜ羨ましいですか）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、TIのWebサイトは私たちに何を教えていますか？評価モジュールでの作業を開始するには、3つの必要な手順を実行する必要があります。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">評価モジュールを購入-完了。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
マージン（PNP）に関するメモ：問題のプログラミング環境では、私が（残念ながら）個人的に（残念ながら）ハードウェアをデバッグ用にエミュレートする機能を見つけることができなかったため、これも行う必要があります。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">開発環境をインストールします-ダウンロードしてインストーラーを実行すると、すべてがうまくいきました。</font><font style="vertical-align: inherit;">評価モジュールをUSBに接続します-薪が自然に立ち上がり、すべてが再びうまくいきました-完了。</font><font style="vertical-align: inherit;">デバイスをプログラムしようとすると、ファームウェアを更新する必要があるというメッセージが表示され、同意し、すべてが判明しました。</font><font style="vertical-align: inherit;">一般に、それがいつでもどこでもあったとしても、何も書く必要はありません...</font></font></li>
<li>    TI SimpleLink Academy 3.10.01 for SimpleLink CC13x0 SDK 3.10 —  ,     —  ,     ,       —    . </li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここでは、SYS / BIOSハードウェアドライバーの操作、TI-RTOSオペレーティングシステムの操作、USBを含むNDKネットワークスタックの使用、ワイヤレスプロトコルの使用、および会社が製造するさまざまなMKファミリの代表者との作業に関する多くの側面に関するトレーニング資料をご覧いただけます。この豊富な機能にはすぐに使用できる例が付属しており、ユーザーマニュアルやモジュールの説明の存在も考慮に入れると、おそらくこれ以上何も望めません。しかし、さまざまな方法でプログラムコードの準備と構成、フラッシュおよびデバッグの作業を容易にするユーティリティもあり、この豊富な機能も詳細に文書化されています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：誰かがこの資料を会社、その製品、プログラミングシステムに関連する広告と見なす傾向がある場合、それはおそらく正しいでしょう。検出されたソフトウェアの量には本当に非常に感銘を受けます。その質についてさらに議論し、バイアスの疑いが払拭されることを願っています。私はその感情に完全に盲目ではなく、説明の対象の欠点を完全に見続けているため、これは若者の愛ではなく、大人の専門家の深刻な感情です。このような大量のソフトウェアとドキュメントを作成および維持するために必要な材料費がどれほどかかるか想像できないのですが、これは明らかに1か月で完了しなかったため、会社はその内容を理解していると考えられます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さて、後で資料の調査を延期するまで、「ナゲットに沿って」すべてを理解し、大胆にオープンなCCSを作成します。 Eclipseの親から受け取ったワークスペースの概念を実装しています。個人的には、プロジェクトのコンセプトは私に近いですが、プロジェクトを1つだけ宇宙に留めておこうとする人はいないので、次に進みましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、状況は少し悪化します。デバッグボードのワークスペース（RP）を開き、多くのプロジェクトを確認します（原則として、RTOSの下と「ベアアイロン」用の2つのバージョン）。先に述べたように、これは犯罪ではありませんが、多くのプロジェクトに同じソフトウェアモジュールを持つ同じファイルが含まれているという事実は、まったく素晴らしいものではありません。コードは何度も複製され、変更をサポートすることは非常に重要な作業になります。はい、そのようなソリューションを使用すると、ディレクトリをコピーするだけでプロジェクトを転送するのがはるかに簡単になりますが、そのような場合にはプロジェクトのエクスポートがあり、非常によく実装されています。プロジェクトツリー内のファイルへのリンクは適切にサポートされているため、提供されている例にファイル自体を含めるという決定は満足できるものとは見なされません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査を続けます。完成したプロジェクトで作業を開始しますが、デバッグボードには2つありますが、LEDの点滅はありませんが、既製のuartechoの例であるシリアルポートで作業します。私たちは新しいRPを作成し、興味のあるプロジェクトを含めます...それから来るものは何もありません。RPに関連プロジェクトを含める必要があることはメッセージから明らかです。なぜこれを行う必要があるのか​​は明確ではありませんが、環境の要件を満たすことは難しくありません。その後、プロジェクトの組み立てが始まります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：自宅のマシンで、[プロジェクトのインポート]コマンドを使用したところ、必要なすべてのインクルードが自分で行われました。正確に関連するプロジェクトが示されている場合、私にはわかりません。この側面の分析は将来のために残しておきましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
コンパイル、フラッシュ、デバッグを開始します。興味深い現象が見つかりました-シリアルポートを使用するライブラリを検討すると、ステップバイステップの実行が適切に表示されません-最適化コスト。コンパイラー設定の最適化をオフにし（設定はありませんが、実際にそれらすべてを知っていて、さらにそれらすべてを使用する人々がいます）、プロジェクトを再度アセンブルします-そして何も変更しません。少なくともリンクの形式で、プロジェクトツリーに含まれているファイルのみが含まれていることがわかります。ライブラリソースへのリンクを追加し、再構築後にすべてが正しくデバッグされます（デバッグ情報を生成するオプションが有効になっている場合）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：でも、MISRA-Cコンプライアンスチェックを有効にするオプションを見つけました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：別の方法は、後続のアセンブリで「Clean ...」コマンドを使用することです。「Build All」コマンドは、何らかの理由で関連プロジェクトに影響を与えません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
さらに、すべてが常に正常にデバッグされるわけではなく、コンパイラーがソースを見つけられないマシンコードの領域にいることもあります。プログラミング環境は、作業に必要なすべてのファイル（プリプロセッサーの結果、アセンブラーコード、およびリンカーカード（対応するオプションを有効にすることを覚えておく必要があります））を提供するため、後者を使用します。プログラムコードには、0x0000から始まる2つの領域があります。 0x1000から開始します。 （32ビットアーキテクチャはすべての人に適していますが、アドレスの記述は長所ではありません）。マイクロ回路のドキュメントに目を向けると、内部に特に0x1000にマップされたROM領域があることがわかります。そして、そこにはライブラリの組み込み部分が含まれています。申し立てそこからサブルーチンを使用すると、パフォーマンスが向上し、0x000アドレス空間と比較して消費が削減されます。 MKを習得している間は、最後のパラメーターにそれほど関心はありませんが、デバッグの利便性は非常に重要です。コンパイラーにNO_ROMオプションを設定することで、ROMの使用を（そして私たちの目的のために）無効にすることができます。これを行ってプロジェクトを再アセンブルします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PNP：ROM内のサブルーチンへの遷移は非常に面白いように見えます-コマンドシステムには長い遷移がないため、最初に下位アドレス領域（0x0000）の中間点に戻ることで遷移が行われ、逆アセンブラーによってパラメーターが認識されないPCブートコマンドがすでに存在します。私は信じられない何か、そのようなオーバーヘッドのコストがあれば、あなたはスピードで勝つことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、興味深い質問は、ROMの内容が会社から提供されたソースコードに対応していることが一般的にどのように保証されているかです。追加の（もちろん、デバッグとサービス）機能をROMに埋め込むためのメカニズムをすぐに提案できます。これは、ユーザーにとっては、MKプログラマーから完全に見えなくなります。そして個人的には、チップの開発者がそのような機能を実装する他の多くのメカニズムも知っていることは間違いありませんが、私たちはパラノイアの攻撃を終わらせます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一方、私はBIOSのこのような類似体の出現を歓迎することができるだけです。これは、長期的には、1つのコアを持つ異なるMKファミリ間でコードを実際に移植できるという開発者の夢を実現するためです。また、「組み込み」ソフトウェアモジュールとの相互作用の実装の特殊性にも注意します。 TivaCモデルに実装された同様のメカニズムを早期に作成しようとした場合、サブプログラムのグループ番号とエントリポイント番号を使用してアクセスされるコールスーパーバイザがあり、大きなオーバーヘッドが発生しました。ここで、関数の二重の名前により、通信の解決はリンカーレベルで行われます。 ROM内のサブルーチンへの直接の長いジャンプが挿入されます。これは実行がはるかに高速ですが、使用モデルを変更するときにプロジェクトの再コンパイルが必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
便利なデバッグの準備が整ったので、プロジェクトに戻り、モジュールのソースコードにアクセスしてプログラムを静かにデバッグし始めます（そうですね、それが私が思ったとおりです...）。これにより、これらのテキストの品質について意見を述べることができます。調査中のプロジェクトは、シリアル通信チャネルのミラーを実装しており、トレーニングの目的で非常に便利です。もちろん、RTOSを使用してオプションを選択しましたが、構成（大量のメモリとプログラムメモリ）でRTOSを使用しない理由はほとんどありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに、ソースコードはCで表示されることに注意してください。多くの場合、言語コンストラクトはプラスの類似物に比べて扱いにくいように見えますが、作成者は構文上の砂糖よりもコードの互換性を重視していました。 C ++バージョンのライブラリを作成することは可能ですが、条件付きコンパイルは古くから知られており、どこでも使用されていますが、これには追加の材料コストが伴います。確かに、会社の経営陣は彼らが何をしているか知っており、私のコメントは一種の「狡猾な分析」ですが、私には自分の意見に対する権利もあるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ライブラリが最新のC ++ツールを使用して設計されている場合、および最新の仕様を満たしていないツールでコンパイラを使用する開発者に何をすべきかを尋ねられた場合、私は反対のアプローチも知っています。優れた答えがあるはずです-新しいバージョンに切り替えるかどうかこのライブラリ（そのような場合は2番目のオプションを強くお勧めします）。私の個人的な見解では、製品を本当に使用したい場合（そしてTIがこれを明らかに望んでおり、「私からイチジクを落とす、これがあなたのための新しいドラムだ」という原則でライブラリを作成しない）場合、そのアプローチは確かに真実です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
プログラムのソースコードは古典的に見えます-ハードウェアおよびソフトウェア環境の初期化、タスクの作成、メインモジュールでのShedulerの起動、別のコンパイルモジュールでのタスクのテキスト。</font><font style="vertical-align: inherit;">この例では、タスクは正確に1つです-mainThread、目的は名前から完全に明確ではありません、そしてそれは私を少し混乱させます-ソーステキストを含むファイルの名前が関数の名前（uartecho.c-名前はここで話していますが）と一致しませんプログラミング環境での検索は標準的な方法（コンテキストメニューまたはエンティティ名のF3）で実装されており、これで問題はありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
開始する前にタスクパラメータを設定するプロセスは、かなり期待されています。</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">パラメータの構造を作成します（もちろん、ローカル）。 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">デフォルト値を与え、 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">標準以外のパラメータを設定し、 </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">タスクを作成するときに構造を使用します。</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
これらの操作の自然さにもかかわらず、すべてのライブラリ作成者には明らかではありません。たとえば、ステージ2がなく、面白​​い（プログラマーではなく外部の観察者にとって）プログラムの動作につながるさまざまな実装を見ました。この場合、すべてが問題ありません。発生した唯一の問題は、デフォルト値が一定でない理由です。おそらくこれは、のろわれた過去の遺産です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PNP：よく知られているFREE-RTOSでは、わずかに異なるアプローチが取られ、タスク作成関数のAPI呼び出しの本体でタスクのパラメーターを直接示します。これらのアプローチの長所と短所は次のとおりです。</font></font><br>
<br>
<ol>
<li>+    ,     , +    , - , -  , -    , -    </li>
<li> —    , -   , + , +  , +    . <br>
<br>
  ,     (  ),     </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+標準に一致するパラメーターを明示的に指定できないようにします+パラメーターの順序を覚えておく必要がありません-マルチ言語、-メモリコストが大きくなります-デフォルトのパラメーターを知る必要があります+ラムダスタイルで機能します+標準エラーの実装が難しくなります-多少見える右括弧が多いので奇妙です。 </font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まあ、別の4番目のオプションがありますが、欠点はありませんが、C ++が14以上である必要があります。唇をなめて通り過ぎます。 </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
デバッグを開始し、プログラムを実行して、プログラミング環境が提供するターミナルウィンドウでデバッグボードが提供する2つのシリアルポートの1つを開きます。 2つのポートのいずれか（1つはデバッグ用、2つ目はユーザー、システムでそれらの番号を確認できます）は事前に判別するのが難しく、場合によっては最年少、時には上級、少なくともボードを再接続しても変更されないため、ボードに書き込むことができます。さて、もう1つの不便さ-開いているターミナルはプロジェクトに保存されず、デバッグセッションを開いたときに復元されませんが、デバッグセッションを終了しても閉じません。私たちはプログラムの動作をチェックし、すぐに別の欠点を見つけます-端末は設定できません。たとえば、基本的に/ rを閉じてUnixスタイルで動作します。そのようなミニマリズムには触れませんでした。外部ターミナルプログラムの使用を妨げている人はいません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：デバッグのもう1つの機能に注目します。これは、どの開発環境にも当てはまります。Sedulerでタスクを切り替えると、フォーカスフォーカスが失われ、ブレークポイントがこの問題の解決に役立ちます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最初に、シリアルポートのインスタンスを作成するプロセスを検討します。ここではすべてが標準的なようです。構造体が使用され、そのフィールドにはオブジェクトの必須パラメーターが割り当てられています。プロでは、Cには完全に欠けているため、すべての初期化を「内部で」完全に隠す機会がありますが、2番目の解決策を支持する可能性のある議論についてはすでに述べています。チューニング構造を初期化するための関数があり、これは適切です（奇妙なことに、この関数は一部のライブラリの作成者にとって必須ではないようです）。物語のこの時点で、新婚旅行は終わり、普通のことが始まります</font></font><strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（結婚）</font></font></strike><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">人生。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ソースを注意深く調査すると、すべてがそれほど良好であるとは限りません。</font><font style="vertical-align: inherit;">問題は何ですか-初期化関数は、定常領域にあるオブジェクトからデフォルト値を制御構造にコピーしますが、これは素晴らしいことですが、何らかの理由で：</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">オブジェクトはグローバルですが、パラメーターを初期化するための唯一の関数によって使用されます（一度に同様の方法でトヨタにかなりの費用がかかります）。まあ、静的ディレクティブを追加するのは簡単です。</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">コントロールオブジェクトには名前が付けられていますが、Cではこの問題に対する美しい解決策はありません。または、匿名コピーによる解決策があり、長い間投稿したのですが、多くの右角かっこでこのオプションを本当に美しいものにすることはできません。さらに、すばらしい美しさの解決策がありますが、パイプの夢を夢見る;</font></font></li>
<li>      ,    (    )   32- ;</li>
<li>      ,          —  -;</li>
<li>        ,       (   ) ;</li>
<li>          ( )       .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、受信バッファの初期化は適切に行われています。事前に予約されたメモリを使用し、ヒープの操作はありません。呼び出しチェーンはやや複雑ですが、すべてが非常に読みやすくなっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：デバッグウィンドウでは、目の前のコールスタックで、すべてが適切かつ適切に行われます。少し意外なのは、このウィンドウを非表示にしようとすると、デバッグセッションが終了することだけです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ええと、もう少し予期しないもう1つの決定-シリアルポートおよびこのデバッグボードに対して、列挙内のオブジェクトの可能な数をスタイルで1に設定します</font></font><br>
<br>
<pre><code class="cpp hljs"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> CC1310_LAUNCHXL_UARTName {<font></font>
    CC1310_LAUNCHXL_UART0 = <span class="hljs-number">0</span>,<font></font>
    CC1310_LAUNCHXL_UARTCOUNT<font></font>
} CC1310_LAUNCHXL_UARTName;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
このような解決策は実際の転送の標準ですが、ハードウェアオブジェクトを記述するためのものです。それが可能であることを私は知りませんでした。</font><font style="vertical-align: inherit;">アイアンの初期化が完了しました。次へ進みましょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実行中のタスクで、シリアルポートからのデータが関数によって読み取られる古典的な無限ループを観察します</font></font><pre><code class="cpp hljs">UART_read(uart, &amp;input, <span class="hljs-number">1</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 機能によってすぐに返送されます </font></font><pre><code class="cpp hljs">UART_write(uart, &amp;input, <span class="hljs-number">1</span>);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">最初のものに行き、受信バッファから文字を読み取る試みを見てみましょう</font></font><pre><code class="cpp hljs"><span class="hljs-keyword">return</span> (handle-&gt;fxnTablePtr-&gt;readPollingFxn(handle, buffer, size))</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （どのように私はそのようなことを嫌うが、Cではそれが不可能であるだけである）、私たちはUARTCC26XX_readに深く入り込み、そこから自分自身をリングバッファの実装に入ります-関数 </font></font><pre><code class="cpp hljs">RingBuf_get(&amp;object-&gt;ringBuffer, &amp;readIn)</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。ここで、日常生活は急性期に入ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
私はこの特定のモジュール（ringbuf.cファイル）が好きではないことを言いたくありませんでした。それは単にひどいものであり、私は個人的にこの部分の作者のそのような尊敬される会社の場所を恥ずかしくて追い出したでしょう（まだ私を彼らの場所に連れて行くことができますが、私は恐れています）インド人の同僚の給与レベルは私には合わないと思います）が、私はおそらく何を知りません。あなたの手を見てください：</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
1）読み取り/書き込みポインターの再ロールは、分割の残りを通して実装されます</font></font><br>
<br>
<pre><code class="cpp hljs">object-&gt;tail = (object-&gt;tail + <span class="hljs-number">1</span>) % object-&gt;length;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
また、ビットマスクの適用のようにこの操作を実行する場合、コンパイラーの最適化はありません。バッファーの長さが定数ではないため、最適化することはできません。はい、このMKにはハードウェア除算演算があり、かなり高速です（私はそれについて書きました）が、正直な再ロールを使用した正しい実装（および私もこれについて書きました）のように、2クロックサイクルはかかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pnp：実装で新しいM7アーキテクチャの説明を最近見ましたが、誰も覚えていません。そのため、何らかの理由で、32を32で割ることは、2-7ではなく2-12サイクルで実行されるようになりました。これは翻訳エラーか、何を考えればよいかわかりません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
2）さらに、このコードフラグメントは複数の場所で繰り返されます-wimpsのマクロとインライン、ctrl + Cおよびctrl + Vルール、DRY原則はフォレストを通過します、</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
3）満たされたバッファプレースの完全に冗長なカウンタが実装されました。これには、次の欠点がありました</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
。4）読み取りと書き込みの両方でクリティカルセクション。まあ、私はまだ（この動作は、ファームウェアの分野での専門家のために受け入れられないですが）、このモジュールの作者がHabréの私の記事を読んでいないが、彼らはムスタングブックに精通している必要があることを信じることができ、この問題は、詳細にそこに検討する</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
）方法5さらに、最大のバッファーサイズのインジケーターが導入され、非常に不明瞭な名前と完全に欠落した説明が付いています（後者は一般的にモジュール全体に適用されます）。このオプションがデバッグに役立つ可能性があることを除外しませんが、なぜそれをリリースにドラッグするのですか？RAMでプロセッササイクルはありますか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
6）同時に、バッファーオーバーフロー処理は完全にありません（この状況については-1のリターンシグナルがあります）。Arduinoでも、この処理の品質は別にしますが、その欠如はさらに悪化します。あるいは、著者は、空ではないという事実を含め、比較的空のセットに関して何らかの仮定が当てはまるというよく知られた事実に触発されたのでしょうか？</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
一般に、私のコメントは、コードレビューのテーマ「コードの10行-コメント10」に関するデモティベーターの最初の行と完全に一致しています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、指摘された欠点の最後から2番目は、よりグローバルなことについて考えるようになりますが、その深い変更を実行できるようにするために、基本クラスをどのように実装すればよいでしょうか。すべてのフィールドを保護するのは疑わしいアイデアです（おそらく唯一正しいものですが）、フレンドリーな関数の呼び出しを相続人に挿入することは、松葉杖に非常によく似ています。この特定のケースで、バッファがいっぱいであることのインジケーターを導入するという質問に対する簡単な答えがある場合-書き込みと読み取りが重複する生成されたクラスと追加のカウンター、そしてバッファを進めずに（この場合のように）読み取りを実装するか、最後に配置された文字を置き換えます（私はそのように見ました）リングバッファの実装）親クラスの内部データにアクセスしないと実行できません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
同時に、シリアルインターフェイスからの実際の読み取りの実装についての不満はありません-入力がブロックされており、受信バッファーに十分な文字がない場合、セマフォが作動し、制御がシェデュラーに転送されます-すべてが正確かつ正しく実装されています。個人的には、汎用の手順で機器を制御することはあまり好きではありませんが、これにより、手順の入れ子が減り、意味が何であれ、循環的複雑度の指標が減ります。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
オブジェクトを作成するときに、リングバッファーが1つ（受信側のバッファー）しか提供されなかったため、シリアルチャネルへの受信データの送信に注目してみましょう。</font><font style="vertical-align: inherit;">実際、ハードウェアの内部バッファーは文字を送信するために使用され、それがいっぱいになると、準備状態の待機に入ります（少なくともブロッキング操作モードで）。</font><font style="vertical-align: inherit;">対応する関数のスタイルを批判しないように、私は自分自身を助けることはできません：1）何らかの理由で、オブジェクトには一般化されたポインターがあり、関数内では常に文字へのポインターに変わります</font></font><pre><code class="cpp hljs">*(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *)object-&gt;writeBuf);</code></pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2）作業のロジックは完全に不透明で、少し混乱しています。</font><font style="vertical-align: inherit;">しかし、これはユーザーから隠されたままであり、「最大速度に影響を与えない」ため、これはそれほど重要ではありません。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
調査の過程で、もう1つの機能に出くわします。デバッグモードでは一部の内部関数のソースコードが表示されません。これは、さまざまなコンパイルオプション（ROM / NO_ROM）の名前が変更されたためです。必要なソースファイルを置き換えます（C：\ Jenkins \ jobs \ FWGroup-DriverLib \ workspace \ modules \ output \ cc13xx_cha_2_0_ext \ driverlib \ bin \ ccs /./../../../ driverlib / uart.c--） （もちろん、uart.cファイルのファイルに感謝の意を込めて）ソースを見つけましたが、幸いにも、このフラグメントは単純で、Cのソースコードを使用してアセンブラーコードを簡単に識別できました。 （特にITxxxチームの機能を知っている場合）。複雑な関数を含むライブラリーでこの問題を解決する方法がわかりません。必要に応じて検討します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして最後に、小さな発言-MK CC13x0モデルのシリアルチャネル実装のハードウェアはCC26x0のハードウェアと同じであり、UARTCC26XX.cと呼ばれるファイルの内容の複製は正しいソリューションとは言えませんが、インクルードを含む中間定義ファイルを作成することはできます私はソースファイルを歓迎します。これにより、関数と対応するコメントをオーバーライドします。これにより、プログラムがより理解しやすくなるので、これは常に歓迎されるべきですvout。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、テストケースは機能し、標準ライブラリの内部構造について多くのことを学び、その長所とあまりよくない側面を指摘しました。レビューの終わりに、プログラマーが通常注意する「OSまたはOSではない」という疑問に対する答えを見つけようとします-コンテキスト切り替え時間。ここでは2つの方法が可能です。1）ソースコードの検討は理論的な方法であり、私が実証する準備ができていない主題にある程度の没入感が必要です。2）実用的な実験です。もちろん、2番目の方法は、1番目の方法とは異なり、完全に正しい結果は得られませんが、「真実は常に具体的」であり、測定が正しく整理されていれば、取得されたデータは適切であると見なすことができます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
まず、切り替え時間を評価するために、さまざまなプログラムフラグメントの全体的な実行時間を評価する方法を学ぶ必要があります。このアーキテクチャには、システムカウンターの一部であるデバッグモジュールがあります。このモジュールに関する情報は非常にアクセスしやすいですが、悪魔はいつものように詳細に隠れています。最初に、レジスタへのアクセスを介して直接ハンドルで必要なモードを構成してみましょう。レジスターのブロックCPU_DWTをすばやく見つけ、その中にカウンターCYCCNT自体と、そのビットのCYCCNTENAを持つCTRLの制御レジスターの両方を見つけます。当然、または当然ながら、何も実現していません。ARMのWebサイトには、なぜかという質問への回答があります。DEMCRレジスタのTRCENAビットでデバッグモジュールを有効にする必要があります。しかし、最後のレジスタでは、それほど単純ではありません。DWTブロックにはありません。他のブロックで検索するのは面倒です-それらはかなり長いですが、レジスターウィンドウで名前による検索を見つけられませんでした（しかし、それがあればいいでしょう）。メモリウィンドウに移動し、レジスタのアドレス（日付からわかる）を入力します（ちなみに、何らかの理由でアドレスの16進形式がデフォルトではないため、0xプレフィックスをペンで追加する必要があります）。突然、CPU_CSC_DEMCRという名前の名前付きメモリセルが表示されます。奇妙なことに、アーキテクチャのライセンサーが提案した名前と比較して、会社がレジスタの名前を変更したのはおかしいですが、おそらく必要でした。そして正確に言うと、レジスターのCPU_CSCブロックでレジスターを見つけ、そこに目的のビットを設定し、カウンターに戻り、それを有効にすると、すべてが機能しました。レジスタアドレスを入力します（日付からわかります）（ちなみに、何らかの理由でアドレスの16進形式はデフォルトではありません。ハンドルに0xプレフィックスを追加する必要があります）。突然、CPU_CSC_DEMCRという名前の名前付きメモリセルが表示されます。奇妙なことに、アーキテクチャのライセンサーが提案した名前と比較して、会社がレジスタの名前を変更したのはおかしいですが、おそらく必要でした。そして、確かに、レジスタのCPU_CSCブロックで、レジスタを見つけ、そこに目的のビットを設定し、カウンタに戻って有効にし、すべてが機能しました。レジスタアドレスを入力します（日付からわかります）（ちなみに、何らかの理由でアドレスの16進形式はデフォルトではありません。ハンドルに0xプレフィックスを追加する必要があります）。突然、CPU_CSC_DEMCRという名前の名前付きメモリセルが表示されます。奇妙なことに、アーキテクチャのライセンサーが提案した名前と比較して、会社がレジスタの名前を変更したのはおかしいですが、おそらく必要でした。そして、正確に言うと、レジスターのCPU_CSCブロックで、レジスターを見つけ、そこに目的のビットを設定し、カウンターに戻り、それを有効にすると、すべてが機能しました。そして、確かに、レジスタのCPU_CSCブロックで、レジスタを見つけ、そこに目的のビットを設定し、カウンタに戻って有効にし、すべてが機能しました。そして、確かに、レジスタのCPU_CSCブロックで、レジスタを見つけ、そこに目的のビットを設定し、カウンタに戻って有効にし、すべてが機能しました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PNP：名前による検索はまだあり、Ctrl-Fの組み合わせによって（当然）呼び出されます。これはコンテキストメニューにのみ存在しますが、通常のメニューではキャンセルされます。開発者に謝罪します。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
すぐに、メモリウィンドウのもう1つの欠点を指摘します。名前付きのセルを示すことによって内容の印刷が中断され、出力が破損し、figが16（8.32.64、必要なものに置き換えられます）に分割されなくなります。また、ウィンドウのサイズを変更すると、出力形式が変わります。これらすべてはユーザーのニーズに応じて構成できますが、私自身の経験（および他に何をすべきか）に基づいて、メモリ表示ウィンドウの出力形式の設定は直感的に明らかな解決策には適用されないことを宣言します。私は、表示ウィンドウに名前付きメモリ領域を表示するなどの便利な機能を有効にすることに全面的に賛成です。そうしないと、多くのユーザーはそれを知らないでしょうが、意識的に無効にしたい人にも注意が必要です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ちなみに、デバッグのためにレジスタ操作を挿入してコード修正を検討しているため、MKをリセットした後に毎回（時間測定を有効にするために）レジスタの設定を行う必要があったため、環境で作業するためのマクロ（またはスクリプト）を作成する可能性を完全に放棄することはしません。あまり正しくないただし、マクロは見つかりませんでしたが、個々の（必要な）レジスターを式ウィンドウに含めることができるため、レジスターでの作業が大幅に簡略化され、それらの作業が大幅に促進および高速化されます。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
MKファミリーに対するエンジニアの気持ちが冷めていなかったことを強調するために（そうでなければ、開発環境のさまざまな側面を叱りました）、カウンターは正常に機能していることに気づきました-どのデバッグモードでも余分なサイクルを見つけることができませんでしたが、これが起こる前に少なくとも、MKシリーズでは、LuminaryMicroによって開発されました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
したがって、コンテキスト切り替え時間を決定するための実験計画の概要を説明します。特定の内部カウンターを（無限ループで）インクリメントする2番目のタスクを作成し、MCを特定の時間起動し、システムカウンターとタスクカウンターの関係を見つけます。次に、MKを同様の時間（必ずしも完全に同じである必要はありません）に開始し、毎秒約1回のペースで10文字を入力します。これにより、エコータスクに切り替わり、カウンタータスクに切り替わることが予想されます。はい、これらのコンテキストスイッチは、sedulerタイマーではなくイベントに従って実行されますが、調査対象の関数の合計実行時間には影響しないため、計画の実装を開始し、カウンタータスクを作成して開始します。</font></font><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
ここで、少なくとも標準構成ではRTOSの1つの機能が見つかります-「本当の意味で」混雑しているわけではありません。優先タスクが常に実行の準備ができており（そしてカウンタータスクがそうである場合）、シェデュラーに制御を与えない（シグナルを期待せず、眠りに落ちない）フラグなどでブロックされていない場合）、優先度の低い単一のタスクがその単語から実行されることはありません。これはLinuxではなく、さまざまな方法を使用して、「誰も気分を害することがないように」すべての人が量子を取得できるようにします。この動作は非常に予想され、多くの軽量RTOSはこのように動作しますが、管理者は常に準備されているタスクと同じ優先度のタスクを受信しないため、問題はさらに深くなります。このため、この例では、待機に含まれるエコータスクを配置しました。優先度は、常に終了するカウンタータスクよりも高く、そうでない場合、後者はすべてのプロセッサリソースを時間内にキャプチャします。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
実験を開始します。最初の部分（実行時間を待機するだけ）で、カウンターの比率に関するデータを提供しました406181/58015= 7-これは非常に期待されています。 2番目の部分（約10秒間に10文字が続く）の結果は351234k-50167k * 7 = 63k / 20 = 3160サイクルで、最後の数字はMKサイクルでのコンテキスト切り替え手順に関連する時間です。個人的には、この値は予想よりも少し大きいように思われます。調査を続けていますが、統計を台無しにする行動がまだいくつかあるようです。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PNP：実験者の一般的な間違いは、以前に予想された結果を評価せず、受け取ったゴミを信じないことです（開発者737に感謝）。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
結果には、実際のコンテキストの切り替えに加えて、バッファから文字を読み取り、シリアルポートに出力する操作を実行するために必要な時間が含まれることは明らかです（「はい、非常に明白」）。それほど明白ではないのは、それが受信時に割り込みを処理し、文字を受信バッファーに入れるのにかかる時間もあるということです。猫と肉をどのように分離しますか？これにはトリッキーなトリックがあります-プログラムを停止し、10文字を入力して開始します。受信時の割り込みは1回だけ発生し、すぐにすべての文字が受信バッファからリングバッファに送信されることを期待できます（ソースを確認する必要があります）。つまり、オーバーヘッドが少なくなります。シリアルポートへの配信時間を決定するのも簡単です。2番目の文字を出力し、2つの未知数を含む2つの線形方程式を解きます。そしてそれは可能であり、さらに簡単です-私がしたように、何も推論しないこと。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
そして、ここにはそのようなトリッキーな操作の結果があります：パケットによる入力を作成し、欠落しているメジャーを小さくします-2282、出力をオフにすると、コストは1222メジャーに下がります-これはより良いですが、300サイクルを期待していました。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
しかし、読んでいるときは、このようなことは思いつきません;望ましいコンテキスト切り替え時間と同時にスケーリングされます。私が提供できる唯一のことは、受信した文字の入力を開始するときに内部タイマーをオフにし、次の文字を入力する前にオンに戻すことです。次に、2つのカウンタが同期して動作し（切り替えを除く）、簡単に判別できます。しかし、このようなアプローチでは、テキストにシステムプログラムを深く実装する必要があり、とにかく、割り込み処理のコンポーネントが残ります。したがって、私はすでに取得したデータに制限することを提案します。これにより、検討中のTI-RTOSのタスク切り替え時間が1222クロックサイクルを超えないことを断言できます。これは、所定のクロック周波数で30マイクロ秒です。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
PNP：まだたくさん-100でサイクルを数えました：30はコンテキストを保存し、40は完了したタスクを決定し、30はコンテキストを復元しましたが、さらに1桁多くなっています。最適化は現在オフになっていますが、–o2をオンにして結果を確認してください。あまり変わっていません。3160ではなく2894になっています。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
別のアイデアがあります-ピアツーピアタスクの切り替えがOSでサポートされている場合、カウンターを使用して2つのタスクを開始し、時間の経過に伴う切り替えの数に関するデータを魔法のように取得し、システムカウンターの損失を計算することができますが、Sedulerの特性により、すでに述べたように、このアプローチは成功につながりません。別のオプションも可能ですが、セマフォを介して2つのピアツーピア（またはピアツーピア）タスク間でピンポンを実行することもできますが、ここでコンテキストスイッチの数を計算するのは簡単です。試してみる必要がありますが、明日になるでしょう。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
今回の投稿の最後にある従来の調査は、プレゼンテーションのレベル（賞賛を超えていること、期待を超えていることは公平な読者には明らかです）ではなく、次の投稿のトピックに当てられます。</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ja451904/index.html">時々、多くは少ないです。負荷の減少が遅延の増加につながる場合</a></li>
<li><a href="../ja451906/index.html">Exchangeの脆弱性：ドメイン管理者に対する特権の昇格を検出する方法</a></li>
<li><a href="../ja451908/index.html">コンピューターの歴史：Yandex Museumでの夜</a></li>
<li><a href="../ja451912/index.html">MuseNetディープニューラルネットワークが音楽を書き込む</a></li>
<li><a href="../ja451916/index.html">非同期PHPと1台の自転車の話</a></li>
<li><a href="../ja451920/index.html">Zimbra Collaboration Suiteでメールストレージを最適化する</a></li>
<li><a href="../ja451922/index.html">C ++での固定小数点演算</a></li>
<li><a href="../ja451926/index.html">130ストリーム後のライブコードについて</a></li>
<li><a href="../ja451928/index.html">AMPページでウェブ解析を設定する方法</a></li>
<li><a href="../ja451930/index.html">階段の照明の自動化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>