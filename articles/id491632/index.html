<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍❤️‍💋‍👨 🥛 🏿 Keabadian Digital - Internet Sinkron 👨‍👧‍👦 ↖️ 🧡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saya mengusulkan untuk melanjutkan topik yang dimulai pada artikel sebelumnya (https://habr.com/en/post/489068/). Jika, pada dasarnya, ia memanjakan d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Keabadian Digital - Internet Sinkron</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491632/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengusulkan untuk melanjutkan topik yang dimulai pada artikel sebelumnya (https://habr.com/en/post/489068/). Jika, pada dasarnya, ia memanjakan diri dalam mimpi-mimpi tentang tipe bagaimana semuanya akan baik-baik saja (atau sangat tergantung pada tipe orang) ketika singularitas teknologi dan keabadian digital datang pada tahun 20XX, maka dalam artikel ini dan selanjutnya saya akan mencoba melakukan segala yang mungkin untuk memastikan masa depan yang bahagia (Singularitas) datang lebih cepat, yaitu untuk menciptakan paradigma komputasi untuk prosesor generasi kelima (ingat ada beberapa baris tentang ini). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan menggunakan "hak cipta" dan menamai paradigma komputasi yang dibuat "Rutel".</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita coba mencari tahu: apakah benar-benar ada kebutuhan untuk sesuatu yang baru secara radikal, atau bisakah orang tua von Neumann menjadi "dukun" dan cukup? </font><font style="vertical-align: inherit;">Orang Jepang hanya terbakar: ketika mereka mencoba membuat arsitektur baru dan prosesor paralel, teknologi produksi prosesor serial konvensional meningkat. </font><font style="vertical-align: inherit;">Mereka telah sangat meningkat sehingga semua parameter yang diharapkan untuk prosesor paralel pada serial reguler telah tercapai. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemungkinan mengulang skenario seperti</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu saat ini rendah karena berbagai alasan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan arsitektur yang ada telah habis (karya-karya Lebedev dan lainnya);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ukuran transistor sudah sebanding dengan molekul;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembuangan panas secara praktis tidak turun dengan penurunan standar teknologi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meningkatkan frekuensi prosesor tidak meningkatkan kinerja.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para pengembang teknologi komputer tidak memiliki ide, kecuali untuk peningkatan dangkal dalam jumlah inti dalam sistem komputer. </font><font style="vertical-align: inherit;">Saya pikir pendekatan ini tidak produktif untuk sistem yang tidak didasarkan pada konsep "komputasi paralel." </font><font style="vertical-align: inherit;">Dan pemikiran logis (berurutan) seseorang (programmer) juga tidak bersinar dengan paralelisme. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengingat masalah yang diidentifikasi, mari kita tentukan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">persyaratan yang</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> saat ini diajukan untuk sistem komputasi yang menjanjikan:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paralelisme</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Distribusi</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memecahkan masalah kompleksitas.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Toleransi kesalahan.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembuatan perangkat apa pun dibuat sebagai respons terhadap kebutuhan apa pun. Teknologi komputer modern diciptakan sebagai tanggapan atas kebutuhan akan komputasi ilmiah dan rekayasa dalam jumlah besar. Saat ini, penggunaan utama teknologi komputer adalah "komputasi", "revitalisasi" berbagai model virtual, beberapa di antaranya adalah model objek yang disederhanakan dari dunia fisik nyata, yang lain umumnya sepenuhnya virtual dan pada saat yang sama berinteraksi dengan dunia luar melalui berbagai antarmuka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemindahan kepribadian seseorang ke sistem semacam itu juga merupakan kebutuhan modern.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paradigma komputasi Von Neumann secara inheren cukup canggih dan kuat, tetapi masih berupa kalkulator. Dasar dari teknologi komputasi modern adalah "imitasi" dari pemikiran logis seseorang (catatan: hanya pemikiran logis, dan bukan struktur otak secara keseluruhan), tetapi tidak dimaksudkan untuk mensimulasikan dunia sekitarnya. Pemikiran logis seseorang adalah proses mental tingkat tinggi dan secara fundamental konsisten. Pikirkan tentang frasa: bahasa pemrograman. Bahasa pemrograman, dasar interaksi dengan sistem komputer secara logis terhubung dengan bagian dari tubuh manusia dan mewarisi banyak fitur-fiturnya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai contoh, cobalah mengucapkan dua frasa sekaligus. Ya, dan mendengarkan dua orang secara bersamaan (terutama dengan suara serupa) tidak berhasil.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebagai </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tugas utama</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , seseorang harus mengambil tugas mempertahankan atau "merevitalisasi" objek-objek dari dunia virtual. </font><font style="vertical-align: inherit;">Dunia virtual, yang berisi kedua model objek dari dunia nyata ditambah dengan koneksi (melalui berbagai sensor dan manipulator), dan model yang tidak memiliki analog di dalamnya. </font><font style="vertical-align: inherit;">Dalam batas itu, "paradigma komputasi baru" tidak boleh dianggap sebagai alat lain untuk memecahkan masalah langsung, tetapi sebagai satu set dimensi tambahan untuk dunia fisik kita. </font><font style="vertical-align: inherit;">Saya ingin mencatat bahwa seseorang (secara keseluruhan) adalah sistem biologis yang memecahkan masalah yang sama persis, sehingga untuk mentransfer kepribadian seseorang, diperlukan sistem dengan fungsi yang sama atau lebih besar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di mana untuk memulai?</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara alami, Anda harus mulai dengan postulat dari sifat-sifat ruang virtual. </font><font style="vertical-align: inherit;">Teknologi komputasi saat ini diwakili oleh ruang satu dimensi (ruang alamat tak terbatas). </font><font style="vertical-align: inherit;">Tapi ini tidak cukup untuk memodelkan dunia tiga dimensi (+ waktu), yang terus-menerus menimbulkan masalah yang membutuhkan "tongkat" untuk solusi mereka. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan memberikan contoh masalah yang melekat dalam paradigma komputasi modern:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah lokasi objek dalam memori, tidak mungkin untuk mengubah ukurannya tanpa membuat ulang. </font><font style="vertical-align: inherit;">Anda harus menggunakan pengalamatan tidak langsung, menyelesaikan masalah dengan defragmentasi dan alokasi memori. </font><font style="vertical-align: inherit;">Masalah dengan stack overflow dan berbagai buffer.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada konsep kurangnya data dalam sistem penyajian data, setiap sampah dalam memori fisik adalah data yang sah, yang menyebabkan kesalahan.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak ada konsep sistem komputer lain (objek), hanya ada satu "pita" memori dan satu otomat yang memodifikasinya. </font><font style="vertical-align: inherit;">Pendekatan ini menimbulkan masalah dengan interaksi tugas bahkan dalam prosesor yang sama (tugas dilakukan berurutan), dan jika lebih dari satu sistem komputer perlu berinteraksi, maka "kruk" mencapai proporsi epik.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh-contoh ini hanya untuk memahami bahwa sebagian besar masalah besar adalah inti dari paradigma komputasi, dalam elemen "batu bata" yang paling sederhana. </font><font style="vertical-align: inherit;">"Batu bata" ini pada titik tertentu tidak ingin membentuk struktur tunggal dan seluruh "bangunan" runtuh. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Postulat</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (mereka akan diisi ulang, dan kemudian dikurangi menjadi beberapa yang dasar):</font></font><br>
<br>
<ol>
<li>     «»,          «»   .</li>
<li>   «»  .    «»    (  )   «»      «»    «».  ,                  «»  .</li>
<li>      .</li>
<li>      ,          «» « »  «»,   .</li>
</ol><br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara singkat, ruang virtual adalah busa multidimensi yang bersentuhan satu sama lain.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Postulat ini akan memungkinkan Anda untuk membuat sistem apa pun (set objek yang berinteraksi) dari dunia nyata (fisik) atau virtual. Contoh: akses ke alamat melalui objek "memori" menggunakan dimensi "alamat" dan mungkin ada sejumlah ruang alamat tersebut. Objek yang dialamatkan memiliki dimensi tambahan yang sesuai dengan ruang alamat yang berbeda. Objek "memori" dalam bentuk objek fisik mungkin tidak ada (model virtual murni). </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin penting</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: postulat tidak menunjukkan lokasi objek, keberadaan dan perangkat penyimpanan, bahkan konsep ruang alamat tidak (apalagi satu). Semua yang dapat dikatakan adalah potensi keberadaan ruang ("gelembung"); seseorang dapat diyakinkan tentang keberadaan gelembung itu sendiri hanya dengan kehadiran "kontak". Di dalam "gelembung", semua yang bisa "dinomori" adalah titik kontak. Jika tidak ada kontak, maka ini benar-benar independen dan secara teoritis sama sekali tidak mempengaruhi sistem lain, tetapi pada saat yang sama mereka semua dalam "gelembung" asli dan dapat mulai berinteraksi di masa depan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk tugas pemindahan kepribadian, otak digital akan terlihat seperti satu gelembung umum, termasuk 100 miliar gelembung, yang berisi objek yang mengemulasi neuron atau objek komunikasi dengan otak biologis. </font><font style="vertical-align: inherit;">Secara visual, seseorang bahkan dapat membayangkan peregangan (deformasi proyeksi "gelembung" dalam ruang tiga dimensi) dari benang (akson dendrit) ke titik kontak.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implementasi sistem komunikasi dalam paradigma yang dibuat</font></font></h3><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatian</font></font></b> <br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Semua ide dan algoritma yang dijelaskan dalam artikel ini adalah hasil dari aktivitas intelektual saya yang independen dan sepenuhnya independen. </font><font style="vertical-align: inherit;">Sebagai seorang penulis, saya mengizinkan Anda untuk secara bebas menggunakan, memodifikasi, melengkapi semua ide dan algoritme untuk setiap orang atau organisasi di semua jenis proyek dengan indikasi wajib kepenulisan saya.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk paradigma modern, mewujudkan ruang sebagai cincin satu dimensi cukup sederhana: alamat, data untuk "menulis" - "membaca" dan sinyal "membaca" - "menulis". Untuk paradigma dengan "gelembung" multidimensi, diperlukan untuk menciptakan sistem komunikasi untuk "semua orang dengan semua orang" (dalam batas), tentu saja, dalam kenyataannya ini tidak mungkin. Sebagian besar objek akan terhubung melalui node perantara. Distribusi "jangkauan komunikasi" akan memiliki "tipe normal", semakin kecil jarak antara node, semakin besar jumlah koneksi tersebut (logika dan akal sehat menentukan kebutuhan untuk menandai objek yang berinteraksi sedekat mungkin satu sama lain). Dasar dari sistem komunikasi dengan node perantara adalah algoritma untuk multiplexing (membagi) saluran komunikasi antara beberapa sumber.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertama, lebih baik memberikan penjelasan yang disederhanakan tentang prinsip operasi algoritma multiplexing dari saluran komunikasi fisik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Data yang ditransmisikan dapat direpresentasikan sebagai "hamburan" manik-manik (setiap manik unik dan urutannya tidak dapat diubah), yang harus dikirim melalui tabung dengan diameter sama dengan diameter manik-manik. </font><font style="vertical-align: inherit;">Jika ada satu sumber manik-manik, maka tidak ada masalah akses ke "pipa telekomunikasi", itu adalah milik eksklusif. </font><font style="vertical-align: inherit;">Jika ada banyak sumber manik-manik, maka mereka dapat bertabrakan di pintu masuk ke "tabung", dan bahkan di pintu keluar manik-manik Anda harus memisahkan ke dalam tempat sampah yang terpisah. </font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Algoritma yang diusulkan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (misalnya, bus) terlihat seperti ini:</font></font><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">merangkai manik-manik dari berbagai sumber pada benang elastis dan perbaiki (utas terpisah untuk setiap sumber)</font></font></li>
<li>  ,     ,          (   ).        ,    .</li>
<li>     ,        .</li>
<li>       (  )</li>
<li>       (        )</li>
<li>        :   ,         (        ).</li>
<li> ,           (,    ),    ,        . </li>
<li>          ,       ( ).</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika pada saat diperlukan untuk menempatkan manik dalam tabung, manik belum ditransfer melalui tabung masuk dan hopper kosong, maka untuk memastikan keunikan algoritma penyortiran, Anda perlu menempatkan manik "kosong" khusus sebagai gantinya. Di sisi penerima, manik-manik kosong tidak akan ditempatkan di hopper, tetapi dibuang begitu saja. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Berikutnya adalah teks yang ditargetkan untuk para profesional telekomunikasi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena keinginan untuk mencakup semua aspek dari paradigma telekomunikasi, teks tersebut ternyata agak berantakan dan membengkak. Apa yang membutuhkan pembacaan yang bijaksana, mungkin ada istilah yang tidak akurat dan kesalahan logis (saya akan berterima kasih atas koreksi).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada masalah dengan kesulitan memahami teks, saya ingin menambah deskripsi dengan gambar, tetapi saya tidak memiliki kemampuan untuk menggambar dengan indah. </font><font style="vertical-align: inherit;">Jika seseorang ingin memikul beban seperti itu, saya akan sangat berterima kasih. </font><font style="vertical-align: inherit;">Sebagai tanggapan, saya hanya dapat menawarkan catatan kepengarangan di setiap gambar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berikutnya untuk mereka yang tidak takut</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Keadaan saat ini dari jaringan transmisi data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jaringan transmisi data modern dirancang untuk intensitas koneksi yang relatif rendah (jumlah saluran atau pesan individu) dan pada saat yang sama melemahnya persyaratan simultan dikenakan pada stabilitas waktu, kecepatan pengiriman, waktu pembuatan saluran virtual, waktu yang diperlukan untuk menggunakan jalur transfer data cadangan dan persentase maksimum penggunaan bandwidth saluran fisik. . Jaringan data yang dibangun berdasarkan prinsip-prinsip tersebut secara kritis tidak memenuhi persyaratan yang diajukan oleh paradigma komputasi baru. Untuk memahami skala peningkatan yang diharapkan dalam persyaratan lalu lintas dan kecepatan, Anda dapat mengambil jumlah dan kecepatan data yang dikirimkan melalui tumpukan prosesor dan data terkait dalam memori (pointer paling sering melewati tumpukan) dan dikalikan dengan jumlah inti komputasi dari komputer super khas.Persyaratan ini akan menjadi bar persyaratan yang lebih rendah untuk jaringan data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem komputasi terdistribusi adalah sejumlah besar modul (blok) yang saling berhubungan (berpartisipasi dalam perhitungan bersama) yang menghasilkan, dalam kasus umum, sejumlah besar koneksi jangka pendek. </font><font style="vertical-align: inherit;">Koneksi membutuhkan kecepatan transmisi yang lebih tinggi dikombinasikan dengan latensi rendah, stabil, dan pengiriman yang terjamin. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Persyaratan yang diajukan ke jaringan transmisi data dari perspektif sistem komputer terdistribusi (terdistribusi), kinerja seluruh sistem pada akhirnya tergantung pada implementasi yang mana.</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Waktu pembuatan saluran virtual yang sangat singkat. </font><font style="vertical-align: inherit;">Waktu pembuatan saluran virtual harus sebanding dengan waktu mengisi buffer lokal dari pemancar (router).</font></font></li>
<li>                    .</li>
<li>                      .  ,                 ,     .</li>
<li>           .</li>
<li>  ,              .        ()    .</li>
<li>            (90%  ). </li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idealnya, sistem komunikasi memerlukan koneksi langsung dari masing-masing komponen sistem dengan masing-masing, tetapi pada kenyataannya ini tidak mungkin dan Anda harus mengirimkan data melalui node perantara. Di setiap node jaringan seperti itu ada saklar yang terhubung ke beberapa node yang sama menggunakan jalur komunikasi bersama (ke saluran virtual). Dasar dari sistem komunikasi tersebut adalah algoritma untuk multiplexing (membagi) saluran fisik menjadi sejumlah besar saluran virtual dan mentransfer data antara saluran virtual di berbagai saluran fisik. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma (utama) yang saat ini digunakan (hierarki sinkron dan sistem transmisi data paket) dari pemisahan (multiplexing) saluran fisik tersebut secara kritis tidak memenuhi persyaratan yang diajukan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saluran yang dibuat oleh metode hierarki sinkron (SDH) memiliki kinerja yang sangat baik dalam hal stabilitas kecepatan transmisi, kurangnya tabrakan, dan efek pemanfaatan saluran pada parameter ini. Pada saat yang sama, penundaan transmisi menyisakan banyak yang diinginkan (beroperasi dengan wadah yang cukup besar) dan tidak ada fleksibilitas dalam parameter saluran yang dibuat. Untuk operasi optimal jaringan komputer, waktu tunda (yaitu, waktu transfer data) diperlukan, yang harus ditentukan oleh dua parameter: jarak fisik (panjang kabel) dan sebanding dengan kecepatan transfer data yang diminta. Switch harus dapat secara bersamaan mendukung sejumlah besar saluran virtual (hingga jutaan pada saat yang sama) dengan waktu switching yang konstan. Selain itu, saluran (SHD) tidak memiliki fleksibilitas yang cukup dalam kecepatan saluran yang dibuat,dan waktu yang diperlukan untuk membuat saluran virtual umumnya adalah gambar yang menyedihkan (kita perlu waktu yang sebanding dengan waktu tunda transmisi).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menggunakan packet switching sama sekali tidak masuk akal (bila digunakan dalam bentuk kanonik), tidak satu pun persyaratan terpenuhi sama sekali (untuk sistem komputasi yang cukup besar). Waktu pembuatan saluran hanya dieksekusi sebagian di sisi pemancar, bekerja dengan sejumlah besar kemungkinan rute secara real time tidak disediakan, Anda tidak dapat membuat tabel untuk semua opsi koneksi (ukuran terlalu besar dan biaya administrasi). Keterlambatan dijamin untuk pengiriman data paket pada prinsipnya tidak mungkin. Regulasi kecepatan transfer data dan akses yang dijamin hanya dimungkinkan melalui bandwidth cadangan, yang tidak dimungkinkan dengan sejumlah besar saluran virtual. Kehilangan data (tabrakan) secara fundamental hadir dalam transmisi paket (untuk nilai riil buffer di sakelar).Semua masalah pengiriman data paket secara signifikan diperburuk ketika mendekati kapasitas saluran fisik maksimum.</font></font><br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Untuk operasi optimal dari sistem komputasi terdistribusi, diperlukan paradigma baru dalam membangun sistem transfer data.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dasar dari sistem transmisi data adalah metode (algoritma) untuk membagi satu saluran fisik ke dalam jumlah yang diperlukan virtual dan yang sinkron secara maksimal untuk membangun saluran virtual ujung ke ujung antara penerima dan pemancar. Menurut hasil analisis awal dari situasi, yang paling optimal adalah algoritma SDH. Untuk mengatasi kerugian yang melekat dalam SDH, perlu "mendesain ulang" sistem ini. Algoritma SDH sebagian besar merupakan kelanjutan dari ide-ide yang terkandung dalam PDH, yang tumbuh dari sistem teleponi darat. Untuk sistem komputasi terdistribusi, keberadaan bingkai dengan durasi 125 μs, serta pemisahan ke banyak saluran dengan kinerja yang sama (dan hierarki dengan sinkronisasi ujung-ke-ujung, juga), adalah batasan yang sama sekali tidak masuk akal (untuk telepon semua ini adalah dasar dari dasar-dasar).Untuk sistem komputasi "TK" untuk level terendah dari sistem transfer data adalah sebagai berikut:</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membagi aliran sumber menjadi sejumlah saluran data virtual, dengan bit rate yang diberikan untuk setiap saluran. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk memastikan transfer muatan dari saluran masuk ke saluran keluar, gunakan buffer data dengan ukuran cenderung satu karakter.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada persyaratan eksplisit untuk kehadiran bingkai ukuran konstan atau variabel dan disarankan untuk tidak memperkenalkannya, bahkan sebagai sarana untuk menentukan periode waktu di mana daftar saluran virtual (di mana saluran fisik dibagi) konstan. Jika Anda memperkenalkan konsep bingkai, maka pembuatan saluran tambahan akan membutuhkan waktu, ditentukan oleh ukuran bingkai. Jika tidak ada tindakan tambahan yang diambil, penundaan membuat saluran baru akan rata-rata setengah dari waktu bingkai dikalikan jumlah transit switch, yang secara drastis akan meningkatkan waktu untuk membuat saluran virtual baru (dan menghapus yang lama).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara membagi satu saluran fisik menjadi sejumlah saluran virtual terpisah yang sewenang-wenang dengan laju transmisi sewenang-wenang, tunduk pada aturan jumlah kecepatan (jumlah kecepatan saluran virtual ditambah biaya administrasi saluran tidak boleh melebihi kecepatan saluran primer)?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, persyaratan untuk sinkronisasi, waktu yang sama antara masing-masing data yang dikirimkan, diajukan ke saluran yang dibuat, yang memastikan ukuran minimum buffer. Persyaratan ukuran buffer minimum berasal dari ketidakmampuan untuk mengatur buffer di luar kristal switch di saklar. Cobalah untuk buffer aliran 100G (400G) atau lebih, dan jika ada sepuluh atau seratus aliran seperti itu, bahkan ketidakrataan minimal akan meluap memori dari ukuran yang masuk akal, dan throughput dari RAM yang khas kurang dari kecepatan bahkan satu aliran tersebut. Jika Anda ingin membuat satu saluran virtual (atau beberapa saluran dengan kecepatan transmisi yang sama), maka tidak ada masalah (SDH), tetapi ketika membuat dua saluran atau lebih dengan laju transfer data yang berbeda, konflik dapat terjadi,pada saat yang sama, perlu untuk mengirimkan data milik berbagai saluran virtual. Untuk memenuhi persyaratan sistem transmisi data, kami akan memodifikasi algoritma multiplexing SDH.</font></font><br>
<br>
<h3>   </h3><br>
<ol>
<li>              .</li>
<li>    — .       ,           (    ),     .      :  ,      (). <br>
<br>
            .                        (   ).           (,  ,    ,     ).      (  )  ,      ,      ,      .         .         .    100     ,          .         (   )     (),             .          (     ),             . </li>
<li>   (   )      «»,       .      ,           .      .           ,    .</li>
<li>   «»  (   )           .        (   )          .</li>
<li>            .            .</li>
<li>        ,      (   )          (   ).</li>
<li>      .   (  )       «».      ,     (      ), ,    FIFO   .       ,     ,          ( ).              «» (    ),     FIFO       . <br>
<br>
 ,      (      ),    .    «»    -    .         ,    « ».    « »,    «»              FIFO   .           ,      (  ).     ,   ,       —    ,          ,      (   ). (         )</li>
<li>        32 (24)     64 /,      E1(T1). ,    PHD        .</li>
<li>       .         ( 100)    ( ).     106    .      120 .          2.5  (    )   (  ).. (                .)</li>
<li>  (   )  ,    ( )    «»  « »,       (   ).                 .       «»  « »,      .</li>
<li>        ,     « »               (          ),        « ».         « »,               .            .</li>
<li>      (    )        (         ).          .   « »         ,                () .     « »      ,       .   ,           (  ).        ,      ()   .       ,     ,         .   ,     ,            .</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah transmisi melalui saluran fisik, aliran total harus dibongkar tidak hanya karena pengaturan ulang saluran virtual antara saluran fisik, tetapi juga karena kebutuhan potensial untuk menambah atau menghapus karakter "tidak ada data" (dimungkinkan hanya ketika menulis atau membaca karakter ke buffer). "Pengeditan" sebagian atau penggantian data tidak masuk akal. Anda dapat menambahkan kemampuan untuk membuat aliran total yang tidak dipahami dalam sakelar perantara - sebuah terowongan (terowongan tidak akan memahami komponen-komponen dalam sakelar perantara). Membuat "terowongan" virtual dimungkinkan jika Anda membuat aliran ringkasan menggunakan simbol layanan alternatif (algoritme tetap sama, setiap tingkat terowongan membutuhkan rangkaian simbol layanannya sendiri) dan kemudian mentransfer arus ringkasan yang dihasilkan sebagai saluran virtual biasa.Di sisi penerima, prosedur tambahan diperlukan untuk membongkar saluran tersebut ke dalam komponennya (jumlah analisis sama dengan tingkat "terowongan"). Membuat "terowongan" bermanfaat karena penurunan jumlah saluran virtual dan, oleh karena itu, buffer yang diperlukan dalam sakelar perantara (dan penundaan sakelar yang sebanding dengan kecepatan kanal virtual akan lebih sedikit). Jumlah buffer membatasi jumlah saluran virtual yang melewati sakelar secara bersamaan. Saluran fisik apa pun (untuk penerimaan atau transmisi) dapat menggunakan buffer apa pun (buffer adalah sumber daya bersama), yang meningkatkan koefisien penggunaannya.Secara fisik, buffer adalah FIFO kecil untuk menyimpan beberapa karakter (hingga 10 dan ditentukan pada waktu yang diperlukan untuk membuat saluran virtual baru dan ketidakrataan maksimum waktu transfer data) dengan jumlah antarmuka baca dan tulis sama dengan jumlah modul yang mengumpulkan atau membongkar total saluran dalam sakelar ini (semua fisik dan saluran virtual), sementara ada jaminan tidak lebih dari satu panggilan per siklus jam. Periode sinkronisasi jam buffer bertepatan dengan frekuensi penerimaan dan transmisi karakter. Jika Anda memiliki satu saluran broadband dan sejumlah besar saluran yang lebih kecil, Anda dapat menetapkan karakter besar ke saluran cepat dan menulis beberapa potong data ke buffer sekaligus (atau opsi lain). Arsitektur yang dijelaskan sangat mengalir dengan baik.Ada banyak opsi konfigurasi dan perlu untuk mencari kompromi yang optimal.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika membangun jaringan komunikasi dalam satu chip, modul pemancar akan berubah menjadi dua register (satu di sisi pemancar dan satu di sisi penerima), algoritma itu sendiri tidak akan berubah. Jika kecepatan dan komposisi saluran yang dibuat konstan, maka ukuran perangkat keras sakelar dapat sangat dioptimalkan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara total, jaringan transmisi data terdiri dari sakelar dan kabel komunikasi di antara port-port mereka. Tujuan jaringan adalah untuk memberikan data pelanggan dengan kualitas setinggi mungkin. Klien terhubung ke jaringan melalui perangkat yang mirip dengan saklar biasa, fitur yang membedakan adalah kemampuan untuk mengakses buffer data oleh perangkat keras dari sistem komputasi itu sendiri dan ukurannya yang lebih besar. Segera setelah data yang diterima dari saluran virtual yang dibuat ditulis ke buffer saklar yang terhubung ke sistem komputer (untuk penerimaan), maka mekanisme (mirip dengan gangguan dalam sistem komputer biasa) harus dihidupkan, menunggu informasi muncul cukup untuk menentukan layanan yang dipanggil dan perangkat lunak yang sesuai akan terhubung untuk mempertahankan buffer ini.Perbedaan dari "kartu jaringan" modern adalah kemampuan untuk membuat sejumlah besar saluran paralel (akses paralel ke jaringan data), yang menghilangkan antrian internal paket dari (ke) jaringan ke (dari) sejumlah besar inti komputasi (utas). Otomasi peluncuran "penangan data".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Membuat saluran dapat dibagi menjadi dua tahap: administrasi (pencarian rute, penetapan kecepatan, izin akses, dll.) Dan pembuatan langsung saluran virtual (saat transfer data diperlukan). Tahap pertama dilakukan relatif jarang (jaringan relatif statis) dan ini dapat dilakukan terlebih dahulu pada tahap peluncuran aplikasi. Tahap kedua diperlukan untuk dilakukan secepat mungkin, tahap inilah yang menentukan kinerja jaringan data dan kinerja seluruh sistem komputasi terdistribusi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Secara langsung membuat dan menghapus saluran virtual (semua data yang diperlukan disiapkan pada tahap pertama) harus terjadi pada kecepatan setinggi mungkin. Lebih tepat mengatakan bahwa pembuatan saluran dan transmisi data harus terjadi secara bersamaan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritme akan terlihat seperti ini: pada saat awal waktu, saluran virtual belum ada (bagian pertama dari data ditulis ke buffer yang terkait dengan sumber data), multiplexer belum mengalokasikan bagian dari bandwidth saluran fisik untuk itu, hanya ada saluran layanan dan Anda harus memutuskan yang mana saluran virtual baru akan dibuat dari saluran fisik. Ketika jumlah data yang cukup muncul di buffer untuk membuat saluran virtual (arah dan kecepatan yang diperlukan, mereka dipilih dari daftar alternatif), perlu untuk membentuk dan mengirim (menggunakan saluran layanan) paket data dengan permintaan untuk membuat saluran virtual di saluran fisik yang diinginkan. Paket dengan permintaan dan parameter saluran virtual yang dibuat,melewati perangkat sintesis saluran total pemancar dan mengurai total saluran penerima saluran fisik yang dipilih, mengubah komposisi tabel saluran virtual penerima dan pemancar. Paket dengan parameter harus berisi simbol layanan "tambah saluran", setelah itu pengontrol mulai mentransmisikan aliran total dengan saluran virtual baru yang ditambahkan padanya. Pada saat menambahkan saluran virtual baru, pengambilan sampel data dari buffer dimulai dan karakter saluran virtual yang dibuat dikirim ke sisi router yang dipilih. Saluran baru dibuat tanpa memberi tahu sakelar jarak jauh, hanya berdasarkan bandwidth bebas saluran fisik lokal. Kinerja saluran yang dibuat selalu kurang dari kinerja awal saluran layanan (bagian bebas dari saluran fisik),saluran baru dibuat dengan memisahkan bagian dari sumber daya dari saluran layanan. Saat memproses (menerima dari saluran fisik) paket dengan permintaan untuk membuat saluran virtual baru, perlu untuk menentukan di mana buffer (gratis) yang tersedia untuk mulai menyimpan data saluran baru dalam waktu yang tersisa sebelum menerima simbol "tambahkan saluran". Tidak mungkin untuk menyimpan permintaan dalam memori dan memprosesnya nanti, komposisi aliran total akan segera berubah setelah menerima simbol "buat saluran" (atau dengan penundaan yang diketahui) dan aliran total yang mengandung simbol dari saluran virtual yang dibuat akan mulai diterima, yang akan menghancurkan proses pengodean ulang dari aliran total (jika daftar saluran di penerima Tidak akan berubah). Waktu untuk menghitung jumlah saluran fisik keluar yang diperlukan untuk mulai mengirim data dari buffer yang dialokasikan,harus minimal (ditentukan oleh ukuran buffer), yang berarti bahwa kecepatan dan rute data harus sudah ada di header paket dengan permintaan untuk membuat saluran virtual baru (pada dasarnya tidak ada waktu untuk mengakses tabel di memori eksternal).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pembentukan paket dengan permintaan hanya dimungkinkan setelah menerima semua data yang diperlukan tentang arah perpindahan dan kecepatan saluran yang dibuat. Buffer saluran virtual di sakelar harus berukuran kecil, yang berarti bahwa data ini (kecepatan dan nomor port di sakelar berikutnya) harus berada di bagian paling awal dari data yang dikirimkan, tetapi ukuran buffer saat ini akan memungkinkan semua data selanjutnya disimpan hingga pembentukan saluran total baru tanpa meluap. Setelah paket dengan permintaan terbentuk, Anda perlu menghapus simbol dengan data pada jumlah saluran fisik yang mengarah ke switch berikutnya (jika rute ditentukan dengan menentukan urutan port switch). Untuk menutup saluran virtual, tidak perlu meneruskan paket menggunakan saluran layanan,cukup dengan menempatkan simbol layanan "hapus saluran" dalam data yang ditransmisikan dari saluran yang dihapus. Pada saat menerima simbol "hapus saluran" oleh modul sintesis saluran multipleks, saluran virtual yang sesuai dihapus dan kemudian saluran ringkasan yang diperbarui tidak lagi berisi saluran virtual jarak jauh. Untuk penghapusan otomatis (pembersihan), pencegahan "kebocoran" kinerja saluran fisik, perlu untuk mengintegrasikan ke dalam buffer perangkat keras saluran virtual, penghitung jumlah karakter yang ditransmisikan (apa saja) dan setelah mencapai nilai tertentu (batas waktu) secara otomatis mentransmisikan simbol "saluran dekat". Untuk memperpanjang masa pakai saluran virtual, Anda dapat memasukkan simbol "reset counter" yang ditambahkan ke data. Switch lokal dapat mengabaikan ekstensi masa pakai saluran,yang akan menjadi jawaban atas kurangnya bandwidth saluran fisik. Jika selama pembuatan saluran virtual, itu harus dialihkan ke saluran fisik dengan kekurangan bandwidth gratis, kecepatan saluran layanan tidak cukup untuk membuat saluran virtual baru atau tidak ada buffer gratis atau alasan lain, maka paket permintaan harus dihancurkan. Lebih tepatnya, itu diarahkan ke modul rintisan, yang akan menerima semua karakter saluran virtual yang gagal dan menghasilkan semua pesan yang diperlukan untuk sisi transmisi (pesan-pesan ini dikirim menggunakan saluran layanan). Saya tidak mempertimbangkan opsi dengan buffering karena kompleksitas implementasinya. Pendekatan ini optimal untuk saluran dengan panjang pendek,bagi mereka, batas waktu pengiriman minimal dan tidak akan sangat mempengaruhi kinerja keseluruhan karena pengulangan membuat saluran virtual. Jika saluran berhasil dibuat, maka yang dapat terjadi hanyalah distorsi data karena gangguan pada peralatan. Berbeda dengan jaringan yang ada (Ethernet), perlu tidak hanya mengirim paket, tetapi juga untuk memastikan bahwa paket tersebut berhasil dibangun sampai ke pihak yang dituju, yang sudah berada di tingkat layanan terendah. Mengirim data "ke mana-mana" umumnya tidak memuaskan siapa pun, dan memeriksa pengiriman data dengan menunggu pesan respons sangat "tidak menyenangkan" karena waktu yang tidak diketahui diperlukan. Mengirim pemberitahuan tentang membangun saluran menggunakan saluran layanan, operasi yang tidak memerlukan sumber daya besar.Anda dapat menerapkan opsi lain - segera buat cincin yang menggabungkan sumber dan penerima data yang ditransmisikan (paket akan segera berjalan dalam lingkaran secara keseluruhan atau paket respons akan dibentuk oleh saklar di sisi penerima). Anda dapat membuat notifikasi seperti itu (jika ada kegagalan dalam pembuatan saluran) pada setiap saklar perantara sehingga pemancar akan tahu sesegera mungkin tentang ketidakmungkinan membuat saluran. Jika Anda benar-benar tidak ingin mengirim ulang data ketika tidak mungkin membuat saluran virtual dengan kecepatan yang diperlukan, ini optimal untuk rute dengan waktu pengiriman yang sangat lama (ke sisi lain dunia melalui satelit), maka Anda dapat mencoba menggunakan algoritma pengiriman parsial.Anda dapat membuat notifikasi seperti itu (jika ada kegagalan dalam pembuatan saluran) pada setiap saklar perantara sehingga pemancar akan tahu sesegera mungkin tentang ketidakmungkinan membuat saluran. Jika Anda benar-benar tidak ingin mengirim ulang data ketika tidak mungkin membuat saluran virtual dengan kecepatan yang diperlukan, ini optimal untuk rute dengan waktu pengiriman yang sangat lama (ke sisi lain dunia melalui satelit), maka Anda dapat mencoba menggunakan algoritma pengiriman parsial.Anda dapat membuat notifikasi seperti itu (jika ada kegagalan dalam pembuatan saluran) pada setiap saklar perantara sehingga pemancar akan tahu sesegera mungkin tentang ketidakmungkinan membuat saluran. Jika Anda benar-benar tidak ingin mengirim ulang data ketika tidak mungkin membuat saluran virtual dengan kecepatan yang diperlukan, ini optimal untuk rute dengan waktu pengiriman yang sangat lama (ke sisi lain dunia melalui satelit), maka Anda dapat mencoba menggunakan algoritma pengiriman parsial.maka Anda dapat mencoba menggunakan algoritma pengiriman parsial.maka Anda dapat mencoba menggunakan algoritma pengiriman parsial.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika mustahil untuk membuat saluran dengan kecepatan yang diperlukan, saluran dengan kecepatan lebih rendah dibuat (kemudian saluran dibuat dengan kecepatan ini) dan pada saat saklar buffer overflow, buffer dihapus dan simbol yang menunjukkan buffer overflow dan jumlah karakter yang dibuang ditempatkan di dalamnya. Menerima karakter seperti itu, penerima membentuk daftar pengurangan kecepatan tersebut dan mengirimkannya ke pemancar. Pemancar menurunkan kecepatan saluran primer, menghitung data apa yang dilewati (data yang dilewati dapat ditentukan hanya dari daftar pengurangan kecepatan dan ukuran buffer) dan mengirimkannya dengan cara yang paling optimal (meskipun rute alternatif).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Routing di jaringan packet-switched yang ada didasarkan pada alamat di header paket, tabel rute, dan aturan lain di router perantara. Pendekatan ini bekerja dengan baik untuk sejumlah kecil definisi rute dan kemungkinan buffering data yang diterima dari satu paket, dibutuhkan waktu yang relatif lama untuk menentukan nomor port di mana paket harus dikirim. Untuk sistem berkecepatan tinggi dengan masa pakai saluran virtual yang pendek, tidak akan ada kecepatan akses yang cukup ke memori tabel switching (dan tabel itu sendiri akan memiliki ukuran dalam megabyte untuk setiap saluran fisik - Anda perlu mengalokasikan RAM sama dengan jumlah maksimum saluran virtual yang mungkin) dan lebih menguntungkan untuk menggambarkan rute menggunakan metode langsung. enumerasi saluran fisik,melalui mana saluran virtual harus dibangun. Ukuran informasi alamat tidak akan terlalu besar, jumlah switch menengah relatif kecil dan jika 8 bit (jumlah port fisik atau terowongan) dialokasikan untuk setiap switch, maka analog dari alamat IP6 akan memungkinkan Anda untuk membangun rute 16 switch.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk metode yang diusulkan, tabel diubah menjadi satu byte untuk setiap buffer (yaitu, saluran virtual yang ada, dan tidak berpotensi). Selain itu, perlu untuk mempertimbangkan bahwa alamat tersebut dikirimkan hanya pada saat membuat saluran (secara bertahap dihapus ketika bergerak ke penerima), dan penggunaan terowongan virtual secara signifikan mengurangi biaya routing. Untuk membangun rantai saluran fisik, Anda dapat menggunakan analog mesin pencari konvensional atau DNS dari jaringan modern, mengatur parameter tujuan (serangkaian parameter apa pun: alamat IP juga merupakan parameter normal) dan kami mendapatkan serangkaian rantai dengan rute alternatif. Penanganan relatif telah meningkatkan perlindungan terhadap akses tidak sah, ada kontrol penuh atas rute. Agar jaringan berfungsi,tidak perlu kehadiran wajib (operasi) komponen tingkat tinggi, rute dapat ditetapkan di muka (untuk jaringan dengan sistem komunikasi permanen, sebagai contoh, kabel pada papan sirkuit cetak - koneksi tidak berubah).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kontrol lalu lintas langsung, alokasi (perencanaan) bandwidth, dll. Tidak mungkin karena kecepatan tinggi membuat saluran dan ukuran jaringan yang berpotensi besar. Untuk menyeimbangkan beban saluran, perlu menggunakan metode tidak langsung, seperti merencanakan berbagai rute, menetapkan laju transmisi dengan mempertimbangkan statistik yang terakumulasi pada penggunaan saluran virtual. Ketika saluran fisik kelebihan beban, data dari saluran virtual yang sudah ada tidak dibuang, tidak mungkin untuk hanya membuat saluran baru. Jika kita mempertimbangkan sifat lalu lintas (terutama pesan singkat dan sering), ketersediaan rute cadangan, dan prosedur yang sangat cepat untuk membuat (menghapus) saluran virtual, maka menolak untuk membuat saluran tidak akan menyebabkan penurunan kinerja yang sangat besar,hanya akan ada sedikit penurunan kecepatan perhitungan (pembuatan ulang saluran akan terjadi pada saat pesan tentang kesalahan koneksi atau berakhirnya waktu yang telah ditentukan). Ketika statistik negatif diakumulasikan (yaitu statistik, dan bukan reaksi terhadap peristiwa individual), perangkat lunak manajemen saklar memantau frekuensi kesalahan koneksi dan menjadwalkan parameter saluran dengan mempertimbangkan data ini. Dengan probabilitas tinggi, kemacetan itu sendiri akan berhenti dalam waktu ratusan nanodetik, dan perangkat lunak router harus berurusan dengan masalah perencanaan strategis. Perencanaan tersebut dapat mencakup kemampuan untuk mengedit rute yang telah dibuat (data disimpan dalam multiplexer), jika tidak, tidak mungkin untuk membangun kembali jaringan rute secara andal (ketika perangkat lunak masih meminta penciptaan kembali rute).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Program komunikasi (utas proses komputasi) dengan sumber (penerima) dari data yang dikirimkan dibangun sesuai dengan skema yang sama seperti pada sakelar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sistem komputasi adalah sejumlah besar modul eksekutif yang berbeda yang diintegrasikan oleh jaringan komunikasi. Jaringan komunikasi menggantikan semua bus dan antarmuka lokal dari akses ke memori hingga menghubungkan keyboard.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitektur sistem komputasi ini secara mendasar mengubah keseluruhan paradigma komputasi (masalah ini nantinya akan dipertimbangkan dalam artikel yang menggambarkan struktur sistem operasi dan perangkat lunak). </font><font style="vertical-align: inherit;">Peran peralatan jaringan dalam arsitektur komputasi berubah secara signifikan. </font><font style="vertical-align: inherit;">Jika sebelumnya jaringan itu merupakan cara untuk menghubungkan komputer dan aplikasi terpisah yang berjalan di atasnya, sekarang konsep komputer terpisah pada dasarnya tidak ada dan aplikasi tersebut dapat "tersebar" di berbagai sumber daya perangkat keras jaringan. </font><font style="vertical-align: inherit;">Masalah administrasi (manajemen sumber daya dengan parameter akses sistem komputer) sepenuhnya masuk ke bidang manajemen jaringan yang menghubungkan modul eksekutif individu (tidak ada lagi prosesor sentral).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menanggapi kesalahan transmisi</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Level kontrol kesalahan terendah dapat dianggap sebagai pengkodean karakter yang ditransmisikan dengan kemungkinan pemulihan ketika satu atau lebih kesalahan terjadi (jumlahnya tergantung pada saluran transmisi data). Namun, jika dengan coding, simbol yang keliru (atau sekelompok simbol) tetap muncul, maka sinkronisasi daftar saluran virtual dari pemancar dan penerima akan memiliki efek yang paling tidak menyenangkan. Dengan demikian, permintaan untuk mengubah tabel (membuat atau menghapus saluran) harus memiliki kemungkinan pemulihan maksimum. Jika permintaan itu tetap hilang, maka data semua saluran virtual yang memiliki kecepatan lebih rendah dari kecepatan dalam permintaan akan terdistorsi. Lebih jauh, ada dua opsi untuk merespons, benar-benar memutus semua saluran virtual atau hanya saluran virtual dengan data terdistorsi (dengan kecepatan transfer lebih rendah daripada saluran yang hilang),dalam data yang mengalami distorsi tambahkan simbol "kesalahan" (simbol ini diproses oleh penerima). Jika desync terdeteksi, perlu untuk mengembalikan identitas tabel secepat mungkin, dan waktu pemulihan saluran harus ditentukan oleh panjang kabel (menghubungkan dua sakelar). Pengiriman lengkap tabel dari pemancar ke penerima adalah pilihan yang paling mudah, tetapi lebih baik menambahkan nomor permintaan melingkar ke setiap permintaan pengeditan tabel. Dengan nomor permintaan, tentukan momen desync (angka-angka tidak berurutan) dan buat permintaan untuk mengirim kembali perubahan yang hilang.dan waktu pemulihan saluran harus ditentukan oleh panjang kabel (menghubungkan kedua sakelar). Pengiriman lengkap tabel dari pemancar ke penerima adalah pilihan yang paling mudah, tetapi lebih baik menambahkan nomor permintaan melingkar ke setiap permintaan pengeditan tabel. Dengan nomor permintaan, tentukan momen desync (angka-angka tidak berurutan) dan buat permintaan untuk mengirim kembali perubahan yang hilang.dan waktu pemulihan saluran harus ditentukan oleh panjang kabel (menghubungkan kedua sakelar). Pengiriman lengkap tabel dari pemancar ke penerima adalah pilihan yang paling mudah, tetapi lebih baik menambahkan nomor permintaan melingkar ke setiap permintaan pengeditan tabel. Dengan nomor permintaan, tentukan momen desync (angka-angka tidak berurutan) dan buat permintaan untuk mengirim kembali perubahan yang hilang.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Paradigma komunikasi yang diusulkan dapat digunakan tidak hanya untuk membangun sistem komputasi generasi berikutnya, tetapi juga untuk meningkatkan jaringan yang ada. Sinkronisasi dan kualitas layanan yang tinggi dari saluran komunikasi virtual yang dibuat akan secara optimal menyelesaikan semua masalah transmisi, suara, video (tanpa pudar). Untuk sistem real-time atau sistem keandalan tinggi, antara lain, kemampuan untuk membuat banyak rute alternatif, kontrol ketat atas waktu pembuatan saluran dan pengiriman data sangat berguna. Packet switching dapat ditiru secara transparan oleh paradigma baru, pengiriman paket hanyalah pembuatan saluran sementara, transfer data dan penutupan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Reverse emulation dari jaringan baru dengan packet switching tidak dimungkinkan</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya harap Anda menikmati artikel tentang sistem komunikasi. Jika selama proses membaca ditemukan kesalahan dan tidak ada dok, harap tunjukkan. Saya berharap teks ini akan berfungsi sebagai dasar untuk proyek-proyek baru dan startup yang akan dibeli oleh organisasi besar. Jika ada keinginan untuk mengimplementasikan sistem seperti itu sebagai model HDL di komunitas seperti OpenCores.org, saya akan sangat senang (jangan lupa untuk menunjuk ke sumbernya). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Artikel-artikel berikut akan menjelaskan aspek-aspek lain (bagian) dari paradigma komputasi. Sebuah artikel direncanakan tentang prinsip-prinsip mekanis dalam merancang "avatar".</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Algoritma yang dijelaskan untuk membangun sistem komunikasi dapat menjadi bagian dari keseluruhan yang besar, atau bahkan standar internasional (saya sangat berharap). </font><font style="vertical-align: inherit;">Jika Anda memiliki pertanyaan, saya selalu siap untuk menjawab, memberi saran, dan memeriksa "kepatuhan terhadap garis umum partai" dengan implementasi fisik tertentu.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491620/index.html">Apa yang membuat Cypress hebat untuk pemula otomasi?</a></li>
<li><a href="../id491622/index.html">Memprediksi krisis keuangan dengan Python</a></li>
<li><a href="../id491624/index.html">Membuat Efek Garis Besar di Unity Universal Render Pipeline</a></li>
<li><a href="../id491628/index.html">Spelunky sebagai contoh desain game yang bagus</a></li>
<li><a href="../id491630/index.html">Aplikasi Ekstensi Browser Firefox (WebExtensions)</a></li>
<li><a href="../id491634/index.html">Melindungi dan Meretas Xbox 360 (Bagian 1)</a></li>
<li><a href="../id491636/index.html">Templat GRASP: Pakar Informasi</a></li>
<li><a href="../id491638/index.html">Cloud 1C. Semuanya tidak berawan</a></li>
<li><a href="../id491640/index.html">Akankah Big Data Menepati Janji Mereka?</a></li>
<li><a href="../id491642/index.html">Bagaimana kami membuat video di Alconost dan bagaimana klien berpartisipasi dalam hal ini</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>