<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏼 🚞 👈🏾 Struktur data: daftar yang dapat melakukan segalanya * 🥚 🧛🏿 ⛓️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="* Yang saya maksud adalah eksekusi operasi yang relatif cepat pada satu elemen array. 
 
 Struktur data yang mengimplementasikan daftar sudah lengkap....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Struktur data: daftar yang dapat melakukan segalanya *</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/488778/"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">* Yang saya maksud adalah eksekusi operasi yang relatif cepat pada satu elemen array. </font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur data yang mengimplementasikan daftar sudah lengkap. </font><font style="vertical-align: inherit;">Setiap orang memiliki kelebihan dan kekurangan mereka sendiri. </font><font style="vertical-align: inherit;">Misalnya, di dunia Java - tergantung pada operasi yang diperlukan - Anda dapat menggunakan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (obj), get (obj), set (index, obj): kumpulan dasar dari hampir semua daftar, mis. ArrayList. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">add (index, obj): struktur mirip pohon, mis. TreeList dari koleksi umum apache. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hapus (indeks): sama seperti di atas. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi (obj), indexOf (obj): Anda dapat menggunakan banyak ArrayList dan HashMap. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hapus (keberatan): ... Saya merasa sulit untuk menjawab. </font><font style="vertical-align: inherit;">Dalam beberapa kasus, Anda dapat bertahan dengan LinkedHashSet. </font><font style="vertical-align: inherit;">Ini diselesaikan dengan sepele di hadapan dua poin sebelumnya, tetapi struktur mana yang bisa keduanya dengan cepat?</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ketika saya membutuhkan struktur dengan quick add (obj), get (index), hapus (index) dan indexOf (obj), google tidak memberikan jawaban. Saya tidak menemukan contoh kode atau deskripsi dari struktur tersebut. Mungkin saya tidak melihat di sana, saya harus menciptakannya sendiri. Tetapi jika seseorang menjatuhkan tautan di komentar, saya akan sangat menghargainya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin seseorang menyadari bahwa Anda dapat mengambil TreeList, yang dapat dengan cepat menyisipkan / menghapus item di tengah daftar dan menambahkan HashMap dari objek ke indeks di TreeList untuk eksekusi cepat indexOf (obj). Dan itu akan menjadi keputusan yang sederhana, elegan, tetapi salah. Lagi pula, ketika menambahkan ke tengah atau menghapus dari tengah, akan perlu untuk menghitung ulang indeks, rata-rata, untuk setengah elemen. Ini akan menurunkan kinerja ke O (n).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selanjutnya saya akan berbicara tentang struktur data yang dapat melakukan semua hal di atas. Yang melakukan operasi apa pun pada satu elemen dalam waktu O (log (n)). Yah, hampir - untuk logaritma dilakukan dalam kasus ketika semua objek dalam daftar berbeda. Jika daftar berisi objek yang sama, maka dimungkinkan untuk melorot kinerja hingga O (log (n) ^ 2).</font></font><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya akan segera memperingatkan Anda bahwa saya tidak akan mengecat kode di sini. </font><font style="vertical-align: inherit;">Ini bisa sangat rumit untuk artikel ini. </font><font style="vertical-align: inherit;">Tapi itu, ditulis dalam bahasa Jawa. </font><font style="vertical-align: inherit;">Berdasarkan kelas TreeList dari apache common-collections. </font><font style="vertical-align: inherit;">Permintaan tarik sudah ada, tetapi pada saat penulisan, artikel belum dituangkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Juga, saya tidak akan menjelaskan algoritma yang terkenal. </font><font style="vertical-align: inherit;">Misalnya, algoritma balancing pohon. </font><font style="vertical-align: inherit;">Bagi sebagian besar, mungkin cukup untuk menerima begitu saja fakta bahwa pohon itu dapat tetap seimbang. </font><font style="vertical-align: inherit;">Ini tidak memengaruhi pemahaman akan gagasan umum. </font><font style="vertical-align: inherit;">Mereka yang ingin tahu lebih banyak dapat dengan mudah menemukan informasi. </font><font style="vertical-align: inherit;">Tetapi saya akan memberi tahu Anda secara singkat tentang beberapa hal mendasar, karena tanpa sepengetahuan dasar-dasarnya, banyak elemen kunci tidak dapat dipahami. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tautan akan ada di akhir.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa itu perlu?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Faktanya, tidaklah mudah untuk menemukan situasi di mana semuanya dibutuhkan langsung dari daftar. </font><font style="vertical-align: inherit;">Tidak mungkin bahwa ini adalah semacam struktur yang sangat diperlukan, jika tidak semua orang akan mengetahuinya. </font><font style="vertical-align: inherit;">Namun, beberapa contoh di mana daftar semacam itu dapat bermanfaat dapat diberikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya menyadari bahwa banyak contoh yang dibuat-buat. </font><font style="vertical-align: inherit;">Semua atau hampir semuanya bisa diselesaikan dengan cara lain.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Caching dan kompresi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas awal saya, karena itu saya mulai meneliti masalah ini. </font><font style="vertical-align: inherit;">Dimainkan dengan kompresi data tertentu dan memerlukan daftar untuk cache objek. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Idenya adalah ini: ketika memproses objek lain, kita mencarinya dalam daftar. </font><font style="vertical-align: inherit;">Jika tidak ditemukan, simpan objek dan tambahkan ke bagian atas daftar. </font><font style="vertical-align: inherit;">Jika ditemukan, maka kita ambil indeksnya dalam daftar dan alih-alih objek kita hanya menyimpan indeksnya, setelah itu kita memindahkan objek ke bagian atas daftar. </font><font style="vertical-align: inherit;">Dengan demikian, objek yang terjadi akan sering menerima indeks kecil, dan objek yang muncul hanya sekali akhirnya akan pindah ke akhir daftar dan dihapus.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Belok</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika alih-alih antrian FIFO biasa, untuk beberapa tugas, struktur serupa digunakan, maka operasi berikut dapat dilakukan:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jawab pertanyaan: berapa banyak tugas dalam antrian sebelum tugas ini. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hapus tugas dari antrian. </font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seperti di supermarket. </font><font style="vertical-align: inherit;">Jika Anda datang untuk cokelat, tetapi Anda melihat bahwa garis bergerak lambat, maka mungkin cokelat tidak terlalu dibutuhkan? </font><font style="vertical-align: inherit;">:)</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tabel skor tinggi</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalkan kita ingin menyimpan waktu di mana pemain menyelesaikan level dalam permainan. </font><font style="vertical-align: inherit;">Ada banyak pemain dan mereka semua berlomba, berusaha menunjukkan waktu minimum. </font><font style="vertical-align: inherit;">Data pemain dapat dimasukkan ke dalam array dan diurutkan berdasarkan waktu. </font><font style="vertical-align: inherit;">Dengan menggunakan struktur ini, Anda dapat:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pindahkan pemain lebih tinggi dalam daftar jika mereka menunjukkan hasil yang lebih baik dari sebelumnya. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hapus pemain dari daftar, misalnya, dalam kasus larangan curang. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tunjukkan setiap pemain di mana dia berada. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tampilkan tabel catatan halaman demi halaman. </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perlihatkan tabel yang jarang di beberapa tempat, misalnya, waktu 1, 2, 3, 5, 10, 20, 50, 100, 1000, 10000 tempat. </font></font></li>
</ul><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Struktur data</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur didasarkan pada pohon dengan kunci implisit. </font><font style="vertical-align: inherit;">Pada pendekatan ini, misalnya, bahwa TreeList di-koleksi umum apache didasarkan. </font><font style="vertical-align: inherit;">Untuk melanjutkan, Anda perlu memahami cara kerja struktur ini.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pohon Kunci Tersirat</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pohon terdiri dari node (Nodes). </font><font style="vertical-align: inherit;">Setiap node berisi tautan ke objek yang disimpan di simpul dan 2 tautan ke simpul lain: kiri dan kanan. </font><font style="vertical-align: inherit;">Node paling atas disebut simpul akar. </font><font style="vertical-align: inherit;">Dalam kasus paling sederhana, simpul terlihat seperti ini:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam pohon biner klasik untuk setiap node di subtree kiri, semua objek lebih kecil dari pada node saat ini, dan di kanan - besar. </font><font style="vertical-align: inherit;">Contohnya:</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [ element: 25 ]<font></font>
                           /                 \<font></font>
                          /                   \<font></font>
          [ element: 14 ]                       [ element: 45 ]<font></font>
           /          \                           /          \<font></font>
          /            \                         /            \<font></font>
[ element: 10 ]    [ element: 22 ]     [ element: 27 ]    [ element: 90 ]<font></font>
                    /          \                            /<font></font>
                   /            \                          /<font></font>
            [ element: 17 ] [ element: 23 ]         [ element: 80 ] </code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi untuk tujuan kita, pohon seperti itu tidak cocok. Kita tidak perlu menyimpan objek yang diurutkan, tetapi kita harus memiliki akses ke mereka dengan indeks, seperti dalam array. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana saya bisa meletakkan array di pohon? Mari kita pilih elemen dengan indeks i dari tengah array. Tempatkan elemen engan dari array di node root. 2 sub pohon keluar dari simpul akar. Di subtree kiri kita meletakkan setengah array dengan indeks &lt;i, dan di sebelah kanan dengan index&gt; i. Bagaimana cara melakukannya? Dengan cara yang sama: kita memilih elemen dari tengah dalam sebuah subarray, meletakkan elemen ini dalam sebuah node, kita mendapatkan 2 sub-array yang lebih kecil. Jadi sampai kita meletakkan semua elemen array di node pohon. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, array dengan elemen ["q", "w", "e", "r", "t", "y", "u"] akan terlihat seperti ini:</font></font><br>
<br>
<pre><code class="plaintext hljs">                            [el: r,  size: 7]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, size: 3]           :           [el: y, size: 3]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, size: 1] : [el: e, size: 1] : [el: t, size: 1] : [el: u, size: 1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Elemen tengah dalam array "r", kita letakkan di simpul root. Dua subarrays ["q", "w", "e"] dan ["t", "y", "u"] ditempatkan di sub pohon kiri dan kanan. Untuk ini, elemen-elemen pusat dipilih dari sub-array, dalam kasus kami ini adalah "w" dan "y", dan mereka jatuh ke dalam node dari tingkat berikutnya. Dan seterusnya, </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
dalam kasus kami, pohon seimbang, kedalaman semua sub pohon sama. Tetapi ini tidak harus demikian. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada gambar di atas, setiap node, selain elemen dan tautan ke node kiri dan kanan, berisi jumlah elemen dari seluruh subtree. Informasi ini harus diperbarui dengan benar ketika pohon berubah. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana menemukan, misalnya, elemen dengan indeks = 4 di pohon seperti itu.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mulai merangkak dari simpul root (root, dalam kasus kami dengan elemen "r"). Kami memiliki 3 opsi: kami sudah berada di simpul kanan, simpul kanan di kiri, simpul kanan di kanan. Untuk memahami di mana mencari elemen yang diinginkan, Anda perlu membandingkan ukuran subtree kiri (dalam kasus kami left.size = 3) dan indeks saat ini (dalam kasus kami 4). Jika 2 angka ini sama, maka kami menemukan simpul yang diperlukan dan elemen yang diinginkan di dalamnya. Jika ukuran subtree kiri lebih besar, maka simpul yang diperlukan di subtree kiri. Jika kurang, maka Anda perlu melihat di subtree kanan, tetapi Anda perlu mengurangi indeks yang diinginkan: index = index - left.size - 1. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Karena dalam kasus kami left.size &lt;index, kami mencari subtree kanan untuk elemen dengan indeks baru 4 - 3 - 1 = 0. Pindah ke simpul dengan elemen “y”.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lalu kami melakukan hal yang sama yang kami lakukan pada simpul root. Bandingkan ukuran kiri dan indeks. Karena 1&gt; 0, kita melihat di subtree kiri, pindah ke node dengan elemen "t". </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tidak ada subtree kiri dalam node ini, dan ukurannya adalah 0. index = left.size, yang berarti kami menemukan sebuah node dengan indeks 4 dan kita bisa mendapatkan elemen yang diperlukan "t" dari itu. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kode pseudo, tampilannya seperti ini:</font></font><br>
<br>
<pre><code class="kotlin hljs">function <span class="hljs-keyword">get</span>(node: Node&lt;T&gt;, index: int): T {
  <span class="hljs-keyword">val</span> leftSize: int = (node.left == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : node.left.size;
  <span class="hljs-keyword">if</span> (leftSize == index) {
    <span class="hljs-keyword">return</span> node.obj;<font></font>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leftSize &gt; index) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.left, index);<font></font>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">get</span>(node.right, index — leftSize — <span class="hljs-number">1</span>);<font></font>
  }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya mencoba menjelaskan prinsip utama cara meletakkan array di pohon. </font><font style="vertical-align: inherit;">Struktur seperti itu bekerja, tentu saja, lebih lambat daripada array klasik, untuk O (log (n)) versus O (1). </font><font style="vertical-align: inherit;">Tetapi memiliki keuntungan penting: menambahkan elemen ke tengah atau menghapus dari tengah juga berfungsi untuk O (log (n)) versus O (n) untuk array. </font><font style="vertical-align: inherit;">Tentu saja, asalkan pohonnya kurang lebih seimbang. </font><font style="vertical-align: inherit;">Ada banyak algoritma untuk memelihara pohon dengan cara yang hampir seimbang. </font><font style="vertical-align: inherit;">Misalnya, pohon merah-hitam, pohon AVL, pohon Cartesian. </font><font style="vertical-align: inherit;">Saya tidak akan menuliskan detail balancing tree, algoritma apa pun cocok untuk kita. </font><font style="vertical-align: inherit;">Anggap saja pohon itu seimbang rata-rata dan kedalaman maksimumnya tidak jauh berbeda dari minimum.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Optimasi sedikit</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan yang dijelaskan di atas, dengan memeriksa ukuran pohon di sebelah kiri nyaman untuk persepsi, tetapi dapat dilakukan sedikit lebih efisien. Agar tidak melihat ke subtree kiri setiap kali, alih-alih ukuran pohon, seseorang dapat menyimpan di simpul posisinya relatif terhadap posisi simpul induknya. Simpul root menyimpan posisi absolut yang cocok dengan ukuran subtree kiri.</font></font><br>
<br>
<pre><code class="plaintext hljs">                             [el: r, pos: 3]<font></font>
                           /        :        \<font></font>
                          /         :         \<font></font>
         [el: w, pos: -2]           :           [el: y, pos: +2]<font></font>
           /     :    \             :             /    :     \<font></font>
          /      :     \            :            /     :      \<font></font>
[el: q, pos: -1] : [el: e, pos: +1] : [el: t, pos: -1] : [el: u, pos: +1]<font></font>
        :        :         :        :         :        :         :<font></font>
        :        :         :        :         :        :         :<font></font>
       [q]      [w]       [e]      [r]       [t]      [y]       [u]<font></font>
<font></font>
Index:  0        1         2        3         4        5         6</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, simpul akar "r" memiliki posisi 3. Node "w" memiliki posisi -2 relatif terhadap simpul induk atau posisi absolut 3 + (-2) = 1. Demikian pula, Anda dapat turun satu tingkat lagi, misalnya, simpul "e" memiliki posisi 3 + (-2) + (+1) = 2. Yaitu, </font><font style="vertical-align: inherit;">indeks simpul adalah jumlah posisi dari akar pohon ke simpul ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pengoptimalan ini, selain pencarian yang lebih cepat untuk suatu item dalam daftar, akan menyediakan pencarian yang lebih cepat dan lebih mudah untuk indeks pada node. </font><font style="vertical-align: inherit;">Tapi, tentu saja, memperbarui posisi dengan benar saat mengganti pohon menjadi sedikit lebih sulit.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambahkan Pengindeksan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jadi, di pohon kita dapat mengambil elemen dengan indeks, ubah nilainya, tambahkan elemen ke tengah dan hapus. Pada dasarnya, kita hanya perlu menambahkan pencarian indeks cepat berdasarkan nilai, indexOf (obj). Kemudian berisi (obj) dan menghapus (obj) akan diselesaikan dengan sepele. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tapi pertama-tama, mari sederhanakan tugasnya. Mari kita membuat struktur yang hanya menyimpan elemen unik. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mencari sesuatu dengan cepat, mereka biasanya menggunakan tabel. Di dunia Java, tabel disebut Map, memiliki 2 implementasi utama: HashMap dan TreeMap. Kunci ke tabel akan menjadi tautan ke objek, dan nilainya akan menjadi tautan ke simpulnya:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeListSet</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, Node&lt;T&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Itu struktur terdiri dari dua bagian: daftar pohon itu sendiri dan tabel dengan tautan ke objek dan simpul pohon ini. Saat memperbarui pohon, tabel juga harus diperbarui. Saya tidak akan menjelaskan proses secara rinci. Secara intuitif, ini bisa dimengerti: tambahkan sebuah simpul - letakkan di tabel, hapus simpul - hapus dari tabel. Dalam praktiknya, ada nuansa dengan menyeimbangkan pohon: algoritme harus mengubah tautan antara simpul, dan tidak memindahkan objek di antara simpul. Jika tidak, Anda harus melakukan banyak pembaruan di tabel dan kinerja akan turun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, kami akan menganggap bahwa kami dapat dengan cepat menemukan node oleh elemen yang dikandungnya. Terus? Kita perlu menemukan indeksnya, tetapi ini belum dapat dilakukan. Tetapi kita dapat memperumit kelas simpul sehingga tidak hanya berisi tautan ke simpul kiri dan kanan, tetapi juga ke induknya:</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  obj: T<font></font>
  left: Node&lt;T&gt;<font></font>
  right: Node&lt;T&gt;<font></font>
  parent: Node&lt;T&gt;<font></font>
  pos: int<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentu saja, memperbarui pohon sedikit lebih rumit, karena sekarang kita perlu memperbarui tautan ke orang tua dengan hati-hati. Tapi sekarang, mengetahui simpul, kita bisa naik pohon dan menghitung indeks dari simpul apa pun. Jika kita menggunakan optimasi dari bab sebelumnya, maka kita hanya perlu menghitung jumlah posisi dari node saat ini ke root. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk daftar yang berisi elemen unik, masalah dapat dianggap diselesaikan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Benar, kami punya masalah kecil. </font><font style="vertical-align: inherit;">Misalkan kita sebut set (index, obj). </font><font style="vertical-align: inherit;">Kita dapat dengan mudah mengganti satu elemen dalam satu node dengan yang lain, tetapi hanya jika belum ada elemen baru dalam daftar. </font><font style="vertical-align: inherit;">Dan jika demikian, apa yang harus saya lakukan? </font><font style="vertical-align: inherit;">Hapus kelebihan item dari posisi lama dan masukkan yang baru? </font><font style="vertical-align: inherit;">Atau sebaliknya, tambahkan dulu lalu hapus? </font><font style="vertical-align: inherit;">Hasilnya mungkin berbeda. </font><font style="vertical-align: inherit;">Dan Anda tidak dapat melakukan apa pun atau melemparkan pengecualian. </font><font style="vertical-align: inherit;">Tidak ada solusi yang sempurna. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Menyortir dengan metode standar daftar seperti itu, kemungkinan besar, tidak akan berfungsi baik. </font><font style="vertical-align: inherit;">Lagi pula, algoritma pengurutan tidak akan tahu tentang perlunya keunikan objek dan akan membuat duplikat saat memindahkan item dalam daftar.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menghapus keunikan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, memperumit lebih jauh, mari kita simpan benda yang sama. Jelas, Anda perlu melakukan sesuatu dengan meja. Gagasan pertama untuk menyimpan daftar node di dalamnya tampaknya tidak terlalu bagus: dengan peningkatan panjang daftar, kinerja akan memburuk. Hingga O (n) jika semua item daftar adalah sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian mari kita coba menyimpan pohon node yang diurutkan dalam sebuah tabel alih-alih daftar. Diurutkan berdasarkan posisi dalam daftar.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexedTreeList</span>&lt;<span class="hljs-type">T</span>&gt; </span>{<font></font>
  root: Node&lt;T&gt;<font></font>
  indexMap: Map&lt;T, TreeSet&lt;Node&lt;T&gt;&gt;&gt;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kemudian penyisipan / penghapusan ke / dari TreeSet &lt;Node&gt; ukuran m akan terjadi selama log (m) perbandingan posisi node, dan setiap perbandingan akan terjadi lebih dari waktu log (n). Kompleksitas terakhir dari memasukkan atau menghapus ke dalam struktur yang sama akan terjadi pada O (log (n) * (1 + log (m))), di mana n adalah jumlah total elemen dalam daftar, dan m adalah jumlah elemen dalam daftar yang sama dengan yang dimasukkan / dihapus. Dalam kasus terburuk, ketika semua elemen sama satu sama lain, kita mendapatkan kompleksitas O (log (n) ^ 2).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Seorang pembaca yang penuh perhatian mungkin akan keberatan: tetapi bagaimana dengan kekekalan? </font><font style="vertical-align: inherit;">Lagi pula, kita tidak dapat mengubah objek jika itu adalah tombol tabel? </font><font style="vertical-align: inherit;">Secara umum, itu. </font><font style="vertical-align: inherit;">Namun, untuk pohon yang menyimpan objek yang disortir dalam kunci, selain aturan standar untuk perbandingan, cukup untuk mempertahankan invarian: jika a &lt;b, maka properti ini tidak boleh berubah seiring waktu. </font><font style="vertical-align: inherit;">Ini hanya kasus kami: jika posisi satu node kurang dari posisi node lain, maka properti ini akan dipertahankan terlepas dari berapa banyak node yang ditambahkan atau dihapus di antara mereka.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apakah mungkin untuk membuat struktur bertahan?</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jawaban singkat: tidak, itu tidak mungkin. </font><font style="vertical-align: inherit;">Karena hubungan kedua pohon, dari akar ke daun dan kembali, kami memiliki setiap simpul pohon yang terhubung ke masing-masing. </font><font style="vertical-align: inherit;">Kegigihan tidak dapat dilakukan dengan cara ini, Anda harus membuat ulang seluruh struktur dengan perubahan apa pun. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi saya memiliki pemahaman tentang bagaimana menerapkan struktur persisten untuk kasus-kasus di mana kita tidak perlu memasukkan elemen di tengah daftar. </font><font style="vertical-align: inherit;">Anda dapat menambahkan elemen ke awal atau akhir, dan Anda dapat menghapus dari tengah. </font><font style="vertical-align: inherit;">Properti yang tersisa adalah sama. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda tertarik, maka saya akan mencoba menulis artikel tentang struktur ini. </font><font style="vertical-align: inherit;">Mungkin saya bahkan mengimplementasikannya di Jawa, Kotlin atau Scala. </font><font style="vertical-align: inherit;">Tapi, kemungkinan besar, itu tidak akan segera terjadi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Beberapa fitur implementasi</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini saya ingin menggambarkan beberapa fitur yang harus saya hadapi. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tentang salah satu optimasi tentang menyimpan posisi simpul dalam daftar, saya tulis di atas. Di sini kekuatan dari Open Source dimanifestasikan: Saya mengambil kode TreeList yang sudah jadi dan tidak menyelidiki rincian dari pohon AVL, rotasi node, pembaruan posisi, dll.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Fitur lain yang diwarisi dari TreeList adalah tautan ke sub pohon di daun pohon. Setiap node menyimpan boolean leftIsPrevious dan rightIsNext. Variabel-variabel ini menunjukkan ada atau tidaknya subtree kiri / kanan. Jika tidak ada subtree, maka di kiri / kanan, alih-alih tautan ke subtree, tautan ke node yang sesuai dengan elemen sebelumnya atau berikutnya disimpan. Dalam contoh kita, ["q", "w", "e", "r", "t", "y", "u"] simpul "e" berdaun, ia tidak memiliki sub cabang. Dengan demikian, leftIsPrevious dan rightIsNext benar, dan titik kiri dan kanan ke node "w" dan "r", masing-masing. Pendekatan ini membantu beralih melalui daftar lebih cepat. Dan itu mengganggu pemrograman fitur baru :)</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sedikit tentang bekerja dengan objek tabel → node. Idealnya, Anda perlu memasukkan elemen ke tabel sekali saat menambahkannya ke struktur dan menghapusnya sekali ketika menghapus dari struktur. Dalam praktiknya, saya tidak bisa mencapai ini. Ketika Anda menambahkan item, itu ditambahkan ke tabel, semuanya sudah sebagaimana mestinya. Namun, ketika Anda menghapus item, algoritma balancing terkadang memindahkan item di antara node. Hasilnya adalah dua penghapusan dan satu catatan di tabel, bukan satu penghapusan. Ini dapat diperbaiki jika Anda menghapus optimasi dari leftIsPrevious dan rightIsNext. Dan bahkan mendapatkan keuntungan kinerja kecil, dan tidak hanya selama penghapusan. Dalam beberapa tes, peningkatannya adalah 10-20%. Tetapi kecepatan iterasi turun secara signifikan, 1,5-2,5 kali dalam tes saya. Saya memutuskan untuk meninggalkan optimasi untuk saat ini.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Jawa, jenis tabel utama adalah HashMap dan TreeMap. Untuk tabel, objek → node menggunakan HashMap secara default. Namun, Anda dapat menggunakan TreeMap dengan pembanding khusus tugas. Dalam hal ini, indexOf (obj) dan menghapus (obj) akan mencari / menghapus objek yang sama dengan objek yang ditentukan sesuai dengan kode Comparator. Misalnya, kami menyimpan daftar pengguna, dan pembanding membandingkan pengguna hanya dengan nama. Kemudian kita dapat menjawab pertanyaan "Posisi apa dari daftar tersebut adalah pengguna dengan nama 'Napoleon?'". Atau hapus semua Napoleon dari daftar :). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Struktur tidak mendukung null. Anda dapat memperbaikinya, tetapi tidak ada perasaan bahwa itu perlu.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengenai fakta bahwa struktur “tahu segalanya”, saya, tentu saja, sedikit menyesatkan. </font><font style="vertical-align: inherit;">Tentu saja, ketika bekerja dengan elemen tunggal, semuanya baik-baik saja dan dalam kondisi tertentu bahkan untuk logaritma. </font><font style="vertical-align: inherit;">Namun, dia tidak tahu beberapa hal yang struktur lain bisa. </font><font style="vertical-align: inherit;">Misalnya, pohon Cartesian dengan kunci implisit, ada artikel tentang itu di hub </font><font style="vertical-align: inherit;">Ia tidak tahu bagaimana cara cepat melakukan indexOf, tetapi ia tahu bagaimana membuat sublist dan menggabungkan dua daftar menjadi satu untuk logaritma (rata-rata, tidak dijamin), ditambah lagi dapat dibuat terus-menerus.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Performa</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di Jawa, kinerja biasanya diukur menggunakan kerangka kerja jmh. </font><font style="vertical-align: inherit;">Tes dilakukan pada MacBook Pro 2017 di bawah Java11. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya membandingkan kinerja standar ArrayList, TreeList dari kumpulan-umum apache, dan dua kelas saya IndexedTreeList dan IndexedTreeListSet dalam beberapa skenario. </font><font style="vertical-align: inherit;">Dalam setiap skenario, 1000 operasi dari jenis yang sama dilakukan, sehingga hasilnya harus dikalikan dengan 1000.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode di bawah spoiler</font></font></b><div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-meta">@Fork(1)</span>
<span class="hljs-meta">@Warmup(iterations = 3)</span>
<span class="hljs-meta">@Measurement(iterations = 5)</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceCompare</span> </span>{<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Class&gt; CLASSES = Stream.of(TreeList.class, IndexedTreeListSet.class, IndexedTreeList.class,<font></font>
            ArrayList.class)<font></font>
            .collect(Collectors.toMap(c -&gt; c.getSimpleName(), c -&gt; c));<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ITERATIONS = <span class="hljs-number">1000</span>;<font></font>
<font></font>
    <span class="hljs-meta">@State(Scope.Benchmark)</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plan</span> </span>{<font></font>
<font></font>
        <span class="hljs-meta">@Param({"10", "100", "1000", "10000", "100000", "1000000"/*, "10000000"*/})</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> size;<font></font>
<font></font>
        <span class="hljs-meta">@Param({"ArrayList", "TreeList", "IndexedTreeList", "IndexedTreeListSet"})</span>
        <span class="hljs-keyword">public</span> String className;<font></font>
<font></font>
        <span class="hljs-keyword">private</span> Random random;
        <span class="hljs-keyword">private</span> List&lt;Integer&gt; list;<font></font>
<font></font>
        <span class="hljs-meta">@Setup</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalAccessException, InstantiationException </span>{<font></font>
            random = <span class="hljs-keyword">new</span> Random();<font></font>
            list = (List&lt;Integer&gt;) CLASSES.get(className).newInstance();<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {<font></font>
                list.add(i);<font></font>
            }<font></font>
        }<font></font>
    }<font></font>
<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfKnown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value = list.indexOf(random.nextInt(plan.size));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">indexOfUnknown</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.indexOf(random.nextInt());<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRemoveRandom</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            list.add(random.nextInt(list.size() + <span class="hljs-number">1</span>), random.nextInt());<font></font>
            value += list.remove(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Benchmark</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">(Plan plan, Blackhole blackhole)</span> </span>{<font></font>
        List&lt;Integer&gt; list = plan.list;<font></font>
        Random random = plan.random;<font></font>
        <span class="hljs-keyword">int</span> value = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ITERATIONS; i++) {<font></font>
            value += list.get(random.nextInt(list.size()));<font></font>
        }<font></font>
        blackhole.consume(value);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-meta">@Timeout(time = 1, timeUnit = TimeUnit.MILLISECONDS)</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException </span>{<font></font>
        Options opt = <span class="hljs-keyword">new</span> OptionsBuilder()<font></font>
                .include(PerformanceCompare.class.getSimpleName())<font></font>
                .forks(<span class="hljs-number">1</span>)
<span class="hljs-comment">//                .jvmArgs("-Xms2048m", "-Xmx2048m", "-XX:MaxDirectMemorySize=512M")</span><font></font>
                .build();<font></font>
<font></font>
        <span class="hljs-keyword">new</span> Runner(opt).run();<font></font>
    }<font></font>
}</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk mulai dengan, saya membandingkan kecepatan mendapatkan item acak dari daftar. </font><font style="vertical-align: inherit;">Saya akan segera memperingatkan Anda bahwa dalam pengujian ini biaya overhead sangat signifikan. </font><font style="vertical-align: inherit;">Hasil mendekati 100.000 * 1.000 operasi per detik sangat terdistorsi.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dapatkan hasil tes</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.get                       ArrayList       10  thrpt    5  79865.412 ± 10145.202  ops/s<font></font>
PerformanceCompare.get                       ArrayList      100  thrpt    5  81862.243 ±   983.727  ops/s<font></font>
PerformanceCompare.get                       ArrayList     1000  thrpt    5  81033.507 ±  4540.206  ops/s<font></font>
PerformanceCompare.get                       ArrayList    10000  thrpt    5  64096.123 ±  1430.361  ops/s<font></font>
PerformanceCompare.get                       ArrayList   100000  thrpt    5  41289.491 ± 11286.114  ops/s<font></font>
PerformanceCompare.get                       ArrayList  1000000  thrpt    5   8598.944 ±  2048.461  ops/s<font></font>
PerformanceCompare.get                        TreeList       10  thrpt    5  33912.275 ±  3754.284  ops/s<font></font>
PerformanceCompare.get                        TreeList      100  thrpt    5  21346.854 ±   863.588  ops/s<font></font>
PerformanceCompare.get                        TreeList     1000  thrpt    5  14808.414 ±   508.098  ops/s<font></font>
PerformanceCompare.get                        TreeList    10000  thrpt    5   8679.384 ±   109.250  ops/s<font></font>
PerformanceCompare.get                        TreeList   100000  thrpt    5   4605.998 ±  1028.945  ops/s<font></font>
PerformanceCompare.get                        TreeList  1000000  thrpt    5   2241.381 ±   768.147  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList       10  thrpt    5  34054.357 ±  3682.829  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList      100  thrpt    5  21934.002 ±  2339.947  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList     1000  thrpt    5  14626.691 ±   369.893  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList    10000  thrpt    5   7386.863 ±   342.150  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList   100000  thrpt    5   4562.126 ±   352.772  ops/s<font></font>
PerformanceCompare.get                 IndexedTreeList  1000000  thrpt    5   2105.718 ±   702.064  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet       10  thrpt    5  33317.503 ±  2307.829  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet      100  thrpt    5  21247.440 ±  1253.386  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet     1000  thrpt    5  14665.557 ±   487.833  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet    10000  thrpt    5   7667.214 ±    80.093  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet   100000  thrpt    5   3454.023 ±    82.994  ops/s<font></font>
PerformanceCompare.get              IndexedTreeListSet  1000000  thrpt    5   1768.701 ±    35.878  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, anehnya, minat terbesar adalah ArrayList standar. Secara teoritis, kecepatan keluarnya harus konstan dan tidak tergantung pada jumlah elemen. Dalam praktiknya, kinerja awalnya menampung sekitar 90.000 * 1000 operasi per detik (ingat biaya overhead), tetapi dengan daftar panjang beberapa ribu item mulai melorot. Hal ini disebabkan oleh semakin banyaknya cache yang hilang: cache prosesor tidak memiliki data yang diperlukan dan semakin sering Anda harus mencari data dalam RAM. Dengan sejuta elemen, kecepatan tes 10 kali lebih rendah, tetapi dalam praktiknya, penurunan kinerja bahkan lebih besar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TreeList, IndexedTreeList, dan IndexedTreeListSet diharapkan menunjukkan hasil yang sama. </font><font style="vertical-align: inherit;">Diharapkan jauh lebih lambat daripada ArrayList. </font><font style="vertical-align: inherit;">Bahkan dengan sejumlah kecil elemen, TreeList beberapa kali lebih lambat dari ArrayList, meskipun tes menunjukkan perbedaan hanya 2 kali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tes selanjutnya adalah addRemoveRandom. </font><font style="vertical-align: inherit;">Di sini, di setiap tes, saya memasukkan elemen ke posisi acak dan menghapus elemen dari posisi acak.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil uji AddRemoveRandom</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.addRemoveRandom           ArrayList       10  thrpt    5  12440.764 ±   485.642  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList      100  thrpt    5   9880.123 ±   464.014  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList     1000  thrpt    5   5288.905 ±  1219.055  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList    10000  thrpt    5   1024.942 ±   179.366  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList   100000  thrpt    5     91.219 ±    25.380  ops/s<font></font>
PerformanceCompare.addRemoveRandom           ArrayList  1000000  thrpt    5      5.499 ±     0.400  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList       10  thrpt    5   6242.607 ±   350.290  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList      100  thrpt    5   3117.945 ±   116.066  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList     1000  thrpt    5   1829.778 ±    80.516  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList    10000  thrpt    5   1230.077 ±    53.381  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList   100000  thrpt    5    443.571 ±    69.207  ops/s<font></font>
PerformanceCompare.addRemoveRandom            TreeList  1000000  thrpt    5    308.963 ±    84.077  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList       10  thrpt    5   3556.511 ±   144.596  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList      100  thrpt    5   2120.777 ±    83.848  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList     1000  thrpt    5   1211.112 ±    92.288  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList    10000  thrpt    5    789.458 ±    19.450  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList   100000  thrpt    5    302.989 ±    40.030  ops/s<font></font>
PerformanceCompare.addRemoveRandom     IndexedTreeList  1000000  thrpt    5    178.822 ±    92.853  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet       10  thrpt    5   4138.007 ±   119.943  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet      100  thrpt    5   2435.803 ±    20.276  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet     1000  thrpt    5   1445.054 ±   276.909  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet    10000  thrpt    5    972.256 ±    19.987  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet   100000  thrpt    5    366.608 ±    94.487  ops/s<font></font>
PerformanceCompare.addRemoveRandom  IndexedTreeListSet  1000000  thrpt    5    227.677 ±    48.276  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dapat diasumsikan bahwa ArrayList lebih cepat pada daftar kecil. </font><font style="vertical-align: inherit;">Namun, fakta bahwa ia menang dalam tes ini pada daftar hingga 10.000 elemen terlihat menarik. </font><font style="vertical-align: inherit;">Rupanya, System.arrayCopy dioptimalkan dengan sangat baik dan menggunakan semua fitur prosesor modern. </font><font style="vertical-align: inherit;">Mulai dari 10.000 item, struktur data khusus mulai menang. </font><font style="vertical-align: inherit;">Dengan 1.000.000 elemen, perbedaan kecepatan adalah 30-50 kali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
IndexedTreeList dan IndexedTreeListSet diharapkan lebih lambat dari TreeList. </font><font style="vertical-align: inherit;">Sekitar 1,5 - 2 kali. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sisa 2 tes indexOfKnown dan indexOfUnknown hanya dapat menunjukkan fitur utama dari struktur ini. </font><font style="vertical-align: inherit;">Perbedaan antara tes adalah bahwa dalam satu kasus kami mencari elemen yang ada dalam daftar, dan dalam kasus lain kami mencari elemen yang tidak ada dalam daftar.</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uji hasil indexOfKnown dan indexOfUnknown</font></font></b><div class="spoiler_text"><pre><code class="plaintext hljs">PerformanceCompare.indexOfKnown              ArrayList       10  thrpt    5  41424.356 ±   549.047  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList      100  thrpt    5  17216.477 ±  1444.744  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList     1000  thrpt    5   2296.306 ±    76.372  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList    10000  thrpt    5    233.863 ±    26.926  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList   100000  thrpt    5     23.208 ±     2.776  ops/s<font></font>
PerformanceCompare.indexOfKnown              ArrayList  1000000  thrpt    5      0.919 ±     0.455  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList       10  thrpt    5  26740.708 ±  1323.125  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList      100  thrpt    5   5670.923 ±    99.638  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList     1000  thrpt    5    745.408 ±    26.827  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList    10000  thrpt    5     52.288 ±     1.362  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList   100000  thrpt    5      4.224 ±     0.855  ops/s<font></font>
PerformanceCompare.indexOfKnown               TreeList  1000000  thrpt    5      0.193 ±     0.052  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList       10  thrpt    5  34485.128 ±  1582.703  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList      100  thrpt    5  29209.412 ±  1544.268  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList     1000  thrpt    5  21139.584 ±  1442.867  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList    10000  thrpt    5  12544.306 ±   312.097  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList   100000  thrpt    5   3538.201 ±   272.537  ops/s<font></font>
PerformanceCompare.indexOfKnown        IndexedTreeList  1000000  thrpt    5   1420.119 ±   538.476  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet       10  thrpt    5  39201.995 ±  1887.065  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet      100  thrpt    5  34204.112 ±  1122.517  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet     1000  thrpt    5  25374.557 ±  1596.746  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet    10000  thrpt    5  14291.317 ±   391.180  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet   100000  thrpt    5   4215.898 ±   283.680  ops/s<font></font>
PerformanceCompare.indexOfKnown     IndexedTreeListSet  1000000  thrpt    5   1729.100 ±  1260.815  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList       10  thrpt    5  59053.313 ±  1845.665  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList      100  thrpt    5  10867.572 ±   142.823  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList     1000  thrpt    5   1186.583 ±    28.003  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList    10000  thrpt    5    120.953 ±     4.146  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList   100000  thrpt    5     11.936 ±     0.320  ops/s<font></font>
PerformanceCompare.indexOfUnknown            ArrayList  1000000  thrpt    5      0.566 ±     0.335  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList       10  thrpt    5  28134.237 ±  2291.670  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList      100  thrpt    5   3153.930 ±   158.734  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList     1000  thrpt    5    322.383 ±    44.245  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList    10000  thrpt    5     25.674 ±     1.787  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList   100000  thrpt    5      1.867 ±     0.291  ops/s<font></font>
PerformanceCompare.indexOfUnknown             TreeList  1000000  thrpt    5      0.093 ±     0.008  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList       10  thrpt    5  66625.126 ±  5232.668  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList      100  thrpt    5  70038.055 ±  5803.848  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList     1000  thrpt    5  63240.467 ±   885.956  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList    10000  thrpt    5  54731.988 ±  3950.150  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList   100000  thrpt    5  22049.476 ±   821.924  ops/s<font></font>
PerformanceCompare.indexOfUnknown      IndexedTreeList  1000000  thrpt    5   9459.862 ±   804.738  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet       10  thrpt    5  70274.968 ± 15830.355  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet      100  thrpt    5  71017.685 ±  6920.447  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet     1000  thrpt    5  66405.960 ±  1127.231  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet    10000  thrpt    5  57983.963 ±  3276.142  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet   100000  thrpt    5  41277.110 ±  9919.893  ops/s<font></font>
PerformanceCompare.indexOfUnknown   IndexedTreeListSet  1000000  thrpt    5   9840.185 ±  2159.352  ops/s<font></font>
</code></pre><br>
</div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini, ArrayList dan TreeList hampir tidak memiliki kejutan. Dengan meningkatnya ukuran, kecepatan berkurang hampir secara linear. Pencarian item dari daftar tidak diharapkan 2 kali lebih lambat daripada pencarian item dari daftar, karena Anda harus melalui seluruh array, bukan setengah rata-rata. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi IndexedTreeList dan IndexedTreeListSet di sini menunjukkan hasil yang diharapkan. Struktur data ini menunjukkan kecepatan eksekusi indexOf yang sebanding dengan ArrayList bahkan dengan 10 elemen. Dengan 1000 elemen, struktur ini 10 kali lebih cepat, dengan 1.000.000 lebih cepat 1000 kali. Saat mencari item yang tidak ada dalam daftar, mereka diharapkan untuk memberikan kecepatan yang lebih baik daripada saat mencari item dari daftar.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apa lagi yang menarik untuk diperhatikan adalah penurunan kinerja IndexedTreeList dan IndexedTreeListSet dalam uji indexOfUnknown. </font><font style="vertical-align: inherit;">Di sini situasinya mirip dengan yang di tes dengan ArrayList.get. </font><font style="vertical-align: inherit;">Secara teoritis, kita seharusnya tidak mendapatkan penurunan kinerja, tetapi dalam praktiknya, karena cache miss, kita mendapatkannya, terlebih lagi, secara signifikan.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih sebuah kesimpulan</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saya masih tidak tahu apakah struktur yang diusulkan memiliki hal yang baru atau tidak. Di satu sisi, idenya tidak rumit jika Anda tahu cara kerja pohon dengan kunci implisit. Di sisi lain, saya belum melihat deskripsi struktur dengan properti seperti itu. Dan jika demikian, maka masuk akal untuk membuat struktur lebih terkenal, mungkin berguna bagi seseorang. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tetapi bahkan jika ini adalah motor lain, saya mencoba membuatnya berguna. Permintaan penarikan dalam koleksi umum telah dibuat, tetapi pada saat penulisan artikel ini belum dituangkan. Mengetahui betapa lambatnya segala sesuatu dapat terjadi dalam open source, saya tidak akan terkejut jika proses berlangsung selama berbulan-bulan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agak kaget dengan hasil membandingkan kinerja ArrayList dan TreeList. </font><font style="vertical-align: inherit;">Pengujian menunjukkan bahwa TreeList tidak masuk akal untuk menggunakan hingga 10.000 elemen pada ukuran daftar. </font><font style="vertical-align: inherit;">Akan menarik untuk mencoba b-tree daripada pohon biner. </font><font style="vertical-align: inherit;">Struktur ini harus menggunakan memori lebih hati-hati dan, kemungkinan besar, bekerja lebih cepat. </font><font style="vertical-align: inherit;">Dan untuk itu Anda dapat menyesuaikan ide dengan pengindeksan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam kasus apa pun, menyenangkan memiliki instrumen di gudang yang dapat (hampir) melakukan segalanya dengan kompleksitas yang dapat diprediksi.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referensi</font></font></h2><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Proyek </font></font><br>
</a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">permintaan Tarik </font></font></a><font style="vertical-align: inherit;"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">Asli </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">dalam apache-koleksi umum </font></a></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiket di Jira</font></font></a></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id488758/index.html">Konferensi DEFCON 27. Pengakuan Penipuan Internet</a></li>
<li><a href="../id488762/index.html">Pemrograman asinkron yang elegan dengan janji-janji</a></li>
<li><a href="../id488766/index.html">Seni dan Teknologi: Universitas Massachusetts di Lowell</a></li>
<li><a href="../id488768/index.html">Neraka berdarah, atau Cara bersumpah dalam bahasa Inggris untuk dikira orang yang berbudaya</a></li>
<li><a href="../id488776/index.html">Peningkatan Aksesibilitas di Visual Studio 2019 untuk Mac</a></li>
<li><a href="../id488780/index.html">Mozilla hilang dalam perang browser, tetapi masih percaya itu bisa menyelamatkan Internet</a></li>
<li><a href="../id488782/index.html">Bagaimana Anda menyukai opsi manajemen dependensi ini di Python?</a></li>
<li><a href="../id488784/index.html">Komersialisasi peningkatan perangkat lunak gratis di bawah lisensi Copyleft</a></li>
<li><a href="../id488786/index.html">Seberapa rinci seharusnya cerita pengguna?</a></li>
<li><a href="../id488792/index.html">Memantau ketersediaan situs di Rusia dengan lutut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>