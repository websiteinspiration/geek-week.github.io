<!doctype html>
<html class="no-js" lang="id">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÜüèæ üôÜüèæ ü§π Pemrograman async di .NET: praktik terbaik üëÉüèΩ ‚ÜïÔ∏è üõãÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Munculnya async / menunggu di C # telah menyebabkan redefinisi tentang cara menulis kode paralel yang sederhana dan benar. Seringkali, menggunakan pem...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Pemrograman async di .NET: praktik terbaik</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/jugru/blog/491236/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Munculnya async / menunggu di C # telah menyebabkan redefinisi tentang cara menulis kode paralel yang sederhana dan benar. Seringkali, menggunakan pemrograman asinkron, programmer tidak hanya tidak menyelesaikan masalah yang ada di utas, tetapi juga memperkenalkan yang baru. Kebuntuan dan penerbangan tidak pergi ke mana pun - mereka hanya menjadi lebih sulit untuk didiagnosis. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bu/uz/8g/buuz8gok2hqubwnj1773hwimncq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dmitry Ivanov - Analisis Perangkat Lunak TeamLead di Huawei, mantan techlide JetBrains Rider dan pengembang inti ReSharper: struktur data, cache, multithreading, dan pembicara reguler di konferensi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DotNext</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di bawah cutscene - rekaman video dan transkrip teks dari laporan Dmitry dari konferensi DotNext 2019 Piter.</font></font><br>
<a name="habracut"></a><br>
<iframe width="560" height="315" src="https://www.youtube.com/embed/wM-h6P1BJRk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <br>
<br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Narasi lebih lanjut atas nama pembicara.</font></font></b><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Dalam kode multi-utas atau asinkron, sesuatu sering rusak. Alasannya bisa jadi jalan buntu dan ras. Sebagai aturan, sebuah perlombaan crash sekali dari seribu, seringkali tidak secara lokal, tetapi hanya pada server build, dan dibutuhkan beberapa hari untuk menangkapnya. Saya yakin bagi banyak orang ini adalah situasi yang akrab. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Selain itu, melihat kode asinkron bahkan oleh pengembang berpengalaman, saya mendapati diri saya berpikir bahwa beberapa hal dapat ditulis tiga kali lebih pendek dan lebih tepat.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini menunjukkan bahwa masalahnya bukan pada orang, tetapi pada instrumen. </font><font style="vertical-align: inherit;">Orang-orang hanya menggunakan alat dan ingin menyelesaikan masalah mereka. </font><font style="vertical-align: inherit;">Alat itu sendiri memiliki sejumlah besar kemampuan (kadang-kadang bahkan berlebihan), pengaturan, konteks tersirat, yang mengarah pada fakta bahwa sangat mudah digunakan secara tidak benar. </font><font style="vertical-align: inherit;">Mari kita coba mencari tahu cara menggunakan async / menunggu dan bekerja dengan kelas </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di .NET.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rencana</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah dengan pendekatan yang diselesaikan dengan async / menunggu.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh desain kontroversial.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah tugas dari kehidupan nyata yang akan kita selesaikan secara tidak sinkron.</font></font></li>
</ul><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / menunggu dan masalah yang harus diselesaikan</font></font></h2><br>
<img src="https://habrastorage.org/webt/v1/ym/30/v1ym304jgxmwh_4kymlyqr4wddi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa kita perlu async / menunggu? Katakanlah kita memiliki kode yang berfungsi dengan memori bersama yang dibagikan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pada awal pekerjaan, kami membaca permintaan, dalam hal ini, file dari antrian pemblokiran (misalnya, dari Internet atau dari disk), menggunakan permintaan pemblokiran </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dequeue</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (permintaan pemblokiran akan ditandai dengan warna merah pada gambar dengan contoh). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan ini membutuhkan banyak utas, dan setiap utas membutuhkan sumber daya, membuat beban pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjadwal</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tapi ini bukan masalah utama. Misalkan orang dapat menulis ulang sistem operasi sehingga sistem ini mendukung seratus ribu dan sejuta utas. Tetapi masalah utama adalah bahwa beberapa utas tidak dapat diambil. Misalnya, Anda memiliki utas antarmuka pengguna. Tidak ada kerangka kerja UI normal yang memadai di mana akses ke data tidak hanya dari satu utas, belum. Utas UI tidak dapat diblokir. Dan agar tidak memblokirnya, kita memerlukan kode asinkron. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sekarang mari kita bicara tentang tugas kedua. Setelah kami membaca file, itu perlu diproses. Kami akan melakukannya secara paralel. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Banyak dari Anda telah mendengar bahwa paralelisme tidak sama dengan asinkron. Dalam hal ini, muncul pertanyaan: bisakah asynchrony membantu menulis kode paralel yang lebih kompak, cantik, dan lebih cepat?</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tugas terakhir adalah bekerja dengan memori bersama. </font><font style="vertical-align: inherit;">Apakah kita perlu menyeret mekanisme ini dengan kunci, sinkronisasi ke kode asinkron, atau bisakah ini dihindari? </font><font style="vertical-align: inherit;">Bisakah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bantuan dengan ini?</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan ke async / tunggu</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat evolusi pemrograman asinkron secara umum di dunia dan .NET.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telepon balik</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Void <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {‚Ä¶}<font></font>
 <font></font>
<font></font>
<span class="hljs-function">Void <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ‚Ä¶<span class="hljs-comment">//synchronous code</span><font></font>
 <font></font>
    Foo(<span class="hljs-keyword">params</span>,() =&gt;{<font></font>
       ‚Ä¶<span class="hljs-comment">//asynchronous code;continuation</span><font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pemrograman asinkron dimulai dengan callback. </font><font style="vertical-align: inherit;">Artinya, pertama Anda perlu memanggil beberapa bagian dari kode secara sinkron, dan bagian kedua - secara tidak sinkron. </font><font style="vertical-align: inherit;">Misalnya, Anda membaca dari file, dan ketika data siap, entah bagaimana akan dikirimkan kepada Anda. </font><font style="vertical-align: inherit;">Bagian asinkron ini dilewatkan sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan balik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lebih banyak panggilan balik</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action callback</span>)</span> {...} 
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Bar</span>(<span class="hljs-params">Action callback</span>)</span> {...}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Baz</span>(<span class="hljs-params">Action callback</span>)</span> {...}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
    <font></font>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; { <font></font>
      ... <span class="hljs-comment">//continuation 1 </span><font></font>
      Bar(() =&gt; {<font></font>
        <span class="hljs-comment">//continuation 2</span><font></font>
        Baz(() =&gt; {<font></font>
          <span class="hljs-comment">//continuation 3</span><font></font>
        }); <font></font>
      });<font></font>
    });<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, dari satu panggilan balik Anda dapat mendaftarkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan balik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> lain </font><font style="vertical-align: inherit;">, dari mana Anda dapat mendaftarkan panggilan balik ketiga, dan pada akhirnya semuanya berubah menjadi </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Neraka Panggilan Balik</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bf/vq/8g/bfvq8gknishmtrdwaiixz6mzuvs.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan balik: pengecualian</font></font></h3><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"><span class="hljs-keyword">params</span>, Action onSuccess, Action onFailure</span>)</span> {...}<font></font>
<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OurMethod</span>(<span class="hljs-params"></span>)</span> {<font></font>
    ... <span class="hljs-comment">//synchronous code </span>
    Foo(<span class="hljs-keyword">params</span>, () =&gt; {<font></font>
      ... <span class="hljs-comment">//asynchronous code on success </span><font></font>
    },<font></font>
    () =&gt; {<font></font>
        ... <span class="hljs-comment">//asynchronous code on failure</span><font></font>
    }); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana cara bekerja dengan pengecualian? Misalnya, ReSharper, ketika secara terpisah merespons pengecualian dan eksekusi yang baik, tidak menunjukkan bagian kode yang paling indah - ada panggilan balik terpisah untuk situasi yang luar biasa dan untuk kelanjutan yang sukses. Hasilnya hanya seperti </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">panggilan balik neraka</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , tetapi tidak linier, tetapi seperti pohon, yang bisa sangat membingungkan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lg/hs/y3/lghsy31j9pke1do-8rpmcyuovfq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam .NET, pendekatan panggilan balik pertama disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous Programming Model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (APM). Metode ini akan dipanggil </font></font><code>AsyncCallback</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang pada dasarnya sama dengan </font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi pendekatan tersebut memiliki beberapa fitur. Pertama-tama, metode harus dimulai dengan kata "Mulai" (membaca dari file adalah BeginRead), yang mengembalikan beberapa </font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Diri</font></font><code>AsyncResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah pawang yang tahu bahwa operasi telah selesai dan yang memiliki mekanisme </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda </font></font><code>WaitHandle</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat menunggu, menunggu operasi selesai secara tidak sinkron. Di sisi lain, Anda dapat menelepon </font></font><code>EndOperation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, membuat </font></font><code>EndRead</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan menggantung secara bersamaan (yang sangat mirip dengan properti </font></font><code>Task.Result</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pendekatan ini memiliki sejumlah masalah. Pertama, itu tidak melindungi kita dari </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neraka panggilan balik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Kedua, masih sepenuhnya tidak jelas apa yang harus dilakukan dengan pengecualian. Ketiga, tidak jelas di utas mana panggilan balik ini akan dipanggil - kami tidak memiliki kendali atas panggilan itu. Keempat, muncul pertanyaan, bagaimana menggabungkan potongan kode dengan panggilan balik? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/mr/5z/xr/mr5zxr01ztmadod_fuetd3loqew.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Model kedua disebut </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Asynchronous Berbasis Acara</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah pendekatan panggilan balik reaktif. Ide dari metode ini adalah bahwa kita meneruskan ke metode </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa objek yang memiliki acara Selesai dan berlangganan ke acara ini. Seperti yang Anda perhatikan, </font></font><code>BeginOperationName</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berubah menjadi </font></font><code>OperationNameAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kebingungan dapat terjadi ketika Anda masuk ke kelas Socket, di mana dua pola dicampur: </font></font><code>ConnectAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>BeginConnect</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap dicatat bahwa Anda harus menelepon untuk membatalkan </font></font><code>OperationNameAsyncCancel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Karena dalam .NET ini tidak ditemukan di tempat lain, biasanya semua orang mengirim </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CancellingT s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jadi, jika Anda secara tidak sengaja menemukan metode di pustaka yang berakhir dengan </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda perlu memahami bahwa itu tidak selalu kembali </font></font><code>Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi dapat mengembalikan konstruksi yang sama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6s/w4/4u/6sw44uh3ljw5kwdkowtxylfz5xc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan model yang dikenal di Jawa sebagai</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berjangka</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dalam JavaScript, sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Janji</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dan dalam. NET, sebagai </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Asinkron Tugas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , dengan kata lain, "tugas." Metode ini mengasumsikan bahwa Anda memiliki beberapa objek perhitungan, dan Anda dapat melihat status objek ini (berjalan atau selesai). Dalam. NET, ada </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemisahan dua status yang </font><font style="vertical-align: inherit;">disebut </font><font style="vertical-align: inherit;">nyaman: awal tugas dan penyelesaian tugas. Kesalahan umum terjadi ketika suatu metode dipanggil pada tugas </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang mengembalikan kelanjutan tidak berhasil, tetapi </font></font><code>RnToCompletion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>Faulted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan demikian, hasil mengklik "Batalkan" di aplikasi UI harus berbeda dari pengembalian pengecualian (eksekusi). Di .NET, perbedaan telah dibuat: jika eksekusi adalah kesalahan Anda yang ingin Anda amankan, maka </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Batalkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- operasi paksa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam. NET, sebuah konsep juga diperkenalkan </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- itu adalah semacam abstraksi di atas utas yang memberi tahu di mana harus menjalankan tugas. Dalam hal ini, dukungan pembatalan dirancang pada tingkat desain. Hampir semua operasi di pustaka di .NET memiliki </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dapat diteruskan. Ini tidak berfungsi untuk semua bahasa: misalnya, di Kotlin Anda dapat membatalkan tugas, tetapi di .NET Anda tidak bisa. Solusinya mungkin adalah pembagian tanggung jawab antara mereka yang membatalkan tugas, dan tugas itu sendiri. Ketika Anda menerima tugas, Anda tidak dapat membatalkannya selain secara eksplisit - Anda harus meneruskannya </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objek khusus </font></font><code>TaskCompletionSoure</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memungkinkan Anda untuk dengan mudah menyesuaikan API lama yang terkait dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pola Asinkron Berbasis Kejadian</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Model Pemrograman Asinkron</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ada dokumen yang harus Anda baca jika Anda memprogram dalam tugas. </font><font style="vertical-align: inherit;">Ini menggambarkan semua perjanjian tentang tasas. </font><font style="vertical-align: inherit;">Misalnya, metode apa pun, mengembalikan tugas, harus mengembalikannya dalam keadaan berjalan, yang berarti tidak bisa </font></font><code>Created</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sementara semua operasi tersebut harus berakhir </font></font><code>Async</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggabungkan kelanjutan</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function">Task <span class="hljs-title">ourMethod</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">return</span> Task.RunSynchronously(() =&gt;{<font></font>
    ... <span class="hljs-comment">//synchronous code</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Foo(); <span class="hljs-comment">//continuation 1</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Bar(); <span class="hljs-comment">//continuation 2</span><font></font>
  })<font></font>
  .ContinueWith(_ =&gt;{<font></font>
    Baz(); <span class="hljs-comment">//continuation 3</span><font></font>
  })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Adapun kombinasi, dengan mempertimbangkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">neraka panggilan balik</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , itu dapat muncul dalam bentuk yang lebih linier, meskipun ada potongan kode berulang dengan perubahan minimal. </font><font style="vertical-align: inherit;">Tampaknya kodenya membaik dengan cara ini, tetapi ada jebakan di sini juga.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mulai &amp; lanjutkan tugas</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
  TaskCreationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)<font></font>
Task.ContinueWith(Action&lt;Task&gt;, <font></font>
  TaskContinuationOptions, <font></font>
  TaskScheduler, <font></font>
  CancellationToken<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita beralih ke tiga parameter selama peluncuran tugas standar: yang pertama adalah opsi untuk memulai tugas, yang kedua adalah yang </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana tugas diluncurkan, dan yang ketiga - </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/w_/a4/fw/w_a4fwuiwflisfw-ifxqwtgnpxu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
TaskScheduler memberi tahu di mana tugas dimulai dan merupakan objek yang bisa Anda timpa secara independen. Misalnya, Anda dapat mengganti metode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika Anda melakukannya </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, metode </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengambil benang dari </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengirimkan tugas Anda di sana. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda mengambil </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">alih utas utama, ia menempatkan semuanya dalam satu antrian, dan tugas dieksekusi secara berurutan pada utas utama. Namun, masalahnya adalah. NET Anda dapat menjalankan tugas tanpa melewati </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Timbul pertanyaan: bagaimana. NET menghitung tugas apa yang diberikan padanya? Saat tugas dimulai dari </font></font><code>StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dalam</font></font><code>Action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dipamerkan di salah satu </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang kami berikan padanya. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desain ini tampaknya agak kontroversial karena konteksnya yang implisit. Ada kasus ketika itu </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berisi kode asinkron yang mewarisi suatu tempat yang sangat dalam </font></font><code>TaskScheduler.Current</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan tumpang tindih dengan penjadwal lain, yang menyebabkan kebuntuan. Dalam hal ini, Anda dapat menggunakan opsi </font></font><code>TaskCreationOption.HideScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Ini adalah bel alarm yang mengatakan bahwa kita memiliki beberapa opsi yang mengesampingkan </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pengaturan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semuanya sama dengan kelanjutan. Timbul pertanyaan: dari mana datangnya </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk kelanjutan? Pertama-tama, ini diambil dalam metode di mana Anda memulai </font></font><code>Continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Itu juga </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diambil dari ThreadStatic. Adalah penting bahwa untuk </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu / menunggu,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kelanjutan bekerja dengan sangat berbeda.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/bt/-f/ne/bt-fnekfbdnfmn4n-u3zrvp7bdc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami beralih ke parameter </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>TaskContinuationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Masalah utama mereka adalah ada banyak dari mereka. Beberapa parameter ini saling membatalkan, beberapa lainnya saling eksklusif. Semua parameter ini dapat digunakan dalam semua kombinasi yang memungkinkan, jadi sulit untuk mengingat semua yang dapat terjadi dengan kerinduan. Beberapa opsi ini bekerja sangat tidak bisa dimengerti. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ag/us/wh/aguswhpfaos0qjqvfopo_rr8aeo.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, parameter </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mewakili dua opsi aplikasi yang mungkin, tetapi apakah kelanjutan akan diluncurkan secara serempak atau tidak serempak bergantung pada begitu banyak hal yang tidak akan Anda ketahui. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jm/-c/zv/jm-czv9x4lhhmibfgxqxwjcvxqe.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh lain: kami meluncurkan tugas, meluncurkan kelanjutan dan secara bersamaan memberikan dua parameter</font></font><code>TaskContinuations.ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, setelah itu mereka mulai melanjutkan secara tidak sinkron. </font><font style="vertical-align: inherit;">Apakah akan dieksekusi di tumpukan yang sama di mana tugas sebelumnya berakhir, atau akankah itu ditransfer ke </font></font><code>thread pool</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">Dalam hal ini, akan ada opsi ketiga: itu tergantung.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/vv/j6/8z/vvj68zu1keb_n50viyk4iqbydae.png"><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TaskCompletionSource</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pertimbangkan </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Saat Anda membuat tugas, Anda mengatur hasilnya </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">untuk menyesuaikan pola asinkron sebelumnya dengan dunia tugas. Anda </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat meminta </font></font><code>tcs.Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan tugas ini akan masuk ke kondisi </font></font><code>finish</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat Anda menelepon </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Namun, jika Anda menjalankan ini di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kumpulan utas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda akan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menemui jalan buntu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Pertanyaannya adalah, mengapa jika kita tidak menulis apa pun secara serempak? </font></font><br>
<br>
<img src="https://habrastorage.org/webt/v5/g1/2b/v5g12bn0tycbshdrascqvi-hkug.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami membuat </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, memulai tugas baru, dan kami memiliki utas kedua yang memulai sesuatu dalam tugas ini. Ia pergi dan jatuh ke dalam harapan selama seratus milidetik. Lalu utas utama kami - hijau - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan hanya itu. Dia melepaskan tumpukan, tumpukan hang, menunggu untuk dipanggil dalam kelanjutan</font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">saat </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">terpapar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di utas biru kita sampai </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan kemudian yang paling menarik. </font><font style="vertical-align: inherit;">Berdasarkan pertimbangan internal .NET, ia </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">percaya bahwa kelanjutan dari ini </font></font><code>tcs</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat dilakukan secara serempak, yaitu, langsung pada tumpukan yang sama, maka ini </font></font><code>task.Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dilakukan secara serempak pada tumpukan yang sama. </font><font style="vertical-align: inherit;">Ini sangat aneh, meskipun faktanya kita belum menulis di mana pun </font></font><code>ExecuteSynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini mungkin masalah dengan pencampuran kode sinkron dan asinkron. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/uv/7z/go/uv7zgosoif24okbeyq7fffwdz8o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Masalah lain dengan ini </font></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah bahwa ketika kami memanggil di </font></font><code>SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bawah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Anda tidak dapat memanggil kode arbitrer, karena di bawah kunci Anda hanya dapat melakukan beberapa aktivitas granular kecil. </font><font style="vertical-align: inherit;">Jalankan di bawah beberapa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">aksi-s</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mustahil datang dari tempat asalnya. </font><font style="vertical-align: inherit;">Bagaimana cara mengatasi masalah ini?</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">var</span>  tcs  =  <span class="hljs-keyword">new</span>   TaskCompletionSource&lt;<span class="hljs-keyword">int</span>&gt;(<font></font>
       TaskContinuationsOptions.RunContinuationsAsynchronously  <font></font>
) ;<font></font>
<span class="hljs-keyword">lock</span>(mylock)<font></font>
{  <font></font>
    tcs.SetResult(O); <font></font>
});</code></pre><br><font style="vertical-align: inherit;"></font><code>TaskCompletionSource</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Layak </font><font style="vertical-align: inherit;">
digunakan </font><font style="vertical-align: inherit;">hanya untuk adaptasi </font><font style="vertical-align: inherit;">kode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tugas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak </font><font style="vertical-align: inherit;">di perpustakaan. </font><font style="vertical-align: inherit;">Hampir semuanya bisa diselesaikan melalui menunggu. </font><font style="vertical-align: inherit;">Dalam hal ini, selalu sangat disarankan untuk meresepkan parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"TaskCompletionSource.RunContinuationsAsynchronously"</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anda hampir selalu perlu menjalankan kelanjutan secara tidak sinkron. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda </font></font><code>tcs.SetResult</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">memiliki sesuatu yang tidak dapat meluncurkan apa pun. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/ap/_-/ab/ap_-abu8wjhwxr0edsvayrcc-6w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa kelanjutan harus dilakukan secara serempak? </font><font style="vertical-align: inherit;">Karena </font></font><code>RunContinuationsAsynchronously</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengacu pada yang berikut </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan bukan milik kita. </font><font style="vertical-align: inherit;">Agar dia berhubungan dengan kita, Anda perlu menulis yang berikut: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/qb/zj/6q/qbzj6q1fjhhqozii8yec5ok3pcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Contoh ini menunjukkan bagaimana parameter tidak intuitif, bagaimana mereka bersinggungan satu sama lain, bagaimana mereka memperkenalkan kompleksitas kognitif - sangat sulit untuk menulis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hirarki orangtua-anak</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   })<font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada opsi lain untuk menggunakan parameter. Misalnya, </font><font style="vertical-align: inherit;">hierarki </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orangtua-anak</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> muncul </font><font style="vertical-align: inherit;">ketika Anda meluncurkan satu tugas dan menjalankan yang lain di bawahnya. Dalam hal ini, jika Anda menulis </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan menunggu tugas diluncurkan di dalam. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/gw/se/28/gwse28nxykd4vfwt_chfw0qjt_w.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menulis </font></font><code>TaskCreationOptions.AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu </font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan menunggu. Anda dapat menggunakan properti ini dalam produk Anda. Saya pikir semua orang dapat memberikan contoh di mana ada hierarki tugas, dengan tugas menunggu subtugas, dan subtugas untuk subtugasnya. Tidak perlu menulis di mana pun </font></font><code>WaitForChildren</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tunggu ini terjadi secara serempak. Artinya, tubuh tugas orang tua berakhir, dan setelah itu tugas orang tua tidak dianggap selesai, tidak memulai kelanjutannya sampai tugas anak berhasil.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">// still wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... parent task to attach is in ThreadStatic</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin ada masalah saat tugas ditransfer ke suatu tempat </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka semua yang Anda mulai </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan ditambahkan ke tugas induk ini, yang merupakan bel alarm.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo();<font></font>
}, TaskCreationOptions.DenyChildAttach)<font></font>
.ContinueWith(...) <span class="hljs-comment">// don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
   }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sisi lain, ada opsi yang membatalkan opsi sebelumnya </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Aplikasi semacam itu sering terjadi.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Run(() =&gt; <font></font>
{<font></font>
  <span class="hljs-comment">//... some parent activity</span><font></font>
<font></font>
  Foo(); <font></font>
<font></font>
})<font></font>
.ContinueWith(...) <span class="hljs-comment">//don‚Äôt wait for child</span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
   Task.Factory.StartNew(() =&gt; {<font></font>
      <span class="hljs-comment">//... some child activity</span><font></font>
    }, TaskCreationOptions.AttachedToParent); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perlu diingat bahwa </font></font><code>Task.Run</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ini adalah cara standar untuk memulai, yang secara default menyiratkan </font></font><code>DenyChildAttach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Konteks implisit yang Anda masukkan </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menambah kompleksitas bagi Anda. Anda tidak mengerti bagaimana tugas itu bekerja, karena Anda perlu tahu konteksnya. Masalah lain yang mungkin timbul terkait dengan status siaga async / menunggu. Itu karena di </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda tidak memiliki tugas, tetapi tindakan. Kelanjutan bukanlah tugas yang jujur, tetapi tindakan. Saat Anda menulis kode async / </font></font><code>AttachedToParent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wait </font><font style="vertical-align: inherit;">, Anda tidak perlu menggunakannya </font><font style="vertical-align: inherit;">karena Anda secara eksplisit mengikat tugas-tugas untuk menunggu, dan ini adalah pendekatan yang tepat. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/k7/q5/vg/k7q5vgi8h9qwvvo3akgzow8vu_q.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Anda memiliki enam opsi tentang cara memulai kelanjutan. Anda meluncurkan tugas, diluncurkan</font></font><code>ContinueWith</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pertanyaan: Apa status kelanjutan ini? </font><font style="vertical-align: inherit;">Ada lima kemungkinan jawaban:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kelanjutan umum akan selesai dengan sukses, RunToCompletion akan terjadi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tugas akan salah;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pembatalan akan terjadi;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tugas tidak akan mencapai penyelesaian sama sekali, itu akan menjadi semacam limbo;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">opsi - "tergantung".</font></font></li>
</ul><br>
<img src="https://habrastorage.org/webt/5u/x5/1k/5ux51kwpr4aixg_2io3xroerxam.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal ini, tugas akan berada dalam status "dibatalkan", meskipun tidak ada kata "dibatalkan" di mana pun. </font><font style="vertical-align: inherit;">Di sini kita mengadakan resepsi dan tidak melakukan apa pun. </font><font style="vertical-align: inherit;">Masalahnya adalah ketika Anda membaca kode orang lain dengan banyak opsi - bahkan jika Anda tahu tentang opsi ini 10 menit yang lalu - Anda masih lupa apa yang terjadi di sini. </font><font style="vertical-align: inherit;">Jadi jangan menulis.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pembatalan</font></font></h3><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(); <font></font>
});<font></font>
<font></font>
                                                      Failed</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Parameter ketiga di awal tugas adalah kancellation. </font><font style="vertical-align: inherit;">Anda menulis </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, tindakan khusus yang menempatkan tugas dalam status "Dibatalkan". </font><font style="vertical-align: inherit;">Dalam hal ini, tugas akan berada dalam status "Gagal", karena tidak semua </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sama.</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> OperationCanceledException(cancellationToken); <font></font>
}, cancellationToken);<font></font>
<font></font>
                                                      Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agar tugas dapat dilakukan </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda harus membuangnya </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bersama dengan PembatalanTokennya. </font><font style="vertical-align: inherit;">Pada kenyataannya, Anda tidak pernah secara eksplisit melakukan ini, tetapi lakukan seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    cancellationToken.ThrowIfCancellationRequested(); <font></font>
}, cancellationToken);<font></font>
                                                       Canceled</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah perlu untuk membedakan cancellationToken? </font><font style="vertical-align: inherit;">Di suatu tempat di dalam tugas, Anda memeriksa bahwa seseorang menghapus Anda: membuang pembatalan lemparan, lalu tugas tersebut masuk ke status </font></font><code>Canceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Atau seseorang mengklik "Batalkan" pada waktu berjalan dan membatalkan tugas. </font><font style="vertical-align: inherit;">Latihan kami di JetBrains menunjukkan bahwa Anda tidak perlu membedakan antara token ini. </font><font style="vertical-align: inherit;">Jika Anda mendapatkan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">OperationCanceledException</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - jenis khusus yang terjadi ketika beberapa pembatalan telah terjadi, Anda dapat membedakannya. </font><font style="vertical-align: inherit;">Dalam hal ini, Anda hanya perlu menyelesaikan tugas secara normal, jangan masuk, dan ketika Anda menerima eksekusi - masuk.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tumpukan yang dalam</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
    Foo();<font></font>
}, cancellationToken);<font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { <font></font>
     Bar() {<font></font>
       ...<font></font>
          Baz() {<font></font>
             <span class="hljs-comment">//how to get cancellation token?</span><font></font>
          } <font></font>
    }<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Katakanlah Anda memiliki tumpukan yang dalam. Ini </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">adalah satu-satunya parameter eksplisit yang kami diskusikan. Ini harus ditransmisikan ke mana-mana melalui semua hierarki. Apa yang harus saya lakukan jika, di hadapan hierarki yang mendalam, Anda perlu membatalkan tugas Anda di suatu tempat, pada tingkat yang paling rendah, untuk membuang resepsi? Ada trik khusus yang kami gunakan. Dia dipanggil </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">static</span> AsyncLocal&lt;Cancelation&gt; asyncLocalCancellation;<font></font>
<font></font>
Task.Factory.StartNew(() =&gt; <font></font>
{<font></font>
     asyncLocalCancellation.Set(cancellationToken) <font></font>
    Foo();<font></font>
}, cancellationToken); <span class="hljs-comment">// use AsyncLocal to put cancellation int</span><font></font>
<font></font>
  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>)</span> { 
     <span class="hljs-function"><span class="hljs-keyword">async</span> <span class="hljs-title">Bar</span>(<span class="hljs-params"></span>)</span> {<font></font>
      ...<font></font>
         Baz() {<font></font>
             asyncLocalCancellation.Value.CheckForInterrupt(); <font></font>
         }<font></font>
   } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini sama dengan, </font></font><code>ThreadStatic</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanya yang spesial </font></font><code>ThreadLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang bertahan dari async / menunggu perjalanan kode. </font><font style="vertical-align: inherit;">Karena kode Anda asinkron, dan Anda memiliki kancellation ini, Anda memasukkannya </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan di suatu tempat pada level yang lebih dalam Anda dapat mengatakan " </font></font><code>CheckForInterrupt Throw If Cancellation Requested</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">". </font><font style="vertical-align: inherit;">Sekali lagi, ini adalah satu-satunya parameter </font></font><code>CancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang perlu sepenuhnya mengolesi seluruh kode, tetapi, menurut pendapat saya, untuk sebagian besar tugas Anda hanya perlu tahu apa yang terjadi </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan dari sini menarik kesimpulan yang menyatakan: Dibatalkan atau Gagal.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompleksitas kognitif</font></font></h3><br>
<pre><code class="cs hljs">Task.Factory.StartNew(Action, <font></font>
    TaskCreationOptions, <font></font>
    TaskScheduler, <font></font>
    CancellationToken<font></font>
)<font></font>
                                                   JetBrains.Lifetimes<font></font>
<font></font>
lifetime.Start(TaskScheduler, Action) <span class="hljs-comment">//puts lifetime in AsyncLocal</span><font></font>
<font></font>
lifetime.StartMainRead(Action) <font></font>
lifetime.StartMainWrite(TaskScheduler, Action) <font></font>
lifetime.StartBackgroundRead(TaskScheduler, Action)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Semakin sulit kode dibaca saat memulai tugas, semakin tinggi risiko kesalahan. Melihat kode setelah satu tahun, Anda akan lupa apa yang dilakukannya, karena ada sejumlah besar parameter. Tetapi kami memiliki pustaka </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">JetBrains.Lifetimes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , yang menawarkan masa hidup modern, CancellToken yang dioptimalkan dengan baik, yang dengannya metode Start ditulis ulang dan masalah dengan pengulangan potongan kode dipecahkan, seperti dengan </font></font><code>Task.Factory.StartNew</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>TaskCreationOptions</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada sejumlah kecil penjadwal yang memungkinkan Anda untuk menjadwalkan tugas pada utas utama dengan kunci baca. Artinya, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">baca kunci</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bukanlah sesuatu yang Anda pilih secara eksplisit, itu adalah penjadwal khusus yang menjadwalkan kode Anda pada utas utama dengan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci baca</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, serta utas utama dengan kunci tulis, utas latar belakang - dan sekarang metode menjadi sangat sederhana untuk memulai shuffle. Pada saat yang sama, masa hidup secara otomatis membatalkan </font></font><code>AsyncLocal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, menyederhanakan kode secara signifikan. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/_h/1n/gu/_h1ngucdl-vvbpyyalkk_gwvapu.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mari kita lihat bagaimana cara </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menyinkronkan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> masalah ini, dan masalah apa yang mereka perkenalkan. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam contoh ini, bagian dari kode dieksekusi secara sinkron, kemudian </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan kode asinkron. Pertama, itu baik bahwa ada potongan kode berulang yang jauh lebih sedikit ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">boiler-plate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). Kedua, bagus bahwa kode asinkron sangat mirip dengan kode sinkron, inilah gunanya </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Anda dapat menulis secara tidak sinkron dengan cara yang sama seperti Anda menulis secara sinkron, tanpa mengambil utas.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dalam hal apa kompiler akan digunakan? Kode sinkron akan dieksekusi secara sinkron, setelah itu tugas </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan </font><font style="vertical-align: inherit;">dijalankan secara sinkron </font><font style="vertical-align: inherit;">, dari mana objek GetAwaiter khusus berasal. Dalam hal ini, kami tertarik </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda dapat menulis penunggu untuk objek apa pun. Akibatnya, kami menunggu tugas untuk menyelesaikan </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan secara sinkron melaksanakannya </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jika tugas tidak selesai, maka </font><font style="vertical-align: inherit;">kode </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lanjutan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dijadwalkan pada </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">penjadwal konteks</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Mungkin saja, meskipun Anda menulis </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , semuanya pasti akan dipanggil secara serempak.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
   <span class="hljs-keyword">await</span> InnerAsync();
   <span class="hljs-keyword">await</span> Task.Yield(); <span class="hljs-comment">//guaranteed !IsCompleted </span><font></font>
   continuationCode();<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada satu trik </font></font><code>Task.Yield</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- ini adalah tugas khusus yang memastikan bahwa penantunya tidak akan selalu kembali kepada Anda </font></font><code>IsCompleted</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan demikian, </font></font><code>continuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu tidak akan dipanggil secara serempak di tempat ini. Untuk utas UI, ini bisa menjadi penting karena Anda tidak menggunakan utas ini untuk waktu yang lama. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/jg/jy/7d/jgjy7dh0cnbslfcyk4jpyapc9du.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bagaimana memilih utas untuk kelanjutan? Filosofi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / await</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah </font><font style="vertical-align: inherit;">ini: Anda menulis kode asinkron sama dengan sinkron. Jika Anda memiliki kumpulan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">utas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">tidak </font><font style="vertical-align: inherit;">ada bedanya bagi Anda - continuationCode akan dieksekusi di utas lainnya. Terlepas dari apakah itu </font></font><code>InnerAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selesai ketika Anda mengatakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> atau tidak, Anda perlu segalanya untuk dijalankan di utas UI. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mekanisme untuk tugas menunggu adalah sebagai berikut: itu diambil </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu disebut</font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan darinya diciptakan </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SynchronizationContext</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah sesuatu dengan metode Post, yang sangat mirip dengan metode ini </font></font><code>Queue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bahkan </font></font><code>TaskScheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yang sebelumnya, hanya mengambil </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melalui Post melakukan tugasnya di atasnya.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(<span class="hljs-literal">false</span>);<font></font>
    continuationCode(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada cara untuk mengubah perilaku ini menggunakan parameter </font></font><code>ContinueOnCapturedContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">API paling menjijikkan yang ada di .NET disebut </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dalam hal ini, API membuat penunggu khusus yang berbeda dari </font></font><code>TaskAwaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang menggeser kelanjutan, itu berjalan di utas yang sama, dalam konteks yang sama di mana metode berakhir </font></font><code>InnerAsync </code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan di mana tugas berakhir.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> InnerAsync().ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//code must be absolutely context-agnostic</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada sejumlah saran gila di Internet: jika Anda </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menemui jalan buntu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , mohon apakan semua kode ConfigureAwait Anda dan semuanya akan baik-baik saja. </font><font style="vertical-align: inherit;">Ini cara yang salah. </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dapat digunakan dalam kasus di mana Anda ingin sedikit meningkatkan kinerja, atau di akhir metode, di beberapa metode pustaka.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jalan buntu</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode();<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ini adalah </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kebuntuan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> klasik </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Di utas UI, mereka menunggu sepuluh detik dan melakukannya </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Karena apa yang telah Anda lakukan </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, itu </font></font><code>continuationCode</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tidak akan pernah diluncurkan, </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">oleh karena itu </font><font style="vertical-align: inherit;">, tidak </font><font style="vertical-align: inherit;">akan pernah kembali. </font><font style="vertical-align: inherit;">Semua itu terjadi di awal.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">OnBluttionClick</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span>
  <span class="hljs-keyword">int</span> v = Button.Text.ParseInt();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
  Button.Text.Set((v+<span class="hljs-number">1</span>).ToString());<font></font>
}<font></font>
myFuncAsync().Wait() <span class="hljs-comment">//on UI thread</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bayangkan ini adalah aktivitas nyata. Kami mengklik tombol, mengambilnya </font></font><code>Button.ParseInt</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , menulis, </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami berkata: "Tolong jangan tutup aliran UI kami, lakukan kelanjutan." Masalahnya adalah bahwa kita ingin bagian kedua setelah </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">juga dieksekusi di utas UI, karena ini adalah filosofi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Artinya, kode asinkron Anda terlihat sama dengan kode sinkron, dan berjalan dalam konteks yang sama. Dalam hal ini, tentu saja, akan ada kesalahan. Dan selain </font></font><code>Button.Text.Set</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">itu bisa ada sejumlah panggilan metode yang juga mengasumsikan konteksnya. Apa yang harus dilakukan dalam situasi ini? Kamu bisa melakukan ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <span class="hljs-comment">//UI thread </span><font></font>
  synchronousCode();<font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">10</span>).ConfigureAwait(continueOnCapturedContext: <span class="hljs-literal">false</span>); <font></font>
    continuationCode(); <span class="hljs-comment">//The same UI context</span><font></font>
}<font></font>
PumpUntil(() =&gt; task.IsCompleted);<font></font>
<span class="hljs-comment">//VS synchronization contexts always pump on any Wait</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan utas UI, Anda harus melarang melakukannya </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pada utas yang memiliki antrian pesan umum. Alih-alih melakukan </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">atau menulis </font></font><code>ConfigureAwait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda dapat memompa antrian pesan ini, dan pada saat yang sama, kontinum juga akan dipompa. Jika Anda tidak dapat mencampur kode sinkron dan asinkron, maka Anda tidak boleh mencampurnya. Namun terkadang ini tidak bisa dihindari. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, Anda memiliki kode lama, dan Anda harus mencampurnya, lalu Anda memompa aliran UI. Visual Studio memompa utas UI sesuai harapan, bahkan </font></font><code>SynchronizationContext</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sedikit berubah. Jika Anda masuk ke WaitHandle di mana saja </font></font><code>Wait</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, maka ketika Anda hang, aliran UI Anda dipompa. Dengan demikian, mereka memilih antara </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kebuntuan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan ras demi ras. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pumpuntil</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- Ini adalah API yang tidak ideal, yaitu, ketika Anda melakukan kontinuitas acak di tempat yang sewenang-wenang, mungkin ada nuansa. </font><font style="vertical-align: inherit;">Sayangnya, tidak ada cara lain. </font><font style="vertical-align: inherit;">Campur kode sinkron dan asinkron. </font><font style="vertical-align: inherit;">Jika ada, seluruh Penunggang begitu diatur di tempat-tempat lama, jadi kadang-kadang ada nuansa juga.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ubah konteks</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> myTaskScheduler;<font></font>
    continuationCode(); <span class="hljs-comment">//on scheduler context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada cara lain yang menarik untuk menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async / menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Anda dapat menulis </font></font><code>Awaiter</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tentang </font></font><code>scheduler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan melompat pada benang. </font><font style="vertical-align: inherit;">Saya membaca posting di Visual Studio, mereka menulis untuk waktu yang sangat lama bahwa tidak baik untuk bolak-balik di tengah metode, tetapi sekarang mereka melakukannya sendiri. </font><font style="vertical-align: inherit;">Visual Studio memiliki API yang melompat pada utas melalui penjadwal. </font><font style="vertical-align: inherit;">Untuk penggunaan normal, melakukan ini tidak baik.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Konkurensi terstruktur</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyFuncAsync</span>(<span class="hljs-params"></span>)</span> { <font></font>
  synchronousCode(); <span class="hljs-comment">// on initial context</span><font></font>
<font></font>
    <span class="hljs-keyword">await</span> Task.Factory.StartNew(() =&gt; {...}, myTaskScheduler);<font></font>
    continuationCode(); <span class="hljs-comment">//on initial context </span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Untuk perendaman yang nyaman dalam konteks baru dan kembali ke yang lama, beberapa kompetisi struktural, atau paralelisme struktural, harus dibangun. </font><font style="vertical-align: inherit;">Misalnya, pada tahun enam puluhan, operator GoTo dianggap berbahaya karena melanggar strukturalitas. </font><font style="vertical-align: inherit;">Jadi di sini. </font><font style="vertical-align: inherit;">Melompat dengan benang melanggar struktur. </font><font style="vertical-align: inherit;">Anehnya, menggunakan mesin negara async sepertinya jalan keluar yang bagus. </font><font style="vertical-align: inherit;">Yaitu, di mana struktur biasa Anda dilanggar, Anda melompat di GoTo, Anda dapat melanggar struktur utas: jangan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , </font><font style="vertical-align: inherit;">campur </font><font style="vertical-align: inherit;">dengan tag. </font><font style="vertical-align: inherit;">Ini adalah situasi yang sangat aneh dan langka ketika Anda perlu melakukan ini. </font><font style="vertical-align: inherit;">Namun, lebih baik ketika </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kembali ke konteks yang sama. </font><font style="vertical-align: inherit;">Dengan demikian, kumpulan utas tidak akan memiliki utas yang sama, tetapi konteks yang sama seperti aslinya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku berurutan</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mengapa </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">menunggu</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tidak sama dengan eksekusi paralel? </font><font style="vertical-align: inherit;">Menunggu eksekusi adalah eksekusi berurutan. </font><font style="vertical-align: inherit;">Dalam hal ini, kami memulai tugas pertama, tunggu, mulai tugas kedua - kami menunggu. </font><font style="vertical-align: inherit;">Kami tidak memiliki paralelisme. </font><font style="vertical-align: inherit;">Untuk sebagian besar kegunaan, paralelisme tidak diperlukan. </font><font style="vertical-align: inherit;">Paralelisme itu sendiri lebih kompleks daripada urutan. </font><font style="vertical-align: inherit;">Kode serial lebih sederhana daripada paralel, ini adalah aksioma. </font><font style="vertical-align: inherit;">Tetapi kadang-kadang Anda perlu menjalankan sesuatu dalam kode paralel, dan Anda melakukannya seperti ini:</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">await</span> task1;<font></font>
<font></font>
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perilaku serentak</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async();<font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Di sini tugas dimulai secara paralel. </font><font style="vertical-align: inherit;">Jelas bahwa metode dapat mengembalikan tugas segera dalam keadaan berjalan, maka tidak akan ada paralelisme. </font><font style="vertical-align: inherit;">Misalkan saja kedua tasky melakukan eksekusi. </font><font style="vertical-align: inherit;">Dan Anda menunggu tugas pertama, lalu pada menunggu pertama berangkat. </font><font style="vertical-align: inherit;">Artinya, segera setelah Anda menulis </font></font><code>await task1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda lepas landas dan tidak memproses </font></font><code>exception task2</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Menariknya, ini adalah kode yang benar-benar valid. </font><font style="vertical-align: inherit;">Dan kode inilah yang menyebabkan .NET pada fakta bahwa dalam versi 4.5 perilaku bekerja dengan eksekusi telah berubah.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Penanganan pengecualian</font></font></h3><br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">MyAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> task1 = StartTask1Async();
  <span class="hljs-keyword">var</span> task2 = StartTask2Async(); <font></font>
<font></font>
  <span class="hljs-keyword">await</span> task1;
  <span class="hljs-keyword">await</span> task2;<font></font>
<font></font>
  <span class="hljs-comment">// if task1 throws exception and task2 throws exception we only throw and</span>
  <span class="hljs-comment">// handle task1‚Äôs exception</span><font></font>
<font></font>
  <span class="hljs-comment">//4.0 -&gt; 4.5 framework: unhandled exceptions now don‚Äôt crush process</span>
  <span class="hljs-comment">//still visible in UnobservedExceptionHandler</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sebelumnya, eksekusi tidak tertangani hanya membuang proses, dan jika Anda tidak menangkap beberapa eksekusi </font></font><code>UnobservedExceptionHandler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(ini juga beberapa </font></font><code>static</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang dapat Anda lampirkan pada penjadwal), maka proses ini tidak dieksekusi. Sekarang ini adalah kode yang benar-benar valid. Meskipun .NET mengubah perilakunya, tetap mempertahankan pengaturan untuk mengembalikan perilaku ke arah yang berlawanan.</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword">async</span>  Task  <span class="hljs-title">MyAsync</span>(<span class="hljs-params">CancellationToken cancellationToken</span>)</span>  {  <font></font>
<font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">SomeTask1  <span class="hljs-title">Async</span>(<span class="hljs-params">cancellationToken</span>)</span>; <font></font>
 <font></font>
  <span class="hljs-keyword">await</span>  <span class="hljs-function">Some <span class="hljs-title">Task2Async</span>(<span class="hljs-params"> cancellation  Token</span>)</span>; 
  <span class="hljs-comment">//you should always pass use async API with cancelationToken  if possible </span><font></font>
} <font></font>
  <font></font>
<span class="hljs-keyword">try</span> { 
    <span class="hljs-keyword">await</span>  MyAsync( cancellation  Token); <font></font>
} <span class="hljs-keyword">catch</span> (OperationException e) { <span class="hljs-comment">// do nothing: OCE happened</span>
} <span class="hljs-keyword">catch</span> (Exception e) { <font></font>
    log.Error(e);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lihat bagaimana pemrosesan eksekusi berjalan. </font><font style="vertical-align: inherit;">PembatalanToken-s harus ditransmisikan, perlu untuk "smear" PembatalanToken-s semua kode. </font><font style="vertical-align: inherit;">Perilaku normal async adalah Anda tidak memeriksa di mana pun </font></font><code>Task.Status ancellationToken</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, Anda bekerja dengan kode asinkron dengan cara yang sama seperti dengan sinkron. </font><font style="vertical-align: inherit;">Yaitu, dalam kasus pembatalan, Anda mendapatkan eksekusi, dan dalam kasus ini, Anda tidak melakukan apa pun ketika Anda menerimanya </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Perbedaan antara status Dibatalkan dan Kesalahan adalah bahwa Anda tidak menerima </font></font><code>OperationCanceledException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tetapi eksekusi biasa. </font><font style="vertical-align: inherit;">Dan dalam hal ini, kita bisa menjanjikannya, Anda hanya perlu mendapatkan eksekusi dan menarik kesimpulan berdasarkan ini. </font><font style="vertical-align: inherit;">Jika Anda memulai tugas secara eksplisit, melalui Tugas, Anda akan diterbangkan </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dan di async, dalam kasus ini mereka </font></font><code>AggregateException</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">selalu membuang eksekusi pertama yang ada di dalamnya (dalam hal ini - </font></font><code>OperationCanceled</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">).</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam praktek</font></font></h2><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode sinkron</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SynchronousWorker</span>(<span class="hljs-params">...</span>)</span> {<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Misalnya, setan berfungsi di ReSharper - editor yang memberi warna pada file untuk Anda. </font><font style="vertical-align: inherit;">Jika file dibuka di editor, maka ada beberapa aktivitas yang menempatkannya dalam antrian pemblokiran. </font><font style="vertical-align: inherit;">Proses kami </font></font><code>worker</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">membaca dari sana, setelah itu melakukan banyak tugas yang berbeda dengan file ini, mewarnai, mem-parsing, membangun, setelah itu file-file ini ditambahkan </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Dengan </font></font><code>sharedMemory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kunci, mekanisme lain sudah bekerja dengannya.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Metode asinkron</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Saat menulis ulang kode menjadi asinkron, pertama-tama kita akan menggantinya </font></font><code>void</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dengan </font></font><code>async Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Pastikan untuk menulis kata "Async" di akhir. </font><font style="vertical-align: inherit;">Semua metode asinkron harus diakhiri dengan Async - ini adalah konvensi.</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = blockingQueue.Dequeue(); <font></font>
<font></font>
  ProcessedFile p = ProcessInParallel(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Setelah itu, Anda perlu melakukan sesuatu dengan kami </font></font><code>blockingQueue</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Jelas, jika ada beberapa primitif sinkron, maka harus ada beberapa primitif asinkron. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/-6/zk/8i/-6zk8ilnmdsonzd6zkafkcloqyi.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Primitif ini disebut saluran: saluran yang hidup dalam paket </font></font><code>System.Threading.Channels</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Anda dapat membuat saluran dan antrian, terbatas dan tidak terbatas, yang dapat Anda tunggu secara tidak sinkron. Selain itu, Anda dapat membuat saluran dengan nilai "nol", artinya tidak memiliki buffer sama sekali. Saluran semacam itu disebut saluran pertemuan dan secara aktif dipromosikan di Go dan Kotlin. Dan pada prinsipnya, jika dimungkinkan untuk menggunakan saluran dalam kode asinkron, ini adalah pola yang sangat bagus. Artinya, kami mengubah antrian ke saluran tempat ada metode </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan </font></font><code>WriteAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br>
<br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ProcessInParallel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah sekelompok kode paralel yang melakukan pemrosesan file dan mengubahnya menjadi</font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Bisakah async membantu kita menulis bukan asinkron, tetapi kode paralel lebih kompak?</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sederhanakan Kode Paralel</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode dapat ditulis ulang dengan cara ini:</font></font><br>
<br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
  <span class="hljs-keyword">lock</span> (_lock) { <font></font>
    sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
  } <font></font>
}</code></pre><br>
<img src="https://habrastorage.org/webt/e0/zt/8u/e0zt8ud_8b4_wsiqsrd9_baalwy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mereka seperti apa </font></font><code>ProcessInParallel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">? Sebagai contoh, kami memiliki file. Pertama, kita memecahnya menjadi leksem, dan kita dapat memiliki dua tugas secara paralel: membangun cache pencarian dan membangun pohon sintaksis. Setelah itu muncul tugas "mencari kesalahan semantik." Penting di sini bahwa semua tugas ini membentuk grafik asiklik terarah. Artinya, Anda dapat menjalankan beberapa bagian dalam utas paralel, sebagian tidak bisa, dan jelas ada ketergantungan tugas mana yang harus menunggu untuk tugas lain. Anda mendapatkan grafik dari tugas-tugas tersebut, Anda ingin entah bagaimana menyebarkannya di sepanjang utas. Apakah mungkin untuk menulisnya dengan indah, tanpa kesalahan? Dalam kode kami, masalah ini diselesaikan beberapa kali, setiap kali dengan cara yang berbeda. Jarang terjadi ketika kode ini ditulis tanpa kesalahan.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/xh/-h/3j/xh-h3jav69twzsqei3rrjbe2ymy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kami mendefinisikan grafik tugas ini sebagai berikut: misalkan setiap tugas memiliki tugas lain yang bergantung padanya, kemudian menggunakan kamus ExecuteBefore kami menulis kerangka metode kami.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi kerangka</font></font></h3> <br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore; <span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();<font></font>
<font></font>
<font></font>
  <span class="hljs-comment">// lots of work with toposort, locks, etc.</span><font></font>
<font></font>
  <span class="hljs-keyword">return</span> res; <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda menyelesaikan masalah ini secara langsung, maka Anda perlu melakukan pengurutan topologi dari grafik ini. </font><font style="vertical-align: inherit;">Kemudian ambil tugas yang tidak memiliki tugas yang tergantung, jalankan, analisis struktur di bawah kunci, lihat tugas mana yang tidak memiliki yang tergantung. </font><font style="vertical-align: inherit;">Jalankan, sebarkan mereka entah bagaimana </font></font><code>Task Runner</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Kami menulisnya sedikit lebih kompak: pengurutan topologi dari grafik + pelaksanaan tugas-tugas tersebut pada utas yang berbeda.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async malas</font></font></h3><br>
<pre><code class="cs hljs">Dictionary&lt;Action&lt;ProcessedFile&gt;, Action&lt;ProcessedFile&gt;[]&gt; ExecuteBefore;
<span class="hljs-function"><span class="hljs-keyword">async</span> Task&lt;ProcessedFile&gt; <span class="hljs-title">ProcessInParallelAsync</span>(<span class="hljs-params"></span>)</span> {
  <span class="hljs-keyword">var</span> res = <span class="hljs-keyword">new</span> ProcessedFile();
  <span class="hljs-keyword">var</span> lazy = <span class="hljs-keyword">new</span> Dictionary&lt;Action&lt;ProcessedFile&gt;, Lazy&lt;Task&gt;&gt;(); 
  <span class="hljs-keyword">foreach</span> ((action, beforeList) <span class="hljs-keyword">in</span> ExecuteBefore)<font></font>
    lazy[action] = <span class="hljs-keyword">new</span> Lazy&lt;Task&gt;(<span class="hljs-keyword">async</span> () =&gt; <font></font>
    {<font></font>
      <span class="hljs-keyword">await</span> Task.WhenAll(beforeList.Select(b =&gt; lazy[b].Value)) 
      <span class="hljs-keyword">await</span> Task.Yield();<font></font>
      action(res);<font></font>
}<font></font>
  <span class="hljs-keyword">await</span> Task.WhenAll(lazy.Values.Select(l =&gt; l.Value)) 
  <span class="hljs-keyword">return</span> res;<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ada pola yang disebut </font></font><code>Async Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami membuat milik kami </font></font><code>ProcessedFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana berbagai tindakan harus dijalankan. Mari kita membuat kamus: kita akan memformat setiap tahap kita (Action ProcessedFile) menjadi beberapa Tugas, atau lebih tepatnya, ke Malas dari Tugas dan berjalan di sepanjang grafik asli. Variabel </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">akan memiliki </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tindakan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> itu sendiri </font><font style="vertical-align: inherit;">, dan di beforeList - tindakan-tindakan yang harus dilakukan sebelum kita. Lalu buat </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari </font></font><code>action</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami menulis di Tugas </font></font><code>await</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan demikian, kami menunggu semua tugas yang harus diselesaikan sebelum itu. Di beforeList, pilih </font></font><code>Lazy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">yang ada di kamus ini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Harap perhatikan bahwa di sini tidak ada yang akan dijalankan secara sinkron, sehingga kode ini tidak akan jatuh </font></font><code>ItemNotFoundException in Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Kami melakukan semua tugas yang ada di hadapan kami, melakukan pencarian dengan tindakan</font></font><code>Lazy Task</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Lalu kami melakukan tindakan kami. </font><font style="vertical-align: inherit;">Pada akhirnya, Anda hanya perlu meminta setiap tugas untuk memulai, jika tidak, Anda tidak akan pernah tahu jika sesuatu tidak dimulai. </font><font style="vertical-align: inherit;">Dalam hal ini, tidak ada yang dimulai. </font><font style="vertical-align: inherit;">Ini solusinya. </font><font style="vertical-align: inherit;">Metode ini ditulis dalam 10 menit, sangat jelas. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dengan demikian, kode asinkron membuat keputusan kami, awalnya ia menempati beberapa layar dengan kode kompetitif yang kompleks. </font><font style="vertical-align: inherit;">Di sini dia sangat konsisten. </font><font style="vertical-align: inherit;">Saya bahkan tidak menggunakannya </font></font><code>ConcurrentDictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, saya menggunakan yang biasa </font></font><code>Dictionary</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, karena kami tidak menulis apa pun untuk itu secara kompetitif. </font><font style="vertical-align: inherit;">Ada kode yang konsisten dan konsisten. </font><font style="vertical-align: inherit;">Kami memecahkan masalah penulisan kode paralel menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">async-s dengan</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> indah, yang berarti - tanpa bug.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Singkirkan kunci</font></font></h3><br>
<pre><code class="cs hljs">DataTable&lt;File, ProcessedFile&gt; sharedMemory;<font></font>
<font></font>
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
<font></font>
    <span class="hljs-keyword">lock</span> (_lock) {<font></font>
      sharedMemory.<span class="hljs-keyword">add</span>(f, p);<font></font>
   }<font></font>
 }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Apakah perlu menarik async dan kunci-kunci ini? Sekarang ada semua jenis kunci async, async semaphores, yaitu upaya untuk menggunakan primitif yang ada dalam kode sinkron dan asinkron. Konsep ini tampaknya salah, karena dengan kunci Anda melindungi sesuatu dari eksekusi paralel. Tugas kami adalah menerjemahkan eksekusi paralel menjadi berurutan, karena lebih mudah. Dan jika lebih sederhana - lebih sedikit kesalahan.</font></font><br>
<br>
<pre><code class="cs hljs">Channel&lt;Pair&lt;File, ProcessedFile&gt;&gt; output;
<span class="hljs-comment">// in any thread</span>
<span class="hljs-function"><span class="hljs-keyword">async</span> Task <span class="hljs-title">WorkerAsync</span>(<span class="hljs-params">...</span>)</span> {<font></font>
<font></font>
  File f = <span class="hljs-keyword">await</span> channel.ReadAsync();<font></font>
<font></font>
  ProcessedFile p = <span class="hljs-keyword">await</span> ProcessInParallelAsync(f);<font></font>
  <font></font>
  <span class="hljs-keyword">await</span> output.WriteAsync(); <font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kita dapat membuat beberapa saluran dan meletakkan di sana beberapa File dan ProcessedFile, dan </font></font><code>ReadAsync</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">beberapa prosedur lain akan </font><font style="vertical-align: inherit;">memproses saluran ini </font><font style="vertical-align: inherit;">, dan itu akan melakukannya secara berurutan. Mengunci sendiri, selain melindungi struktur, pada dasarnya membuat akses linier, tempat semua utas dari yang berurutan menjadi paralel. Dan kami mengganti ini secara eksplisit dengan saluran. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/q_/qe/mf/q_qemfc4mssz9shitqlekzee6nc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Arsitekturnya adalah sebagai berikut: pekerja menerima file dari </font></font><code>input</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan mengirimnya ke suatu tempat ke prosesor, yang juga memproses semuanya secara berurutan, tidak ada paralelisme. Kode terlihat lebih sederhana. Saya mengerti bahwa tidak semuanya bisa dilakukan dengan cara ini. Arsitektur seperti itu, ketika Anda bisa membangun pipa data, tidak selalu berhasil.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/7k/9j/sv/7k9jsvdwqbqrzgbejoozsk5lj_s.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mungkin saja Anda memiliki saluran kedua yang masuk ke prosesor Anda dan bukan grafik berarah asiklik yang terbentuk dari saluran, tetapi grafik dengan siklus. </font><font style="vertical-align: inherit;">Ini adalah contoh yang dikatakan Roman Elizarov kepada KotlinConf pada tahun 2018. </font><font style="vertical-align: inherit;">Dia menulis contoh di Kotlin dengan saluran-saluran ini, dan ada siklus di sana, dan contoh ini ditutup. </font><font style="vertical-align: inherit;">Masalahnya adalah jika Anda memiliki siklus seperti itu dalam grafik, maka semuanya menjadi lebih rumit di dunia asinkron. </font><font style="vertical-align: inherit;">Kebuntuan asinkron buruk karena jauh lebih sulit dipecahkan daripada sinkron ketika Anda memiliki setumpuk utas, dan jelas apa yang terjadi. </font><font style="vertical-align: inherit;">Oleh karena itu, ini adalah alat yang harus digunakan dengan benar.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ringkasan</font></font></h2><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hindari sinkronisasi dalam kode asinkron.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode serial lebih sederhana daripada paralel.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode asinkron bisa sederhana dan menggunakan parameter minimum dan konteks implisit yang mengubah perilakunya.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Jika Anda telah mengembangkan kebiasaan menulis kode sinkron, dan meskipun kode asinkron sangat mirip dengan kode sinkron, Anda tidak perlu menyeret primitif di sana, yang biasa Anda gunakan dalam kode sinkron </font></font><code>async mutex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Gunakan feed, jika mungkin, dan primitif </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pesan yang lewat lainnya</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Kode serial lebih sederhana daripada paralel. Jika Anda dapat menulis arsitektur Anda sehingga terlihat berurutan, tanpa menjalankan kode paralel dan mengunci, maka tulis arsitektur secara berurutan.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dan hal terakhir yang kami lihat dari sejumlah besar contoh dengan tugas. </font><font style="vertical-align: inherit;">Saat Anda mendesain sistem Anda, cobalah untuk tidak terlalu bergantung pada konteks implisit. </font><font style="vertical-align: inherit;">Konteks implisit mengarah pada kesalahpahaman tentang apa yang terjadi dalam kode, dan Anda bisa melupakan masalah tersirat dalam setahun. </font><font style="vertical-align: inherit;">Dan jika orang lain mengerjakan kode ini dan mengulang sesuatu di dalamnya, ini dapat menyebabkan kesulitan yang pernah Anda ketahui, dan programmer baru tidak tahu karena konteks yang tersirat. </font><font style="vertical-align: inherit;">Akibatnya, desain yang buruk dicirikan oleh sejumlah besar parameter, kombinasi dan konteks implisit.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang harus dibaca</font></font></h2><br>
<ul>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dokumen TAP</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panduan Asyncs</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seumur hidup</font></font></a></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">medium.com/@elizarov/deadlocks-in-non-hierarchical-csp-e5910d137cc</font></font></a></li>
</ul><br>
<blockquote>     -10     .     DotNext   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a>.</blockquote></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id491218/index.html">Integrasi PVS-Studio di PlatformIO</a></li>
<li><a href="../id491224/index.html">Otomatisasi layanan pengiriman, atau Bagaimana perusahaan jasa dapat mengurangi biaya transportasi hingga 30%</a></li>
<li><a href="../id491230/index.html">Bagaimana saya pergi ke sekolah 21 dan pengungkapan rahasia</a></li>
<li><a href="../id491232/index.html">RPA + Machine Learning = Otomasi Cerdas</a></li>
<li><a href="../id491234/index.html">Tiga Trik untuk Bekerja dengan SOLIDWORKS untuk Memodelkan Bagian untuk Pencetakan 3D</a></li>
<li><a href="../id491238/index.html">Analisis Kode Genetik II</a></li>
<li><a href="../id491240/index.html">Jalan menuju awan: kemarin dan hari ini Adobe</a></li>
<li><a href="../id491244/index.html">Ableton tidak diperlukan: sambungkan Ableton Push 2 ke VCV Rack</a></li>
<li><a href="../id491246/index.html">Konferensi DEFCON 27. Mobil Anda adalah mobil saya. Bagian 2</a></li>
<li><a href="../id491250/index.html">Lampu LED Gauss Basic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>