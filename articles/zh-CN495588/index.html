<!doctype html>
<html class="no-js" lang="zh-CN">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔤 👈🏾 🎎 从零开始在Unity中创建类似于Rogue的游戏：地牢生成器 😿 🖕🏽 🕳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这次，我们将深入研究地牢生成器算法的实现。在上一篇文章中，我们创建了第一个房间，现在我们将生成其余的地牢级别。
 
 但是在我们开始之前，我想修复先前文章中的一个错误。实际上，最近几周我学到了一些新知识，这就是为什么我所做的一些工作已经过时了，我想谈一谈。
 
 还记得我们创建的Position类吗...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>从零开始在Unity中创建类似于Rogue的游戏：地牢生成器</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/495588/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png" alt="图片"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这次，我们将深入研究地牢生成器算法的实现。在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上一篇文章中，</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们创建了第一个房间，现在我们将生成其余的地牢级别。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在我们开始之前，我想修复先前文章中的一个错误。实际上，最近几周我学到了一些新知识，这就是为什么我所做的一些工作已经过时了，我想谈一谈。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
还记得我们创建的Position类吗？实际上，Unity已经有一个内置的类，可以执行完全相同的功能，但控制性稍好-声明和处理都更容易。此类称为Vector2Int。因此，在开始之前，我们将从MapManager.cs中删除Position类，并将每个Position变量替换为Vector2Int变量。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/656/b7d/f40/656b7df4053976af99cbd2d359edd494.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在DungeonGenerator.cs脚本中的多个地方都需要做同样的事情。</font><font style="vertical-align: inherit;">现在让我们开始讨论算法的其余部分。</font></font><br>
<a name="habracut"></a><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第七阶段-房间/大厅生成</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们将对上次创建的函数FirstRoom（）进行小的更改。</font><font style="vertical-align: inherit;">我们无需创建另一个函数来生成地图的所有其他元素并复制一堆代码，而只是将其转换为通用的GenerateFeature（）。</font><font style="vertical-align: inherit;">因此，将名称从FirstRoom更改为GenerateFeature。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要将参数传递给该函数。</font><font style="vertical-align: inherit;">首先，您需要知道它产生什么功能-房间或走廊。</font><font style="vertical-align: inherit;">我们可以传递一个叫做</font><em><font style="vertical-align: inherit;">type</font></em><font style="vertical-align: inherit;">的字符串</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">接下来，函数需要知道元素的起点，即它来自哪面墙（因为我们总是从较旧元素的墙创建一个新元素），为此，传递Wall参数就足够了。</font><font style="vertical-align: inherit;">最后，要创建的第一个房间具有特殊的特征，因此我们需要一个可选的bool变量，该变量告诉该项目是否是第一个房间。</font><font style="vertical-align: inherit;">默认情况下，它为false：bool isFirst = false。</font><font style="vertical-align: inherit;">因此，函数标题将与此不同：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5f/b79/d17/e5fb79d178098b3bcde238ff733f9ca9.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45e/124/afc/45e124afc4b4f60b12ab18deaa060719.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细。</font><font style="vertical-align: inherit;">下一步是更改计算元素的宽度和高度的方式。</font><font style="vertical-align: inherit;">当我们计算它们时，在房间的高度和宽度的最小值和最大值之间获取一个随机值-这对于房间来说是理想的，但不适用于走廊。</font><font style="vertical-align: inherit;">因此，到目前为止，我们有以下内容：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f5/c0d/976/2f5c0d9765a596c2d2188b56b1f7b7ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是，走廊的宽度或高度将恒定为3，具体取决于方向。</font><font style="vertical-align: inherit;">因此，我们需要检查元素是-房间还是走廊，然后执行适当的计算。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/071/163/df8/071163df82fc248fc92d370672369743.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
所以。</font><font style="vertical-align: inherit;">我们检查物品是否是房间。</font><font style="vertical-align: inherit;">如果是这样，那么我们将做与以前相同的操作</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 -在高度和宽度的最小值和最大值之间的间隔中获得一个随机数。</font><font style="vertical-align: inherit;">但是，现在在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的，如果你需要做的东西有点不同。</font><font style="vertical-align: inherit;">我们需要检查走廊的方向。</font><font style="vertical-align: inherit;">幸运的是，生成墙时，我们会保存有关墙朝向的信息，因此我们可以使用它来获取走廊的方向。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/91a/a84/328/91aa84328140d1414b8512843e1cd397.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是我们尚未声明变量minCorridorLength。</font><font style="vertical-align: inherit;">您需要回到变量声明并在maxCorridorLength上方声明它。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f13/857/6e1/f138576e1dc1cb4a9949fd51e8c5fe47.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在回到我们的条件开关语句。</font><font style="vertical-align: inherit;">我们在这里做的是：获得</font><font style="vertical-align: inherit;">墙</font><font style="vertical-align: inherit;">的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">方向</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的值</font><font style="vertical-align: inherit;">，即墙在看的位置，从中走过的走廊。</font><font style="vertical-align: inherit;">方向只能有四个可能的值：南，北，西和东。</font><font style="vertical-align: inherit;">对于南边和北边，走廊的宽度为3（中间有两堵墙和一层地板），高度可变（长度）。</font><font style="vertical-align: inherit;">对于西方和东方，一切都将相反：高度将始终等于3，宽度将具有可变的长度。</font><font style="vertical-align: inherit;">因此，让我们开始吧。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e2/175/8d6/0e21758d6d2e17406ce516c3fef6ccf5.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
哇。</font><font style="vertical-align: inherit;">这就是我们最终确定新项目大小的地方。</font><font style="vertical-align: inherit;">现在，您需要确定放置位置。</font><font style="vertical-align: inherit;">我们将第一个房间放置在相对于地图中心的阈值内的随机位置。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fb/d53/010/6fbd5301066f6b0ba77ab90142370a5d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是对于所有其他元素，这将行不通。它们应从生成元素的墙的随机点开始。因此，让我们更改代码。首先，我们需要检查元素是否是第一个房间。如果这是第一个房间，那么我们将以与以前相同的方式定义起点-为地图的宽度和高度的一半。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ff3/d29/44d/ff3d2944da973a48200a6c9c3066d20d.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他情况下，</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果元素不是第一个房间，那么我们将在生成元素的墙壁上获得一个随机点。首先，我们需要检查墙的大小是否为3（这意味着它是走廊的终点），如果是，则将始终选择中间点，即墙阵列的索引1（具有3个元素，该阵列具有索引0、1、2）。但是，如果大小不等于3（墙不是走廊的终点），则我们在点1与墙的长度减去2的长度之间的间隔中取一个随机点。这对于避免在拐角处创建通道是必要的。也就是说，例如，在长度为6的墙上，我们排除索引0和5（第一个和最后一个），并在点1、2、3和4中选择一个随机点。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/4e1/703/ee24e1703c28b4cfa96e98d84a76c790.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们具有将在墙上创建新元素的点的位置。但是我们不能仅仅从那里开始生成一个元素，因为这样一来，它就会被已经放置的墙壁所阻挡。同样重要的是要注意，该元素从其左下角开始生成，然后向右和向上执行增量，因此我们必须根据墙壁的方向将初始位置设置在不同的位置。此外，第一列x和第一行y将是墙，如果我们在墙的某个点旁边开始一个新元素，则可以在房间的一角而不是墙的合适位置创建一条走廊。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，如果墙指向北，则必须使该元素从y轴向北的一个位置开始，但沿x轴向西的随机位置在1到Room-2的宽度范围内开始。</font><font style="vertical-align: inherit;">在南向，x轴的作用相同，但是y轴的起始位置是墙上点的位置减去房间高度的位置。</font><font style="vertical-align: inherit;">西墙和东墙遵循相同的逻辑，只是轴是倒置的。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
但是在执行所有这些操作之前，我们需要将壁点的位置保存在Vector2Int变量中，以便以后可以对其进行操作。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/374/129/41a/37412941a3a58f32fd2dd38c1fc2c252.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
大。</font><font style="vertical-align: inherit;">来做吧。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/140/2c7/ec0/1402c7ec0596d77f9a9b70b5eac076a9.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们生成了具有大小和位置的元素，下一步是将该元素放置在地图上。</font><font style="vertical-align: inherit;">但是首先，我们需要确定地图上此位置上是否确实存在该元素的空间。</font><font style="vertical-align: inherit;">现在，我们只调用CheckIfHasSpace（）函数。</font><font style="vertical-align: inherit;">它将以红色突出显示，因为我们尚未实现它。</font><font style="vertical-align: inherit;">在完成GenerateFeature（）函数中需要在此处完成的操作后，我们将立即执行此操作。</font><font style="vertical-align: inherit;">因此，请忽略红色下划线并继续。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/805/942/b2080594237c23cae023cabb20b2d20e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在下一部分中，将创建墙。</font><font style="vertical-align: inherit;">直到我们接触它，第二个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环中的片段除外</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/227/d7f/e2b/227d7fe2bf3c2eef41f423e36b4afc79.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在撰写本文时，我注意到这些if-else构造是完全错误的。例如，其中某些墙的长度将为1。这是因为，当要向北墙添加位置时，如果该位置在与东墙的转角处，则不会按原样将其添加到东墙。这导致生成算法中令人讨厌的错误。让我们消除它们。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
修复它们非常简单。删除</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有</font><em><font style="vertical-align: inherit;">内容</font></em><font style="vertical-align: inherit;">就足够了，</font><font style="vertical-align: inherit;">以便该位置通过所有</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">构造</font><font style="vertical-align: inherit;">，并且在返回</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true时</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不停在第一个位置</font><font style="vertical-align: inherit;">。然后将最后一个</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">else</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（不是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的另一个</font><font style="vertical-align: inherit;">）更改为</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，它检查位置是否已添加为“墙”，如果尚未添加，则将其添加为“地板”。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/784/834/65c784834461a2d8b05d1d39dd9ee44c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
太神奇了，我们在这里差不多完成了。</font><font style="vertical-align: inherit;">现在，我们有了一个全新的元素，该元素在正确的位置创建，但它与我们的第一个房间相同：它完全被墙壁包围。</font><font style="vertical-align: inherit;">这意味着玩家将无法到达这个新地方。</font><font style="vertical-align: inherit;">也就是说，我们需要转换墙上的一个点（我们记得，该点存储在Vector2Int类型的变量中）和地板上新元素的墙上的对应点。</font><font style="vertical-align: inherit;">但仅当元素不是第一个房间时。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/350/67f/5ac/35067f5ac7db26fd304578b8dd53326c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
这段代码检查新项目是否是第一个房间。</font><font style="vertical-align: inherit;">如果不是，它将把墙的最后位置转换为地板，然后检查墙的方向，以检查新元素的哪一块应变成地板。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们到了GenerateFeature（）函数的最后一部分。</font><font style="vertical-align: inherit;">它已经有添加有关该函数创建的元素的信息的行。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4fe/165/626/4fe165626aca42951f86568a4d6649c7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里我们需要改变一些东西。</font><font style="vertical-align: inherit;">首先，元素类型并不总是等于Room。</font><font style="vertical-align: inherit;">幸运的是，所需的变量作为参数（即类型字符串）传递给函数。</font><font style="vertical-align: inherit;">因此，我们在这里用type替换“ Room”。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b57/d12/f17/b57d12f17802ec40e0c609d26803f661.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
好。</font><font style="vertical-align: inherit;">现在，为了使生成游戏所有元素的算法正常工作，我们需要在此处添加新数据。</font><font style="vertical-align: inherit;">即，一个int会计算创建的项目数以及所有创建的项目的列表。</font><font style="vertical-align: inherit;">我们到达声明所有变量的地方，并声明一个名为countFeatures的int以及一个名为allFeatures的元素列表。</font><font style="vertical-align: inherit;">所有元素的列表必须是公共的，并且int计数器可以是私有的。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcb/ebf/8dd/bcbebf8ddbc768864ba70331317cc72c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在返回到GenerateFeature（）函数，并在最后添加几行：增加变量countFeatures并将新元素添加到allFeatures列表中。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e6/8a8/496/5e68a8496d7047c87650a609acb912cf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
因此，我们的GenerateFeature（）即将完成。</font><font style="vertical-align: inherit;">稍后，我们将需要返回到它来填充空的CheckIfHasSpace函数，但是首先我们需要创建它。</font><font style="vertical-align: inherit;">这就是我们现在要做的。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阶段8-检查是否有地方</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，让我们在GenerateFeature（）函数完成后立即创建一个新函数。她需要两个参数：元素开始的位置和元素结束的位置。您可以将两个Vector2Int变量用作它们。该函数应返回布尔值，以便可以在</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是否</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">检查空间时</font><font style="vertical-align: inherit;">使用它</font><font style="vertical-align: inherit;">。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/998/f03/cad/998f03cad9a6bd8a05bd7d8b9658bad6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
它带有红色下划线，因为到目前为止它还没有返回任何东西。很快我们将修复它，但是现在我们将不关注。在此函数中，我们将遍历元素开始和结束之间的所有位置，并检查MapManager.map中的当前位置是否为null或已经有东西。如果那里有东西，那么我们停止该函数并返回false。如果不是，则继续。如果函数到达循环末尾但未满足填充的位置，则返回true。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
另外，在检查位置是否为空之前，我们需要一行来检查位置是否在地图内。因为否则，我们可能会得到数组索引错误和游戏崩溃。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/473/582/a5b/473582a5b560d6738de08b2f6190cf6b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细。</font><font style="vertical-align: inherit;">现在回到我们在GenerateFeature（）函数中插入此函数的地方。</font><font style="vertical-align: inherit;">我们需要解决此调用，因为它没有传递必要的参数。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在这里，我们要插入一条</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">if语句</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来检查元素是否有足够的空间。</font><font style="vertical-align: inherit;">如果结果为假，则无需在MapManager.map中插入新元素即可结束函数。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/068/661/e53/068661e533ef21536a51f17ae3de570b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们需要传递必需的参数，即两个Vector2Int变量。</font><font style="vertical-align: inherit;">首先，一切都很简单，这是元素起点的x和y坐标位置。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0c1/869/26d/0c186926d741d2423c791500adbed2cd.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
第二个难度更大，但幅度不大。</font><font style="vertical-align: inherit;">这是起点加上y的高度和x的宽度，两者都减去1（因为已经考虑了起点）。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a18/f85/4a9/a18f854a9e0a0bbe5883012bf2e313ff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在让我们继续下一步-创建一个算法来调用GenerateFeature（）函数。</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">阶段9-调用生成的元素</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
返回本文前面部分中创建的GenerateDungeon（）函数。</font><font style="vertical-align: inherit;">现在看起来应该像这样：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3e9/57c/5e3/3e957c5e316f5329e935353e961df47b.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
由于我们更改了此函数的名称，因此对FirstRoom（）的调用用红色下划线标出。</font><font style="vertical-align: inherit;">因此，让我们称第一代房间。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d6/926/908/8d692690826997750f3bc860ae9216f0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我们传递了必要的参数：“ Room”作为类型，因为第一个房间将始终是Room，new Wall（），因为第一个房间将不会从其他任何房间创建，因此我们只传递了null，这是很正常的。可以使用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">null</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代替新的Wall（），</font><font style="vertical-align: inherit;">这是个人喜好问题。最后一个参数确定新元素是否是第一个房间，因此在本例中，我们传递</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们来谈重点。我们使用一个for循环，该循环将运行500次-是的，我们将尝试添加元素500次。但是，如果创建的元素数（countFeatures变量）等于指定的最大元素数（maxFeatures变量），则我们中断此循环。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/410/ded/9e6410ded47210776fcda40ae2492229.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
此循环的第一步是声明将从中创建新元素的元素。</font><font style="vertical-align: inherit;">如果我们仅创建一个元素（第一个房间），那么它将是原始元素。</font><font style="vertical-align: inherit;">否则，我们将随机选择一个已创建的元素。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ddb/e84/f92/ddbe84f92cbb06f56e3ccce561dde991.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在，我们将选择将使用该元素的哪面墙来创建新元素。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7ad/e7c/0e4/7ade7c0e438985098eed6f5dbdd42e6d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
请注意，我们还没有此ChoseWall（）函数。</font><font style="vertical-align: inherit;">让我们快速编写它。</font><font style="vertical-align: inherit;">转到函数末尾并创建它。</font><font style="vertical-align: inherit;">它应该返回一堵墙，并使用一个元素作为参数，以便函数可以选择此元素的墙。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aeb/631/9f1/aeb6319f1ee6f601474d0aa0e32e2c77.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我在CheckIfHasSpace（）和DrawMap（）函数之间创建了它。</font><font style="vertical-align: inherit;">请注意，如果您正在与Unity一起安装的Visual Studio中工作，则可以使用左侧的-/ +字段折叠/展开部分代码以简化工作。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
在此功能中，我们将找到尚未从中创建元素的墙。</font><font style="vertical-align: inherit;">有时我们会获得带有一个或多个墙的元素，其中的其他元素已经连接，因此我们需要一次又一次地检查任意随机墙是否空闲。</font><font style="vertical-align: inherit;">为此，我们使用一个for循环重复十次-如果在这十次之后没有找到空闲墙，则该函数返回null。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b10/44a/028/b1044a028bf9ab566a0120690311396d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在返回到GenerateDungeon（）函数，并将原始元素作为参数传递给ChoseWall（）函数。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0a3/281/8aa/0a32818aafc77ddd87f1ffac21b6981e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
该行</font></font><code>if (wall == null) continue;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">表示如果wall搜索函数返回false，则原始元素无法生成新元素，因此该函数将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">继续</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">循环，即，它无法创建新元素并继续进行循环的下一个迭代。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
现在我们需要为下一项选择类型。</font><font style="vertical-align: inherit;">如果源元素是一个房间，则下一个必须是走廊（我们不希望该房间直接通向另一个房间，而它们之间没有走廊）。</font><font style="vertical-align: inherit;">但是，如果这是一个走廊，那么我们需要确定下一个走廊或房间将成为下一个走廊的可能性。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b22/df0/954/b22df0954bbe21d82506d42e5118a70f.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
精细。</font><font style="vertical-align: inherit;">现在，我们只需要调用GenerateFeature（）函数，将墙壁和类型作为参数传递给它。</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a07/90b/834/a0790b83479f46dc17c57fbb981aef81.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
最后，转到Unity检查器，选择GameManager对象并将值更改为以下内容：</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9cc/09c/786/9cc09c786641bf85a89674cc33042ebf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
如果现在单击“播放”按钮，那么您已经可以看到结果了！</font></font><br>
<br>
<div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/09d/9af/aac/09d9afaace836ef3bde082e3d63c580a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
正如我所说，这不是最好的地牢。</font><font style="vertical-align: inherit;">我们有很多死胡同。</font><font style="vertical-align: inherit;">但是它具有完整的功能，并且可以保证您不会有没有其他任何房间的房间。</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
我希望你喜欢它！</font><font style="vertical-align: inherit;">在下一篇文章中，我们将创建一个将在地牢中移动的玩家，然后将地图从ASCII转换为精灵。</font></font><br>
<br>
<pre><code class="cs hljs"><span class="hljs-keyword">using</span> System.Collections;
<span class="hljs-keyword">using</span> System.Collections.Generic;
<span class="hljs-keyword">using</span> UnityEngine;
<span class="hljs-keyword">using</span> UnityEngine.UI;<font></font>
<font></font>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Post3</span> : <span class="hljs-title">MonoBehaviour</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapWidth;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> mapHeight;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> widthMaxRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMinRoom;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> heightMaxRoom;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> minCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxCorridorLength;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> maxFeatures;
    <span class="hljs-keyword">int</span> countFeatures;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">bool</span> isASCII;<font></font>
<font></font>
    <span class="hljs-keyword">public</span> List&lt;Feature&gt; allFeatures;<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">InitializeDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        MapManager.map = <span class="hljs-keyword">new</span> Tile[mapWidth, mapHeight];<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GenerateDungeon</span>(<span class="hljs-params"></span>)</span> {<font></font>
        GenerateFeature(<span class="hljs-string">"Room"</span>, <span class="hljs-keyword">new</span> Wall(), <span class="hljs-literal">true</span>);<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) {<font></font>
            Feature originFeature;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (allFeatures.Count == <span class="hljs-number">1</span>) {<font></font>
                originFeature = allFeatures[<span class="hljs-number">0</span>];<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {<font></font>
                originFeature = allFeatures[Random.Range(<span class="hljs-number">0</span>, allFeatures.Count - <span class="hljs-number">1</span>)];<font></font>
            }<font></font>
<font></font>
            Wall wall = ChoseWall(originFeature);<font></font>
            <span class="hljs-keyword">if</span> (wall == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<font></font>
<font></font>
            <span class="hljs-keyword">string</span> type;<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (originFeature.type == <span class="hljs-string">"Room"</span>) {<font></font>
                type = <span class="hljs-string">"Corridor"</span>;<font></font>
            }<font></font>
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) &lt; <span class="hljs-number">90</span>) {<font></font>
                    type = <span class="hljs-string">"Room"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> {<font></font>
                    type = <span class="hljs-string">"Corridor"</span>;<font></font>
                }<font></font>
            }<font></font>
<font></font>
            GenerateFeature(type, wall);<font></font>
<font></font>
            <span class="hljs-keyword">if</span> (countFeatures &gt;= maxFeatures) <span class="hljs-keyword">break</span>;<font></font>
        }<font></font>
<font></font>
        DrawMap(isASCII);<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">GenerateFeature</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> type, Wall wall, <span class="hljs-keyword">bool</span> isFirst = <span class="hljs-literal">false</span></span>)</span> {<font></font>
        Feature room = <span class="hljs-keyword">new</span> Feature();<font></font>
        room.positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
<font></font>
        <span class="hljs-keyword">int</span> roomWidth = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> roomHeight = <span class="hljs-number">0</span>;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) {<font></font>
            roomWidth = Random.Range(widthMinRoom, widthMaxRoom);<font></font>
            roomHeight = Random.Range(heightMinRoom, heightMaxRoom);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    roomWidth = <span class="hljs-number">3</span>;<font></font>
                    roomHeight = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    roomWidth = Random.Range(minCorridorLength, maxCorridorLength);<font></font>
                    roomHeight = <span class="hljs-number">3</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">int</span> xStartingPoint;
        <span class="hljs-keyword">int</span> yStartingPoint;<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint = mapWidth / <span class="hljs-number">2</span>;<font></font>
            yStartingPoint = mapHeight / <span class="hljs-number">2</span>;<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> id;
            <span class="hljs-keyword">if</span> (wall.positions.Count == <span class="hljs-number">3</span>) id = <span class="hljs-number">1</span>;
            <span class="hljs-keyword">else</span> id = Random.Range(<span class="hljs-number">1</span>, wall.positions.Count - <span class="hljs-number">2</span>);<font></font>
<font></font>
            xStartingPoint = wall.positions[id].x;<font></font>
            yStartingPoint = wall.positions[id].y;<font></font>
        }<font></font>
<font></font>
        Vector2Int lastWallPosition = <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint);<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (isFirst) {<font></font>
            xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth);<font></font>
            yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight);<font></font>
        }<font></font>
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) xStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomWidth - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> xStartingPoint--;<font></font>
                    yStartingPoint ++;<font></font>
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    xStartingPoint -= roomWidth;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    xStartingPoint++;<font></font>
                    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"Room"</span>) yStartingPoint -= Random.Range(<span class="hljs-number">1</span>, roomHeight - <span class="hljs-number">2</span>);
                    <span class="hljs-keyword">else</span> yStartingPoint--;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
         <span class="hljs-keyword">if</span> (!CheckIfHasSpace(<span class="hljs-keyword">new</span> Vector2Int(xStartingPoint, yStartingPoint), <span class="hljs-keyword">new</span> Vector2Int(xStartingPoint + roomWidth - <span class="hljs-number">1</span>, yStartingPoint + roomHeight - <span class="hljs-number">1</span>))) {
            <span class="hljs-keyword">return</span>;<font></font>
        }<font></font>
<font></font>
        room.walls = <span class="hljs-keyword">new</span> Wall[<span class="hljs-number">4</span>];<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; room.walls.Length; i++) {<font></font>
            room.walls[i] = <span class="hljs-keyword">new</span> Wall();<font></font>
            room.walls[i].positions = <span class="hljs-keyword">new</span> List&lt;Vector2Int&gt;();<font></font>
            room.walls[i].length = <span class="hljs-number">0</span>;<font></font>
<font></font>
            <span class="hljs-keyword">switch</span> (i) {
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"South"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"North"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"West"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<font></font>
                    room.walls[i].direction = <span class="hljs-string">"East"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>; y &lt; roomHeight; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; roomWidth; x++) {<font></font>
                Vector2Int position = <span class="hljs-keyword">new</span> Vector2Int();<font></font>
                position.x = xStartingPoint + x;<font></font>
                position.y = yStartingPoint + y;<font></font>
<font></font>
                room.positions.Add(position);<font></font>
<font></font>
                MapManager.map[position.x, position.y] = <span class="hljs-keyword">new</span> Tile();<font></font>
                MapManager.map[position.x, position.y].xPosition = position.x;<font></font>
                MapManager.map[position.x, position.y].yPosition = position.y;<font></font>
<font></font>
                <span class="hljs-keyword">if</span> (y == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">0</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">0</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (y == (roomHeight - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">1</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">1</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) {<font></font>
                    room.walls[<span class="hljs-number">2</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">2</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (x == (roomWidth - <span class="hljs-number">1</span>)) {<font></font>
                    room.walls[<span class="hljs-number">3</span>].positions.Add(position);<font></font>
                    room.walls[<span class="hljs-number">3</span>].length++;<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Wall"</span>;<font></font>
                }<font></font>
                <span class="hljs-keyword">if</span> (MapManager.map[position.x, position.y].type != <span class="hljs-string">"Wall"</span>) {<font></font>
                    MapManager.map[position.x, position.y].type = <span class="hljs-string">"Floor"</span>;<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">if</span> (!isFirst) {<font></font>
            MapManager.map[lastWallPosition.x, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
            <span class="hljs-keyword">switch</span> (wall.direction) {
                <span class="hljs-keyword">case</span> <span class="hljs-string">"South"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y - <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"North"</span>:<font></font>
                    MapManager.map[lastWallPosition.x, lastWallPosition.y + <span class="hljs-number">1</span>].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"West"</span>:<font></font>
                    MapManager.map[lastWallPosition.x - <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;
                <span class="hljs-keyword">case</span> <span class="hljs-string">"East"</span>:<font></font>
                    MapManager.map[lastWallPosition.x + <span class="hljs-number">1</span>, lastWallPosition.y].type = <span class="hljs-string">"Floor"</span>;
                    <span class="hljs-keyword">break</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        room.width = roomWidth;<font></font>
        room.height = roomHeight;<font></font>
        room.type = type;<font></font>
        allFeatures.Add(room);<font></font>
        countFeatures++;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">CheckIfHasSpace</span>(<span class="hljs-params">Vector2Int start, Vector2Int end</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = start.y; y &lt;= end.y; y++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = start.x; x &lt;= end.x; x++) {
                <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || y &lt; <span class="hljs-number">0</span> || x &gt;= mapWidth || y &gt;= mapHeight) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">if</span> (MapManager.map != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<font></font>
            }<font></font>
        }<font></font>
<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function">Wall <span class="hljs-title">ChoseWall</span>(<span class="hljs-params">Feature feature</span>)</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
            <span class="hljs-keyword">int</span> id = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>) / <span class="hljs-number">25</span>;
            <span class="hljs-keyword">if</span> (!feature.walls[id].hasFeature) {
                <span class="hljs-keyword">return</span> feature.walls[id];<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<font></font>
    }<font></font>
<font></font>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DrawMap</span>(<span class="hljs-params"><span class="hljs-keyword">bool</span> isASCII</span>)</span> {
        <span class="hljs-keyword">if</span> (isASCII) {<font></font>
            Text screen = GameObject.Find(<span class="hljs-string">"ASCIITest"</span>).GetComponent&lt;Text&gt;();<font></font>
<font></font>
            <span class="hljs-keyword">string</span> asciiMap = <span class="hljs-string">""</span>;<font></font>
<font></font>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> y = (mapHeight - <span class="hljs-number">1</span>); y &gt;= <span class="hljs-number">0</span>; y--) {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>; x &lt; mapWidth; x++) {
                    <span class="hljs-keyword">if</span> (MapManager.map[x, y] != <span class="hljs-literal">null</span>) {
                        <span class="hljs-keyword">switch</span> (MapManager.map[x, y].type) {
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Wall"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"#"</span>;
                                <span class="hljs-keyword">break</span>;
                            <span class="hljs-keyword">case</span> <span class="hljs-string">"Floor"</span>:<font></font>
                                asciiMap += <span class="hljs-string">"."</span>;
                                <span class="hljs-keyword">break</span>;<font></font>
                        }<font></font>
                    }<font></font>
                    <span class="hljs-keyword">else</span> {<font></font>
                        asciiMap += <span class="hljs-string">" "</span>;<font></font>
                    }<font></font>
<font></font>
                    <span class="hljs-keyword">if</span> (x == (mapWidth - <span class="hljs-number">1</span>)) {<font></font>
                        asciiMap += <span class="hljs-string">"\n"</span>;<font></font>
                    }<font></font>
                }<font></font>
            }<font></font>
<font></font>
            screen.text = asciiMap;<font></font>
        }<font></font>
    }<font></font>
}</code></pre></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN495560/index.html">物联网趋势：AI接听电话，云和5G驯服的大数据</a></li>
<li><a href="../zh-CN495570/index.html">PVS-Studio的兔子洞深度或C ++采访</a></li>
<li><a href="../zh-CN495572/index.html">硬件生态系统社区为电子行业的所有人发起播客</a></li>
<li><a href="../zh-CN495576/index.html">带有micropython的esp8266 MK上的自推式平台</a></li>
<li><a href="../zh-CN495580/index.html">黄瓜JVM-不只是BDD</a></li>
<li><a href="../zh-CN495592/index.html">如何使用字典（不仅限于此）</a></li>
<li><a href="../zh-CN495594/index.html">开始在软件上赚钱：创建小型数字业务</a></li>
<li><a href="../zh-CN495596/index.html">在办公室的远程工作。RDP，Port Knocking，Mikrotik：简单又安全</a></li>
<li><a href="../zh-CN495602/index.html">从核心数据开始！难以用简单的语言表达[第二部分]</a></li>
<li><a href="../zh-CN495604/index.html">Symfony 4 + Twig的临时本地化</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>