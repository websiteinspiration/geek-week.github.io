<!doctype html>
<html class="no-js" lang="pt">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>♓️ 🔰 🤶🏽 Ferrugem. Emprestar verificador através de iteradores 👨🏼‍🎓 ⛺️ 👩‍❤️‍👨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá Habr! 
 
 Eu estudo há cerca de um ano e, nas horas vagas, escrevo sobre o assunto. Gosto de como seus autores resolveram o problema do gerenciame...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Ferrugem. Emprestar verificador através de iteradores</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/499108/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Olá Habr! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Eu estudo há cerca de um ano e, nas horas vagas, escrevo sobre o assunto. </font><font style="vertical-align: inherit;">Gosto de como seus autores resolveram o problema do gerenciamento de memória e dispensaram o coletor de lixo - através do conceito de empréstimo. </font><font style="vertical-align: inherit;">Neste artigo, abordarei essa idéia por meio de iteradores. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ultimamente, scala é o meu idioma principal, então haverá comparações com ele, mas não há muitos e tudo é intuitivo, sem mágica :) O </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
artigo foi criado para aqueles que ouviram algo sobre ferrugem, mas não entraram em detalhes. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/lu/ju/o1/lujuo1lkziqqcu6fpfxiuuuaquy.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
fotos tiradas </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daqui</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> e </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">daqui</font></font></a><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prefácio</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nas linguagens jvm, é habitual ocultar o trabalho com links, ou seja, quase sempre trabalhamos com tipos de dados de referência, por isso decidimos ocultar oe comercial (&amp;). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
No rasta existem links explícitos, por exemplo, para inteiro - `&amp; i32`, o link pode ser desreferenciado por` * `, também pode haver um link para o link e, em seguida, será necessário desreferenciado duas vezes **.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iterador</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao escrever código, muitas vezes você precisa filtrar a coleção por uma condição (predicado). </font><font style="vertical-align: inherit;">No rock, pegar elementos pares seria algo assim:</font></font><br>
<br>
<pre><code class="scala hljs">    <span class="hljs-keyword">val</span> vec = <span class="hljs-type">Vector</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)
    <span class="hljs-keyword">val</span> result = vec.filter(e =&gt; e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vejamos os tipos:</font></font><br>
<br>
<pre><code class="scala hljs">  <span class="hljs-keyword">private</span>[scala] <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filterImpl</span></span>(p: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">Boolean</span>, isFlipped: <span class="hljs-type">Boolean</span>): <span class="hljs-type">Repr</span> = {
    <span class="hljs-keyword">val</span> b = newBuilder
    <span class="hljs-keyword">for</span> (x &lt;- <span class="hljs-keyword">this</span>)
      <span class="hljs-keyword">if</span> (p(x) != isFlipped) b += x<font></font>
<font></font>
    b.result<font></font>
  }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Sem entrar nos detalhes do `newBuilder`, é claro que uma nova coleção está sendo criada, iteramos sobre a antiga e, se o predicado retornar verdadeiro, adicione um elemento. </font><font style="vertical-align: inherit;">Apesar do fato de a coleção ser nova, seus elementos são na verdade links para elementos da primeira coleção e, se, de repente, esses elementos forem mutáveis, sua alteração será comum a ambas as coleções. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Agora vamos tentar fazer o mesmo no passado. </font><font style="vertical-align: inherit;">Darei imediatamente um exemplo de trabalho e depois considerarei as diferenças.</font></font><br>
<br>
<pre><code class="rust hljs">    <span class="hljs-keyword">let</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
    <span class="hljs-keyword">let</span> result: <span class="hljs-built_in">Vec</span>&lt;&amp;<span class="hljs-built_in">i32</span>&gt; = v.iter().filter(|e| **e % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect();</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Uau, uau o que? </font><font style="vertical-align: inherit;">Desreferenciamento de ponteiro duplo? </font><font style="vertical-align: inherit;">Apenas para filtrar o vetor? </font><font style="vertical-align: inherit;">Difícil :( Mas há razões para isso. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos destacar como esse código difere do rock:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> obtenha explicitamente o iterador no vetor (`iter ()`) </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> na função predicado, por algum motivo, desreferenciamos o ponteiro duas vezes </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chame `collect ()` </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> também resultou em um vetor de tipos de referência Vec &lt;&amp; i32&gt;, e ints não comuns </font></font></li>
</ol><br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Emprestar verificador</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que chamar explicitamente `iter ()` na coleção? </font><font style="vertical-align: inherit;">Está claro para qualquer rockman que, se você chamar `.filter (...)`, precisará iterar sobre a coleção. </font><font style="vertical-align: inherit;">Por que, de maneira explícita, escreva explicitamente o que pode ser feito implicitamente? </font><font style="vertical-align: inherit;">Porque existem </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">três</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> iteradores diferentes! </font></font><br>
<br>
<img src="https://habrastorage.org/webt/6t/vw/-m/6tvw-mzsdc6ce1caxkzl-custrw.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Para descobrir por que três? </font><font style="vertical-align: inherit;">necessidade de tocar em </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Borrow </font></font></b><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(emprestado, pedir emprestado) </font></font></i> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verificador</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 'a. </font><font style="vertical-align: inherit;">A mesma coisa pela qual o rast funciona sem um GC e sem alocação / desalocação explícita de memória. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Por que é necessário?</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para evitar situações em que vários ponteiros apontam para a mesma área de memória, permitindo que você a altere. </font><font style="vertical-align: inherit;">Essa é uma condição de corrida.</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para não desalocar a mesma memória várias vezes.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como isso é alcançado? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Devido ao conceito de propriedade. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Em geral, o conceito de propriedade é simples - apenas um pode possuir alguma coisa (mesmo intuição). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O proprietário pode mudar, mas ele está sempre sozinho. Quando escrevemos `let x: i32 = 25 ', isso significa que houve uma alocação de memória para 32bit int e um certo` x` é o proprietário. A ideia de propriedade existe apenas na mente do compilador, no verificador de empréstimos. Quando o proprietário, neste caso, `x` sai do escopo (sai do escopo), a memória da qual ele possui será limpa. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui está um código que o emprestador não perderá:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; X {
    <span class="hljs-keyword">let</span> first = X; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second = first; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> third = first; <span class="hljs-comment">//   ,   first   </span>
<span class="hljs-comment">//    value used here after move</span><font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
`struct X` é algo como` case class X () `- uma estrutura sem borda. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Esse comportamento é super contra-intuitivo, eu acho, para todos. </font><font style="vertical-align: inherit;">Não conheço outros idiomas nos quais seria impossível "usar" a mesma "variável" duas vezes. </font><font style="vertical-align: inherit;">É importante sentir esse momento. </font><font style="vertical-align: inherit;">primeiro não é uma referência a X, é seu </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">proprietário</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Mudando o proprietário, nós meio que matamos o anterior, o verificador de empréstimo não permitirá seu uso.</font></font><br>
<br>
<div class="spoiler" role="button" tabindex="0">
                        <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por que você precisou criar sua própria estrutura, por que não usar um número inteiro regular?</font></font></b>
                        <div class="spoiler_text">    —       (`struct X`),  , ,   integer.   ,     ,     :<br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span> </span>() -&gt; <span class="hljs-built_in">i32</span> {
    <span class="hljs-keyword">let</span> first = <span class="hljs-number">32</span>;
    <span class="hljs-keyword">let</span> second = first; 
    <span class="hljs-keyword">let</span> third = first; <font></font>
<font></font>
    <span class="hljs-keyword">return</span> third;<font></font>
}<font></font>
</code></pre><br>
  ,   borrow checker,            ,   .     Copy,      .      `i32` second     ,   (   ), -  third   .   X     Copy,      .<br>
<br>
     .   ,              ,      «»            .        Clone,    ,     .    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">copy</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow">clone</a>.<br>
</div>
                    </div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voltar para os iteradores. </font><font style="vertical-align: inherit;">O conceito de "captura" entre eles é o </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Ele "engole" a coleção, dando posse de seus elementos. </font><font style="vertical-align: inherit;">No código, essa ideia será refletida assim:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">let</span> coll_1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> coll_2: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = coll_1.into_iter().collect();
<span class="hljs-comment">//coll_1 doesn't exists anymore</span>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ao chamar `into_iter ()` em coll_1, nós o "transformamos" em um iterador, absorvendo todos os seus elementos, como no exemplo anterior, `segundo` absorvido` primeiro`. </font><font style="vertical-align: inherit;">Depois disso, todas as chamadas para coll_1 serão punidas pelo verificador emprestado durante a compilação. </font><font style="vertical-align: inherit;">Em seguida, coletamos esses elementos com a função `collect`, criando um novo vetor. </font><font style="vertical-align: inherit;">A função `collect` é necessária para coletar uma coleção de um iterador, para isso é necessário especificar explicitamente o tipo do que queremos coletar. </font><font style="vertical-align: inherit;">Portanto, coll_2 indica claramente o tipo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ok, em geral, o descrito acima é suficiente para uma linguagem de programação, mas não será muito eficiente copiar / clonar estruturas de dados toda vez que quisermos transferi-las e você também precisará alterar alguma coisa. </font><font style="vertical-align: inherit;">Então, vamos às dicas.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ponteiros</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
O proprietário, como descobrimos, pode ser apenas um. </font><font style="vertical-align: inherit;">Mas você pode ter qualquer número de links.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Y</span></span>; <span class="hljs-comment">// </span><font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; Y {
    <span class="hljs-keyword">let</span> first = Y; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;Y = &amp;first; <span class="hljs-comment">//   ,     </span>
    <span class="hljs-keyword">let</span> third = &amp;first; <span class="hljs-comment">//    </span><font></font>
<font></font>
<span class="hljs-comment">// </span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, second);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:?}"</span>, third);<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Este código já é válido, porque o proprietário ainda é um. Toda a lógica de propriedade é verificada apenas no estágio de compilação, sem afetar a alocação / movimentação de memória. Além disso, você pode ver que o tipo de segundo foi alterado para `&amp; Y`! Ou seja, a semântica de propriedade e links são refletidos nos tipos, o que permite verificar durante a compilação, por exemplo, a ausência de uma condição de corrida. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como posso me proteger contra a condição de corrida em tempo de compilação? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Definindo um limite para o número de links mutáveis! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Um link mutável em um momento no tempo pode ser um e apenas um (sem imutável). Ou seja, um / vários imutáveis ​​ou um mutável. O código fica assim:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-comment">// </span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">X</span></span> {<font></font>
    x: <span class="hljs-built_in">i32</span>,<font></font>
} <font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_borrow_checker</span></span>() -&gt; X {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> first = X { x: <span class="hljs-number">20</span> }; <span class="hljs-comment">//  </span>
    <span class="hljs-keyword">let</span> second: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//   </span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-keyword">mut</span> X = &amp;<span class="hljs-keyword">mut</span> first; <span class="hljs-comment">//    .        `second`        - .</span>
<span class="hljs-comment">//    second.x = 33;  //    ,             ,    </span>
    third.x = <span class="hljs-number">33</span>;<font></font>
<font></font>
    <span class="hljs-keyword">return</span> first;<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vamos examinar as mudanças no exemplo anterior relativo. Primeiro, adicionamos um campo à estrutura para que houvesse algo para mudar, porque precisamos de mutabilidade. Em segundo lugar, `mut` apareceu na declaração da variável` let mut first = ... `, este é um marcador para o compilador sobre mutabilidade, como` val` e `var` na rocha. Em terceiro lugar, todos os links mudaram de tipo de `&amp; X` para` &amp; mut X` (parece, é claro, monstruoso. E isso é sem tempo de vida ...), agora podemos alterar o valor armazenado pelo link.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mas eu disse que não podemos criar vários links mutáveis, eles dizem que o emprestador não dará isso, mas eu mesmo criei dois! Sim, mas as verificações lá são muito complicadas, e é por isso que às vezes não é óbvio porque o compilador jura. Ele está se esforçando para garantir que seu programa seja compilado e se não houver absolutamente nenhuma opção para cumprir as regras, um erro e talvez não o que você está esperando, mas aquele que viola sua última tentativa, a mais desesperada e não óbvia para um iniciante: ) Por exemplo, você é informado de que a estrutura não implementa a característica de Cópia, embora você não tenha chamado cópias em nenhum lugar. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesse caso, a existência de dois links mutáveis ​​é permitida ao mesmo tempo, porque usamos apenas um, ou seja, o segundo pode ser descartado e nada muda. Também o `segundo` pode ser usado </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">até</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crie um terceiro e então tudo ficará bem. </font><font style="vertical-align: inherit;">Mas, se você descomentar `second.x = 33;`, acontece que dois links mutáveis ​​existem simultaneamente e você não pode sair daqui de qualquer maneira - compile um erro de tempo.</font></font><br>
<br>
<h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iteradores</font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Portanto, temos três tipos de transmissão:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Absorção, empréstimo, movimento</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligação</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link mutável</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cada tipo precisa de seu próprio iterador.</font></font><br>
<br>
<ol>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O IntoIter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> absorve objetos da coleção original</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Iter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é executado em links de objetos</font></font></li>
<li><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O IterMut</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> é executado em referências de objetos mutáveis</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Surge a questão - quando usar qual. </font><font style="vertical-align: inherit;">Não existe uma bala de prata - você precisa praticar, ler o código de alguém, artigos. </font><font style="vertical-align: inherit;">Vou dar um exemplo demonstrando a ideia. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suponha que exista uma escola, que haja uma classe nela e os alunos na classe.</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-meta">#[derive(PartialEq, Eq)]</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Sex</span></span> {<font></font>
    Male,<font></font>
    Female<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Scholar</span></span> {<font></font>
    name: <span class="hljs-built_in">String</span>,<font></font>
    age: <span class="hljs-built_in">i32</span>,<font></font>
    sex: Sex<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = ...;
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pegamos o vetor de crianças em idade escolar consultando o banco de dados, por exemplo. </font><font style="vertical-align: inherit;">Em seguida, eu precisava contar o número de meninas na classe. </font><font style="vertical-align: inherit;">Se "engolimos" o vetor através de `into_iter ()`, depois de contar, não podemos mais usar esta coleção para contar os meninos:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bad_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars<font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Female)<font></font>
        .count();<font></font>
<font></font>
    <span class="hljs-keyword">let</span> boys_c = scholars <font></font>
        .into_iter()<font></font>
        .filter(|s| (*s).sex == Sex::Male)<font></font>
        .count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Haverá um erro "valor usado aqui após o movimento" na linha para contar meninos. </font><font style="vertical-align: inherit;">Também é óbvio que o iterador mutável não é útil para nós. </font><font style="vertical-align: inherit;">É por isso que é apenas `iter ()` e trabalhando com um link duplo:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_idea</span></span>() {
    <span class="hljs-keyword">let</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();
    <span class="hljs-keyword">let</span> girls_c = scholars.iter().filter(|s| (**s).sex == Sex::Female).count();
    <span class="hljs-keyword">let</span> boys_c = scholars.iter().filter(|s| (**s).sex == Sex::Male).count();<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Aqui, para aumentar o número de recrutas em potencial no país, um iterador mutável já é necessário:</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">very_good_idea</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Desenvolvendo a idéia, podemos transformar soldados em "caras" e demonstrar o iterador "absorvente":</font></font><br>
<br>
<pre><code class="rust hljs">
<span class="hljs-keyword">impl</span> Scholar {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">to_soldier</span></span>(<span class="hljs-keyword">self</span>) -&gt; Soldier {<font></font>
        Soldier { forgotten_name: <span class="hljs-keyword">self</span>.name, number: some_random_number_generator() }<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Soldier</span></span> {<font></font>
    forgotten_name: <span class="hljs-built_in">String</span>,<font></font>
    number: <span class="hljs-built_in">i32</span><font></font>
}<font></font>
<font></font>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">good_bright_future</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scholars: <span class="hljs-built_in">Vec</span>&lt;Scholar&gt; = <span class="hljs-built_in">Vec</span>::new();<font></font>
    scholars.iter_mut().for_each(|s| (*s).sex = Sex::Male);<font></font>
    <span class="hljs-keyword">let</span> soldiers: <span class="hljs-built_in">Vec</span>&lt;Soldier&gt; = scholars.into_iter().map(|s| s.to_soldier()).collect();
    <span class="hljs-comment">//   scholars,    </span><font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nesta nota maravilhosa, talvez seja tudo. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
A última pergunta permanece - de onde veio a dupla desreferenciação dos links no `filter`. </font><font style="vertical-align: inherit;">O fato é que um predicado é uma função que faz referência a um argumento (para não capturá-lo):</font></font><br>
<br>
<pre><code class="rust hljs">
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">filter</span></span>&lt;P&gt;(<span class="hljs-keyword">self</span>, predicate: P) -&gt; Filter&lt;<span class="hljs-keyword">Self</span>, P&gt; <span class="hljs-keyword">where</span>
        <span class="hljs-keyword">Self</span>: <span class="hljs-built_in">Sized</span>, P: <span class="hljs-built_in">FnMut</span>(&amp;Self::Item) -&gt; <span class="hljs-built_in">bool</span>,
</code></pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
o predicado é FnMut (a grosso modo uma função), que faz uma referência ao seu item (próprio) e retorna bool. </font><font style="vertical-align: inherit;">Como já tínhamos um link do iterador `.iter ()`, o segundo apareceu no filtro. </font><font style="vertical-align: inherit;">Quando absorvido por um iterador (`into_iter`), a desreferenciação dupla do link se torna regular.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuação</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Como não tenho muita experiência em escrever artigos, ficarei feliz em criticar. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Se estiver interessado, eu posso continuar. </font><font style="vertical-align: inherit;">Opções para tópicos:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> como e quando ocorre a desalocação de memória </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> vida útil do link </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> programação assíncrona </font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> escrevendo um pequeno serviço web, você pode até oferecer API </font></font></li>
</ul><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ligações</font></font></h3><br>
<ul>
<li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">livro de ferrugem</font></font></a> </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Devido ao conceito de propriedade, a implementação de itens básicos como, por exemplo, uma lista vinculada não é mais trivial. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aqui estão</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> várias maneiras de implementá-las.</font></font></li>
</ul></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt499092/index.html">Modelo de referência BIAN. Que novidade e útil para a arquitetura corporativa do banco oferece?</a></li>
<li><a href="../pt499096/index.html">Lógica confusa em belas fotos. Superfícies de resposta para diferentes funções de associação</a></li>
<li><a href="../pt499102/index.html">Kubernetes, microsserviços, CI / CDs e Dockers para retrógrados: dicas de aprendizado</a></li>
<li><a href="../pt499104/index.html">IoT para suas feridas: por que a Internet das coisas é mais bem-vinda na era dos coronavírus</a></li>
<li><a href="../pt499106/index.html">HTML avançado</a></li>
<li><a href="../pt499110/index.html">O Big Brother está tentando servir o bem. Como os coletores de dados e as empresas de programas estão envolvidos na luta contra o coronavírus</a></li>
<li><a href="../pt499112/index.html">Sistema avançado de autorização de recursos no Laravel. Parte 3. Atributos de leitura / escrita, modelos próprios</a></li>
<li><a href="../pt499114/index.html">Exportando o Plano de Numeração da Agência Federal de Comunicações para um Banco de Dados Relacional</a></li>
<li><a href="../pt499118/index.html">Como criar um vídeo viral</a></li>
<li><a href="../pt499120/index.html">[Bookmark] CSS: Usando recuo e recuo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>