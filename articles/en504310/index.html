<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîí üë©‚Äçüëß‚Äçüë¶ üë©üèø‚Äçüé§ Dichotomy of data: rethinking the relationship with data and services üñåÔ∏è üëåüèæ üßïüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello everyone! We have great news, in June OTUS starts the course ‚ÄúSoftware Architect‚Äù again , and therefore we traditionally share useful material w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Dichotomy of data: rethinking the relationship with data and services</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/504310/"><i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hello everyone! </font><font style="vertical-align: inherit;">We have great news, in June OTUS starts the course </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚ÄúSoftware Architect‚Äù</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> again </font><font style="vertical-align: inherit;">, and therefore we traditionally share useful material with you.</font></font></b></i><br>
<br>
<img src="https://habrastorage.org/webt/_u/yb/mf/_uybmfq3weld6i8pn9mmhaavd7q.png"><br>
<hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 If you come across this whole story with microservices without any context, then you are excusable to consider it a bit strange. Partitioning the application into fragments connected by a network, of course, means adding complex fault tolerance modes to the resulting distributed system. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Despite the fact that this approach includes splitting into many independent services, the final goal is much more than just the operation of these services on different machines. We are talking about interaction with the outside world, which in its essence is also distributed. Not in the technical sense, but rather in the sense of an ecosystem that consists of many people, teams, programs, and each of these parts must somehow do its job.</font></font><a name="habracut"></a><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Companies, for example, are a set of distributed systems that together contribute to the achievement of a certain goal. We have ignored this fact for decades, trying to achieve unification, transferring files via FTP or using corporate integration tools, while focusing on our personal isolated goals. But with the advent of services, everything has changed. Services have helped us look beyond the horizon and see the world of interdependent programs that work together. However, in order to work successfully, it is necessary to realize and design two fundamentally different worlds: the outside world, where we live in an ecosystem of many other services, and our personal, inner world, where we rule alone.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/wn/rj/wg/wnrjwgzns_o1pancqlclv6u2lnu.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Such a distributed world is different from the one in which we grew up and to which we are accustomed. </font><font style="vertical-align: inherit;">The principles of building traditional monolithic architecture do not stand up to criticism. </font><font style="vertical-align: inherit;">Therefore, a correct understanding of such systems is more than creating a classroom diagram on a white marker board or a cool proof of concept. </font><font style="vertical-align: inherit;">It is about such a system working successfully for a long time. </font><font style="vertical-align: inherit;">Fortunately, services have been around for quite some time, although they do look different. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SOA lessons</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are still relevant, even flavored with Docker, Kubernetes, and slightly battered hipster beards.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, today we look at how the rules have changed, why we need to rethink our approach to the services and data that they transmit to each other, and why we need completely different tools for this.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encapsulation won't always be your friend</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Microservices can work independently of each other. </font><font style="vertical-align: inherit;">It is this property that gives them the greatest value. </font><font style="vertical-align: inherit;">The same property allows services to scale and grow. </font><font style="vertical-align: inherit;">Not so much in terms of scaling up to quadrillion users or petabytes of data (although here they can help), but in terms of scaling from the point of view of people, because teams and organizations are growing continuously.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/dp/jo/y6/dpjoy6kenzqm9yamw36i0rqykc8.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, independence is a double-edged sword. That is, the service itself can spin easily and naturally. But if a function is implemented inside the service that requires the use of another service, then in the end we have to make changes to both services almost simultaneously. In the monolith, this is easy to do, you just make a change and send it to the release, but in the case of synchronization of independent services there will be more problems. The coordination between teams and release cycles destroys flexibility.</font></font><br>
 <br>
<img src="https://habrastorage.org/webt/_8/1-/qe/_81-qeg0kzrubvo7ztupdaml924.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As part of the standard approach, annoying end-to-end changes are simply avoided, clearly dividing the functionality between the services. The single sign-on service here can be a good example. He has a clearly defined role that distinguishes him from other services. Such a clear separation means that in a world of rapidly changing requirements for the services surrounding it, the single sign-on service is unlikely to change. It exists within a strictly limited context.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/kb/qa/3v/kbqa3v294bn890fp_axo-hqxzuy.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The problem is that in the real world, business services cannot constantly maintain an equally clean separation of roles. For example, the same business services work more with data coming from other similar services. If you are engaged in online retail, then processing the order flow, product catalog or user information will become a requirement for many of your services. Each of the services will need access to this data to work. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/s3/9m/2o/s39m2oqbanuuxmt6hyy4k5pycua.png"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most business services use the same data stream, so their work is always intertwined.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So we come to an important point worth talking about. </font><font style="vertical-align: inherit;">While services work well for infrastructure components that work largely apart, most business services are more intertwined.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data dichotomy</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Service-oriented approaches may already exist, but they still have little information on how to exchange large amounts of data between services. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The main problem is that data and services are inseparable. On the one hand, encapsulation encourages us to hide data so that services can be separated from each other and facilitate their growth and further changes. On the other hand, we need to be able to freely share and rule over general data, as well as over any others. It is about being able to immediately start work, as freely as in any other information system.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
However, information systems have little to do with encapsulation. In fact, even the opposite. Databases do everything they can to give access to the data stored in them. They come with a powerful declarative interface that allows you to modify the data as you need. Such functionality is important at the stage of preliminary research, but not for managing the growing complexity of an ever-evolving service. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/sz/c6/sr/szc6srm3bhvzavnk6impsaz7zv4.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 And here a dilemma arises. Contradiction. Dichotomy. After all, information systems are about providing data, and services are about concealment. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
These two forces are fundamental. They form the basis of most of our work, constantly striving for excellence in the systems we create.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As service systems grow and evolve, we see different manifestations of the effects of data dichotomy. Either the service interface will grow, providing an increasingly wide range of functions and will begin to look like a very wonderful home-grown database, or we will be disappointed, and we will implement some way to extract or move massively whole data sets from service to service. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/eg/lr/xm/eglrxm4yt7pj5osqvp2rsy-wjxm.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 In turn, creating something that looks like a wonderful homegrown database will lead to a number of problems. We will not go into details of what the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">shared database is</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dangerous </font><font style="vertical-align: inherit;">, just say that it represents significant costly engineering and operational </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">difficulties</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the company that is trying to use it.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Worse, data volumes multiply problems with service boundaries. The more common data is inside the service, the more complicated the interface will become and the more difficult it will be to combine the data sets coming from different services. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
An alternative approach to extracting and moving entire data sets also has its problems. A common approach to this issue looks like a simple extraction and storage of the entire data set, and then storing it locally in each consumer service. </font></font><br>
 <br>
<img src="https://habrastorage.org/webt/bc/v8/iq/bcv8iqnulyqgmwfmkrdim14ra-q.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The problem is that different services interpret the data they consume differently. This data is always at hand. They are modified and processed locally. Pretty quickly they cease to have anything in common with the data in the source.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/oc/qx/zj/ocqxzjghidto9whb_li5ys9p8dw.png"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The more mutable the copies, the more the data will vary over time.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 
Even worse, such data is difficult to correct in retrospect ( </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">MDM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can really come to the rescue here). In fact, some of the intractable technological problems that a business faces are due to heterogeneous data multiplying from application to application. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To find a solution to this problem about shared data, you need to think differently. They should become first-class objects in the architectures we build. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pat helland</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">calls such data ‚Äúexternal‚Äù, and this is a very important feature. </font><font style="vertical-align: inherit;">We need encapsulation so as not to expose the internal structure of the service, but we must facilitate services access to shared data so that they can correctly perform their work. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/xz/fp/mm/xzfpmme3ft-esfrtn1m0elos5ee.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 The problem is that none of the approaches is relevant today, since neither the service interfaces, nor the messaging, nor the Shared Database offer a good solution for working with external data. </font><font style="vertical-align: inherit;">Service interfaces are poorly suited for exchanging data at any scale. </font><font style="vertical-align: inherit;">Messaging moves data, but does not store its history, so data gets corrupted over time. </font><font style="vertical-align: inherit;">Shared Databases focus too much on one point, which holds back progress. </font><font style="vertical-align: inherit;">We are inevitably stuck in a data failure cycle:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/yz/b5/og/yzb5ogucyvztyuuistwg82vna5e.png"> <br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data Insolvency Cycle</font></font></i><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Streams: a decentralized approach to data and services</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Ideally, we need to change the approach to how services work with shared data. </font><font style="vertical-align: inherit;">At the moment, any approach is faced with the aforementioned dichotomy, since there is no magic pollen that could be generously sprinkled with it and made so that it disappears. </font><font style="vertical-align: inherit;">However, we can rethink the problem and come to a compromise.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This compromise involves a degree of centralization. We can use the distributed log mechanism because it provides reliable scalable flows. Now we need services to be able to join and work with these common threads, however we want to avoid the complex centralized God Services that perform this processing. Therefore, the best option is to embed streaming processing in each consumer service. So services will be able to combine data sets from different sources and work with them as they need. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
One way to achieve this approach is to use a streaming platform. There are many options, but today we will consider Kafka, since the use of its Stateful Stream Processing allows us to effectively solve the presented problem.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/p9/da/ce/p9dacej5l9ycv8nvl7nnf8nfkge.png"><br>
 <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
 Using the distributed logging mechanism allows us to follow a well-trodden path and use messaging to work with </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event-oriented architecture</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . It is believed that this approach provides better scaling and separation than the request-response mechanism, because it gives control of the flow to the receiver, not the sender. However, you have to pay for everything in this life, and here you need a broker. But for large systems, this trade-off is worth it (which cannot be said about your average web applications).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If a broker is responsible for distributed logging, and not a traditional messaging system, you can take advantage of additional features. Transport can be scaled linearly almost as well as a distributed file system. Data can be stored in the logs for a long time, so we get not only messaging, but also information storage. Scalable storage without fear of a mutable general state.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Then you can use the stateful stream processing mechanism to add declarative database tools to consumer services. This is a very important point. While data is stored in shared streams that all services can access, the pooling and processing that the service makes are private. They find themselves isolated within a strictly limited context. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/bj/9p/qu/bj9pquf4tpz4k5iu3ukrzcfrsra.png"><br>
 <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Get rid of the dichotomy of data by dividing the immune flow of states. Then add this feature to each service using Stateful Stream Processing.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, if your service must work with orders, a product catalog, a warehouse, it will have full access: only you will decide what data to combine, where to process it and how it should change over time. Despite the fact that the data is general, work with them is completely decentralized. It is made inside each service, in a world where everything goes according to your rules. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/om/hh/pe/omhhpeczejvxvusmit3aisoaa7o.png"> <br>
<i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Share data so that its integrity is not violated. Encapsulate a function, not a source, in every service that needs it.</font></font></i><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
It so happens that the data needs to be massively moved. </font><font style="vertical-align: inherit;">Sometimes a service requires a local historical data set in a selected database engine. </font><font style="vertical-align: inherit;">The trick is that you can guarantee that if necessary, a copy can be restored from the source by accessing the distributed logging mechanism. </font><font style="vertical-align: inherit;">Connectors at Kafka do a great job of this. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
So, the approach considered today has several advantages:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data is used in the form of shared streams that can be stored for a long time in the logs, and the mechanism for working with shared data is wired in each individual context, which allows services to work quickly and easily. </font><font style="vertical-align: inherit;">In this way, you can balance the dichotomy of the data.</font></font></li>
<li>,    ,      .                  .</li>
<li>Stateful Stream Processing   ,      ,           .</li>
<li>  ,   ,        ,        -.</li>
<li>    ,    .       ,      .</li>
<li>      ,      .</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As you can see, this is more than just REST. We got a set of tools that allows you to work with shared data in a decentralized way. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In today's article, not all aspects were disclosed. We still need to decide how to balance between the request-response paradigm and the event-oriented paradigm. But we will deal with this next time. There are topics you need to get to know better, for example, why Stateful Stream Processing is so good. We will talk about this in the third article. And there are other powerful designs that we can use if we resort to them, for example, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exactly Once Processing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . With its help, the rules of the game for distributed business systems are changed, since this design provides transactional guarantees for </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in scalable form. This will be discussed in the fourth article. Finally, we will need to go over the details of the implementation of these principles.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/cj/ub/7h/cjub7hkld4nj4n7i1whompdedcy.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
But for now, just remember the following: a data dichotomy is the force we face when creating business services. And we must remember this. The trick is to turn everything upside down and begin to consider the general data as first-class objects. Stateful Stream Processing provides a unique compromise for this. He avoids the centralized ‚ÄúGod Components‚Äù holding back progress. Moreover, it provides the speed, scalability and fault tolerance of data streaming pipelines and adds them to each service. Therefore, we can focus on the general stream of consciousness, to which any service can connect and work with its data. So the services are more scalable, interchangeable and autonomous. Therefore, they will not only look good on whiteboards and when testing hypotheses,but also work and develop for decades.</font></font><br>
<br>
<hr><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=">   .<br>
</a><br>
<hr></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en504282/index.html">Creation of Enterprise-architecture in NSPK</a></li>
<li><a href="../en504284/index.html">The book ‚ÄúPure Agile. The Basics of Flexibility</a></li>
<li><a href="../en504290/index.html">Load testing as a CI service for developers</a></li>
<li><a href="../en504296/index.html">Generating Random Branches in Python</a></li>
<li><a href="../en504306/index.html">How is Russian hardware made for storage Aerodisk Vostok on Elbrus</a></li>
<li><a href="../en504312/index.html">Unified register of Russian programs and GPL. My five cents</a></li>
<li><a href="../en504314/index.html">Implementation of docker pull and docker push commands without docker client via HTTP requests</a></li>
<li><a href="../en504320/index.html">Single line code or Nethermind validation using PVS-Studio C # for Linux</a></li>
<li><a href="../en504326/index.html">Evgeny Dikiy: ‚ÄúLocally, Antarctica is the least polluted, but global pollution is very noticeable here‚Äù</a></li>
<li><a href="../en504328/index.html">Electronic voting lessons at the Moscow City Duma 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>