<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÄ üëÑ üõ≥Ô∏è Backend-Driven UI with widgets üï∞Ô∏è üê¢ üë∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Consider the features of this approach and our implementation using widgets, their concept, advantages and differences from other views in Android.
 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Backend-Driven UI with widgets</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/498664/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the features of this approach and our implementation using widgets, their concept, advantages and differences from other views in Android.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/0z/p9/hd/0zp9hdtjfkdd28_s70pm46rqvw0.png"><br>
<a name="habracut"></a><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Backend-Driven UI - an approach that allows you to create UI-components based on server response. The API description should contain the types of components and their properties, and the application should display the necessary components depending on the types and properties. In general, the logic of the components can be laid down, and for a mobile application they are a black box, since each component can have logic independent of the rest of the application and can be configured arbitrarily by the server, depending on the required business logic. That is why this approach is often used in banking applications: for example, when you need to display a translation form with a large number of dynamically defined fields. The application does not know in advance the composition of the form and the order of the fields in it, therefore,this approach is the only way to write code without crutches. In addition, it adds flexibility: from the server side, you can change the form at any time, and the mobile application will be ready for this.</font></font><br>
<cut></cut><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use case</font></font></h3><br>
<img src="https://habrastorage.org/webt/kd/ao/vw/kdaovw36bkxi3ec-y5ajmidakke.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The following types of components are presented above:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of accounts available for transfer;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The name of the type of translation;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field for entering a phone number (it has a mask for entering and contains an icon for selecting contacts from the device);</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field for entering the transfer amount.</font></font></li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Also on the form, any number of other components embedded in the business logic and determined at the design stage is possible. Information about each component that comes in the response from the server must meet the requirements, and each component must be expected by the mobile application to process it correctly. </font></font><br>
<br>
<img src="https://habrastorage.org/webt/j9/3g/hu/j93ghualguxt2lxhch93sraomys.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Different input fields have different masks and validation rules; the button may have a shimmer animation at boot time; a widget for selecting a charge-off account can have animation when scrolling, and so on. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
All UI components are independent of each other, and the logic can be taken out into separate views with different areas of responsibility - let's call them widgets. Each widget receives its configuration in the server response and encapsulates the logic of display and data processing.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
When implementing the screen, RecyclerView is best suited, the elements of which will contain widgets. </font><font style="vertical-align: inherit;">The ViewHolder of each unique list item will initialize the widget and give it the data it needs to display.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget concept</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's consider widgets in more detail. </font><font style="vertical-align: inherit;">At its core, a widget is a custom view "at maximum speed." </font><font style="vertical-align: inherit;">An ordinary custom view can also contain data and the logic of their display, but the widget implies something more - it has a presenter, a screen model and has its own DI-scope. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Before diving into the details of the implementation of widgets, we discuss their advantages:</font></font><br>
<br>
<ul>
<li>     ,   ,   ¬´¬ª ,       ‚Äî     UI-  ,             .</li>
<li>        ,         ,         .</li>
<li>,     ‚Äî        :  ,      ,    .</li>
</ul><br>
<h3> </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
To implement scalable widgets, we use the base classes for the most commonly used ViewGroups, which have their own DI scopes. All base classes, in turn, are inherited from the common interface, which contains everything necessary for initializing widgets. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The easiest case for using widgets is static views, specified directly in the layout. After implementing the widget classes, you can safely add it to the XML layout, without forgetting to specify its id in the layout (based on the id, a widget's DI scope will be formed). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In this article, we consider dynamic widgets in more detail, since the case of the translation form described above with an arbitrary set of fields is conveniently solved with their help.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Any widget, both static and dynamic, in our implementation is almost no different from ordinary view in terms of MVP. </font><font style="vertical-align: inherit;">Typically, 4 classes are needed to implement a widget:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">View class, where layout layout and content displaying occurs;</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidget</span> <span class="hljs-meta">@JvmOverloads</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        context: Context,<font></font>
        attrs: AttributeSet? = <span class="hljs-literal">null</span><font></font>
) : CoreFrameLayoutView(context, attrs) {<font></font>
<span class="hljs-meta">@Inject</span>
<span class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> presenter: TextInputFieldPresenter<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">init</span> {<font></font>
     inflate(context, R.layout.view_field_text_input, <span class="hljs-keyword">this</span>)<font></font>
  }<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A class for the presenter, where the basic logic of the widget is described, for example:</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> loading data and transmitting it for a render;</font></font></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Subscribing to various events and emit events of widget input changes;</font></font></li>
</ol><br>
<pre><code class="kotlin hljs"><span class="hljs-meta">@PerScreen</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldPresenter</span> <span class="hljs-meta">@Inject</span> <span class="hljs-keyword">constructor</span></span>(<font></font>
        basePresenterDependency: BasePresenterDependency,<font></font>
        rxBus: RxBus<font></font>
) : BaseInputFieldPresenter&lt;TextInputFieldWidget&gt;(<font></font>
       basePresenterDependency, rxBus<font></font>
) {<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TextInputFieldScreenModel()<font></font>
...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In our implementation, the RxBus class is a PublishSubject-based bus for sending events and subscribing to them.</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A class for the screen model, with the help of which the presenter receives data and transfers it for rendering in a view (in terms of the Presentation Model pattern);</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldScreenModel</span> : <span class="hljs-type">ScreenModel</span></span>() {
	<span class="hljs-keyword">val</span> value = String = ‚Äú‚Äù
	<span class="hljs-keyword">val</span> hint = String = ‚Äú‚Äù
	<span class="hljs-keyword">val</span> errorText = String = ‚Äú‚Äù<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A configurator class for implementing DI, with the help of which dependencies for the widget are delivered that have the desired scope, and the presenter is injected into its view.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextInputFieldWidgetConfigurator</span> : <span class="hljs-type">WidgetScreenConfigurator</span></span>() {
	<span class="hljs-comment">// logic for components injection</span><font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The only difference between widgets and our implementation of full-fledged screens (Activity, Fragment) is that the widget does not have many life cycle methods (onStart, onResume, onPause). </font><font style="vertical-align: inherit;">It has only the onCreate method, which shows that the widget has currently created its scope, and the scoop is destroyed in the onDetachedFromWindow method. </font><font style="vertical-align: inherit;">But for convenience and consistency, the widget‚Äôs presenter gets the same lifecycle methods as the rest of the screens. </font><font style="vertical-align: inherit;">These events are automatically transmitted to him from the parent. </font><font style="vertical-align: inherit;">It should be noted that the base class of the widget presenter is the same base class of presenters of other screens.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using dynamic widgets</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Let's move on to the implementation of the case described at the beginning of the article.</font></font><br>
<br>
<ol>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the screen presenter, the data for the translation form is loaded, the data is transmitted to the view for rendering. </font><font style="vertical-align: inherit;">At this stage, it doesn‚Äôt matter to us whether the view of the activity screen is a fragment or widget. </font><font style="vertical-align: inherit;">We are only interested in having RecyclerView and rendering a dynamic form with it.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormPresenter</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> sm = TransferFormScreenModel()<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">loadData</span><span class="hljs-params">()</span></span> {<font></font>
	loadDataDisposable.dispose()<font></font>
  	loadDataDisposable = subscribe(<font></font>
              observerDataForTransfer().io(), <font></font>
              { <span class="hljs-keyword">data</span> -&gt; <font></font>
                      sm.<span class="hljs-keyword">data</span> = <span class="hljs-keyword">data</span><font></font>
                      view.render(sm)<font></font>
              },<font></font>
              { error -&gt; <span class="hljs-comment">/* error handling */</span> }<font></font>
  	)<font></font>
 }<font></font>
</code></pre><br>
 </li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Form data is transferred to the list adapter and rendered using widgets that are in the ViewHolder for each unique form element. </font><font style="vertical-align: inherit;">The desired ViewHolder for rendering the component is determined based on predefined types of form components.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TransferFormView</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(sm: <span class="hljs-type">TransferFormScreenModel</span>)</span></span> {
    <span class="hljs-comment">//      </span>
    <span class="hljs-comment">//   EasyAdapter [3]</span>
    <span class="hljs-keyword">val</span> list = ItemList.create()
    <span class="hljs-comment">//       Controller,</span>
    <span class="hljs-comment">//       </span><font></font>
<font></font>
    sm.<span class="hljs-keyword">data</span><font></font>
        .filter { transferField -&gt; transferField.visible }<font></font>
        .forEach { transferField -&gt;<font></font>
            <span class="hljs-keyword">when</span> (transferField.type) {<font></font>
                TransferFieldType.PHONE_INPUT -&gt; {<font></font>
                    list.add(<font></font>
                        PhoneInputFieldData(transferField),<font></font>
                        phoneInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.MONEY -&gt; {<font></font>
                    list.add(<font></font>
                        MoneyInputFieldData(transferField),<font></font>
                        moneyInputController<font></font>
                    )<font></font>
                }<font></font>
                TransferFieldType.BUTTON -&gt; {<font></font>
                    list.add(<font></font>
                        ButtonInputFieldData(transferField),<font></font>
                        buttonController<font></font>
                    )<font></font>
                }<font></font>
                <span class="hljs-keyword">else</span> -&gt; {<font></font>
                    list.add(<font></font>
                        TextInputFieldData(transferField),<font></font>
                        textInputController<font></font>
                    )<font></font>
                }<font></font>
            }<font></font>
        }<font></font>
        <span class="hljs-comment">//     RecyclerView</span><font></font>
        adapter.setItems(list)<font></font>
}  <font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The widget is initialized in the bind method of ViewHolder. </font><font style="vertical-align: inherit;">In addition to transmitting data for the render, it is also important to set a unique id for the widget, on the basis of which its DI scope will be formed. </font><font style="vertical-align: inherit;">In our case, each element of the form had a unique id, which was responsible for the appointment of input and came in response in addition to the type of element (types can be repeated on the form).</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// ViewHolder</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">data</span>: <span class="hljs-type">TransferFieldUi</span>)</span></span> {
	<span class="hljs-comment">// get initialize params from given data</span><font></font>
	itemView.findViewById(R.id.field_tif).initialize(...)<font></font>
}<font></font>
</code></pre><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The initialize method initializes the widget view data, which is then transmitted to the presenter using the onCreate life cycle method, where the field values ‚Äã‚Äãare set to the widget model and its render.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">initialize</span><span class="hljs-params">(
       id: <span class="hljs-type">String</span> = this.id,
       value: <span class="hljs-type">String</span> = this.value,
       hint: <span class="hljs-type">String</span> = this.hint,
       errorText: <span class="hljs-type">String</span> = this.errorText
)</span></span> {
       <span class="hljs-keyword">this</span>.id = id
       <span class="hljs-keyword">this</span>.value = value
       <span class="hljs-keyword">this</span>.hint = hint
       <span class="hljs-keyword">this</span>.errorText = errorText<font></font>
}<font></font>
    <font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
       presenter.onCreate(value, hint, errorText)<font></font>
       <span class="hljs-comment">// other logic...</span><font></font>
}<font></font>
<span class="hljs-comment">// TextInputFieldPresenter</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, hint: <span class="hljs-type">String</span>, errorText: <span class="hljs-type">String</span>)</span></span> {<font></font>
       sm.value = value<font></font>
       sm.hint = hint<font></font>
       sm.errorText = errorText<font></font>
       view.render(sm)<font></font>
}<font></font>
</code></pre><br>
</li>
</ol><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Underwater rocks</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
As can be seen from the description, the implementation is very simple and intuitive. </font><font style="vertical-align: inherit;">However, there are nuances that need to be considered.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Consider the life cycle of widgets</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Since the base classes of widgets are inheritors of the commonly used ViewGroups, we also know the life cycle of widgets. </font><font style="vertical-align: inherit;">Typically, widgets are initialized in the ViewHolder by calling a special method where the data is transferred, as shown in the previous paragraph. </font><font style="vertical-align: inherit;">Other initialization takes place in onCreate (for example, setting click listeners) - this method is called after onAttachedToWindow using a special delegate that controls the key entities of the widget logic.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// CoreFrameLayoutView (      ViewGroup)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoreFrameLayoutView</span></span><font></font>
          extends FrameLayout implements CoreWidgetViewInterface {<font></font>
‚Ä¶<font></font>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> void onAttachedToWindow() {
   <span class="hljs-keyword">super</span>.onAttachedToWindow();
   <span class="hljs-keyword">if</span> (!isManualInitEnabled) {<font></font>
        widgetViewDelegate = createWidgetViewDelegate();<font></font>
        widgetViewDelegate.onCreate();<font></font>
   }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
    <span class="hljs-comment">//empty. define in descendant class if needed</span><font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// WidgetViewDelegate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WidgetViewDelegate</span> </span>{<font></font>
‚Ä¶<font></font>
<span class="hljs-keyword">public</span> void onCreate() {
   <span class="hljs-comment">// other logic of widget initialization</span><font></font>
   coreWidgetView.onCreate();<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Always clean the listeners</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
If there are dependent fields on the form, we may need onDetachedFromWindow. </font><font style="vertical-align: inherit;">Consider the following case: the translation form has many fields, among which there is a drop-down list. </font><font style="vertical-align: inherit;">Depending on the value selected in the list, an additional form input field may become visible or an existing one may disappear.</font></font><br>
<div class="scrollable-table"><table>
<tbody><tr>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dropdown value for choosing the type of translation</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Visibility of the payment period input field</font></font></th>
<th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">phone number input field visibility</font></font></th>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">transfer by phone number</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></td>
</tr>
<tr>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">payment</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></td>
<td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">false</font></font></td>
</tr>
</tbody></table></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
In the case described above, it is very important to clear all widget listeners in the onDetachedFromWindow method, since if you add the widget to the list again, all listeners will be reinitialized.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span></span> {<font></font>
     initListeners()<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onDetachedFromWindow</span><span class="hljs-params">()</span></span> {
      <span class="hljs-keyword">super</span>.onDetachedFromWindow()<font></font>
      clearListeners()<font></font>
}<font></font>
</code></pre><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Handle widget event subscriptions correctly</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The presentation of the screen containing the widgets should be notified of the changes in the input of each widget. The most obvious implementation of each widget using emit events and subscribing to all events with a screen presenter. The event must contain the widget id and its data. It is best to implement this logic so that the current input values ‚Äã‚Äãare saved in the screen model and when you click on the button, the finished data is sent in the request. With this approach, it is easier to implement form validation: it occurs when a button is clicked, and if there were no errors, the request is sent with the form data saved in advance.</font></font><br>
<br>
<pre><code class="kotlin hljs"><span class="hljs-comment">// TextInputFieldWidget</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> defaultTextChangedListener = <span class="hljs-keyword">object</span> : OnMaskedValueChangedListener {
        <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onValueChanged</span><span class="hljs-params">(value: <span class="hljs-type">String</span>)</span></span> {<font></font>
            presenter.onTextChange(value, id)<font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// Events.kt</span>
<span class="hljs-keyword">sealed</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputValueType</span></span>(<span class="hljs-keyword">val</span> id: String)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextValue</span></span>(id: String, <span class="hljs-keyword">val</span> value: String) : InputValueType(id)<font></font>
<font></font>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataEvent</span></span>(<span class="hljs-keyword">val</span> <span class="hljs-keyword">data</span>: InputValueType)<font></font>
<font></font>
<span class="hljs-comment">// TextInputFieldPresenter -  </span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onTextChange</span><span class="hljs-params">(value: <span class="hljs-type">String</span>, id: <span class="hljs-type">String</span>)</span></span> {<font></font>
	rxBus.emitEvent(DataEvent(<span class="hljs-keyword">data</span> = TextValue(id = id, value = value)))<font></font>
}<font></font>
<font></font>
<span class="hljs-comment">// TransferFormPresenter -  </span>
<span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">subscribeToEvents</span><span class="hljs-params">()</span></span> {<font></font>
	subscribe(rxBus.observeEvents(DataEvent::<span class="hljs-keyword">class</span>.java))<font></font>
        {<font></font>
            handleValue(it.<span class="hljs-keyword">data</span>) // handle <span class="hljs-keyword">data</span><font></font>
        }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">fun</span> handleValue(value: InputValueType) {
	 <span class="hljs-keyword">val</span> id = value.id
	 <span class="hljs-keyword">when</span> (value) {<font></font>
		 // handle event using its type, saving event value using its id<font></font>
	 	 <span class="hljs-keyword">is</span> TextValue -&gt; {<font></font>
       		 	 sm.fieldValuesMap[id] = value.value<font></font>
       	 	 }<font></font>
		 <span class="hljs-keyword">else</span> -&gt; {<font></font>
			// handle other events<font></font>
		 }<font></font>
 	 }<font></font>
}<font></font>
// TransferScreenModel<font></font>
<span class="hljs-keyword">class</span> TransferScreenModel : ScreenModel() {<font></font>
 	 // map <span class="hljs-keyword">for</span> form values: key = input id
	 <span class="hljs-keyword">val</span> fieldValuesMap: MutableMap&lt;String, String&gt; = mutableMapOf()<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
There is a second implementation option, in which events from widgets with their data come only after clicking on the button, and not as you type, that is, we collect all the data immediately before sending the request. </font><font style="vertical-align: inherit;">With this option, there will be much fewer events, but it is worth noting that this implementation may turn out to be nontrivial in practice, and additional logic will be needed to check whether all events have been received.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unify All Requirements</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
I would like to once again note that the described case is possible only after coordinating the requirements with the backend. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
What requirements need to be unified:</font></font><br>
<br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Field types. </font><font style="vertical-align: inherit;">Each field should be expected by the mobile application for its correct display and processing.</font></font></li>
<li>  ‚Äî     ,   ,     ,        .</li>
<li>   ,         .</li>
<li> .    ,          : ,    ,     ‚Äî              ,        -,     .</li>
</ul><br>
<img src="https://habrastorage.org/webt/vy/h-/v4/vyh-v4r81dk91ehe3t3j8fgurkq.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
This is necessary in order for the component received in the response to be known to the mobile application for the correct display and processing of logic. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
The second nuance is that the components of the form themselves are generally independent of each other, however, some scenarios are possible when, for example, the visibility of one element depends on the state of another, as described above. </font><font style="vertical-align: inherit;">To implement this logic, it is necessary that the dependent elements always come together, and the response must contain a description of the logic, which components depend on each other and how. </font><font style="vertical-align: inherit;">And of course, all this should be agreed with the server team before starting development.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Thus, when implementing even such a standard case as filling in a dynamic list, you can always not stop at already existing solutions. </font><font style="vertical-align: inherit;">For us, this was a new concept, which allowed us to select atomic pieces of logic and representation from huge screens and we managed to get a working extensible solution that is easy to maintain due to the similarity of widgets with other views. </font><font style="vertical-align: inherit;">In our implementation, widgets were developed in terms of the RxPM pattern - after adding binders, it became even more convenient to use widgets, but this is a completely different story.</font></font><br>
<br>
<h4><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">useful links</font></font></b></h4><br>
<ol>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Android application development </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;">framework Surf</font></a></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Widget module</font></font></a></li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Our </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">implementation of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> simple render of complex lists</font></font></li>
<li><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PresentationModel pattern</font></font></a></li>
</ol></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../en498654/index.html">What is VPS / VDS and how to buy it. The most intelligible instruction</a></li>
<li><a href="../en498656/index.html">Crohn Battery Test</a></li>
<li><a href="../en498658/index.html">OWASP Consortium Updated Web Security Testing Guide</a></li>
<li><a href="../en498660/index.html">How our unmanned tram sees the real city</a></li>
<li><a href="../en498662/index.html">How can COVID-19 change Google‚Äôs search results forever?</a></li>
<li><a href="../en498672/index.html">Buttons and their variety</a></li>
<li><a href="../en498674/index.html">Product Security Trends 2020 Online Conference Video Recordings</a></li>
<li><a href="../en498678/index.html">Mapping to the top of the mountain and a phonendoscope near the statue of Christ - how projectors allow you to express words of support in difficult times</a></li>
<li><a href="../en498680/index.html">E-sports club in isolation: distributed gaming as an opportunity not only to survive, but also to earn</a></li>
<li><a href="../en498686/index.html">Dark Corners iOS Auto renewable Subscriptions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>