<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏿 ⚪️ 🈵 Programmation asynchrone avec async / wait 🌈 🙋🏿 🌻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour mes amis! 
 
 Les ajouts JavaScript relativement nouveaux sont les fonctions asynchrones et le mot-clé wait. Ces fonctionnalités sont essentie...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Programmation asynchrone avec async / wait</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/491012/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bonjour mes amis! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les ajouts JavaScript relativement nouveaux sont les fonctions asynchrones et le mot-clé wait. </font><font style="vertical-align: inherit;">Ces fonctionnalités sont essentiellement du sucre syntaxique au-dessus des promesses (promesses), ce qui facilite l'écriture et la lecture de code asynchrone. </font><font style="vertical-align: inherit;">Ils font que le code asynchrone ressemble à synchrone. </font><font style="vertical-align: inherit;">Cet article vous aidera à comprendre ce qui est quoi. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Conditions: connaissances informatiques de base, connaissance des bases de JS, compréhension des bases du code asynchrone et promesses. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Objectif: Comprendre comment les promesses sont faites et comment elles sont utilisées.</font></font><br>
<a name="habracut"></a><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async / attente des bases</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation de async / wait comporte deux parties.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mot-clé asynchrone</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, nous avons le mot-clé async, que nous mettons avant la déclaration de fonction pour le rendre asynchrone. </font><font style="vertical-align: inherit;">Une fonction asynchrone est une fonction qui anticipe la possibilité d'utiliser le mot clé wait pour exécuter du code asynchrone. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayez de taper ce qui suit dans la console du navigateur:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La fonction renverra «Bonjour». </font><font style="vertical-align: inherit;">Rien d'inhabituel, non? </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Mais que faire si nous la transformons en fonction asynchrone? </font><font style="vertical-align: inherit;">Essayez ce qui suit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, un appel de fonction renvoie une promesse. </font><font style="vertical-align: inherit;">C'est l'une des caractéristiques des fonctions asynchrones - elles renvoient des valeurs qui sont garanties d'être converties en promesses. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également créer des expressions fonctionnelles asynchrones, comme ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> hello() }<font></font>
hello()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez également utiliser les fonctions fléchées:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> hello = <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello'</span> }
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes ces fonctions font la même chose. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin d'obtenir la valeur d'une promesse terminée, nous pouvons utiliser le bloc .then ():</font></font><br>
<br>
<pre><code class="javascript hljs">hello().then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> <span class="hljs-built_in">console</span>.log(value))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
... ou même ainsi:</font></font><br>
<br>
<pre><code class="javascript hljs">hello().then(<span class="hljs-built_in">console</span>.log)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ainsi, l'ajout du mot clé async fait que la fonction retourne une promesse au lieu d'une valeur. </font><font style="vertical-align: inherit;">De plus, il permet aux fonctions synchrones d'éviter toute surcharge associée à l'exécution et à la prise en charge de l'attente. </font><font style="vertical-align: inherit;">Un simple ajout d'async devant la fonction permet une optimisation automatique du code par le moteur JS. </font><font style="vertical-align: inherit;">Cool!</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mot clé en attente</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les avantages des fonctions asynchrones deviennent encore plus apparents lorsque vous les combinez avec le mot-clé wait. </font><font style="vertical-align: inherit;">Il peut être ajouté avant toute fonction basée sur une promesse pour faire attendre la fin de la promesse, puis renvoyer le résultat. </font><font style="vertical-align: inherit;">Après cela, le bloc de code suivant est exécuté. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez utiliser wait lorsque vous appelez une fonction qui renvoie une promesse, y compris les fonctions de l'API Web. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Voici un exemple trivial:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hello</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> greeting = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello'</span>)<font></font>
}<font></font>
<font></font>
hello().then(alert)<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bien sûr, le code ci-dessus est inutile, il ne sert que de démonstration de la syntaxe. </font><font style="vertical-align: inherit;">Passons à autre chose et regardons un exemple réel.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Réécriture du code sur les promesses en utilisant async / wait</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Prenez l'exemple de récupération de l'article précédent:</font></font><br>
<br>
<pre><code class="javascript hljs">fetch(<span class="hljs-string">'coffee.jpg'</span>)<font></font>
.then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.blob())<font></font>
.then(<span class="hljs-function"><span class="hljs-params">myBlob</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
})<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There has been a problem with your fetch operation: '</span> + e.message)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devriez déjà comprendre ce que sont les promesses et comment elles fonctionnent, mais réécrivons ce code en utilisant async / wait pour voir à quel point c'est simple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">let</span> myBlob = <span class="hljs-keyword">await</span> response.blob()<font></font>
<font></font>
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}<font></font>
<font></font>
myFetch().catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'There has been a problem with your fetch operation: '</span> + e.message)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela rend le code beaucoup plus simple et plus facile à comprendre - pas de blocs .then ()! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'utilisation du mot-clé async transforme une fonction en promesse, nous pouvons donc utiliser une approche mixte à partir des promesses et attendre, en mettant en évidence la deuxième partie de la fonction dans un bloc séparé afin d'augmenter la flexibilité:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.blob()<font></font>
}<font></font>
<font></font>
myFetch().then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(blob)
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'image'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez réécrire l'exemple ou exécuter notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo en direct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir aussi le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mais comment ça fonctionne?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons encapsulé le code à l'intérieur de la fonction et ajouté le mot clé async avant le mot clé function. Vous devez créer une fonction asynchrone pour déterminer le bloc de code dans lequel le code asynchrone s'exécutera; attendre ne fonctionne que dans les fonctions asynchrones. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Encore une fois: attendre ne fonctionne que dans les fonctions asynchrones.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
À l'intérieur de la fonction myFetch (), le code ressemble beaucoup à la version promise, mais avec quelques différences. Au lieu d'utiliser le bloc .then () après chaque méthode basée sur la promesse, ajoutez simplement le mot clé wait avant d'appeler la méthode et attribuez une valeur à la variable. Le mot-clé wait fait interrompre l'exécution du code JS sur une ligne donnée, permettant à un autre code de s'exécuter jusqu'à ce que la fonction asynchrone renvoie un résultat. Une fois exécuté, le code continuera son exécution à partir de la ligne suivante. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par exemple:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La valeur renvoyée par la promesse fetch () est affectée à la variable de réponse lorsque la valeur donnée devient disponible, et l'analyseur s'arrête à cette ligne jusqu'à ce que la promesse soit terminée. </font><font style="vertical-align: inherit;">Dès que la valeur devient disponible, l'analyseur passe à la ligne de code suivante qui crée le blob. </font><font style="vertical-align: inherit;">Cette ligne appelle également la méthode asynchrone basée sur les promesses, donc ici nous utilisons également wait. </font><font style="vertical-align: inherit;">Lorsque le résultat de l'opération revient, nous le renvoyons à partir de la fonction myFetch (). </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que lorsque nous appelons la fonction myFetch (), elle renvoie une promesse, nous pouvons donc y ajouter .then (), à l'intérieur de laquelle nous gérons l'affichage de l'image à l'écran.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pensez probablement "C'est génial!" Et vous avez raison - moins de blocs .then () pour encapsuler le code, tout cela ressemble à du code synchrone, donc c'est intuitif.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ajouter la gestion des erreurs</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez ajouter la gestion des erreurs, vous avez plusieurs options. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez utiliser la structure synchrone try ... catch avec async / wait. </font><font style="vertical-align: inherit;">Cet exemple est une version étendue du code ci-dessus:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">try</span>{
        <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">'coffee.jpg'</span>)
        <span class="hljs-keyword">let</span> myBlob = <span class="hljs-keyword">await</span> response.blob()<font></font>
<font></font>
        <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL(myBlob)
        <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
        image.src = objectURL<font></font>
        <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
    } <span class="hljs-keyword">catch</span>(e){
        <span class="hljs-built_in">console</span>.log(e)<font></font>
    }<font></font>
}<font></font>
<font></font>
myFetch()<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le bloc catch () {} accepte un objet d'erreur, que nous avons nommé "e"; </font><font style="vertical-align: inherit;">Maintenant, nous pouvons le sortir sur la console, cela nous permettra de recevoir un message indiquant où l'erreur s'est produite dans le code. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez utiliser la deuxième version du code ci-dessus, vous devez simplement continuer d'utiliser l'approche hybride et ajouter le bloc .catch () à la fin de l'appel .then (), comme suit:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFetch</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> fecth(<span class="hljs-string">'coffee.jpg'</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> response.blob()<font></font>
}<font></font>
<font></font>
myFetch().then(<span class="hljs-function">(<span class="hljs-params">blob</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> objectURL = URL.createObjectURL
    <span class="hljs-keyword">let</span> image = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image.src = objectURL<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image)<font></font>
}).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela est possible car le bloc .catch () interceptera les erreurs qui se produisent à la fois dans la fonction asynchrone et dans la chaîne de promesses. </font><font style="vertical-align: inherit;">Si vous utilisez le bloc try / catch ici, vous ne pourrez pas gérer les erreurs qui se produisent lorsque la fonction myFetch () est appelée. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez trouver les deux exemples sur GitHub: </font></font><br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple-fetch-async-wait-try-catch.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><br>
<br>
<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">simple-fetch-async-wait-promise-catch.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En attente de Promise.all ()</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Wait est basé sur des promesses, vous pouvez donc profiter pleinement de ces dernières. </font><font style="vertical-align: inherit;">Il s'agit notamment de Promise.all () en particulier - vous pouvez facilement ajouter attendre à Promise.all () pour écrire toutes les valeurs de retour d'une manière similaire au code synchrone. </font><font style="vertical-align: inherit;">Encore une fois, reprenons l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">exemple de l'article précédent</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Gardez un onglet ouvert avec lui pour comparer avec le code ci-dessous. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avec async / wait (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">la démo en direct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ), cela ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAndDecode</span>(<span class="hljs-params">url, type</span>)</span>{
    <span class="hljs-keyword">let</span> repsonse = <span class="hljs-keyword">await</span> fetch(url)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> content<font></font>
<font></font>
    <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'blob'</span>){<font></font>
        content = <span class="hljs-keyword">await</span> response.blob()<font></font>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(type === <span class="hljs-string">'text'</span>){<font></font>
        content = <span class="hljs-keyword">await</span> response.text()<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">return</span> content<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayContent</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">let</span> coffee = fetchAndDecode(<span class="hljs-string">'coffee.jpg'</span>, <span class="hljs-string">'blob'</span>)
    <span class="hljs-keyword">let</span> tea = fetchAndDecode(<span class="hljs-string">'tea.jpg'</span>, <span class="hljs-string">'blob'</span>)
    <span class="hljs-keyword">let</span> description = fetchAndDecode(<span class="hljs-string">'description.txt'</span>, <span class="hljs-string">'text'</span>)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> values = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([coffee, tea, description])<font></font>
<font></font>
    <span class="hljs-keyword">let</span> objectURL1 = URL.createObjectURL(values[<span class="hljs-number">0</span>])
    <span class="hljs-keyword">let</span> objectURL2 = URL.createObjectURL(values[<span class="hljs-number">1</span>])
    <span class="hljs-keyword">let</span> descText = values[<span class="hljs-number">2</span>]<font></font>
<font></font>
    <span class="hljs-keyword">let</span> image1 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)
    <span class="hljs-keyword">let</span> image2 = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'img'</span>)<font></font>
    image1.src = objectURL1<font></font>
    image2.src = objectURL2<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(image1)
    <span class="hljs-built_in">document</span>.body.appendChild(image2)<font></font>
<font></font>
    <span class="hljs-keyword">let</span> para = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'p'</span>)<font></font>
    para.textContent = descText<font></font>
    <span class="hljs-built_in">document</span>.body.appendChild(para)<font></font>
}<font></font>
<font></font>
displayContent()<font></font>
.catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(e))
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons facilement rendu la fonction fetchAndDecode () asynchrone avec quelques modifications. </font><font style="vertical-align: inherit;">Faites attention à la ligne:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> values = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([coffee, tea, description])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En utilisant wait, nous obtenons les résultats de trois promesses dans la variable values, d'une manière similaire au code synchrone. </font><font style="vertical-align: inherit;">Nous devons encapsuler la fonction entière dans une nouvelle fonction asynchrone, displayContent (). </font><font style="vertical-align: inherit;">Nous n'avons pas obtenu une forte réduction de code, mais avons pu extraire la majeure partie du code du bloc .then (), ce qui fournit une simplification utile et rend le code plus lisible. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour gérer les erreurs, nous avons ajouté un bloc .catch () à notre appel à displayContent (); </font><font style="vertical-align: inherit;">Il gère les erreurs des deux fonctions. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
N'oubliez pas: vous pouvez également utiliser le bloc .finally () pour obtenir un rapport sur l'opération - vous pouvez le voir en action dans notre </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">démo en direct</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir aussi le </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">code source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ).</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchroniser / attendre les inconvénients</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / attendent a quelques défauts. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Wait donne au code un aspect synchrone et, dans un sens, le fait se comporter de manière plus synchrone. Le mot-clé wait bloque l'exécution du code qui le suit jusqu'à la fin de la promesse, comme cela se produit dans une opération synchrone. Cela vous permet d'effectuer d'autres tâches, mais votre propre code est verrouillé. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Cela signifie que votre code peut être ralenti par un grand nombre de promesses en attente qui se succèdent. Chaque attente attendra la fin de la précédente, tandis que nous aimerions que les promesses soient tenues simultanément, comme si nous n'utilisions pas async / wait.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il existe un modèle de conception pour atténuer ce problème - la désactivation de tous les processus de promesse en stockant les objets Promise dans des variables, puis en les attendant. </font><font style="vertical-align: inherit;">Voyons comment cela est mis en œuvre. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous avons deux exemples à notre disposition: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slow-async-wait.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) et </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fast-async-wait.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (voir </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">le code source</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Les deux exemples commencent par une fonction de promesse qui imite une opération asynchrone à l'aide de setTimeout ():</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeoutPromise</span>(<span class="hljs-params">interval</span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {<font></font>
        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<font></font>
            resolve(<span class="hljs-string">'done'</span>)<font></font>
        }, interval)<font></font>
    })<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Suit ensuite la fonction asynchrone timeTest (), qui attend trois appels à timeoutPromise ():</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{<font></font>
    ...<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Chacun des trois appels à timeTest () se termine par un enregistrement du temps qu'il a fallu pour remplir la promesse, puis le temps qu'il faut pour terminer l'ensemble de l'opération est enregistré:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> startTime = <span class="hljs-built_in">Date</span>.now()<font></font>
timeTest().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">let</span> finishTime = <span class="hljs-built_in">Date</span>.now()
    <span class="hljs-keyword">let</span> timeTaken = finishTime - startTime<font></font>
    alert(<span class="hljs-string">'Time taken in milliseconds: '</span> + timeTaken)<font></font>
})<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans chaque cas, la fonction timeTest () est différente. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans slow-async-wait.html timeTest () ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">await</span> timeoutPromise(<span class="hljs-number">3000</span>)<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous attendons seulement trois appels à timeoutPromise, en définissant à chaque fois un délai de 3 secondes. </font><font style="vertical-align: inherit;">Chaque appel attend la fin du précédent - si vous exécutez le premier exemple, vous verrez une fenêtre modale dans environ 9 secondes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans fast-async-wait.html timeTest () ressemble à ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeTest</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">const</span> timeoutPromise1 = timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">const</span> timeoutPromise2 = timeoutPromise(<span class="hljs-number">3000</span>)
    <span class="hljs-keyword">const</span> timeoutPromise3 = timeoutPromise(<span class="hljs-number">3000</span>)<font></font>
<font></font>
    <span class="hljs-keyword">await</span> timeoutPromise1
    <span class="hljs-keyword">await</span> timeoutPromise2
    <span class="hljs-keyword">await</span> timeoutPromise3<font></font>
}<font></font>
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Ici, nous enregistrons trois objets Promise dans des variables, ce qui entraîne l'exécution simultanée des processus qui lui sont associés. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
De plus, nous attendons leurs résultats - comme les promesses commencent à être tenues simultanément, les promesses seront également réalisées en même temps; </font><font style="vertical-align: inherit;">lorsque vous exécutez le deuxième exemple, vous verrez une fenêtre modale dans environ 3 secondes! </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez soigneusement tester le code et garder cela à l'esprit tout en réduisant les performances. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Un autre inconvénient mineur est la nécessité d'encapsuler les promesses attendues dans une fonction asynchrone.</font></font><br>
<br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utiliser async / wait avec les classes</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En conclusion, nous notons que vous pouvez ajouter async même dans les méthodes de création de classes afin qu'elles retournent des promesses et attendent des promesses à l'intérieur. </font><font style="vertical-align: inherit;">Prenez le code de l' </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">article sur JS orienté objet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et comparez-le avec la version modifiée en utilisant async:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>{
    <span class="hljs-keyword">constructor</span>(first, last, age, gender, interests){
        <span class="hljs-keyword">this</span>.name = {<font></font>
            first,<font></font>
            last<font></font>
        }<font></font>
        <span class="hljs-keyword">this</span>.age = age
        <span class="hljs-keyword">this</span>.gender = gender
        <span class="hljs-keyword">this</span>.interests = interests<font></font>
    }<font></font>
<font></font>
    <span class="hljs-keyword">async</span> greeting(){
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">`Hi! I'm <span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span>`</span>)<font></font>
    }<font></font>
<font></font>
    farewell(){<font></font>
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${<span class="hljs-keyword">this</span>.name.first}</span> has left the building. Bye for now!`</span>)<font></font>
    }<font></font>
}<font></font>
<font></font>
<span class="hljs-keyword">let</span> han = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'Han'</span>, <span class="hljs-string">'Solo'</span>, <span class="hljs-number">25</span>, <span class="hljs-string">'male'</span>, [<span class="hljs-string">'Smuggling'</span>])
</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La méthode de classe peut être utilisée comme suit:</font></font><br>
<br>
<pre><code class="javascript hljs">han.greeting().then(<span class="hljs-built_in">console</span>.log)
</code></pre><br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prise en charge du navigateur</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
L'un des obstacles à l'utilisation d'Async / Wait est le manque de prise en charge des anciens navigateurs. </font><font style="vertical-align: inherit;">Cette fonctionnalité est disponible dans presque tous les navigateurs modernes, ainsi que dans les promesses; </font><font style="vertical-align: inherit;">Certains problèmes existent dans Internet Explorer et Opera Mini. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Si vous souhaitez utiliser async / wait, mais avez besoin de la prise en charge d'anciens navigateurs, vous pouvez utiliser la bibliothèque </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BabelJS</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - elle vous permet d'utiliser la dernière version de JS, en la convertissant en une version spécifique au navigateur.</font></font><br>
<br>
<h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conclusion</font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Async / Wait vous permet d'écrire du code asynchrone facile à lire et à gérer. </font><font style="vertical-align: inherit;">Bien que asynchrone / attente soit pire pris en charge que d'autres façons d'écrire du code asynchrone, cela vaut vraiment la peine d'être exploré. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Merci de votre attention. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Bon codage!</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr490998/index.html">Test de matériel dans SIBUR</a></li>
<li><a href="../fr491000/index.html">Option de sélection de style (presque) sans JavaScript</a></li>
<li><a href="../fr491006/index.html">Intel NUC comme passe dans Unity3D</a></li>
<li><a href="../fr491008/index.html">Vieux bien oublié</a></li>
<li><a href="../fr491010/index.html">Une sélection d'articles sur l'apprentissage automatique: cas, guides et études pour février 2020</a></li>
<li><a href="../fr491016/index.html">Numéro 32: Formation informatique - problèmes et défis actuels des grandes entreprises</a></li>
<li><a href="../fr491018/index.html">Création d'une boutique en ligne sur Nuxt.js 2 Procédure pas à pas, partie 2</a></li>
<li><a href="../fr491028/index.html">Seigneur des mouches</a></li>
<li><a href="../fr491030/index.html">Déployer Mediawiki sur Debian (c'est très simple)</a></li>
<li><a href="../fr491032/index.html">"RTFM, mec!", Ou comment le fromage gratuit m'a coûté 5 $. Et cela aurait pu être à 80 $ et plus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>