<!doctype html>
<html class="no-js" lang="fr">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-13"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-13');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíπ ü§õüèø üò¶ Faites-le vous-m√™me en 3D. Partie 1: pixels et lignes ‚òÇÔ∏è üéç üßóüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Je veux consacrer cette s√©rie d'articles aux lecteurs qui souhaitent explorer le monde de la programmation 3D √† partir de z√©ro, aux personnes qui veul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://geek-week.github.io/index.html"></a>
    <div class="page-header-text">Get best of the week</div>
  </header>
  <section class="page js-page"><h1>Faites-le vous-m√™me en 3D. Partie 1: pixels et lignes</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/494094/"><img src="https://habrastorage.org/webt/-u/-n/6a/-u-n6axbw6fowganklzotzai0sk.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je veux consacrer cette s√©rie d'articles aux lecteurs qui souhaitent explorer le monde de la programmation 3D √† partir de z√©ro, aux personnes qui veulent apprendre les bases de la cr√©ation du composant 3D des jeux et des applications. </font><font style="vertical-align: inherit;">Nous allons impl√©menter chaque op√©ration √† partir de z√©ro afin de comprendre tous les aspects, m√™me s'il existe d√©j√† une fonction pr√™te √† l'emploi qui la rend plus rapide. </font><font style="vertical-align: inherit;">Apr√®s avoir appris, nous passerons aux outils int√©gr√©s pour travailler avec la 3D. </font><font style="vertical-align: inherit;">Apr√®s avoir lu la s√©rie d'articles, vous comprendrez comment cr√©er des sc√®nes tridimensionnelles complexes avec de la lumi√®re, des ombres, des textures et des effets, comment faire tout cela sans connaissances approfondies en math√©matiques, et bien plus encore. </font><font style="vertical-align: inherit;">Vous pouvez faire tout cela √† la fois ind√©pendamment et √† l'aide d'outils pr√™ts √† l'emploi.</font></font><br>
<a name="habracut"></a><br>
<b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans la premi√®re partie, nous consid√©rerons:</font></font><br>
</b><br>
<ul>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Concepts de rendu (logiciel, mat√©riel)</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Qu'est-ce qu'un pixel / surface?</font></font><br>
</li>
<li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Analyse d√©taill√©e de la sortie ligne</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Afin de ne pas perdre votre temps pr√©cieux √† lire des articles, qui peuvent √™tre incompr√©hensibles pour une personne non pr√©par√©e, je me tournerai imm√©diatement vers les exigences. Vous pouvez commencer √† lire des articles sur la 3D en toute s√©curit√©, si vous connaissez les bases de la programmation dans n'importe quel langage, car Je me concentrerai uniquement sur l'√©tude de la programmation 3D, et non sur l'√©tude des caract√©ristiques du langage et des fondamentaux de la programmation. En ce qui concerne la pr√©paration math√©matique, ne vous inqui√©tez pas ici, bien que beaucoup n'aient pas envie d'√©tudier la 3D, car ils sont effray√©s par des calculs complexes et des formules furieuses √† cause desquelles les cauchemars r√™vent plus tard, mais en fait il n'y a rien √† craindre. Je vais essayer d'expliquer le plus clairement possible tout ce qui est n√©cessaire pour la 3D, il suffit de pouvoir multiplier, diviser, additionner et soustraire. Donc, si vous avez r√©ussi les crit√®res de s√©lection, vous pouvez commencer √† lire.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Avant de commencer √† explorer le monde int√©ressant de la 3D, choisissons un langage de programmation pour les exemples, ainsi qu'un environnement de d√©veloppement. Quelle langue dois-je choisir pour programmer des graphiques 3D? N'importe qui, vous pouvez travailler l√† o√π vous √™tes le plus √† l'aise, les math√©matiques seront les m√™mes partout. Dans cet article, tous les exemples seront pr√©sent√©s dans le contexte de JS (ici les tomates volent en moi). Pourquoi js? C'est simple - ces derniers temps, j'ai travaill√© principalement avec lui, et donc je peux vous transmettre plus efficacement l'essence. Je contournerai toutes les fonctionnalit√©s de JS dans les exemples, car nous n'avons besoin que des fonctionnalit√©s les plus √©l√©mentaires de toutes les langues, nous ferons donc particuli√®rement attention √† la 3D. Mais vous choisissez ce que vous aimez, car dans les articles, toutes les formules ne seront li√©es aux fonctionnalit√©s d'aucun langage de programmation. Quel environnement choisir? Ce n'est pas important,dans le cas de JS, n'importe quel √©diteur de texte convient, vous pouvez utiliser celui qui est le plus proche de vous.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les exemples utiliseront une toile pour la peinture, comme avec lui, vous pouvez commencer √† dessiner tr√®s rapidement, sans analyse d√©taill√©e. Canvas est un outil puissant, avec de nombreuses m√©thodes de dessin pr√™tes √† l'emploi, mais de toutes ses fonctionnalit√©s, pour la premi√®re fois, nous n'utiliserons que la sortie pixel!&nbsp; </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tous les affichages en trois dimensions sur l'√©cran utilisant des pixels, plus loin dans les articles, vous verrez comment cela se produit. Va-t-il ralentir? Sans acc√©l√©ration mat√©rielle (par exemple, acc√©l√©ration par une carte vid√©o) - sera. Dans le premier article, nous n'utiliserons pas d'acc√©l√©rations, nous √©crirons tout √† partir de z√©ro afin de comprendre les aspects fondamentaux de la 3D. Regardons quelques termes qui seront mentionn√©s dans les prochains articles:</font></font><br>
<br>
<ul>
<li><i> (Rendering)</i> ‚Äî    3D-    . ,     3D-     ,        ,        .</li>
<li><i>  (Software Rendering) </i> ‚Äî     .  ,  , ,    -  .       ,     .       3D-   ,    ‚Äî  .</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rendu mat√©riel</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - Un processus de rendu assist√© par mat√©riel. </font><font style="vertical-align: inherit;">Je l'utilise jeux et applications. </font><font style="vertical-align: inherit;">Tout fonctionne tr√®s rapidement, car </font><font style="vertical-align: inherit;">beaucoup de calcul de routine prend le relais de la carte vid√©o, qui est con√ßue pour cela.</font></font></li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je n'aspire pas au titre "d√©finition de l'ann√©e" et j'essaie de formuler le plus clairement possible toutes les descriptions des termes. </font><font style="vertical-align: inherit;">L'essentiel est de comprendre l'id√©e, qui peut ensuite √™tre d√©velopp√©e ind√©pendamment. </font><font style="vertical-align: inherit;">Je tiens √©galement √† attirer l'attention sur le fait que tous les exemples de code qui seront pr√©sent√©s dans les articles ne sont souvent pas optimis√©s pour la vitesse, afin de maintenir la facilit√© de compr√©hension. </font><font style="vertical-align: inherit;">Lorsque vous comprenez l'essentiel - le fonctionnement des graphiques 3D, vous pouvez tout optimiser vous-m√™me. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tout d'abord, cr√©ez un projet, pour moi, c'est juste un </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fichier</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> texte </font><i><font style="vertical-align: inherit;">index.html</font></i><font style="vertical-align: inherit;"> , avec le contenu suivant:</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>3D it‚Äôs easy. Part 1<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">&lt;!--         --&gt;</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"surface"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"800"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"600"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-comment">//    </span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><font></font>
<font></font>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Je ne vais pas trop me concentrer sur JS et canvas maintenant - ce ne sont pas les personnages principaux de cet article. </font><font style="vertical-align: inherit;">Mais pour une compr√©hension g√©n√©rale, je pr√©ciserai que &lt;canvas ...&gt; est un rectangle (dans mon cas, de 800 x 600 pixels) sur lequel je vais afficher tous les graphiques. </font><font style="vertical-align: inherit;">J'ai enregistr√© la toile une fois et je ne la changerai plus.</font></font><br>
<br>
<pre><code class="html hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span> ‚Ä¶ <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>&nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Script - un √©l√©ment dans lequel nous √©crirons toute la logique de rendu graphique 3D de nos propres mains (en JavaScript).&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous venons de revoir la structure du fichier </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">index.html</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> du </font><font style="vertical-align: inherit;">projet nouvellement cr√©√©, nous allons commencer √† traiter des graphiques 3D.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Lorsque nous dessinons quelque chose dans la fen√™tre, cela dans le d√©compte final se transforme en pixels, car ce sont eux que le moniteur affiche. Plus il y a de pixels, plus l'image est nette, mais l'ordinateur charge √©galement plus. Comment ce que nous dessinons dans la fen√™tre est-il stock√©? Les graphiques dans n'importe quelle fen√™tre peuvent √™tre repr√©sent√©s comme un tableau de pixels, et le pixel lui-m√™me n'est qu'une couleur. Autrement dit, une r√©solution d'√©cran de 800x600 signifie que notre fen√™tre contient 600 lignes de 800 pixels chacune, √† savoir 800 * 600 = 480000 pixels, beaucoup, n'est-ce pas? Les pixels sont stock√©s dans un tableau. Pensons dans quel tableau nous stockons les pixels. Si nous devons avoir 800 par 600 pixels, alors l'option la plus √©vidente est dans un tableau bidimensionnel de 800 par 600. Et c'est presque la bonne option, ou plut√¥t, l'option compl√®tement correcte. Mais les pixels de la fen√™tre, il est pr√©f√©rable de stocker dans un tableau unidimensionnel de 480 000 √©l√©ments (si la r√©solution est de 800 par 600),juste parce qu'il est plus rapide de travailler avec un tableau unidimensionnel, car il est stock√© en m√©moire dans une s√©quence continue d'octets (tout se trouve √† proximit√© et donc il est facile de l'obtenir). Dans un tableau √† deux dimensions (par exemple, dans le cas de JS), chaque ligne peut √™tre dispers√©e √† diff√©rents endroits de la m√©moire, donc l'acc√®s aux √©l√©ments d'un tel tableau prendra plus de temps. De plus, pour parcourir un tableau unidimensionnel, un seul cycle est n√©cessaire, et pour les entiers bidimensionnels 2, √©tant donn√© la n√©cessit√© de faire des dizaines de milliers d'it√©rations du cycle, la vitesse est ici importante. Qu'est-ce qu'un pixel dans un tel tableau? Comme mentionn√© ci-dessus - ce n'est qu'une couleur, ou plut√¥t 3 de ses composants (rouge, vert, bleu). N'importe quelle image, m√™me la plus color√©e, n'est qu'un tableau de pixels de diff√©rentes couleurs. Un pixel en m√©moire peut √™tre stock√© comme vous le souhaitez, soit un tableau de 3 √©l√©ments, soit dans une structure o√π le rouge, le vert,bleu; ou autre chose. Une image compos√©e d'un tableau de pixels que nous venons d'analyser, je continuerai d'appeler la surface. Il s'av√®re que puisque tout ce qui est affich√© √† l'√©cran est stock√© dans un tableau de pixels, puis en changeant les √©l√©ments (pixels) dans ce tableau - nous allons changer pixel par pixel l'image √† l'√©cran. C'est exactement ce que nous allons faire dans cet article.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a pas de fonction de dessin de pixels dans le canevas, mais il est possible d'acc√©der √† un tableau unidimensionnel de pixels, dont nous avons discut√© ci-dessus. </font><font style="vertical-align: inherit;">La proc√©dure √† suivre est indiqu√©e dans l'exemple ci-dessous (cet exemple et tous les autres √† l'avenir ne seront que dans l'√©l√©ment de script):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     ()    </span>
<span class="hljs-keyword">const</span> ctx = <span class="hljs-built_in">document</span>
.getElementById(<span class="hljs-string">'surface'</span>)<font></font>
.getContext(<span class="hljs-string">'2d'</span>)<font></font>
<font></font>
<span class="hljs-comment">//     ,   &nbsp;</span>
<span class="hljs-comment">// +       </span>
<span class="hljs-keyword">const</span> imageData = ctx.createImageData(<span class="hljs-number">800</span>, <span class="hljs-number">600</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple, imageData est un objet dans lequel il y a 3 propri√©t√©s:</font></font><br>
<br>
<ul>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hauteur et largeur</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - entiers stockant la hauteur et la largeur de la fen√™tre pour le dessin</font></font><br>
</li>
<li><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">donn√©es</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - tableau d'entiers non sign√©s 8 bits (vous pouvez y stocker des nombres compris entre 0 et 255)</font></font><br>
</li>
</ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau de donn√©es a une structure simple mais explicative. </font><font style="vertical-align: inherit;">Ce tableau unidimensionnel stocke les donn√©es de chaque pixel, que nous afficherons √† l'√©cran au format suivant:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Les 4 premiers √©l√©ments du tableau (indices 0,1,2,3) sont les donn√©es du premier pixel de la premi√®re ligne. Les 4 seconds √©l√©ments (indices 4, 5, 6, 7) sont les donn√©es du deuxi√®me pixel de la premi√®re ligne. Lorsque nous arrivons au 800e pixel de la premi√®re ligne, √† condition que la fen√™tre ait une largeur de 800 pixels - le 801e pixel appartiendra d√©j√† √† la deuxi√®me ligne. Si nous le changeons, √† l'√©cran, nous verrons que le 1er pixel de la 2e ligne a chang√© (bien que par le nombre dans le tableau ce sera le 801e pixel). Pourquoi y a-t-il 4 √©l√©ments pour chaque pixel du tableau? En effet, en toile, en plus d'allouer 1 √©l√©ment pour chaque couleur - rouge, vert, bleu (ce sont 3 √©l√©ments), 1 √©l√©ment de plus pour la transparence (ils disent aussi le canal alpha ou l'opacit√©). Le canal alpha, comme la couleur, est d√©fini dans la plage de 0 (transparent) √† 255 (opaque). Avec cette structure, nous obtenons une image 32 bits,car chaque pixel est compos√© de 4 √©l√©ments de 8 bits. Pour r√©sumer: chaque pixel contient: couleurs rouge, vert, bleu et canal alpha (transparence). Ce sch√©ma de couleurs est appel√© ARGB (Alpha Red Green Blue). Et le fait que chaque pixel occupe 32 bits indique que nous avons une image 32 bits (ils disent aussi une image avec une profondeur de couleur de 32 bits).</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Par d√©faut, l'ensemble du tableau de pixels imageData.data (les donn√©es sont une propri√©t√© dans laquelle le tableau de pixels et imageData n'est qu'un objet) est rempli avec les valeurs 0, et si nous essayions de sortir un tel tableau, nous ne verrions rien d'int√©ressant √† l'√©cran, car 0 , 0, 0 est noir, mais comme la transparence ici sera √©galement 0, et c'est une couleur compl√®tement transparente, nous ne verrons m√™me pas le noir √† l'√©cran!</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'est pas pratique de travailler directement avec un tel tableau unidimensionnel, nous allons donc lui √©crire une classe dans laquelle nous allons cr√©er des m√©thodes de dessin. Je nommerai la classe - Tiroir. Cette classe ne stockera que les donn√©es n√©cessaires et effectuera les calculs n√©cessaires, en faisant abstraction autant que possible de l'outil utilis√© pour le rendu. C'est pourquoi nous placerons tous les calculs et travaillerons avec le tableau dedans. Et l'appel m√™me √† la m√©thode d'affichage sur toile, nous allons placer en dehors de la classe, car il pourrait y avoir autre chose au lieu de la toile. Dans ce cas, notre classe ne devra pas √™tre chang√©e. Pour travailler avec un tableau de pixels (surface), il est plus pratique pour nous de l'enregistrer dans la classe Drawer, ainsi que la largeur et la hauteur de l'image, afin que nous puissions acc√©der correctement au pixel souhait√©. Ainsi, la classe Drawer, tout en pr√©servant les donn√©es minimales n√©cessaires au dessin, ressemble √† ceci pour moi:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;surface = <span class="hljs-literal">null</span>
&nbsp;&nbsp;&nbsp;&nbsp;width = <span class="hljs-number">0</span>
&nbsp;&nbsp;&nbsp;&nbsp;height = <span class="hljs-number">0</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">constructor</span>(surface, width, height) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface = surface
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.width = width
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.height = height<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comme vous pouvez le voir dans le constructeur, la classe Drawer prend toutes les donn√©es n√©cessaires et les enregistre. </font><font style="vertical-align: inherit;">Vous pouvez maintenant cr√©er une instance de cette classe et y passer un tableau de pixels, largeur et hauteur (nous avons d√©j√† toutes ces donn√©es, car nous l'avons cr√©√© ci-dessus et stock√© dans imageData):</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> drawer = <span class="hljs-keyword">new</span> Drawer(<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.data,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.width,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;imageData.height<font></font>
)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans la classe Drawer, nous √©crirons plusieurs fonctions de dessin, pour faciliter le travail √† l'avenir. </font><font style="vertical-align: inherit;">Nous aurons une fonction pour dessiner un pixel, une fonction pour dessiner une ligne, et dans d'autres articles des fonctions pour dessiner un triangle et d'autres formes appara√Ætront. </font><font style="vertical-align: inherit;">Mais commen√ßons par la m√©thode de dessin au pixel. </font><font style="vertical-align: inherit;">Je l'appellerai drawPixel. </font><font style="vertical-align: inherit;">Si nous dessinons un pixel, il devrait avoir des coordonn√©es, ainsi que de la couleur:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b)&nbsp; { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Veuillez noter que la fonction drawPixel n'accepte pas le param√®tre alpha (transparence), et ci-dessus, nous avons compris que le tableau de pixels se compose de 3 param√®tres de couleur et 1 param√®tre de transparence. Je n'ai pas sp√©cifiquement indiqu√© la transparence, car nous n'en avons absolument pas besoin pour les exemples. Par d√©faut, nous d√©finirons 255 (c'est-√†-dire que tout sera opaque). Voyons maintenant comment √©crire la couleur souhait√©e dans un tableau de pixels en coordonn√©es x, y. Puisque nous avons toutes les informations sur l'image sont stock√©es dans un tableau unidimensionnel, dans lequel 1 pixel (8 bits) est allou√© pour chaque pixel. Pour acc√©der au pixel souhait√© dans le tableau, nous devons d'abord d√©terminer l'indice de localisation rouge, car tout pixel commence par lui (par exemple [r, g, b, a]). Une petite explication de la structure du tableau:</font></font><br>
<br>
<img src="https://habrastorage.org/webt/uz/4j/8o/uz4j8olujyuhzo3z1anuexucnoc.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Le tableau en vert indique comment les composants de couleur sont stock√©s dans un r√©seau de surfaces unidimensionnel. Leurs indices dans le m√™me tableau sont indiqu√©s en bleu, et les coordonn√©es du pixel qui accepte les fonctions drawPixel, que nous devons convertir en indices dans le tableau unidimensionnel, indiquent r, g, b, a pour le pixel en bleu. Ainsi, √† partir du tableau, on peut voir que pour chaque pixel, la composante rouge de la couleur vient en premier, commen√ßons par elle. Supposons que nous voulons changer la composante rouge de la couleur des pixels dans les coordonn√©es X1Y1 avec une taille d'image de 2 par 2 pixels. Dans le tableau, nous voyons que c'est l'indice 12, mais comment le calculer? Nous trouvons d'abord l'indice de la ligne dont nous avons besoin, pour cela nous multiplions la largeur de l'image par Y et par 4 (le nombre de valeurs par pixel) - ce sera:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 <font></font>
//  :<font></font>
2 * 1 * 4 = 8</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
On voit que la 2√®me ligne commence par l'index 8. Si l'on compare avec la plaque, le r√©sultat converge. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous devez maintenant ajouter un d√©calage de colonne √† l'index de ligne trouv√© pour obtenir l'index rouge souhait√©. </font><font style="vertical-align: inherit;">Pour ce faire, ajoutez X fois 4 √† l'index de ligne. La formule compl√®te sera:</font></font><br>
<br>
<pre><code class="plaintext hljs">width * y * 4 + x * 4 <font></font>
//     :<font></font>
(width * y + x) * 4<font></font>
//  :<font></font>
(2 * 1 + 1) * 4 = 12</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, nous comparons 12 au tableau et voyons que le pixel X1Y1 commence vraiment par l'index 12. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Pour trouver les indices des autres composants de couleur, vous devez ajouter le d√©calage de couleur √† l'index rouge: +1 (vert), +2 (bleu), +3 (alpha) . </font><font style="vertical-align: inherit;">Nous pouvons maintenant impl√©menter la m√©thode drawPixel dans la classe Drawer en utilisant la formule ci-dessus:</font></font><br>
<br>
<pre><code class="javascript hljs">drawPixel(x, y, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset] = r
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cette m√©thode drawPixel, j'ai rendu la partie r√©p√©titive de la formule √† la constante de d√©calage. On voit aussi qu'en alpha j'√©cris juste 255, parce que c'est dans la structure, mais maintenant nous n'avons pas besoin de sortir des pixels. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il est temps de tester le code et de voir enfin le premier pixel √† l'√©cran. Voici un exemple utilisant la m√©thode de rendu pixel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-comment">//     Drawer</span>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
drawer.drawPixel(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
<font></font>
<span class="hljs-comment">//         canvas</span>
ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans l'exemple ci-dessus, je dessine 2 pixels, l'un rouge 255, 0, 0, l'autre bleu 0, 0, 255. Mais les changements dans le tableau imageData.data (c'est aussi la surface √† l'int√©rieur de la classe Drawer) n'appara√Ætront pas √† l'√©cran. Pour dessiner, vous devez appeler ctx.putImageData (imageData, 0, 0), o√π imageData est l'objet dans lequel le tableau de pixels et la largeur / hauteur de la zone de dessin, et 0, 0 est le point par rapport auquel le tableau de pixels sera affich√© (laissez toujours 0, 0 ) Si vous avez tout fait correctement, vous aurez l'image suivante en haut √† gauche de l'√©l√©ment canvas dans la fen√™tre du navigateur: Avez-vous vu les </font></font><br>
<br>
<img src="https://habrastorage.org/webt/d8/xn/cz/d8xnczchpgfg-9amhgdlyrpvzma.jpeg"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
pixels? Ils sont si petits et combien de travail a √©t√© fait.</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Essayons maintenant d'ajouter un peu de dynamique √† l'exemple, par exemple, de sorte que toutes les 10 millisecondes, notre pixel se d√©place vers la droite (nous changeons X pixels de +1 toutes les 10 millisecondes), nous corrigeons le code de dessin des pixels de un par intervalle:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans cet exemple, je n'ai laiss√© que la sortie du pixel bleu et j'ai encapsul√© la fonction setInterval avec le param√®tre 10 en JavaScript. Cela signifie que le code sera appel√© toutes les 10 millisecondes environ. Si vous ex√©cutez un tel exemple, vous verrez qu'au lieu d'un pixel se d√©pla√ßant vers la droite, vous aurez quelque chose comme ceci: </font></font><br>
<br>
<img src="https://habrastorage.org/webt/8o/0v/uu/8o0vuuurtmmqgu8uy7sufdka16o.png"><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Une telle longue bande (ou trace) reste parce que nous n'effa√ßons pas la couleur du pixel pr√©c√©dent dans le tableau de surface, donc √† chaque appel √† l'intervalle que nous ajoutons un pixel. √âcrivons une m√©thode qui nettoiera la surface √† son √©tat d'origine. En d'autres termes, remplissez le tableau de z√©ros. Ajoutez la m√©thode clearSurface √† la classe Drawer:</font></font><br>
<br>
<pre><code class="javascript hljs">clearSurface() {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Il n'y a aucune logique dans ce tableau, juste un remplissage avec des z√©ros. </font><font style="vertical-align: inherit;">Il est recommand√© d'appeler cette m√©thode √† chaque fois avant de dessiner une nouvelle image. </font><font style="vertical-align: inherit;">Dans le cas d'une animation pixel, avant de dessiner ce pixel:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>
setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.clearSurface()<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;drawer.drawPixel(x++, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<font></font>
}, <span class="hljs-number">10</span>)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Maintenant, si vous ex√©cutez cet exemple, le pixel se d√©placera vers la droite, un par un - sans trace inutile des coordonn√©es pr√©c√©dentes. </font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La derni√®re chose que nous impl√©mentons dans le premier article est la m√©thode de dessin au trait. </font><font style="vertical-align: inherit;">Ajoutez-le, bien s√ªr, √† la classe Drawer. </font><font style="vertical-align: inherit;">La m√©thode que j'appellerai drawLine. </font><font style="vertical-align: inherit;">Que prendra-t-il? </font><font style="vertical-align: inherit;">Contrairement √† un point, la ligne a toujours les coordonn√©es auxquelles elle se termine. </font><font style="vertical-align: inherit;">En d'autres termes, la ligne a un d√©but, une fin et une couleur, que nous passerons √† la m√©thode:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) { }</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toute ligne est constitu√©e de pixels, il ne reste plus qu'√† la remplir correctement avec des pixels de x1, y1 √† x2, y2. Pour commencer, puisque la ligne est constitu√©e de pixels, nous la sortirons pixel par pixel dans la boucle, mais comment calculer le nombre de pixels √† sortir? Par exemple, pour tracer une ligne de [0, 0] √† [3, 0], il est intuitivement clair que vous avez besoin de 4 pixels ([0, 0], [1, 0], [2, 0], [3, 0],) . Mais de [12, 6] √† [43, 14], on ne sait d√©j√† pas combien de temps la ligne sera (combien de pixels afficher) et quelles coordonn√©es elles auront. Pour ce faire, rappelons un peu de g√©om√©trie. Donc, nous avons une ligne qui commence √† x1, y1 et se termine √† x2, y2.</font></font><br>
<br>
<img src="https://habrastorage.org/webt/ou/z7/ip/ouz7ipd2uiokmmijlro7wldayzw.jpeg"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Tirons une ligne pointill√©e du d√©but et de la fin pour obtenir un triangle (image ci-dessus). </font><font style="vertical-align: inherit;">Nous verrons qu'√† la jonction des lignes trac√©es un angle de 90 degr√©s s'est form√©. </font><font style="vertical-align: inherit;">Si le triangle a un tel angle, alors le triangle est appel√© rectangulaire, et ses c√¥t√©s, entre lesquels l'angle est de 90 degr√©s, sont appel√©s jambes. </font><font style="vertical-align: inherit;">La troisi√®me ligne continue (que nous essayons de tracer) est appel√©e hypot√©nuse dans un triangle. </font><font style="vertical-align: inherit;">En utilisant ces deux jambes introduites (c1 et c2 sur la figure), nous pouvons calculer la longueur de l'hypot√©nuse en utilisant le th√©or√®me de Pythagore. </font><font style="vertical-align: inherit;">Voyons comment faire. </font><font style="vertical-align: inherit;">La formule de la longueur de l'hypot√©nuse (ou longueur de ligne) sera la suivante:&nbsp;</font></font><br>
<p></p><p><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><div class="MathJax_SVG_Display" style="text-align: center;"><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x433;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x438;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43F;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43E;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43D;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x443;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x437;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mo>=</mo><msqrt><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x43A;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x430;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x435;</mo></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x442;</mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="31.778ex" height="4.759ex" viewBox="0 -1401.3 13682.2 2049.1" role="img" focusable="false" style="vertical-align: -1.505ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(376,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1345,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1776,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2152,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(2535,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3019,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3450,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(3790,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-3D" x="4499" y="0"></use><g transform="translate(5555,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJSZ2-221A" x="0" y="87"></use><rect stroke="none" width="7126" height="60" x="1000" y="1178"></rect><g transform="translate(1000,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text><g transform="translate(430,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(861,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1237,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1620,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(1997,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-31" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-32" x="707" y="583"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-2B" x="3173" y="0"></use><g transform="translate(4174,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(4605,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5035,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5412,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(5795,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(53.819) matrix(1 0 0 -1 0 0)"></text></g><g transform="translate(6171,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-32" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=aue&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://habr.com/ru/post/494094/&amp;usg=ALkJrhh2glbT6PGNLyg0e65s839-7YCdTg#MJMAIN-32" x="707" y="583"></use></g></g></g></g></svg><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mo>=</mo><msqrt><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><mrow class="MJX-TeXAtom-ORD"><mo></mo></mrow><msup><mn>2</mn><mn>2</mn></msup></msqrt></math></span></span></div><script type="math/tex;mode=display" id="MathJax-Element-1"> = \sqrt{1^2 + 2^2}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Comment obtenir les deux jambes est √©galement vu du triangle. </font><font style="vertical-align: inherit;">Maintenant, en utilisant la formule ci-dessus, nous trouvons l'hypot√©nuse, qui sera la longue ligne (le nombre de pixels):</font></font><br>
<br>
<pre><code class="javascript hljs">&nbsp;drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Nous savons d√©j√† combien de pixels dessiner pour tracer une ligne. Mais nous ne savons pas encore comment les pixels sont d√©cal√©s. Autrement dit, nous devons tracer une ligne de x1, y1 √† x2, y2, nous savons que la longueur de la ligne sera, par exemple, de 20 pixels. On peut dessiner le 1er pixel en x1, y1 et le dernier en x2, y2, mais comment trouver les coordonn√©es des pixels interm√©diaires? Pour ce faire, nous devons savoir comment d√©caler chaque pixel suivant par rapport √† x1, y1 pour obtenir la ligne souhait√©e. Je donnerai un autre exemple afin de mieux comprendre de quel type de d√©placement nous parlons. Nous avons des points [0, 0] et [0, 3], nous devons tracer une ligne sur eux. L'exemple montre clairement que le point suivant apr√®s [0, 0] sera [0, 1], puis [0, 2] et enfin [0, 3]. Autrement dit, X de chaque point n'a pas √©t√© d√©cal√©, eh bien, ou nous pouvons dire qu'il a √©t√© d√©cal√© de 0 pixels, et Y a √©t√© d√©cal√© de 1 pixel, c'est le d√©calage,il peut √™tre √©crit comme [0, 1]. Un autre exemple: nous avons un point [0, 0] et un point [3, 6], essayons de calculer dans notre esprit comment ils se d√©placent, le premier sera [0, 0], puis [0.5, 1], puis [1, 2] puis [1.5, 3] et ainsi de suite jusqu'√† [3, 6], dans cet exemple le d√©calage sera [0.5, 1]. Comment le calculer?&nbsp;</font></font><br>
<br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Vous pouvez utiliser la formule suivante:</font></font><br>
<br>
<pre><code class="javascript hljs">   = <span class="hljs-number">2</span> /  <font></font>
  Y = <span class="hljs-number">1</span> /  &nbsp;</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le code du programme, nous aurons ceci:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">const</span> xStep = c2 / length
<span class="hljs-keyword">const</span> yStep = c1 / length</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Toutes les donn√©es sont d√©j√† l√†: la longueur de la ligne, le d√©calage des pixels le long de X et Y. On commence dans le cycle √† dessiner:</font></font><br>
<br>
<pre><code class="javascript hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
En tant que coordonn√©e X de la fonction Pixel, nous transf√©rons le d√©but de la ligne X + d√©calage X * i, obtenant ainsi la coordonn√©e du i-√®me pixel, nous calculons √©galement la coordonn√©e Y. Math.trunc est une m√©thode en JS qui vous permet d'√©liminer la partie fractionnaire d'un nombre. </font><font style="vertical-align: inherit;">Le code de la m√©thode enti√®re ressemble √† ceci:</font></font><br>
<br>
<pre><code class="javascript hljs">drawLine(x1, y1, x2, y2, r, g, b) {
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c1 = y2 - y1
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> xStep = c2 / length
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-keyword">this</span>.drawPixel(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r, g, b,<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<font></font>
&nbsp;&nbsp;&nbsp;&nbsp;}<font></font>
}</code></pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
La premi√®re partie est arriv√©e √† son terme, un chemin long mais passionnant pour comprendre le monde 3D. </font><font style="vertical-align: inherit;">Il n'y avait encore rien de tridimensionnel, mais nous avons effectu√© des op√©rations pr√©paratoires pour le dessin: nous avons mis en ≈ìuvre les fonctions de dessin d'un pixel, d'une ligne, de nettoyage d'une fen√™tre et appris quelques termes. </font><font style="vertical-align: inherit;">Tout le code de la classe Drawer peut √™tre consult√© sous le spoiler:</font></font><br>
<br>
<div class="spoiler"><b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Code de classe de tiroir</font></font></b><div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Drawer</span> </span>{<font></font>
  surface = <span class="hljs-literal">null</span>
  width = <span class="hljs-number">0</span>
  height = <span class="hljs-number">0</span><font></font>
<font></font>
  <span class="hljs-keyword">constructor</span>(surface, width, height) {
    <span class="hljs-keyword">this</span>.surface = surface
    <span class="hljs-keyword">this</span>.width = width
    <span class="hljs-keyword">this</span>.height = height<font></font>
  }<font></font>
<font></font>
  drawPixel(x, y, r, g, b)  {<font></font>
    <span class="hljs-keyword">const</span> offset = (<span class="hljs-keyword">this</span>.width * y + x) * <span class="hljs-number">4</span><font></font>
<font></font>
    <span class="hljs-keyword">this</span>.surface[offset] = r
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">1</span>] = g
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">2</span>] = b
    <span class="hljs-keyword">this</span>.surface[offset + <span class="hljs-number">3</span>] = <span class="hljs-number">255</span><font></font>
  }<font></font>
<font></font>
  drawLine(x1, y1, x2, y2, r, g, b) {<font></font>
    <span class="hljs-keyword">const</span> c1 = y2 - y1
    <span class="hljs-keyword">const</span> c2 = x2 - x1<font></font>
<font></font>
    <span class="hljs-keyword">const</span> length = <span class="hljs-built_in">Math</span>.sqrt(c1 * c1 + c2 * c2)<font></font>
<font></font>
    <span class="hljs-keyword">const</span> xStep = c2 / length
    <span class="hljs-keyword">const</span> yStep = c1 / length<font></font>
<font></font>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; length ; i++) {
        <span class="hljs-keyword">this</span>.drawPixel(
          <span class="hljs-built_in">Math</span>.trunc(x1 + xStep * i),
          <span class="hljs-built_in">Math</span>.trunc(y1 + yStep * i),<font></font>
          r, g, b,<font></font>
        )<font></font>
    }<font></font>
  }<font></font>
<font></font>
  clearSurface() {<font></font>
    <span class="hljs-keyword">const</span> surfaceSize = <span class="hljs-keyword">this</span>.width * <span class="hljs-keyword">this</span>.height * <span class="hljs-number">4</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; surfaceSize; i++) {
      <span class="hljs-keyword">this</span>.surface[i] = <span class="hljs-number">0</span><font></font>
    }<font></font>
  }<font></font>
}<font></font>
</code></pre></div></div><br>
<h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Et apr√®s?</font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">
Dans le prochain article, nous verrons comment une op√©ration aussi simple que la sortie d'un pixel et d'une ligne peut se transformer en objets 3D int√©ressants. </font><font style="vertical-align: inherit;">Nous allons nous familiariser avec les matrices et leurs op√©rations, afficher un objet tridimensionnel dans une fen√™tre et m√™me ajouter une animation.</font></font></div>
      
    </div>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr494076/index.html">Analyse: strat√©gies de comportement des investisseurs lors des krachs boursiers</a></li>
<li><a href="../fr494082/index.html">Dalenka: les articles les plus utiles sur le travail efficace √† domicile</a></li>
<li><a href="../fr494084/index.html">Coronavirus: services d'information en ligne</a></li>
<li><a href="../fr494090/index.html">Limitation du c√©leri - d√©finition de la limite de d√©bit pour les files d'attente</a></li>
<li><a href="../fr494092/index.html">D√©gradation de la structure connect√©e</a></li>
<li><a href="../fr494096/index.html">D√©ploiement intranet. Exp√©rience, erreurs, recommandations</a></li>
<li><a href="../fr494098/index.html">Approche imp√©rative des donn√©es r√©actives sur l'exemple de Jetbrains KTor et R2DBC</a></li>
<li><a href="../fr494100/index.html">Ce dont vous avez besoin pour cr√©er le mod√®le id√©al d'un centre √©ducatif pour former des informaticiens</a></li>
<li><a href="../fr494114/index.html">Comment r√©duire le nombre et augmenter la lisibilit√© du code dans react-redux, redux-saga</a></li>
<li><a href="../fr494118/index.html">COVID-19 Telegram-bot // Nous r√©pondons automatiquement aux questions fr√©quemment pos√©es</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter63335242 = new Ya.Metrika({
                  id:63335242,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/63335242" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-13', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Geek Week | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2020</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=i62cJ2037o_BACd40gCrIso3niu0Sjx2sDFYJkeYdRk&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>